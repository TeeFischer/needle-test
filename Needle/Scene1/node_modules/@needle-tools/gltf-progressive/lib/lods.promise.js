import { debug } from "./lods.debug.js";
/**
 * A group of promises that can be awaited together.
 * This is used for awaiting LOD
 */
export class PromiseGroup {
    static addPromise = (type, object, promise, groups) => {
        groups.forEach(group => {
            group.add(type, object, promise);
        });
    };
    ready;
    /** The number of promises that have been added to this group so far */
    get awaitedCount() {
        return this._addedCount;
    }
    /** The number of promises that have been resolved */
    get resolvedCount() {
        return this._resolvedCount;
    }
    /** The number of promises that are in-flight */
    get currentlyAwaiting() {
        return this._awaiting.length;
    }
    _resolve;
    _signal;
    /** start frame can be undefined if the user configured this group to wait for the first promise.
     * Then the start frame will be set when the first promise has been added to the group */
    _frame_start;
    /** How many frames to capture since the start frame */
    _frames_to_capture;
    _resolved = false;
    _addedCount = 0;
    _resolvedCount = 0;
    /** These promises are currently being awaited */
    _awaiting = [];
    _maxPromisesPerObject = 1;
    constructor(frame, options) {
        const minFrames = 2; // wait at least 2 frames to capture promises
        const framesToCapture = Math.max(options.frames ?? minFrames, minFrames); // default to 2 frames and make sure it's at least 2 frames
        this._frame_start = options.waitForFirstCapture ? undefined : frame;
        this._frames_to_capture = framesToCapture;
        this.ready = new Promise((resolve) => {
            this._resolve = resolve;
        });
        this.ready.finally(() => {
            this._resolved = true;
            this._awaiting.length = 0;
        });
        this._signal = options.signal;
        this._signal?.addEventListener("abort", () => {
            this.resolveNow();
        });
        this._maxPromisesPerObject = Math.max(1, options.maxPromisesPerObject ?? 1);
    }
    _currentFrame = 0;
    update(frame) {
        this._currentFrame = frame;
        // Check if start frame is not defined yet but we have added objects since the last update
        if (this._frame_start === undefined && this._addedCount > 0) {
            this._frame_start = frame;
        }
        // If we've passes the frame capture end frame and didn't add any promises, we resolve immediately
        if (this._signal?.aborted || (this._awaiting.length === 0 && (this._frame_start !== undefined && (frame > this._frame_start + this._frames_to_capture)))) {
            this.resolveNow();
        }
    }
    _seen = new WeakMap();
    add(_type, object, promise) {
        if (this._resolved) {
            if (debug)
                console.warn("PromiseGroup: Trying to add a promise to a resolved group, ignoring.");
            return;
        }
        if (this._frame_start !== undefined && this._currentFrame > this._frame_start + this._frames_to_capture) {
            return; // we are not capturing any more promises
        }
        if (this._maxPromisesPerObject >= 1) {
            if (this._seen.has(object)) {
                let count = this._seen.get(object);
                if (count >= this._maxPromisesPerObject) {
                    if (debug)
                        console.warn(`PromiseGroup: Already awaiting object ignoring new promise for it.`);
                    return;
                }
                this._seen.set(object, count + 1);
            }
            else {
                this._seen.set(object, 1);
            }
        }
        this._awaiting.push(promise);
        this._addedCount++;
        promise.finally(() => {
            this._resolvedCount++;
            this._awaiting.splice(this._awaiting.indexOf(promise), 1);
        });
    }
    resolveNow() {
        if (this._resolved)
            return;
        this._resolve?.({
            awaited_count: this._addedCount,
            resolved_count: this._resolvedCount,
            cancelled: this._signal?.aborted ?? false,
        });
    }
}
