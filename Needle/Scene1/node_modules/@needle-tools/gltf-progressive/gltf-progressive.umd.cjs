"use strict";var Fe=Object.create;var Le=Object.defineProperty;var Ue=Object.getOwnPropertyDescriptor;var We=Object.getOwnPropertyNames;var Ee=Object.getPrototypeOf,Ne=Object.prototype.hasOwnProperty;var ze=(o,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of We(t))!Ne.call(o,n)&&n!==e&&Le(o,n,{get:()=>t[n],enumerable:!(r=Ue(t,n))||r.enumerable});return o};var Ve=(o,t,e)=>(e=o!=null?Fe(Ee(o)):{},ze(t||!o||!o.__esModule?Le(e,"default",{value:o,enumerable:!0}):e,o));Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const d=require("three"),pe=require("three/examples/jsm/loaders/GLTFLoader.js"),qe=require("three/examples/jsm/libs/meshopt_decoder.module.js"),je=require("three/examples/jsm/loaders/DRACOLoader.js"),Xe=require("three/examples/jsm/loaders/KTX2Loader.js");var oe=typeof document<"u"?document.currentScript:null;const De="";globalThis.GLTF_PROGRESSIVE_VERSION=De;console.debug("[gltf-progressive] version -");let k="https://www.gstatic.com/draco/versioned/decoders/1.5.7/",z="https://cdn.needle.tools/static/three/0.179.1/basis2/";const Ke=k,Ye=z,Oe=new URL(k+"draco_decoder.js");Oe.searchParams.append("range","true");fetch(Oe,{method:"GET",headers:{Range:"bytes=0-1"}}).catch(o=>{console.debug(`Failed to fetch remote Draco decoder from ${k} (offline: ${typeof navigator<"u"?navigator.onLine:"unknown"})`),k===Ke&&Se("./include/draco/"),z===Ye&&Te("./include/ktx2/")}).finally(()=>{Pe()});const He=()=>({dracoDecoderPath:k,ktx2TranscoderPath:z});function Se(o){k=o,A&&A[fe]!=k?(console.debug("Updating Draco decoder path to "+o),A[fe]=k,A.setDecoderPath(k),A.preload()):console.debug("Setting Draco decoder path to "+o)}function Te(o){z=o,R&&R.transcoderPath!=z?(console.debug("Updating KTX2 transcoder path to "+o),R.setTranscoderPath(z),R.init()):console.debug("Setting KTX2 transcoder path to "+o)}function re(o){return Pe(),o?R.detectSupport(o):o!==null&&console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail"),{dracoLoader:A,ktx2Loader:R,meshoptDecoder:te}}function me(o){o.dracoLoader||o.setDRACOLoader(A),o.ktx2Loader||o.setKTX2Loader(R),o.meshoptDecoder||o.setMeshoptDecoder(te)}const fe=Symbol("dracoDecoderPath");let A,te,R;function Pe(){A||(A=new je.DRACOLoader,A[fe]=k,A.setDecoderPath(k),A.setDecoderConfig({type:"js"}),A.preload()),R||(R=new Xe.KTX2Loader,R.setTranscoderPath(z),R.init()),te||(te=qe.MeshoptDecoder)}const he=new WeakMap;function ye(o,t){let e=he.get(o);e?e=Object.assign(e,t):e=t,he.set(o,e)}const Qe=pe.GLTFLoader.prototype.load;function Je(...o){const t=he.get(this);let e=o[0];const r=new URL(e,window.location.href);if(r.hostname.endsWith("needle.tools")){const s=t?.progressive!==void 0?t.progressive:!0,i=t?.usecase?t.usecase:"default";s?this.requestHeader.Accept=`*/*;progressive=allowed;usecase=${i}`:this.requestHeader.Accept=`*/*;usecase=${i}`,e=r.toString()}return o[0]=e,Qe?.call(this,...o)}pe.GLTFLoader.prototype.load=Je;V("debugprogressive");function V(o){if(typeof window>"u")return!1;const e=new URL(window.location.href).searchParams.get(o);return e==null||e==="0"||e==="false"?!1:e===""?!0:e}function Ze(o,t){if(t===void 0||o===void 0||t.startsWith("./")||t.startsWith("http")||t.startsWith("data:")||t.startsWith("blob:"))return t;const e=o.lastIndexOf("/");if(e>=0){const r=o.substring(0,e+1);for(;r.endsWith("/")&&t.startsWith("/");)t=t.substring(1);return r+t}return t}function Ae(){return X!==void 0||(X=/iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent),V("debugprogressive")&&console.log("[glTF Progressive]: isMobileDevice",X)),X}let X;function _e(){if(typeof window>"u")return!1;const o=new URL(window.location.href),t=o.hostname==="localhost"||/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(o.hostname);return o.hostname==="127.0.0.1"||t}class et{constructor(t=100,e={}){this.maxConcurrent=t,this.debug=e.debug??!1,window.requestAnimationFrame(this.tick)}_running=new Map;_queue=[];debug=!1;tick=()=>{this.internalUpdate(),setTimeout(this.tick,10)};slot(t){return this.debug&&console.debug(`[PromiseQueue]: Requesting slot for key ${t}, running: ${this._running.size}, waiting: ${this._queue.length}`),new Promise(e=>{this._queue.push({key:t,resolve:e})})}add(t,e){this._running.has(t)||(this._running.set(t,e),e.finally(()=>{this._running.delete(t),this.debug&&console.debug(`[PromiseQueue]: Promise finished now running: ${this._running.size}, waiting: ${this._queue.length}. (finished ${t})`)}),this.debug&&console.debug(`[PromiseQueue]: Added new promise, now running: ${this._running.size}, waiting: ${this._queue.length}. (added ${t})`))}internalUpdate(){const t=this.maxConcurrent-this._running.size;for(let e=0;e<t&&this._queue.length>0;e++){this.debug&&console.debug(`[PromiseQueue]: Running ${this._running.size} promises, waiting for ${this._queue.length} more.`);const{key:r,resolve:n}=this._queue.shift();n({use:s=>this.add(r,s)})}}}const tt=typeof window>"u"&&typeof document>"u",ge=Symbol("needle:raycast-mesh");function q(o){return o?.[ge]instanceof d.BufferGeometry?o[ge]:null}function Ie(o,t){if((o.type==="Mesh"||o.type==="SkinnedMesh")&&!q(o)){const r=rt(t);r.userData={isRaycastMesh:!0},o[ge]=r}}function Ce(o=!0){if(o){if(K)return;const t=K=d.Mesh.prototype.raycast;d.Mesh.prototype.raycast=function(e,r){const n=this,s=q(n);let i;s&&n.isMesh&&(i=n.geometry,n.geometry=s),t.call(this,e,r),i&&(n.geometry=i)}}else{if(!K)return;d.Mesh.prototype.raycast=K,K=null}}let K=null;function rt(o){const t=new d.BufferGeometry;for(const e in o.attributes)t.setAttribute(e,o.getAttribute(e));return t.setIndex(o.getIndex()),t}const W=new Array,p=V("debugprogressive");let H,N=-1;if(p){let o=function(){N+=1,N>=t&&(N=-1),console.log(`Toggle LOD level [${N}]`)},t=6;window.addEventListener("keyup",e=>{e.key==="p"&&o(),e.key==="w"&&(H=!H,console.log(`Toggle wireframe [${H}]`));const r=parseInt(e.key);!isNaN(r)&&r>=0&&(N=r,console.log(`Set LOD level to [${N}]`))})}function ke(o){if(p&&H!==void 0)if(Array.isArray(o))for(const t of o)ke(t);else o&&"wireframe"in o&&(o.wireframe=H===!0)}const Y=new Array;let st=0;const nt=Ae()?2:10;function ot(o){if(Y.length<nt){const r=Y.length;p&&console.warn(`[Worker] Creating new worker #${r}`);const n=xe.createWorker(o||{});return Y.push(n),n}const t=st++%Y.length;return Y[t]}class xe{constructor(t,e){this.worker=t,this._debug=e.debug??!1,t.onmessage=r=>{const n=r.data;switch(this._debug&&console.log("[Worker] EVENT",n),n.type){case"loaded-gltf":for(const s of this._running)if(s.url===n.result.url){it(n.result),s.resolve(n.result);const i=s.url;i.startsWith("blob:")&&URL.revokeObjectURL(i)}}},t.onerror=r=>{console.error("[Worker] Error in gltf-progressive worker:",r)},t.postMessage({type:"init"})}static async createWorker(t){const e=new Worker(new URL("/assets/loader.worker-CwaLRBn2.js",typeof document>"u"?require("url").pathToFileURL(__filename).href:oe&&oe.tagName.toUpperCase()==="SCRIPT"&&oe.src||new URL("gltf-progressive.umd.cjs",document.baseURI).href),{type:"module"});return new xe(e,t)}_running=[];_webglRenderer=null;async load(t,e){const r=He();let n=e?.renderer;n||(this._webglRenderer??=(async()=>{const{WebGLRenderer:u}=await import("three");return new u})(),n=await this._webglRenderer);const l=re(n).ktx2Loader.workerConfig;t instanceof URL?t=t.toString():t.startsWith("file:")?t=URL.createObjectURL(new Blob([t])):!t.startsWith("blob:")&&!t.startsWith("http:")&&!t.startsWith("https:")&&(t=new URL(t,window.location.href).toString());const a={type:"load",url:t,dracoDecoderPath:r.dracoDecoderPath,ktx2TranscoderPath:r.ktx2TranscoderPath,ktx2LoaderConfig:l};return this._debug&&console.debug("[Worker] Sending load request",a),this.worker.postMessage(a),new Promise(u=>{this._running.push({url:t.toString(),resolve:u})})}_debug=!1}function it(o){for(const t of o.geometries){const e=t.geometry,r=new d.BufferGeometry;if(r.name=e.name||"",e.index){const n=e.index;r.setIndex(ie(n))}for(const n in e.attributes){const s=e.attributes[n],i=ie(s);r.setAttribute(n,i)}if(e.morphAttributes)for(const n in e.morphAttributes){const i=e.morphAttributes[n].map(l=>ie(l));r.morphAttributes[n]=i}if(r.morphTargetsRelative=e.morphTargetsRelative??!1,r.boundingBox=new d.Box3,r.boundingBox.min=new d.Vector3(e.boundingBox?.min.x,e.boundingBox?.min.y,e.boundingBox?.min.z),r.boundingBox.max=new d.Vector3(e.boundingBox?.max.x,e.boundingBox?.max.y,e.boundingBox?.max.z),r.boundingSphere=new d.Sphere(new d.Vector3(e.boundingSphere?.center.x,e.boundingSphere?.center.y,e.boundingSphere?.center.z),e.boundingSphere?.radius),e.groups)for(const n of e.groups)r.addGroup(n.start,n.count,n.materialIndex);e.userData&&(r.userData=e.userData),t.geometry=r}for(const t of o.textures){const e=t.texture;let r=null;if(e.isCompressedTexture){const n=e.mipmaps,s=e.image?.width||e.source?.data?.width||-1,i=e.image?.height||e.source?.data?.height||-1;r=new d.CompressedTexture(n,s,i,e.format,e.type,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.anisotropy,e.colorSpace)}else r=new d.Texture(e.image,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),r.mipmaps=e.mipmaps,r.channel=e.channel,r.source.data=e.source.data,r.flipY=e.flipY,r.premultiplyAlpha=e.premultiplyAlpha,r.unpackAlignment=e.unpackAlignment,r.matrix=new d.Matrix3(...e.matrix.elements);if(!r){console.error("[Worker] Failed to create new texture from received data. Texture is not a CompressedTexture or Texture.");continue}t.texture=r}return o}function ie(o){let t=o;if("isInterleavedBufferAttribute"in o&&o.isInterleavedBufferAttribute){const e=o.data,r=e.array,n=new d.InterleavedBuffer(r,e.stride);t=new d.InterleavedBufferAttribute(n,o.itemSize,r.byteOffset,o.normalized),t.offset=o.offset}else"isBufferAttribute"in o&&o.isBufferAttribute&&(t=new d.BufferAttribute(o.array,o.itemSize,o.normalized),t.usage=o.usage,t.gpuType=o.gpuType,t.updateRanges=o.updateRanges);return t}const at=V("gltf-progressive-worker"),lt=V("gltf-progressive-reduce-mipmaps"),ae=Symbol("needle-progressive-texture"),G="NEEDLE_progressive";class m{get name(){return G}static getMeshLODExtension(t){const e=this.getAssignedLODInformation(t);return e?.key?this.lodInfos.get(e.key):null}static getPrimitiveIndex(t){const e=this.getAssignedLODInformation(t)?.index;return e??-1}static getMaterialMinMaxLODsCount(t,e){const r=this,n="LODS:minmax",s=t[n];if(s!=null)return s;if(e||(e={min_count:1/0,max_count:0,lods:[]}),Array.isArray(t)){for(const l of t)this.getMaterialMinMaxLODsCount(l,e);return t[n]=e,e}if(p==="verbose"&&console.log("getMaterialMinMaxLODsCount",t),t.type==="ShaderMaterial"||t.type==="RawShaderMaterial"){const l=t;for(const a of Object.keys(l.uniforms)){const u=l.uniforms[a].value;u?.isTexture===!0&&i(u,e)}}else if(t.isMaterial)for(const l of Object.keys(t)){const a=t[l];a?.isTexture===!0&&i(a,e)}else p&&console.warn(`[getMaterialMinMaxLODsCount] Unsupported material type: ${t.type}`);return t[n]=e,e;function i(l,a){const u=r.getAssignedLODInformation(l);if(u){const f=r.lodInfos.get(u.key);if(f&&f.lods){a.min_count=Math.min(a.min_count,f.lods.length),a.max_count=Math.max(a.max_count,f.lods.length);for(let y=0;y<f.lods.length;y++){const v=f.lods[y];v.width&&(a.lods[y]=a.lods[y]||{min_height:1/0,max_height:0},a.lods[y].min_height=Math.min(a.lods[y].min_height,v.height),a.lods[y].max_height=Math.max(a.lods[y].max_height,v.height))}}}}}static hasLODLevelAvailable(t,e){if(Array.isArray(t)){for(const s of t)if(this.hasLODLevelAvailable(s,e))return!0;return!1}if(t.isMaterial===!0){for(const s of Object.keys(t)){const i=t[s];if(i&&i.isTexture&&this.hasLODLevelAvailable(i,e))return!0}return!1}else if(t.isGroup===!0){for(const s of t.children)if(s.isMesh===!0&&this.hasLODLevelAvailable(s,e))return!0}let r,n;if(t.isMesh?r=t.geometry:(t.isBufferGeometry||t.isTexture)&&(r=t),r&&r?.userData?.LODS){const s=r.userData.LODS;if(n=this.lodInfos.get(s.key),e===void 0)return n!=null;if(n)return Array.isArray(n.lods)?e<n.lods.length:e===0}return!1}static assignMeshLOD(t,e){if(!t)return Promise.resolve(null);if(t instanceof d.Mesh||t.isMesh===!0){const r=t.geometry,n=this.getAssignedLODInformation(r);if(!n)return Promise.resolve(null);for(const s of W)s.onBeforeGetLODMesh?.(t,e);return t["LOD:requested level"]=e,m.getOrLoadLOD(r,e).then(s=>{if(Array.isArray(s)){const i=n.index||0;s=s[i]}return t["LOD:requested level"]===e&&(delete t["LOD:requested level"],s&&r!=s&&(s?.isBufferGeometry?t.geometry=s:p&&console.error("Invalid LOD geometry",s))),s}).catch(s=>(console.error("Error loading mesh LOD",t,s),null))}else p&&console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh",t);return Promise.resolve(null)}static assignTextureLOD(t,e=0){if(!t)return Promise.resolve(null);if(t.isMesh===!0){const r=t;if(Array.isArray(r.material)){const n=new Array;for(const s of r.material){const i=this.assignTextureLOD(s,e);n.push(i)}return Promise.all(n).then(s=>{const i=new Array;for(const l of s)Array.isArray(l)&&i.push(...l);return i})}else return this.assignTextureLOD(r.material,e)}if(t.isMaterial===!0){const r=t,n=[],s=new Array;if(r.uniforms&&(r.isRawShaderMaterial||r.isShaderMaterial===!0)){const i=r;for(const l of Object.keys(i.uniforms)){const a=i.uniforms[l].value;if(a?.isTexture===!0){const u=this.assignTextureLODForSlot(a,e,r,l).then(f=>(f&&i.uniforms[l].value!=f&&(i.uniforms[l].value=f,i.uniformsNeedUpdate=!0),f));n.push(u),s.push(l)}}}else for(const i of Object.keys(r)){const l=r[i];if(l?.isTexture===!0){const a=this.assignTextureLODForSlot(l,e,r,i);n.push(a),s.push(i)}}return Promise.all(n).then(i=>{const l=new Array;for(let a=0;a<i.length;a++){const u=i[a],f=s[a];u&&u.isTexture===!0?l.push({material:r,slot:f,texture:u,level:e}):l.push({material:r,slot:f,texture:null,level:e})}return l})}if(t instanceof d.Texture||t.isTexture===!0){const r=t;return this.assignTextureLODForSlot(r,e,null,null)}return Promise.resolve(null)}static assignTextureLODForSlot(t,e,r,n){return t?.isTexture!==!0?Promise.resolve(null):n==="glyphMap"?Promise.resolve(t):m.getOrLoadLOD(t,e).then(s=>{if(Array.isArray(s))return console.warn("Progressive: Got an array of textures for a texture slot, this should not happen..."),null;if(s?.isTexture===!0){if(s!=t&&r&&n){const i=r[n];if(i&&!p){const l=this.getAssignedLODInformation(i);if(l&&l?.level<e)return p==="verbose"&&console.warn("Assigned texture level is already higher: ",l.level,e,r,i,s),null}if(lt&&s.mipmaps){const l=s.mipmaps.length;s.mipmaps.length=Math.min(s.mipmaps.length,3),l!==s.mipmaps.length&&p&&console.debug(`Reduced mipmap count from ${l} to ${s.mipmaps.length} for ${s.uuid}: ${s.image?.width}x${s.image?.height}.`)}r[n]=s}return s}else p=="verbose"&&console.warn("No LOD found for",t,e);return null}).catch(s=>(console.error("Error loading LOD",t,s),null))}parser;url;constructor(t){const e=t.options.path;p&&console.log("Progressive extension registered for",e),this.parser=t,this.url=e}_isLoadingMesh;loadMesh=t=>{if(this._isLoadingMesh)return null;const e=this.parser.json.meshes[t]?.extensions?.[G];return e?(this._isLoadingMesh=!0,this.parser.getDependency("mesh",t).then(r=>(this._isLoadingMesh=!1,r&&m.registerMesh(this.url,e.guid,r,e.lods?.length,0,e),r))):null};afterRoot(t){return p&&console.log("AFTER",this.url,t),this.parser.json.textures?.forEach((e,r)=>{if(e?.extensions){const n=e?.extensions[G];if(n){if(!n.lods){p&&console.warn("Texture has no LODs",n);return}let s=!1;for(const i of this.parser.associations.keys())i.isTexture===!0&&this.parser.associations.get(i)?.textures===r&&(s=!0,m.registerTexture(this.url,i,n.lods?.length,r,n));s||this.parser.getDependency("texture",r).then(i=>{i&&m.registerTexture(this.url,i,n.lods?.length,r,n)})}}}),this.parser.json.meshes?.forEach((e,r)=>{if(e?.extensions){const n=e?.extensions[G];if(n&&n.lods){for(const s of this.parser.associations.keys())if(s.isMesh){const i=this.parser.associations.get(s);i?.meshes===r&&m.registerMesh(this.url,n.guid,s,n.lods.length,i.primitives,n)}}}}),null}static registerTexture=(t,e,r,n,s)=>{if(!e){p&&console.error("!! gltf-progressive: Called register texture without texture");return}if(p){const l=e.image?.width||e.source?.data?.width||0,a=e.image?.height||e.source?.data?.height||0;console.log(`> gltf-progressive: register texture[${n}] "${e.name||e.uuid}", Current: ${l}x${a}, Max: ${s.lods[0]?.width}x${s.lods[0]?.height}, uuid: ${e.uuid}`,s,e)}e.source&&(e.source[ae]=s);const i=s.guid;m.assignLODInformation(t,e,i,r,n),m.lodInfos.set(i,s),m.lowresCache.set(i,e)};static registerMesh=(t,e,r,n,s,i)=>{const l=r.geometry;if(!l){p&&console.warn("gltf-progressive: Register mesh without geometry");return}l.userData||(l.userData={}),p&&console.log("> Progressive: register mesh "+r.name,{index:s,uuid:r.uuid},i,r),m.assignLODInformation(t,l,e,n,s),m.lodInfos.set(e,i);let a=m.lowresCache.get(e);a?a.push(r.geometry):a=[r.geometry],m.lowresCache.set(e,a),n>0&&!q(r)&&Ie(r,l);for(const u of W)u.onRegisteredNewMesh?.(r,i)};static lodInfos=new Map;static previouslyLoaded=new Map;static lowresCache=new Map;static workers=[];static _workersIndex=0;static async getOrLoadLOD(t,e){const r=p=="verbose",n=this.getAssignedLODInformation(t);if(!n)return p&&console.warn(`[gltf-progressive] No LOD information found: ${t.name}, uuid: ${t.uuid}, type: ${t.type}`,t),null;const s=n?.key;let i;if(t.isTexture===!0){const a=t;a.source&&a.source[ae]&&(i=a.source[ae])}if(i||(i=m.lodInfos.get(s)),!i)p&&console.warn(`Can not load LOD ${e}: no LOD info found for "${s}" ${t.name}`,t.type,m.lodInfos);else{if(e>0){let f=!1;const y=Array.isArray(i.lods);if(y&&e>=i.lods.length?f=!0:y||(f=!0),f)return this.lowresCache.get(s)}const a=Array.isArray(i.lods)?i.lods[e]?.path:i.lods;if(!a)return p&&!i["missing:uri"]&&(i["missing:uri"]=!0,console.warn("Missing uri for progressive asset for LOD "+e,i)),null;const u=Ze(n.url,a);if(u.endsWith(".glb")||u.endsWith(".gltf")){if(!i.guid)return console.warn("missing pointer for glb/gltf texture",i),null;const f=u+"_"+i.guid,y=await this.queue.slot(u),v=this.previouslyLoaded.get(f);if(v!==void 0){r&&console.log(`LOD ${e} was already loading/loaded: ${f}`);let c=await v.catch(S=>(console.error(`Error loading LOD ${e} from ${u}
`,S),null)),w=!1;if(c==null||(c instanceof d.Texture&&t instanceof d.Texture?c.image?.data||c.source?.data?c=this.copySettings(t,c):(w=!0,this.previouslyLoaded.delete(f)):c instanceof d.BufferGeometry&&t instanceof d.BufferGeometry&&(c.attributes.position?.array||(w=!0,this.previouslyLoaded.delete(f)))),!w)return c}if(!y.use)return p&&console.log(`LOD ${e} was aborted: ${u}`),null;const M=i,I=new Promise(async(c,w)=>{if(at){const x=await(await ot({})).load(u);if(x.textures.length>0)for(const h of x.textures){let g=h.texture;return m.assignLODInformation(n.url,g,s,e,void 0),t instanceof d.Texture&&(g=this.copySettings(t,g)),g&&(g.guid=M.guid),c(g)}if(x.geometries.length>0){const h=new Array;for(const g of x.geometries){const D=g.geometry;m.assignLODInformation(n.url,D,s,e,g.primitiveIndex),h.push(D)}return c(h)}return c(null)}const S=new pe.GLTFLoader;me(S),p&&(await new Promise(L=>setTimeout(L,1e3)),r&&console.warn("Start loading (delayed) "+u,M.guid));let B=u;if(M&&Array.isArray(M.lods)){const L=M.lods[e];L.hash&&(B+="?v="+L.hash)}const b=await S.loadAsync(B).catch(L=>(console.error(`Error loading LOD ${e} from ${u}
`,L),c(null)));if(!b)return c(null);const E=b.parser;r&&console.log("Loading finished "+u,M.guid);let T=0;if(b.parser.json.textures){let L=!1;for(const x of b.parser.json.textures){if(x?.extensions){const h=x?.extensions[G];if(h?.guid&&h.guid===M.guid){L=!0;break}}T++}if(L){let x=await E.getDependency("texture",T);return x&&m.assignLODInformation(n.url,x,s,e,void 0),r&&console.log('change "'+t.name+'" → "'+x.name+'"',u,T,x,f),t instanceof d.Texture&&(x=this.copySettings(t,x)),x&&(x.guid=M.guid),c(x)}else p&&console.warn("Could not find texture with guid",M.guid,b.parser.json)}if(T=0,b.parser.json.meshes){let L=!1;for(const x of b.parser.json.meshes){if(x?.extensions){const h=x?.extensions[G];if(h?.guid&&h.guid===M.guid){L=!0;break}}T++}if(L){const x=await E.getDependency("mesh",T);if(r&&console.log(`Loaded Mesh "${x.name}"`,u,T,x,f),x.isMesh===!0){const h=x.geometry;return m.assignLODInformation(n.url,h,s,e,0),c(h)}else{const h=new Array;for(let g=0;g<x.children.length;g++){const D=x.children[g];if(D.isMesh===!0){const O=D.geometry;m.assignLODInformation(n.url,O,s,e,g),h.push(O)}}return c(h)}}else p&&console.warn("Could not find mesh with guid",M.guid,b.parser.json)}return c(null)});return this.previouslyLoaded.set(f,I),y.use(I),await I}else if(t instanceof d.Texture){r&&console.log("Load texture from uri: "+u);const y=await new d.TextureLoader().loadAsync(u);return y?(y.guid=i.guid,y.flipY=!1,y.needsUpdate=!0,y.colorSpace=t.colorSpace,r&&console.log(i,y)):p&&console.warn("failed loading",u),y}}return null}static maxConcurrent=50;static queue=new et(m.maxConcurrent,{debug:p!=!1});static assignLODInformation(t,e,r,n,s){if(!e)return;e.userData||(e.userData={});const i=new ut(t,r,n,s);e.userData.LODS=i,"source"in e&&typeof e.source=="object"&&(e.source.LODS=i)}static getAssignedLODInformation(t){return t?t.userData?.LODS?t.userData.LODS:"source"in t&&t.source?.LODS?t.source.LODS:null:null}static copySettings(t,e){return e?(p==="verbose"&&console.debug(`Copy texture settings
`,t.uuid,`
`,e.uuid),e=e.clone(),e.offset=t.offset,e.repeat=t.repeat,e.colorSpace=t.colorSpace,e.magFilter=t.magFilter,e.minFilter=t.minFilter,e.wrapS=t.wrapS,e.wrapT=t.wrapT,e.flipY=t.flipY,e.anisotropy=t.anisotropy,e.mipmaps||(e.generateMipmaps=t.generateMipmaps),e):t}}class ut{url;key;level;index;constructor(t,e,r,n){this.url=t,this.key=e,this.level=r,n!=null&&(this.index=n)}}class le{static addPromise=(t,e,r,n)=>{n.forEach(s=>{s.add(t,e,r)})};ready;get awaitedCount(){return this._addedCount}get resolvedCount(){return this._resolvedCount}get currentlyAwaiting(){return this._awaiting.length}_resolve;_signal;_frame_start;_frames_to_capture;_resolved=!1;_addedCount=0;_resolvedCount=0;_awaiting=[];_maxPromisesPerObject=1;constructor(t,e){const n=Math.max(e.frames??2,2);this._frame_start=e.waitForFirstCapture?void 0:t,this._frames_to_capture=n,this.ready=new Promise(s=>{this._resolve=s}),this.ready.finally(()=>{this._resolved=!0,this._awaiting.length=0}),this._signal=e.signal,this._signal?.addEventListener("abort",()=>{this.resolveNow()}),this._maxPromisesPerObject=Math.max(1,e.maxPromisesPerObject??1)}_currentFrame=0;update(t){this._currentFrame=t,this._frame_start===void 0&&this._addedCount>0&&(this._frame_start=t),(this._signal?.aborted||this._awaiting.length===0&&this._frame_start!==void 0&&t>this._frame_start+this._frames_to_capture)&&this.resolveNow()}_seen=new WeakMap;add(t,e,r){if(this._resolved){p&&console.warn("PromiseGroup: Trying to add a promise to a resolved group, ignoring.");return}if(!(this._frame_start!==void 0&&this._currentFrame>this._frame_start+this._frames_to_capture)){if(this._maxPromisesPerObject>=1)if(this._seen.has(e)){let n=this._seen.get(e);if(n>=this._maxPromisesPerObject){p&&console.warn("PromiseGroup: Already awaiting object ignoring new promise for it.");return}this._seen.set(e,n+1)}else this._seen.set(e,1);this._awaiting.push(r),this._addedCount++,r.finally(()=>{this._resolvedCount++,this._awaiting.splice(this._awaiting.indexOf(r),1)})}}resolveNow(){this._resolved||this._resolve?.({awaited_count:this._addedCount,resolved_count:this._resolvedCount,cancelled:this._signal?.aborted??!1})}}const C=V("debugprogressive"),dt=V("noprogressive"),ue=Symbol("Needle:LODSManager"),de=Symbol("Needle:LODState"),U=Symbol("Needle:CurrentLOD"),P={mesh_lod:-1,texture_lod:-1};class _{static debugDrawLine;static getObjectLODState(t){return t[de]}static addPlugin(t){W.push(t)}static removePlugin(t){const e=W.indexOf(t);e>=0&&W.splice(e,1)}static get(t,e){if(t[ue])return console.debug("[gltf-progressive] LODsManager already exists for this renderer"),t[ue];const r=new _(t,{engine:"unknown",...e});return t[ue]=r,r}renderer;context;projectionScreenMatrix=new d.Matrix4;get plugins(){return W}overrideLodLevel=void 0;targetTriangleDensity=2e5;skinnedMeshAutoUpdateBoundsInterval=30;updateInterval="auto";#e=1;pause=!1;manual=!1;_newPromiseGroups=[];_promiseGroupIds=0;awaitLoading(t){const e=this._promiseGroupIds++,r=new le(this.#s,{...t});this._newPromiseGroups.push(r);const n=performance.now();return r.ready.finally(()=>{const s=this._newPromiseGroups.indexOf(r);s>=0&&(this._newPromiseGroups.splice(s,1),_e()&&performance.measure("LODsManager:awaitLoading",{start:n,detail:{id:e,name:t?.name,awaited:r.awaitedCount,resolved:r.resolvedCount}}))}),r.ready}_postprocessPromiseGroups(){if(this._newPromiseGroups.length!==0)for(let t=this._newPromiseGroups.length-1;t>=0;t--)this._newPromiseGroups[t].update(this.#s)}_lodchangedlisteners=[];addEventListener(t,e){t==="changed"&&this._lodchangedlisteners.push(e)}removeEventListener(t,e){if(t==="changed"){const r=this._lodchangedlisteners.indexOf(e);r>=0&&this._lodchangedlisteners.splice(r,1)}}constructor(t,e){this.renderer=t,this.context={...e}}#t;#o=new d.Clock;#s=0;#n=0;#i=0;#r=0;_fpsBuffer=[60,60,60,60,60];enable(){if(this.#t)return;console.debug("[gltf-progressive] Enabling LODsManager for renderer");let t=0;this.#t=this.renderer.render;const e=this;re(this.renderer),this.renderer.render=function(r,n){const s=e.renderer.getRenderTarget();(s==null||"isXRRenderTarget"in s&&s.isXRRenderTarget)&&(t=0,e.#s+=1,e.#n=e.#o.getDelta(),e.#i+=e.#n,e._fpsBuffer.shift(),e._fpsBuffer.push(1/e.#n),e.#r=e._fpsBuffer.reduce((l,a)=>l+a)/e._fpsBuffer.length,C&&e.#s%200===0&&console.log("FPS",Math.round(e.#r),"Interval:",e.#e));const i=t++;e.#t.call(this,r,n),e.onAfterRender(r,n,i)}}disable(){this.#t&&(console.debug("[gltf-progressive] Disabling LODsManager for renderer"),this.renderer.render=this.#t,this.#t=void 0)}update(t,e){this.internalUpdate(t,e)}onAfterRender(t,e,r){if(this.pause)return;const s=this.renderer.renderLists.get(t,0).opaque;let i=!0;if(s.length===1){const l=s[0].material;(l.name==="EffectMaterial"||l.name==="CopyShader")&&(i=!1)}if((e.parent&&e.parent.type==="CubeCamera"||r>=1&&e.type==="OrthographicCamera")&&(i=!1),i){if(dt||(this.updateInterval==="auto"?this.#r<40&&this.#e<10?(this.#e+=1,C&&console.warn("↓ Reducing LOD updates",this.#e,this.#r.toFixed(0))):this.#r>=60&&this.#e>1&&(this.#e-=1,C&&console.warn("↑ Increasing LOD updates",this.#e,this.#r.toFixed(0))):this.#e=this.updateInterval,this.#e>0&&this.#s%this.#e!=0))return;this.internalUpdate(t,e),this._postprocessPromiseGroups()}}internalUpdate(t,e){const r=this.renderer.renderLists.get(t,0),n=r.opaque;this.projectionScreenMatrix.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse);const s=this.targetTriangleDensity;for(const a of n){if(a.material&&(a.geometry?.type==="BoxGeometry"||a.geometry?.type==="BufferGeometry")&&(a.material.name==="SphericalGaussianBlur"||a.material.name=="BackgroundCubeMaterial"||a.material.name==="CubemapFromEquirect"||a.material.name==="EquirectangularToCubeUV")){C&&(a.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]||(a.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]=!0,console.warn("Ignoring skybox or BLIT object",a,a.material.name,a.material.type)));continue}switch(a.material.type){case"LineBasicMaterial":case"LineDashedMaterial":case"PointsMaterial":case"ShadowMaterial":case"MeshDistanceMaterial":case"MeshDepthMaterial":continue}if(C==="color"&&a.material&&!a.object.progressive_debug_color){a.object.progressive_debug_color=!0;const f=Math.random()*16777215,y=new d.MeshStandardMaterial({color:f});a.object.material=y}const u=a.object;(u instanceof d.Mesh||u.isMesh)&&this.updateLODs(t,e,u,s)}const i=r.transparent;for(const a of i){const u=a.object;(u instanceof d.Mesh||u.isMesh)&&this.updateLODs(t,e,u,s)}const l=r.transmissive;for(const a of l){const u=a.object;(u instanceof d.Mesh||u.isMesh)&&this.updateLODs(t,e,u,s)}}updateLODs(t,e,r,n){r.userData||(r.userData={});let s=r[de];if(s||(s=new ct,r[de]=s),s.frames++<2)return;for(const l of W)l.onBeforeUpdateLOD?.(this.renderer,t,e,r);const i=this.overrideLodLevel!==void 0?this.overrideLodLevel:N;i>=0?(P.mesh_lod=i,P.texture_lod=i):(this.calculateLodLevel(e,r,s,n,P),P.mesh_lod=Math.round(P.mesh_lod),P.texture_lod=Math.round(P.texture_lod)),P.mesh_lod>=0&&this.loadProgressiveMeshes(r,P.mesh_lod),r.material&&P.texture_lod>=0&&this.loadProgressiveTextures(r.material,P.texture_lod,i),p&&r.material&&!r.isGizmo&&ke(r.material);for(const l of W)l.onAfterUpdatedLOD?.(this.renderer,t,e,r,P);s.lastLodLevel_Mesh=P.mesh_lod,s.lastLodLevel_Texture=P.texture_lod}loadProgressiveTextures(t,e,r){if(!t)return;if(Array.isArray(t)){for(const s of t)this.loadProgressiveTextures(s,e);return}let n=!1;if((t[U]===void 0||e<t[U])&&(n=!0),r!==void 0&&r>=0&&(n=t[U]!=r,e=r),n){t[U]=e;const s=m.assignTextureLOD(t,e).then(i=>{this._lodchangedlisteners.forEach(l=>l({type:"texture",level:e,object:t}))});le.addPromise("texture",t,s,this._newPromiseGroups)}}loadProgressiveMeshes(t,e){if(!t)return Promise.resolve(null);let r=t[U]!==e;const n=t["DEBUG:LOD"];if(n!=null&&(r=t[U]!=n,e=n),r){t[U]=e;const s=t.geometry,i=m.assignMeshLOD(t,e).then(l=>(l&&t[U]==e&&s!=t.geometry&&this._lodchangedlisteners.forEach(a=>a({type:"mesh",level:e,object:t})),l));return le.addPromise("mesh",t,i,this._newPromiseGroups),i}return Promise.resolve(null)}_sphere=new d.Sphere;_tempBox=new d.Box3;_tempBox2=new d.Box3;tempMatrix=new d.Matrix4;_tempWorldPosition=new d.Vector3;_tempBoxSize=new d.Vector3;_tempBox2Size=new d.Vector3;static corner0=new d.Vector3;static corner1=new d.Vector3;static corner2=new d.Vector3;static corner3=new d.Vector3;static _tempPtInside=new d.Vector3;static isInside(t,e){const r=t.min,n=t.max,s=(r.x+n.x)*.5,i=(r.y+n.y)*.5;return this._tempPtInside.set(s,i,r.z).applyMatrix4(e).z<0}static skinnedMeshBoundsFrameOffsetCounter=0;static $skinnedMeshBoundsOffset=Symbol("gltf-progressive-skinnedMeshBoundsOffset");calculateLodLevel(t,e,r,n,s){if(!e){s.mesh_lod=-1,s.texture_lod=-1;return}if(!t){s.mesh_lod=-1,s.texture_lod=-1;return}let l=10+1,a=!1;if(C&&e["DEBUG:LOD"]!=null)return e["DEBUG:LOD"];const u=m.getMeshLODExtension(e.geometry)?.lods,f=m.getPrimitiveIndex(e.geometry),y=u&&u.length>0,v=m.getMaterialMinMaxLODsCount(e.material),M=v.min_count!==1/0&&v.min_count>=0&&v.max_count>=0;if(!y&&!M){s.mesh_lod=0,s.texture_lod=0;return}y||(a=!0,l=0);const I=this.renderer.domElement.clientHeight||this.renderer.domElement.height;let F=e.geometry.boundingBox;if(e.type==="SkinnedMesh"){const c=e;if(!c.boundingBox)c.computeBoundingBox();else if(this.skinnedMeshAutoUpdateBoundsInterval>0){if(!c[_.$skinnedMeshBoundsOffset]){const S=_.skinnedMeshBoundsFrameOffsetCounter++;c[_.$skinnedMeshBoundsOffset]=S}const w=c[_.$skinnedMeshBoundsOffset];if((r.frames+w)%this.skinnedMeshAutoUpdateBoundsInterval===0){const S=q(c),B=c.geometry;S&&(c.geometry=S),c.computeBoundingBox(),c.geometry=B}}F=c.boundingBox}if(F){const c=t;if(e.geometry.attributes.color&&e.geometry.attributes.color.count<100&&e.geometry.boundingSphere){this._sphere.copy(e.geometry.boundingSphere),this._sphere.applyMatrix4(e.matrixWorld);const h=t.getWorldPosition(this._tempWorldPosition);if(this._sphere.containsPoint(h)){s.mesh_lod=0,s.texture_lod=0;return}}if(this._tempBox.copy(F),this._tempBox.applyMatrix4(e.matrixWorld),c.isPerspectiveCamera&&_.isInside(this._tempBox,this.projectionScreenMatrix)){s.mesh_lod=0,s.texture_lod=0;return}if(this._tempBox.applyMatrix4(this.projectionScreenMatrix),this.renderer.xr.enabled&&c.isPerspectiveCamera&&c.fov>70){const h=this._tempBox.min,g=this._tempBox.max;let D=h.x,O=h.y,$=g.x,j=g.y;const Q=2,se=1.5,J=(h.x+g.x)*.5,Z=(h.y+g.y)*.5;D=(D-J)*Q+J,O=(O-Z)*Q+Z,$=($-J)*Q+J,j=(j-Z)*Q+Z;const $e=D<0&&$>0?0:Math.min(Math.abs(h.x),Math.abs(g.x)),Ge=O<0&&j>0?0:Math.min(Math.abs(h.y),Math.abs(g.y)),ne=Math.max($e,Ge);r.lastCentrality=(se-ne)*(se-ne)*(se-ne)}else r.lastCentrality=1;const w=this._tempBox.getSize(this._tempBoxSize);w.multiplyScalar(.5),screen.availHeight>0&&I>0&&w.multiplyScalar(I/screen.availHeight),t.isPerspectiveCamera?w.x*=t.aspect:t.isOrthographicCamera;const S=t.matrixWorldInverse,B=this._tempBox2;B.copy(F),B.applyMatrix4(e.matrixWorld),B.applyMatrix4(S);const b=B.getSize(this._tempBox2Size),E=Math.max(b.x,b.y);if(Math.max(w.x,w.y)!=0&&E!=0&&(w.z=b.z/Math.max(b.x,b.y)*Math.max(w.x,w.y)),r.lastScreenCoverage=Math.max(w.x,w.y,w.z),r.lastScreenspaceVolume.copy(w),r.lastScreenCoverage*=r.lastCentrality,C&&_.debugDrawLine){const h=this.tempMatrix.copy(this.projectionScreenMatrix);h.invert();const g=_.corner0,D=_.corner1,O=_.corner2,$=_.corner3;g.copy(this._tempBox.min),D.copy(this._tempBox.max),D.x=g.x,O.copy(this._tempBox.max),O.y=g.y,$.copy(this._tempBox.max);const j=(g.z+$.z)*.5;g.z=D.z=O.z=$.z=j,g.applyMatrix4(h),D.applyMatrix4(h),O.applyMatrix4(h),$.applyMatrix4(h),_.debugDrawLine(g,D,255),_.debugDrawLine(g,O,255),_.debugDrawLine(D,$,255),_.debugDrawLine(O,$,255)}let L=999;if(u&&r.lastScreenCoverage>0)for(let h=0;h<u.length;h++){const g=u[h],O=(g.densities?.[f]||g.density||1e-5)/r.lastScreenCoverage;if(f>0&&_e()&&!g.densities&&!globalThis["NEEDLE:MISSING_LOD_PRIMITIVE_DENSITIES"]&&(window["NEEDLE:MISSING_LOD_PRIMITIVE_DENSITIES"]=!0,console.warn("[Needle Progressive] Detected usage of mesh without primitive densities. This might cause incorrect LOD level selection: Consider re-optimizing your model by updating your Needle Integration, Needle glTF Pipeline or running optimization again on Needle Cloud.")),O<n){L=h;break}}L<l&&(l=L,a=!0)}if(a?s.mesh_lod=l:s.mesh_lod=r.lastLodLevel_Mesh,C&&s.mesh_lod!=r.lastLodLevel_Mesh){const w=u?.[s.mesh_lod];w&&console.debug(`Mesh LOD changed: ${r.lastLodLevel_Mesh} → ${s.mesh_lod} (density: ${w.densities?.[f].toFixed(0)}) | ${e.name}`)}if(M){const c="saveData"in globalThis.navigator&&globalThis.navigator.saveData===!0;if(r.lastLodLevel_Texture<0){if(s.texture_lod=v.max_count-1,C){const w=v.lods[v.max_count-1];C&&console.log(`First Texture LOD ${s.texture_lod} (${w.max_height}px) - ${e.name}`)}}else{const w=r.lastScreenspaceVolume.x+r.lastScreenspaceVolume.y+r.lastScreenspaceVolume.z;let S=r.lastScreenCoverage*4;this.context?.engine==="model-viewer"&&(S*=1.5);const b=I/window.devicePixelRatio*S;let E=!1;for(let T=v.lods.length-1;T>=0;T--){const L=v.lods[T];if(!(c&&L.max_height>=2048)&&!(Ae()&&L.max_height>4096)&&(L.max_height>b||!E&&T===0)){if(E=!0,s.texture_lod=T,C&&s.texture_lod<r.lastLodLevel_Texture){const x=L.max_height;console.log(`Texture LOD changed: ${r.lastLodLevel_Texture} → ${s.texture_lod} = ${x}px 
Screensize: ${b.toFixed(0)}px, Coverage: ${(100*r.lastScreenCoverage).toFixed(2)}%, Volume ${w.toFixed(1)} 
${e.name}`)}break}}}}else s.texture_lod=0}}class ct{frames=0;lastLodLevel_Mesh=-1;lastLodLevel_Texture=-1;lastScreenCoverage=0;lastScreenspaceVolume=new d.Vector3;lastCentrality=0}const ve=Symbol("NEEDLE_mesh_lod"),ee=Symbol("NEEDLE_texture_lod");let ce=null;function we(){const o=ft();o&&(o.mapURLs(function(t){return Me(),t}),Me(),ce?.disconnect(),ce=new MutationObserver(t=>{t.forEach(e=>{e.addedNodes.forEach(r=>{r instanceof HTMLElement&&r.tagName.toLowerCase()==="model-viewer"&&Re(r)})})}),ce.observe(document,{childList:!0,subtree:!0}))}function ft(){if(typeof customElements>"u")return null;const o=customElements.get("model-viewer");return o||(customElements.whenDefined("model-viewer").then(()=>{console.debug("[gltf-progressive] model-viewer defined"),we()}),null)}function Me(){if(typeof document>"u")return;document.querySelectorAll("model-viewer").forEach(t=>{Re(t)})}const be=new WeakSet;let ht=0;function Re(o){if(!o||be.has(o))return null;be.add(o),console.debug("[gltf-progressive] found new model-viewer..."+ ++ht+`
`,o.getAttribute("src"));let t=null,e=null,r=null;for(let n=o;n!=null;n=Object.getPrototypeOf(n)){const s=Object.getOwnPropertySymbols(n),i=s.find(u=>u.toString()=="Symbol(renderer)"),l=s.find(u=>u.toString()=="Symbol(scene)"),a=s.find(u=>u.toString()=="Symbol(needsRender)");!t&&i!=null&&(t=o[i].threeRenderer),!e&&l!=null&&(e=o[l]),!r&&a!=null&&(r=o[a])}if(t&&e){let n=function(){if(r){let i=0,l=setInterval(()=>{if(i++>5){clearInterval(l);return}r?.call(o)},300)}};console.debug("[gltf-progressive] setup model-viewer");const s=_.get(t,{engine:"model-viewer"});return _.addPlugin(new gt),s.enable(),s.addEventListener("changed",()=>{r?.call(o)}),o.addEventListener("model-visibility",i=>{i.detail.visible&&r?.call(o)}),o.addEventListener("load",()=>{n()}),()=>{s.disable()}}return null}class gt{_didWarnAboutMissingUrl=!1;onBeforeUpdateLOD(t,e,r,n){this.tryParseMeshLOD(e,n),this.tryParseTextureLOD(e,n)}getUrl(t){if(!t)return null;let e=t.getAttribute("src");return e||(e=t.src),e||(this._didWarnAboutMissingUrl||console.warn("No url found in modelviewer",t),this._didWarnAboutMissingUrl=!0),e}tryGetCurrentGLTF(t){return t._currentGLTF}tryGetCurrentModelViewer(t){return t.element}tryParseTextureLOD(t,e){if(e[ee]==!0)return;e[ee]=!0;const r=this.tryGetCurrentGLTF(t),n=this.tryGetCurrentModelViewer(t),s=this.getUrl(n);if(s&&r&&e.material){let i=function(a){if(a[ee]==!0)return;a[ee]=!0,a.userData&&(a.userData.LOD=-1);const u=Object.keys(a);for(let f=0;f<u.length;f++){const y=u[f],v=a[y];if(v?.isTexture===!0){const M=v.userData?.associations?.textures;if(M==null)continue;const I=r.parser.json.textures[M];if(!I){console.warn("Texture data not found for texture index "+M);continue}if(I?.extensions?.[G]){const F=I.extensions[G];F&&s&&m.registerTexture(s,v,F.lods.length,M,F)}}}};const l=e.material;if(Array.isArray(l))for(const a of l)i(a);else i(l)}}tryParseMeshLOD(t,e){if(e[ve]==!0)return;e[ve]=!0;const r=this.tryGetCurrentModelViewer(t),n=this.getUrl(r);if(!n)return;const s=e.userData?.gltfExtensions?.[G];if(s&&n){const i=e.uuid;m.registerMesh(n,i,e,0,s.lods.length,s)}}}function Be(...o){let t,e,r,n;switch(o.length){case 2:[r,e]=o,n={};break;case 3:[r,e,n]=o;break;case 4:[t,e,r,n]=o;break;default:throw new Error("Invalid arguments")}re(e),me(r),ye(r,{progressive:!0,...n?.hints}),r.register(i=>new m(i));const s=_.get(e);return n?.enableLODsManager!==!1&&s.enable(),s}we();if(!tt){const o={gltfProgressive:{useNeedleProgressive:Be,LODsManager:_,configureLoader:ye,getRaycastMesh:q,useRaycastMeshes:Ce}};if(!globalThis.Needle)globalThis.Needle=o;else for(const t in o)globalThis.Needle[t]=o[t]}exports.EXTENSION_NAME=G;exports.LODsManager=_;exports.NEEDLE_progressive=m;exports.VERSION=De;exports.addDracoAndKTX2Loaders=me;exports.configureLoader=ye;exports.createLoaders=re;exports.getRaycastMesh=q;exports.patchModelViewer=we;exports.registerRaycastMesh=Ie;exports.setDracoDecoderLocation=Se;exports.setKTX2TranscoderLocation=Te;exports.useNeedleProgressive=Be;exports.useRaycastMeshes=Ce;
