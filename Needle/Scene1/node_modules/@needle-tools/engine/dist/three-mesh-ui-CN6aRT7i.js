import { Vector4 as Pt, Vector3 as It, Vector2 as Ct, TextureLoader as Rt, Texture as Bt, ShaderMaterial as Ut, PlaneGeometry as At, Plane as Tt, Object3D as Mt, MeshBasicMaterial as Ft, Mesh as Ot, LinearFilter as Lt, FrontSide as zt, FileLoader as Wt, EventDispatcher as Et, DoubleSide as Dt, Color as Ht, BufferGeometry as Gt, BufferAttribute as $t, BackSide as Nt } from "./three-CsHK73Zc.js";
var V = {};
V.d = (i, e) => {
  for (var t in e)
    V.o(e, t) && !V.o(i, t) && Object.defineProperty(i, t, { enumerable: !0, get: e[t] });
};
V.o = (i, e) => Object.prototype.hasOwnProperty.call(i, e);
V.r = (i) => {
  typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
};
var m = {};
V.d(m, {
  ti: () => (
    /* reexport */
    p
  ),
  nS: () => (
    /* reexport */
    yt
  ),
  eB: () => (
    /* reexport */
    T
  ),
  Yp: () => (
    /* reexport */
    ne
  ),
  VB: () => (
    /* reexport */
    I
  ),
  BC: () => (
    /* reexport */
    O
  ),
  zN: () => (
    /* reexport */
    C
  ),
  cV: () => (
    /* reexport */
    B
  ),
  hW: () => (
    /* reexport */
    F
  ),
  k2: () => (
    /* reexport */
    ze
  ),
  K6: () => (
    /* reexport */
    w
  ),
  M7: () => (
    /* reexport */
    oe
  ),
  ls: () => (
    /* reexport */
    L
  ),
  Hi: () => (
    /* reexport */
    tt
  ),
  EY: () => (
    /* reexport */
    M
  ),
  MR: () => (
    /* reexport */
    je
  ),
  zf: () => (
    /* reexport */
    Le
  ),
  Ay: () => (
    /* binding */
    an
  ),
  yo: () => (
    /* binding */
    bt
  )
});
var ne = {};
V.r(ne);
V.d(ne, {
  get: () => Fe,
  set: () => Xt
});
var oe = {};
V.r(oe);
V.d(oe, {
  alphaTestTransformer: () => Y,
  asPreprocessorValueTransformer: () => Ye,
  toPreprocessorTriggerTransformer: () => me,
  toUserDataTransformer: () => ss,
  uniformOrUserDataTransformer: () => x
});
const se = {
  fontFamily: null,
  fontSize: 0.05,
  fontKerning: "auto",
  fontStyle: "normal",
  fontWeight: "normal",
  offset: 5e-3,
  lineHeight: 1.2,
  lineBreak: `- ,.:?!
`,
  // added '\n' to also acts as friendly breaks when white-space:normal
  whiteSpace: "pre-line",
  flexDirection: "column",
  justifyContent: "start",
  alignItems: "start",
  backgroundImage: null,
  textAlign: "left",
  boxSizing: "content-box",
  position: "static",
  color: 16777215,
  fontColor: 16777215,
  fontOpacity: 1,
  opacity: 1,
  fontPXRange: 4,
  fontSupersampling: !0,
  fontSmooth: "antialiased",
  borderRadius: 0,
  borderWidth: 0,
  borderColor: "black",
  borderOpacity: 1,
  backgroundSize: "cover",
  backgroundColor: 0,
  backgroundOpacity: 0,
  overflow: "visible",
  letterSpacing: 0,
  invertAlpha: !1,
  segments: 1
}, Xt = function(i) {
  for (const e in i)
    se[e] = i[e];
}, Fe = function(i) {
  return Object.prototype.hasOwnProperty.call(se, i) || console.warn(`ThreeMeshUI::DefaultValues is trying to retrieve non-existing property '${i}'`), se[i];
};
class p {
  /**
   *
   * @param {string} propertyId
   * @param {any} [value=null]
   * @param primitive
   */
  constructor(e, t = null, s = !0) {
    this._id = e, this._value = t, this._needsUpdate = !0, this._needsProcess = !1, this._needsRender = !1, this._isPrimitive = s;
  }
  /**
   *
   * @return {string}
   */
  get id() {
    return this._id;
  }
  /**
   *
   * @return {any}
   */
  get value() {
    return this._value;
  }
  /**
   *
   * @param {any} value
   */
  set value(e) {
    this.isValid(e) && this._value !== e && (this._value = e, this._needsUpdate = !0);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   * @param {Object.<string,any>} out
   */
  update(e, t) {
    this.output(t);
  }
  /* eslint-disable no-unused-vars */
  /**
   * Output this property in a dictionnary
   * @param {Object.<string,any>} out
   */
  output(e) {
  }
  /**
   *
   * @param {Out} out
   */
  _outputValue(e) {
    e[this._id] = this._value;
  }
  /* eslint-disable no-unused-vars */
  /**
   * Execute additional process after all properties have been updated
   * @param {MeshUIBaseElement} element
   */
  process(e) {
  }
  /* eslint-disable no-unused-vars */
  /**
   * Execute additional process after all properties have been updated
   * @param {MeshUIBaseElement} element
   */
  render(e) {
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  getInheritedInput(e) {
    if (this._value !== "inherit") return this._value;
    const t = e._parent._value;
    return t && t[`_${this._id}`] ? t[`_${this._id}`].getInheritedInput(t) : this.getDefaultValue();
  }
  /**
   *
   * @return {any}
   */
  getDefaultValue() {
    return Fe(this._id);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {any} value
   * @return {boolean}
   */
  isValid(e) {
    return !0;
  }
  /**
   *
   */
  emptyStrategyLogic() {
    throw new Error(`ThreeMeshUI::${this.constructor.name} has empty strategy. Update has not been processed.`);
  }
  requestUpdate() {
    this._needsUpdate = !0;
  }
  requestProcess() {
    this._needsProcess = !1;
  }
  requestRender() {
    this._needsRender = !1;
  }
}
class jt extends p {
  constructor() {
    super("renderOrder", "auto", !0), this.output = this._outputValue, this._actualValue = 0;
  }
  /**
   *
   * @param {number} value
   */
  set value(e) {
    this.isValid(e) && (this._value = e, this._needsUpdate = !0);
  }
  update(e, t) {
    if (this._value !== "auto")
      this._actualValue = this._value;
    else {
      const s = e._parent._value;
      if (s !== null) {
        const r = s._renderOrder._actualValue, n = 1 + s._children._uis.indexOf(e);
        this._actualValue = r + n;
      }
    }
    for (const s of e._children._uis)
      s._renderOrder._value === "auto" && (s._renderOrder._needsUpdate = !0);
    this._outputValue(t);
  }
  _outputValue(e) {
    e[this._id] = this._actualValue;
  }
  /**
   *
   * @return {number}
   */
  get value() {
    return this._value;
  }
}
class C extends p {
  /**
   *
   * @param {string} propertyId
   * @param {any} [value=null]
   * @param primitive
   */
  constructor(e, t = null, s = !0) {
    super(e, t, s), this.output = this._outputValue, this._notInheritedValue = null;
  }
  update(e, t) {
    this._notInheritedValue = this._value, this._notInheritedValue === "inherit" && (this._notInheritedValue = this.getInheritedInput(e)), this.propagate(e), this._outputValue(t);
  }
  propagate(e) {
    for (const t of e._children._uis) {
      const s = t[`_${this._id}`];
      s !== void 0 && s._value === "inherit" && (t[`_${this._id}`]._needsUpdate = !0);
    }
  }
  /**
   * Output this property in a dictionnary
   * @override
   */
  _outputValue(e) {
    e[this._id] = this._notInheritedValue;
  }
  set value(e) {
    this.isValid(e) && this._value !== e && (this._value = e, this._needsUpdate = !0);
  }
  /**
   *
   * @override
   * @return {any|"inherit"}
   */
  get value() {
    return this._value === "inherit" ? this._notInheritedValue : this._value;
  }
}
class Yt extends C {
  constructor() {
    super("offset", "inherit", !1);
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    super.update(e, t), e._parent._value !== null && (e.position.z = this._notInheritedValue);
  }
}
class Kt extends C {
  constructor() {
    super("fontSmooth", "inherit", !0), this._needsUpdate = !1, this.isValid = Jt, this.output = this._outputValue;
  }
}
const qt = ["inherit", "none", "antialiased"];
function Jt(i) {
  return qt.indexOf(i) === -1 ? (console.warn(`.fontSmoothing value '${i}' is not valid. Aborted`), !1) : !0;
}
var Zt = (i) => {
  var e = {};
  return V.d(e, i), e;
};
const u = Zt({ BackSide: () => Nt, BufferAttribute: () => $t, BufferGeometry: () => Gt, Color: () => Ht, DoubleSide: () => Dt, EventDispatcher: () => Et, FileLoader: () => Wt, FrontSide: () => zt, LinearFilter: () => Lt, Mesh: () => Ot, MeshBasicMaterial: () => Ft, Object3D: () => Mt, Plane: () => Tt, PlaneGeometry: () => At, ShaderMaterial: () => Ut, Texture: () => Bt, TextureLoader: () => Rt, Vector2: () => Ct, Vector3: () => It, Vector4: () => Pt });
class g extends p {
  /**
   *
   * @param {string} propertyId
   * @param {boolean} [primitive=true]
   * @param {any} defaultValue
   */
  constructor(e, t, s = !0) {
    super(e, "unset", s), this._input = "inherit", this._allowsInherit = !0, this._inheritedInput = void 0, this._inline = void 0;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   * @param {Object.<string,any> } out
   */
  update(e, t) {
    this._allowsInherit || (this._inheritedInput = this.getInheritedInput(e)), this.computeOutputValue(e);
    for (const s of e._children._uis) {
      const r = s[`_${this._id}`];
      (r._input ? r._input : r._value) === "inherit" && (s[`_${this._id}`]._needsUpdate = !0);
    }
    this.output(t);
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(e) {
    this._value = this._input;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  _computeFromInherited(e) {
    this._value = this._inheritedInput;
  }
  /**
   * @override
   * @deprecated
   * @param {any} v
   */
  set value(e) {
    console.warn(".(style) sub-property cannot be directly set. It must comes from inline or computed setter.");
  }
  /**
   *
   * @param {any} value
   */
  set inline(e) {
    this.isValidValue(e) && e !== this._inline && (this._input = this._inline = e, this._needsUpdate = !0);
  }
  /**
   *
   * @return {any}
   */
  get inline() {
    return this._inline;
  }
  /**
   *
   * @param {any} value
   * @return {boolean}
   */
  isValidValue(e) {
    return !0;
  }
  /**
   * @param {MeshUIBaseElement} element
   */
  getInheritedInput(e) {
    if (this._input !== "inherit") return this._input;
    const t = e._parent._value;
    return t ? t[`_${this._id}`].getInheritedInput(t) : this.getDefaultValue();
  }
}
class j extends g {
  constructor(e, t) {
    super(e, t, !1), this._input = new u.Vector4(0, 0, 0, 0), this._inline = null, this._value = new u.Vector4(0, 0, 0, 0);
  }
  /**
   * @override
   * @return {Vector4}
   */
  get value() {
    return this._value;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @override
   */
  computeOutputValue(e) {
    this._vector4ValueSetter(this._value, this._input);
  }
  set inline(e) {
    this._vector4ValueSetter(this._input, e), !this._input.equals(this._value) && (this._needsUpdate = !0);
  }
  /**
   *
   * @param {Number} v
   */
  set top(e) {
    this._input.x !== e && (this._input.x = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {number}
   */
  get top() {
    return this._input.x;
  }
  /**
   *
   * @param {Number} v
   */
  set right(e) {
    this._input.y !== e && (this._input.y = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {number}
   */
  get right() {
    return this._input.y;
  }
  /**
   *
   * @param {Number} v
   */
  set bottom(e) {
    this._input.z !== e && (this._input.z = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {number}
   */
  get bottom() {
    return this._input.z;
  }
  /**
   *
   * @param {Number} v
   */
  set left(e) {
    this._input.w !== e && (this._input.w = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {number}
   */
  get left() {
    return this._input.w;
  }
  dispose() {
    this._computed = null, this._inline = null, this._input = null, this._output = null;
  }
  /**
   *
   * @param {Vector4} vector4
   * @param {Vector4|Array.<Number>|Number|String} value
   * @protected
   */
  _vector4ValueSetter(e, t) {
    if (t instanceof u.Vector4) {
      e.copy(t);
      return;
    }
    if ((typeof t == "string" || t instanceof String) && (t = t.split(" ")), Array.isArray(t))
      switch (t = t.map((s) => parseFloat(s)), t.length) {
        case 1:
          e.setScalar(t[0]);
          return;
        case 2:
          e.x = e.z = t[0], e.y = e.w = t[1];
          return;
        case 3:
          e.x = t[0], e.y = t[1], e.z = t[2];
          return;
        case 4:
          e.x = t[0], e.y = t[1], e.z = t[2], e.w = t[3];
          return;
        default:
          console.error("StyleVector4Property::set() Four Dimension property had more than four values");
          return;
      }
    isNaN(t) || e.setScalar(t);
  }
}
class Qt extends j {
  constructor() {
    super("padding", new u.Vector4(0, 0, 0, 0));
  }
  computeOutputValue(e) {
    super.computeOutputValue(e), e._bounds._needsUpdate = !0, e._bounds._needsRender = !0, e._layouter._needsProcess = !0, e._renderer._needsRender = !0, e._parent._value && (e._parent._value._layouter._needsProcess = !0);
  }
}
class ei extends j {
  constructor() {
    super("margin", new u.Vector4(0, 0, 0, 0));
  }
  computeOutputValue(e) {
    super.computeOutputValue(e), e._renderer._needsRender = !0, e._parent._value && (e._parent._value._flexDirection._needsProcess = !0);
  }
}
const Ie = function(i, e, t) {
  i[e] = t;
}, ti = function(i, e, t) {
  t !== null && (i[e] = t);
};
class z {
  /**
   * @constructor
   * @param {MediationDefinition} definition
   */
  constructor(e) {
    this._definition = e;
  }
  /**
   *
   * @param {MediationDefinition} value
   */
  set definition(e) {
    this._definition = e;
  }
  /**
   *
   * @param {MeshUIBaseElement} subject
   * @param {any} target
   * @param {Object.<(string|number), any>} options
   * @param {any} [secondTarget=null]
   */
  mediate(e, t, s, r = null) {
    for (const n in this._definition) {
      const o = this._definition[n];
      if (s[n] !== void 0) {
        const a = o.t ? o.t : Ie;
        a(t, o.m, s[n]), r && a(r, o.m, s[n]);
      }
    }
  }
  /***********************************************************************************************************************
   * STATIC
   **********************************************************************************************************************/
  /**
   *
   * @param {MeshUIComponent} subject
   * @param {any} target
   * @param {Object.<(string|number), any>} options
   * @param {Object.<{subjectProperty:string, t?:(target:any, targetProperty:string, value:any) => void}>} mediationDefinitions
   * @param {any} [secondTarget=null]
   */
  static mediate(e, t, s, r, n = null) {
    if (t)
      for (const o in r) {
        const a = r[o];
        if (s[o] !== void 0) {
          const l = a.t ? a.t : Ie;
          l(t, a.m, s[o]), n && l(n, a.m, s[o]);
        }
      }
  }
}
class ii extends p {
  constructor() {
    super("parent", null, !1);
  }
  /* eslint-disable no-unused-vars */
  /**
   * Update when :
   * 		- element has been added
   * 		- element has been removed
   *
   * @param element
   * @param out
   */
  update(e, t) {
    e.parent && e.parent.isUI ? this._value = e.parent : this._value = null;
  }
  set value(e) {
    console.warn("ParentProperty is readonly");
  }
  /**
   *
   * @return {MeshUIBaseElement}
   */
  get value() {
    return this._value;
  }
  /**
   *
   * @param {(p:Object3D)=>boolean } conditionCallback
   */
  find(e) {
    return this._value ? e(this._value) ? this._value : this._value._parent.find(e) : null;
  }
  /**
   *
   */
  dispose() {
    this._value = null;
  }
}
const re = function(i, e, t = 6) {
  return i.toFixed(t) === e.toFixed(t);
};
class Ce extends p {
  /**
   *
   * @param {string} propertyId
   * @param {number} [value]
   */
  constructor(e, t) {
    super(e, t, !0), this.output = this._outputValue;
  }
  /**
   *
   * @param {number} value
   */
  set value(e) {
    this.isValid(e) && (re(this._value, e) || (this._value = e, this._needsUpdate = !0));
  }
  /**
   *
   * @return {number}
   */
  get value() {
    return this._value;
  }
}
class Re extends C {
  /**
   *
   * @param {string} propertyId
   */
  constructor(e) {
    super(e, "inherit", !0), this.isValid = ri;
  }
}
const si = [u.FrontSide, u.BackSide, u.DoubleSide];
function ri(i) {
  return si.indexOf(i) === -1 ? (console.warn(`SideProperty value '${i}' is not valid. Abort`), !1) : !0;
}
class Oe {
  constructor() {
    this._offsetX = 0, this._offsetY = 0, this._lineBreak = null, this._kerning = 0, this._fontFactor = 1, this._fontSize = 0, this._cumulativeWidth = 0, this._paddingLeft = 0, this._paddingRight = 0, this._marginLeft = 0, this._marginRight = 0;
  }
  /**
   * @returns {void}
   */
  resetOffsets() {
    this._offsetX = this._offsetY = 0, this._cumulativeWidth = 0;
  }
  /**
   * The horizontal distance this inline fills
   * @returns {number}
   */
  get xadvance() {
    return 0;
  }
  /**
   * The offset x of this inline in a line
   * @returns {number}
   */
  get xoffset() {
    return 0;
  }
  /**
   * The offset y of this inline in a line
   * @returns {number}
   */
  get yoffset() {
    return 0;
  }
  /**
   *
   * @returns {number}
   */
  get width() {
    return 0;
  }
  /**
   *
   * @returns {number}
   */
  get height() {
    return 0;
  }
  /**
   *
   * @param {string|null} value
   */
  set lineBreak(e) {
    this._lineBreak = e;
  }
  /**
   *
   * @returns {string|null}
   */
  get lineBreak() {
    return this._lineBreak;
  }
  /**
   *
   * @returns {number}
   */
  get anchor() {
    return 0;
  }
  /**
   *
   * @returns {number}
   */
  get kerning() {
    return this._kerning * this._fontFactor;
  }
  /**
   *
   * @param {number} value
   */
  set kerning(e) {
    this._kerning = e;
  }
  /**
   *
   * @returns {number}
   */
  get fontSize() {
    return this._fontSize;
  }
  /**
   *
   * @param {number} value
   */
  set fontSize(e) {
    this._fontSize = e;
  }
  /**
   *
   * @returns {number}
   */
  get lineHeight() {
    return 0;
  }
  /**
   *
   * @returns {number}
   */
  get offsetX() {
    return this._offsetX;
  }
  /**
   *
   * @param value
   */
  set offsetX(e) {
    this._offsetX = e;
  }
  /**
   *
   * @returns {number}
   */
  get offsetY() {
    return this._offsetY;
  }
  /**
   *
   * @param {number} value
   */
  set offsetY(e) {
    this._offsetY = e;
  }
  /**
   *
   * @return {number}
   */
  get cumulativeWidth() {
    return this._cumulativeWidth;
  }
  /**
   *
   * @param {number} value
   */
  set cumulativeWidth(e) {
    this._cumulativeWidth = e;
  }
  /**
   *
   * @return {number}
   */
  get marginLeft() {
    return this._marginLeft;
  }
  /**
   *
   * @param {number} value
   */
  set marginLeft(e) {
    this._marginLeft = e;
  }
  /**
   *
   * @return {number}
   */
  get marginRight() {
    return this._marginRight;
  }
  /**
   *
   * @param {number} value
   */
  set marginRight(e) {
    this._marginRight = e;
  }
  /**
   *
   * @return {number}
   */
  get paddingLeft() {
    return this._paddingLeft;
  }
  /**
   *
   * @param {number} value
   */
  set paddingLeft(e) {
    this._paddingLeft = e;
  }
  /**
   *
   * @return {number}
   */
  get paddingRight() {
    return this._paddingRight;
  }
  /**
   *
   * @param {number} value
   */
  set paddingRight(e) {
    this._paddingRight = e;
  }
  /**
   *
   * @returns {number}
   */
  get lineBase() {
    return 0;
  }
  /**
   *
   * @param {number} value
   */
  set fontFactor(e) {
    this._fontFactor = e;
  }
  /**
   *
   * @returns {number}
   */
  get fontFactor() {
    return this._fontFactor;
  }
}
class Le {
  /**
   *
   * @param {TypographicFont} typographicFont
   */
  constructor(e) {
    this._char = "", this._width = 1, this._heigth = 1, this._xadvance = 1, this._xoffset = 0, this._yoffset = 0, this._font = e;
  }
  /**
   *
   * @returns {TypographicFont}
   */
  get font() {
    return this._font;
  }
  /**
   *
   * @return {string}
   */
  get char() {
    return this._char;
  }
  /**
   *
   * @returns {number}
   */
  get width() {
    return this._width;
  }
  /**
   *
   * @returns {number}
   */
  get height() {
    return this._heigth;
  }
  /**
   *
   * @returns {number}
   */
  get xadvance() {
    return this._xadvance;
  }
  /**
   *
   * @returns {number}
   */
  get xoffset() {
    return this._xoffset;
  }
  /**
   *
   * @returns {number}
   */
  get yoffset() {
    return this._yoffset;
  }
  /**
   *
   * @param value
   */
  set yoffset(e) {
    this._yoffset = e;
  }
  /**
   *
   * @abstract
   * @param {string} otherChar
   * @returns {TypographicGlyph}
   */
  /* eslint-disable no-unused-vars */
  clone(e) {
    throw new Error("Abstract... Need to be implemented");
  }
  /**
   *
   * @abstract
   * @returns {InlineGlyph}
   */
  asInlineGlyph() {
    throw new Error("Abstract... Need to be implemented");
  }
}
class ze extends Oe {
  /**
   *
   * @param {TypographicGlyph} characterDesc
   */
  constructor(e) {
    super(), this._typographic = e;
  }
  /**
   *
   * @returns {TypographicGlyph}
   */
  get typographic() {
    return this._typographic;
  }
  /*********************************************************************************************************************
   * GETTERS FROM CHARACTER DESCRIPTION
   ********************************************************************************************************************/
  /**
   * @override
   * @returns {number}
   */
  get xadvance() {
    return this._typographic.xadvance * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get xoffset() {
    return this._typographic.xoffset * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get yoffset() {
    return this._typographic.yoffset * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get width() {
    return this._typographic.width * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get height() {
    return this._typographic.height * this._fontFactor;
  }
  /**
   *
   * @return {string}
   */
  get char() {
    return this._typographic.char;
  }
  /**
   * @override
   * @returns {number}
   */
  get anchor() {
    return this.yoffset;
  }
  /**
   * @override
   * @returns {number}
   */
  get lineHeight() {
    return this._typographic.font.lineHeight * this._fontFactor;
  }
  /**
   * @override
   * @returns {number}
   */
  get lineBase() {
    return this._typographic.font.lineBase * this._fontFactor;
  }
}
const ni = {
  light: "100",
  normal: "400",
  bold: "700",
  bolder: "900"
};
function ae(i) {
  if (!isNaN(i)) return i.toString();
  const e = ni[i];
  return e || i;
}
class oi extends u.EventDispatcher {
  /**
   *
   * @param {import('./../core/elements/MeshUIBaseElement').FontWeightFormat} weight
   * @param {"normal"|"italic"} style
   */
  constructor(e, t) {
    super(), this._isReady = !1, this._weight = ae(e), this._style = t, this._size = 42, this._lineHeight = 42, this._lineBase = 42, this._font = null;
  }
  /**
   *
   * @returns {TypographicFont}
   */
  get typographic() {
    return this._font;
  }
  /**
   *
   * @returns {boolean}
   */
  get isReady() {
    return this._isReady;
  }
  /**
   *
   * @returns {string}
   */
  get weight() {
    return this._weight;
  }
  /**
   *
   * @returns {string}
   */
  get style() {
    return this._style;
  }
  /**
   *
   * @returns {Texture}
   */
  get texture() {
    return this._texture;
  }
  /**
   * @param {Function.<ShaderMaterial|Material>} v
   * @abstract
   */
  set fontMaterial(e) {
    throw Error(`FontVariant('${this.id}')::fontMaterial - is abstract.`);
  }
  /**
   * @return {Function.<ShaderMaterial|Material>}
   * @abstract
   */
  get fontMaterial() {
    throw Error(`FontVariant('${this.id}')::fontMaterial - is abstract.`);
  }
  /**
   *
   * @returns {string}
   */
  get id() {
    return `${this._name}(w:${this.weight},s:${this.style})`;
  }
  /**
   *
   * @param {string} character
   * @returns {TypographicGlyph}
   */
  getTypographicGlyph(e) {
    let t = this._chars[e];
    if (t) return t;
    if (e.match(/\s/)) return this._chars[" "];
    const s = this._getFallbackCharacter(e);
    if (s && (t = this._chars[s], t))
      return t;
    throw Error(`FontVariant('${this.id}')::getTypographicGlyph() - character('${e}') and/or fallback character were not found in provided msdf charset.`);
  }
  /* eslint-disable no-unused-vars */
  /**
   * @abstract
   * @protected
   * @param {string} missingChar
   * @returns {string|null}
   */
  _getFallbackCharacter(e) {
    throw new Error(`FontVariant(${typeof this})::_getFallbackCharacter() is abstract and should therefore be overridden.`);
  }
  /* eslint-disable no-unused-vars */
  /**
   * Convert an InlineCharacter to a geometry
   *
   * @abstract
   * @param {InlineGlyph} inline
   * @param {MeshUIBaseElement} element
   * @returns {BufferGeometry|Array.<BufferGeometry>}
   */
  getGeometricGlyph(e, t) {
    throw new Error(`FontVariant(${typeof this})::getGeometryCharacter() is abstract and should therefore be overridden.`);
  }
  /* eslint-enable no-unused-vars */
  /**
   * Obtain the kerning amount of a glyphPair
   * @param {string} glyphPair
   * @returns {number}
   */
  getKerningAmount(e) {
    return this._kernings[e] ? this._kernings[e] : 0;
  }
  /**
   * Perform some changes on the character description of this font
   * @param {Object.<string,Object.<string,number|string>>} adjustmentObject
   */
  adjustTypographicGlyphs(e) {
    for (const t in e) {
      const s = this.getTypographicGlyph(t), r = e[t];
      for (const n in r)
        s["_" + n] = e[t][n];
    }
  }
  /**
   *
   * @private
   */
  _checkReadiness() {
    this._readyCondition() && ui(this);
  }
  /* eslint-disable no-unused-vars */
  /**
   * @abstract
   * @param element
   * @internal
   */
  _alterElementProperties(e) {
    throw new Error(`FontVariant(${typeof this})::_alterElementProperties() is abstract and should therefore be overridden.`);
  }
  /**
   *
   * @abstract
   * @returns {boolean}
   * @protected
   */
  _readyCondition() {
    throw new Error(`FontVariant(${typeof this})::_readyCondition() is abstract and should therefore be overridden.`);
  }
}
const ai = { type: "ready" };
function ui(i) {
  i._isReady = !0, i.dispatchEvent(ai);
}
const O = oi;
class hi extends p {
  /**
   *
   * @param {FontVariant} [value=null]
   */
  constructor(e = null) {
    super("font", e, !1), this._needsUpdate = !1, this._fontVariant = null, this._handleFontReadyClosure = null, this.isValid = li;
  }
  output(e) {
    e[this._id] = this._fontVariant;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   */
  update(e, t) {
    if (this._fontVariant && !this._fontVariant.isReady && this._fontVariant.removeEventListener("ready", this._handleFontReadyClosure), this._value && this._value instanceof O)
      this._fontVariant = this._value;
    else {
      const s = e._fontFamily._value;
      s && (this._fontVariant = s.getVariant(
        e._fontWeight._value,
        e._fontStyle._value
      ));
    }
    this._fontVariant && (this._fontVariant._alterElementProperties(e), this._handleFontReadyClosure = ci(e, this), this._fontVariant.isReady ? this._handleFontReadyClosure() : this._fontVariant.addEventListener("ready", this._handleFontReadyClosure), (!e._fontMaterial._defaultMaterial || !(e._fontMaterial._defaultMaterial instanceof this._fontVariant.fontMaterial)) && (e._fontMaterial._defaultMaterial = new this._fontVariant.fontMaterial(), e._fontMaterial._needsUpdate = !0));
  }
  /**
   * @override
   * @param {FontVariant} value
   */
  set value(e) {
    this.isValid(e) && this._value !== e && (this._value = e, this._needsUpdate = !0);
  }
  /**
   *
   * @return {FontVariant}
   */
  get value() {
    return this._value;
  }
  /**
   *
   * @return {FontVariant|null}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  /**
   *
   */
  dispose() {
    this._handleFontReadyClosure && (this._fontVariant.removeEventListener("ready", this._handleFontReadyClosure), this._handleFontReadyClosure = null), this._value = null, this._fontVariant = null;
  }
}
function li(i) {
  return i instanceof O ? !0 : (console.warn(`.font value '${i}' is not valid. It requires a FontVariant instance. Aborted`), !1);
}
function ci(i, e) {
  return function() {
    e._needsUpdate = !0, i._glyphs._needsProcess = !0, e._fontVariant.removeEventListener("ready", e._handleFontReadyClosure), e._handleFontReadyClosure = null;
  };
}
class di extends g {
  constructor(e) {
    super("display", e), this._value = "flex", this._allowsInherit = !1, this._needsUpdate = !1, this.isValidValue = fi;
  }
  computeOutputValue(e) {
    e._visible._value = this._output !== "none";
  }
}
const _i = ["none", "flex"];
function fi(i) {
  return _i.indexOf(i) === -1 ? (console.warn(`(.style) display value '${i}' is not valid. Aborted`), !1) : !0;
}
class pi extends g {
  constructor(e) {
    super("boxSizing", e), this._allowsInherit = !1, this.isValidValue = mi;
  }
  computeOutputValue(e) {
    this._value = this._inheritedInput, e._bounds._needsUpdate = !0;
  }
}
const gi = ["border-box", "content-box"];
function mi(i) {
  return gi.indexOf(i) === -1 ? (console.warn(`(.style) boxSizing value '${i}' is not valid. Aborted`), !1) : !0;
}
class U extends g {
  constructor(e, t) {
    super(e, t, !1), this._value = new u.Color(), this.output = this._outputValue;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @override
   */
  computeOutputValue(e) {
    this._input !== "inherit" && this._value.set(this._input);
  }
  set inline(e) {
    this._input = this._inline = e, this._needsUpdate = !0;
  }
}
class Z extends g {
  /**
   *
   * @param {string} propertyId
   * @param {any} defaultValue
   */
  constructor(e, t) {
    super(e, t, !0), this.isValidValue = vi, this._allowsInherit = !1, this._input = t, this._value = t, this.output = this._outputValue, this.computeOutputValue = this._computeFromInherited;
  }
  _outputValue(e) {
    e[this._id] = this._inheritedInput;
  }
}
function vi(i) {
  return i < 0 && i > 1 ? (console.warn(`(.style) styleFactorProperty('${this.id}') value '${i}' is not valid)`), !1) : !0;
}
class yi extends g {
  constructor(e) {
    super("backgroundImage", e, !0), this._input = null, this._allowsInherit = !1, this._textureSize = new u.Vector2(1, 1), this.isValidValue = bi;
  }
  /**
   * @override
   * @return {any|Texture|null}
   */
  get value() {
    return this._value;
  }
  output(e) {
    e[this._id] = this._value, e.tSize = this._textureSize;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(e) {
    if (this._value = this._inheritedInput, this._value instanceof u.Texture && !this._value.image) {
      console.warn("ThreeMeshUI - .backgroundImage :: Please provide preloaded texture in order to have accurate sizing.");
      return;
    }
    this._needsProcess = !0;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   */
  process(e) {
    this._value ? this._textureSize.set(this._value.image.width, this._value.image.height) : this._textureSize.set(1, 1);
  }
}
function bi(i) {
  return !0;
}
class xi extends g {
  constructor(e) {
    super("backgroundSize", e, !0), this.isValidValue = Si, this.output = this._outputValue;
  }
}
const wi = ["cover", "contain", "stretch"];
function Si(i) {
  return wi.indexOf(i) === -1 ? (console.warn(`(.style) backgroundSize value '${i}' is not valid. Aborted`), !1) : !0;
}
class Vi extends g {
  constructor(e) {
    super("overflow", e, !0), this.isValidValue = Pi, this._clippingPlanes = null, this._renderStrategy = this._emptyRender;
  }
  /**
   * Update of overflow is a bit different, as parent may trigger changes on it
   * @override
   */
  update(e, t) {
    this._inline !== void 0 && this._inline !== "unset" ? this._input = this._inline : this._computed !== void 0 && (this._input = this._computed), this._allowsInherit || (this._inheritedInput = this.getInheritedInput(e)), this.computeOutputValue(e);
    for (const s of e._children._uis)
      s._overflow._needsUpdate = !0;
    this.output(t);
  }
  output(e) {
    e.clippingPlanes = this._clippingPlanes;
  }
  computeOutputValue(e) {
    super.computeOutputValue(e), this._value === "hidden" ? this._renderStrategy = this._propagateRender : (this._renderStrategy = this._emptyRender, this._clippingPlanes = null);
    const t = e._parent._value;
    if (t !== null) {
      const s = t._overflow;
      if ((s._value === "hidden" || s._clippingPlanes !== null) && !this._clippingPlanes) {
        this._clippingPlanes = [
          // top
          new u.Plane(new u.Vector3(0, -1, 0), 1),
          // right
          new u.Plane(new u.Vector3(-1, 0, 0), 1),
          // bottom
          new u.Plane(new u.Vector3(0, 1, 0), 1),
          // left
          new u.Plane(new u.Vector3(1, 0, 0), 1)
        ];
        for (let r = 0; r < this._clippingPlanes.length; r++)
          this._clippingPlanes[r].parent = t;
        s._clippingPlanes !== null && this._clippingPlanes.push(...s._clippingPlanes), this._renderStrategy = this._hiddenRender, this._needsRender = !0;
      } else (s._value === "visible" || s._clippingPlanes === null) && this._clippingPlanes !== null && (this._clippingPlanes = null, this._renderStrategy = this._emptyRender, this._needsRender = !0);
    }
  }
  render(e) {
    this._renderStrategy(e);
  }
  /* eslint-disable no-unused-vars */
  _emptyRender(e) {
  }
  _hiddenRender(e) {
    const t = e._parent._value, s = t._bounds._offsetHeight, r = t._bounds._offsetWidth, n = t._padding._value, o = t._borderWidth._value;
    for (let a = 0; a < 4 && a < this._clippingPlanes.length; a++) {
      const l = this._clippingPlanes[a];
      switch (a % 4) {
        // top
        case 0:
          l.constant = s / 2 - (n.x + o.x);
          break;
        // right
        case 1:
          l.constant = r / 2 - (n.y + o.y);
          break;
        // bottom
        case 2:
          l.constant = s / 2 - (n.z + o.z);
          break;
        // left
        case 3:
          l.constant = r / 2 - (n.w + o.w);
          break;
      }
      l.applyMatrix4(t.matrixWorld);
    }
    for (let a = 0; a < e._children._uis.length; a++) {
      const l = e._children._uis[a];
      l._overflow._needsRender = !0;
    }
  }
  _propagateRender(e) {
    for (let t = 0; t < e._children._uis.length; t++) {
      const s = e._children._uis[t];
      s._overflow._needsRender = !0;
    }
  }
}
const ki = ["visible", "hidden"];
function Pi(i) {
  return ki.indexOf(i) === -1 ? (console.warn(`(.style) overflow value '${i}' is not valid. Aborted`), !1) : !0;
}
const R = "rem", We = "em", G = "%", Ii = [R, We, G], Ee = function(i) {
  return Ii.indexOf(i) === -1 ? R : i;
};
class Ci extends j {
  /**
   *
   * @param {Vector4} defaultValue
   */
  constructor(e) {
    super("borderRadius", e), this._valueUV = this._value.clone(), this._input = new u.Vector4(0, 0, 0, 0), this._mediation = !0, this._cornerTL = new u.Vector2(0, 1), this._cornerTR = new u.Vector2(1, 1), this._cornerBR = new u.Vector2(1, 0), this._cornerBL = new u.Vector2(0, 0);
    const t = new W(this._valueUV, ["x", "y"]), s = new W(this._valueUV, ["z", "w"]), r = new W(this._valueUV, ["x", "w"]), n = new W(this._valueUV, ["y", "z"]);
    t.complementaryMediation = s, s.complementaryMediation = t, r.complementaryMediation = n, n.complementaryMediation = r, this._sideMediators = [t, s, r, n], this._units = R;
  }
  /**
   *
   * @param {string} units
   */
  set units(e) {
    this._units = Ee(e), this._needsProcess = !0;
  }
  /**
   *
   * @returns {string}
   */
  get units() {
    return this._units;
  }
  /**
   *
   * @param {boolean} v
   */
  set mediation(e) {
    e !== this._mediation && (this._mediation = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {boolean}
   */
  get mediation() {
    return this._mediation;
  }
  /**
   *
   * @param {Object.<string,any>} out
   */
  output(e) {
    e.cornerTL = this._cornerTL, e.cornerTR = this._cornerTR, e.cornerBR = this._cornerBR, e.cornerBL = this._cornerBL;
  }
  /**
   *
   * @override
   */
  /* eslint-disable no-unused-vars */
  computeOutputValue(e) {
    this._vector4ValueSetter(this._value, this._input), this._needsProcess = !0;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   */
  process(e) {
    this._needsRender = !0;
  }
  /**
   *
   * @override
   */
  render(e) {
    this._valueUV.copy(this._value);
    const t = e._bounds._offsetWidth, s = e._bounds._offsetHeight;
    if (this._units === G && this._valueUV.divideScalar(100), this._units === R && this._valueUV.divideScalar(Math.min(t, s)), this._mediation)
      do
        this._sideMediators.forEach((o) => o.computeValue()), this._sideMediators.sort((o, a) => o.value < a.value ? 1 : -1), this._sideMediators[0].value > 1 && this._sideMediators[0].mediate();
      while (this._sideMediators[0].value > 1);
    let r = t > s ? s / t : 1, n = t < s ? t / s : 1;
    this._units === G && (r = n = 1), this._cornerTL.x = this._valueUV.x * r, this._cornerTL.y = 1 - this._valueUV.x * n, this._cornerTR.x = 1 - this._valueUV.y * r, this._cornerTR.y = 1 - this._valueUV.y * n, this._cornerBR.x = 1 - this._valueUV.z * r, this._cornerBR.y = this._valueUV.z * n, this._cornerBL.x = this._valueUV.w * r, this._cornerBL.y = this._valueUV.w * n;
  }
  /**
   *
   */
  dispose() {
    for (const e of this._sideMediators)
      e.dispose();
    this._sideMediators = null, this._cornerTL = null, this._cornerTR = null, this._cornerBR = null, this._cornerBL = null, super.dispose();
  }
  /**
   *
   * @param {Number} v
   */
  set topLeft(e) {
    this._input.x !== e && (this._input.x = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {number}
   */
  get topLeft() {
    return this._input.x;
  }
  /**
   *
   * @param {Number} v
   */
  set topRight(e) {
    this._input.y !== e && (this._input.y = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {number}
   */
  get topRight() {
    return this._input.y;
  }
  /**
   *
   * @param {Number} v
   */
  set bottomRight(e) {
    this._input.z !== e && (this._input.z = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {number}
   */
  get bottomRight() {
    return this._input.z;
  }
  /**
   *
   * @param {Number} v
   */
  set bottomLeft(e) {
    this._input.w !== e && (this._input.w = e, this._needsUpdate = !0);
  }
  /**
   *
   * @returns {number}
   */
  get bottomLeft() {
    return this._input.w;
  }
  /**
   * @override
   * @param {Number} v
   */
  set top(e) {
    this._input.x === e && this._input.y === e || (this._input.x = this._input.y = e, this._needsUpdate = !0);
  }
  /**
   * @override
   * @returns {number}
   */
  get top() {
    return (this._input.x + this._input.y) / 2;
  }
  /**
   * @override
   * @param {Number} v
   */
  set right(e) {
    this._input.y === e && this._input.z === e || (this._input.y = this._input.z = e, this._needsUpdate = !0);
  }
  /**
   * @override
   * @returns {number}
   */
  get right() {
    return (this._input.y + this._input.z) / 2;
  }
  /**
   * @override
   * @param {Number} v
   */
  set bottom(e) {
    this._input.z === e && this._input.w === e || (this._input.z = this._input.w = e, this._needsUpdate = !0);
  }
  /**
   * @override
   * @returns {number}
   */
  get bottom() {
    return (this._input.z + this._input.w) / 2;
  }
  /**
   * @override
   * @param {Number} v
   */
  set left(e) {
    this._input.w === e && this._input.x === e || (this._input.w = this._input.x = e, this._needsUpdate = !0);
  }
  /**
   * @override
   * @returns {number}
   */
  get left() {
    return (this._input.w + this._input.x) / 2;
  }
}
class W {
  /**
   *
   * @param {Vector4} borderRadiuses
   * @param {Array.<string>} sideProperties
   */
  constructor(e, t) {
    this._borderRadiuses = e, this._sideProperties = t, this._complementaryMediation = null, this._value = 0;
  }
  /**
   * The sum of the border radius of that side
   * @returns {number}
   */
  get value() {
    return this._value;
  }
  /**
   * A complementary side mediation ie: For top, complementary is bottom
   * @param {BorderRadiusMediator} brm
   */
  set complementaryMediation(e) {
    this._complementaryMediation = e;
  }
  /**
   * Adds all side property to compute the value of that side
   */
  computeValue() {
    let e = 0;
    for (const t of this._sideProperties)
      e += this._borderRadiuses[t];
    this._value = e;
  }
  /**
   *
   * @param {boolean} [mediateOpposite=true]
   */
  mediate(e = !0) {
    if (!(this._value < 1)) {
      for (const t of this._sideProperties)
        this._borderRadiuses[t] /= this._value;
      e && this._complementaryMediation.mediate(!1);
    }
  }
  /**
   *
   */
  dispose() {
    this._complementaryMediation = null, this._borderRadiuses = null;
  }
}
class Ri extends j {
  /**
   *
   * @param defaultValue
   */
  constructor(e) {
    super("borderWidth", e, !1), this._valueUV = this._value.clone(), this.output = this._outputValue, this._units = R;
  }
  /**
   *
   * @param {string} units
   */
  set units(e) {
    this._units = Ee(e), this._needsUpdate = !0;
  }
  /**
   *
   * @returns {string}
   */
  get units() {
    return this._units;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   */
  computeOutputValue(e) {
    this._vector4ValueSetter(this._value, this._input), this._needsProcess = !0, e._bounds._needsUpdate = !0, e._layouter._needsUpdate = !0;
  }
  _outputValue(e) {
    e[this._id] = this._valueUV;
  }
  /**
   *
   * @override
   */
  process(e) {
    this._needsRender = !0, e._borderRadius._needsRender = !0;
  }
  /**
   * @override
   */
  render(e) {
    this._valueUV.copy(this._value);
    const t = e._bounds._offsetWidth, s = e._bounds._offsetHeight;
    if (this._units === G && (console.log("Percent"), console.log(this._valueUV)), this._units === R)
      t !== 0 && (this._valueUV.w /= t, this._valueUV.y /= t), s !== 0 && (this._valueUV.x /= s, this._valueUV.z /= s);
    else if (this._units === We) {
      if (t !== 0) {
        const r = t > s ? s / t : 1;
        this._valueUV.y *= r, this._valueUV.w *= r;
      }
      if (s !== 0) {
        const r = t < s ? t / s : 1;
        this._valueUV.x *= r, this._valueUV.z *= r;
      }
    }
  }
}
class Bi extends p {
  /**
   *
   * @param {string} propertyId
   * @param {any} [value=null]
   */
  constructor(e, t = !0) {
    super("visible", t, !0), this._needsUpdate = !1;
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    e.visible = this._value, e._parent._value && (e._parent._value._children._needsUpdate = !0);
  }
  set value(e) {
    this.isValid(e) && this._value !== e && (this._value = e, this._needsUpdate = !0);
  }
  /**
   *
   * @return {boolean}
   */
  get value() {
    return this._value;
  }
}
class De extends U {
  constructor(e) {
    super("backgroundColor", e, !1), this._input = "transparent", this._allowsInherit = !1;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(e) {
    e._backgroundMesh.visible = !(this._input === "none" || this._input === "transparent"), this._input === "inherit" ? this._value.set(this.getInheritedInput(e)) : this._input === "transparent" || this._input === "none" || this._value.set(this._input);
  }
}
class P extends p {
  /**
   *
   * @param {string} propertyId
   */
  constructor(e = "untitled") {
    super(e, void 0, !1);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   * @param {Object.<string,any>} out
   */
  update(e, t) {
  }
  /* eslint-disable no-unused-vars */
  /**
   * Output this property in a dictionnary
   * @param {Object.<string,any>} out
   */
  output(e) {
  }
}
class Ui extends p {
  constructor() {
    super("inlineJustificator", null, !1), this._value = null;
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
  }
  /**
   *
   * @override
   */
  process(e) {
    const t = e._bounds._innerHeight, s = e._layouter._value, r = Math.abs(s.height);
    let n = (() => {
      switch (e._alignItems._value) {
        case "inherit":
        case "start":
          return t / 2;
        case "end":
          return r - t / 2;
        case "stretch":
        // @TODO : Stretch should trigger an error in own property
        case "center":
          return r / 2;
      }
    })();
    const o = e._padding._value, a = e._borderWidth._value;
    n += (-o.x + o.z) / 2 + (-a.x + a.z) / 2, s.forEach((l) => {
      l.y += n, l.forEach((d) => {
        d.offsetY += n;
      });
    });
  }
}
const Ai = ["start", "center", "end", "stretch"], Ti = function(i) {
  return Ai.indexOf(i) === -1 ? (console.warn(`(.style) alignItems value '${i}' is not valid. Aborted`), !1) : !0;
};
class ue extends g {
  constructor() {
    super("alignItems", "inherit", !0), this.isValidValue = Ti;
  }
}
class he extends g {
  constructor() {
    super("textAlign", "inherit", !0), this.isValidValue = Fi;
  }
}
const Mi = ["left", "right", "center", "justify", "justify-left", "justify-right", "justify-center"], Fi = function(i) {
  return Mi.indexOf(i) === -1 ? (console.warn(`(.style) textAlign value '${i}' is not valid. Aborted`), !1) : !0;
};
class le extends g {
  constructor() {
    super("flexDirection", "inherit", !0), this.isValid = Li;
  }
}
const Oi = ["row", "row-reverse", "column", "column-reverse"];
function Li(i) {
  return Oi.indexOf(i) === -1 ? (console.warn(`(.style) flexDirection value '${i}' is not valid. Aborted`), !1) : !0;
}
class ce extends g {
  constructor() {
    super("justifyContent", "inherit", !0), this.isValidValue = Wi;
  }
}
const zi = ["start", "center", "end", "space-between", "space-around", "space-evenly"];
function Wi(i) {
  return zi.indexOf(i) === -1 ? (console.warn(`(.style) justifyContent value '${i}' is not valid. Aborted`), !1) : !0;
}
class Ei extends g {
  constructor() {
    super("order", 0, !0), this._value = 0, this._input = 0, this._allowsInherit = !1;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(e) {
    this._value = this._inheritedInput, e._parent._value && (e._parent._value._children._needsProcess = !0);
  }
}
class He extends g {
  constructor() {
    super("position", "static", !0), this._allowsInherit = !1, this._value = "static", this._needsUpdate = !1, this.computeOutputValue = this._computeFromInherited, this.isValidValue = Hi;
  }
  _computeFromInherited(e) {
    super._computeFromInherited(e), e._parent._value && (e._parent._value._children._needsProcess = !0);
  }
}
const Di = ["static", "absolute"];
function Hi(i) {
  return Di.indexOf(i) === -1 ? (console.warn(`(.style) position value '${i}' is not valid. Aborted`), !1) : !0;
}
class Ge extends g {
  /**
   *
   * @param {string} propertyId
   * @param {number} defaultValue
   */
  constructor(e, t = null) {
    super(e, t, !0), this._input = "auto", this._auto = !0, this._relative = !1, this._updateRequired = !0;
  }
  /**
   *
   * @param {any} value
   */
  set inline(e) {
    this.isValidValue(e) && e !== this._inline && (this._inline = e, this._input !== this._inline && this._parseInput());
  }
  get inline() {
    return this._inline;
  }
  _parseInput() {
    let e = !0;
    if (this._inline !== void 0 && this._inline !== "unset" ? this._input = this._inline : this._computed !== void 0 ? (this._computed === this._input && (e = !1), this._input = this._computed) : e = this._input === "inherit", e) {
      if (this._auto = !this._input || this._input === "auto", this._auto)
        this._relative = !1;
      else if ((typeof this._input == "string" || this._input instanceof String) && this._input.endsWith("%")) {
        this._relative = !0, this._value = 0;
        const t = parseFloat(this._input.replace("%", "").trim());
        isNaN(t) || (this._value = t / 100);
      } else
        this._relative = !1, this._value = this._input;
      this._needsUpdate = this._updateRequired = e;
    }
  }
  update(e, t) {
    if (this._updateRequired) {
      this._updateRequired = !1, this._allowsInherit || (this._inheritedInput = this.getInheritedInput(e)), this.computeOutputValue(e);
      for (const s of e._children._uis)
        s[`_${this._id}`]._needsUpdate = !0;
      this.output(t), e._parent._value && (e._parent._value._layouter._needsProcess = !0);
    }
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(e) {
    e._bounds._needsUpdate = !0, e._renderer._needsRender = !0;
  }
  getInheritedInput(e) {
    if (this._input !== "inherit" && !this._auto) return this._input;
    const t = e._parent._value;
    return t ? t[`_${this._id}`].getInheritedInput(t) : this.getDefaultValue();
  }
  getDefaultValue() {
    return 0;
  }
  /**
   *
   * @return {number}
   */
  get value() {
    return this._value;
  }
}
class Gi extends Ge {
  constructor() {
    super("width");
  }
}
class $i extends Ge {
  constructor() {
    super("height");
  }
  computeOutputValue(e) {
    super.computeOutputValue(e);
  }
}
class $e extends P {
  constructor() {
    super("textContent"), this._needsUpdate = !1;
  }
  /* eslint-disable no-unused-vars */
  set value(e) {
  }
  /* eslint-disable no-unused-vars */
  process(e) {
    let t = "";
    for (let s = 0; s < e.children.length; s++) {
      const r = e.children[s];
      r.isUI && (t += r.textContent);
    }
    this._value = t;
  }
}
class Ne extends g {
  constructor(e) {
    super("fontStyle", e, !0), this.isValidValue = Xi;
  }
}
const Ni = ["normal", "italic"];
function Xi(i) {
  return Ni.indexOf(i) === -1 ? (console.warn(`(.style) fontStyle value '${i}' is not valid. Aborted`), !1) : !0;
}
class Xe extends g {
  constructor() {
    super("fontWeight", "inherit", !0), this.isValid = Yi;
  }
}
const ji = ["100", "200", "300", "400", "500", "600", "700", "800", "900", "light", "normal", "bold", "bolder"];
function Yi(i) {
  return ji.indexOf(i.toString()) === -1 ? (console.warn(`(.style) fontWeight value '${i}' is not valid. Aborted`), !1) : !0;
}
class je {
  constructor() {
    this._size = 42, this._lineHeight = 42, this._lineBase = 38, this._name = "-", this._charset = "";
  }
  /**
   *
   * @returns {number}
   */
  get size() {
    return this._size;
  }
  /**
   *
   * @returns {number}
   */
  get lineHeight() {
    return this._lineHeight;
  }
  /**
   *
   * @returns {number}
   */
  get lineBase() {
    return this._lineBase;
  }
  /**
   *
   * @returns {string}
   */
  get name() {
    return this._name;
  }
  /**
   *
   * @returns {string}
   */
  get charset() {
    return this._charset;
  }
}
class Ki extends je {
  /**
   *
   * @param {import('./MSDFFontVariant').MSDFJson} json
   */
  constructor(e) {
    super(), this._size = e.info.size, this._lineHeight = e.common.lineHeight, this._lineBase = e.common.base, this._name = e.info.face, this._textureWidth = e.common.scaleW, this._textureHeight = e.common.scaleH, this._charset = e.chars.map((t) => t.char).join("");
  }
  /**
   *
   * @returns {number}
   */
  get textureWidth() {
    return this._textureWidth;
  }
  /**
   *
   * @returns {number}
   */
  get textureHeight() {
    return this._textureHeight;
  }
}
class qi extends ze {
  /**
   *
   * @param {MSDFTypographicGlyph} characterDesc
   */
  constructor(e) {
    super(e);
  }
  /**
   *
   * @returns {{left:number, right:number, top:number, bottom:number}|null}
   */
  get uv() {
    return this.typographic.uv;
  }
}
class $ extends Le {
  /**
   * @param {MSDFTypographicFont} fontDescription
   * @param {import('./MSDFFontVariant').MSDFJsonChar} characterData
   */
  constructor(e, t) {
    super(e), this._char = t.char, this._width = t.width, this._heigth = t.height, this._xadvance = t.xadvance ? t.xadvance : this._width, this._xoffset = t.xoffset ? t.xoffset : 0, this._yoffset = t.yoffset ? t.yoffset : 0, this._uv = t.uv ? t.uv : null, isNaN(t.x) || (this._uv = {
      left: t.x / e.textureWidth,
      right: (t.x + t.width) / e.textureWidth,
      top: 1 - (t.y + t.height) / e.textureHeight,
      bottom: 1 - t.y / e.textureHeight
    });
  }
  /**
   *
   * @returns {{left: number, right: number, top: number, bottom: number}|null}
   */
  get uv() {
    return this._uv;
  }
  /**
   * @override
   * @param {string} otherChar
   * @returns {MSDFTypographicGlyph}
   */
  clone(e) {
    return new $(this._font, {
      char: e,
      width: this._width,
      height: this._heigth,
      xadvance: this._xadvance,
      xoffset: this._xoffset,
      yoffset: this._yoffset,
      // Msdf requires uvs
      uv: null
    });
  }
  /**
   * @override
   * @returns {MSDFInlineGlyph}
   */
  asInlineGlyph() {
    return new qi(this);
  }
}
class Ji extends u.PlaneGeometry {
  /**
   *
   * @param {MSDFInlineGlyph} inline
   * @param {MeshUIBaseElement} element
   */
  constructor(e, t) {
    let s = 1, r = 1;
    const n = e.typographic.font.size, o = t._segments.value;
    s = Math.ceil(e.typographic.width / n * o), r = Math.ceil(e.typographic.height / n * o), super(e.width, e.height, s, r), e.uv ? (this._mapUVs(e), this._transformGeometry(e)) : (this._nullifyUVs(), this.scale(0, 0, 1), this.translate(0, e.fontSize / 2, 0)), this.name = "GlyphGeometry";
  }
  /**
   * Compute the right UVs that will map the MSDF texture so that the passed character
   * will appear centered in full size
   * @param {MSDFInlineGlyph} inline
   * @private
   */
  _mapUVs(e) {
    const t = e.uv.right - e.uv.left, s = e.uv.bottom - e.uv.top, r = this.getAttribute("uv").array.slice(), n = [];
    for (let o = 0; o < r.length; o += 2) {
      const a = r[o], l = r[o + 1];
      n.push(e.uv.left + t * a), n.push(e.uv.top + s * l);
    }
    this.setAttribute("uvG", new u.BufferAttribute(new Float32Array(n), 2));
  }
  /**
   * Set all UVs to 0, so that none of the glyphs on the texture will appear
   * @private
   * */
  _nullifyUVs() {
    const e = [], t = this.getAttribute("uv").array.length;
    for (let s = 0; s < t; s++)
      e.push(0);
    this.setAttribute("uvG", new u.BufferAttribute(new Float32Array(e), 2));
  }
  /**
   *
   * @TODO: Apply pivot properties when splitText isset
   * Gives the previously computed scale and offset to the geometry
   * @param {MSDFInlineGlyph} inline
   * @private
   */
  _transformGeometry(e) {
    this.translate(
      e.width / 2,
      -e.height / 2,
      0
    );
  }
}
const Zi = (
  /* glsl */
  `
attribute vec2 uvG;
varying vec2 vUvG;
`
), de = Zi, Qi = (
  /* glsl */
  `
vUvG = uvG;
`
), _e = Qi, es = (
  /* glsl */
  `
gl_Position.z -= 0.00001;
`
), fe = es, ts = (
  /* glsl */
  `
varying vec2 vUvG;
uniform sampler2D glyphMap;
uniform vec2 unitRange;
// functions from the original msdf repo:
// https://github.com/Chlumsky/msdfgen#using-a-multi-channel-distance-field
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
float screenPxRange() {

	// precomputed unitRange as recommended by Chlumsky
	// vec2 unitRange = vec2(pxRange)/vec2(textureSize(glyphMap, 0));
	vec2 screenTexSize = vec2(1.0)/fwidth(vUvG);
	return max(0.5*dot(unitRange, screenTexSize), 1.0);
}
float tap(vec2 offsetUV) {
	vec3 msd = texture( glyphMap, offsetUV ).rgb;
	float sd = median(msd.r, msd.g, msd.b);
	float screenPxDistance = screenPxRange() * (sd - 0.5);
	float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
	return alpha;
}
`
), pe = ts, is = (
  /* glsl */
  `
	float alpha;
#ifdef NO_RGSS

	alpha = tap( vUvG );

#else

	// shader-based supersampling based on https://bgolus.medium.com/sharper-mipmapping-using-shader-based-supersampling-ed7aadb47bec
	// per pixel partial derivatives
	vec2 dx = dFdx(vUvG);
	vec2 dy = dFdy(vUvG);
	// rotated grid uv offsets
	vec2 uvOffsets = vec2(0.125, 0.375);
	vec2 offsetUV = vec2(0.0, 0.0);
	// supersampled using 2x2 rotated grid
	alpha = 0.0;
	offsetUV.xy = vUvG + uvOffsets.x * dx + uvOffsets.y * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG - uvOffsets.x * dx - uvOffsets.y * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG + uvOffsets.y * dx - uvOffsets.x * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG - uvOffsets.y * dx + uvOffsets.x * dy;
	alpha += tap(offsetUV);
	alpha *= 0.25;

#endif

	alpha = clamp( alpha, 0.0, 1.0 );

#ifdef INVERT_ALPHA

	alpha = 1.0 - alpha;

#endif

	diffuseColor.a *= alpha;
`
), ge = is, Y = function(i, e, t) {
  i.alphaTest = t, me(i, "USE_ALPHATEST", t > 0);
}, me = function(i, e, t) {
  i.defines && (t ? i.defines[e] === void 0 && (i.defines[e] = "", i.needsUpdate = !0) : i.defines[e] !== void 0 && (delete i.defines[e], i.needsUpdate = !0));
}, Ye = function(i, e, t) {
  i.defines[e] && i.defines[e] === t || (i.defines[e] = t, i.needsUpdate = !0);
}, x = function(i, e, t) {
  i.userData[e] ? i.userData[e].value = t : i.uniforms[e].value = t;
}, ss = function(i, e, t) {
  i.userData[e].value = t;
};
class w {
  /**
   * Alter a material options with required fontMaterial options and or default values
   * @param {Object.<string,any>} materialOptions
   */
  static ensureMaterialOptions(e) {
    e.transparent = !0, e.alphaTest = e.alphaTest || 0.02;
  }
  /**
   * As three-mesh-ui FontMaterial relies on webgl preprocessors,
   * lets force the material to have a proper defines object
   * @param {Material|ShaderMaterial} threeMaterial
   */
  static ensureDefines(e) {
    e.defines || (e.defines = {});
  }
  /**
   *
   * @param {Material|ShaderMaterial} threeMaterial
   * @param {Object.<string,any>} materialOptions
   */
  static ensureUserData(e, t) {
    e.userData.glyphMap = { value: t.glyphMap }, e.userData.unitRange = { value: new u.Vector2() };
  }
  /**
   *
   * @param {any} shader
   * @param {Material|ShaderMaterial} threeMaterial
   */
  static bindUniformsWithUserData(e, t) {
    e.uniforms.glyphMap = t.userData.glyphMap, e.uniforms.unitRange = t.userData.unitRange;
  }
  /**
   *
   * @param shader
   */
  static injectShaderChunks(e) {
    w.injectVertexShaderChunks(e), w.injectFragmentShaderChunks(e);
  }
  /**
   *
   * @param shader
   */
  static injectVertexShaderChunks(e) {
    e.vertexShader = e.vertexShader.replace(
      "#include <uv_pars_vertex>",
      `#include <uv_pars_vertex>
` + de
    ), e.vertexShader = e.vertexShader.replace(
      "#include <uv_vertex>",
      `#include <uv_vertex>
` + _e
    ), e.vertexShader = e.vertexShader.replace(
      "#include <project_vertex>",
      `#include <project_vertex>
` + fe
    );
  }
  /**
   *
   * @param shader
   */
  static injectFragmentShaderChunks(e) {
    e.fragmentShader = e.fragmentShader.replace(
      "#include <uv_pars_fragment>",
      `#include <uv_pars_fragment>
` + pe
    ), e.fragmentShader = e.fragmentShader.replace(
      "#include <alphamap_fragment>",
      `#include <alphamap_fragment>
` + ge
    );
  }
  /**
   * Mix a threejs Material into a three-mesh-ui FontMaterial
   * @param {typeof Material|ShaderMaterial} materialClass
   * @returns {typeof Material|ShaderMaterial}
   */
  static from(e) {
    return class extends e {
      /**
       *
       * @abstract
       * @returns {Object.<{m:string, t?:(fontMaterial:Material|ShaderMaterial, materialProperty:string, value:any) => void}>}
       */
      static get fontMaterialProperties() {
        return w.mediation;
      }
      constructor(t = {}) {
        w.ensureMaterialOptions(t), super(t), w.ensureDefines(this), w.ensureUserData(this, t), this._userDefinedOnBeforeCompile = (s) => {
        }, this._onBeforeCompile = this._cumulativeOnBeforeCompile;
      }
      ////////////////////////////
      // OnBeforeCompile Override
      ///////////////////////////
      /**
       * Override the setter of onBeforeCompile in order to never overwrite
       * the three-mesh-ui fontMaterial onBeforeCompile
       * @param { (shader:any) => void }fct
       */
      set onBeforeCompile(t) {
        this._userDefinedOnBeforeCompile = t;
      }
      /**
       * Override the getter of onBeforeCompile in order to
       * always deliver the cumulativeCallbacks to threejs
       * @returns { (shader:any) => void }
       */
      get onBeforeCompile() {
        return this._onBeforeCompile;
      }
      /**
       *
       * On before compile that first run three-mesh-ui fontMaterial
       * then user defined onBeforeCompile
       * @param shader
       * @private
       */
      _cumulativeOnBeforeCompile = (t) => {
        w.bindUniformsWithUserData(t, this), w.injectShaderChunks(t), this._userDefinedOnBeforeCompile(t);
      };
    };
  }
  /**
   *
   * @returns {Object<{m: string, t?: (function((Material|ShaderMaterial), string, *): void)}>}
   */
  static get mediation() {
    return os;
  }
}
const rs = function(i, e, t) {
  const s = t ? t.texture : null, r = t ? t.unitRange : new u.Vector2();
  if (i[e] !== void 0) {
    i.glyphMap = s, i.unitRange = r;
    return;
  }
  i.userData && i.userData.glyphMap && (i.userData.glyphMap.value = s, i.userData.unitRange.value = r);
}, ns = function(i, e, t) {
  t && t !== "antialiased" ? i.defines.NO_RGSS = "" : delete i.defines.NO_RGSS, i.needsUpdate = !0;
}, os = {
  clippingPlanes: { m: "clippingPlanes" },
  fontAlphaTest: { m: "alphaTest", t: Y },
  fontSide: { m: "side" },
  font: { m: "glyphMap", t: rs },
  color: { m: "color" },
  fontOpacity: { m: "opacity" },
  fontSmooth: { m: "NO_RGSS", t: ns },
  invertAlpha: { m: "INVERT_ALPHA", t: me }
}, as = (
  /* glsl */
  `
${de}
#include <clipping_planes_pars_vertex>
void main() {
	${_e}
	#include <begin_vertex>
	#include <project_vertex>
	${fe}
	#include <clipping_planes_vertex>
}
`
), us = (
  /* glsl */
  `
uniform vec3 diffuse;
uniform float opacity;
${pe}
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	// instead of <color_fragment> : vec4 diffuseColor
	vec4 diffuseColor = vec4( diffuse, opacity );
	${ge}
	#include <alphatest_fragment>
	// instead of <output_fragment>
	gl_FragColor = diffuseColor;
	#include <clipping_planes_fragment>
}
`
), hs = 0.02;
class ve extends u.ShaderMaterial {
  /**
   * This static method is mandatory for extending ThreeMeshUI.MSDFFontMaterial
   * It will provide a transfer description for properties from ThreeMeshUI.Text to THREE.Material
   * @see {MSDFFontMaterialUtils.mediation}
   * @returns {Object.<{m:string, t?:(fontMaterial:Material|ShaderMaterial, materialProperty:string, value:any) => void}>}
   */
  static get mediation() {
    return w.mediation;
  }
  constructor(e = {}) {
    super({
      uniforms: {
        glyphMap: { value: null },
        // texture
        diffuse: { value: null },
        // vec3
        opacity: { value: 1 },
        unitRange: { value: new u.Vector2(0, 0) },
        // vec2
        alphaTest: { value: hs }
      },
      transparent: !0,
      clipping: !0,
      vertexShader: as,
      fragmentShader: us,
      extensions: {
        derivatives: !0
      }
    }), this.defines.USE_ALPHATEST = "", this.needsUpdate = !0, this.noRGSS = e.noRGSS || !1;
  }
  /**
   * The color will be the diffuse uniform
   * @returns {Color}
   */
  get color() {
    return this.uniforms.diffuse.value;
  }
  /**
   *
   * @param {Color} v
   */
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  /**
   *
   * @param {number} v
   */
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  /**
   * The color will be the diffuse uniform
   * @returns {number}
   */
  get opacity() {
    return this.uniforms.opacity.value;
  }
  /**
   * The color will be the diffuse uniform
   * @returns {Vector2}
   */
  get unitRange() {
    return this.uniforms.unitRange.value;
  }
  /**
   *
   * @param {Vector2} v
   */
  set unitRange(e) {
    this.uniforms.unitRange.value.copy(e);
  }
  /**
   *
   * @returns {Texture}
   */
  get glyphMap() {
    return this.uniforms.glyphMap.value;
  }
  /**
   *
   * @param {Texture} v
   */
  set glyphMap(e) {
    this.uniforms.glyphMap.value = e;
  }
  /**
   * Is this a default fontMaterial instance
   * @returns {boolean}
   */
  get isDefault() {
    return this.constructor === ve;
  }
  /**
   *
   * @returns {number}
   */
  get alphaTest() {
    return this.uniforms.alphaTest.value;
  }
  /**
   *
   * @param {number} v
   */
  set alphaTest(e) {
    this.uniforms.alphaTest.value = e;
  }
}
class ls extends O {
  constructor(e, t, s, r) {
    if (super(e, t), this._unitRange = new u.Vector2(1, 1), s.pages ? this._buildData(s) : cs(this, s), r instanceof u.Texture)
      this._texture = r, this._buildTexture(r);
    else if (typeof r == "string" || r instanceof String)
      ds(this, r);
    else
      throw new Error(`ThreeMeshUI::MSDFVariant provided 'texture' parameter is '${typeof r}'. Only Texture and String allowed.`);
    this._defaultMaterialClass = ve, this._checkReadiness();
  }
  get texture() {
    return this._texture;
  }
  get unitRange() {
    return this._unitRange;
  }
  /**
   * @param {Function.<Material|ShaderMaterial>} v
   * @override
   */
  set fontMaterial(e) {
    this._defaultMaterialClass = e;
  }
  /**
   *
   * @override
   * @returns {Function.<Material|ShaderMaterial>}
   */
  get fontMaterial() {
    return this._defaultMaterialClass;
  }
  /**
   *
   * @param {MSDFJson} json
   * @private
   */
  _buildData(e) {
    this._font = new Ki(e), this._kernings = this._buildKerningPairs(e), this._chars = this._buildCharacters(e), this._chars[" "] = this._buildCharacterWhite(e), this._chars[`
`] = this._buildCharacterWhite(e, `
`, 1e-3, 1), this._chars["	"] = this._buildCharacterWhite(e, "	", 4, 1), this._size = e.info.size, this._lineHeight = e.common.lineHeight, this._lineBase = e.common.base, this._distanceRange = e.distanceField.distanceRange, this._unitRange = new u.Vector2(this._distanceRange, this._distanceRange).divide(new u.Vector2(e.common.scaleW, e.common.scaleH));
  }
  /**
   *
   * @param texture
   * @private
   */
  _buildTexture(e) {
    e.generateMipmaps = !1, e.minFilter = u.LinearFilter, e.magFilter = u.LinearFilter, e.needsUpdate = !0;
  }
  /**
   * @abstract
   * @protected
   * @param {string} missingChar
   * @returns {string|null}
   */
  _getFallbackCharacter(e) {
    return I.missingCharacter(this, e);
  }
  /**
   *
   * @override
   * @param {import('./../InlineGlyph').default|import('./MSDFInlineGlyph').default} inline
   * @param {import('./../../core/elements/MeshUIBaseElement').default} element
   * @returns {MSDFGeometricGlyph}
   */
  getGeometricGlyph(e, t) {
    return new Ji(e, t);
  }
  /**
   * Abstraction implementation
   *
   * @returns {boolean}
   * @private
   */
  _readyCondition() {
    return this._chars && this._texture && this._texture.image;
  }
  /**
   * Ensure that each font variant has its kerning dictionary
   * @see src/font/msdf/FontVariantMSDF.js for an implementation
   *
   * @param {MSDFJson} json
   * @returns {import('../FontVariant').KerningPairs}
   * @private
   */
  _buildKerningPairs(e) {
    const t = {};
    for (let s = 0; s < e.kernings.length; s++) {
      const r = e.kernings[s];
      if (r.amount === 0) continue;
      const n = String.fromCharCode(r.first, r.second);
      t[n] = r.amount;
    }
    return t;
  }
  /**
   *
   * @param {MSDFJson} json
   * @private
   */
  _buildCharacters(e) {
    const t = {};
    for (let s = 0; s < e.chars.length; s++) {
      const r = e.chars[s];
      t[r.char] = new $(this._font, r);
    }
    return t;
  }
  /**
   *
   * @param {MSDFJson} json
   * @param char
   * @param scaleX
   * @param scaleY
   * @private
   */
  _buildCharacterWhite(e, t = " ", s = 1, r = 1) {
    return new $(
      this._font,
      {
        char: t,
        width: e.info.size / 3 * s,
        height: e.info.size * 0.7 * r
      }
    );
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   * @private
   */
  _alterElementProperties(e) {
  }
}
function cs(i, e) {
  new u.FileLoader().setResponseType("json").load(e, (t) => {
    i._buildData(t), i._checkReadiness();
  });
}
function ds(i, e) {
  i._texture = new u.TextureLoader().load(e, (t) => {
    i._buildTexture(t), i._checkReadiness();
  });
}
class K extends u.EventDispatcher {
  /**
   *
   * @param {string} name
   */
  constructor(e) {
    super(), this._name = e, this._variants = [], this._isReady = !1;
  }
  get isReady() {
    return this._isReady;
  }
  /**
   *
   * @param {string|number} weight
   * @param {string} style
   * @param {string|Object} json
   * @param {string|Texture} texture
   * @param {boolean} [override=false]
   */
  addVariant(e, t, s, r, n = !1) {
    if (n || !this.getVariant(e, t)) {
      this._isReady = !1;
      const o = new ls(e, t, s, r);
      this._variants.push(o), o.isReady ? this._checkReadiness() : o.addEventListener("ready", this._checkReadiness);
    } else
      console.warn(`FontFamily('${this._name}')::addVariant() - Variant(${e}, ${t}) already exists.`);
    return this;
  }
  /**
   *
   * @param {FontVariant} variantImplementation
   * @param {boolean} [override=false]
   */
  addCustomImplementationVariant(e, t = !1) {
    return t || !this.getVariant(e.weight, e.style) ? (this._isReady = !1, this._variants.push(e), e.isReady ? this._checkReadiness() : e.addEventListener("ready", this._checkReadiness)) : console.warn(`FontFamily('${this._name}')::addCustomImplementationVariant() - Variant(${e.weight}, ${e.style}) already exists.`), this;
  }
  /**
   *
   * @param {string|number} weight
   * @param {string} style
   * @returns {FontVariant|null}
   */
  getVariant(e, t) {
    return e = ae(e), this._variants.find((s) => s.weight === e && s.style === t);
  }
  /**
   *
   * @return {string}
   */
  get name() {
    return this._name;
  }
  _checkReadiness = () => {
    this._variants.every((e) => e.isReady) && fs(this);
  };
}
const _s = { type: "ready" };
function fs(i) {
  i._isReady = !0, i.dispatchEvent(_s);
}
const H = {}, ps = function(i) {
  const e = [...arguments];
  e.forEach((s) => {
    if (!(s instanceof K))
      throw new Error(`FontLibrary::prepare() - One of the provided parameter is not a FontFamily. Instead ${typeof s} given.`);
  });
  const t = function() {
    return e.every((s) => s.isReady);
  };
  return new Promise((s, r) => {
    if (t())
      s();
    else
      for (let n = 0; n < e.length; n++) {
        const o = e[n];
        o.isReady || o.addEventListener("ready", () => {
          t() && s();
        });
      }
  });
}, gs = function(i) {
  return H[i] && console.error(`FontLibrary::addFontFamily - Font('${i}') is already registered`), H[i] = new K(i), H[i];
}, ms = function(i) {
  return H[i];
}, vs = function(i) {
  Ke = i;
};
let Ke = function(i, e) {
  return console.error(`The character '${e}' is not included in the font characters set.`), " ";
};
function ys(i, e) {
  return Ke(i, e);
}
const bs = {
  addFontFamily: gs,
  getFontFamily: ms,
  prepare: ps,
  setMissingCharacterHandler: vs,
  missingCharacter: ys
}, I = bs;
class qe extends g {
  constructor() {
    super("fontFamily", "inherit", !0);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   */
  computeOutputValue(e) {
    if (this._input instanceof K)
      this._value = this._input;
    else if (this._input !== "inherit") if (typeof this._input == "string") {
      const t = I.getFontFamily(this._input);
      t ? this._value = t : console.warn(`(.style) fontFamily, the font '${this._input}' is not registered. Aborted.`);
    } else
      console.warn("(.style) fontFamily requires a registered fontFamily instance, or the id of a registered fontFamily."), console.warn("If you want to set a specific font, please use .font property instead.");
  }
  /**
   * @override
   * @return {any|FontFamily|null}
   */
  get value() {
    return this._value;
  }
  getInheritedInput(e) {
    if (this._input !== "inherit") return this._input;
    const t = e._parent._value;
    return t ? t[`_${this._id}`].getInheritedInput(t) : this.getDefaultValue();
  }
}
class Je extends g {
  /**
   *
   */
  constructor() {
    super("lineHeight", "inherit", !0);
  }
  update(e, t) {
    super.update(e, t), e._layouter._needsProcess = !0;
  }
}
class Ze extends g {
  constructor() {
    super("whiteSpace", "inherit"), this.isValidValue = ws;
  }
}
const xs = ["normal", "nowrap", "pre", "pre-line", "pre-wrap"];
function ws(i) {
  return xs.indexOf(i) === -1 ? (console.warn(`(.style) whiteSpace value '${i}' is not valid. Aborted`), !1) : !0;
}
class Qe extends g {
  constructor() {
    super("letterSpacing", "inherit", !0);
  }
}
class Ss extends g {
  constructor() {
    super("fontSize", "inherit", !0);
  }
}
class et extends p {
  constructor() {
    super("segments", 1, !1);
  }
}
class Vs extends C {
  constructor() {
    super("invertAlpha", "inherit");
  }
}
class q extends g {
  constructor() {
    super("fontKerning", "inherit"), this.isValidValue = Ps;
  }
}
const ks = ["normal", "none", "inherit"];
function Ps(i) {
  return ks.indexOf(i) === -1 ? (console.warn(`(.style) fontKerning value '${i}' is not valid. Aborted`), !1) : !0;
}
class E extends C {
  /**
   *
   * @param {string} propertyId
   */
  constructor(e) {
    super(e, "inherit", !0);
  }
}
class Be extends C {
  /**
   *
   * @param {string} propertyId
   */
  constructor(e) {
    super(e, "inherit", !1), this._mediation = {}, this._defaultMaterial = null;
  }
  update(e, t) {
    this._notInheritedValue = this._value, this._notInheritedValue === "inherit" ? this._notInheritedValue = this.getInheritedInput(e) : this.propagate(e), this._notInheritedValue ? this._notInheritedValue.constructor.mediation ? this._mediation = { ...this._notInheritedValue.constructor.mediation } : this._mediation = {
      clippingPlanes: { m: "clippingPlanes" },
      fontAlphaTest: { m: "alphaTest", t: Y },
      fontSide: { m: "side" },
      color: { m: "color" },
      fontOpacity: { m: "opacity" }
    } : this._mediation = {}, e._transferToFontMaterial(), this._outputValue(t);
  }
  /**
   * @override
   */
  getInheritedInput(e) {
    if (this._value !== "inherit") return this._value;
    let t = e, s = null;
    for (; t._parent._value; )
      if (t = t._parent._value, t[`_${this._id}`]._value !== "inherit") {
        s = t[`_${this._id}`]._value;
        break;
      }
    return s !== null ? s : this.getDefaultValue();
  }
  getDefaultValue() {
    return this._defaultMaterial;
  }
}
const Is = function(i, e, t) {
  i.traverse((s) => {
    s.renderOrder = t;
  });
};
class L extends u.Object3D {
  /**
   *
   * @param {Properties} properties
   * @param {Options} values
   */
  constructor(e, t) {
    super(), Object.defineProperties(
      this,
      {
        isUI: {
          configurable: !1,
          enumerable: !0,
          value: !0
        }
      }
    ), this._backgroundMesh = null, this._backgroundMaterial = null, this._backgroundCustomDepthMaterial = null, this._backgroundMaterialMediation = {}, this._backgroundMeshMediation = {
      backgroundCastShadow: { m: "castShadow" },
      backgroundReceiveShadow: { m: "receiveShadow" },
      renderOrder: { m: "renderOrder", t: Is }
    }, this._fontMesh = null, this._fontMaterial = new Be("fontMaterial"), this._fontCustomDepthMaterial = new Be("fontCustomDepthMaterial"), this._fontMeshMediation = {
      fontMaterial: { m: "material" },
      fontCustomDepthMaterial: { m: "customDepthMaterial", t: ti },
      fontCastShadow: { m: "castShadow" },
      fontReceiveShadow: { m: "receiveShadow" },
      renderOrder: { m: "renderOrder" }
    }, this._children = e.children ? new e.children() : new P("children"), this._parent = new ii(), this.addEventListener("added", this._rebuildParentUI), this.addEventListener("removed", this._rebuildParentUI), this._backgroundSide = new Re("backgroundSide"), this._fontSide = new Re("fontSide"), this._backgroundAlphaTest = new Ce("backgroundAlphaTest", 0.02), this._fontAlphaTest = new Ce("fontAlphaTest", 0.02), this._visible = new Bi("visible", !0), this._backgroundCastShadow = new E("backgroundCastShadow"), this._fontCastShadow = new E("fontCastShadow"), this._backgroundReceiveShadow = new E("backgroundReceiveShadow"), this._fontReceiveShadow = new E("fontReceiveShadow"), this._renderOrder = new jt(), this._segments = e.segments ? new e.segments() : new et(), this._bounds = e.bounds ? new e.bounds() : new P("bounds"), this._order = new Ei(), this._padding = new Qt(), this._margin = new ei(), this._position = new He(), this._flexDirection = e.flexDirection ? new e.flexDirection() : new le(), this._justifyContent = e.justifyContent ? new e.justifyContent() : new ce(), this._alignItems = e.alignItems ? new e.alignItems() : new ue(), this._display = new di("flex"), this._boxSizing = new pi("border-box"), this._width = new Gi(), this._height = new $i(), this._backgroundColor = e.backgroundColor ? new e.backgroundColor() : new De(), this._backgroundOpacity = new Z("backgroundOpacity", 0.5), this._backgroundImage = new yi(), this._backgroundSize = new xi("cover"), this._color = e.color ? new e.color() : new U("color", "inherit"), this._fontOpacity = new Z("fontOpacity", "inherit"), this._whiteSpace = e.whiteSpace ? new e.whiteSpace() : new Ze(), this._fontFamily = e.fontFamily ? new e.fontFamily() : new qe(), this._fontStyle = e.fontStyle ? new e.fontStyle() : new Ne("normal"), this._fontWeight = e.fontWeight ? new e.fontWeight() : new Xe(), this._fontSize = e.fontSize ? new e.fontSize() : new Ss(), this._lineHeight = e.lineHeight ? new e.lineHeight() : new Je(), this._fontKerning = e.fontKerning ? new e.fontKerning() : new q(), this._letterSpacing = e.letterSpacing ? new e.letterSpacing() : new Qe(), this._overflow = new Vi("visible"), this._borderRadius = new Ci(0), this._borderWidth = new Ri(0), this._borderColor = new U("borderColor", 16711935), this._borderOpacity = new Z("borderOpacity", 1), this._font = new hi(), this._lineBreak = e.lineBreak ? new e.lineBreak() : new P("lineBreak"), this._textContent = e.textContent ? new e.textContent() : new $e(), this._glyphs = e.glyphs ? new e.glyphs() : new P("glyphs"), this._inlines = e.inlines ? new e.inlines() : new P("inlines"), this._layouter = e.layouter ? new e.layouter() : new P("layouter"), this._inlineJustificator = new Ui(), this._textAlign = e.textAlign ? new e.textAlign() : new he(), this._autoSize = e.autoSize ? new e.autoSize() : new P("autoSize"), this._renderer = e.renderer ? new e.renderer() : new P("renderer"), this._offset = new Yt(), this._invertAlpha = new Vs(), this._fontSmooth = e.fontSmooth ? new e.fontSmooth() : new Kt(), this._components = [
      this._textContent,
      this._children,
      this._parent,
      this._autoSize,
      this._fontFamily,
      this._fontStyle,
      this._fontWeight,
      this._font,
      this._whiteSpace,
      this._glyphs,
      this._inlines,
      this._visible,
      // Meshes interfaces
      this._backgroundSide,
      this._fontSide,
      this._backgroundAlphaTest,
      this._fontAlphaTest,
      this._backgroundCastShadow,
      this._fontCastShadow,
      this._backgroundReceiveShadow,
      this._fontReceiveShadow,
      this._renderOrder,
      this._segments,
      // styles ---;
      this._padding,
      this._margin,
      this._width,
      this._height,
      this._borderWidth,
      this._boxSizing,
      this._bounds,
      this._position,
      this._flexDirection,
      this._justifyContent,
      this._alignItems,
      this._order,
      this._display,
      this._backgroundColor,
      this._backgroundOpacity,
      this._backgroundImage,
      this._backgroundSize,
      this._fontOpacity,
      this._color,
      // font : update order : WhiteSpace > Glyph > Inlines > Kerning > newlineBreakability > LineBreak > FontSize
      // font : process order : ??
      // this._font,
      this._fontSize,
      this._lineHeight,
      this._fontKerning,
      this._letterSpacing,
      this._borderRadius,
      this._borderColor,
      this._borderOpacity,
      // this._styles,
      // styles ---;
      this._lineBreak,
      this._offset,
      this._layouter,
      this._inlineJustificator,
      this._textAlign,
      // !! this._renderer renderer MUST NOT BE in components !!
      this._invertAlpha,
      this._fontSmooth,
      this._fontMaterial,
      this._fontCustomDepthMaterial,
      this._overflow,
      this._renderer
    ], this._onAfterUpdates = [], t.backgroundSide || (t.backgroundSide = 0), t && this.set(t);
  }
  ///////////////
  ///  UPDATE
  ///////////////
  update() {
    const e = {};
    for (const t of this._components)
      t._needsUpdate && (t.update(this, e), t._needsUpdate = !1);
    this._transferToBackgroundMesh(e), this._transferToFontMesh(e), this._transferToBackgroundMaterial(e), this._transferToFontMaterial(e);
    for (const t of this._children._uis)
      t.update();
  }
  process() {
    for (const e of this._children._uis)
      e.process();
    for (const e of this._components)
      e._needsProcess && (e.process(this), e._needsProcess = !1);
  }
  render() {
    for (let e = 0; e < this._components.length; e++) {
      const t = this._components[e];
      t._needsRender && (t.render(this), t._needsRender = !1);
    }
    for (const e of this._children._uis)
      e.render();
  }
  /**
   *
   * @param {Options} options
   */
  set(e) {
    if (e.fontTexture && (console.warn("ThreeMeshUI::set( {fontTexture} ) is deprecated. Please use fontLibrary to register font families and variants."), e.fontFamily)) {
      const t = e.fontFamily.pages ? e.fontFamily.info.face : e.fontFamily;
      let s = I.getFontFamily(t);
      if (!s) {
        const r = e.fontStyle ? e.fontStyle : "normal", n = e.fontWeight ? e.fontWeight : "400";
        s = I.addFontFamily(t).addVariant(n, r, e.fontFamily, e.fontTexture);
      }
      e.fontFamily = s, delete e.fontTexture;
    }
    for (let t of Object.keys(e)) {
      const s = e[t];
      switch (t) {
        case "contentDirection":
          console.warn("ThreeMeshUI v7xx: property `contentDirection` is deprecated and has been renamed as `flexDirection`"), t = "flexDirection";
          break;
        case "interLine":
          console.warn("ThreeMeshUI v7xx: property `interLine` is deprecated and has been renamed as `lineHeight`"), t = "lineHeight";
          break;
        case "content":
          console.warn("ThreeMeshUI v7xx: property `content` is deprecated and has been renamed as `textContent`"), t = "textContent";
          break;
        case "fontColor":
          console.warn("ThreeMeshUI v7xx: property `fontColor` is deprecated and has been renamed as `color`"), t = "color";
          break;
        case "hiddenOverflow":
          console.warn("ThreeMeshUI v7xx: property `hiddenOverflow` is deprecated and has been renamed as `overflow`"), t = "overflow";
          break;
        case "backgroundTexture":
          console.warn("ThreeMeshUI v7xx: property `backgroundTexture` is deprecated and has been renamed as `backgroundImage`"), t = "backgroundImage";
          break;
        case "alignContent":
          console.warn("ThreeMeshUI v7xx: property `alignContent` is deprecated and has been renamed as `alignItems`"), t = "alignItems";
          break;
        case "borderTopColor":
        case "borderBottomColor":
        case "borderLeftColor":
        case "borderRightColor":
          t = "borderColor";
          break;
      }
      switch (t) {
        // properties
        // As textContent property might alter the hierarchy, do not wait until update
        // 	case 'textContent' :
        case "fontSmooth":
        case "renderOrder":
        case "segments":
        case "visible":
        case "offset":
          this[`_${t}`].value = s;
          break;
        // styles properties
        case "flexDirection":
        case "justifyContent":
        case "alignItems":
        case "color":
        case "fontFamily":
        case "fontOpacity":
        case "fontKerning":
        case "fontSize":
        case "fontStyle":
        case "fontWeight":
        case "textAlign":
        case "letterSpacing":
        case "lineHeight":
        case "whiteSpace":
        case "breakOn":
        // Not valid anymore?
        case "width":
        case "height":
        case "padding":
        case "margin":
        case "backgroundColor":
        case "backgroundOpacity":
        case "backgroundImage":
        case "backgroundSize":
        case "borderColor":
        case "borderOpacity":
        case "borderRadius":
        case "borderWidth":
        case "overflow":
        case "order":
        case "boxSizing":
          this[`_${t}`] && (this[`_${t}`].inline = s);
          break;
        case "paddingTop":
          this._padding.top = s;
          break;
        case "paddingRight":
          this._padding.right = s;
          break;
        case "paddingBottom":
          this._padding.bottom = s;
          break;
        case "paddingLeft":
          this._padding.left = s;
          break;
        case "marginTop":
          this._margin.top = s;
          break;
        case "marginRight":
          this._margin.right = s;
          break;
        case "marginBottom":
          this._margin.bottom = s;
          break;
        case "marginLeft":
          this._margin.left = s;
          break;
        case "borderTopWidth":
          this._borderWidth.top = s;
          break;
        case "borderRightWidth":
          this._borderWidth.right = s;
          break;
        case "borderBottomWidth":
          this._borderWidth.bottom = s;
          break;
        case "borderLeftWidth":
          this._borderWidth.left = s;
          break;
        case "borderTopLeftRadius":
          this._borderRadius.topLeft = s;
          break;
        case "borderTopRightRadius":
          this._borderRadius.topRight = s;
          break;
        case "borderBottomRightRadius":
          this._borderRadius.bottomRight = s;
          break;
        case "borderBottomLeftRadius":
          this._borderRadius.bottomLeft = s;
          break;
        // Back & Front linked properties
        case "side":
        case "castShadow":
        case "receiveShadow":
          const r = t.charAt(0).toUpperCase() + t.substr(1);
          this[`_background${r}`].value = s, this[`_font${r}`].value = s;
          break;
        // Meshes & material properties
        case "fontSide":
        case "backgroundSide":
        case "fontCastShadow":
        case "backgroundCastShadow":
        case "fontReceiveShadow":
        case "backgroundReceiveShadow":
        case "fontMaterial":
        case "fontCustomDepthMaterial":
          this[`_${t}`].value = s;
          break;
        default:
          this[`_${t}`] !== void 0 ? this[`_${t}`].value = s : this[t] = s;
      }
    }
  }
  get(e) {
    switch (e) {
      case "overflow":
      case "width":
      case "height":
        return this[`_${e}`].inline;
    }
  }
  /**
   * Filters children in order to compute only one times children lists
   * @private
   */
  _rebuildChildrenLists() {
    this._children._needsUpdate = !0;
  }
  /**
   * Try to retrieve parentUI after each structural change
   * @protected
   */
  _rebuildParentUI = () => {
    this._parent._needsUpdate = !0, this.parent && !this.parent.isUI ? (N.register(this), this.activatePseudoState("root")) : (N.remove(this), this.deactivatePseudoState("root"));
  };
  /**
   * When the user calls component.add, it registers for updates,
   * then call THREE.Object3D.add.
   */
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(e) {
    let t = !1;
    for (let s = 0; s < arguments.length; s++)
      super.add(arguments[s]), arguments[s].isUI && (t = !0);
    return t && this._rebuildChildrenLists(), this;
  }
  /**
   * When the user calls component.remove, it registers for updates,
   * then call THREE.Object3D.remove.
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  remove(e) {
    for (const t of Object.keys(arguments))
      arguments[t].isInline && this.update(null, !0);
    return super.remove(...arguments), this._rebuildChildrenLists(), this;
  }
  /**
   *
   * @return {Object3D}
   */
  clear() {
    return this.removeFromParent(), this.traverse((e) => {
      e.material && e.material.dispose(), e.geometry && e.geometry.dispose();
    }), super.clear(), this._backgroundMesh = null, this._backgroundMaterial = null, this._backgroundMaterialMediation = null, this._backgroundMeshMediation = null, this._children.dispose(), this._children = null, this._parent.dispose(), this._parent = null, this._backgroundSide = null, this._backgroundAlphaTest = null, this._visible = null, this._backgroundCastShadow = null, this._backgroundReceiveShadow = null, this._renderOrder = null, this._segments = null, this._bounds = null, this._boxSizing = null, this._padding = null, this._margin = null, this._position = null, this._flexDirection = null, this._justifyContent = null, this._alignItems = null, this._display = null, this._backgroundColor = null, this._backgroundOpacity = null, this._backgroundSize = null, this._fontOpacity = null, this._color = null, this._whiteSpace = null, this._fontFamily = null, this._fontStyle = null, this._fontWeight = null, this._lineHeight = null, this._fontKerning = null, this._letterSpacing = null, this._overflow = null, this._textAlign = null, this._font = null, this._lineBreak = null, this._layouter = null, this;
  }
  /**
   *
   * @return {string}
   */
  get textContent() {
    return this._textContent.process(this), this._textContent._value;
  }
  /***********************************************************************************************************************
   * TO MATERIAL HOLDER
   **********************************************************************************************************************/
  /**
   *
   * @returns {Material|ShaderMaterial}
   */
  get backgroundMaterial() {
    return this._backgroundMaterial;
  }
  /**
   *
   * @param {Material|ShaderMaterial} material
   */
  set backgroundMaterial(e) {
    this._backgroundMaterial = e, this._backgroundMaterialMediation = { ...e.constructor.mediation }, this._transferToBackgroundMaterial(), this._backgroundMesh && (this._backgroundMesh.material = this._backgroundMaterial, x(e, "frameSize", this._backgroundMesh.scale));
  }
  /**
   *
   * @param {Material|null} material
   */
  set backgroundCustomDepthMaterial(e) {
    this._backgroundCustomDepthMaterial = e, this._transferToBackgroundMaterial(), this._backgroundMesh && (this._backgroundMesh.customDepthMaterial = this._backgroundCustomDepthMaterial);
  }
  /**
   *
   * @returns {Material|null}
   */
  get backgroundCustomDepthMaterial() {
    return this._backgroundCustomDepthMaterial;
  }
  /**
   * According to the list of materialProperties
   * some properties are sent to material
   * @param {Object} [options=null]
   * @private
   */
  _transferToBackgroundMaterial(e = null) {
    if (!e) {
      e = {};
      for (const t of this._components)
        t.output(e);
    }
    z.mediate(this, this._backgroundMaterial, e, this._backgroundMaterialMediation, this._backgroundCustomDepthMaterial);
  }
  /**
   *
   * @param {number} value
   */
  set backgroundSide(e) {
    this._backgroundSide.value = e, this._backgroundMaterial && (this._backgroundMaterial.side = e);
  }
  /**
   *
   * @return {number}
   */
  get backgroundSide() {
    return this._backgroundSide.value;
  }
  /**
   *
   * @param {number} value
   */
  set backgroundAlphaTest(e) {
    this._backgroundAlphaTest.value = e, this._backgroundMaterial && (this._backgroundMaterial.alphaTest = e);
  }
  /**
   *
   * @return {number}
   */
  get backgroundAlphaTest() {
    return this._backgroundAlphaTest.value;
  }
  /** Font Material ----------------------------------------------------------*/
  /**
   *
   * @returns {Material|ShaderMaterial}
   */
  // get fontMaterial() { return this._fontMaterial__; }
  get fontMaterial() {
    return this._fontMaterial.value;
  }
  /**
   *
   * @param {Material|ShaderMaterial} material
   */
  set fontMaterial(e) {
    this._fontMaterial.value = e;
  }
  /**
   *
   * @param {Material|null} material
   */
  set fontCustomDepthMaterial(e) {
    this._fontCustomDepthMaterial.value = e;
  }
  /**
   *
   * @returns {Material|null}
   */
  get fontCustomDepthMaterial() {
    return this._fontCustomDepthMaterial.value;
  }
  /**
   * According to the list of materialProperties
   * some properties are sent to material
   * @param {Object} [options=null]
   * @private
   */
  _transferToFontMaterial(e = null) {
    const t = this._fontMaterial.value;
    if (t) {
      if (!e) {
        e = {};
        for (const s of this._components)
          s.output(e);
      }
      z.mediate(this, t, e, this._fontMaterial._mediation, this._fontCustomDepthMaterial.value);
    }
  }
  /**
   *
   * @param {number} value
   */
  set fontSide(e) {
    this._fontSide.value = e;
  }
  /**
   *
   * @return {number}
   */
  get fontSide() {
    return this._fontSide.value;
  }
  /**
   *
   * @param {number} value
   */
  set fontAlphaTest(e) {
    this._fontAlphaTest.value = e;
  }
  /**
   *
   * @return {number}
   */
  get fontAlphaTest() {
    return this._fontAlphaTest.value;
  }
  /*********************************************************************************************************************
   * MESH MEDIATION
   ********************************************************************************************************************/
  /**
   * According to the list of meshProperties
   * some properties are sent to mesh
   * @param {Object} [options=null]
   * @private
   */
  _transferToBackgroundMesh(e = null) {
    if (!e) {
      e = {};
      for (const t of this._components)
        t.output(e);
    }
    z.mediate(this, this._backgroundMesh, e, this._backgroundMeshMediation);
  }
  /**
   * @internal
   * @param {Mesh|Array.<Mesh>|null} mesh
   */
  setBackgroundMesh(e) {
    this._backgroundMesh && (this.remove(this._backgroundMesh), this.unbindBackgroundMeshProperties()), this._backgroundMesh = e, this._backgroundMesh && (this.bindBackgroundMeshProperties(), this._backgroundCustomDepthMaterial && (this._backgroundMesh.customDepthMaterial = this._backgroundCustomDepthMaterial), this._backgroundMaterial && x(this._backgroundMaterial, "frameSize", this._backgroundMesh.scale), this._transferToBackgroundMesh(), this.add(this._backgroundMesh));
  }
  /**
   *
   */
  bindBackgroundMeshProperties() {
  }
  /**
   *
   */
  unbindBackgroundMeshProperties() {
  }
  activatePseudoState(e) {
  }
  deactivatePseudoState(e) {
  }
  togglePseudoState(e) {
  }
  hasPseudoState(e) {
    return !1;
  }
  set borderRadiusMediation(e) {
    this._borderRadius.mediation = e;
  }
  /**
   *
   * @param {boolean} value
   */
  set backgroundCastShadow(e) {
    this._backgroundCastShadow && (this._backgroundCastShadow.value = e);
  }
  /**
   *
   * @return {boolean}
   */
  get backgroundCastShadow() {
    return this._backgroundCastShadow;
  }
  /**
   *
   * @param {boolean} value
   */
  set backgroundReceiveShadow(e) {
    this._backgroundReceiveShadow && (this._backgroundReceiveShadow.value = e);
  }
  /**
   *
   * @return {boolean}
   */
  get backgroundReceiveShadow() {
    return this._backgroundReceiveShadow;
  }
  /**
   *
   * @param {number} value
   */
  set renderOrder(e) {
    this._renderOrder && (this._renderOrder.value = e);
  }
  /**
   *
   * @return {number}
   */
  get renderOrder() {
    return this._renderOrder.value;
  }
  /** Font Mesh --------------------------------------------------------------*/
  /**
   * According to the list of meshProperties
   * some properties are sent to mesh
   * @param {Object} [options=null]
   * @private
   */
  _transferToFontMesh(e = null) {
    if (this._fontMesh) {
      if (!e) {
        e = {};
        for (const t of this._components)
          t.output(e);
      }
      z.mediate(this, this._fontMesh, e, this._fontMeshMediation);
    }
  }
  /**
   * @internal
   * @param {Mesh|Array.<Mesh>|null} mesh
   */
  setFontMesh(e) {
    this._fontMesh && (this.remove(this._fontMesh), this._fontMesh.material && this._fontMesh.material.dispose(), this._fontMesh.geometry && this._fontMesh.geometry.dispose(), this._fontMesh = null, this.unbindFontMeshProperties()), this._fontMesh = e, this._fontMesh && (this._fontMesh.raycast = () => {
    }, this.bindFontMeshProperties(), this._transferToFontMaterial(), this._transferToFontMesh(), this.add(this._fontMesh));
  }
  /**
   *
   */
  bindFontMeshProperties() {
  }
  /**
   *
   */
  unbindFontMeshProperties() {
  }
  /**
   *
   * @param {boolean} value
   */
  set fontCastShadow(e) {
    this._fontCastShadow && (this._fontCastShadow.value = e);
  }
  /**
   *
   * @return {boolean}
   */
  get fontCastShadow() {
    return this._fontCastShadow;
  }
  /**
   *
   * @param {boolean} value
   */
  set fontReceiveShadow(e) {
    this._fontReceiveShadow && (this._fontReceiveShadow.value = e);
  }
  /**
   *
   * @return {boolean}
   */
  get fontReceiveShadow() {
    return this._fontReceiveShadow;
  }
  /***********************************************************************************************************************
   * GEOMETRY
   **********************************************************************************************************************/
  /**
   *
   * @param {Number} v
   */
  set segments(e) {
    this._segments.value = e;
  }
  /**
   *
   * @return {number}
   */
  get segments() {
    return this._segments.value;
  }
  /***********************************************************************************************************************
   * HOOKS & ALTERS
   **********************************************************************************************************************/
  /**
   *
   * @param {Function} func
   */
  set onAfterUpdate(e) {
    console.warn("ThreeMeshUI v7xx : `onAfterUpdate()` property has been deprecated, please rely on `addAfterUpdate` instead."), this.addAfterUpdate(e);
  }
  /**
   *
   * @param {Function} func
   */
  addAfterUpdate(e) {
    this._onAfterUpdates.push(e);
  }
  /**
   *
   * @param {Function} func
   */
  removeAfterUpdate(e) {
    const t = this._onAfterUpdates.indexOf(e);
    t !== -1 && this._onAfterUpdates.splice(t, 1);
  }
  /**
   * @todo: afterUpdate not called anymore
   */
  performAfterUpdate() {
    for (let e = 0; e < this._onAfterUpdates.length; e++)
      this._onAfterUpdates[e]();
  }
  /**
   * Retrieve a property
   * @param propertyName
   * @return {BaseProperty|null}
   */
  getProperty(e) {
    return this[`_${e}`] ? this[`_${e}`] : null;
  }
  /**
   *
   * @param {string} name
   * @param {BaseProperty} instance
   * @returns {void}
   */
  appendProperty(e, t) {
    this[`_${e}`] = t, this._components.push(t);
  }
  /**
   *
   * @param {string} name
   * @param {BaseProperty} instance
   * @returns {BaseProperty}
   */
  replaceProperty(e, t) {
    const s = this[`_${e}`], r = this._components.indexOf(s);
    return this._components[r] = this[`_${e}`] = t, t.needsUpdate = !0, s;
  }
}
class N {
  static register(e) {
    this.elements.includes(e) || this.elements.push(e);
  }
  static remove(e) {
    const t = this.elements.indexOf(e);
    t !== -1 && this.elements.splice(t, 1);
  }
  static update() {
    for (const e of this.elements)
      e.update(), e.process(), e.process(), e.render();
  }
}
N.elements = [];
const Cs = (
  /* glsl */
  `

// FrameBorder vertex pars
attribute vec2 uvB;
varying vec2 vUvB;

`
), ye = Cs, Rs = (
  /* glsl */
  `

	// FrameBorder vertex shader
	vUvB = uvB;

`
), be = Rs, Bs = (
  /* glsl */
  `

// borders sequences are : x:TOP, y:RIGHT, z:BOTTOM, w:LEFT
uniform vec4 borderWidth;
uniform vec3 borderColor;
uniform float borderOpacity;
uniform vec4 borderRadius;

uniform vec2 cornerTL;
uniform vec2 cornerTR;
uniform vec2 cornerBR;
uniform vec2 cornerBL;

varying vec2 vUvB;

float getEllipticFactor( vec2 uv, vec2 center, float radiusX, float radiusY )
{

		float edx = uv.x - center.x;
		float edy = uv.y - center.y;

		float ddx = (edx * edx) / (radiusX * radiusX);
		float ddy = (edy * edy) / (radiusY * radiusY);

		return ddx + ddy;

}

`
), xe = Bs, Us = (
  /* glsl */
  `

vec4 borderColor = vec4( borderColor, borderOpacity );

// This could be tweak to produce more smoothing
float mult = 1.0;

// Step 1 ----------------------------------------------
// Draw the four borders ( top - right - bottom - left )
// Without worrying about radiuses ( Straight boorders )

// Top
float topBorderUVy = 1.0 - borderWidth.x;
if( borderWidth.x > 0.0 && vUvB.y > topBorderUVy )
{

	float w = fwidth( 1.0 - vUvB.y ) * mult;
	float step = smoothstep( topBorderUVy , topBorderUVy + w , vUvB.y );
	diffuseColor = mix( diffuseColor, borderColor, step );

}

// Left
float leftBorderUVx = borderWidth.w;
if( borderWidth.w > 0.0 && vUvB.x < leftBorderUVx )
{

	float w = fwidth( vUvB.x ) * mult ;
	float step = smoothstep( leftBorderUVx , leftBorderUVx - w , vUvB.x );
	diffuseColor = mix( diffuseColor, borderColor, step );

}

// Bottom
float bottomBorderUVy = borderWidth.z;
if( borderWidth.z > 0.0 && vUvB.y < bottomBorderUVy )
{
	float w = fwidth( vUvB.y ) * mult;
	float step = smoothstep( bottomBorderUVy , bottomBorderUVy - w , vUvB.y );
	diffuseColor = mix( diffuseColor, borderColor, step );
}

// Right
float rightBorderUVx = 1.0 - borderWidth.y;
if( borderWidth.y > 0.0 && vUvB.x > rightBorderUVx )
{
	float w = fwidth( 1.0 - vUvB.x ) * mult;
	float step = smoothstep( rightBorderUVx , rightBorderUVx + w , vUvB.x );
	diffuseColor = mix( diffuseColor, borderColor, step );
}


// Step 2 ----------------------------------------------
// Process each corners ( topLeft, topRight, bottomRight, bottomLeft )
// To transparentize outside radiuses
// To draw ellipse border on the corner


// Top Left corner
if( vUvB.x < cornerTL.x && vUvB.y > cornerTL.y ) {

		// Only draw border if width is set
		if( borderWidth.w + borderWidth.x > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerTL, cornerTL.x - borderWidth.w,  ( 1.0 - cornerTL.y ) - borderWidth.x );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		// Then then radius
		float radiusFactor = getEllipticFactor( vUvB, cornerTL, cornerTL.x, 1.0 - cornerTL.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Bottom Left
if( vUvB.x < cornerBL.x && vUvB.y < cornerBL.y ) {

		if( borderWidth.w + borderWidth.z > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerBL, cornerBL.x - borderWidth.w,  cornerBL.y - borderWidth.z );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}


		float radiusFactor = getEllipticFactor( vUvB, cornerBL, cornerBL.x, cornerBL.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Top Right
if( vUvB.x > cornerTR.x && vUvB.y > cornerTR.y ) {

		if( borderWidth.y + borderWidth.x > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerTR, ( 1.0 - cornerTR.x ) - borderWidth.y,  ( 1.0 - cornerTR.y ) - borderWidth.x );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		float radiusFactor = getEllipticFactor( vUvB, cornerTR, 1.0 - cornerTR.x, 1.0 - cornerTR.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Bottom Right
if( vUvB.x > cornerBR.x && vUvB.y < cornerBR.y ) {

		if( borderWidth.y + borderWidth.z > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerBR, ( 1.0 - cornerBR.x ) - borderWidth.y,  cornerBR.y - borderWidth.z );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		float radiusFactor = getEllipticFactor( vUvB, cornerBR, 1.0 - cornerBR.x, cornerBR.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}

`
), we = Us, As = (
  /* glsl */
  `

// To be removed - required for both border and background
uniform vec3 frameSize;
uniform vec2 textureSize;

`
), Se = As, Ts = (
  /* glsl */
  `

#ifdef USE_MAP

vec4 sampleTexture() {

	vec2 uv = vUv;

	// default stretch
	#if BACKGROUND_MAPPING != 0

	float textureRatio = textureSize.x / textureSize.y;
	float panelRatio = frameSize.x / frameSize.y;
	float ratio = panelRatio / textureRatio;
	float ratio2 = textureRatio / panelRatio;

		// contain
		#if BACKGROUND_MAPPING == 1
		if ( textureRatio < panelRatio ) { // repeat on X
			float newX = uv.x * ratio;
			newX += 0.5 - 0.5 * ratio;
			uv.x = newX;
		} else { // repeat on Y
			float newY = uv.y * ratio2;
			newY += 0.5 - 0.5 * ratio2;
			uv.y = newY;
		}
		#else
		// cover
		if ( textureRatio < panelRatio ) { // stretch on Y
			float newY = uv.y * ratio2;
			newY += 0.5 - 0.5 * ratio2;
			uv.y = newY;
		} else { // stretch on X
			float newX = uv.x * ratio;
			newX += 0.5 - 0.5 * ratio;
			uv.x = newX;
		}

		#endif

	#endif

	return texture2D( map, uv );

}
#endif
`
), Ve = Ts, Ms = (
  /* glsl */
  `
#ifdef USE_MAP

	vec4 textureSample = sampleTexture();
	diffuseColor *= textureSample;

#endif
`
), ke = Ms, tt = {
  msdfAlphaglyphParsVertexGlsl: de,
  msdfAlphaglyphVertexGlsl: _e,
  msdfOffsetglyphVertexGlsl: fe,
  msdfAlphaglyphParsFragmentGlsl: pe,
  msdfAlphaglyphFragmentGlsl: ge,
  frameBorderParsVertexGlsl: ye,
  frameBorderVertexGlsl: be,
  frameCommonParsFragmentGlsl: Se,
  frameBorderParsFragmentGlsl: xe,
  frameBorderFragmentGlsl: we,
  frameBackgroundParsFragmentGlsl: Ve,
  frameBackgroundFragmentGlsl: ke
}, Fs = (
  /* glsl */
  `
// Would be automatic on three materials and from USE_UV
#ifdef USE_MAP
varying vec2 vUv;
#endif

${ye}

#include <clipping_planes_pars_vertex>

void main() {

	#ifdef USE_MAP
	vUv = uv;
	#endif

	${be}

	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;

	#include <clipping_planes_vertex>

}
`
), Os = (
  /* glsl */
  `

// Basic
uniform vec3 diffuse;
uniform float opacity;

#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif

${Se}

${xe}


#ifdef USE_MAP
varying vec2 vUv;
uniform sampler2D map;
#endif

${Ve}

#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );

	// map
	${ke}

	${we}

	#ifdef USE_ALPHATEST

	if ( diffuseColor.a < alphaTest ) discard;

	#endif

	// output
	gl_FragColor = diffuseColor;


	#include <clipping_planes_fragment>
}
`
);
class X {
  /**
   *
   * @returns {Object<{m: string, t?: (function((Material|ShaderMaterial), string, *): void)}>}
   */
  static get mediation() {
    return zs;
  }
  /**
   * Alter a material options with required fontMaterial options and or default values
   * @param {Object.<string,any>} materialOptions
   */
  static ensureMaterialOptions(e) {
    e.transparent = !0, e.alphaTest = e.alphaTest || 0.02;
  }
  /**
   * As three-mesh-ui FontMaterial relies on webgl preprocessors,
   * lets force the material to have a proper defines object
   * @param {Material|ShaderMaterial} threeMaterial
   */
  static ensureDefines(e) {
    e.defines || (e.defines = {});
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {Material|ShaderMaterial} threeMaterial
   * @param {Object.<string,any>} materialOptions
   */
  static ensureUserData(e, t) {
    e.userData.borderColor = { value: null }, e.userData.borderRadius = { value: new u.Vector4(0, 0, 0, 0) }, e.userData.cornerTL = { value: new u.Vector2(0, 1) }, e.userData.cornerTR = { value: new u.Vector2(1, 1) }, e.userData.cornerBR = { value: new u.Vector2(1, 0) }, e.userData.cornerBL = { value: new u.Vector2(0, 0) }, e.userData.borderWidth = { value: new u.Vector4(0, 0, 0, 0) }, e.userData.borderOpacity = { value: null }, e.userData.frameSize = { value: new u.Vector3(1, 1, 1) }, e.userData.textureSize = { value: new u.Vector2(1, 1) };
  }
  /* eslint-enable no-unused-vars */
  /**
   *
   * @param {any} shader
   * @param {Material|ShaderMaterial} threeMaterial
   */
  static bindUniformsWithUserData(e, t) {
    e.uniforms.borderColor = t.userData.borderColor, e.uniforms.borderRadius = t.userData.borderRadius, e.uniforms.cornerTL = t.userData.cornerTL, e.uniforms.cornerTR = t.userData.cornerTR, e.uniforms.cornerBR = t.userData.cornerBR, e.uniforms.cornerBL = t.userData.cornerBL, e.uniforms.borderWidth = t.userData.borderWidth, e.uniforms.borderOpacity = t.userData.borderOpacity, e.uniforms.frameSize = t.userData.frameSize, e.uniforms.textureSize = t.userData.textureSize;
  }
  /**
   *
   * @param shader
   */
  static injectShaderChunks(e) {
    X.injectVertexShaderChunks(e), X.injectFragmentShaderChunks(e);
  }
  /**
   *
   * @param shader
   */
  static injectVertexShaderChunks(e) {
    e.vertexShader = e.vertexShader.replace(
      "#include <uv_pars_vertex>",
      `#include <uv_pars_vertex>
` + ye
    ), e.vertexShader = e.vertexShader.replace(
      "#include <uv_vertex>",
      `#include <uv_vertex>
` + be
    );
  }
  /**
   *
   * @param shader
   */
  static injectFragmentShaderChunks(e) {
    e.fragmentShader = e.fragmentShader.replace(
      "#include <map_pars_fragment>",
      `#include <map_pars_fragment>
` + Ve
    ), e.fragmentShader = e.fragmentShader.replace(
      "#include <map_pars_fragment>",
      `#include <map_pars_fragment>
` + xe
    ), e.fragmentShader = e.fragmentShader.replace(
      "#include <map_pars_fragment>",
      `#include <map_pars_fragment>
` + Se
    ), e.fragmentShader = e.fragmentShader.replace(
      "#include <map_fragment>",
      ke
    ), e.fragmentShader = e.fragmentShader.replace(
      "#include <alphamap_fragment>",
      we + `
#include <alphamap_fragment>`
    );
  }
}
const Ls = function(i, e, t) {
  t = ["stretch", "contain", "cover"].indexOf(t), Ye(i, "BACKGROUND_MAPPING", t);
}, zs = {
  clippingPlanes: { m: "clippingPlanes" },
  backgroundAlphaTest: { m: "alphaTest", t: Y },
  backgroundSide: { m: "side" },
  // backgroundTexture: { m: 'map' },
  backgroundImage: { m: "map" },
  backgroundColor: { m: "color" },
  backgroundOpacity: { m: "opacity" },
  backgroundSize: { m: "computedBackgroundSize", t: Ls },
  borderWidth: { m: "borderWidth", t: x },
  borderColor: { m: "borderColor", t: x },
  cornerTL: { m: "cornerTL", t: x },
  cornerTR: { m: "cornerTR", t: x },
  cornerBR: { m: "cornerBR", t: x },
  cornerBL: { m: "cornerBL", t: x },
  borderOpacity: { m: "borderOpacity", t: x },
  size: { m: "frameSize", t: x },
  tSize: { m: "textureSize", t: x }
};
class it extends u.ShaderMaterial {
  /**
   * This static method is mandatory for extending ThreeMeshUI.FrameMaterial
   * It will provide a transfer description for properties from ThreeMeshUI.Text to THREE.Material
   * @see {FrameMaterialUtils.mediation}
   * @returns {Object.<{m:string, t?:(frameMaterial:Material|ShaderMaterial, materialProperty:string, value:any) => void}>}
   */
  static get mediation() {
    return X.mediation;
  }
  constructor() {
    super({
      uniforms: {
        alphaTest: { value: 0.02 },
        map: { value: null },
        diffuse: { value: new u.Color(16777215) },
        opacity: { value: 1 },
        borderColor: { value: new u.Color(0) },
        borderOpacity: { value: 0 },
        borderRadius: { value: new u.Vector4(0, 0, 0, 0) },
        // Corners for customized radius not all starting on center [0.5,0.5];
        // Corners will be generated from borderRadiuses
        cornerTL: { value: new u.Vector2(0, 1) },
        cornerTR: { value: new u.Vector2(1, 1) },
        cornerBR: { value: new u.Vector2(1, 0) },
        cornerBL: { value: new u.Vector2(0, 0) },
        borderWidth: { value: new u.Vector4(0, 0, 0, 0) },
        frameSize: { value: new u.Vector3(1, 1, 1) },
        textureSize: { value: new u.Vector2(1, 1) }
      },
      side: u.FrontSide,
      transparent: !0,
      clipping: !0,
      vertexShader: Fs,
      fragmentShader: Os,
      extensions: {
        derivatives: !0
      }
    }), this.defines.USE_ALPHATEST = "", this.needsUpdate = !0;
  }
  set map(e) {
    this.uniforms.map.value = e, e ? this.defines.USE_UV === void 0 && (this.defines.USE_UV = "", this.needsUpdate = !0) : this.defines.USE_UV !== void 0 && (delete this.defines.USE_UV, this.needsUpdate = !0), this.needsUpdate = !0;
  }
  get map() {
    return this.uniforms.map.value;
  }
  /**
   *
   * @returns {number}
   */
  get alphaTest() {
    return this.uniforms.alphaTest.value;
  }
  /**
   *
   * @param {number} v
   */
  set alphaTest(e) {
    this.uniforms.alphaTest.value = e;
  }
  /**
   *
   * @param {number} v
   */
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  /**
   * The color will be the diffuse uniform
   * @returns {number}
   */
  get opacity() {
    return this.uniforms.opacity.value;
  }
  /**
   * The color will be the diffuse uniform
   * @returns {Color}
   */
  get color() {
    return this.uniforms.diffuse.value;
  }
  /**
   *
   * @param {Color} v
   */
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
}
class Ws extends p {
  constructor() {
    super("children", null, !1), this._uis = [], this._boxes = [];
  }
  /* eslint-disable no-unused-vars */
  /**
   * Update requested when :
   * 		- New child has been added
   * 		- Existing child has been removed
   *
   * @param element
   * @param out
   */
  update(e, t) {
    this._compute(e), e._layouter._needsUpdate = !0, e._renderOrder._needsUpdate = !0;
  }
  /**
   * Process when :
   * 		- Existing child visibility changed
   *
   * @param element
   */
  process(e) {
    this._compute(e), e._flexDirection._needsProcess = !0, e._layouter._needsProcess = !0, e._overflow._needsRender = !0;
  }
  _compute(e) {
    this._uis = e.children.filter((t) => t.visible && t.isUI), this._boxes = this._uis.filter((t) => t.isBox).sort(this._sortOrder);
  }
  /**
   *
   */
  dispose() {
    this._uis = null, this._boxes = null;
  }
  /**
   *
   * Sort children according to their .style.order property or fallback on children index
   *
   * @param {HTMLElementVR} a
   * @param {HTMLElementVR} b
   * @return {number}
   * @private
   */
  _sortOrder = (e, t) => e._order._value < t._order._value ? -1 : e._order._value > t._order._value ? 1 : this._uis.indexOf(e) < this._uis.indexOf(t) ? -1 : 1;
}
class st extends p {
  constructor() {
    super("bounds", null, !1), this._size = new u.Vector3(1, 1, 1), this._offsetWidth = 0, this._offsetHeight = 0, this._innerWidth = 0, this._innerHeight = 0, this._centerX = 0.5, this._centerY = 0.5, this._needsProcess = !0;
  }
  /**
   * Set the value of the width 100%
   * @param element
   * @param value
   */
  setReferenceWidth(e, t) {
    const s = e._width, r = e._padding._value, n = e._borderWidth._value, o = e._margin._value, a = s._auto ? 1 : s._value, l = t * a - (o.y + o.w);
    re(l, this._offsetWidth) || (this._offsetWidth = l, this._innerWidth = this._offsetWidth - (r.y + r.w + n.y + n.w), this._centerX = Q(e), this._propagateWidth(e), this._triggerCascadingDependencies(e));
  }
  /**
   * Set the value of the height 100%
   * @param element
   * @param value
   */
  setReferenceHeight(e, t) {
    const s = e._height, r = e._padding._value, n = e._borderWidth._value, o = e._margin._value, a = s._auto ? 1 : s._value, l = t * a - (o.x + o.z);
    re(l, this._offsetHeight) || (this._offsetHeight = l, this._innerHeight = this._offsetHeight - (r.x + r.z + n.x + n.z), this._centerY = ee(e), this._propagateHeight(e), this._triggerCascadingDependencies(e));
  }
  setChildrenWidth(e, t) {
    const s = e._padding._value, r = e._borderWidth._value;
    this._innerWidth = t, this._offsetWidth = this._innerWidth + (s.y + s.w + r.y + r.w), this._centerX = Q(e), this._propagateWidth(e), this._triggerCascadingDependencies(e);
  }
  setChildrenHeight(e, t) {
    const s = e._padding._value, r = e._borderWidth._value;
    this._innerHeight = t, this._offsetHeight = this._innerHeight + (s.x + s.z + r.x + r.z), this._centerY = ee(e), this._propagateHeight(e), this._triggerCascadingDependencies(e);
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    const s = e._padding._value, r = e._borderWidth._value, n = e._width;
    !n._auto && !n._relative && (e._boxSizing._value === "content-box" ? (this._innerWidth = n._value, this._offsetWidth = this._innerWidth + s.y + s.w + r.y + r.w) : (this._offsetWidth = n._value, this._innerWidth = this._offsetWidth - (s.y + s.w + r.y + r.w)), this._centerX = Q(e), this._needsProcess = !0, this._propagateWidth(e), this._triggerCascadingDependencies(e));
    const o = e._height;
    !o._auto && !o._relative && (e._boxSizing._value === "content-box" ? (this._innerHeight = o._value, this._offsetHeight = this._innerHeight + s.x + s.z + r.x + r.z) : (this._offsetHeight = o._value, this._innerHeight = this._offsetHeight - (s.x + s.z + r.x + r.z)), this._centerY = ee(e), this._needsProcess = !0, this._propagateHeight(e), this._triggerCascadingDependencies(e));
  }
  /* eslint-disable no-unused-vars */
  render(e) {
    this._size.x = this._offsetWidth, this._size.y = this._offsetHeight, e._backgroundMesh && e._backgroundMesh.updateScale(), e._renderer._needsRender = !0;
  }
  /**
   *
   * @param {Object.<string,any>} out
   */
  output(e) {
    e.size = this._size;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @override
   */
  process(e) {
    e._overflow._needsRender = !0;
  }
  /**
   *
   * @param element
   * @internal
   */
  _computeChildrenSideWidth(e) {
    return Es(e);
  }
  /**
   *
   * @param element
   * @internal
   */
  _computeChildrenSideHeight(e) {
    return Ds(e);
  }
  _propagateWidth(e) {
    for (let t = 0; t < e._children._boxes.length; t++) {
      const s = e._children._boxes[t];
      s._width._relative && s._bounds.setReferenceWidth(s, this._innerWidth);
    }
  }
  _propagateHeight(e) {
    for (let t = 0; t < e._children._boxes.length; t++) {
      const s = e._children._boxes[t];
      s._height._relative && s._bounds.setReferenceHeight(s, this._innerHeight);
    }
  }
  _triggerCascadingDependencies(e) {
    e._parent._value && (e._parent._value._autoSize._needsProcess = !0), e._flexDirection._needsProcess = !0, e._fontSize._needsProcess = !0, e._layouter._needsProcess = !0, this._needsRender = !0, e._borderWidth._needsRender = !0, e._borderRadius._needsRender = !0, e._overflow._needsRender = !0;
  }
}
function Q(i) {
  const e = i._padding._value, t = i._borderWidth._value, s = e.w + t.w, r = e.y + t.y;
  return (s - r) / 2;
}
function ee(i) {
  const e = i._padding._value, t = i._borderWidth._value, s = e.x + t.x;
  return (e.z + t.z - s) / 2;
}
function Es(i) {
  return i._children._boxes.reduce((e, t) => {
    const s = t._margin._value, r = t._bounds._offsetWidth + s.y + s.w;
    return e + r;
  }, 0);
}
function Ds(i) {
  return i._children._boxes.reduce((e, t) => {
    const s = t._margin._value, r = t._bounds._offsetHeight + s.x + s.z;
    return e + r;
  }, 0);
}
class Hs extends ue {
  constructor() {
    super(), this._allowsInherit = !1, this._needsUpdate = !0, this._process = this.emptyStrategyLogic, this._childAlign = this.emptyStrategyLogic;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(e) {
    switch (this._value = this._inheritedInput, e._flexDirection._value) {
      case "row":
      case "row-reverse":
        switch (this._process = Ys, this._value) {
          case "start":
            this._childAlign = $s;
            break;
          case "end":
            this._childAlign = Gs;
            break;
          default:
            this._childAlign = Ue;
        }
        break;
      case "column":
      case "column-reverse":
        switch (this._process = js, this._value) {
          case "start":
            this._childAlign = Xs;
            break;
          case "end":
            this._childAlign = Ns;
            break;
          default:
            this._childAlign = Ue;
        }
        break;
    }
    this._needsProcess = !0, e._autoSize._needsProcess = !0, e._flexDirection._needsProcess = !0, e._justifyContent._needsProcess = !0, this._needsProcess = !0, e._fontSize._needsProcess = !0, e._layouter._needsProcess = !0;
  }
  /**
   *
   * @param element
   */
  process(e) {
    this._process(e, this._childAlign);
    let t = "center", s = "center", r = "center";
    const n = e._padding._value, o = e._borderWidth._value;
    e._flexDirection._value.indexOf("column") !== -1 ? this._value === "start" ? t = s = "left" : this._value === "end" ? t = s = "right" : t = "centerX" : this._value === "start" ? t = r = "top" : this._value === "end" ? t = r = "bottom" : t = "centerY";
    let a = -(n.x - n.z) / 2 - (o.x - o.z) / 2, l = -(n.y - n.w) / 2 - (o.y - o.w) / 2;
    s === "left" ? l = (n.w - n.y) / 2 + (o.w - o.y) / 2 : s === "right" && (l = -(n.y - n.w) / 2 - (o.y - o.w) / 2), r === "top" ? a = -(n.x - n.z) / 2 - (o.x - o.z) / 2 : r === "bottom" && (a = (n.z - n.x) / 2 + (o.z - o.x) / 2), e._children._boxes.forEach((d) => {
      let c = 0, h = 0;
      t === "top" ? h = -d._margin._value.x : t === "bottom" ? h = d._margin._value.z : t === "left" ? c = d._margin._value.w : t === "right" ? c = -d._margin._value.y : t === "centerX" ? c = (d._margin._value.w - d._margin._value.y) / 2 : t === "centerY" && (h = (-d._margin._value.x + d._margin._value.z) / 2), e._layouter._childrenPos[d.id].x += l + c, e._layouter._childrenPos[d.id].y += a + h;
    });
  }
}
function Ue() {
  return 0;
}
function Gs(i, e) {
  return -e + i._bounds._offsetHeight / 2;
}
function $s(i, e) {
  return e - i._bounds._offsetHeight / 2;
}
function Ns(i, e) {
  return e - i._bounds._offsetWidth / 2;
}
function Xs(i, e) {
  return -e + i._bounds._offsetWidth / 2;
}
function js(i, e) {
  const t = i._bounds._innerWidth / 2;
  i._children._boxes.forEach((s) => {
    i._layouter._childrenPos[s.id].x = e(s, t);
  });
}
function Ys(i, e) {
  const t = i._bounds._innerHeight / 2;
  i._children._boxes.forEach((s) => {
    i._layouter._childrenPos[s.id].y = e(s, t);
  });
}
class Ks extends le {
  constructor() {
    super(), this._allowsInherit = !1, this._needsUpdate = !0, this._offset = 0, this._reverse = 1, this._process = this.emptyStrategyLogic;
  }
  computeOutputValue(e) {
    switch (this._value = this._inheritedInput, this._value) {
      case "row":
        this._process = qs;
        break;
      case "row-reverse":
        this._process = Js;
        break;
      case "column":
        this._process = Zs;
        break;
      case "column-reverse":
        this._process = Qs;
        break;
    }
    e._justifyContent._needsUpdate || e._justifyContent.computeOutputValue(e), e._alignItems._needsUpdate || e._alignItems.computeOutputValue(e), this._needsProcess = !0;
  }
  process(e) {
    switch (this._value) {
      case "row":
        this._offset = -e._bounds._innerWidth / 2;
        break;
      case "row-reverse":
        this._offset = e._bounds._innerWidth / 2;
        break;
      case "column":
        this._offset = e._bounds._innerHeight / 2;
        break;
      case "column-reverse":
        this._offset = -e._bounds._innerHeight / 2;
        break;
    }
    this._reverse = -Math.sign(this._offset), this._reverse === 0 && (this._reverse = 1), this._process(e), e._justifyContent._needsProcess = !0, e._layouter._needsProcess = !0;
  }
}
function qs(i) {
  let e = i._flexDirection._offset;
  const t = i._flexDirection._reverse, s = i._children._boxes;
  for (let r = 0; r < s.length; r++) {
    const n = s[r], o = n.id, a = n._bounds._offsetWidth;
    e += n._margin._value.w * t;
    const l = i._layouter._childrenPos[o];
    l.x = e + a / 2 * t, l.y = 0, e += t * (a + n._margin._value.y);
  }
}
function Js(i) {
  let e = i._flexDirection._offset;
  const t = i._flexDirection._reverse, s = i._children._boxes;
  for (let r = 0; r < s.length; r++) {
    const n = s[r], o = n.id, a = n._bounds._offsetWidth;
    e += n._margin._value.y * t;
    const l = i._layouter._childrenPos[o];
    l.x = e + a / 2 * t, l.y = 0, e += (a + n._margin._value.w) * t;
  }
}
function Zs(i) {
  let e = i._flexDirection._offset;
  const t = i._flexDirection._reverse, s = i._children._boxes;
  for (let r = 0; r < s.length; r++) {
    const n = s[r], o = n.id, a = n._bounds._offsetHeight;
    e += n._margin._value.x * t;
    const l = i._layouter._childrenPos[o];
    l.x = 0, l.y = e + a / 2 * t, e += (a + n._margin._value.z) * t;
  }
}
function Qs(i) {
  let e = i._flexDirection._offset;
  const t = i._flexDirection._reverse, s = i._children._boxes;
  for (let r = 0; r < s.length; r++) {
    const n = s[r], o = n.id, a = n._bounds._offsetHeight;
    e += n._margin._value.z * t;
    const l = i._layouter._childrenPos[o];
    l.x = 0, l.y = e + a / 2 * t, e += (a + n._margin._value.x) * t;
  }
}
class er extends ce {
  constructor(e) {
    super("justifyContent", e, !0), this._allowsInherit = !1, this._needsUpdate = !0, this._computeOffset = this.emptyStrategyLogic, this._computeMargin = this.emptyStrategyLogic, this._process = this.emptyStrategyLogic;
  }
  computeOutputValue(e) {
    switch (this._value = this._inheritedInput, e._flexDirection._value) {
      case "column-reverse":
      case "column":
        this._process = ir.bind(this);
        break;
      case "row-reverse":
      case "row":
        this._process = tr.bind(this);
        break;
    }
    switch (this._value) {
      case "end":
        this._computeOffset = nr, this._computeMargin = te;
        break;
      case "center":
        this._computeOffset = or, this._computeMargin = te;
        break;
      case "start":
        this._computeOffset = D, this._computeMargin = te;
        break;
      case "space-between":
        this._computeOffset = D, this._computeMargin = ar;
        break;
      case "space-around":
        this._computeOffset = D, this._computeMargin = hr;
        break;
      case "space-evenly":
        this._computeOffset = D, this._computeMargin = ur;
        break;
    }
    e._flexDirection._needsProcess = !0;
  }
  process(e) {
    this._process(e), e._alignItems._needsProcess = !0;
  }
}
function tr(i) {
  const e = i._flexDirection._offset, { usedDirectionSpace: t, remainingSpace: s } = sr(i), r = e * 2 - t * Math.sign(e), n = this._computeOffset(r), o = this._computeMargin(i, s, i._flexDirection._reverse);
  i._children._boxes.forEach((a, l) => {
    i._layouter._childrenPos[a.id].x -= n - o[l];
  });
}
function ir(i) {
  const e = i._flexDirection._offset, { usedDirectionSpace: t, remainingSpace: s } = rr(i), r = e * 2 - t * Math.sign(e), n = this._computeOffset(r), o = this._computeMargin(i, s, i._flexDirection._reverse);
  i._children._boxes.forEach((a, l) => {
    i._layouter._childrenPos[a.id].y -= n - o[l];
  });
}
function sr(i) {
  const e = i._bounds._computeChildrenSideWidth(i);
  return { usedDirectionSpace: e, remainingSpace: i._bounds._innerWidth - e };
}
function rr(i) {
  const e = i._bounds._computeChildrenSideHeight(i);
  return { usedDirectionSpace: e, remainingSpace: i._bounds._innerHeight - e };
}
function D(i) {
  return 0;
}
function nr(i) {
  return i;
}
function or(i) {
  return i / 2;
}
function te(i, e = 0, t = 1) {
  return Array(i._children._boxes.length).fill(0);
}
function ar(i, e = 0, t = 1) {
  const r = i._children._boxes.length, n = Array(r).fill(0);
  if (e > 0 && r > 1) {
    const o = e / (r - 1) * t;
    n[0] = 0;
    for (let a = 1; a < r; a++)
      n[a] = o * a;
  }
  return n;
}
function ur(i, e = 0, t = 1) {
  const r = i._children._boxes.length, n = Array(r).fill(0);
  if (e > 0) {
    const o = e / (r + 1) * t;
    for (let a = 0; a < r; a++)
      n[a] = o * (a + 1);
  }
  return n;
}
function hr(i, e = 0, t = 1) {
  const r = i._children._boxes.length, n = Array(r).fill(0);
  if (e > 0) {
    const o = e / r * t, a = o / 2;
    n[0] = a;
    for (let l = 1; l < r; l++)
      n[l] = a + o * l;
  }
  return n;
}
let ie;
class rt extends u.Mesh {
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  constructor(e) {
    const t = e.slice, s = {};
    let r = 1, n = 1;
    if (t) {
      if (r = t.width ? t.width : 1, n = t.height ? t.height : 1, t.top) {
        if (t.left) {
          const _ = new u.PlaneGeometry(t.left * r, t.top * n, 1, 1);
          k(_, 0, t.left, 1 - t.top, 1), _.translate(t.left * r / 2, -t.top * n / 2, 0), s.topLeft = _;
        }
        const h = new u.PlaneGeometry(1, t.top * n, 1, 1);
        if (k(h, t.left, 1 - t.right, 1 - t.top, 1), h.translate(0, -t.top * n / 2, 0), s.top = h, t.right) {
          const _ = new u.PlaneGeometry(t.right * r, t.top * n, 1, 1);
          k(_, 1 - t.right, 1, 1 - t.top, 1), _.translate(-t.right * r / 2, -t.top * n / 2, 0), s.topRight = _;
        }
      }
      if (t.left) {
        const h = new u.PlaneGeometry(t.left * r, 1, 1, 1);
        k(h, 0, t.left, t.bottom, 1 - t.top), h.translate(t.left * r / 2, 0, 0), s.left = h;
      }
      const c = new u.PlaneGeometry(1, 1, 1, 1);
      if (k(c, t.left, 1 - t.right, t.bottom, 1 - t.top), s.middle = c, t.right) {
        const h = new u.PlaneGeometry(t.right * r, 1, 1, 1);
        k(h, 1 - t.right, 1, t.bottom, 1 - t.top), h.translate(-t.right * r / 2, 0, 0), s.right = h;
      }
      if (t.bottom) {
        if (t.left) {
          const _ = new u.PlaneGeometry(t.left * r, t.bottom * n, 1, 1);
          k(_, 0, t.left, 0, t.bottom), _.translate(t.left * r / 2, t.bottom * n / 2, 0), s.bottomLeft = _;
        }
        const h = new u.PlaneGeometry(1, t.bottom * n, 1, 1);
        if (k(h, t.left, 1 - t.right, 0, t.bottom), h.translate(0, t.bottom * n / 2, 0), s.bottom = h, t.right) {
          const _ = new u.PlaneGeometry(t.right * r, t.bottom * n, 1, 1);
          k(_, 1 - t.right, 1, 0, t.bottom), _.translate(-t.right * r / 2, t.bottom * n / 2, 0), s.bottomRight = _;
        }
      }
    }
    let o = e.backgroundMaterial;
    t && (ie || (ie = new u.MeshBasicMaterial({ alphaTest: 1.1 })), o = ie);
    const a = new u.PlaneGeometry(1, 1, e._segments.value, e._segments.value), l = new u.BufferAttribute(new Float32Array(a.getAttribute("uv").array), 2);
    if (a.setAttribute("uvB", l).name = "uvB", super(a, o), this.name = "UIBackgroundBox", t) {
      this.slice = t, this.sliceSize = new u.Vector3(1 - (t.left + t.right), 1 - (t.bottom + t.top), 1), this.sliceScale = new u.Vector3(r, n, 1);
      for (const d in s) {
        const c = new u.Mesh(s[d], e.backgroundMaterial);
        this.add(c), s[d] = c;
      }
      this.updateScale = this.updateScaleSlice, this.slices = s;
    }
  }
  updateScale() {
  }
  updateScaleSlice() {
    const e = new u.Vector3(1, 1, 1);
    this.scale.x < (this.slice.left + this.slice.right) * this.sliceScale.x && (e.x = this.scale.x / ((this.slice.left + this.slice.right) * this.sliceScale.x)), this.scale.y < (this.slice.bottom + this.slice.top) * this.sliceScale.y && (e.y = this.scale.y / ((this.slice.bottom + this.slice.top) * this.sliceScale.y));
    for (const t in this.slices) {
      const s = this.slices[t];
      s.scale.set(1 / this.scale.x, 1 / this.scale.y, this.scale.y);
      const r = lr[t];
      for (const o in r)
        s.position[o] = this.scale[o] * r[o] * s.scale[o];
      const n = cr[t];
      if (n) {
        n.x && (s.position.x = this.sliceScale.x * 0.5 * (this.slice.left - this.slice.right) * (1 / this.scale.x)), n.y && (s.position.y = this.sliceScale.y * 0.5 * (this.slice.bottom - this.slice.top) * (1 / this.scale.y));
        for (const o in n) {
          const a = this.scale[o] - (1 - this.sliceSize[o]) * this.sliceScale[o];
          s.scale[o] = Math.max(0, a * (1 / this.scale[o]));
        }
      }
    }
    e.x !== 1 && (this.slices.left.scale.x *= e.x, this.slices.topLeft.scale.x *= e.x, this.slices.bottomLeft.scale.x *= e.x, this.slices.right.scale.x *= e.x, this.slices.topRight.scale.x *= e.x, this.slices.bottomRight.scale.x *= e.x), e.y !== 1 && (this.slices.top.scale.y *= e.y, this.slices.topLeft.scale.y *= e.y, this.slices.topRight.scale.y *= e.y, this.slices.bottom.scale.y *= e.y, this.slices.bottomLeft.scale.y *= e.y, this.slices.bottomRight.scale.y *= e.y);
  }
}
const lr = {
  topLeft: { x: -0.5, y: 0.5 },
  top: { y: 0.5 },
  topRight: { x: 0.5, y: 0.5 },
  left: { x: -0.5 },
  right: { x: 0.5 },
  bottomLeft: { x: -0.5, y: -0.5 },
  bottom: { y: -0.5 },
  bottomRight: { x: 0.5, y: -0.5 }
}, cr = {
  top: { x: 1 },
  left: { y: 1 },
  right: { y: 1 },
  bottom: { x: 1 },
  middle: { x: 1, y: 1 }
};
function k(i, e, t, s, r) {
  const n = t - e, o = r - s, a = i.attributes.uv;
  for (let d = 0; d < a.count; d++) {
    const c = a.getX(d), h = a.getY(d);
    a.setXY(d, e + c * n, s + h * o);
  }
  const l = new u.BufferAttribute(new Float32Array(i.getAttribute("uv").array), 2);
  i.setAttribute("uvB", l).name = "uvB";
}
class nt extends p {
  constructor() {
    super("renderer");
  }
  render(e) {
    e._backgroundMesh || e.setBackgroundMesh(new rt(e)), e.performAfterUpdate();
  }
}
class dr extends He {
  constructor() {
    super("position");
  }
  update(e, t) {
    super.update(e, t), this._needsProcess = !0;
  }
}
class _r extends p {
  constructor() {
    super("autosize"), this._needsProcess = !0;
  }
  process(e) {
    e._width._auto && fr(e), e._height._auto && pr(e);
    const t = e._alignItems._value === "stretch", s = t && e._flexDirection._value.indexOf("column") !== -1, r = t && !s;
    for (const n of e._children._boxes)
      (n._width._auto && s || n._width._relative) && n._bounds.setReferenceWidth(n, e._bounds._innerWidth), (n._height._auto && r || n._height._relative) && n._bounds.setReferenceHeight(n, e._bounds._innerHeight);
  }
}
function fr(i) {
  i._bounds.setChildrenWidth(i, mr(i));
}
function pr(i) {
  i._bounds.setChildrenHeight(i, gr(i));
}
function gr(i) {
  switch (i._flexDirection._value) {
    case "row":
    case "row-reverse":
      return xr(i);
    case "column":
    case "column-reverse":
      return yr(i);
  }
}
function mr(i) {
  switch (i._flexDirection._value) {
    case "row":
    case "row-reverse":
      return vr(i);
    case "column":
    case "column-reverse":
      return br(i);
  }
}
function vr(i) {
  let e = 0;
  for (const t of i._children._boxes) {
    if (t._position._value !== "static") continue;
    const s = t._margin._value, r = t._bounds._offsetWidth + s.y + s.w;
    e += r;
  }
  return e;
}
function yr(i) {
  let e = 0;
  for (const t of i._children._boxes) {
    if (t._position._value !== "static") continue;
    const s = t._margin._value, r = t._bounds._offsetHeight + s.x + s.z;
    e += r;
  }
  return e;
}
function br(i) {
  let e = 0;
  for (const t of i._children._boxes) {
    if (t._position._value !== "static") continue;
    const s = t._margin._value, r = t._bounds._offsetWidth + s.y + s.w;
    r > e && (e = r);
  }
  return e;
}
function xr(i) {
  let e = 0;
  for (const t of i._children._boxes) {
    if (t._position._value !== "static") continue;
    const s = t._margin._value, r = t._bounds._offsetHeight + s.x + s.z;
    r > e && (e = r);
  }
  return e;
}
class A extends L {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  constructor(e, t) {
    A.definePropertiesValues(e, t), super(e, t), A.init(this);
  }
  /**
   * When the backgroundMesh has been set, bind properties
   * @override
   */
  bindBackgroundMeshProperties() {
    this._bounds._size = this._backgroundMesh.scale, this._bounds._needsProcess = !0;
  }
  /**
   * When the backgroundMesh has been unset, unbind properties
   * @override
   */
  unbindBackgroundMeshProperties() {
    this._bounds._size = new u.Vector3(1, 1, 1), this._bounds._needsProcess = !0;
  }
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(e, t) {
    e.children || (e.children = Ws), e.bounds || (e.bounds = st), e.flexDirection || (e.flexDirection = Ks), e.justifyContent || (e.justifyContent = er), e.alignItems || (e.alignItems = Hs), e.position || (e.position = dr), e.autoSize || (e.autoSize = _r), e.renderer || (e.renderer = nt), t.fontSide || (t.fontSide = 0), t.invertAlpha || (t.invertAlpha = !1), t.fontCastShadow || (t.fontCastShadow = !1), t.fontReceiveShadow || (t.fontReceiveShadow = !1), t.backgroundCastShadow || (t.backgroundCastShadow = !1), t.backgroundReceiveShadow || (t.backgroundReceiveShadow = !1);
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(e) {
    Object.defineProperties(
      e,
      {
        isBox: {
          configurable: !1,
          enumerable: !0,
          value: !0
        }
      }
    ), e.backgroundMaterial = new it(), e._renderer.render(e), e._backgroundMesh.visible = !1;
  }
}
class Ae extends Array {
  /**
   *
   * @param {Inline[]} items
   */
  constructor(...e) {
    super(...e), this.width = 0, this.lineBase = 0, this.lineHeight = 0, this.y = 0;
  }
}
class wr extends p {
  constructor() {
    super("layouter", null, !1), this._needsUpdate = !0, this._childrenPos = {};
  }
  /* eslint-disable no-unused-vars */
  /**
   * Updated when :
   * 	- New child added
   * 	- Child removed
   * 	- Child position changed
   * 	- Child visibility changed
   * 	- ...?
   * 	@override
   */
  update(e, t) {
    this._childrenPos = {};
    for (const s of e._children._boxes)
      s._position._value === "static" && (this._childrenPos[s.id] = s.position);
  }
  /**
   *
   * @override
   */
  /* eslint-disable no-unused-vars */
  process(e) {
  }
}
class T extends A {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} [values={}]
   */
  constructor(e = {}) {
    const t = {};
    T.definePropertiesValues(t, e), super(t, e), T.init(this);
  }
  /* eslint-disable no-unused-vars */
  /**
   * A Block Element can only contains box elements
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(e) {
    const t = [];
    for (let s = 0; s < arguments.length; s++) {
      const r = arguments[s];
      !r.isUI || r.isBox ? t.push(r) : console.warn("Block element can only contain Box elements.", r);
    }
    return super.add(...t);
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(e, t) {
    e.layouter = wr;
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(e) {
    Object.defineProperties(
      e,
      {
        isBlock: {
          configurable: !1,
          enumerable: !0,
          value: !0
        }
      }
    );
  }
}
class Sr extends p {
  constructor() {
    super("textContent", null, !1);
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    e._glyphs._needsUpdate = !0, e._whiteSpace._needsProcess = !0;
  }
}
class Vr extends p {
  constructor() {
    super("inlines", null, !1), this._value = null;
  }
  process(e) {
    if (this._value = e._glyphs._value.map((t) => t.asInlineGlyph()), this._value.length) {
      this._value[0].paddingLeft = e._padding._value.w, this._value[0].marginLeft = e._margin._value.w;
      const t = this._value.length - 1;
      this._value[t].paddingRight = e._padding._value.y, this._value[t].marginRight = e._margin._value.y;
    }
    e._fontSize._needsProcess = !0, e._lineBreak._needsProcess = !0, e._fontKerning._needsProcess = !0, e._layouter._needsProcess = !0;
  }
  /**
   *
   * @return {Array.<Inline>}
   */
  get value() {
    return this._value;
  }
}
class kr extends p {
  constructor() {
    super("glyphs", null, !1), this._needsUpdate = !1, this._value = null;
  }
  process(e) {
    e._font._fontVariant && e._font._fontVariant.isReady && (this._value = e._whiteSpace._whiteSpacedContent.split("").map((t) => e._font._fontVariant.getTypographicGlyph(t)), this._value && (e._inlines._needsProcess = !0));
  }
  /**
   *
   * @return {Array.<TypographicGlyph>}
   */
  get value() {
    return this._value;
  }
}
class Pr extends U {
  constructor() {
    super("color", "inherit", !1), this.output = this._outputValue;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(e) {
    this._input === "inherit" ? this._value.set(this.getInheritedInput(e)) : this._value.set(this._input);
  }
}
class ot extends p {
  constructor(e = `- ,.:?!
`) {
    super("lineBreak", e, !0), this._newLineBreakability = null;
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    this._needsProcess = !0;
  }
  process(e) {
    const t = e._whiteSpace._newLineBreakability;
    if (e._inlines._value)
      for (let s = 0; s < e._inlines._value.length; s++) {
        const r = e._inlines._value[s], n = r.char;
        let o = null;
        n !== void 0 && (t !== "nowrap" && (this._value.includes(n) || n.match(/\s/g)) && (o = "possible"), n.match(/\n/g) && (o = t)), r.lineBreak = o;
      }
  }
  /**
   * @override
   * @return {string}
   */
  get value() {
    return this._value;
  }
}
class at extends p {
  constructor() {
    super("layouter", null, !1), this._value = null;
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    this._value = e._parent.find((s) => s.isUI && s.isText), this._needsProcess = !0;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   */
  process(e) {
    this._value && (this._value._layouter._needsProcess = !0);
  }
}
class Ir extends U {
  constructor(e) {
    super("backgroundColor", e, !1), this._allowsInherit = !1, this._input = 0;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  computeOutputValue(e) {
    this._input === "inherit" ? this._value.set(this.getInheritedInput(e)) : this._value.set(this._input);
  }
}
class ut extends Ne {
  constructor() {
    super(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited;
  }
}
class ht extends Xe {
  constructor() {
    super();
  }
  computeOutputValue(e) {
    this._value = ae(this.getInheritedInput(e));
  }
}
class lt extends qe {
  constructor() {
    super("fontFamily", "inherit", !0), this._input = "inherit", this._needsUpdate = !0, this._allowsInherit = !1;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   */
  computeOutputValue(e) {
    let t = this._inheritedInput;
    if (t === "inherit" && (t = this.getInheritedInput(e)), t instanceof K)
      this._value = t, e._font._needsUpdate = !0;
    else if (typeof t == "string") {
      const s = I.getFontFamily(t);
      s ? (this._value = s, e._font._needsUpdate = !0) : console.warn(`(.style) fontFamily, the font '${t}' is not registered. Aborted.`);
    } else
      console.warn("(.style) fontFamily requires a registered fontFamily instance, or the id of a registered fontFamily."), console.warn("If you want to set a specific font, please use .font property instead.");
  }
  /**
   * @override
   * @return {any|FontFamilyPropertyInline|null}
   */
  get value() {
    return this._value;
  }
}
class Pe extends Ze {
  constructor() {
    super(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited, this._whiteSpacedContent = "", this._stringCollapser = this.emptyStrategyLogic, this._inlineCollapser = this.emptyStrategyLogic, this._inlineWrapper = this.emptyStrategyLogic;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param element
   * @private
   */
  _computeFromInherited(e) {
    switch (super._computeFromInherited(e), this._newLineBreakability = Cr(this._value), this._value) {
      case "nowrap":
      case "normal":
        this._stringCollapser = Rr;
        break;
      case "pre-line":
        this._stringCollapser = ct;
        break;
      default:
        this._stringCollapser = Br;
    }
    switch (this._value) {
      case "pre-line":
      case "nowrap":
      case "normal":
        this._inlineCollapser = Fr;
        break;
      case "pre-wrap":
        this._inlineCollapser = Mr;
        break;
      default:
        this._inlineCollapser = Or;
    }
    switch (this._value) {
      case "pre-line":
      case "pre-wrap":
      case "normal":
        this._inlineWrapper = Ur;
        break;
      case "pre":
        this._inlineWrapper = Ar;
        break;
      default:
        this._inlineWrapper = Tr;
    }
    this._needsProcess = !0;
  }
  process(e) {
    e.isInline && !e.isInlineBlock && (this._whiteSpacedContent = this._stringCollapser(e._textContent._value), e._glyphs._needsProcess = !0);
  }
}
const Te = { "	": "	", "\n": `
`, "\r": "\r", " ": " " }, Cr = function(i) {
  switch (i) {
    case "pre":
    case "pre-wrap":
    case "pre-line":
      return "mandatory";
  }
  return null;
};
function Rr(i) {
  return ct(i.replace(/\n/g, " "));
}
function ct(i) {
  return i.replace(/[ ]{2,}/g, " ");
}
function Br(i) {
  return i;
}
function Ur(i, e, t, s) {
  const r = i[e];
  if (r.lineBreak === "mandatory" || t + r.xadvance + r.xoffset + r.kerning > s.INNER_WIDTH) return !0;
  const n = ft(i, e, s);
  return Lr(i[e - 1], t, n, s);
}
function Ar(i, e, t, s) {
  return i[e].lineBreak === "mandatory";
}
function Tr() {
  return !1;
}
function Mr(i) {
  if (!i[0]) return 0;
  const e = i[0], t = i[i.length - 1];
  return e.char && e.char === `
` && i.length > 1 && _t([e], i[1]), t.char && t.char === `
` && i.length > 1 && dt([t], i[i.length - 2]), e.offsetX;
}
function Fr(i) {
  if (!i[0]) return 0;
  let e = [], t;
  for (let s = 0; s < i.length; s++) {
    const r = i[s];
    if (r.char && Te[r.char] && i.length > s) {
      e.push(r), t = i[s + 1];
      continue;
    }
    break;
  }
  _t(e, t), e = [], t = null;
  for (let s = i.length - 1; s > 0; s--) {
    const r = i[s];
    if (r.char && Te[r.char] && s > 0) {
      e.push(r), t = i[s - 1];
      continue;
    }
    break;
  }
  return dt(e, t), i[0].offsetX;
}
function Or(i) {
  return i[0] ? i[0].offsetX : 0;
}
function dt(i, e) {
  if (e)
    for (let t = 0; t < i.length; t++) {
      const s = i[t];
      s.fontFactor = 0, s.offsetX = e.offsetX + e.cumulativeWidth, s.cumulativeWidth = 0;
    }
}
function _t(i, e) {
  if (e)
    for (let t = 0; t < i.length; t++) {
      const s = i[t];
      s.fontFactor = 0, s.offsetX = e.offsetX, s.cumulativeWidth = 0;
    }
}
function ft(i, e, t, s) {
  if (s = s || 0, !i[e]) return s;
  const r = i[e];
  return r.lineBreak ? s + r.xadvance : ft(
    i,
    e + 1,
    t,
    s + r.xadvance + r.xoffset + r.kerning + t.LETTERSPACING
  );
}
function Lr(i, e, t, s) {
  return !i || !i.char || e + t < s.INNER_WIDTH ? !1 : s.BREAKON.indexOf(i.char) > -1;
}
class pt extends Qe {
  constructor() {
    super(), this._input = "inherit", this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited;
  }
  _computeFromInherited(e) {
    super._computeFromInherited(e), e._fontSize._needsProcess = !0, e._layouter._needsProcess = !0;
  }
}
class gt extends g {
  constructor() {
    super("fontSize", "inherit", !0), this._allowsInherit = !1;
  }
  computeOutputValue(e) {
    this._value = this._inheritedInput, e._font._fontVariant && (e._bounds._needsProcess = !0, e._layouter._needsProcess = !0);
  }
  process(e) {
    if (!e._font._fontVariant || !e._font._fontVariant.isReady) return;
    const t = this._value / e._font._fontVariant.typographic.size, s = e._inlines._value;
    for (let r = 0; r < s.length; r++) {
      const n = s[r];
      n.resetOffsets(), n.fontSize = this._value, n.fontFactor = t;
    }
  }
  /**
   *
   * @return {number}
   */
  get value() {
    return this._value;
  }
}
class mt extends et {
  constructor() {
    super("segments", 1, !1), this._notInheritedValue = void 0;
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    this._notInheritedValue = this._value, this._notInheritedValue === "inherit" && (this._notInheritedValue = this.getInheritedInput(e)), e._layouter._needsUpdate = !0;
  }
  /**
   *
   * @param {number|"inherit"} v
   */
  set value(e) {
    this._value !== e && (this._value = e, this._needsUpdate = !0);
  }
  /**
   *
   * @override
   * @return {number}
   */
  get value() {
    return this._value === "inherit" ? this._notInheritedValue : this._value;
  }
}
class zr extends mt {
  constructor() {
    super(), this._value = "inherit";
  }
}
class Wr extends q {
  constructor() {
    super(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited;
  }
  _computeFromInherited(e) {
    super._computeFromInherited(e), e._parent._value._layouter._needsProcess = !1;
  }
  process(e) {
    if (this._value !== "none") {
      const t = e._whiteSpace._whiteSpacedContent, s = e._inlines._value;
      for (let r = 1; r < s.length; r++) {
        const n = t[r - 1] + t[r];
        s[r].kerning = e._font._fontVariant.getKerningAmount(n);
      }
    }
  }
}
class vt extends p {
  constructor() {
    super("children", null, !1), this._uis = [];
  }
  /* eslint-disable no-unused-vars */
  /**
   * Update requested when :
   * 		- New child has been added
   * 		- Existing child has been removed
   *
   * @param element
   * @param out
   */
  update(e, t) {
  }
  /* eslint-disable no-unused-vars */
  /**
   * Process when :
   * 		- Existing child visibility changed
   *
   * @param element
   */
  process(e) {
  }
  /* eslint-disable no-unused-vars */
  _compute(e) {
  }
  /**
   *
   */
  dispose() {
  }
}
function Er(i, e = !1) {
  const t = i[0].index !== null, s = new Set(Object.keys(i[0].attributes)), r = new Set(Object.keys(i[0].morphAttributes)), n = {}, o = {}, a = i[0].morphTargetsRelative, l = new u.BufferGeometry();
  let d = 0;
  for (let c = 0; c < i.length; ++c) {
    const h = i[c];
    let _ = 0;
    if (t !== (h.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const f in h.attributes) {
      if (!s.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null;
      n[f] === void 0 && (n[f] = []), n[f].push(h.attributes[f]), _++;
    }
    if (_ !== s.size)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ". Make sure all geometries have the same number of attributes."), null;
    if (a !== h.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const f in h.morphAttributes) {
      if (!r.has(f))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ".  .morphAttributes must be consistent throughout all geometries."), null;
      o[f] === void 0 && (o[f] = []), o[f].push(h.morphAttributes[f]);
    }
    if (e) {
      let f;
      if (t)
        f = h.index.count;
      else if (h.attributes.position !== void 0)
        f = h.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ". The geometry must have either an index or a position attribute"), null;
      l.addGroup(d, f, c), d += f;
    }
  }
  if (t) {
    let c = 0;
    const h = [];
    for (let _ = 0; _ < i.length; ++_) {
      const f = i[_].index;
      for (let v = 0; v < f.count; ++v)
        h.push(f.getX(v) + c);
      c += i[_].attributes.position.count;
    }
    l.setIndex(h);
  }
  for (const c in n) {
    const h = Me(n[c]);
    if (!h)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + c + " attribute."), null;
    l.setAttribute(c, h);
  }
  for (const c in o) {
    const h = o[c][0].length;
    if (h === 0) break;
    l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[c] = [];
    for (let _ = 0; _ < h; ++_) {
      const f = [];
      for (let S = 0; S < o[c].length; ++S)
        f.push(o[c][S][_]);
      const v = Me(f);
      if (!v)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + c + " morphAttribute."), null;
      l.morphAttributes[c].push(v);
    }
  }
  return l;
}
function Me(i) {
  let e, t, s, r = -1, n = 0;
  for (let d = 0; d < i.length; ++d) {
    const c = i[d];
    if (e === void 0 && (e = c.array.constructor), e !== c.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t === void 0 && (t = c.itemSize), t !== c.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (s === void 0 && (s = c.normalized), s !== c.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (r === -1 && (r = c.gpuType), r !== c.gpuType)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    n += c.count * t;
  }
  const o = new e(n), a = new u.BufferAttribute(o, t, s);
  let l = 0;
  for (let d = 0; d < i.length; ++d) {
    const c = i[d];
    if (c.isInterleavedBufferAttribute) {
      const h = l / t;
      for (let _ = 0, f = c.count; _ < f; _++)
        for (let v = 0; v < t; v++) {
          const S = c.getComponent(_, v);
          a.setComponent(_ + h, v, S);
        }
    } else
      o.set(c.array, l);
    l += c.count * t;
  }
  return r !== void 0 && (a.gpuType = r), a;
}
class Dr extends p {
  constructor() {
    super("renderer");
  }
  render(e) {
    if (!e._inlines._value || !e._inlines._value.length) return;
    const t = e._inlines._value.map(
      (r) => e._font._fontVariant.getGeometricGlyph(r, e).translate(r.offsetX, r.offsetY, 0)
    ), s = Er(t);
    e.setFontMesh(new u.Mesh(s, e.fontMaterial)), e._fontMesh.renderOrder = 1 / 0;
  }
}
class Hr extends he {
  constructor() {
    super(), this._allowsInherit = !1, this._needsUpdate = !1;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(e) {
    this._value = this._inheritedInput, e._layouter._needsProcess = !0;
  }
}
class B extends L {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} [values={}]
   */
  constructor(e = {}) {
    const t = {};
    B.definePropertiesValues(t, e), super(t, e), B.init(this);
  }
  /* eslint-disable no-unused-vars */
  /**
   * A Text Element can only contains inline elements
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(e) {
    const t = [];
    for (let s = 0; s < arguments.length; s++) {
      const r = arguments[s];
      !r.isUI || r.isInline ? (t.push(r), r.position.z = 5e-3) : console.warn("Block element can only contain Box elements.", r);
    }
    return super.add(...t);
  }
  _rebuildParentUI = () => {
    super._rebuildParentUI(), this._layouter._needsUpdate = !0;
  };
  set textContent(e) {
    this._textContent.value = e;
  }
  get textContent() {
    return this._textContent._value;
  }
  set invertAlpha(e) {
    this._invertAlpha.value = e;
  }
  get invertAlpha() {
    return this._invertAlpha._value;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(e, t) {
    e.children || (e.children = vt), e.textContent || (e.textContent = Sr), e.glyphs || (e.glyphs = kr), e.inlines || (e.inlines = Vr), e.layouter || (e.layouter = at), e.renderer || (e.renderer = Dr), e.fontFamily || (e.fontFamily = lt), e.fontWeight || (e.fontWeight = ht), e.fontStyle || (e.fontStyle = ut), e.fontSize || (e.fontSize = gt), e.color || (e.color = Pr), e.backgroundColor || (e.backgroundColor = Ir), e.lineBreak || (e.lineBreak = ot), e.letterSpacing || (e.letterSpacing = pt), e.whiteSpace || (e.whiteSpace = Pe), e.segments || (e.segments = zr), e.textAlign || (e.textAlign = Hr), e.fontKerning || (e.fontKerning = Wr);
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(e) {
    Object.defineProperties(
      e,
      {
        isInline: {
          configurable: !1,
          enumerable: !0,
          value: !0
        }
      }
    );
  }
}
class Gr extends $e {
  constructor() {
    super("textContent", null, !1), this._needsUpdate = !1;
  }
  set value(e) {
    this._value !== e && (this._value = e, this._needsUpdate = !0);
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    this._needsUpdate = !1;
    for (let s = e.children.length - 1; s >= 0; s--) {
      const r = e.children[s];
      r.isUI && (e.remove(r), r.clear());
    }
    e._children._uis = [], this._value && e.add(new B({ name: "anonymousInline", textContent: this._value }));
  }
}
class $r extends Array {
  /**
   *
   * @param {Line} items
   */
  constructor(...e) {
    super(...e), this.width = 0, this.height = 0;
  }
}
class Nr extends p {
  constructor() {
    super("layouter", null, !1), this._value = null;
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
  }
  /**
   *
   * @override
   */
  process(e) {
    let t = e._width._value;
    e._width._auto ? t = 1 / 0 : t = e._bounds._innerWidth;
    const s = e._lineHeight._value, r = new $r(new Ae());
    let n = 0;
    e._children._inlines.forEach((h) => {
      if (!h._inlines.value) return;
      this._resetInlines(h);
      const _ = h._fontSize._value, f = h._letterSpacing._value * _, v = h._whiteSpace._value, S = h._lineBreak._value, b = {
        WHITESPACE: v,
        LETTERSPACING: f,
        BREAKON: S,
        INNER_WIDTH: t
      }, St = h._whiteSpace._inlineWrapper;
      n += h._margin._value.w + h._padding._value.w, h._inlines.value.forEach((y, Vt, kt) => {
        const J = r[r.length - 1];
        if (St(kt, Vt, n, b)) {
          if (r.push(new Ae(y)), y.offsetX = y.xoffset, y.width === 0) {
            n = 0;
            return;
          }
          y.cumulativeWidth = y.xadvance + f, n = y.cumulativeWidth;
          return;
        }
        r[r.length - 1].push(y), y.offsetX = n + y.xoffset + y.kerning, y.cumulativeWidth = y.xadvance + y.kerning + f, n += y.cumulativeWidth, J.length - 1 === 1 && J[J.length - 2].width === 0 && (y.offsetX -= y.xoffset, n -= y.xoffset);
      }), n += h._margin._value.y + h._padding._value.y;
    });
    const o = e._whiteSpace._inlineCollapser;
    let a = 0, l = 0, d = 0;
    r.forEach((h, _) => {
      const f = o(h);
      let v = 0, S = 0;
      if (h.forEach((b) => {
        v = Math.max(v, b.lineHeight), S = Math.max(S, b.lineBase), b.offsetX -= f;
      }), h.lineHeight = v, h.lineBase = S, _ === 0 ? d = -(v * s - v) * 0.5 : d -= r[_ - 1].lineHeight * s, h.y = d, h.x = 0, h.forEach((b) => {
        b.offsetY = d - b.anchor, b.lineHeight < h.lineHeight && (b.offsetY -= h.lineBase - b.lineBase);
      }), l += h.lineHeight * s, h.width = 0, h[0]) {
        const b = h[h.length - 1];
        h.width = b.offsetX + b.cumulativeWidth + b.paddingRight + b.marginRight + h[0].offsetX, a = Math.max(a, h.width);
      }
    }), r.height = l, r.width = a, this._value = r, t === 1 / 0 && e._bounds.setChildrenWidth(e, r.width), e._height._auto && e._bounds.setChildrenHeight(e, r.height);
    const c = e._parent._value;
    c && (c._autoSize._needsProcess = !0, c._flexDirection._needsProcess = !0), e._inlineJustificator._needsProcess = !0, e._textAlign._needsProcess = !0, e._overflow._needsUpdate = !0;
  }
  /**
   *
   * @param inlineElement
   * @protected
   */
  _resetInlines(e) {
    e._fontSize.process(e);
  }
}
class Xr extends he {
  constructor() {
    super(), this._allowsInherit = !1, this._needsUpdate = !0;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(e) {
    this._value = this._inheritedInput, this._needsProcess = !0;
  }
  process(e) {
    jr(e), e._renderer._needsRender = !0;
  }
}
function jr(i) {
  const e = i._layouter._value, t = i._textAlign._value, s = i._bounds._innerWidth;
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = Yr(i, n, r === e.length - 1), a = i._padding._value, l = i._borderWidth._value, d = (-a.w + a.y) / 2 + (-l.w + l.y) / 2;
    n.x += o;
    for (let c = 0; c < n.length; c++)
      n[c].offsetX += o - d;
  }
  if (t.indexOf("justify") === 0)
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (t.indexOf("-") !== -1 && r === e.length - 1) return;
      const o = s - n.width;
      if (o <= 0) return;
      let a = 0;
      for (let h = 1; h < n.length - 1; h++)
        a += n[h].char === " " ? 1 : 0;
      const l = o / a;
      let d = 1;
      t === "justify-right" && (n.reverse(), d = -1);
      let c = 0;
      for (let h = 1; h <= n.length - 1; h++) {
        const _ = n[h];
        _.offsetX += c * d, c += _.char === " " ? l : 0;
      }
      t === "justify-right" && n.reverse();
    }
}
function Yr(i, e, t) {
  switch (i._textAlign._value) {
    case "justify-left":
    case "justify":
    case "left":
      return -i._bounds._innerWidth / 2;
    case "justify-right":
    case "right":
      return -e.width + i._bounds._innerWidth / 2;
    case "center":
      return -e.width / 2;
    case "justify-center":
      return t ? -e.width / 2 : -i._bounds._innerWidth / 2;
    default:
      console.warn(`textAlign: '${i._textAlign._value}' is not valid`);
  }
}
class Kr extends le {
  constructor() {
    super(), this._value = this._input = "column", this._allowsInherit = !1, this._needsUpdate = !0;
  }
  /* eslint-disable no-unused-vars */
  computeOutputValue(e) {
    this._value = this._inheritedInput;
  }
}
class qr extends Je {
  /**
   *
   */
  constructor() {
    super(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited;
  }
}
class Jr extends q {
  constructor() {
    super(), this._value = this._input = this.getDefaultValue(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited;
  }
  _computeFromInherited(e) {
    super._computeFromInherited(e);
  }
}
class Zr extends st {
  constructor() {
    super(), this._innerWidth = 1 / 0, this._innerHeight = 0;
  }
}
class Qr extends p {
  constructor() {
    super("children", null, !1), this._uis = [], this._inlines = [], this._boxes = [];
  }
  /* eslint-disable no-unused-vars */
  /**
   * Update requested when :
   * 		- New child has been added
   * 		- Existing child has been removed
   *
   * @param element
   * @param out
   */
  update(e, t) {
    this._compute(e), this._needsProcess = !0;
  }
  /**
   * Process when :
   * 		- Existing child visibility changed
   *
   * @param element
   */
  process(e) {
    this._compute(e), e._overflow._needsRender = !0;
  }
  _compute(e) {
    this._uis = e.children.filter((t) => t.visible && t.isUI), this._inlines = this._uis.filter((t) => t.isInline).sort(this._sortOrder);
  }
  /**
   *
   */
  dispose() {
    this._inlines = null;
  }
  /**
   *
   * Sort children according to their .style.order property or fallback on children index
   *
   * @param {HTMLElementVR} a
   * @param {HTMLElementVR} b
   * @return {number}
   * @private
   */
  _sortOrder = (e, t) => e._order._value < t._order._value ? -1 : e._order._value > t._order._value ? 1 : this._uis.indexOf(e) < this._uis.indexOf(t) ? -1 : 1;
}
class en extends p {
  constructor() {
    super("autosize");
  }
  process(e) {
    if (e._layouter._value && e._layouter._value.length) {
      const t = e._layouter._value, s = e._padding._value, r = e._borderWidth._value;
      e._width._auto && e._bounds.setOffsetWidth(e, t.width + s.w + s.y + r.w + r.y), e._height._auto && e._bounds.setOffsetHeight(e, t.height + s.x + s.z + r.x + r.z);
    }
  }
}
class tn extends nt {
  constructor() {
    super("renderer"), this._needsUpdate = !1;
  }
  render(e) {
    super.render(e);
    for (const t of e._children._inlines)
      t._renderer.render(t);
    e.performAfterUpdate();
  }
}
class M extends A {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} [values={}]
   * @param [properties={}]
   */
  constructor(e = {}, t = {}) {
    M.definePropertiesValues(t, e), super(t, e), M.init(this);
  }
  /* eslint-disable no-unused-vars */
  /**
   * A Text Element can only contains inline elements
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(e) {
    const t = [];
    let s = !1;
    for (let r = 0; r < arguments.length; r++) {
      const n = arguments[r];
      !n.isUI || n.isInline ? (n.isInline && (s = !0), t.push(n)) : console.warn("Block element can only contain Box elements.", n);
    }
    return t.length > 0 && super.add(...t), s && (this._children._needsUpdate = !0, this._layouter._needsProcess = !0), this;
  }
  set textContent(e) {
    this._textContent.value = e;
  }
  // Must redefine getter also, or issue.
  get textContent() {
    return super.textContent;
  }
  set invertAlpha(e) {
    this._invertAlpha.value = e;
  }
  get invertAlpha() {
    return this._invertAlpha._value;
  }
  get lines() {
    return this._layouter._value;
  }
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(e, t) {
    e.flexDirection = Kr, e.justifyContent = ce, e.alignItems = ue, e.bounds = Zr, e.autoSize = en, e.renderer = tn, e.children || (e.children = Qr), e.textContent || (e.textContent = Gr), e.layouter || (e.layouter = Nr), e.lineHeight || (e.lineHeight = qr), e.textAlign || (e.textAlign = Xr), e.whiteSpace || (e.whiteSpace = Pe), e.fontKerning || (e.fontKerning = Jr), e.segments || (e.segments = mt), t.width || (t.width = "100%"), t.fontSide || (t.fontSide = 0);
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(e) {
    Object.defineProperties(
      e,
      {
        isText: {
          configurable: !1,
          enumerable: !0,
          value: !0
        }
      }
    );
  }
}
class sn extends p {
  constructor() {
    super("inlines", null, !1), this._value = [];
  }
  process(e) {
    this._value[0].paddingLeft = e._padding._value.w, this._value[0].marginLeft = e._margin._value.w;
    const t = this._value.length - 1;
    this._value[t].paddingRight = e._padding._value.y, this._value[t].marginRight = e._margin._value.y;
  }
}
class rn extends p {
  constructor() {
    super("renderer");
  }
  render(e) {
    e._backgroundMesh || e.setBackgroundMesh(new rt(e)), e._backgroundMesh.position.x = e._inlines._value[0].offsetX + e._inlines._value[0].width / 2, e._backgroundMesh.position.y = e._inlines._value[0].offsetY + e._inlines._value[0].lineBase / 2, e._bounds.render(e);
  }
}
class nn extends p {
  constructor() {
    super("bounds", null, !1), this._size = new u.Vector3(1, 1, 1), this._offsetWidth = 0, this._offsetHeight = 0, this._innerWidth = 0, this._innerHeight = 0;
  }
  /* eslint-disable no-unused-vars */
  update(e, t) {
    this.output(t), this._needsProcess = !0;
  }
  process(e) {
    this._offsetWidth = this._innerWidth = e._inlines._value[0].width, this._offsetHeight = this._innerHeight = e._inlines._value[0].height, this._needsRender = !0, e._borderWidth._needsRender = !0, e._borderRadius._needsRender = !0;
  }
  /* eslint-disable no-unused-vars */
  render(e) {
    this._size.x = this._offsetWidth, this._size.y = this._offsetHeight;
  }
  /**
   *
   * @param {Object.<string,any>} out
   */
  output(e) {
    e.size = this._size;
  }
}
class F extends L {
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} [values={}]
   */
  constructor(e = {}) {
    const t = {};
    F.definePropertiesValues(t, e), super(t, e), F.init(this);
  }
  clear() {
    for (const e of this._inlines._value)
      e.clear();
    return super.clear();
  }
  /**
   * When the backgroundMesh has been set, bind properties
   * @override
   */
  bindBackgroundMeshProperties() {
    this._backgroundMesh.raycast = () => {
    }, this._bounds._size = this._backgroundMesh.scale, this._bounds._needsUpdate = !0;
  }
  /**
   * When the backgroundMesh has been unset, unbind properties
   * @override
   */
  unbindBackgroundMeshProperties() {
    this._bounds._size = new u.Vector3(1, 1, 1), this._bounds._needsUpdate = !0;
  }
  /* eslint-disable no-unused-vars */
  /**
   *
   * @override
   * @param {...Object3D} object
   * @return {this}
   */
  add(e) {
    const t = [];
    for (let s = 0; s < arguments.length; s++) {
      const r = arguments[s];
      r.isUI ? console.warn("ThreeMeshUI::InlineBlockElement cannot contains UI Elements.", r) : (t.push(r), r.position.z = 5e-3);
    }
    return super.add(...t);
  }
  /**
   *
   * @param {import('./../../core/elements/MeshUIBaseElement').Properties} properties
   * @param {import('./../../core/elements/MeshUIBaseElement').Options} values
   */
  static definePropertiesValues(e, t) {
    e.children || (e.children = vt), e.bounds || (e.bounds = nn), e.inlines || (e.inlines = sn), e.layouter || (e.layouter = at), e.renderer || (e.renderer = rn), e.fontFamily || (e.fontFamily = lt), e.fontWeight || (e.fontWeight = ht), e.fontStyle || (e.fontStyle = ut), e.fontSize || (e.fontSize = gt), e.backgroundColor || (e.backgroundColor = De), e.lineBreak || (e.lineBreak = ot), e.letterSpacing || (e.letterSpacing = pt), e.whiteSpace || (e.whiteSpace = Pe), e.fontKerning || (e.fontKerning = q), t.backgroundSize || (t.backgroundSize = "cover"), t.width || (t.width = "100%"), t.height || (t.height = "100%"), t.boxSizing || (t.boxSizing = "border-box");
  }
  /**
   *
   * @param {MeshUIBaseElement} element
   */
  static init(e) {
    Object.defineProperties(
      e,
      {
        isInline: {
          configurable: !1,
          enumerable: !0,
          value: !0
        },
        isInlineBlock: {
          configurable: !1,
          enumerable: !0,
          value: !0
        }
      }
    ), e._inlines._value = [new on(e)], e.backgroundMaterial = new it(), e._renderer.render(e);
  }
}
class on extends Oe {
  /**
   *
   * @param {InlineBlockElement} parent
   */
  constructor(e) {
    super(), this._uiElement = e;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get xadvance() {
    const e = this._uiElement._padding._value, t = this._uiElement._width;
    return t._relative ? t._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.w + e.y + t.value;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get width() {
    const e = this._uiElement._width;
    return e._relative ? e._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.value;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get height() {
    const e = this._uiElement._height;
    return e._relative ? e._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.value;
  }
  get anchor() {
    return this.height;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get lineHeight() {
    const e = this._uiElement._height;
    return e._relative ? e._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.value;
  }
  /**
   * Rely on the parent for size computation
   * @override
   * @returns {number}
   */
  get lineBase() {
    const e = this._uiElement._height;
    return e._relative ? e._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.value;
  }
  /**
   *
   */
  clear() {
    this._uiElement = null;
  }
}
class yt {
  /**
   *
   * @param {MeshUIBaseElement} subject
   */
  constructor(e) {
    this._subject = e;
  }
  /**
   * @abstract
   */
  attach() {
    console.error(`Behavior::attach() - Is abstract and therefore should be overridden in ${this.constructor.name}`);
  }
  /**
   * @abstract
   * @returns {void}
   */
  act() {
    throw new Error(`Behavior::act() - Is abstract and therefore should be overridden in ${this.constructor.name}`);
  }
  /**
   * @abstract
   */
  detach() {
    console.error(`Behavior::detach() - Is abstract and therefore should be overridden in ${this.constructor.name}`);
  }
  /**
   *
   */
  clear() {
  }
}
const bt = () => N.update(), xt = {
  BaseProperty: p,
  Block: T,
  Text: M,
  Inline: B,
  InlineBlock: F,
  // Keyboard : KeyboardElement,
  MeshUIBaseElement: L,
  FontLibrary: I,
  update: bt,
  MSDFFontMaterialUtils: w,
  ShaderChunkUI: tt,
  Behavior: yt,
  FontVariant: O
};
typeof global < "u" && (global.ThreeMeshUI = xt);
const an = xt;
var un = m.ti, wt = m.nS, hn = m.eB, ln = m.Yp, cn = m.VB, dn = m.BC, _n = m.zN, fn = m.cV, pn = m.hW, gn = m.k2, mn = m.K6, vn = m.M7, yn = m.ls, bn = m.Hi, xn = m.EY, wn = m.MR, Sn = m.zf, Vn = m.Ay, kn = m.yo;
const Cn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseProperty: un,
  Behavior: wt,
  Block: hn,
  DefaultValues: ln,
  FontLibrary: cn,
  FontVariant: dn,
  InheritableProperty: _n,
  Inline: fn,
  InlineBlock: pn,
  InlineGlyph: gn,
  MSDFFontMaterialUtils: mn,
  MaterialTransformers: vn,
  MeshUIBaseElement: yn,
  ShaderChunkUI: bn,
  Text: xn,
  TypographicFont: wn,
  TypographicGlyph: Sn,
  default: Vn,
  update: kn
}, Symbol.toStringTag, { value: "Module" }));
class Rn extends wt {
  constructor(e, t = {}) {
    super(e), e._simpleState__activeStates = [], e._simpleState__normalStyles = {}, e._simpleState__states = t, e._simpleState__statesProperties = {};
    for (const s in t)
      for (const r in t[s])
        e._simpleState__statesProperties[r] || (e._simpleState__statesProperties[r] = []), e._simpleState__statesProperties[r].push(s);
    for (const s of e._components)
      e._simpleState__statesProperties[s.id] && (e._simpleState__normalStyles[s.id] = s.inline ? s.inline : s._value);
    e.__overridedSet = e.set, e.set = this.storeSet.bind(e), e.renderStates = this.renderStates.bind(e), e.setupState = this.setupState.bind(e), e.setState = this.setState.bind(e), e.activatePseudoState = this.activatePseudoState.bind(e), e.deactivatePseudoState = this.deactivatePseudoState.bind(e), e.togglePseudoState = this.togglePseudoState.bind(e);
  }
  act() {
  }
  attach() {
  }
  detach() {
  }
  setupState(e, t) {
    this._simpleState__states[e] = t;
    const s = [];
    for (const r in t)
      this._simpleState__statesProperties[r] || (this._simpleState__statesProperties[r] = [], s.push(r)), this._simpleState__statesProperties[r].push(e);
    for (const r of this._components)
      s.indexOf(r.id) > -1 && (this._simpleState__normalStyles[r.id] = r.inline ? r.inline : r._value);
  }
  renderStates() {
    let e = { ...this._simpleState__normalStyles };
    for (const t in this._simpleState__states)
      this._simpleState__activeStates.indexOf(t) > -1 && (e = { ...e, ...this._simpleState__states[t] });
    this.set(e, !1);
  }
  /**
   * @internal will replace default set method
   * @param options
   * @param store
   */
  storeSet(e, t = !0) {
    if (t)
      for (const s in e)
        this._simpleState__statesProperties[s] && (this._simpleState__normalStyles[s] = e[s]);
    this.__overridedSet(e);
  }
  activatePseudoState(e) {
    this._simpleState__activeStates.indexOf(e) === -1 && (this._simpleState__activeStates.push(e), this.renderStates());
  }
  deactivatePseudoState(e) {
    const t = this._simpleState__activeStates.indexOf(e);
    t > -1 && (this._simpleState__activeStates.splice(t, 1), this.renderStates());
  }
  togglePseudoState(e) {
    const t = this._simpleState__activeStates.indexOf(e);
    t > -1 ? this._simpleState__activeStates.splice(t, 1) : this._simpleState__activeStates.push(e), this.renderStates();
  }
  setState(e) {
    Array.isArray(e) ? this._simpleState__activeStates = e : this._simpleState__activeStates = [e], this.renderStates();
  }
}
export {
  Rn as SimpleStateBehavior,
  Cn as ThreeMeshUI,
  hn as __webpack_exports__Block,
  cn as __webpack_exports__FontLibrary,
  fn as __webpack_exports__Inline,
  xn as __webpack_exports__Text,
  Vn as __webpack_exports__default,
  kn as __webpack_exports__update
};
