import { Mesh as q, SphereGeometry as ui, Vector3 as P, MeshBasicMaterial as Qt, Node as fa, PerspectiveCamera as gs, NodeFrame as Ia, NodeBuilder as ma, GLSLNodeParser as Ea, ShaderLib as wt, UniformsUtils as gi, UniformsLib as Un, normalView as ba, defaultShaderStages as Yn, ShaderChunk as Ca, Material as en, TrianglesDrawMode as Ba, TriangleFanDrawMode as qs, TriangleStripDrawMode as Do, Matrix4 as ue, Loader as kt, LoaderUtils as tn, FileLoader as It, MeshPhysicalMaterial as Tt, Vector2 as Le, Color as Se, LinearSRGBColorSpace as Xe, SRGBColorSpace as ge, SpotLight as Ro, PointLight as zs, DirectionalLight as _o, InstancedMesh as wa, Quaternion as Te, InstancedBufferAttribute as ya, Object3D as xt, TextureLoader as di, ImageBitmapLoader as Qa, BufferAttribute as st, InterleavedBuffer as xa, LinearMipmapLinearFilter as jn, NearestMipmapLinearFilter as Mo, LinearMipmapNearestFilter as Fo, NearestMipmapNearestFilter as pi, LinearFilter as rt, NearestFilter as cs, RepeatWrapping as on, MirroredRepeatWrapping as ko, ClampToEdgeWrapping as ls, PointsMaterial as _n, LineBasicMaterial as Ft, MeshStandardMaterial as fi, DoubleSide as Ii, PropertyBinding as Lt, BufferGeometry as ut, SkinnedMesh as Lo, LineSegments as hs, Line as pt, LineLoop as Sa, Points as is, Group as nn, MathUtils as Qe, OrthographicCamera as No, Skeleton as Uo, AnimationClip as Go, Bone as Ys, InterpolateDiscrete as Po, InterpolateLinear as mi, InterleavedBufferAttribute as $t, Texture as Ks, VectorKeyframeTrack as Js, NumberKeyframeTrack as Vs, QuaternionKeyframeTrack as Ws, ColorManagement as Ve, FrontSide as Oo, Interpolant as Ta, Box3 as ds, Sphere as Ei, RGBA_S3TC_DXT1_Format as Xs, RGB_PVRTC_4BPPV1_Format as va, RGB_ETC2_Format as Ho, RGB_ETC1_Format as Da, RGBA_S3TC_DXT5_Format as Zs, RGBA_PVRTC_4BPPV1_Format as Ra, RGBA_ETC2_EAC_Format as jo, RGBA_BPTC_Format as $s, RGB_BPTC_UNSIGNED_Format as _a, RGBA_ASTC_4x4_Format as os, RGBAFormat as zt, FloatType as mt, HalfFloatType as We, UnsignedByteType as dt, CompressedCubeTexture as Ma, CompressedArrayTexture as Fa, CompressedTexture as Gn, NoColorSpace as us, RGBA_S3TC_DXT3_Format as Mi, RGB_S3TC_DXT1_Format as Fi, RGBA_ASTC_6x6_Format as ki, RGBFormat as ei, RedFormat as gn, RGFormat as Mn, UnsignedInt101111Type as qo, UnsignedInt5999Type as zo, DataTexture as ka, Data3DTexture as La, ExtrudeGeometry as Na, ShapePath as Ua, Raycaster as bi, CylinderGeometry as Ye, BoxGeometry as je, Float32BufferAttribute as Fe, OctahedronGeometry as Kn, TorusGeometry as bn, Euler as qt, Controls as Yo, PlaneGeometry as Ci, DataTextureLoader as Ko, DataUtils as dn, Vector4 as Nt, Curve as Ga, MeshPhongMaterial as Pn, MeshLambertMaterial as Pa, EquirectangularReflectionMapping as Oa, AmbientLight as Ha, Uint16BufferAttribute as ja, Matrix3 as Jo, ShapeUtils as qa, DefaultLoadingManager as za, Ray as Ya, Plane as Ka, MOUSE as fn, TOUCH as pn, Spherical as Li, ShaderMaterial as Vo, Uniform$1 as Ja, Scene as ti, WebGLRenderer as Va, CanvasTexture as Wo, REVISION as Wa, Source as Xa, InstancedBufferGeometry as Za, InstancedInterleavedBuffer as ni, WireframeGeometry as $a, Line3 as eA } from "./three-CsHK73Zc.js";
class ph extends q {
  constructor(e, t, s, n = 128) {
    if (t <= 0 || s <= 0 || n <= 0)
      throw new Error("GroundedSkybox height, radius, and resolution must be positive.");
    const i = new ui(s, 2 * n, n);
    i.scale(1, 1, -1);
    const o = i.getAttribute("position"), r = new P();
    for (let a = 0; a < o.count; ++a)
      if (r.fromBufferAttribute(o, a), r.y < 0) {
        const c = -t * 3 / 2, l = r.y < c ? -t / r.y : 1 - r.y * r.y / (3 * c * c);
        r.multiplyScalar(l), r.toArray(o.array, 3 * a);
      }
    o.needsUpdate = !0, super(i, new Qt({ map: e, depthWrite: !1 }));
  }
}
class Be extends fa {
  constructor(e) {
    super(e.nodeType), this.node = null, this.source = null, this.target = null, this.inclusionType = "replace", Object.assign(this, e);
  }
  generate(e) {
    return this.node.build(e, this.getNodeType(e));
  }
}
const nt = new Ia();
nt.camera = new gs();
const Ni = {
  LineBasicNodeMaterial: wt.basic,
  MeshBasicNodeMaterial: wt.basic,
  PointsNodeMaterial: wt.points,
  MeshStandardNodeMaterial: wt.standard,
  MeshPhysicalNodeMaterial: wt.physical,
  MeshPhongNodeMaterial: wt.phong
}, tA = {
  atan2: "atan"
}, nA = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
function Pt(A) {
  return `#include <${A}>`;
}
function Cn(A) {
  return `${A}Shader`;
}
class sA extends ma {
  constructor(e, t, s, n = null) {
    super(e, t, new Ea(), null, n), this.shader = s, this.slots = { vertex: [], fragment: [] }, this._parseShaderLib(), this._parseInclude("fragment", "lights_physical_fragment", "clearcoat_normal_fragment_begin", "transmission_fragment"), this._parseObject(), this._sortSlotsToFlow(), this.useComparisonMethod = !0;
  }
  getMethod(e) {
    return tA[e] || e;
  }
  addSlot(e, t) {
    this.slots[e].push(t);
  }
  _parseShaderLib() {
    const e = this.material;
    let t = e.type;
    if (e.isMeshPhysicalNodeMaterial ? t = "MeshPhysicalNodeMaterial" : e.isMeshStandardNodeMaterial ? t = "MeshStandardNodeMaterial" : e.isMeshPhongNodeMaterial ? t = "MeshPhongNodeMaterial" : e.isMeshBasicNodeMaterial ? t = "MeshBasicNodeMaterial" : e.isPointsNodeMaterial ? t = "PointsNodeMaterial" : e.isLineBasicNodeMaterial && (t = "LineBasicNodeMaterial"), Ni[t] !== void 0) {
      const s = Ni[t], n = this.shader;
      n.vertexShader = s.vertexShader, n.fragmentShader = s.fragmentShader, n.uniforms = gi.merge([s.uniforms, Un.lights]);
    }
  }
  _parseObject() {
    const { material: e, renderer: t } = this;
    this.addSlot("fragment", new Be({
      node: ba,
      nodeType: "vec3",
      source: "void main() {",
      target: "vec3 TransformedNormalView = %RESULT%;",
      inclusionType: "append"
    })), t.toneMappingNode && t.toneMappingNode.isNode === !0 && this.addSlot("fragment", new Be({
      node: e.colorNode,
      nodeType: "vec4",
      source: Pt("tonemapping_fragment"),
      target: ""
    })), e.colorNode && e.colorNode.isNode && this.addSlot("fragment", new Be({
      node: e.colorNode,
      nodeType: "vec4",
      source: "vec4 diffuseColor = vec4( diffuse, opacity );",
      target: "vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;"
    })), e.opacityNode && e.opacityNode.isNode && this.addSlot("fragment", new Be({
      node: e.opacityNode,
      nodeType: "float",
      source: Pt("alphatest_fragment"),
      target: "diffuseColor.a = %RESULT%;",
      inclusionType: "append"
    })), e.normalNode && e.normalNode.isNode && this.addSlot("fragment", new Be({
      node: e.normalNode,
      nodeType: "vec3",
      source: Pt("normal_fragment_begin"),
      target: "normal = %RESULT%;",
      inclusionType: "append"
    })), e.emissiveNode && e.emissiveNode.isNode && this.addSlot("fragment", new Be({
      node: e.emissiveNode,
      nodeType: "vec3",
      source: Pt("emissivemap_fragment"),
      target: "totalEmissiveRadiance = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshStandardNodeMaterial && (e.metalnessNode && e.metalnessNode.isNode && this.addSlot("fragment", new Be({
      node: e.metalnessNode,
      nodeType: "float",
      source: Pt("metalnessmap_fragment"),
      target: "metalnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.roughnessNode && e.roughnessNode.isNode && this.addSlot("fragment", new Be({
      node: e.roughnessNode,
      nodeType: "float",
      source: Pt("roughnessmap_fragment"),
      target: "roughnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshPhysicalNodeMaterial && (e.clearcoatNode && e.clearcoatNode.isNode ? (this.addSlot("fragment", new Be({
      node: e.clearcoatNode,
      nodeType: "float",
      source: "material.clearcoat = clearcoat;",
      target: "material.clearcoat = %RESULT%;"
    })), e.clearcoatRoughnessNode && e.clearcoatRoughnessNode.isNode && this.addSlot("fragment", new Be({
      node: e.clearcoatRoughnessNode,
      nodeType: "float",
      source: "material.clearcoatRoughness = clearcoatRoughness;",
      target: "material.clearcoatRoughness = %RESULT%;"
    })), e.clearcoatNormalNode && e.clearcoatNormalNode.isNode && this.addSlot("fragment", new Be({
      node: e.clearcoatNormalNode,
      nodeType: "vec3",
      source: "vec3 clearcoatNormal = nonPerturbedNormal;",
      target: "vec3 clearcoatNormal = %RESULT%;"
    })), e.defines.USE_CLEARCOAT = "") : delete e.defines.USE_CLEARCOAT, e.sheenNode && e.sheenNode.isNode ? (this.addSlot("fragment", new Be({
      node: e.sheenNode,
      nodeType: "vec3",
      source: "material.sheenColor = sheenColor;",
      target: "material.sheenColor = %RESULT%;"
    })), e.sheenRoughnessNode && e.sheenRoughnessNode.isNode && this.addSlot("fragment", new Be({
      node: e.sheenRoughnessNode,
      nodeType: "float",
      source: "material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",
      target: "material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"
    })), e.defines.USE_SHEEN = "") : delete e.defines.USE_SHEEN, e.iridescenceNode && e.iridescenceNode.isNode ? (this.addSlot("fragment", new Be({
      node: e.iridescenceNode,
      nodeType: "float",
      source: "material.iridescence = iridescence;",
      target: "material.iridescence = %RESULT%;"
    })), e.iridescenceIORNode && e.iridescenceIORNode.isNode && this.addSlot("fragment", new Be({
      node: e.iridescenceIORNode,
      nodeType: "float",
      source: "material.iridescenceIOR = iridescenceIOR;",
      target: "material.iridescenceIOR = %RESULT%;"
    })), e.iridescenceThicknessNode && e.iridescenceThicknessNode.isNode && this.addSlot("fragment", new Be({
      node: e.iridescenceThicknessNode,
      nodeType: "float",
      source: "material.iridescenceThickness = iridescenceThicknessMaximum;",
      target: "material.iridescenceThickness = %RESULT%;"
    })), e.defines.USE_IRIDESCENCE = "") : delete e.defines.USE_IRIDESCENCE, e.iorNode && e.iorNode.isNode && this.addSlot("fragment", new Be({
      node: e.iorNode,
      nodeType: "float",
      source: "material.ior = ior;",
      target: "material.ior = %RESULT%;"
    })), e.specularColorNode && e.specularColorNode.isNode && this.addSlot("fragment", new Be({
      node: e.specularColorNode,
      nodeType: "vec3",
      source: "vec3 specularColorFactor = specularColor;",
      target: "vec3 specularColorFactor = %RESULT%;"
    })), e.specularIntensityNode && e.specularIntensityNode.isNode && this.addSlot("fragment", new Be({
      node: e.specularIntensityNode,
      nodeType: "float",
      source: "float specularIntensityFactor = specularIntensity;",
      target: "float specularIntensityFactor = %RESULT%;"
    })), e.transmissionNode && e.transmissionNode.isNode ? (this.addSlot("fragment", new Be({
      node: e.transmissionNode,
      nodeType: "float",
      source: "material.transmission = transmission;",
      target: "material.transmission = %RESULT%;"
    })), e.thicknessNode && e.thicknessNode.isNode && this.addSlot("fragment", new Be({
      node: e.thicknessNode,
      nodeType: "float",
      source: "material.thickness = thickness;",
      target: "material.thickness = %RESULT%;"
    })), e.attenuationDistanceNode && e.attenuationDistanceNode.isNode && this.addSlot("fragment", new Be({
      node: e.attenuationDistanceNode,
      nodeType: "float",
      source: "material.attenuationDistance = attenuationDistance;",
      target: "material.attenuationDistance = %RESULT%;"
    })), e.attenuationColorNode && e.attenuationColorNode.isNode && this.addSlot("fragment", new Be({
      node: e.attenuationColorNode,
      nodeType: "vec3",
      source: "material.attenuationColor = attenuationColor;",
      target: "material.attenuationColor = %RESULT%;"
    })), e.transmission = 1, e.defines.USE_TRANSMISSION = "") : (e.transmission = 0, delete e.defines.USE_TRANSMISSION))), e.positionNode && e.positionNode.isNode && this.addSlot("vertex", new Be({
      node: e.positionNode,
      nodeType: "vec3",
      source: Pt("begin_vertex"),
      target: "transformed = %RESULT%;",
      inclusionType: "append"
    })), e.sizeNode && e.sizeNode.isNode && this.addSlot("vertex", new Be({
      node: e.sizeNode,
      nodeType: "float",
      source: "gl_PointSize = size;",
      target: "gl_PointSize = %RESULT%;"
    }));
  }
  generateTexture(e, t, s) {
    return e.isTextureCube ? `textureCube( ${t}, ${s} )` : `texture2D( ${t}, ${s} )`;
  }
  generateTextureLevel(e, t, s, n) {
    return `textureLod( ${t}, ${s}, ${n} )`;
  }
  buildFunctionCode(e) {
    const t = e.layout, s = this.flowShaderNode(e), n = [];
    for (const o of t.inputs)
      n.push(this.getType(o.type) + " " + o.name);
    return `${this.getType(t.type)} ${t.name}( ${n.join(", ")} ) {

	${s.vars}

${s.code}
	return ${s.result};

}`;
  }
  getUniforms(e) {
    const t = this.uniforms[e];
    let s = "";
    for (const n of t) {
      if (/^(modelViewMatrix|projectionMatrix)$/.test(n.name))
        continue;
      let i = null;
      n.type === "texture" ? i = `sampler2D ${n.name}; ` : n.type === "cubeTexture" ? i = `samplerCube ${n.name}; ` : i = `${this.getVectorType(n.type)} ${n.name}; `;
      const o = n.node.precision;
      o !== null ? i = "uniform " + nA[o] + " " + i : i = "uniform " + i, s += i;
    }
    return s;
  }
  getAttributes(e) {
    let t = "";
    if (e === "vertex") {
      const s = this.attributes;
      for (const n of s)
        /^(position|normal|uv[1-3]?)$/.test(n.name) || (t += `attribute ${n.type} ${n.name}; `);
    }
    return t;
  }
  getVaryings(e) {
    let t = "";
    const s = this.varyings;
    if (e === "vertex")
      for (const n of s)
        t += `${n.needsInterpolation ? "varying" : "/*varying*/"} ${n.type} ${n.name}; `;
    else if (e === "fragment")
      for (const n of s)
        n.needsInterpolation && (t += `varying ${n.type} ${n.name}; `);
    return t;
  }
  addCode(e, t, s, n = this) {
    const i = Cn(e);
    let o = n[i];
    const r = o.indexOf(t);
    if (r !== -1) {
      const a = o.substring(0, r + t.length), c = o.substring(r + t.length);
      o = `${a}
${s}
${c}`;
    }
    n[i] = o;
  }
  replaceCode(e, t, s, n = this) {
    const i = Cn(e);
    n[i] = n[i].replaceAll(t, s);
  }
  getVertexIndex() {
    return "gl_VertexID";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  isFlipY() {
    return !0;
  }
  buildCode() {
    const e = {};
    for (const t of Yn) {
      const s = this.getUniforms(t), n = this.getAttributes(t), i = this.getVaryings(t), o = this.getVars(t), r = this.getCodes(t);
      e[t] = `${this.getSignature()}
// <node_builder>

// uniforms
${s}

// attributes
${n}

// varyings
${i}

// vars
${o}

// codes
${r}

// </node_builder>

${this.shader[Cn(t)]}
`;
    }
    this.vertexShader = e.vertex, this.fragmentShader = e.fragment;
  }
  build() {
    return super.build(!1), this._addSnippets(), this._addUniforms(), this._updateUniforms(), this.shader.vertexShader = this.vertexShader, this.shader.fragmentShader = this.fragmentShader, this;
  }
  _parseInclude(e, ...t) {
    for (const s of t) {
      const n = Pt(s), i = Ca[s], o = Cn(e);
      this.shader[o] = this.shader[o].replaceAll(n, i);
    }
  }
  _sortSlotsToFlow() {
    for (const e of Yn) {
      const t = this.shader[Cn(e)], s = this.slots[e].sort((n, i) => t.indexOf(n.source) > t.indexOf(i.source) ? 1 : -1);
      for (const n of s)
        this.addFlow(e, n);
    }
  }
  _addSnippets() {
    for (const e of Yn) {
      for (const t of this.slots[e]) {
        const s = this.getFlowData(
          t
          /*, shaderStage*/
        ), n = t.inclusionType, i = t.source, o = s.code + `
	` + t.target.replace("%RESULT%", s.result);
        n === "append" ? this.addCode(e, i, o) : n === "replace" ? this.replaceCode(e, i, o) : console.warn(`Inclusion type "${n}" not compatible.`);
      }
      this.addCode(
        e,
        "main() {",
        `
	` + this.flowCode[e]
      );
    }
  }
  _addUniforms() {
    for (const e of Yn)
      for (const t of this.uniforms[e])
        this.shader.uniforms[t.name] = t;
  }
  _updateUniforms() {
    nt.object = this.object, nt.renderer = this.renderer, nt.material = this.material, nt.scene = this.scene;
    for (const e of this.updateNodes)
      nt.updateNode(e);
  }
}
const Xo = /* @__PURE__ */ new WeakMap();
en.prototype.onBuild = function(A, e, t) {
  const s = this;
  if (s.isNodeMaterial === !0) {
    let n;
    try {
      n = new sA(A, t, e, s).build(), Xo.set(s, n);
    } catch (i) {
      console.error("Material.prototype.onBuild: ", i);
    }
  }
};
en.prototype.onBeforeRender = function(A, e, t, s, n) {
  const i = Xo.get(this);
  if (i !== void 0) {
    nt.material = this, nt.camera = t, nt.object = n, nt.renderer = A, nt.scene = e, nt.geometry = s;
    const o = i.updateNodes;
    if (o.length > 0) {
      A.state.useProgram(null);
      for (const r of o)
        nt.updateNode(r);
    }
  }
};
var rs = function() {
  var A = 0, e = document.createElement("div");
  e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function(l) {
    l.preventDefault(), s(++A % e.children.length);
  }, !1);
  function t(l) {
    return e.appendChild(l.dom), l;
  }
  function s(l) {
    for (var h = 0; h < e.children.length; h++)
      e.children[h].style.display = h === l ? "block" : "none";
    A = l;
  }
  var n = (performance || Date).now(), i = n, o = 0, r = t(new rs.Panel("FPS", "#0ff", "#002")), a = t(new rs.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory)
    var c = t(new rs.Panel("MB", "#f08", "#201"));
  return s(0), {
    REVISION: 16,
    dom: e,
    addPanel: t,
    showPanel: s,
    begin: function() {
      n = (performance || Date).now();
    },
    end: function() {
      o++;
      var l = (performance || Date).now();
      if (a.update(l - n, 200), l >= i + 1e3 && (r.update(o * 1e3 / (l - i), 100), i = l, o = 0, c)) {
        var h = performance.memory;
        c.update(h.usedJSHeapSize / 1048576, h.jsHeapSizeLimit / 1048576);
      }
      return l;
    },
    update: function() {
      n = this.end();
    },
    // Backwards Compatibility
    domElement: e,
    setMode: s
  };
};
rs.Panel = function(A, e, t) {
  var s = 1 / 0, n = 0, i = Math.round, o = i(window.devicePixelRatio || 1), r = 80 * o, a = 48 * o, c = 3 * o, l = 2 * o, h = 3 * o, g = 15 * o, d = 74 * o, f = 30 * o, I = document.createElement("canvas");
  I.width = r, I.height = a, I.style.cssText = "width:80px;height:48px";
  var m = I.getContext("2d");
  return m.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif", m.textBaseline = "top", m.fillStyle = t, m.fillRect(0, 0, r, a), m.fillStyle = e, m.fillText(A, c, l), m.fillRect(h, g, d, f), m.fillStyle = t, m.globalAlpha = 0.9, m.fillRect(h, g, d, f), {
    dom: I,
    update: function(C, w) {
      s = Math.min(s, C), n = Math.max(n, C), m.fillStyle = t, m.globalAlpha = 1, m.fillRect(0, 0, r, g), m.fillStyle = e, m.fillText(i(C) + " " + A + " (" + i(s) + "-" + i(n) + ")", c, l), m.drawImage(I, h + o, g, d - o, f, h, g, d - o, f), m.fillRect(h + d - o, g, o, f), m.fillStyle = t, m.globalAlpha = 0.9, m.fillRect(h + d - o, g, o, i((1 - C / w) * f));
    }
  };
};
function fh(A, e = 1e-4) {
  e = Math.max(e, Number.EPSILON);
  const t = {}, s = A.getIndex(), n = A.getAttribute("position"), i = s ? s.count : n.count;
  let o = 0;
  const r = Object.keys(A.attributes), a = {}, c = {}, l = [], h = ["getX", "getY", "getZ", "getW"], g = ["setX", "setY", "setZ", "setW"];
  for (let w = 0, b = r.length; w < b; w++) {
    const B = r[w], Q = A.attributes[B];
    a[B] = new Q.constructor(
      new Q.array.constructor(Q.count * Q.itemSize),
      Q.itemSize,
      Q.normalized
    );
    const D = A.morphAttributes[B];
    D && (c[B] || (c[B] = []), D.forEach((R, x) => {
      const T = new R.array.constructor(R.count * R.itemSize);
      c[B][x] = new R.constructor(T, R.itemSize, R.normalized);
    }));
  }
  const d = e * 0.5, f = Math.log10(1 / e), I = Math.pow(10, f), m = d * I;
  for (let w = 0; w < i; w++) {
    const b = s ? s.getX(w) : w;
    let B = "";
    for (let Q = 0, D = r.length; Q < D; Q++) {
      const R = r[Q], x = A.getAttribute(R), T = x.itemSize;
      for (let U = 0; U < T; U++)
        B += `${~~(x[h[U]](b) * I + m)},`;
    }
    if (B in t)
      l.push(t[B]);
    else {
      for (let Q = 0, D = r.length; Q < D; Q++) {
        const R = r[Q], x = A.getAttribute(R), T = A.morphAttributes[R], U = x.itemSize, L = a[R], H = c[R];
        for (let Z = 0; Z < U; Z++) {
          const N = h[Z], K = g[Z];
          if (L[K](o, x[N](b)), T)
            for (let O = 0, $ = T.length; O < $; O++)
              H[O][K](o, T[O][N](b));
        }
      }
      t[B] = o, l.push(o), o++;
    }
  }
  const C = A.clone();
  for (const w in A.attributes) {
    const b = a[w];
    if (C.setAttribute(w, new b.constructor(
      b.array.slice(0, o * b.itemSize),
      b.itemSize,
      b.normalized
    )), w in c)
      for (let B = 0; B < c[w].length; B++) {
        const Q = c[w][B];
        C.morphAttributes[w][B] = new Q.constructor(
          Q.array.slice(0, o * Q.itemSize),
          Q.itemSize,
          Q.normalized
        );
      }
  }
  return C.setIndex(l), C;
}
function Ui(A, e) {
  if (e === Ba)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), A;
  if (e === qs || e === Do) {
    let t = A.getIndex();
    if (t === null) {
      const o = [], r = A.getAttribute("position");
      if (r !== void 0) {
        for (let a = 0; a < r.count; a++)
          o.push(a);
        A.setIndex(o), t = A.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), A;
    }
    const s = t.count - 2, n = [];
    if (e === qs)
      for (let o = 1; o <= s; o++)
        n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
    else
      for (let o = 0; o < s; o++)
        o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== s && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = A.clone();
    return i.setIndex(n), i.clearGroups(), i;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), A;
}
class Zo extends kt {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new AA(t);
    }), this.register(function(t) {
      return new cA(t);
    }), this.register(function(t) {
      return new mA(t);
    }), this.register(function(t) {
      return new EA(t);
    }), this.register(function(t) {
      return new bA(t);
    }), this.register(function(t) {
      return new hA(t);
    }), this.register(function(t) {
      return new uA(t);
    }), this.register(function(t) {
      return new gA(t);
    }), this.register(function(t) {
      return new dA(t);
    }), this.register(function(t) {
      return new aA(t);
    }), this.register(function(t) {
      return new pA(t);
    }), this.register(function(t) {
      return new lA(t);
    }), this.register(function(t) {
      return new IA(t);
    }), this.register(function(t) {
      return new fA(t);
    }), this.register(function(t) {
      return new oA(t);
    }), this.register(function(t) {
      return new CA(t);
    }), this.register(function(t) {
      return new BA(t);
    });
  }
  load(e, t, s, n) {
    const i = this;
    let o;
    if (this.resourcePath !== "")
      o = this.resourcePath;
    else if (this.path !== "") {
      const c = tn.extractUrlBase(e);
      o = tn.resolveURL(c, this.path);
    } else
      o = tn.extractUrlBase(e);
    this.manager.itemStart(e);
    const r = function(c) {
      n ? n(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
    }, a = new It(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(c) {
      try {
        i.parse(c, o, function(l) {
          t(l), i.manager.itemEnd(e);
        }, r);
      } catch (l) {
        r(l);
      }
    }, s, r);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, s, n) {
    let i, o;
    const r = {}, a = {}, c = new TextDecoder();
    if (typeof e == "string")
      try {
        i = JSON.parse(e);
      } catch (h) {
        o = e, n && n(h);
        return;
      }
    else if (e instanceof ArrayBuffer)
      if (c.decode(new Uint8Array(e, 0, 4)) === $o) {
        try {
          r[ae.KHR_BINARY_GLTF] = new wA(e);
        } catch (g) {
          n && n(g);
          return;
        }
        try {
          i = JSON.parse(r[ae.KHR_BINARY_GLTF].content);
        } catch (g) {
          o = r[ae.KHR_BINARY_GLTF].content, n && n(g);
          return;
        }
      } else
        try {
          i = JSON.parse(c.decode(e));
        } catch (g) {
          o = c.decode(e), n && n(g);
          return;
        }
    else
      i = e;
    if (i.asset === void 0 || i.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    this.json = i, this.jsonErrorData = o;
    const l = new LA(i, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const g = this.pluginCallbacks[h](l);
      g.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[g.name] = g, r[g.name] = !0;
    }
    if (i.extensionsUsed)
      for (let h = 0; h < i.extensionsUsed.length; ++h) {
        const g = i.extensionsUsed[h], d = i.extensionsRequired || [];
        switch (g) {
          case ae.KHR_MATERIALS_UNLIT:
            r[g] = new rA();
            break;
          case ae.KHR_DRACO_MESH_COMPRESSION:
            r[g] = new yA(i, this.dracoLoader);
            break;
          case ae.KHR_TEXTURE_TRANSFORM:
            r[g] = new QA();
            break;
          case ae.KHR_MESH_QUANTIZATION:
            r[g] = new xA();
            break;
          default:
            d.indexOf(g) >= 0 && a[g] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + g + '".');
        }
      }
    l.setExtensions(r), l.setPlugins(a), l.parse(s, n);
  }
  parseAsync(e, t) {
    const s = this;
    return new Promise(function(n, i) {
      s.parse(e, t, n, i);
    });
  }
}
function iA() {
  let A = {};
  return {
    get: function(e) {
      return A[e];
    },
    add: function(e, t) {
      A[e] = t;
    },
    remove: function(e) {
      delete A[e];
    },
    removeAll: function() {
      A = {};
    }
  };
}
const ae = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class oA {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let s = 0, n = t.length; s < n; s++) {
      const i = t[s];
      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, s = "light:" + e;
    let n = t.cache.get(s);
    if (n) return n;
    const i = t.json, a = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
    let c;
    const l = new Se(16777215);
    a.color !== void 0 && l.setRGB(a.color[0], a.color[1], a.color[2], Xe);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        c = new _o(l), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new zs(l), c.distance = h;
        break;
      case "spot":
        c = new Ro(l), c.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, c.angle = a.spot.outerConeAngle, c.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, Mt(c, a), a.intensity !== void 0 && (c.intensity = a.intensity), c.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(c), t.cache.add(s, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, s = this.parser, i = s.json.nodes[e], r = (i.extensions && i.extensions[this.name] || {}).light;
    return r === void 0 ? null : this._loadLight(r).then(function(a) {
      return s._getNodeRef(t.cache, r, a);
    });
  }
}
let rA = class {
  constructor() {
    this.name = ae.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Qt;
  }
  extendParams(e, t, s) {
    const n = [];
    e.color = new Se(1, 1, 1), e.opacity = 1;
    const i = t.pbrMetallicRoughness;
    if (i) {
      if (Array.isArray(i.baseColorFactor)) {
        const o = i.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], Xe), e.opacity = o[3];
      }
      i.baseColorTexture !== void 0 && n.push(s.assignTexture(e, "map", i.baseColorTexture, ge));
    }
    return Promise.all(n);
  }
}, aA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
}, AA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && i.push(s.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && i.push(s.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (i.push(s.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const r = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Le(r, r);
    }
    return Promise.all(i);
  }
}, cA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name];
    return t.dispersion = i.dispersion !== void 0 ? i.dispersion : 0, Promise.resolve();
  }
}, lA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && i.push(s.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && i.push(s.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(i);
  }
}, hA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [];
    t.sheenColor = new Se(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const r = o.sheenColorFactor;
      t.sheenColor.setRGB(r[0], r[1], r[2], Xe);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && i.push(s.assignTexture(t, "sheenColorMap", o.sheenColorTexture, ge)), o.sheenRoughnessTexture !== void 0 && i.push(s.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(i);
  }
}, uA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && i.push(s.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(i);
  }
}, gA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && i.push(s.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const r = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Se().setRGB(r[0], r[1], r[2], Xe), Promise.all(i);
  }
}, dA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name];
    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
  }
}, pA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && i.push(s.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const r = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Se().setRGB(r[0], r[1], r[2], Xe), o.specularColorTexture !== void 0 && i.push(s.assignTexture(t, "specularColorMap", o.specularColorTexture, ge)), Promise.all(i);
  }
}, fA = class {
  constructor(e) {
    this.parser = e, this.name = ae.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && i.push(s.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(i);
  }
}, IA = class {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : Tt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && i.push(s.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(i);
  }
};
class mA {
  constructor(e) {
    this.parser = e, this.name = ae.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, s = t.json, n = s.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const i = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, i.source, o);
  }
}
class EA {
  constructor(e) {
    this.parser = e, this.name = ae.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], r = n.images[o.source];
    let a = s.textureLoader;
    if (r.uri) {
      const c = s.options.manager.getHandler(r.uri);
      c !== null && (a = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return s.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return s.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class bA {
  constructor(e) {
    this.parser = e, this.name = ae.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], r = n.images[o.source];
    let a = s.textureLoader;
    if (r.uri) {
      const c = s.options.manager.getHandler(r.uri);
      c !== null && (a = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return s.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return s.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class CA {
  constructor(e) {
    this.name = ae.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, s = t.bufferViews[e];
    if (s.extensions && s.extensions[this.name]) {
      const n = s.extensions[this.name], i = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return i.then(function(r) {
        const a = n.byteOffset || 0, c = n.byteLength || 0, l = n.count, h = n.byteStride, g = new Uint8Array(r, a, c);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(l, h, g, n.mode, n.filter).then(function(d) {
          return d.buffer;
        }) : o.ready.then(function() {
          const d = new ArrayBuffer(l * h);
          return o.decodeGltfBuffer(new Uint8Array(d), l, h, g, n.mode, n.filter), d;
        });
      });
    } else
      return null;
  }
}
let BA = class {
  constructor(e) {
    this.name = ae.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, s = t.nodes[e];
    if (!s.extensions || !s.extensions[this.name] || s.mesh === void 0)
      return null;
    const n = t.meshes[s.mesh];
    for (const c of n.primitives)
      if (c.mode !== ht.TRIANGLES && c.mode !== ht.TRIANGLE_STRIP && c.mode !== ht.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const o = s.extensions[this.name].attributes, r = [], a = {};
    for (const c in o)
      r.push(this.parser.getDependency("accessor", o[c]).then((l) => (a[c] = l, a[c])));
    return r.length < 1 ? null : (r.push(this.parser.createNodeMesh(e)), Promise.all(r).then((c) => {
      const l = c.pop(), h = l.isGroup ? l.children : [l], g = c[0].count, d = [];
      for (const f of h) {
        const I = new ue(), m = new P(), C = new Te(), w = new P(1, 1, 1), b = new wa(f.geometry, f.material, g);
        for (let B = 0; B < g; B++)
          a.TRANSLATION && m.fromBufferAttribute(a.TRANSLATION, B), a.ROTATION && C.fromBufferAttribute(a.ROTATION, B), a.SCALE && w.fromBufferAttribute(a.SCALE, B), b.setMatrixAt(B, I.compose(m, C, w));
        for (const B in a)
          if (B === "_COLOR_0") {
            const Q = a[B];
            b.instanceColor = new ya(Q.array, Q.itemSize, Q.normalized);
          } else B !== "TRANSLATION" && B !== "ROTATION" && B !== "SCALE" && f.geometry.setAttribute(B, a[B]);
        xt.prototype.copy.call(b, f), this.parser.assignFinalMaterial(b), d.push(b);
      }
      return l.isGroup ? (l.clear(), l.add(...d), l) : d[0];
    }));
  }
};
const $o = "glTF", Bn = 12, Gi = { JSON: 1313821514, BIN: 5130562 };
class wA {
  constructor(e) {
    this.name = ae.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Bn), s = new TextDecoder();
    if (this.header = {
      magic: s.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== $o)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - Bn, i = new DataView(e, Bn);
    let o = 0;
    for (; o < n; ) {
      const r = i.getUint32(o, !0);
      o += 4;
      const a = i.getUint32(o, !0);
      if (o += 4, a === Gi.JSON) {
        const c = new Uint8Array(e, Bn + o, r);
        this.content = s.decode(c);
      } else if (a === Gi.BIN) {
        const c = Bn + o;
        this.body = e.slice(c, c + r);
      }
      o += r;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class yA {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = ae.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const s = this.json, n = this.dracoLoader, i = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, r = {}, a = {}, c = {};
    for (const l in o) {
      const h = si[l] || l.toLowerCase();
      r[h] = o[l];
    }
    for (const l in e.attributes) {
      const h = si[l] || l.toLowerCase();
      if (o[l] !== void 0) {
        const g = s.accessors[e.attributes[l]], d = In[g.componentType];
        c[h] = d.name, a[h] = g.normalized === !0;
      }
    }
    return t.getDependency("bufferView", i).then(function(l) {
      return new Promise(function(h, g) {
        n.decodeDracoFile(l, function(d) {
          for (const f in d.attributes) {
            const I = d.attributes[f], m = a[f];
            m !== void 0 && (I.normalized = m);
          }
          h(d);
        }, r, c, Xe, g);
      });
    });
  }
}
class QA {
  constructor() {
    this.name = ae.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class xA {
  constructor() {
    this.name = ae.KHR_MESH_QUANTIZATION;
  }
}
class er extends Ta {
  constructor(e, t, s, n) {
    super(e, t, s, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, s = this.sampleValues, n = this.valueSize, i = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = s[i + o];
    return t;
  }
  interpolate_(e, t, s, n) {
    const i = this.resultBuffer, o = this.sampleValues, r = this.valueSize, a = r * 2, c = r * 3, l = n - t, h = (s - t) / l, g = h * h, d = g * h, f = e * c, I = f - c, m = -2 * d + 3 * g, C = d - g, w = 1 - m, b = C - g + h;
    for (let B = 0; B !== r; B++) {
      const Q = o[I + B + r], D = o[I + B + a] * l, R = o[f + B + r], x = o[f + B] * l;
      i[B] = w * Q + b * D + m * R + C * x;
    }
    return i;
  }
}
const SA = new Te();
class TA extends er {
  interpolate_(e, t, s, n) {
    const i = super.interpolate_(e, t, s, n);
    return SA.fromArray(i).normalize().toArray(i), i;
  }
}
const ht = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, In = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Pi = {
  9728: cs,
  9729: rt,
  9984: pi,
  9985: Fo,
  9986: Mo,
  9987: jn
}, Oi = {
  33071: ls,
  33648: ko,
  10497: on
}, Es = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, si = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, Ot = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, vA = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: mi,
  STEP: Po
}, bs = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function DA(A) {
  return A.DefaultMaterial === void 0 && (A.DefaultMaterial = new fi({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Oo
  })), A.DefaultMaterial;
}
function Vt(A, e, t) {
  for (const s in t.extensions)
    A[s] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[s] = t.extensions[s]);
}
function Mt(A, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(A.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function RA(A, e, t) {
  let s = !1, n = !1, i = !1;
  for (let c = 0, l = e.length; c < l; c++) {
    const h = e[c];
    if (h.POSITION !== void 0 && (s = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (i = !0), s && n && i) break;
  }
  if (!s && !n && !i) return Promise.resolve(A);
  const o = [], r = [], a = [];
  for (let c = 0, l = e.length; c < l; c++) {
    const h = e[c];
    if (s) {
      const g = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : A.attributes.position;
      o.push(g);
    }
    if (n) {
      const g = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : A.attributes.normal;
      r.push(g);
    }
    if (i) {
      const g = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : A.attributes.color;
      a.push(g);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(r),
    Promise.all(a)
  ]).then(function(c) {
    const l = c[0], h = c[1], g = c[2];
    return s && (A.morphAttributes.position = l), n && (A.morphAttributes.normal = h), i && (A.morphAttributes.color = g), A.morphTargetsRelative = !0, A;
  });
}
function _A(A, e) {
  if (A.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, s = e.weights.length; t < s; t++)
      A.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (A.morphTargetInfluences.length === t.length) {
      A.morphTargetDictionary = {};
      for (let s = 0, n = t.length; s < n; s++)
        A.morphTargetDictionary[t[s]] = s;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function MA(A) {
  let e;
  const t = A.extensions && A.extensions[ae.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Cs(t.attributes) : e = A.indices + ":" + Cs(A.attributes) + ":" + A.mode, A.targets !== void 0)
    for (let s = 0, n = A.targets.length; s < n; s++)
      e += ":" + Cs(A.targets[s]);
  return e;
}
function Cs(A) {
  let e = "";
  const t = Object.keys(A).sort();
  for (let s = 0, n = t.length; s < n; s++)
    e += t[s] + ":" + A[t[s]] + ";";
  return e;
}
function ii(A) {
  switch (A) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function FA(A) {
  return A.search(/\.jpe?g($|\?)/i) > 0 || A.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : A.search(/\.webp($|\?)/i) > 0 || A.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const kA = new ue();
class LA {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new iA(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let s = !1, n = -1, i = !1, o = -1;
    if (typeof navigator < "u") {
      const r = navigator.userAgent;
      s = /^((?!chrome|android).)*safari/i.test(r) === !0;
      const a = r.match(/Version\/(\d+)/);
      n = s && a ? parseInt(a[1], 10) : -1, i = r.indexOf("Firefox") > -1, o = i ? r.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    typeof createImageBitmap > "u" || s && n < 17 || i && o < 98 ? this.textureLoader = new di(this.options.manager) : this.textureLoader = new Qa(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new It(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const s = this, n = this.json, i = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(this._invokeAll(function(o) {
      return o.beforeRoot && o.beforeRoot();
    })).then(function() {
      return Promise.all([
        s.getDependencies("scene"),
        s.getDependencies("animation"),
        s.getDependencies("camera")
      ]);
    }).then(function(o) {
      const r = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: s,
        userData: {}
      };
      return Vt(i, r, n), Mt(r, n), Promise.all(s._invokeAll(function(a) {
        return a.afterRoot && a.afterRoot(r);
      })).then(function() {
        for (const a of r.scenes)
          a.updateMatrixWorld();
        e(r);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], s = this.json.meshes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const o = t[n].joints;
      for (let r = 0, a = o.length; r < a; r++)
        e[o[r]].isBone = !0;
    }
    for (let n = 0, i = e.length; n < i; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (s[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, s) {
    if (e.refs[t] <= 1) return s;
    const n = s.clone(), i = (o, r) => {
      const a = this.associations.get(o);
      a != null && this.associations.set(r, a);
      for (const [c, l] of o.children.entries())
        i(l, r.children[c]);
    };
    return i(s, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let s = 0; s < t.length; s++) {
      const n = e(t[s]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const s = [];
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      i && s.push(i);
    }
    return s;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const s = e + ":" + t;
    let n = this.cache.get(s);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(i) {
            return i.loadNode && i.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(i) {
            return i.loadMesh && i.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(i) {
            return i.loadBufferView && i.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(i) {
            return i.loadMaterial && i.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(i) {
            return i.loadTexture && i.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(i) {
            return i.loadAnimation && i.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(i) {
            return i != this && i.getDependency && i.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(s, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const s = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(i, o) {
        return s.getDependency(e, o);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], s = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[ae.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(i, o) {
      s.load(tn.resolveURL(t.uri, n.path), i, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(s) {
      const n = t.byteLength || 0, i = t.byteOffset || 0;
      return s.slice(i, i + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, s = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = Es[n.type], r = In[n.componentType], a = n.normalized === !0, c = new r(n.count * o);
      return Promise.resolve(new st(c, o, a));
    }
    const i = [];
    return n.bufferView !== void 0 ? i.push(this.getDependency("bufferView", n.bufferView)) : i.push(null), n.sparse !== void 0 && (i.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(i).then(function(o) {
      const r = o[0], a = Es[n.type], c = In[n.componentType], l = c.BYTES_PER_ELEMENT, h = l * a, g = n.byteOffset || 0, d = n.bufferView !== void 0 ? s.bufferViews[n.bufferView].byteStride : void 0, f = n.normalized === !0;
      let I, m;
      if (d && d !== h) {
        const C = Math.floor(g / d), w = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + C + ":" + n.count;
        let b = t.cache.get(w);
        b || (I = new c(r, C * d, n.count * d / l), b = new xa(I, d / l), t.cache.add(w, b)), m = new $t(b, a, g % d / l, f);
      } else
        r === null ? I = new c(n.count * a) : I = new c(r, g, n.count * a), m = new st(I, a, f);
      if (n.sparse !== void 0) {
        const C = Es.SCALAR, w = In[n.sparse.indices.componentType], b = n.sparse.indices.byteOffset || 0, B = n.sparse.values.byteOffset || 0, Q = new w(o[1], b, n.sparse.count * C), D = new c(o[2], B, n.sparse.count * a);
        r !== null && (m = new st(m.array.slice(), m.itemSize, m.normalized)), m.normalized = !1;
        for (let R = 0, x = Q.length; R < x; R++) {
          const T = Q[R];
          if (m.setX(T, D[R * a]), a >= 2 && m.setY(T, D[R * a + 1]), a >= 3 && m.setZ(T, D[R * a + 2]), a >= 4 && m.setW(T, D[R * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        m.normalized = f;
      }
      return m;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, s = this.options, i = t.textures[e].source, o = t.images[i];
    let r = this.textureLoader;
    if (o.uri) {
      const a = s.manager.getHandler(o.uri);
      a !== null && (r = a);
    }
    return this.loadTextureImage(e, i, r);
  }
  loadTextureImage(e, t, s) {
    const n = this, i = this.json, o = i.textures[e], r = i.images[t], a = (r.uri || r.bufferView) + ":" + o.sampler;
    if (this.textureCache[a])
      return this.textureCache[a];
    const c = this.loadImageSource(t, s).then(function(l) {
      l.flipY = !1, l.name = o.name || r.name || "", l.name === "" && typeof r.uri == "string" && r.uri.startsWith("data:image/") === !1 && (l.name = r.uri);
      const g = (i.samplers || {})[o.sampler] || {};
      return l.magFilter = Pi[g.magFilter] || rt, l.minFilter = Pi[g.minFilter] || jn, l.wrapS = Oi[g.wrapS] || on, l.wrapT = Oi[g.wrapT] || on, l.anisotropy = 4, n.associations.set(l, { textures: e }), l;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a] = c, c;
  }
  loadImageSource(e, t) {
    const s = this, n = this.json, i = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], r = self.URL || self.webkitURL;
    let a = o.uri || "", c = !1;
    if (o.bufferView !== void 0)
      a = s.getDependency("bufferView", o.bufferView).then(function(h) {
        c = !0;
        const g = new Blob([h], { type: o.mimeType });
        return a = r.createObjectURL(g), a;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const l = Promise.resolve(a).then(function(h) {
      return new Promise(function(g, d) {
        let f = g;
        t.isImageBitmapLoader === !0 && (f = function(I) {
          const m = new Ks(I);
          m.needsUpdate = !0, g(m);
        }), t.load(tn.resolveURL(h, i.path), f, void 0, d);
      });
    }).then(function(h) {
      return c === !0 && r.revokeObjectURL(a), Mt(h, o), h.userData.mimeType = o.mimeType || FA(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a), h;
    });
    return this.sourceCache[e] = l, l;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, s, n) {
    const i = this;
    return this.getDependency("texture", s.index).then(function(o) {
      if (!o) return null;
      if (s.texCoord !== void 0 && s.texCoord > 0 && (o = o.clone(), o.channel = s.texCoord), i.extensions[ae.KHR_TEXTURE_TRANSFORM]) {
        const r = s.extensions !== void 0 ? s.extensions[ae.KHR_TEXTURE_TRANSFORM] : void 0;
        if (r) {
          const a = i.associations.get(o);
          o = i.extensions[ae.KHR_TEXTURE_TRANSFORM].extendTexture(o, r), i.associations.set(o, a);
        }
      }
      return n !== void 0 && (o.colorSpace = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let s = e.material;
    const n = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const r = "PointsMaterial:" + s.uuid;
      let a = this.cache.get(r);
      a || (a = new _n(), en.prototype.copy.call(a, s), a.color.copy(s.color), a.map = s.map, a.sizeAttenuation = !1, this.cache.add(r, a)), s = a;
    } else if (e.isLine) {
      const r = "LineBasicMaterial:" + s.uuid;
      let a = this.cache.get(r);
      a || (a = new Ft(), en.prototype.copy.call(a, s), a.color.copy(s.color), a.map = s.map, this.cache.add(r, a)), s = a;
    }
    if (n || i || o) {
      let r = "ClonedMaterial:" + s.uuid + ":";
      n && (r += "derivative-tangents:"), i && (r += "vertex-colors:"), o && (r += "flat-shading:");
      let a = this.cache.get(r);
      a || (a = s.clone(), i && (a.vertexColors = !0), o && (a.flatShading = !0), n && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(r, a), this.associations.set(a, this.associations.get(s))), s = a;
    }
    e.material = s;
  }
  getMaterialType() {
    return fi;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, s = this.json, n = this.extensions, i = s.materials[e];
    let o;
    const r = {}, a = i.extensions || {}, c = [];
    if (a[ae.KHR_MATERIALS_UNLIT]) {
      const h = n[ae.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), c.push(h.extendParams(r, i, t));
    } else {
      const h = i.pbrMetallicRoughness || {};
      if (r.color = new Se(1, 1, 1), r.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const g = h.baseColorFactor;
        r.color.setRGB(g[0], g[1], g[2], Xe), r.opacity = g[3];
      }
      h.baseColorTexture !== void 0 && c.push(t.assignTexture(r, "map", h.baseColorTexture, ge)), r.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, r.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(r, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(r, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(g) {
        return g.getMaterialType && g.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(g) {
        return g.extendMaterialParams && g.extendMaterialParams(e, r);
      })));
    }
    i.doubleSided === !0 && (r.side = Ii);
    const l = i.alphaMode || bs.OPAQUE;
    if (l === bs.BLEND ? (r.transparent = !0, r.depthWrite = !1) : (r.transparent = !1, l === bs.MASK && (r.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && o !== Qt && (c.push(t.assignTexture(r, "normalMap", i.normalTexture)), r.normalScale = new Le(1, 1), i.normalTexture.scale !== void 0)) {
      const h = i.normalTexture.scale;
      r.normalScale.set(h, h);
    }
    if (i.occlusionTexture !== void 0 && o !== Qt && (c.push(t.assignTexture(r, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (r.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && o !== Qt) {
      const h = i.emissiveFactor;
      r.emissive = new Se().setRGB(h[0], h[1], h[2], Xe);
    }
    return i.emissiveTexture !== void 0 && o !== Qt && c.push(t.assignTexture(r, "emissiveMap", i.emissiveTexture, ge)), Promise.all(c).then(function() {
      const h = new o(r);
      return i.name && (h.name = i.name), Mt(h, i), t.associations.set(h, { materials: e }), i.extensions && Vt(n, h, i), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Lt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, s = this.extensions, n = this.primitiveCache;
    function i(r) {
      return s[ae.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r, t).then(function(a) {
        return Hi(a, r, t);
      });
    }
    const o = [];
    for (let r = 0, a = e.length; r < a; r++) {
      const c = e[r], l = MA(c), h = n[l];
      if (h)
        o.push(h.promise);
      else {
        let g;
        c.extensions && c.extensions[ae.KHR_DRACO_MESH_COMPRESSION] ? g = i(c) : g = Hi(new ut(), c, t), n[l] = { primitive: c, promise: g }, o.push(g);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, s = this.json, n = this.extensions, i = s.meshes[e], o = i.primitives, r = [];
    for (let a = 0, c = o.length; a < c; a++) {
      const l = o[a].material === void 0 ? DA(this.cache) : this.getDependency("material", o[a].material);
      r.push(l);
    }
    return r.push(t.loadGeometries(o)), Promise.all(r).then(function(a) {
      const c = a.slice(0, a.length - 1), l = a[a.length - 1], h = [];
      for (let d = 0, f = l.length; d < f; d++) {
        const I = l[d], m = o[d];
        let C;
        const w = c[d];
        if (m.mode === ht.TRIANGLES || m.mode === ht.TRIANGLE_STRIP || m.mode === ht.TRIANGLE_FAN || m.mode === void 0)
          C = i.isSkinnedMesh === !0 ? new Lo(I, w) : new q(I, w), C.isSkinnedMesh === !0 && C.normalizeSkinWeights(), m.mode === ht.TRIANGLE_STRIP ? C.geometry = Ui(C.geometry, Do) : m.mode === ht.TRIANGLE_FAN && (C.geometry = Ui(C.geometry, qs));
        else if (m.mode === ht.LINES)
          C = new hs(I, w);
        else if (m.mode === ht.LINE_STRIP)
          C = new pt(I, w);
        else if (m.mode === ht.LINE_LOOP)
          C = new Sa(I, w);
        else if (m.mode === ht.POINTS)
          C = new is(I, w);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + m.mode);
        Object.keys(C.geometry.morphAttributes).length > 0 && _A(C, i), C.name = t.createUniqueName(i.name || "mesh_" + e), Mt(C, i), m.extensions && Vt(n, C, m), t.assignFinalMaterial(C), h.push(C);
      }
      for (let d = 0, f = h.length; d < f; d++)
        t.associations.set(h[d], {
          meshes: e,
          primitives: d
        });
      if (h.length === 1)
        return i.extensions && Vt(n, h[0], i), h[0];
      const g = new nn();
      i.extensions && Vt(n, g, i), t.associations.set(g, { meshes: e });
      for (let d = 0, f = h.length; d < f; d++)
        g.add(h[d]);
      return g;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const s = this.json.cameras[e], n = s[s.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return s.type === "perspective" ? t = new gs(Qe.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : s.type === "orthographic" && (t = new No(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), s.name && (t.name = this.createUniqueName(s.name)), Mt(t, s), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], s = [];
    for (let n = 0, i = t.joints.length; n < i; n++)
      s.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? s.push(this.getDependency("accessor", t.inverseBindMatrices)) : s.push(null), Promise.all(s).then(function(n) {
      const i = n.pop(), o = n, r = [], a = [];
      for (let c = 0, l = o.length; c < l; c++) {
        const h = o[c];
        if (h) {
          r.push(h);
          const g = new ue();
          i !== null && g.fromArray(i.array, c * 16), a.push(g);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new Uo(r, a);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, s = this, n = t.animations[e], i = n.name ? n.name : "animation_" + e, o = [], r = [], a = [], c = [], l = [];
    let h = 0, g = n.channels.length;
    for (h = 0, g = n.channels.length; h < g; h++) {
      const d = n.channels[h], f = n.samplers[d.sampler], I = d.target, m = I.node, C = n.parameters !== void 0 ? n.parameters[f.input] : f.input, w = n.parameters !== void 0 ? n.parameters[f.output] : f.output;
      I.node !== void 0 && (o.push(this.getDependency("node", m)), r.push(this.getDependency("accessor", C)), a.push(this.getDependency("accessor", w)), c.push(f), l.push(I));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(r),
      Promise.all(a),
      Promise.all(c),
      Promise.all(l)
    ]).then(function(d) {
      const f = d[0], I = d[1], m = d[2], C = d[3], w = d[4], b = [];
      for (h = 0, g = f.length; h < g; h++) {
        const B = f[h], Q = I[h], D = m[h], R = C[h], x = w[h];
        if (B === void 0) continue;
        B.updateMatrix && B.updateMatrix();
        const T = s._createAnimationTracks(B, Q, D, R, x);
        if (T)
          for (let U = 0; U < T.length; U++)
            b.push(T[U]);
      }
      return new Go(i, void 0, b);
    });
  }
  createNodeMesh(e) {
    const t = this.json, s = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : s.getDependency("mesh", n.mesh).then(function(i) {
      const o = s._getNodeRef(s.meshCache, n.mesh, i);
      return n.weights !== void 0 && o.traverse(function(r) {
        if (r.isMesh)
          for (let a = 0, c = n.weights.length; a < c; a++)
            r.morphTargetInfluences[a] = n.weights[a];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, s = this, n = t.nodes[e], i = s._loadNodeShallow(e), o = [], r = n.children || [];
    for (let c = 0, l = r.length; c < l; c++)
      o.push(s.getDependency("node", r[c]));
    const a = n.skin === void 0 ? Promise.resolve(null) : s.getDependency("skin", n.skin);
    return Promise.all([
      i,
      Promise.all(o),
      a
    ]).then(function(c) {
      const l = c[0], h = c[1], g = c[2];
      g !== null && l.traverse(function(d) {
        d.isSkinnedMesh && d.bind(g, kA);
      });
      for (let d = 0, f = h.length; d < f; d++)
        l.add(h[d]);
      return l;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, s = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const i = t.nodes[e], o = i.name ? n.createUniqueName(i.name) : "", r = [], a = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return a && r.push(a), i.camera !== void 0 && r.push(n.getDependency("camera", i.camera).then(function(c) {
      return n._getNodeRef(n.cameraCache, i.camera, c);
    })), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      r.push(c);
    }), this.nodeCache[e] = Promise.all(r).then(function(c) {
      let l;
      if (i.isBone === !0 ? l = new Ys() : c.length > 1 ? l = new nn() : c.length === 1 ? l = c[0] : l = new xt(), l !== c[0])
        for (let h = 0, g = c.length; h < g; h++)
          l.add(c[h]);
      if (i.name && (l.userData.name = i.name, l.name = o), Mt(l, i), i.extensions && Vt(s, l, i), i.matrix !== void 0) {
        const h = new ue();
        h.fromArray(i.matrix), l.applyMatrix4(h);
      } else
        i.translation !== void 0 && l.position.fromArray(i.translation), i.rotation !== void 0 && l.quaternion.fromArray(i.rotation), i.scale !== void 0 && l.scale.fromArray(i.scale);
      return n.associations.has(l) || n.associations.set(l, {}), n.associations.get(l).nodes = e, l;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, s = this.json.scenes[e], n = this, i = new nn();
    s.name && (i.name = n.createUniqueName(s.name)), Mt(i, s), s.extensions && Vt(t, i, s);
    const o = s.nodes || [], r = [];
    for (let a = 0, c = o.length; a < c; a++)
      r.push(n.getDependency("node", o[a]));
    return Promise.all(r).then(function(a) {
      for (let l = 0, h = a.length; l < h; l++)
        i.add(a[l]);
      const c = (l) => {
        const h = /* @__PURE__ */ new Map();
        for (const [g, d] of n.associations)
          (g instanceof en || g instanceof Ks) && h.set(g, d);
        return l.traverse((g) => {
          const d = n.associations.get(g);
          d != null && h.set(g, d);
        }), h;
      };
      return n.associations = c(i), i;
    });
  }
  _createAnimationTracks(e, t, s, n, i) {
    const o = [], r = e.name ? e.name : e.uuid, a = [];
    Ot[i.path] === Ot.weights ? e.traverse(function(g) {
      g.morphTargetInfluences && a.push(g.name ? g.name : g.uuid);
    }) : a.push(r);
    let c;
    switch (Ot[i.path]) {
      case Ot.weights:
        c = Vs;
        break;
      case Ot.rotation:
        c = Ws;
        break;
      case Ot.position:
      case Ot.scale:
        c = Js;
        break;
      default:
        switch (s.itemSize) {
          case 1:
            c = Vs;
            break;
          case 2:
          case 3:
          default:
            c = Js;
            break;
        }
        break;
    }
    const l = n.interpolation !== void 0 ? vA[n.interpolation] : mi, h = this._getArrayFromAccessor(s);
    for (let g = 0, d = a.length; g < d; g++) {
      const f = new c(
        a[g] + "." + Ot[i.path],
        t.array,
        h,
        l
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(f), o.push(f);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const s = ii(t.constructor), n = new Float32Array(t.length);
      for (let i = 0, o = t.length; i < o; i++)
        n[i] = t[i] * s;
      t = n;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(s) {
      const n = this instanceof Ws ? TA : er;
      return new n(this.times, this.values, this.getValueSize() / 3, s);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function NA(A, e, t) {
  const s = e.attributes, n = new ds();
  if (s.POSITION !== void 0) {
    const r = t.json.accessors[s.POSITION], a = r.min, c = r.max;
    if (a !== void 0 && c !== void 0) {
      if (n.set(
        new P(a[0], a[1], a[2]),
        new P(c[0], c[1], c[2])
      ), r.normalized) {
        const l = ii(In[r.componentType]);
        n.min.multiplyScalar(l), n.max.multiplyScalar(l);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const i = e.targets;
  if (i !== void 0) {
    const r = new P(), a = new P();
    for (let c = 0, l = i.length; c < l; c++) {
      const h = i[c];
      if (h.POSITION !== void 0) {
        const g = t.json.accessors[h.POSITION], d = g.min, f = g.max;
        if (d !== void 0 && f !== void 0) {
          if (a.setX(Math.max(Math.abs(d[0]), Math.abs(f[0]))), a.setY(Math.max(Math.abs(d[1]), Math.abs(f[1]))), a.setZ(Math.max(Math.abs(d[2]), Math.abs(f[2]))), g.normalized) {
            const I = ii(In[g.componentType]);
            a.multiplyScalar(I);
          }
          r.max(a);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(r);
  }
  A.boundingBox = n;
  const o = new Ei();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, A.boundingSphere = o;
}
function Hi(A, e, t) {
  const s = e.attributes, n = [];
  function i(o, r) {
    return t.getDependency("accessor", o).then(function(a) {
      A.setAttribute(r, a);
    });
  }
  for (const o in s) {
    const r = si[o] || o.toLowerCase();
    r in A.attributes || n.push(i(s[o], r));
  }
  if (e.indices !== void 0 && !A.index) {
    const o = t.getDependency("accessor", e.indices).then(function(r) {
      A.setIndex(r);
    });
    n.push(o);
  }
  return Ve.workingColorSpace !== Xe && "COLOR_0" in s && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ve.workingColorSpace}" not supported.`), Mt(A, e), NA(A, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? RA(A, e.targets, t) : A;
  });
}
var Dh = (function() {
  var A = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), s = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  var n = WebAssembly.validate(t) ? e : A, i, o = WebAssembly.instantiate(r(n), {}).then(function(C) {
    i = C.instance, i.exports.__wasm_call_ctors();
  });
  function r(C) {
    for (var w = new Uint8Array(C.length), b = 0; b < C.length; ++b) {
      var B = C.charCodeAt(b);
      w[b] = B > 96 ? B - 97 : B > 64 ? B - 39 : B + 4;
    }
    for (var Q = 0, b = 0; b < C.length; ++b)
      w[Q++] = w[b] < 60 ? s[w[b]] : (w[b] - 60) * 64 + w[++b];
    return w.buffer.slice(0, Q);
  }
  function a(C, w, b, B, Q, D) {
    var R = i.exports.sbrk, x = b + 3 & -4, T = R(x * B), U = R(Q.length), L = new Uint8Array(i.exports.memory.buffer);
    L.set(Q, U);
    var H = C(T, b, B, U, Q.length);
    if (H == 0 && D && D(T, x, B), w.set(L.subarray(T, T + b * B)), R(T - R(0)), H != 0)
      throw new Error("Malformed buffer data: " + H);
  }
  var c = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, l = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  }, h = [], g = 0;
  function d(C) {
    var w = {
      object: new Worker(C),
      pending: 0,
      requests: {}
    };
    return w.object.onmessage = function(b) {
      var B = b.data;
      w.pending -= B.count, w.requests[B.id][B.action](B.value), delete w.requests[B.id];
    }, w;
  }
  function f(C) {
    for (var w = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(r(n)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + a.toString() + m.toString(), b = new Blob([w], { type: "text/javascript" }), B = URL.createObjectURL(b), Q = 0; Q < C; ++Q)
      h[Q] = d(B);
    URL.revokeObjectURL(B);
  }
  function I(C, w, b, B, Q) {
    for (var D = h[0], R = 1; R < h.length; ++R)
      h[R].pending < D.pending && (D = h[R]);
    return new Promise(function(x, T) {
      var U = new Uint8Array(b), L = g++;
      D.pending += C, D.requests[L] = { resolve: x, reject: T }, D.object.postMessage({ id: L, count: C, size: w, source: U, mode: B, filter: Q }, [U.buffer]);
    });
  }
  function m(C) {
    o.then(function() {
      var w = C.data;
      try {
        var b = new Uint8Array(w.count * w.size);
        a(i.exports[w.mode], b, w.count, w.size, w.source, i.exports[w.filter]), self.postMessage({ id: w.id, count: w.count, action: "resolve", value: b }, [b.buffer]);
      } catch (B) {
        self.postMessage({ id: w.id, count: w.count, action: "reject", value: B });
      }
    });
  }
  return {
    ready: o,
    supported: !0,
    useWorkers: function(C) {
      f(C);
    },
    decodeVertexBuffer: function(C, w, b, B, Q) {
      a(i.exports.meshopt_decodeVertexBuffer, C, w, b, B, i.exports[c[Q]]);
    },
    decodeIndexBuffer: function(C, w, b, B) {
      a(i.exports.meshopt_decodeIndexBuffer, C, w, b, B);
    },
    decodeIndexSequence: function(C, w, b, B) {
      a(i.exports.meshopt_decodeIndexSequence, C, w, b, B);
    },
    decodeGltfBuffer: function(C, w, b, B, Q, D) {
      a(i.exports[l[Q]], C, w, b, B, i.exports[c[D]]);
    },
    decodeGltfBufferAsync: function(C, w, b, B, Q) {
      return h.length > 0 ? I(C, w, b, l[B], c[Q]) : o.then(function() {
        var D = new Uint8Array(C * w);
        return a(i.exports[l[B]], D, C, w, b, i.exports[c[Q]]), D;
      });
    }
  };
})();
const Bs = /* @__PURE__ */ new WeakMap();
class Rh extends kt {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, s, n) {
    const i = new It(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, (o) => {
      this.parse(o, t, n);
    }, s, n);
  }
  parse(e, t, s = () => {
  }) {
    this.decodeDracoFile(e, t, null, null, ge, s).catch(s);
  }
  decodeDracoFile(e, t, s, n, i = Xe, o = () => {
  }) {
    const r = {
      attributeIDs: s || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!s,
      vertexColorSpace: i
    };
    return this.decodeGeometry(e, r).then(t).catch(o);
  }
  decodeGeometry(e, t) {
    const s = JSON.stringify(t);
    if (Bs.has(e)) {
      const a = Bs.get(e);
      if (a.key === s)
        return a.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const i = this.workerNextTaskID++, o = e.byteLength, r = this._getWorker(i, o).then((a) => (n = a, new Promise((c, l) => {
      n._callbacks[i] = { resolve: c, reject: l }, n.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]);
    }))).then((a) => this._createGeometry(a.geometry));
    return r.catch(() => !0).then(() => {
      n && i && this._releaseTask(n, i);
    }), Bs.set(e, {
      key: s,
      promise: r
    }), r;
  }
  _createGeometry(e) {
    const t = new ut();
    e.index && t.setIndex(new st(e.index.array, 1));
    for (let s = 0; s < e.attributes.length; s++) {
      const n = e.attributes[s], i = n.name, o = n.array, r = n.itemSize, a = new st(o, r);
      i === "color" && (this._assignVertexColorSpace(a, n.vertexColorSpace), a.normalized = !(o instanceof Float32Array)), t.setAttribute(i, a);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== ge) return;
    const s = new Se();
    for (let n = 0, i = e.count; n < i; n++)
      s.fromBufferAttribute(e, n), Ve.toWorkingColorSpace(s, ge), e.setXYZ(n, s.r, s.g, s.b);
  }
  _loadLibrary(e, t) {
    const s = new It(this.manager);
    return s.setPath(this.decoderPath), s.setResponseType(t), s.setWithCredentials(this.withCredentials), new Promise((n, i) => {
      s.load(e, n, void 0, i);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((s) => {
      const n = s[0];
      e || (this.decoderConfig.wasmBinary = s[1]);
      const i = UA.toString(), o = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(i) {
          const o = i.data;
          switch (o.type) {
            case "decode":
              n._callbacks[o.id].resolve(o);
              break;
            case "error":
              n._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, i) {
          return n._taskLoad > i._taskLoad ? -1 : 1;
        });
      const s = this.workerPool[this.workerPool.length - 1];
      return s._taskCosts[e] = t, s._taskLoad += t, s;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function UA() {
  let A, e;
  onmessage = function(o) {
    const r = o.data;
    switch (r.type) {
      case "init":
        A = r.decoderConfig, e = new Promise(function(l) {
          A.onModuleLoaded = function(h) {
            l({ draco: h });
          }, DracoDecoderModule(A);
        });
        break;
      case "decode":
        const a = r.buffer, c = r.taskConfig;
        e.then((l) => {
          const h = l.draco, g = new h.Decoder();
          try {
            const d = t(h, g, new Int8Array(a), c), f = d.attributes.map((I) => I.array.buffer);
            d.index && f.push(d.index.array.buffer), self.postMessage({ type: "decode", id: r.id, geometry: d }, f);
          } catch (d) {
            console.error(d), self.postMessage({ type: "error", id: r.id, error: d.message });
          } finally {
            h.destroy(g);
          }
        });
        break;
    }
  };
  function t(o, r, a, c) {
    const l = c.attributeIDs, h = c.attributeTypes;
    let g, d;
    const f = r.GetEncodedGeometryType(a);
    if (f === o.TRIANGULAR_MESH)
      g = new o.Mesh(), d = r.DecodeArrayToMesh(a, a.byteLength, g);
    else if (f === o.POINT_CLOUD)
      g = new o.PointCloud(), d = r.DecodeArrayToPointCloud(a, a.byteLength, g);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!d.ok() || g.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + d.error_msg());
    const I = { index: null, attributes: [] };
    for (const m in l) {
      const C = self[h[m]];
      let w, b;
      if (c.useUniqueIDs)
        b = l[m], w = r.GetAttributeByUniqueId(g, b);
      else {
        if (b = r.GetAttributeId(g, o[l[m]]), b === -1) continue;
        w = r.GetAttribute(g, b);
      }
      const B = n(o, r, g, m, C, w);
      m === "color" && (B.vertexColorSpace = c.vertexColorSpace), I.attributes.push(B);
    }
    return f === o.TRIANGULAR_MESH && (I.index = s(o, r, g)), o.destroy(g), I;
  }
  function s(o, r, a) {
    const l = a.num_faces() * 3, h = l * 4, g = o._malloc(h);
    r.GetTrianglesUInt32Array(a, h, g);
    const d = new Uint32Array(o.HEAPF32.buffer, g, l).slice();
    return o._free(g), { array: d, itemSize: 1 };
  }
  function n(o, r, a, c, l, h) {
    const g = h.num_components(), f = a.num_points() * g, I = f * l.BYTES_PER_ELEMENT, m = i(o, l), C = o._malloc(I);
    r.GetAttributeDataArrayForAllPoints(a, h, m, I, C);
    const w = new l(o.HEAPF32.buffer, C, f).slice();
    return o._free(C), {
      name: c,
      array: w,
      itemSize: g
    };
  }
  function i(o, r) {
    switch (r) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
class GA {
  constructor(e = 4) {
    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++)
      if (!(this.workerStatus & 1 << e)) return e;
    return -1;
  }
  _onMessage(e, t) {
    const s = this.workersResolve[e];
    if (s && s(t), this.queue.length) {
      const { resolve: n, msg: i, transfer: o } = this.queue.shift();
      this.workersResolve[e] = n, this.workers[e].postMessage(i, o);
    } else
      this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((s) => {
      const n = this._getIdleWorker();
      n !== -1 ? (this._initWorker(n), this.workerStatus |= 1 << n, this.workersResolve[n] = s, this.workers[n].postMessage(e, t)) : this.queue.push({ resolve: s, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
const PA = 0, ji = 2, OA = 1, qi = 2, HA = 0, jA = 1, qA = 10, zA = 0, tr = 9, nr = 15, sr = 16, ir = 22, or = 37, rr = 43, ar = 76, Ar = 83, cr = 97, lr = 100, hr = 103, ur = 109, gr = 122, dr = 123, YA = 131, KA = 132, JA = 133, VA = 134, WA = 137, XA = 138, ZA = 141, $A = 142, ec = 145, tc = 146, pr = 148, fr = 152, nc = 157, sc = 158, Ir = 165, mr = 166, Bi = 1000066e3;
class wn {
  constructor(e, t, s, n) {
    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, s), this._littleEndian = n, this._offset = 0;
  }
  _nextUint8() {
    const e = this._dataView.getUint8(this._offset);
    return this._offset += 1, e;
  }
  _nextUint16() {
    const e = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, e;
  }
  _nextUint32() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint64() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, e;
  }
  _nextInt32() {
    const e = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint8Array(e) {
    const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
    return this._offset += e, t;
  }
  _skip(e) {
    return this._offset += e, this;
  }
  _scan(e, t = 0) {
    const s = this._offset;
    let n = 0;
    for (; this._dataView.getUint8(this._offset) !== t && n < e; ) n++, this._offset++;
    return n < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + s, n);
  }
}
const qe = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function zi(A) {
  return new TextDecoder().decode(A);
}
function ic(A) {
  const e = new Uint8Array(A.buffer, A.byteOffset, qe.length);
  if (e[0] !== qe[0] || e[1] !== qe[1] || e[2] !== qe[2] || e[3] !== qe[3] || e[4] !== qe[4] || e[5] !== qe[5] || e[6] !== qe[6] || e[7] !== qe[7] || e[8] !== qe[8] || e[9] !== qe[9] || e[10] !== qe[10] || e[11] !== qe[11]) throw new Error("Missing KTX 2.0 identifier.");
  const t = { vkFormat: 0, typeSize: 1, pixelWidth: 0, pixelHeight: 0, pixelDepth: 0, layerCount: 0, faceCount: 1, levelCount: 0, supercompressionScheme: 0, levels: [], dataFormatDescriptor: [{ vendorId: 0, descriptorType: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], keyValue: {}, globalData: null }, s = 17 * Uint32Array.BYTES_PER_ELEMENT, n = new wn(A, qe.length, s, !0);
  t.vkFormat = n._nextUint32(), t.typeSize = n._nextUint32(), t.pixelWidth = n._nextUint32(), t.pixelHeight = n._nextUint32(), t.pixelDepth = n._nextUint32(), t.layerCount = n._nextUint32(), t.faceCount = n._nextUint32(), t.levelCount = n._nextUint32(), t.supercompressionScheme = n._nextUint32();
  const i = n._nextUint32(), o = n._nextUint32(), r = n._nextUint32(), a = n._nextUint32(), c = n._nextUint64(), l = n._nextUint64(), h = 3 * Math.max(t.levelCount, 1) * 8, g = new wn(A, qe.length + s, h, !0);
  for (let ne = 0, X = Math.max(t.levelCount, 1); ne < X; ne++) t.levels.push({ levelData: new Uint8Array(A.buffer, A.byteOffset + g._nextUint64(), g._nextUint64()), uncompressedByteLength: g._nextUint64() });
  const d = new wn(A, i, o, !0);
  d._skip(4);
  const f = d._nextUint16(), I = d._nextUint16(), m = d._nextUint16(), C = d._nextUint16(), w = { vendorId: f, descriptorType: I, versionNumber: m, colorModel: d._nextUint8(), colorPrimaries: d._nextUint8(), transferFunction: d._nextUint8(), flags: d._nextUint8(), texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], samples: [] }, b = (C / 4 - 6) / 4;
  for (let ne = 0; ne < b; ne++) {
    const X = { bitOffset: d._nextUint16(), bitLength: d._nextUint8(), channelType: d._nextUint8(), samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], sampleLower: Number.NEGATIVE_INFINITY, sampleUpper: Number.POSITIVE_INFINITY };
    64 & X.channelType ? (X.sampleLower = d._nextInt32(), X.sampleUpper = d._nextInt32()) : (X.sampleLower = d._nextUint32(), X.sampleUpper = d._nextUint32()), w.samples[ne] = X;
  }
  t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(w);
  const B = new wn(A, r, a, !0);
  for (; B._offset < a; ) {
    const ne = B._nextUint32(), X = B._scan(ne), ie = zi(X);
    if (t.keyValue[ie] = B._nextUint8Array(ne - X.byteLength - 1), ie.match(/^ktx/i)) {
      const fe = zi(t.keyValue[ie]);
      t.keyValue[ie] = fe.substring(0, fe.lastIndexOf("\0"));
    }
    B._skip(ne % 4 ? 4 - ne % 4 : 0);
  }
  if (l <= 0) return t;
  const Q = new wn(A, c, l, !0), D = Q._nextUint16(), R = Q._nextUint16(), x = Q._nextUint32(), T = Q._nextUint32(), U = Q._nextUint32(), L = Q._nextUint32(), H = [];
  for (let ne = 0, X = Math.max(t.levelCount, 1); ne < X; ne++) H.push({ imageFlags: Q._nextUint32(), rgbSliceByteOffset: Q._nextUint32(), rgbSliceByteLength: Q._nextUint32(), alphaSliceByteOffset: Q._nextUint32(), alphaSliceByteLength: Q._nextUint32() });
  const Z = c + Q._offset, N = Z + x, K = N + T, O = K + U, $ = new Uint8Array(A.buffer, A.byteOffset + Z, x), oe = new Uint8Array(A.buffer, A.byteOffset + N, T), te = new Uint8Array(A.buffer, A.byteOffset + K, U), le = new Uint8Array(A.buffer, A.byteOffset + O, L);
  return t.globalData = { endpointCount: D, selectorCount: R, imageDescs: H, endpointsData: $, selectorsData: oe, tablesData: te, extendedData: le }, t;
}
let ws, _t, oi;
const ys = { env: { emscripten_notify_memory_growth: function(A) {
  oi = new Uint8Array(_t.exports.memory.buffer);
} } };
class oc {
  init() {
    return ws || (ws = typeof fetch < "u" ? fetch("data:application/wasm;base64," + Yi).then((e) => e.arrayBuffer()).then((e) => WebAssembly.instantiate(e, ys)).then(this._init) : WebAssembly.instantiate(Buffer.from(Yi, "base64"), ys).then(this._init), ws);
  }
  _init(e) {
    _t = e.instance, ys.env.emscripten_notify_memory_growth(0);
  }
  decode(e, t = 0) {
    if (!_t) throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const s = e.byteLength, n = _t.exports.malloc(s);
    oi.set(e, n), t = t || Number(_t.exports.ZSTD_findDecompressedSize(n, s));
    const i = _t.exports.malloc(t), o = _t.exports.ZSTD_decompress(i, t, n, s), r = oi.slice(i, i + o);
    return _t.exports.free(n), _t.exports.free(i), r;
  }
}
const Yi = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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", rc = "display-p3", ac = "display-p3-linear", Qs = /* @__PURE__ */ new WeakMap();
let xs = 0, Ss;
class ft extends kt {
  /**
   * Constructs a new KTX2 loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new GA(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn(
      'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
    );
  }
  /**
   * Sets the transcoder path.
   *
   * The WASM transcoder and JS wrapper are available from the `examples/jsm/libs/basis` directory.
   *
   * @param {string} path - The transcoder path to set.
   * @return {KTX2Loader} A reference to this loader.
   */
  setTranscoderPath(e) {
    return this.transcoderPath = e, this;
  }
  /**
   * Sets the maximum number of Web Workers to be allocated by this instance.
   *
   * @param {number} workerLimit - The worker limit.
   * @return {KTX2Loader} A reference to this loader.
   */
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  /**
   * Async version of {@link KTX2Loader#detectSupport}.
   *
   * @async
   * @param {WebGPURenderer|WebGLRenderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the support has been detected.
   */
  async detectSupportAsync(e) {
    return this.workerConfig = {
      astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
      astcHDRSupported: !1,
      // https://github.com/gpuweb/gpuweb/issues/3856
      etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
    }, this;
  }
  /**
   * Detects hardware support for available compressed texture formats, to determine
   * the output format for the transcoder. Must be called before loading a texture.
   *
   * @param {WebGPURenderer|WebGLRenderer} renderer - The renderer.
   * @return {KTX2Loader} A reference to this loader.
   */
  detectSupport(e) {
    return e.isWebGPURenderer === !0 ? this.workerConfig = {
      astcSupported: e.hasFeature("texture-compression-astc"),
      astcHDRSupported: !1,
      // https://github.com/gpuweb/gpuweb/issues/3856
      etc1Supported: e.hasFeature("texture-compression-etc1"),
      etc2Supported: e.hasFeature("texture-compression-etc2"),
      dxtSupported: e.hasFeature("texture-compression-bc"),
      bptcSupported: e.hasFeature("texture-compression-bptc"),
      pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
    } : this.workerConfig = {
      astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
      astcHDRSupported: e.extensions.has("WEBGL_compressed_texture_astc") && e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
      etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    }, this;
  }
  // TODO: Make this method private
  init() {
    if (!this.transcoderPending) {
      const e = new It(this.manager);
      e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"), s = new It(this.manager);
      s.setPath(this.transcoderPath), s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials);
      const n = s.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([t, n]).then(([i, o]) => {
        const r = ft.BasisWorker.toString(), a = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(ft.EngineFormat),
          "let _EngineType = " + JSON.stringify(ft.EngineType),
          "let _TranscoderFormat = " + JSON.stringify(ft.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(ft.BasisFormat),
          "/* basis_transcoder.js */",
          i,
          "/* worker */",
          r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([a])), this.transcoderBinary = o, this.workerPool.setWorkerCreator(() => {
          const c = new Worker(this.workerSourceURL), l = this.transcoderBinary.slice(0);
          return c.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: l }, [l]), c;
        });
      }), xs > 0 && console.warn(
        "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
      ), xs++;
    }
    return this.transcoderPending;
  }
  /**
   * Starts loading from the given URL and passes the loaded KTX2 texture
   * to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(CompressedTexture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, s, n) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const i = new It(this.manager);
    i.setPath(this.path), i.setCrossOrigin(this.crossOrigin), i.setWithCredentials(this.withCredentials), i.setResponseType("arraybuffer"), i.load(e, (o) => {
      this.parse(o, t, n);
    }, s, n);
  }
  /**
   * Parses the given KTX2 data.
   *
   * @param {ArrayBuffer} buffer - The raw KTX2 data as an array buffer.
   * @param {function(CompressedTexture)} onLoad - Executed when the loading/parsing process has been finished.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @returns {Promise} A Promise that resolves when the parsing has been finished.
   */
  parse(e, t, s) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    if (Qs.has(e))
      return Qs.get(e).promise.then(t).catch(s);
    this._createTexture(e).then((n) => t ? t(n) : null).catch(s);
  }
  _createTextureFrom(e, t) {
    const { type: s, error: n, data: { faces: i, width: o, height: r, format: a, type: c, dfdFlags: l } } = e;
    if (s === "error") return Promise.reject(n);
    let h;
    if (t.faceCount === 6)
      h = new Ma(i, a, c);
    else {
      const g = i[0].mipmaps;
      h = t.layerCount > 1 ? new Fa(g, o, r, t.layerCount, a, c) : new Gn(g, o, r, a, c);
    }
    return h.minFilter = i[0].mipmaps.length === 1 ? rt : jn, h.magFilter = rt, h.generateMipmaps = !1, h.needsUpdate = !0, h.colorSpace = Er(t), h.premultiplyAlpha = !!(l & OA), h;
  }
  /**
   * @private
   * @param {ArrayBuffer} buffer
   * @param {?Object} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(e, t = {}) {
    const s = ic(new Uint8Array(e)), n = s.vkFormat === Bi && s.dataFormatDescriptor[0].colorModel === 167;
    if (!(s.vkFormat === zA || n && !this.workerConfig.astcHDRSupported))
      return cc(s);
    const o = t, r = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: o }, [e])).then((a) => this._createTextureFrom(a.data, s));
    return Qs.set(e, { promise: r }), r;
  }
  /**
   * Frees internal resources. This method should be called
   * when the loader is no longer required.
   */
  dispose() {
    this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), xs--;
  }
}
ft.BasisFormat = {
  ETC1S: 0,
  UASTC: 1,
  UASTC_HDR: 2
};
ft.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16,
  BC6H: 22,
  RGB_HALF: 24,
  RGBA_HALF: 25
};
ft.EngineFormat = {
  RGBAFormat: zt,
  RGBA_ASTC_4x4_Format: os,
  RGB_BPTC_UNSIGNED_Format: _a,
  RGBA_BPTC_Format: $s,
  RGBA_ETC2_EAC_Format: jo,
  RGBA_PVRTC_4BPPV1_Format: Ra,
  RGBA_S3TC_DXT5_Format: Zs,
  RGB_ETC1_Format: Da,
  RGB_ETC2_Format: Ho,
  RGB_PVRTC_4BPPV1_Format: va,
  RGBA_S3TC_DXT1_Format: Xs
};
ft.EngineType = {
  UnsignedByteType: dt,
  HalfFloatType: We,
  FloatType: mt
};
ft.BasisWorker = function() {
  let A, e, t;
  const s = _EngineFormat, n = _EngineType, i = _TranscoderFormat, o = _BasisFormat;
  self.addEventListener("message", function(f) {
    const I = f.data;
    switch (I.type) {
      case "init":
        A = I.config, r(I.transcoderBinary);
        break;
      case "transcode":
        e.then(() => {
          try {
            const { faces: m, buffers: C, width: w, height: b, hasAlpha: B, format: Q, type: D, dfdFlags: R } = a(I.buffer);
            self.postMessage({ type: "transcode", id: I.id, data: { faces: m, width: w, height: b, hasAlpha: B, format: Q, type: D, dfdFlags: R } }, C);
          } catch (m) {
            console.error(m), self.postMessage({ type: "error", id: I.id, error: m.message });
          }
        });
        break;
    }
  });
  function r(f) {
    e = new Promise((I) => {
      t = { wasmBinary: f, onRuntimeInitialized: I }, BASIS(t);
    }).then(() => {
      t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
    });
  }
  function a(f) {
    const I = new t.KTX2File(new Uint8Array(f));
    function m() {
      I.close(), I.delete();
    }
    if (!I.isValid())
      throw m(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    let C;
    if (I.isUASTC())
      C = o.UASTC;
    else if (I.isETC1S())
      C = o.ETC1S;
    else if (I.isHDR())
      C = o.UASTC_HDR;
    else
      throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
    const w = I.getWidth(), b = I.getHeight(), B = I.getLayers() || 1, Q = I.getLevels(), D = I.getFaces(), R = I.getHasAlpha(), x = I.getDFDFlags(), { transcoderFormat: T, engineFormat: U, engineType: L } = h(C, w, b, R);
    if (!w || !b || !Q)
      throw m(), new Error("THREE.KTX2Loader:	Invalid texture");
    if (!I.startTranscoding())
      throw m(), new Error("THREE.KTX2Loader: .startTranscoding failed");
    const H = [], Z = [];
    for (let N = 0; N < D; N++) {
      const K = [];
      for (let O = 0; O < Q; O++) {
        const $ = [];
        let oe, te;
        for (let ne = 0; ne < B; ne++) {
          const X = I.getImageLevelInfo(O, ne, N);
          N === 0 && O === 0 && ne === 0 && (X.origWidth % 4 !== 0 || X.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), Q > 1 ? (oe = X.origWidth, te = X.origHeight) : (oe = X.width, te = X.height);
          let ie = new Uint8Array(I.getImageTranscodedSizeInBytes(O, ne, 0, T));
          const fe = I.transcodeImage(ie, O, ne, N, T, 0, -1, -1);
          if (L === n.HalfFloatType && (ie = new Uint16Array(ie.buffer, ie.byteOffset, ie.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !fe)
            throw m(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
          $.push(ie);
        }
        const le = d($);
        K.push({ data: le, width: oe, height: te }), Z.push(le.buffer);
      }
      H.push({ mipmaps: K, width: w, height: b, format: U, type: L });
    }
    return m(), { faces: H, buffers: Z, width: w, height: b, hasAlpha: R, dfdFlags: x, format: U, type: L };
  }
  const c = [
    {
      if: "astcSupported",
      basisFormat: [o.UASTC],
      transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
      engineFormat: [s.RGBA_ASTC_4x4_Format, s.RGBA_ASTC_4x4_Format],
      engineType: [n.UnsignedByteType],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    },
    {
      if: "bptcSupported",
      basisFormat: [o.ETC1S, o.UASTC],
      transcoderFormat: [i.BC7_M5, i.BC7_M5],
      engineFormat: [s.RGBA_BPTC_Format, s.RGBA_BPTC_Format],
      engineType: [n.UnsignedByteType],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    },
    {
      if: "dxtSupported",
      basisFormat: [o.ETC1S, o.UASTC],
      transcoderFormat: [i.BC1, i.BC3],
      engineFormat: [s.RGBA_S3TC_DXT1_Format, s.RGBA_S3TC_DXT5_Format],
      engineType: [n.UnsignedByteType],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    },
    {
      if: "etc2Supported",
      basisFormat: [o.ETC1S, o.UASTC],
      transcoderFormat: [i.ETC1, i.ETC2],
      engineFormat: [s.RGB_ETC2_Format, s.RGBA_ETC2_EAC_Format],
      engineType: [n.UnsignedByteType],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    },
    {
      if: "etc1Supported",
      basisFormat: [o.ETC1S, o.UASTC],
      transcoderFormat: [i.ETC1],
      engineFormat: [s.RGB_ETC1_Format],
      engineType: [n.UnsignedByteType],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    },
    {
      if: "pvrtcSupported",
      basisFormat: [o.ETC1S, o.UASTC],
      transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
      engineFormat: [s.RGB_PVRTC_4BPPV1_Format, s.RGBA_PVRTC_4BPPV1_Format],
      engineType: [n.UnsignedByteType],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    },
    {
      if: "bptcSupported",
      basisFormat: [o.UASTC_HDR],
      transcoderFormat: [i.BC6H],
      engineFormat: [s.RGB_BPTC_UNSIGNED_Format],
      engineType: [n.HalfFloatType],
      priorityHDR: 1,
      needsPowerOfTwo: !1
    },
    // Uncompressed fallbacks.
    {
      basisFormat: [o.ETC1S, o.UASTC],
      transcoderFormat: [i.RGBA32, i.RGBA32],
      engineFormat: [s.RGBAFormat, s.RGBAFormat],
      engineType: [n.UnsignedByteType, n.UnsignedByteType],
      priorityETC1S: 100,
      priorityUASTC: 100,
      needsPowerOfTwo: !1
    },
    {
      basisFormat: [o.UASTC_HDR],
      transcoderFormat: [i.RGBA_HALF],
      engineFormat: [s.RGBAFormat],
      engineType: [n.HalfFloatType],
      priorityHDR: 100,
      needsPowerOfTwo: !1
    }
  ], l = {
    // TODO: For ETC1S we intentionally sort by _UASTC_ priority, preserving
    // a historical accident shown to avoid performance pitfalls for Linux with
    // Firefox & AMD GPU (RadeonSI). Further work needed.
    // See https://github.com/mrdoob/three.js/pull/29730.
    [o.ETC1S]: c.filter((f) => f.basisFormat.includes(o.ETC1S)).sort((f, I) => f.priorityUASTC - I.priorityUASTC),
    [o.UASTC]: c.filter((f) => f.basisFormat.includes(o.UASTC)).sort((f, I) => f.priorityUASTC - I.priorityUASTC),
    [o.UASTC_HDR]: c.filter((f) => f.basisFormat.includes(o.UASTC_HDR)).sort((f, I) => f.priorityHDR - I.priorityHDR)
  };
  function h(f, I, m, C) {
    const w = l[f];
    for (let b = 0; b < w.length; b++) {
      const B = w[b];
      if (B.if && !A[B.if] || !B.basisFormat.includes(f) || C && B.transcoderFormat.length < 2 || B.needsPowerOfTwo && !(g(I) && g(m))) continue;
      const Q = B.transcoderFormat[C ? 1 : 0], D = B.engineFormat[C ? 1 : 0], R = B.engineType[0];
      return { transcoderFormat: Q, engineFormat: D, engineType: R };
    }
    throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.");
  }
  function g(f) {
    return f <= 2 ? !0 : (f & f - 1) === 0 && f !== 0;
  }
  function d(f) {
    if (f.length === 1) return f[0];
    let I = 0;
    for (let w = 0; w < f.length; w++) {
      const b = f[w];
      I += b.byteLength;
    }
    const m = new Uint8Array(I);
    let C = 0;
    for (let w = 0; w < f.length; w++) {
      const b = f[w];
      m.set(b, C), C += b.byteLength;
    }
    return m;
  }
};
const Ac = /* @__PURE__ */ new Set([zt, ei, Mn, gn]), Ts = {
  [ur]: zt,
  [cr]: zt,
  [or]: zt,
  [rr]: zt,
  [hr]: Mn,
  [Ar]: Mn,
  [sr]: Mn,
  [ir]: Mn,
  [lr]: gn,
  [ar]: gn,
  [nr]: gn,
  [tr]: gn,
  [dr]: ei,
  [gr]: ei,
  [pr]: Ho,
  [fr]: jo,
  [Bi]: os,
  [sc]: os,
  [nc]: os,
  [mr]: ki,
  [Ir]: ki,
  [JA]: Xs,
  [VA]: Xs,
  [YA]: Fi,
  [KA]: Fi,
  [XA]: Mi,
  [WA]: Mi,
  [$A]: Zs,
  [ZA]: Zs,
  [tc]: $s,
  [ec]: $s
}, yn = {
  [ur]: mt,
  [cr]: We,
  [or]: dt,
  [rr]: dt,
  [hr]: mt,
  [Ar]: We,
  [sr]: dt,
  [ir]: dt,
  [lr]: mt,
  [ar]: We,
  [nr]: dt,
  [tr]: dt,
  [dr]: zo,
  [gr]: qo,
  [pr]: dt,
  [fr]: dt,
  [Bi]: We,
  [mr]: dt,
  [Ir]: dt
};
async function cc(A) {
  const { vkFormat: e } = A;
  if (Ts[e] === void 0)
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  let t;
  A.supercompressionScheme === ji && (Ss || (Ss = new Promise(async (o) => {
    const r = new oc();
    await r.init(), o(r);
  })), t = await Ss);
  const s = [];
  for (let o = 0; o < A.levels.length; o++) {
    const r = Math.max(1, A.pixelWidth >> o), a = Math.max(1, A.pixelHeight >> o), c = A.pixelDepth ? Math.max(1, A.pixelDepth >> o) : 0, l = A.levels[o];
    let h;
    if (A.supercompressionScheme === PA)
      h = l.levelData;
    else if (A.supercompressionScheme === ji)
      h = t.decode(l.levelData, l.uncompressedByteLength);
    else
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    let g;
    yn[e] === mt ? g = new Float32Array(
      h.buffer,
      h.byteOffset,
      h.byteLength / Float32Array.BYTES_PER_ELEMENT
    ) : yn[e] === We ? g = new Uint16Array(
      h.buffer,
      h.byteOffset,
      h.byteLength / Uint16Array.BYTES_PER_ELEMENT
    ) : yn[e] === zo || yn[e] === qo ? g = new Uint32Array(
      h.buffer,
      h.byteOffset,
      h.byteLength / Uint32Array.BYTES_PER_ELEMENT
    ) : g = h, s.push({
      data: g,
      width: r,
      height: a,
      depth: c
    });
  }
  const n = A.levelCount === 0 || s.length > 1;
  let i;
  if (Ac.has(Ts[e]))
    i = A.pixelDepth === 0 ? new ka(s[0].data, A.pixelWidth, A.pixelHeight) : new La(s[0].data, A.pixelWidth, A.pixelHeight, A.pixelDepth), i.minFilter = n ? pi : cs, i.magFilter = cs, i.generateMipmaps = A.levelCount === 0;
  else {
    if (A.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    i = new Gn(s, A.pixelWidth, A.pixelHeight), i.minFilter = n ? jn : rt, i.magFilter = rt;
  }
  return i.mipmaps = s, i.type = yn[e], i.format = Ts[e], i.colorSpace = Er(A), i.needsUpdate = !0, Promise.resolve(i);
}
function Er(A) {
  const e = A.dataFormatDescriptor[0];
  return e.colorPrimaries === jA ? e.transferFunction === qi ? ge : Xe : e.colorPrimaries === qA ? e.transferFunction === qi ? rc : ac : e.colorPrimaries === HA ? us : (console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), us);
}
class _h extends Na {
  constructor(e, t = {}) {
    const s = t.font;
    if (s === void 0)
      super();
    else {
      const n = s.generateShapes(e, t.size);
      t.depth === void 0 && t.height !== void 0 && console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead"), t.depth = t.depth !== void 0 ? t.depth : t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(n, t);
    }
    this.type = "TextGeometry";
  }
}
class Mh extends kt {
  constructor(e) {
    super(e);
  }
  load(e, t, s, n) {
    const i = this, o = new It(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(r) {
      const a = i.parse(JSON.parse(r));
      t && t(a);
    }, s, n);
  }
  parse(e) {
    return new lc(e);
  }
}
class lc {
  constructor(e) {
    this.isFont = !0, this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100) {
    const s = [], n = hc(e, t, this.data);
    for (let i = 0, o = n.length; i < o; i++)
      s.push(...n[i].toShapes());
    return s;
  }
}
function hc(A, e, t) {
  const s = Array.from(A), n = e / t.resolution, i = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n, o = [];
  let r = 0, a = 0;
  for (let c = 0; c < s.length; c++) {
    const l = s[c];
    if (l === `
`)
      r = 0, a -= i;
    else {
      const h = uc(l, n, r, a, t);
      r += h.offsetX, o.push(h.path);
    }
  }
  return o;
}
function uc(A, e, t, s, n) {
  const i = n.glyphs[A] || n.glyphs["?"];
  if (!i) {
    console.error('THREE.Font: character "' + A + '" does not exists in font family ' + n.familyName + ".");
    return;
  }
  const o = new Ua();
  let r, a, c, l, h, g, d, f;
  if (i.o) {
    const I = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let m = 0, C = I.length; m < C; )
      switch (I[m++]) {
        case "m":
          r = I[m++] * e + t, a = I[m++] * e + s, o.moveTo(r, a);
          break;
        case "l":
          r = I[m++] * e + t, a = I[m++] * e + s, o.lineTo(r, a);
          break;
        case "q":
          c = I[m++] * e + t, l = I[m++] * e + s, h = I[m++] * e + t, g = I[m++] * e + s, o.quadraticCurveTo(h, g, c, l);
          break;
        case "b":
          c = I[m++] * e + t, l = I[m++] * e + s, h = I[m++] * e + t, g = I[m++] * e + s, d = I[m++] * e + t, f = I[m++] * e + s, o.bezierCurveTo(h, g, d, f, c, l);
          break;
      }
  }
  return { offsetX: i.ha * e, path: o };
}
const Wt = new bi(), He = new P(), Ht = new P(), ye = new Te(), Ki = {
  X: new P(1, 0, 0),
  Y: new P(0, 1, 0),
  Z: new P(0, 0, 1)
}, vs = { type: "change" }, Ji = { type: "mouseDown", mode: null }, Vi = { type: "mouseUp", mode: null }, Wi = { type: "objectChange" };
class Fh extends Yo {
  constructor(e, t = null) {
    super(void 0, t);
    const s = new mc(this);
    this._root = s;
    const n = new Ec();
    this._gizmo = n, s.add(n);
    const i = new bc();
    this._plane = i, s.add(i);
    const o = this;
    function r(b, B) {
      let Q = B;
      Object.defineProperty(o, b, {
        get: function() {
          return Q !== void 0 ? Q : B;
        },
        set: function(D) {
          Q !== D && (Q = D, i[b] = D, n[b] = D, o.dispatchEvent({ type: b + "-changed", value: D }), o.dispatchEvent(vs));
        }
      }), o[b] = B, i[b] = B, n[b] = B;
    }
    r("camera", e), r("object", void 0), r("enabled", !0), r("axis", null), r("mode", "translate"), r("translationSnap", null), r("rotationSnap", null), r("scaleSnap", null), r("space", "world"), r("size", 1), r("dragging", !1), r("showX", !0), r("showY", !0), r("showZ", !0);
    const a = new P(), c = new P(), l = new Te(), h = new Te(), g = new P(), d = new Te(), f = new P(), I = new P(), m = new P(), C = 0, w = new P();
    r("worldPosition", a), r("worldPositionStart", c), r("worldQuaternion", l), r("worldQuaternionStart", h), r("cameraPosition", g), r("cameraQuaternion", d), r("pointStart", f), r("pointEnd", I), r("rotationAxis", m), r("rotationAngle", C), r("eye", w), this._offset = new P(), this._startNorm = new P(), this._endNorm = new P(), this._cameraScale = new P(), this._parentPosition = new P(), this._parentQuaternion = new Te(), this._parentQuaternionInv = new Te(), this._parentScale = new P(), this._worldScaleStart = new P(), this._worldQuaternionInv = new Te(), this._worldScale = new P(), this._positionStart = new P(), this._quaternionStart = new Te(), this._scaleStart = new P(), this._getPointer = gc.bind(this), this._onPointerDown = pc.bind(this), this._onPointerHover = dc.bind(this), this._onPointerMove = fc.bind(this), this._onPointerUp = Ic.bind(this), t !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    e !== null && Wt.setFromCamera(e, this.camera);
    const t = Ds(this._gizmo.picker[this.mode], Wt);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && Wt.setFromCamera(e, this.camera);
      const t = Ds(this._plane, Wt, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, Ji.mode = this.mode, this.dispatchEvent(Ji);
    }
  }
  pointerMove(e) {
    const t = this.axis, s = this.mode, n = this.object;
    let i = this.space;
    if (s === "scale" ? i = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (i = "world"), n === void 0 || t === null || this.dragging === !1 || e !== null && e.button !== -1) return;
    e !== null && Wt.setFromCamera(e, this.camera);
    const o = Ds(this._plane, Wt, !0);
    if (o) {
      if (this.pointEnd.copy(o.point).sub(this.worldPositionStart), s === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), i === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), i === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), n.position.copy(this._offset).add(this._positionStart), this.translationSnap && (i === "local" && (n.position.applyQuaternion(ye.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.position.applyQuaternion(this._quaternionStart)), i === "world" && (n.parent && n.position.add(He.setFromMatrixPosition(n.parent.matrixWorld)), t.search("X") !== -1 && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.parent && n.position.sub(He.setFromMatrixPosition(n.parent.matrixWorld))));
      else if (s === "scale") {
        if (t.search("XYZ") !== -1) {
          let r = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (r *= -1), Ht.set(r, r, r);
        } else
          He.copy(this.pointStart), Ht.copy(this.pointEnd), He.applyQuaternion(this._worldQuaternionInv), Ht.applyQuaternion(this._worldQuaternionInv), Ht.divide(He), t.search("X") === -1 && (Ht.x = 1), t.search("Y") === -1 && (Ht.y = 1), t.search("Z") === -1 && (Ht.z = 1);
        n.scale.copy(this._scaleStart).multiply(Ht), this.scaleSnap && (t.search("X") !== -1 && (n.scale.x = Math.round(n.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (n.scale.y = Math.round(n.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (n.scale.z = Math.round(n.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (s === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const r = 20 / this.worldPosition.distanceTo(He.setFromMatrixPosition(this.camera.matrixWorld));
        let a = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(He.copy(this.rotationAxis).cross(this.eye)) * r) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(Ki[t]), He.copy(Ki[t]), i === "local" && He.applyQuaternion(this.worldQuaternion), He.cross(this.eye), He.length() === 0 ? a = !0 : this.rotationAngle = this._offset.dot(He.normalize()) * r), (t === "E" || a) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), i === "local" && t !== "E" && t !== "XYZE" ? (n.quaternion.copy(this._quaternionStart), n.quaternion.multiply(ye.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), n.quaternion.copy(ye.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), n.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(vs), this.dispatchEvent(Wi);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (Vi.mode = this.mode, this.dispatchEvent(Vi)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  // Set current object
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(vs), this.dispatchEvent(Wi), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Wt;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function gc(A) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: A.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (A.clientX - e.left) / e.width * 2 - 1,
      y: -(A.clientY - e.top) / e.height * 2 + 1,
      button: A.button
    };
  }
}
function dc(A) {
  if (this.enabled)
    switch (A.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(A));
        break;
    }
}
function pc(A) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(A.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(A)), this.pointerDown(this._getPointer(A)));
}
function fc(A) {
  this.enabled && this.pointerMove(this._getPointer(A));
}
function Ic(A) {
  this.enabled && (this.domElement.releasePointerCapture(A.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(A)));
}
function Ds(A, e, t) {
  const s = e.intersectObject(A, !0);
  for (let n = 0; n < s.length; n++)
    if (s[n].object.visible || t)
      return s[n];
  return !1;
}
const Jn = new qt(), me = new P(0, 1, 0), Xi = new P(0, 0, 0), Zi = new ue(), Vn = new Te(), as = new Te(), bt = new P(), $i = new ue(), Fn = new P(1, 0, 0), Zt = new P(0, 1, 0), kn = new P(0, 0, 1), Wn = new P(), Qn = new P(), xn = new P();
class mc extends xt {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const t = this.controls;
    t.object !== void 0 && (t.object.updateMatrixWorld(), t.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : t.object.parent.matrixWorld.decompose(t._parentPosition, t._parentQuaternion, t._parentScale), t.object.matrixWorld.decompose(t.worldPosition, t.worldQuaternion, t._worldScale), t._parentQuaternionInv.copy(t._parentQuaternion).invert(), t._worldQuaternionInv.copy(t.worldQuaternion).invert()), t.camera.updateMatrixWorld(), t.camera.matrixWorld.decompose(t.cameraPosition, t.cameraQuaternion, t._cameraScale), t.camera.isOrthographicCamera ? t.camera.getWorldDirection(t.eye).negate() : t.eye.copy(t.cameraPosition).sub(t.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
}
class Ec extends xt {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new Qt({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new Ft({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), s = e.clone();
    s.opacity = 0.15;
    const n = t.clone();
    n.opacity = 0.5;
    const i = e.clone();
    i.color.setHex(16711680);
    const o = e.clone();
    o.color.setHex(65280);
    const r = e.clone();
    r.color.setHex(255);
    const a = e.clone();
    a.color.setHex(16711680), a.opacity = 0.5;
    const c = e.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const l = e.clone();
    l.color.setHex(255), l.opacity = 0.5;
    const h = e.clone();
    h.opacity = 0.25;
    const g = e.clone();
    g.color.setHex(16776960), g.opacity = 0.25, e.clone().color.setHex(16776960);
    const f = e.clone();
    f.color.setHex(7895160);
    const I = new Ye(0, 0.04, 0.1, 12);
    I.translate(0, 0.05, 0);
    const m = new je(0.08, 0.08, 0.08);
    m.translate(0, 0.04, 0);
    const C = new ut();
    C.setAttribute("position", new Fe([0, 0, 0, 1, 0, 0], 3));
    const w = new Ye(75e-4, 75e-4, 0.5, 3);
    w.translate(0, 0.25, 0);
    function b(K, O) {
      const $ = new bn(K, 75e-4, 3, 64, O * Math.PI * 2);
      return $.rotateY(Math.PI / 2), $.rotateX(Math.PI / 2), $;
    }
    function B() {
      const K = new ut();
      return K.setAttribute("position", new Fe([0, 0, 0, 1, 1, 1], 3)), K;
    }
    const Q = {
      X: [
        [new q(I, i), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new q(I, i), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new q(w, i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new q(I, o), [0, 0.5, 0]],
        [new q(I, o), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new q(w, o)]
      ],
      Z: [
        [new q(I, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new q(I, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new q(w, r), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new q(new Kn(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new q(new je(0.15, 0.15, 0.01), l.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new q(new je(0.15, 0.15, 0.01), a.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new q(new je(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, D = {
      X: [
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new q(new Ye(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new q(new Kn(0.2, 0), s)]
      ],
      XY: [
        [new q(new je(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new q(new je(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new q(new je(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, R = {
      START: [
        [new q(new Kn(0.01, 2), n), null, null, null, "helper"]
      ],
      END: [
        [new q(new Kn(0.01, 2), n), null, null, null, "helper"]
      ],
      DELTA: [
        [new pt(B(), n), null, null, null, "helper"]
      ],
      X: [
        [new pt(C, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new pt(C, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new pt(C, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, x = {
      XYZE: [
        [new q(b(0.5, 1), f), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new q(b(0.5, 0.5), i)]
      ],
      Y: [
        [new q(b(0.5, 0.5), o), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new q(b(0.5, 0.5), r), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new q(b(0.75, 1), g), null, [0, Math.PI / 2, 0]]
      ]
    }, T = {
      AXIS: [
        [new pt(C, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, U = {
      XYZE: [
        [new q(new ui(0.25, 10, 8), s)]
      ],
      X: [
        [new q(new bn(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new q(new bn(0.5, 0.1, 4, 24), s), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new q(new bn(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new q(new bn(0.75, 0.1, 2, 24), s)]
      ]
    }, L = {
      X: [
        [new q(m, i), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new q(w, i), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new q(m, i), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new q(m, o), [0, 0.5, 0]],
        [new q(w, o)],
        [new q(m, o), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new q(m, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new q(w, r), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new q(m, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new q(new je(0.15, 0.15, 0.01), l), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new q(new je(0.15, 0.15, 0.01), a), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new q(new je(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new q(new je(0.1, 0.1, 0.1), h.clone())]
      ]
    }, H = {
      X: [
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new q(new Ye(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new q(new Ye(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new q(new je(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new q(new je(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new q(new je(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new q(new je(0.2, 0.2, 0.2), s), [0, 0, 0]]
      ]
    }, Z = {
      X: [
        [new pt(C, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new pt(C, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new pt(C, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function N(K) {
      const O = new xt();
      for (const $ in K)
        for (let oe = K[$].length; oe--; ) {
          const te = K[$][oe][0].clone(), le = K[$][oe][1], ne = K[$][oe][2], X = K[$][oe][3], ie = K[$][oe][4];
          te.name = $, te.tag = ie, le && te.position.set(le[0], le[1], le[2]), ne && te.rotation.set(ne[0], ne[1], ne[2]), X && te.scale.set(X[0], X[1], X[2]), te.updateMatrix();
          const fe = te.geometry.clone();
          fe.applyMatrix4(te.matrix), te.geometry = fe, te.renderOrder = 1 / 0, te.position.set(0, 0, 0), te.rotation.set(0, 0, 0), te.scale.set(1, 1, 1), O.add(te);
        }
      return O;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = N(Q)), this.add(this.gizmo.rotate = N(x)), this.add(this.gizmo.scale = N(L)), this.add(this.picker.translate = N(D)), this.add(this.picker.rotate = N(U)), this.add(this.picker.scale = N(H)), this.add(this.helper.translate = N(R)), this.add(this.helper.rotate = N(T)), this.add(this.helper.scale = N(Z)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const s = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : as;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let n = [];
    n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      o.visible = !0, o.rotation.set(0, 0, 0), o.position.copy(this.worldPosition);
      let r;
      if (this.camera.isOrthographicCamera ? r = (this.camera.top - this.camera.bottom) / this.camera.zoom : r = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), o.scale.set(1, 1, 1).multiplyScalar(r * this.size / 4), o.tag === "helper") {
        o.visible = !1, o.name === "AXIS" ? (o.visible = !!this.axis, this.axis === "X" && (ye.setFromEuler(Jn.set(0, 0, 0)), o.quaternion.copy(s).multiply(ye), Math.abs(me.copy(Fn).applyQuaternion(s).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "Y" && (ye.setFromEuler(Jn.set(0, 0, Math.PI / 2)), o.quaternion.copy(s).multiply(ye), Math.abs(me.copy(Zt).applyQuaternion(s).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "Z" && (ye.setFromEuler(Jn.set(0, Math.PI / 2, 0)), o.quaternion.copy(s).multiply(ye), Math.abs(me.copy(kn).applyQuaternion(s).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "XYZE" && (ye.setFromEuler(Jn.set(0, Math.PI / 2, 0)), me.copy(this.rotationAxis), o.quaternion.setFromRotationMatrix(Zi.lookAt(Xi, me, Zt)), o.quaternion.multiply(ye), o.visible = this.dragging), this.axis === "E" && (o.visible = !1)) : o.name === "START" ? (o.position.copy(this.worldPositionStart), o.visible = this.dragging) : o.name === "END" ? (o.position.copy(this.worldPosition), o.visible = this.dragging) : o.name === "DELTA" ? (o.position.copy(this.worldPositionStart), o.quaternion.copy(this.worldQuaternionStart), He.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), He.applyQuaternion(this.worldQuaternionStart.clone().invert()), o.scale.copy(He), o.visible = this.dragging) : (o.quaternion.copy(s), this.dragging ? o.position.copy(this.worldPositionStart) : o.position.copy(this.worldPosition), this.axis && (o.visible = this.axis.search(o.name) !== -1));
        continue;
      }
      o.quaternion.copy(s), this.mode === "translate" || this.mode === "scale" ? (o.name === "X" && Math.abs(me.copy(Fn).applyQuaternion(s).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "Y" && Math.abs(me.copy(Zt).applyQuaternion(s).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "Z" && Math.abs(me.copy(kn).applyQuaternion(s).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "XY" && Math.abs(me.copy(kn).applyQuaternion(s).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "YZ" && Math.abs(me.copy(Fn).applyQuaternion(s).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "XZ" && Math.abs(me.copy(Zt).applyQuaternion(s).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1)) : this.mode === "rotate" && (Vn.copy(s), me.copy(this.eye).applyQuaternion(ye.copy(s).invert()), o.name.search("E") !== -1 && o.quaternion.setFromRotationMatrix(Zi.lookAt(this.eye, Xi, Zt)), o.name === "X" && (ye.setFromAxisAngle(Fn, Math.atan2(-me.y, me.z)), ye.multiplyQuaternions(Vn, ye), o.quaternion.copy(ye)), o.name === "Y" && (ye.setFromAxisAngle(Zt, Math.atan2(me.x, me.z)), ye.multiplyQuaternions(Vn, ye), o.quaternion.copy(ye)), o.name === "Z" && (ye.setFromAxisAngle(kn, Math.atan2(me.y, me.x)), ye.multiplyQuaternions(Vn, ye), o.quaternion.copy(ye))), o.visible = o.visible && (o.name.indexOf("X") === -1 || this.showX), o.visible = o.visible && (o.name.indexOf("Y") === -1 || this.showY), o.visible = o.visible && (o.name.indexOf("Z") === -1 || this.showZ), o.visible = o.visible && (o.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), o.material._color = o.material._color || o.material.color.clone(), o.material._opacity = o.material._opacity || o.material.opacity, o.material.color.copy(o.material._color), o.material.opacity = o.material._opacity, this.enabled && this.axis && (o.name === this.axis || this.axis.split("").some(function(a) {
        return o.name === a;
      })) && (o.material.color.setHex(16776960), o.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class bc extends q {
  constructor() {
    super(
      new Ci(1e5, 1e5, 2, 2),
      new Qt({ visible: !1, wireframe: !0, side: Ii, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), Wn.copy(Fn).applyQuaternion(t === "local" ? this.worldQuaternion : as), Qn.copy(Zt).applyQuaternion(t === "local" ? this.worldQuaternion : as), xn.copy(kn).applyQuaternion(t === "local" ? this.worldQuaternion : as), me.copy(Qn), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            me.copy(this.eye).cross(Wn), bt.copy(Wn).cross(me);
            break;
          case "Y":
            me.copy(this.eye).cross(Qn), bt.copy(Qn).cross(me);
            break;
          case "Z":
            me.copy(this.eye).cross(xn), bt.copy(xn).cross(me);
            break;
          case "XY":
            bt.copy(xn);
            break;
          case "YZ":
            bt.copy(Wn);
            break;
          case "XZ":
            me.copy(xn), bt.copy(Qn);
            break;
          case "XYZ":
          case "E":
            bt.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        bt.set(0, 0, 0);
    }
    bt.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : ($i.lookAt(He.set(0, 0, 0), bt, me), this.quaternion.setFromRotationMatrix($i)), super.updateMatrixWorld(e);
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/
var Re = Uint8Array, it = Uint16Array, wi = Int32Array, ps = new Re([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), fs = new Re([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), ri = new Re([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), br = function(A, e) {
  for (var t = new it(31), s = 0; s < 31; ++s)
    t[s] = e += 1 << A[s - 1];
  for (var n = new wi(t[30]), s = 1; s < 30; ++s)
    for (var i = t[s]; i < t[s + 1]; ++i)
      n[i] = i - t[s] << 5 | s;
  return { b: t, r: n };
}, Cr = br(ps, 2), Br = Cr.b, ai = Cr.r;
Br[28] = 258, ai[258] = 28;
var wr = br(fs, 0), Cc = wr.b, eo = wr.r, Ai = new it(32768);
for (var we = 0; we < 32768; ++we) {
  var jt = (we & 43690) >> 1 | (we & 21845) << 1;
  jt = (jt & 52428) >> 2 | (jt & 13107) << 2, jt = (jt & 61680) >> 4 | (jt & 3855) << 4, Ai[we] = ((jt & 65280) >> 8 | (jt & 255) << 8) >> 1;
}
var St = (function(A, e, t) {
  for (var s = A.length, n = 0, i = new it(e); n < s; ++n)
    A[n] && ++i[A[n] - 1];
  var o = new it(e);
  for (n = 1; n < e; ++n)
    o[n] = o[n - 1] + i[n - 1] << 1;
  var r;
  if (t) {
    r = new it(1 << e);
    var a = 15 - e;
    for (n = 0; n < s; ++n)
      if (A[n])
        for (var c = n << 4 | A[n], l = e - A[n], h = o[A[n] - 1]++ << l, g = h | (1 << l) - 1; h <= g; ++h)
          r[Ai[h] >> a] = c;
  } else
    for (r = new it(s), n = 0; n < s; ++n)
      A[n] && (r[n] = Ai[o[A[n] - 1]++] >> 15 - A[n]);
  return r;
}), Yt = new Re(288);
for (var we = 0; we < 144; ++we)
  Yt[we] = 8;
for (var we = 144; we < 256; ++we)
  Yt[we] = 9;
for (var we = 256; we < 280; ++we)
  Yt[we] = 7;
for (var we = 280; we < 288; ++we)
  Yt[we] = 8;
var On = new Re(32);
for (var we = 0; we < 32; ++we)
  On[we] = 5;
var Bc = /* @__PURE__ */ St(Yt, 9, 0), wc = /* @__PURE__ */ St(Yt, 9, 1), yc = /* @__PURE__ */ St(On, 5, 0), Qc = /* @__PURE__ */ St(On, 5, 1), Rs = function(A) {
  for (var e = A[0], t = 1; t < A.length; ++t)
    A[t] > e && (e = A[t]);
  return e;
}, gt = function(A, e, t) {
  var s = e / 8 | 0;
  return (A[s] | A[s + 1] << 8) >> (e & 7) & t;
}, _s = function(A, e) {
  var t = e / 8 | 0;
  return (A[t] | A[t + 1] << 8 | A[t + 2] << 16) >> (e & 7);
}, yi = function(A) {
  return (A + 7) / 8 | 0;
}, Qi = function(A, e, t) {
  return (t == null || t > A.length) && (t = A.length), new Re(A.subarray(e, t));
}, xc = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], Je = function(A, e, t) {
  var s = new Error(e || xc[A]);
  if (s.code = A, Error.captureStackTrace && Error.captureStackTrace(s, Je), !t)
    throw s;
  return s;
}, Sc = function(A, e, t, s) {
  var n = A.length, i = 0;
  if (!n || e.f && !e.l)
    return t || new Re(0);
  var o = !t, r = o || e.i != 2, a = e.i;
  o && (t = new Re(n * 3));
  var c = function(Ut) {
    var Kt = t.length;
    if (Ut > Kt) {
      var vt = new Re(Math.max(Kt * 2, Ut));
      vt.set(t), t = vt;
    }
  }, l = e.f || 0, h = e.p || 0, g = e.b || 0, d = e.l, f = e.d, I = e.m, m = e.n, C = n * 8;
  do {
    if (!d) {
      l = gt(A, h, 1);
      var w = gt(A, h + 1, 3);
      if (h += 3, w)
        if (w == 1)
          d = wc, f = Qc, I = 9, m = 5;
        else if (w == 2) {
          var D = gt(A, h, 31) + 257, R = gt(A, h + 10, 15) + 4, x = D + gt(A, h + 5, 31) + 1;
          h += 14;
          for (var T = new Re(x), U = new Re(19), L = 0; L < R; ++L)
            U[ri[L]] = gt(A, h + L * 3, 7);
          h += R * 3;
          for (var H = Rs(U), Z = (1 << H) - 1, N = St(U, H, 1), L = 0; L < x; ) {
            var K = N[gt(A, h, Z)];
            h += K & 15;
            var b = K >> 4;
            if (b < 16)
              T[L++] = b;
            else {
              var O = 0, $ = 0;
              for (b == 16 ? ($ = 3 + gt(A, h, 3), h += 2, O = T[L - 1]) : b == 17 ? ($ = 3 + gt(A, h, 7), h += 3) : b == 18 && ($ = 11 + gt(A, h, 127), h += 7); $--; )
                T[L++] = O;
            }
          }
          var oe = T.subarray(0, D), te = T.subarray(D);
          I = Rs(oe), m = Rs(te), d = St(oe, I, 1), f = St(te, m, 1);
        } else
          Je(1);
      else {
        var b = yi(h) + 4, B = A[b - 4] | A[b - 3] << 8, Q = b + B;
        if (Q > n) {
          a && Je(0);
          break;
        }
        r && c(g + B), t.set(A.subarray(b, Q), g), e.b = g += B, e.p = h = Q * 8, e.f = l;
        continue;
      }
      if (h > C) {
        a && Je(0);
        break;
      }
    }
    r && c(g + 131072);
    for (var le = (1 << I) - 1, ne = (1 << m) - 1, X = h; ; X = h) {
      var O = d[_s(A, h) & le], ie = O >> 4;
      if (h += O & 15, h > C) {
        a && Je(0);
        break;
      }
      if (O || Je(2), ie < 256)
        t[g++] = ie;
      else if (ie == 256) {
        X = h, d = null;
        break;
      } else {
        var fe = ie - 254;
        if (ie > 264) {
          var L = ie - 257, be = ps[L];
          fe = gt(A, h, (1 << be) - 1) + Br[L], h += be;
        }
        var ce = f[_s(A, h) & ne], Ze = ce >> 4;
        ce || Je(3), h += ce & 15;
        var te = Cc[Ze];
        if (Ze > 3) {
          var be = fs[Ze];
          te += _s(A, h) & (1 << be) - 1, h += be;
        }
        if (h > C) {
          a && Je(0);
          break;
        }
        r && c(g + 131072);
        var $e = g + fe;
        if (g < te) {
          var rn = i - te, an = Math.min(te, $e);
          for (rn + g < 0 && Je(3); g < an; ++g)
            t[g] = s[rn + g];
        }
        for (; g < $e; ++g)
          t[g] = t[g - te];
      }
    }
    e.l = d, e.p = X, e.b = g, e.f = l, d && (l = 1, e.m = I, e.d = f, e.n = m);
  } while (!l);
  return g != t.length && o ? Qi(t, 0, g) : t.subarray(0, g);
}, Rt = function(A, e, t) {
  t <<= e & 7;
  var s = e / 8 | 0;
  A[s] |= t, A[s + 1] |= t >> 8;
}, Sn = function(A, e, t) {
  t <<= e & 7;
  var s = e / 8 | 0;
  A[s] |= t, A[s + 1] |= t >> 8, A[s + 2] |= t >> 16;
}, Ms = function(A, e) {
  for (var t = [], s = 0; s < A.length; ++s)
    A[s] && t.push({ s, f: A[s] });
  var n = t.length, i = t.slice();
  if (!n)
    return { t: Qr, l: 0 };
  if (n == 1) {
    var o = new Re(t[0].s + 1);
    return o[t[0].s] = 1, { t: o, l: 1 };
  }
  t.sort(function(Q, D) {
    return Q.f - D.f;
  }), t.push({ s: -1, f: 25001 });
  var r = t[0], a = t[1], c = 0, l = 1, h = 2;
  for (t[0] = { s: -1, f: r.f + a.f, l: r, r: a }; l != n - 1; )
    r = t[t[c].f < t[h].f ? c++ : h++], a = t[c != l && t[c].f < t[h].f ? c++ : h++], t[l++] = { s: -1, f: r.f + a.f, l: r, r: a };
  for (var g = i[0].s, s = 1; s < n; ++s)
    i[s].s > g && (g = i[s].s);
  var d = new it(g + 1), f = ci(t[l - 1], d, 0);
  if (f > e) {
    var s = 0, I = 0, m = f - e, C = 1 << m;
    for (i.sort(function(D, R) {
      return d[R.s] - d[D.s] || D.f - R.f;
    }); s < n; ++s) {
      var w = i[s].s;
      if (d[w] > e)
        I += C - (1 << f - d[w]), d[w] = e;
      else
        break;
    }
    for (I >>= m; I > 0; ) {
      var b = i[s].s;
      d[b] < e ? I -= 1 << e - d[b]++ - 1 : ++s;
    }
    for (; s >= 0 && I; --s) {
      var B = i[s].s;
      d[B] == e && (--d[B], ++I);
    }
    f = e;
  }
  return { t: new Re(d), l: f };
}, ci = function(A, e, t) {
  return A.s == -1 ? Math.max(ci(A.l, e, t + 1), ci(A.r, e, t + 1)) : e[A.s] = t;
}, to = function(A) {
  for (var e = A.length; e && !A[--e]; )
    ;
  for (var t = new it(++e), s = 0, n = A[0], i = 1, o = function(a) {
    t[s++] = a;
  }, r = 1; r <= e; ++r)
    if (A[r] == n && r != e)
      ++i;
    else {
      if (!n && i > 2) {
        for (; i > 138; i -= 138)
          o(32754);
        i > 2 && (o(i > 10 ? i - 11 << 5 | 28690 : i - 3 << 5 | 12305), i = 0);
      } else if (i > 3) {
        for (o(n), --i; i > 6; i -= 6)
          o(8304);
        i > 2 && (o(i - 3 << 5 | 8208), i = 0);
      }
      for (; i--; )
        o(n);
      i = 1, n = A[r];
    }
  return { c: t.subarray(0, s), n: e };
}, Tn = function(A, e) {
  for (var t = 0, s = 0; s < e.length; ++s)
    t += A[s] * e[s];
  return t;
}, yr = function(A, e, t) {
  var s = t.length, n = yi(e + 2);
  A[n] = s & 255, A[n + 1] = s >> 8, A[n + 2] = A[n] ^ 255, A[n + 3] = A[n + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    A[n + i + 4] = t[i];
  return (n + 4 + s) * 8;
}, no = function(A, e, t, s, n, i, o, r, a, c, l) {
  Rt(e, l++, t), ++n[256];
  for (var h = Ms(n, 15), g = h.t, d = h.l, f = Ms(i, 15), I = f.t, m = f.l, C = to(g), w = C.c, b = C.n, B = to(I), Q = B.c, D = B.n, R = new it(19), x = 0; x < w.length; ++x)
    ++R[w[x] & 31];
  for (var x = 0; x < Q.length; ++x)
    ++R[Q[x] & 31];
  for (var T = Ms(R, 7), U = T.t, L = T.l, H = 19; H > 4 && !U[ri[H - 1]]; --H)
    ;
  var Z = c + 5 << 3, N = Tn(n, Yt) + Tn(i, On) + o, K = Tn(n, g) + Tn(i, I) + o + 14 + 3 * H + Tn(R, U) + 2 * R[16] + 3 * R[17] + 7 * R[18];
  if (a >= 0 && Z <= N && Z <= K)
    return yr(e, l, A.subarray(a, a + c));
  var O, $, oe, te;
  if (Rt(e, l, 1 + (K < N)), l += 2, K < N) {
    O = St(g, d, 0), $ = g, oe = St(I, m, 0), te = I;
    var le = St(U, L, 0);
    Rt(e, l, b - 257), Rt(e, l + 5, D - 1), Rt(e, l + 10, H - 4), l += 14;
    for (var x = 0; x < H; ++x)
      Rt(e, l + 3 * x, U[ri[x]]);
    l += 3 * H;
    for (var ne = [w, Q], X = 0; X < 2; ++X)
      for (var ie = ne[X], x = 0; x < ie.length; ++x) {
        var fe = ie[x] & 31;
        Rt(e, l, le[fe]), l += U[fe], fe > 15 && (Rt(e, l, ie[x] >> 5 & 127), l += ie[x] >> 12);
      }
  } else
    O = Bc, $ = Yt, oe = yc, te = On;
  for (var x = 0; x < r; ++x) {
    var be = s[x];
    if (be > 255) {
      var fe = be >> 18 & 31;
      Sn(e, l, O[fe + 257]), l += $[fe + 257], fe > 7 && (Rt(e, l, be >> 23 & 31), l += ps[fe]);
      var ce = be & 31;
      Sn(e, l, oe[ce]), l += te[ce], ce > 3 && (Sn(e, l, be >> 5 & 8191), l += fs[ce]);
    } else
      Sn(e, l, O[be]), l += $[be];
  }
  return Sn(e, l, O[256]), l + $[256];
}, Tc = /* @__PURE__ */ new wi([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Qr = /* @__PURE__ */ new Re(0), vc = function(A, e, t, s, n, i) {
  var o = i.z || A.length, r = new Re(s + o + 5 * (1 + Math.ceil(o / 7e3)) + n), a = r.subarray(s, r.length - n), c = i.l, l = (i.r || 0) & 7;
  if (e) {
    l && (a[0] = i.r >> 3);
    for (var h = Tc[e - 1], g = h >> 13, d = h & 8191, f = (1 << t) - 1, I = i.p || new it(32768), m = i.h || new it(f + 1), C = Math.ceil(t / 3), w = 2 * C, b = function(An) {
      return (A[An] ^ A[An + 1] << C ^ A[An + 2] << w) & f;
    }, B = new wi(25e3), Q = new it(288), D = new it(32), R = 0, x = 0, T = i.i || 0, U = 0, L = i.w || 0, H = 0; T + 2 < o; ++T) {
      var Z = b(T), N = T & 32767, K = m[Z];
      if (I[N] = K, m[Z] = N, L <= T) {
        var O = o - T;
        if ((R > 7e3 || U > 24576) && (O > 423 || !c)) {
          l = no(A, a, 0, B, Q, D, x, U, H, T - H, l), U = R = x = 0, H = T;
          for (var $ = 0; $ < 286; ++$)
            Q[$] = 0;
          for (var $ = 0; $ < 30; ++$)
            D[$] = 0;
        }
        var oe = 2, te = 0, le = d, ne = N - K & 32767;
        if (O > 2 && Z == b(T - ne))
          for (var X = Math.min(g, O) - 1, ie = Math.min(32767, T), fe = Math.min(258, O); ne <= ie && --le && N != K; ) {
            if (A[T + oe] == A[T + oe - ne]) {
              for (var be = 0; be < fe && A[T + be] == A[T + be - ne]; ++be)
                ;
              if (be > oe) {
                if (oe = be, te = ne, be > X)
                  break;
                for (var ce = Math.min(ne, be - 2), Ze = 0, $ = 0; $ < ce; ++$) {
                  var $e = T - ne + $ & 32767, rn = I[$e], an = $e - rn & 32767;
                  an > Ze && (Ze = an, K = $e);
                }
              }
            }
            N = K, K = I[N], ne += N - K & 32767;
          }
        if (te) {
          B[U++] = 268435456 | ai[oe] << 18 | eo[te];
          var Ut = ai[oe] & 31, Kt = eo[te] & 31;
          x += ps[Ut] + fs[Kt], ++Q[257 + Ut], ++D[Kt], L = T + oe, ++R;
        } else
          B[U++] = A[T], ++Q[A[T]];
      }
    }
    for (T = Math.max(T, L); T < o; ++T)
      B[U++] = A[T], ++Q[A[T]];
    l = no(A, a, c, B, Q, D, x, U, H, T - H, l), c || (i.r = l & 7 | a[l / 8 | 0] << 3, l -= 7, i.h = m, i.p = I, i.i = T, i.w = L);
  } else {
    for (var T = i.w || 0; T < o + c; T += 65535) {
      var vt = T + 65535;
      vt >= o && (a[l / 8 | 0] = c, vt = o), l = yr(a, l + 1, A.subarray(T, vt));
    }
    i.i = o;
  }
  return Qi(r, 0, s + yi(l) + n);
}, Dc = /* @__PURE__ */ (function() {
  for (var A = new Int32Array(256), e = 0; e < 256; ++e) {
    for (var t = e, s = 9; --s; )
      t = (t & 1 && -306674912) ^ t >>> 1;
    A[e] = t;
  }
  return A;
})(), Rc = function() {
  var A = -1;
  return {
    p: function(e) {
      for (var t = A, s = 0; s < e.length; ++s)
        t = Dc[t & 255 ^ e[s]] ^ t >>> 8;
      A = t;
    },
    d: function() {
      return ~A;
    }
  };
}, _c = function(A, e, t, s, n) {
  if (!n && (n = { l: 1 }, e.dictionary)) {
    var i = e.dictionary.subarray(-32768), o = new Re(i.length + A.length);
    o.set(i), o.set(A, i.length), A = o, n.w = i.length;
  }
  return vc(A, e.level == null ? 6 : e.level, e.mem == null ? n.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(A.length))) * 1.5) : 20 : 12 + e.mem, t, s, n);
}, xr = function(A, e) {
  var t = {};
  for (var s in A)
    t[s] = A[s];
  for (var s in e)
    t[s] = e[s];
  return t;
}, Ge = function(A, e, t) {
  for (; t; ++e)
    A[e] = t, t >>>= 8;
}, Mc = function(A, e) {
  return ((A[0] & 15) != 8 || A[0] >> 4 > 7 || (A[0] << 8 | A[1]) % 31) && Je(6, "invalid zlib data"), (A[1] >> 5 & 1) == 1 && Je(6, "invalid zlib data: " + (A[1] & 32 ? "need" : "unexpected") + " dictionary"), (A[1] >> 3 & 4) + 2;
};
function Fc(A, e) {
  return _c(A, e || {}, 0, 0);
}
function Ln(A, e) {
  return Sc(A.subarray(Mc(A), -4), { i: 2 }, e, e);
}
var Sr = function(A, e, t, s) {
  for (var n in A) {
    var i = A[n], o = e + n, r = s;
    Array.isArray(i) && (r = xr(s, i[1]), i = i[0]), i instanceof Re ? t[o] = [i, r] : (t[o += "/"] = [new Re(0), r], Sr(i, o, t, s));
  }
}, so = typeof TextEncoder < "u" && /* @__PURE__ */ new TextEncoder(), kc = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Lc = 0;
try {
  kc.decode(Qr, { stream: !0 }), Lc = 1;
} catch {
}
function io(A, e) {
  var t;
  if (so)
    return so.encode(A);
  for (var s = A.length, n = new Re(A.length + (A.length >> 1)), i = 0, o = function(c) {
    n[i++] = c;
  }, t = 0; t < s; ++t) {
    if (i + 5 > n.length) {
      var r = new Re(i + 8 + (s - t << 1));
      r.set(n), n = r;
    }
    var a = A.charCodeAt(t);
    a < 128 || e ? o(a) : a < 2048 ? (o(192 | a >> 6), o(128 | a & 63)) : a > 55295 && a < 57344 ? (a = 65536 + (a & 1047552) | A.charCodeAt(++t) & 1023, o(240 | a >> 18), o(128 | a >> 12 & 63), o(128 | a >> 6 & 63), o(128 | a & 63)) : (o(224 | a >> 12), o(128 | a >> 6 & 63), o(128 | a & 63));
  }
  return Qi(n, 0, i);
}
var li = function(A) {
  var e = 0;
  if (A)
    for (var t in A) {
      var s = A[t].length;
      s > 65535 && Je(9), e += s + 4;
    }
  return e;
}, oo = function(A, e, t, s, n, i, o, r) {
  var a = s.length, c = t.extra, l = r && r.length, h = li(c);
  Ge(A, e, o != null ? 33639248 : 67324752), e += 4, o != null && (A[e++] = 20, A[e++] = t.os), A[e] = 20, e += 2, A[e++] = t.flag << 1 | (i < 0 && 8), A[e++] = n && 8, A[e++] = t.compression & 255, A[e++] = t.compression >> 8;
  var g = new Date(t.mtime == null ? Date.now() : t.mtime), d = g.getFullYear() - 1980;
  if ((d < 0 || d > 119) && Je(10), Ge(A, e, d << 25 | g.getMonth() + 1 << 21 | g.getDate() << 16 | g.getHours() << 11 | g.getMinutes() << 5 | g.getSeconds() >> 1), e += 4, i != -1 && (Ge(A, e, t.crc), Ge(A, e + 4, i < 0 ? -i - 2 : i), Ge(A, e + 8, t.size)), Ge(A, e + 12, a), Ge(A, e + 14, h), e += 16, o != null && (Ge(A, e, l), Ge(A, e + 6, t.attrs), Ge(A, e + 10, o), e += 14), A.set(s, e), e += a, h)
    for (var f in c) {
      var I = c[f], m = I.length;
      Ge(A, e, +f), Ge(A, e + 2, m), A.set(I, e + 4), e += 4 + m;
    }
  return l && (A.set(r, e), e += l), e;
}, Nc = function(A, e, t, s, n) {
  Ge(A, e, 101010256), Ge(A, e + 8, t), Ge(A, e + 10, t), Ge(A, e + 12, s), Ge(A, e + 16, n);
};
function kh(A, e) {
  e || (e = {});
  var t = {}, s = [];
  Sr(A, "", t, e);
  var n = 0, i = 0;
  for (var o in t) {
    var r = t[o], a = r[0], c = r[1], l = c.level == 0 ? 0 : 8, h = io(o), g = h.length, d = c.comment, f = d && io(d), I = f && f.length, m = li(c.extra);
    g > 65535 && Je(11);
    var C = l ? Fc(a, c) : a, w = C.length, b = Rc();
    b.p(a), s.push(xr(c, {
      size: a.length,
      crc: b.d(),
      c: C,
      f: h,
      m: f,
      u: g != o.length || f && d.length != I,
      o: n,
      compression: l
    })), n += 30 + g + m + w, i += 76 + 2 * (g + m) + (I || 0) + w;
  }
  for (var B = new Re(i + 22), Q = n, D = i - n, R = 0; R < s.length; ++R) {
    var h = s[R];
    oo(B, h.o, h, h.f, h.u, h.c.length);
    var x = 30 + h.f.length + li(h.extra);
    B.set(h.c, h.o + x), oo(B, n, h, h.f, h.u, h.c.length, h.o, h.m), n += 16 + x + (h.m ? h.m.length : 0);
  }
  return Nc(B, n, s.length, D, Q), B;
}
class Uc extends Ko {
  constructor(e) {
    super(e), this.type = We;
  }
  parse(e) {
    const T = Math.pow(2.7182818, 2.2);
    function U(u, p) {
      let E = 0;
      for (let v = 0; v < 65536; ++v)
        (v == 0 || u[v >> 3] & 1 << (v & 7)) && (p[E++] = v);
      const y = E - 1;
      for (; E < 65536; ) p[E++] = 0;
      return y;
    }
    function L(u) {
      for (let p = 0; p < 16384; p++)
        u[p] = {}, u[p].len = 0, u[p].lit = 0, u[p].p = null;
    }
    const H = { l: 0, c: 0, lc: 0 };
    function Z(u, p, E, y, v) {
      for (; E < u; )
        p = p << 8 | vi(y, v), E += 8;
      E -= u, H.l = p >> E & (1 << u) - 1, H.c = p, H.lc = E;
    }
    const N = new Array(59);
    function K(u) {
      for (let E = 0; E <= 58; ++E) N[E] = 0;
      for (let E = 0; E < 65537; ++E) N[u[E]] += 1;
      let p = 0;
      for (let E = 58; E > 0; --E) {
        const y = p + N[E] >> 1;
        N[E] = p, p = y;
      }
      for (let E = 0; E < 65537; ++E) {
        const y = u[E];
        y > 0 && (u[E] = y | N[y]++ << 6);
      }
    }
    function O(u, p, E, y, v, S) {
      const F = p;
      let G = 0, k = 0;
      for (; y <= v; y++) {
        if (F.value - p.value > E) return !1;
        Z(6, G, k, u, F);
        const M = H.l;
        if (G = H.c, k = H.lc, S[y] = M, M == 63) {
          if (F.value - p.value > E)
            throw new Error("Something wrong with hufUnpackEncTable");
          Z(8, G, k, u, F);
          let _ = H.l + 6;
          if (G = H.c, k = H.lc, y + _ > v + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; _--; ) S[y++] = 0;
          y--;
        } else if (M >= 59) {
          let _ = M - 59 + 2;
          if (y + _ > v + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; _--; ) S[y++] = 0;
          y--;
        }
      }
      K(S);
    }
    function $(u) {
      return u & 63;
    }
    function oe(u) {
      return u >> 6;
    }
    function te(u, p, E, y) {
      for (; p <= E; p++) {
        const v = oe(u[p]), S = $(u[p]);
        if (v >> S)
          throw new Error("Invalid table entry");
        if (S > 14) {
          const F = y[v >> S - 14];
          if (F.len)
            throw new Error("Invalid table entry");
          if (F.lit++, F.p) {
            const G = F.p;
            F.p = new Array(F.lit);
            for (let k = 0; k < F.lit - 1; ++k)
              F.p[k] = G[k];
          } else
            F.p = new Array(1);
          F.p[F.lit - 1] = p;
        } else if (S) {
          let F = 0;
          for (let G = 1 << 14 - S; G > 0; G--) {
            const k = y[(v << 14 - S) + F];
            if (k.len || k.p)
              throw new Error("Invalid table entry");
            k.len = S, k.lit = p, F++;
          }
        }
      }
      return !0;
    }
    const le = { c: 0, lc: 0 };
    function ne(u, p, E, y) {
      u = u << 8 | vi(E, y), p += 8, le.c = u, le.lc = p;
    }
    const X = { c: 0, lc: 0 };
    function ie(u, p, E, y, v, S, F, G, k) {
      if (u == p) {
        y < 8 && (ne(E, y, v, S), E = le.c, y = le.lc), y -= 8;
        let M = E >> y;
        if (M = new Uint8Array([M])[0], G.value + M > k)
          return !1;
        const _ = F[G.value - 1];
        for (; M-- > 0; )
          F[G.value++] = _;
      } else if (G.value < k)
        F[G.value++] = u;
      else
        return !1;
      X.c = E, X.lc = y;
    }
    function fe(u) {
      return u & 65535;
    }
    function be(u) {
      const p = fe(u);
      return p > 32767 ? p - 65536 : p;
    }
    const ce = { a: 0, b: 0 };
    function Ze(u, p) {
      const E = be(u), v = be(p), S = E + (v & 1) + (v >> 1), F = S, G = S - v;
      ce.a = F, ce.b = G;
    }
    function $e(u, p) {
      const E = fe(u), y = fe(p), v = E - (y >> 1) & 65535, S = y + v - 32768 & 65535;
      ce.a = S, ce.b = v;
    }
    function rn(u, p, E, y, v, S, F) {
      const G = F < 16384, k = E > v ? v : E;
      let M = 1, _, j;
      for (; M <= k; ) M <<= 1;
      for (M >>= 1, _ = M, M >>= 1; M >= 1; ) {
        j = 0;
        const V = j + S * (v - _), z = S * M, ee = S * _, Y = y * M, W = y * _;
        let se, Ie, xe, tt;
        for (; j <= V; j += ee) {
          let Ce = j;
          const he = j + y * (E - _);
          for (; Ce <= he; Ce += W) {
            const _e = Ce + Y, ct = Ce + z, ke = ct + Y;
            G ? (Ze(u[Ce + p], u[ct + p]), se = ce.a, xe = ce.b, Ze(u[_e + p], u[ke + p]), Ie = ce.a, tt = ce.b, Ze(se, Ie), u[Ce + p] = ce.a, u[_e + p] = ce.b, Ze(xe, tt), u[ct + p] = ce.a, u[ke + p] = ce.b) : ($e(u[Ce + p], u[ct + p]), se = ce.a, xe = ce.b, $e(u[_e + p], u[ke + p]), Ie = ce.a, tt = ce.b, $e(se, Ie), u[Ce + p] = ce.a, u[_e + p] = ce.b, $e(xe, tt), u[ct + p] = ce.a, u[ke + p] = ce.b);
          }
          if (E & M) {
            const _e = Ce + z;
            G ? Ze(u[Ce + p], u[_e + p]) : $e(u[Ce + p], u[_e + p]), se = ce.a, u[_e + p] = ce.b, u[Ce + p] = se;
          }
        }
        if (v & M) {
          let Ce = j;
          const he = j + y * (E - _);
          for (; Ce <= he; Ce += W) {
            const _e = Ce + Y;
            G ? Ze(u[Ce + p], u[_e + p]) : $e(u[Ce + p], u[_e + p]), se = ce.a, u[_e + p] = ce.b, u[Ce + p] = se;
          }
        }
        _ = M, M >>= 1;
      }
      return j;
    }
    function an(u, p, E, y, v, S, F, G, k) {
      let M = 0, _ = 0;
      const j = F, V = Math.trunc(y.value + (v + 7) / 8);
      for (; y.value < V; )
        for (ne(M, _, E, y), M = le.c, _ = le.lc; _ >= 14; ) {
          const ee = M >> _ - 14 & 16383, Y = p[ee];
          if (Y.len)
            _ -= Y.len, ie(Y.lit, S, M, _, E, y, G, k, j), M = X.c, _ = X.lc;
          else {
            if (!Y.p)
              throw new Error("hufDecode issues");
            let W;
            for (W = 0; W < Y.lit; W++) {
              const se = $(u[Y.p[W]]);
              for (; _ < se && y.value < V; )
                ne(M, _, E, y), M = le.c, _ = le.lc;
              if (_ >= se && oe(u[Y.p[W]]) == (M >> _ - se & (1 << se) - 1)) {
                _ -= se, ie(Y.p[W], S, M, _, E, y, G, k, j), M = X.c, _ = X.lc;
                break;
              }
            }
            if (W == Y.lit)
              throw new Error("hufDecode issues");
          }
        }
      const z = 8 - v & 7;
      for (M >>= z, _ -= z; _ > 0; ) {
        const ee = p[M << 14 - _ & 16383];
        if (ee.len)
          _ -= ee.len, ie(ee.lit, S, M, _, E, y, G, k, j), M = X.c, _ = X.lc;
        else
          throw new Error("hufDecode issues");
      }
      return !0;
    }
    function Ut(u, p, E, y, v, S) {
      const F = { value: 0 }, G = E.value, k = At(p, E), M = At(p, E);
      E.value += 4;
      const _ = At(p, E);
      if (E.value += 4, k < 0 || k >= 65537 || M < 0 || M >= 65537)
        throw new Error("Something wrong with HUF_ENCSIZE");
      const j = new Array(65537), V = new Array(16384);
      L(V);
      const z = y - (E.value - G);
      if (O(u, E, z, k, M, j), _ > 8 * (y - (E.value - G)))
        throw new Error("Something wrong with hufUncompress");
      te(j, k, M, V), an(j, V, u, E, _, M, S, v, F);
    }
    function Kt(u, p, E) {
      for (let y = 0; y < E; ++y)
        p[y] = u[p[y]];
    }
    function vt(u) {
      for (let p = 1; p < u.length; p++) {
        const E = u[p - 1] + u[p] - 128;
        u[p] = E;
      }
    }
    function An(u, p) {
      let E = 0, y = Math.floor((u.length + 1) / 2), v = 0;
      const S = u.length - 1;
      for (; !(v > S || (p[v++] = u[E++], v > S)); )
        p[v++] = u[y++];
    }
    function Si(u) {
      let p = u.byteLength;
      const E = new Array();
      let y = 0;
      const v = new DataView(u);
      for (; p > 0; ) {
        const S = v.getInt8(y++);
        if (S < 0) {
          const F = -S;
          p -= F + 1;
          for (let G = 0; G < F; G++)
            E.push(v.getUint8(y++));
        } else {
          const F = S;
          p -= 2;
          const G = v.getUint8(y++);
          for (let k = 0; k < F + 1; k++)
            E.push(G);
        }
      }
      return E;
    }
    function Ur(u, p, E, y, v, S) {
      let F = new DataView(S.buffer);
      const G = E[u.idx[0]].width, k = E[u.idx[0]].height, M = 3, _ = Math.floor(G / 8), j = Math.ceil(G / 8), V = Math.ceil(k / 8), z = G - (j - 1) * 8, ee = k - (V - 1) * 8, Y = { value: 0 }, W = new Array(M), se = new Array(M), Ie = new Array(M), xe = new Array(M), tt = new Array(M);
      for (let he = 0; he < M; ++he)
        tt[he] = p[u.idx[he]], W[he] = he < 1 ? 0 : W[he - 1] + j * V, se[he] = new Float32Array(64), Ie[he] = new Uint16Array(64), xe[he] = new Uint16Array(j * 64);
      for (let he = 0; he < V; ++he) {
        let _e = 8;
        he == V - 1 && (_e = ee);
        let ct = 8;
        for (let pe = 0; pe < j; ++pe) {
          pe == j - 1 && (ct = z);
          for (let Ee = 0; Ee < M; ++Ee)
            Ie[Ee].fill(0), Ie[Ee][0] = v[W[Ee]++], Gr(Y, y, Ie[Ee]), Pr(Ie[Ee], se[Ee]), Or(se[Ee]);
          Hr(se);
          for (let Ee = 0; Ee < M; ++Ee)
            jr(se[Ee], xe[Ee], pe * 64);
        }
        let ke = 0;
        for (let pe = 0; pe < M; ++pe) {
          const Ee = E[u.idx[pe]].type;
          for (let Dt = 8 * he; Dt < 8 * he + _e; ++Dt) {
            ke = tt[pe][Dt];
            for (let En = 0; En < _; ++En) {
              const Et = En * 64 + (Dt & 7) * 8;
              F.setUint16(ke + 0 * Ee, xe[pe][Et + 0], !0), F.setUint16(ke + 2 * Ee, xe[pe][Et + 1], !0), F.setUint16(ke + 4 * Ee, xe[pe][Et + 2], !0), F.setUint16(ke + 6 * Ee, xe[pe][Et + 3], !0), F.setUint16(ke + 8 * Ee, xe[pe][Et + 4], !0), F.setUint16(ke + 10 * Ee, xe[pe][Et + 5], !0), F.setUint16(ke + 12 * Ee, xe[pe][Et + 6], !0), F.setUint16(ke + 14 * Ee, xe[pe][Et + 7], !0), ke += 16 * Ee;
            }
          }
          if (_ != j)
            for (let Dt = 8 * he; Dt < 8 * he + _e; ++Dt) {
              const En = tt[pe][Dt] + 8 * _ * 2 * Ee, Et = _ * 64 + (Dt & 7) * 8;
              for (let zn = 0; zn < ct; ++zn)
                F.setUint16(En + zn * 2 * Ee, xe[pe][Et + zn], !0);
            }
        }
      }
      const Ce = new Uint16Array(G);
      F = new DataView(S.buffer);
      for (let he = 0; he < M; ++he) {
        E[u.idx[he]].decoded = !0;
        const _e = E[u.idx[he]].type;
        if (E[he].type == 2)
          for (let ct = 0; ct < k; ++ct) {
            const ke = tt[he][ct];
            for (let pe = 0; pe < G; ++pe)
              Ce[pe] = F.getUint16(ke + pe * 2 * _e, !0);
            for (let pe = 0; pe < G; ++pe)
              F.setFloat32(ke + pe * 2 * _e, J(Ce[pe]), !0);
          }
      }
    }
    function Gr(u, p, E) {
      let y, v = 1;
      for (; v < 64; )
        y = p[u.value], y == 65280 ? v = 64 : y >> 8 == 255 ? v += y & 255 : (E[v] = y, v++), u.value++;
    }
    function Pr(u, p) {
      p[0] = J(u[0]), p[1] = J(u[1]), p[2] = J(u[5]), p[3] = J(u[6]), p[4] = J(u[14]), p[5] = J(u[15]), p[6] = J(u[27]), p[7] = J(u[28]), p[8] = J(u[2]), p[9] = J(u[4]), p[10] = J(u[7]), p[11] = J(u[13]), p[12] = J(u[16]), p[13] = J(u[26]), p[14] = J(u[29]), p[15] = J(u[42]), p[16] = J(u[3]), p[17] = J(u[8]), p[18] = J(u[12]), p[19] = J(u[17]), p[20] = J(u[25]), p[21] = J(u[30]), p[22] = J(u[41]), p[23] = J(u[43]), p[24] = J(u[9]), p[25] = J(u[11]), p[26] = J(u[18]), p[27] = J(u[24]), p[28] = J(u[31]), p[29] = J(u[40]), p[30] = J(u[44]), p[31] = J(u[53]), p[32] = J(u[10]), p[33] = J(u[19]), p[34] = J(u[23]), p[35] = J(u[32]), p[36] = J(u[39]), p[37] = J(u[45]), p[38] = J(u[52]), p[39] = J(u[54]), p[40] = J(u[20]), p[41] = J(u[22]), p[42] = J(u[33]), p[43] = J(u[38]), p[44] = J(u[46]), p[45] = J(u[51]), p[46] = J(u[55]), p[47] = J(u[60]), p[48] = J(u[21]), p[49] = J(u[34]), p[50] = J(u[37]), p[51] = J(u[47]), p[52] = J(u[50]), p[53] = J(u[56]), p[54] = J(u[59]), p[55] = J(u[61]), p[56] = J(u[35]), p[57] = J(u[36]), p[58] = J(u[48]), p[59] = J(u[49]), p[60] = J(u[57]), p[61] = J(u[58]), p[62] = J(u[62]), p[63] = J(u[63]);
    }
    function Or(u) {
      const p = 0.5 * Math.cos(0.7853975), E = 0.5 * Math.cos(3.14159 / 16), y = 0.5 * Math.cos(3.14159 / 8), v = 0.5 * Math.cos(3 * 3.14159 / 16), S = 0.5 * Math.cos(5 * 3.14159 / 16), F = 0.5 * Math.cos(3 * 3.14159 / 8), G = 0.5 * Math.cos(7 * 3.14159 / 16), k = new Array(4), M = new Array(4), _ = new Array(4), j = new Array(4);
      for (let V = 0; V < 8; ++V) {
        const z = V * 8;
        k[0] = y * u[z + 2], k[1] = F * u[z + 2], k[2] = y * u[z + 6], k[3] = F * u[z + 6], M[0] = E * u[z + 1] + v * u[z + 3] + S * u[z + 5] + G * u[z + 7], M[1] = v * u[z + 1] - G * u[z + 3] - E * u[z + 5] - S * u[z + 7], M[2] = S * u[z + 1] - E * u[z + 3] + G * u[z + 5] + v * u[z + 7], M[3] = G * u[z + 1] - S * u[z + 3] + v * u[z + 5] - E * u[z + 7], _[0] = p * (u[z + 0] + u[z + 4]), _[3] = p * (u[z + 0] - u[z + 4]), _[1] = k[0] + k[3], _[2] = k[1] - k[2], j[0] = _[0] + _[1], j[1] = _[3] + _[2], j[2] = _[3] - _[2], j[3] = _[0] - _[1], u[z + 0] = j[0] + M[0], u[z + 1] = j[1] + M[1], u[z + 2] = j[2] + M[2], u[z + 3] = j[3] + M[3], u[z + 4] = j[3] - M[3], u[z + 5] = j[2] - M[2], u[z + 6] = j[1] - M[1], u[z + 7] = j[0] - M[0];
      }
      for (let V = 0; V < 8; ++V)
        k[0] = y * u[16 + V], k[1] = F * u[16 + V], k[2] = y * u[48 + V], k[3] = F * u[48 + V], M[0] = E * u[8 + V] + v * u[24 + V] + S * u[40 + V] + G * u[56 + V], M[1] = v * u[8 + V] - G * u[24 + V] - E * u[40 + V] - S * u[56 + V], M[2] = S * u[8 + V] - E * u[24 + V] + G * u[40 + V] + v * u[56 + V], M[3] = G * u[8 + V] - S * u[24 + V] + v * u[40 + V] - E * u[56 + V], _[0] = p * (u[V] + u[32 + V]), _[3] = p * (u[V] - u[32 + V]), _[1] = k[0] + k[3], _[2] = k[1] - k[2], j[0] = _[0] + _[1], j[1] = _[3] + _[2], j[2] = _[3] - _[2], j[3] = _[0] - _[1], u[0 + V] = j[0] + M[0], u[8 + V] = j[1] + M[1], u[16 + V] = j[2] + M[2], u[24 + V] = j[3] + M[3], u[32 + V] = j[3] - M[3], u[40 + V] = j[2] - M[2], u[48 + V] = j[1] - M[1], u[56 + V] = j[0] - M[0];
    }
    function Hr(u) {
      for (let p = 0; p < 64; ++p) {
        const E = u[0][p], y = u[1][p], v = u[2][p];
        u[0][p] = E + 1.5747 * v, u[1][p] = E - 0.1873 * y - 0.4682 * v, u[2][p] = E + 1.8556 * y;
      }
    }
    function jr(u, p, E) {
      for (let y = 0; y < 64; ++y)
        p[E + y] = dn.toHalfFloat(qr(u[y]));
    }
    function qr(u) {
      return u <= 1 ? Math.sign(u) * Math.pow(Math.abs(u), 2.2) : Math.sign(u) * Math.pow(T, Math.abs(u) - 1);
    }
    function Is(u) {
      return new DataView(u.array.buffer, u.offset.value, u.size);
    }
    function zr(u) {
      const p = u.viewer.buffer.slice(u.offset.value, u.offset.value + u.size), E = new Uint8Array(Si(p)), y = new Uint8Array(E.length);
      return vt(E), An(E, y), new DataView(y.buffer);
    }
    function ms(u) {
      const p = u.array.slice(u.offset.value, u.offset.value + u.size), E = Ln(p), y = new Uint8Array(E.length);
      return vt(E), An(E, y), new DataView(y.buffer);
    }
    function Yr(u) {
      const p = u.viewer, E = { value: u.offset.value }, y = new Uint16Array(u.columns * u.lines * (u.inputChannels.length * u.type)), v = new Uint8Array(8192);
      let S = 0;
      const F = new Array(u.inputChannels.length);
      for (let ee = 0, Y = u.inputChannels.length; ee < Y; ee++)
        F[ee] = {}, F[ee].start = S, F[ee].end = F[ee].start, F[ee].nx = u.columns, F[ee].ny = u.lines, F[ee].size = u.type, S += F[ee].nx * F[ee].ny * F[ee].size;
      const G = mn(p, E), k = mn(p, E);
      if (k >= 8192)
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      if (G <= k)
        for (let ee = 0; ee < k - G + 1; ee++)
          v[ee + G] = Gt(p, E);
      const M = new Uint16Array(65536), _ = U(v, M), j = At(p, E);
      Ut(u.array, p, E, j, y, S);
      for (let ee = 0; ee < u.inputChannels.length; ++ee) {
        const Y = F[ee];
        for (let W = 0; W < F[ee].size; ++W)
          rn(
            y,
            Y.start + W,
            Y.nx,
            Y.size,
            Y.ny,
            Y.nx * Y.size,
            _
          );
      }
      Kt(M, y, S);
      let V = 0;
      const z = new Uint8Array(y.buffer.byteLength);
      for (let ee = 0; ee < u.lines; ee++)
        for (let Y = 0; Y < u.inputChannels.length; Y++) {
          const W = F[Y], se = W.nx * W.size, Ie = new Uint8Array(y.buffer, W.end * 2, se * 2);
          z.set(Ie, V), V += se * 2, W.end += se;
        }
      return new DataView(z.buffer);
    }
    function Kr(u) {
      const p = u.array.slice(u.offset.value, u.offset.value + u.size), E = Ln(p), y = u.inputChannels.length * u.lines * u.columns * u.totalBytes, v = new ArrayBuffer(y), S = new DataView(v);
      let F = 0, G = 0;
      const k = new Array(4);
      for (let M = 0; M < u.lines; M++)
        for (let _ = 0; _ < u.inputChannels.length; _++) {
          let j = 0;
          switch (u.inputChannels[_].pixelType) {
            case 1:
              k[0] = F, k[1] = k[0] + u.columns, F = k[1] + u.columns;
              for (let z = 0; z < u.columns; ++z) {
                const ee = E[k[0]++] << 8 | E[k[1]++];
                j += ee, S.setUint16(G, j, !0), G += 2;
              }
              break;
            case 2:
              k[0] = F, k[1] = k[0] + u.columns, k[2] = k[1] + u.columns, F = k[2] + u.columns;
              for (let z = 0; z < u.columns; ++z) {
                const ee = E[k[0]++] << 24 | E[k[1]++] << 16 | E[k[2]++] << 8;
                j += ee, S.setUint32(G, j, !0), G += 4;
              }
              break;
          }
        }
      return S;
    }
    function Ti(u) {
      const p = u.viewer, E = { value: u.offset.value }, y = new Uint8Array(u.columns * u.lines * (u.inputChannels.length * u.type * 2)), v = {
        version: et(p, E),
        unknownUncompressedSize: et(p, E),
        unknownCompressedSize: et(p, E),
        acCompressedSize: et(p, E),
        dcCompressedSize: et(p, E),
        rleCompressedSize: et(p, E),
        rleUncompressedSize: et(p, E),
        rleRawSize: et(p, E),
        totalAcUncompressedCount: et(p, E),
        totalDcUncompressedCount: et(p, E),
        acCompression: et(p, E)
      };
      if (v.version < 2)
        throw new Error("EXRLoader.parse: " + Jt.compression + " version " + v.version + " is unsupported");
      const S = new Array();
      let F = mn(p, E) - 2;
      for (; F > 0; ) {
        const Y = qn(p.buffer, E), W = Gt(p, E), se = W >> 2 & 3, Ie = (W >> 4) - 1, xe = new Int8Array([Ie])[0], tt = Gt(p, E);
        S.push({
          name: Y,
          index: xe,
          type: tt,
          compression: se
        }), F -= Y.length + 3;
      }
      const G = Jt.channels, k = new Array(u.inputChannels.length);
      for (let Y = 0; Y < u.inputChannels.length; ++Y) {
        const W = k[Y] = {}, se = G[Y];
        W.name = se.name, W.compression = 0, W.decoded = !1, W.type = se.pixelType, W.pLinear = se.pLinear, W.width = u.columns, W.height = u.lines;
      }
      const M = {
        idx: new Array(3)
      };
      for (let Y = 0; Y < u.inputChannels.length; ++Y) {
        const W = k[Y];
        for (let se = 0; se < S.length; ++se) {
          const Ie = S[se];
          W.name == Ie.name && (W.compression = Ie.compression, Ie.index >= 0 && (M.idx[Ie.index] = Y), W.offset = Y);
        }
      }
      let _, j, V;
      if (v.acCompressedSize > 0)
        switch (v.acCompression) {
          case 0:
            _ = new Uint16Array(v.totalAcUncompressedCount), Ut(u.array, p, E, v.acCompressedSize, _, v.totalAcUncompressedCount);
            break;
          case 1:
            const Y = u.array.slice(E.value, E.value + v.totalAcUncompressedCount), W = Ln(Y);
            _ = new Uint16Array(W.buffer), E.value += v.totalAcUncompressedCount;
            break;
        }
      if (v.dcCompressedSize > 0) {
        const Y = {
          array: u.array,
          offset: E,
          size: v.dcCompressedSize
        };
        j = new Uint16Array(ms(Y).buffer), E.value += v.dcCompressedSize;
      }
      if (v.rleRawSize > 0) {
        const Y = u.array.slice(E.value, E.value + v.rleCompressedSize), W = Ln(Y);
        V = Si(W.buffer), E.value += v.rleCompressedSize;
      }
      let z = 0;
      const ee = new Array(k.length);
      for (let Y = 0; Y < ee.length; ++Y)
        ee[Y] = new Array();
      for (let Y = 0; Y < u.lines; ++Y)
        for (let W = 0; W < k.length; ++W)
          ee[W].push(z), z += k[W].width * u.type * 2;
      Ur(M, ee, k, _, j, y);
      for (let Y = 0; Y < k.length; ++Y) {
        const W = k[Y];
        if (!W.decoded)
          switch (W.compression) {
            case 2:
              let se = 0, Ie = 0;
              for (let xe = 0; xe < u.lines; ++xe) {
                let tt = ee[Y][se];
                for (let Ce = 0; Ce < W.width; ++Ce) {
                  for (let he = 0; he < 2 * W.type; ++he)
                    y[tt++] = V[Ie + he * W.width * W.height];
                  Ie++;
                }
                se++;
              }
              break;
            case 1:
            // skip
            default:
              throw new Error("EXRLoader.parse: unsupported channel compression");
          }
      }
      return new DataView(y.buffer);
    }
    function qn(u, p) {
      const E = new Uint8Array(u);
      let y = 0;
      for (; E[p.value + y] != 0; )
        y += 1;
      const v = new TextDecoder().decode(
        E.slice(p.value, p.value + y)
      );
      return p.value = p.value + y + 1, v;
    }
    function Jr(u, p, E) {
      const y = new TextDecoder().decode(
        new Uint8Array(u).slice(p.value, p.value + E)
      );
      return p.value = p.value + E, y;
    }
    function Vr(u, p) {
      const E = at(u, p), y = At(u, p);
      return [E, y];
    }
    function Wr(u, p) {
      const E = At(u, p), y = At(u, p);
      return [E, y];
    }
    function at(u, p) {
      const E = u.getInt32(p.value, !0);
      return p.value = p.value + 4, E;
    }
    function At(u, p) {
      const E = u.getUint32(p.value, !0);
      return p.value = p.value + 4, E;
    }
    function vi(u, p) {
      const E = u[p.value];
      return p.value = p.value + 1, E;
    }
    function Gt(u, p) {
      const E = u.getUint8(p.value);
      return p.value = p.value + 1, E;
    }
    const et = function(u, p) {
      let E;
      return "getBigInt64" in DataView.prototype ? E = Number(u.getBigInt64(p.value, !0)) : E = u.getUint32(p.value + 4, !0) + Number(u.getUint32(p.value, !0) << 32), p.value += 8, E;
    };
    function Oe(u, p) {
      const E = u.getFloat32(p.value, !0);
      return p.value += 4, E;
    }
    function Xr(u, p) {
      return dn.toHalfFloat(Oe(u, p));
    }
    function J(u) {
      const p = (u & 31744) >> 10, E = u & 1023;
      return (u >> 15 ? -1 : 1) * (p ? p === 31 ? E ? NaN : 1 / 0 : Math.pow(2, p - 15) * (1 + E / 1024) : 6103515625e-14 * (E / 1024));
    }
    function mn(u, p) {
      const E = u.getUint16(p.value, !0);
      return p.value += 2, E;
    }
    function Zr(u, p) {
      return J(mn(u, p));
    }
    function $r(u, p, E, y) {
      const v = E.value, S = [];
      for (; E.value < v + y - 1; ) {
        const F = qn(p, E), G = at(u, E), k = Gt(u, E);
        E.value += 3;
        const M = at(u, E), _ = at(u, E);
        S.push({
          name: F,
          pixelType: G,
          pLinear: k,
          xSampling: M,
          ySampling: _
        });
      }
      return E.value += 1, S;
    }
    function ea(u, p) {
      const E = Oe(u, p), y = Oe(u, p), v = Oe(u, p), S = Oe(u, p), F = Oe(u, p), G = Oe(u, p), k = Oe(u, p), M = Oe(u, p);
      return { redX: E, redY: y, greenX: v, greenY: S, blueX: F, blueY: G, whiteX: k, whiteY: M };
    }
    function ta(u, p) {
      const E = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], y = Gt(u, p);
      return E[y];
    }
    function na(u, p) {
      const E = at(u, p), y = at(u, p), v = at(u, p), S = at(u, p);
      return { xMin: E, yMin: y, xMax: v, yMax: S };
    }
    function sa(u, p) {
      const E = [
        "INCREASING_Y",
        "DECREASING_Y",
        "RANDOM_Y"
      ], y = Gt(u, p);
      return E[y];
    }
    function ia(u, p) {
      const E = [
        "ENVMAP_LATLONG",
        "ENVMAP_CUBE"
      ], y = Gt(u, p);
      return E[y];
    }
    function oa(u, p) {
      const E = [
        "ONE_LEVEL",
        "MIPMAP_LEVELS",
        "RIPMAP_LEVELS"
      ], y = [
        "ROUND_DOWN",
        "ROUND_UP"
      ], v = At(u, p), S = At(u, p), F = Gt(u, p);
      return {
        xSize: v,
        ySize: S,
        levelMode: E[F & 15],
        roundingMode: y[F >> 4]
      };
    }
    function ra(u, p) {
      const E = Oe(u, p), y = Oe(u, p);
      return [E, y];
    }
    function aa(u, p) {
      const E = Oe(u, p), y = Oe(u, p), v = Oe(u, p);
      return [E, y, v];
    }
    function Aa(u, p, E, y, v) {
      if (y === "string" || y === "stringvector" || y === "iccProfile")
        return Jr(p, E, v);
      if (y === "chlist")
        return $r(u, p, E, v);
      if (y === "chromaticities")
        return ea(u, E);
      if (y === "compression")
        return ta(u, E);
      if (y === "box2i")
        return na(u, E);
      if (y === "envmap")
        return ia(u, E);
      if (y === "tiledesc")
        return oa(u, E);
      if (y === "lineOrder")
        return sa(u, E);
      if (y === "float")
        return Oe(u, E);
      if (y === "v2f")
        return ra(u, E);
      if (y === "v3f")
        return aa(u, E);
      if (y === "int")
        return at(u, E);
      if (y === "rational")
        return Vr(u, E);
      if (y === "timecode")
        return Wr(u, E);
      if (y === "preview")
        return E.value += v, "skipped";
      E.value += v;
    }
    function ca(u, p) {
      const E = Math.log2(u);
      return p == "ROUND_DOWN" ? Math.floor(E) : Math.ceil(E);
    }
    function la(u, p, E) {
      let y = 0;
      switch (u.levelMode) {
        case "ONE_LEVEL":
          y = 1;
          break;
        case "MIPMAP_LEVELS":
          y = ca(Math.max(p, E), u.roundingMode) + 1;
          break;
        case "RIPMAP_LEVELS":
          throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.");
      }
      return y;
    }
    function Di(u, p, E, y) {
      const v = new Array(u);
      for (let S = 0; S < u; S++) {
        const F = 1 << S;
        let G = p / F | 0;
        y == "ROUND_UP" && G * F < p && (G += 1);
        const k = Math.max(G, 1);
        v[S] = (k + E - 1) / E | 0;
      }
      return v;
    }
    function ha() {
      const u = this, p = u.offset, E = { value: 0 };
      for (let y = 0; y < u.tileCount; y++) {
        const v = at(u.viewer, p), S = at(u.viewer, p);
        p.value += 8, u.size = At(u.viewer, p);
        const F = v * u.blockWidth, G = S * u.blockHeight;
        u.columns = F + u.blockWidth > u.width ? u.width - F : u.blockWidth, u.lines = G + u.blockHeight > u.height ? u.height - G : u.blockHeight;
        const k = u.columns * u.totalBytes, _ = u.size < u.lines * k ? u.uncompress(u) : Is(u);
        p.value += u.size;
        for (let j = 0; j < u.lines; j++) {
          const V = j * u.columns * u.totalBytes;
          for (let z = 0; z < u.inputChannels.length; z++) {
            const ee = Jt.channels[z].name, Y = u.channelByteOffsets[ee] * u.columns, W = u.decodeChannels[ee];
            if (W === void 0) continue;
            E.value = V + Y;
            const se = (u.height - (1 + G + j)) * u.outLineWidth;
            for (let Ie = 0; Ie < u.columns; Ie++) {
              const xe = se + (Ie + F) * u.outputChannels + W;
              u.byteArray[xe] = u.getter(_, E);
            }
          }
        }
      }
    }
    function ua() {
      const u = this, p = u.offset, E = { value: 0 };
      for (let y = 0; y < u.height / u.blockHeight; y++) {
        const v = at(u.viewer, p) - Jt.dataWindow.yMin;
        u.size = At(u.viewer, p), u.lines = v + u.blockHeight > u.height ? u.height - v : u.blockHeight;
        const S = u.columns * u.totalBytes, G = u.size < u.lines * S ? u.uncompress(u) : Is(u);
        p.value += u.size;
        for (let k = 0; k < u.blockHeight; k++) {
          const M = y * u.blockHeight, _ = k + u.scanOrder(M);
          if (_ >= u.height) continue;
          const j = k * S, V = (u.height - 1 - _) * u.outLineWidth;
          for (let z = 0; z < u.inputChannels.length; z++) {
            const ee = Jt.channels[z].name, Y = u.channelByteOffsets[ee] * u.columns, W = u.decodeChannels[ee];
            if (W !== void 0) {
              E.value = j + Y;
              for (let se = 0; se < u.columns; se++) {
                const Ie = V + se * u.outputChannels + W;
                u.byteArray[Ie] = u.getter(G, E);
              }
            }
          }
        }
      }
    }
    function ga(u, p, E) {
      const y = {};
      if (u.getUint32(0, !0) != 20000630)
        throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
      y.version = u.getUint8(4);
      const v = u.getUint8(5);
      y.spec = {
        singleTile: !!(v & 2),
        longName: !!(v & 4),
        deepFormat: !!(v & 8),
        multiPart: !!(v & 16)
      }, E.value = 8;
      let S = !0;
      for (; S; ) {
        const F = qn(p, E);
        if (F == 0)
          S = !1;
        else {
          const G = qn(p, E), k = At(u, E), M = Aa(u, p, E, G, k);
          M === void 0 ? console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${G}'.`) : y[F] = M;
        }
      }
      if ((v & -7) != 0)
        throw console.error("THREE.EXRHeader:", y), new Error("THREE.EXRLoader: Provided file is currently unsupported.");
      return y;
    }
    function da(u, p, E, y, v) {
      const S = {
        size: 0,
        viewer: p,
        array: E,
        offset: y,
        width: u.dataWindow.xMax - u.dataWindow.xMin + 1,
        height: u.dataWindow.yMax - u.dataWindow.yMin + 1,
        inputChannels: u.channels,
        channelByteOffsets: {},
        scanOrder: null,
        totalBytes: null,
        columns: null,
        lines: null,
        type: null,
        uncompress: null,
        getter: null,
        format: null,
        colorSpace: Xe
      };
      switch (u.compression) {
        case "NO_COMPRESSION":
          S.blockHeight = 1, S.uncompress = Is;
          break;
        case "RLE_COMPRESSION":
          S.blockHeight = 1, S.uncompress = zr;
          break;
        case "ZIPS_COMPRESSION":
          S.blockHeight = 1, S.uncompress = ms;
          break;
        case "ZIP_COMPRESSION":
          S.blockHeight = 16, S.uncompress = ms;
          break;
        case "PIZ_COMPRESSION":
          S.blockHeight = 32, S.uncompress = Yr;
          break;
        case "PXR24_COMPRESSION":
          S.blockHeight = 16, S.uncompress = Kr;
          break;
        case "DWAA_COMPRESSION":
          S.blockHeight = 32, S.uncompress = Ti;
          break;
        case "DWAB_COMPRESSION":
          S.blockHeight = 256, S.uncompress = Ti;
          break;
        default:
          throw new Error("EXRLoader.parse: " + u.compression + " is unsupported");
      }
      const F = {};
      for (const _ of u.channels)
        switch (_.name) {
          case "Y":
          case "R":
          case "G":
          case "B":
          case "A":
            F[_.name] = !0, S.type = _.pixelType;
        }
      let G = !1;
      if (F.R && F.G && F.B)
        G = !F.A, S.outputChannels = 4, S.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };
      else if (F.Y)
        S.outputChannels = 1, S.decodeChannels = { Y: 0 };
      else
        throw new Error("EXRLoader.parse: file contains unsupported data channels.");
      if (S.type == 1)
        switch (v) {
          case mt:
            S.getter = Zr;
            break;
          case We:
            S.getter = mn;
            break;
        }
      else if (S.type == 2)
        switch (v) {
          case mt:
            S.getter = Oe;
            break;
          case We:
            S.getter = Xr;
        }
      else
        throw new Error("EXRLoader.parse: unsupported pixelType " + S.type + " for " + u.compression + ".");
      S.columns = S.width;
      const k = S.width * S.height * S.outputChannels;
      switch (v) {
        case mt:
          S.byteArray = new Float32Array(k), G && S.byteArray.fill(1, 0, k);
          break;
        case We:
          S.byteArray = new Uint16Array(k), G && S.byteArray.fill(15360, 0, k);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", v);
          break;
      }
      let M = 0;
      for (const _ of u.channels)
        S.decodeChannels[_.name] !== void 0 && (S.channelByteOffsets[_.name] = M), M += _.pixelType * 2;
      if (S.totalBytes = M, S.outLineWidth = S.width * S.outputChannels, u.lineOrder === "INCREASING_Y" ? S.scanOrder = (_) => _ : S.scanOrder = (_) => S.height - 1 - _, S.outputChannels == 4 ? (S.format = zt, S.colorSpace = Xe) : (S.format = gn, S.colorSpace = us), u.spec.singleTile) {
        S.blockHeight = u.tiles.ySize, S.blockWidth = u.tiles.xSize;
        const _ = la(u.tiles, S.width, S.height), j = Di(_, S.width, u.tiles.xSize, u.tiles.roundingMode), V = Di(_, S.height, u.tiles.ySize, u.tiles.roundingMode);
        S.tileCount = j[0] * V[0];
        for (let z = 0; z < _; z++)
          for (let ee = 0; ee < V[z]; ee++)
            for (let Y = 0; Y < j[z]; Y++)
              et(p, y);
        S.decode = ha.bind(S);
      } else {
        S.blockWidth = S.width;
        const _ = Math.ceil(S.height / S.blockHeight);
        for (let j = 0; j < _; j++)
          et(p, y);
        S.decode = ua.bind(S);
      }
      return S;
    }
    const Ri = { value: 0 }, _i = new DataView(e), pa = new Uint8Array(e), Jt = ga(_i, e, Ri), cn = da(Jt, _i, pa, Ri, this.type);
    return cn.decode(), {
      header: Jt,
      width: cn.width,
      height: cn.height,
      data: cn.byteArray,
      format: cn.format,
      colorSpace: cn.colorSpace,
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, s, n) {
    function i(o, r) {
      o.colorSpace = r.colorSpace, o.minFilter = rt, o.magFilter = rt, o.generateMipmaps = !1, o.flipY = !1, t && t(o, r);
    }
    return super.load(e, i, s, n);
  }
}
const Lh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EXRLoader: Uc
}, Symbol.toStringTag, { value: "Module" }));
class Gc extends Ko {
  constructor(e) {
    super(e), this.type = We;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const o = function(x, T) {
      switch (x) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (T || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (T || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (T || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (T || ""));
      }
    }, h = function(x, T, U) {
      T = T || 1024;
      let H = x.pos, Z = -1, N = 0, K = "", O = String.fromCharCode.apply(null, new Uint16Array(x.subarray(H, H + 128)));
      for (; 0 > (Z = O.indexOf(`
`)) && N < T && H < x.byteLength; )
        K += O, N += O.length, H += 128, O += String.fromCharCode.apply(null, new Uint16Array(x.subarray(H, H + 128)));
      return -1 < Z ? (x.pos += N + Z + 1, K + O.slice(0, Z)) : !1;
    }, g = function(x) {
      const T = /^#\?(\S+)/, U = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, L = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, H = /^\s*FORMAT=(\S+)\s*$/, Z = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, N = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let K, O;
      for ((x.pos >= x.byteLength || !(K = h(x))) && o(1, "no header found"), (O = K.match(T)) || o(3, "bad initial token"), N.valid |= 1, N.programtype = O[1], N.string += K + `
`; K = h(x), K !== !1; ) {
        if (N.string += K + `
`, K.charAt(0) === "#") {
          N.comments += K + `
`;
          continue;
        }
        if ((O = K.match(U)) && (N.gamma = parseFloat(O[1])), (O = K.match(L)) && (N.exposure = parseFloat(O[1])), (O = K.match(H)) && (N.valid |= 2, N.format = O[1]), (O = K.match(Z)) && (N.valid |= 4, N.height = parseInt(O[1], 10), N.width = parseInt(O[2], 10)), N.valid & 2 && N.valid & 4) break;
      }
      return N.valid & 2 || o(3, "missing format specifier"), N.valid & 4 || o(3, "missing image size specifier"), N;
    }, d = function(x, T, U) {
      const L = T;
      if (
        // run length encoding is not allowed so read flat
        L < 8 || L > 32767 || // this file is not run length encoded
        x[0] !== 2 || x[1] !== 2 || x[2] & 128
      )
        return new Uint8Array(x);
      L !== (x[2] << 8 | x[3]) && o(3, "wrong scanline width");
      const H = new Uint8Array(4 * T * U);
      H.length || o(4, "unable to allocate buffer space");
      let Z = 0, N = 0;
      const K = 4 * L, O = new Uint8Array(4), $ = new Uint8Array(K);
      let oe = U;
      for (; oe > 0 && N < x.byteLength; ) {
        N + 4 > x.byteLength && o(1), O[0] = x[N++], O[1] = x[N++], O[2] = x[N++], O[3] = x[N++], (O[0] != 2 || O[1] != 2 || (O[2] << 8 | O[3]) != L) && o(3, "bad rgbe scanline format");
        let te = 0, le;
        for (; te < K && N < x.byteLength; ) {
          le = x[N++];
          const X = le > 128;
          if (X && (le -= 128), (le === 0 || te + le > K) && o(3, "bad scanline data"), X) {
            const ie = x[N++];
            for (let fe = 0; fe < le; fe++)
              $[te++] = ie;
          } else
            $.set(x.subarray(N, N + le), te), te += le, N += le;
        }
        const ne = L;
        for (let X = 0; X < ne; X++) {
          let ie = 0;
          H[Z] = $[X + ie], ie += L, H[Z + 1] = $[X + ie], ie += L, H[Z + 2] = $[X + ie], ie += L, H[Z + 3] = $[X + ie], Z += 4;
        }
        oe--;
      }
      return H;
    }, f = function(x, T, U, L) {
      const H = x[T + 3], Z = Math.pow(2, H - 128) / 255;
      U[L + 0] = x[T + 0] * Z, U[L + 1] = x[T + 1] * Z, U[L + 2] = x[T + 2] * Z, U[L + 3] = 1;
    }, I = function(x, T, U, L) {
      const H = x[T + 3], Z = Math.pow(2, H - 128) / 255;
      U[L + 0] = dn.toHalfFloat(Math.min(x[T + 0] * Z, 65504)), U[L + 1] = dn.toHalfFloat(Math.min(x[T + 1] * Z, 65504)), U[L + 2] = dn.toHalfFloat(Math.min(x[T + 2] * Z, 65504)), U[L + 3] = dn.toHalfFloat(1);
    }, m = new Uint8Array(e);
    m.pos = 0;
    const C = g(m), w = C.width, b = C.height, B = d(m.subarray(m.pos), w, b);
    let Q, D, R;
    switch (this.type) {
      case mt:
        R = B.length / 4;
        const x = new Float32Array(R * 4);
        for (let U = 0; U < R; U++)
          f(B, U * 4, x, U * 4);
        Q = x, D = mt;
        break;
      case We:
        R = B.length / 4;
        const T = new Uint16Array(R * 4);
        for (let U = 0; U < R; U++)
          I(B, U * 4, T, U * 4);
        Q = T, D = We;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: w,
      height: b,
      data: Q,
      header: C.string,
      gamma: C.gamma,
      exposure: C.exposure,
      type: D
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, s, n) {
    function i(o, r) {
      switch (o.type) {
        case mt:
        case We:
          o.colorSpace = Xe, o.minFilter = rt, o.magFilter = rt, o.generateMipmaps = !1, o.flipY = !0;
          break;
      }
      t && t(o, r);
    }
    return super.load(e, i, s, n);
  }
}
const Nh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RGBELoader: Gc
}, Symbol.toStringTag, { value: "Module" }));
function Tr(A, e, t) {
  const s = t.length - A - 1;
  if (e >= t[s])
    return s - 1;
  if (e <= t[A])
    return A;
  let n = A, i = s, o = Math.floor((n + i) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? i = o : n = o, o = Math.floor((n + i) / 2);
  return o;
}
function Pc(A, e, t, s) {
  const n = [], i = [], o = [];
  n[0] = 1;
  for (let r = 1; r <= t; ++r) {
    i[r] = e - s[A + 1 - r], o[r] = s[A + r] - e;
    let a = 0;
    for (let c = 0; c < r; ++c) {
      const l = o[c + 1], h = i[r - c], g = n[c] / (l + h);
      n[c] = a + l * g, a = h * g;
    }
    n[r] = a;
  }
  return n;
}
function Oc(A, e, t, s) {
  const n = Tr(A, s, e), i = Pc(n, s, A, e), o = new Nt(0, 0, 0, 0);
  for (let r = 0; r <= A; ++r) {
    const a = t[n - A + r], c = i[r], l = a.w * c;
    o.x += a.x * l, o.y += a.y * l, o.z += a.z * l, o.w += a.w * c;
  }
  return o;
}
function Hc(A, e, t, s, n) {
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = 0;
  const o = [];
  for (let h = 0; h <= s; ++h)
    o[h] = i.slice(0);
  const r = [];
  for (let h = 0; h <= t; ++h)
    r[h] = i.slice(0);
  r[0][0] = 1;
  const a = i.slice(0), c = i.slice(0);
  for (let h = 1; h <= t; ++h) {
    a[h] = e - n[A + 1 - h], c[h] = n[A + h] - e;
    let g = 0;
    for (let d = 0; d < h; ++d) {
      const f = c[d + 1], I = a[h - d];
      r[h][d] = f + I;
      const m = r[d][h - 1] / r[h][d];
      r[d][h] = g + f * m, g = I * m;
    }
    r[h][h] = g;
  }
  for (let h = 0; h <= t; ++h)
    o[0][h] = r[h][t];
  for (let h = 0; h <= t; ++h) {
    let g = 0, d = 1;
    const f = [];
    for (let I = 0; I <= t; ++I)
      f[I] = i.slice(0);
    f[0][0] = 1;
    for (let I = 1; I <= s; ++I) {
      let m = 0;
      const C = h - I, w = t - I;
      h >= I && (f[d][0] = f[g][0] / r[w + 1][C], m = f[d][0] * r[C][w]);
      const b = C >= -1 ? 1 : -C, B = h - 1 <= w ? I - 1 : t - h;
      for (let D = b; D <= B; ++D)
        f[d][D] = (f[g][D] - f[g][D - 1]) / r[w + 1][C + D], m += f[d][D] * r[C + D][w];
      h <= w && (f[d][I] = -f[g][I - 1] / r[w + 1][h], m += f[d][I] * r[h][w]), o[I][h] = m;
      const Q = g;
      g = d, d = Q;
    }
  }
  let l = t;
  for (let h = 1; h <= s; ++h) {
    for (let g = 0; g <= t; ++g)
      o[h][g] *= l;
    l *= t - h;
  }
  return o;
}
function jc(A, e, t, s, n) {
  const i = n < A ? n : A, o = [], r = Tr(A, s, e), a = Hc(r, s, A, i, e), c = [];
  for (let l = 0; l < t.length; ++l) {
    const h = t[l].clone(), g = h.w;
    h.x *= g, h.y *= g, h.z *= g, c[l] = h;
  }
  for (let l = 0; l <= i; ++l) {
    const h = c[r - A].clone().multiplyScalar(a[l][0]);
    for (let g = 1; g <= A; ++g)
      h.add(c[r - A + g].clone().multiplyScalar(a[l][g]));
    o[l] = h;
  }
  for (let l = i + 1; l <= n + 1; ++l)
    o[l] = new Nt(0, 0, 0);
  return o;
}
function qc(A, e) {
  let t = 1;
  for (let n = 2; n <= A; ++n)
    t *= n;
  let s = 1;
  for (let n = 2; n <= e; ++n)
    s *= n;
  for (let n = 2; n <= A - e; ++n)
    s *= n;
  return t / s;
}
function zc(A) {
  const e = A.length, t = [], s = [];
  for (let i = 0; i < e; ++i) {
    const o = A[i];
    t[i] = new P(o.x, o.y, o.z), s[i] = o.w;
  }
  const n = [];
  for (let i = 0; i < e; ++i) {
    const o = t[i].clone();
    for (let r = 1; r <= i; ++r)
      o.sub(n[i - r].clone().multiplyScalar(qc(i, r) * s[r]));
    n[i] = o.divideScalar(s[0]);
  }
  return n;
}
function Yc(A, e, t, s, n) {
  const i = jc(A, e, t, s, n);
  return zc(i);
}
class Kc extends Ga {
  constructor(e, t, s, n, i) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = i || this.knots.length - 1;
    for (let o = 0; o < s.length; ++o) {
      const r = s[o];
      this.controlPoints[o] = new Nt(r.x, r.y, r.z, r.w);
    }
  }
  getPoint(e, t = new P()) {
    const s = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = Oc(this.degree, this.knots, this.controlPoints, n);
    return i.w !== 1 && i.divideScalar(i.w), s.set(i.x, i.y, i.z);
  }
  getTangent(e, t = new P()) {
    const s = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = Yc(this.degree, this.knots, this.controlPoints, n, 1);
    return s.copy(i[1]).normalize(), s;
  }
}
let re, De, ze;
class Uh extends kt {
  constructor(e) {
    super(e);
  }
  load(e, t, s, n) {
    const i = this, o = i.path === "" ? tn.extractUrlBase(e) : i.path, r = new It(this.manager);
    r.setPath(i.path), r.setResponseType("arraybuffer"), r.setRequestHeader(i.requestHeader), r.setWithCredentials(i.withCredentials), r.load(e, function(a) {
      try {
        t(i.parse(a, o));
      } catch (c) {
        n ? n(c) : console.error(c), i.manager.itemError(e);
      }
    }, s, n);
  }
  parse(e, t) {
    if ($c(e))
      re = new Zc().parse(e);
    else {
      const n = Rr(e);
      if (!el(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (ao(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + ao(n));
      re = new Xc().parse(n);
    }
    const s = new di(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new Jc(s, this.manager).parse(re);
  }
  getFbxTree() {
    return re;
  }
}
class Jc {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    De = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), s = this.parseMaterials(t), n = this.parseDeformers(), i = new Vc().parse(n);
    return this.parseScene(n, i, s), ze;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in re && re.Connections.connections.forEach(function(s) {
      const n = s[0], i = s[1], o = s[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const r = { ID: i, relationship: o };
      e.get(n).parents.push(r), e.has(i) || e.set(i, {
        parents: [],
        children: []
      });
      const a = { ID: n, relationship: o };
      e.get(i).children.push(a);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in re.Objects) {
      const s = re.Objects.Video;
      for (const n in s) {
        const i = s[n], o = parseInt(n);
        if (e[o] = i.RelativeFilename || i.Filename, "Content" in i) {
          const r = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, a = typeof i.Content == "string" && i.Content !== "";
          if (r || a) {
            const c = this.parseImage(s[n]);
            t[i.RelativeFilename || i.Filename] = c;
          }
        }
      }
    }
    for (const s in e) {
      const n = e[s];
      t[n] !== void 0 ? e[s] = t[n] : e[s] = e[s].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, s = e.RelativeFilename || e.Filename, n = s.slice(s.lastIndexOf(".") + 1).toLowerCase();
    let i;
    switch (n) {
      case "bmp":
        i = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        i = "image/jpeg";
        break;
      case "png":
        i = "image/png";
        break;
      case "tif":
        i = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", s), i = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + i + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: i }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in re.Objects) {
      const s = re.Objects.Texture;
      for (const n in s) {
        const i = this.parseTexture(s[n], e);
        t.set(parseInt(n), i);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const s = this.loadTexture(e, t);
    s.ID = e.id, s.name = e.attrName;
    const n = e.WrapModeU, i = e.WrapModeV, o = n !== void 0 ? n.value : 0, r = i !== void 0 ? i.value : 0;
    if (s.wrapS = o === 0 ? on : ls, s.wrapT = r === 0 ? on : ls, "Scaling" in e) {
      const a = e.Scaling.value;
      s.repeat.x = a[0], s.repeat.y = a[1];
    }
    if ("Translation" in e) {
      const a = e.Translation.value;
      s.offset.x = a[0], s.offset.y = a[1];
    }
    return s;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    const s = /* @__PURE__ */ new Set(["tga", "tif", "tiff", "exr", "dds", "hdr", "ktx2"]), n = e.FileName.split(".").pop().toLowerCase(), i = s.has(n) ? this.manager.getHandler(`.${n}`) : this.textureLoader;
    if (!i)
      return console.warn(
        `FBXLoader: ${n.toUpperCase()} loader not found, creating placeholder texture for`,
        e.RelativeFilename
      ), new Ks();
    const o = i.path;
    o || i.setPath(this.textureLoader.path);
    const r = De.get(e.id).children;
    let a;
    r !== void 0 && r.length > 0 && t[r[0].ID] !== void 0 && (a = t[r[0].ID], (a.indexOf("blob:") === 0 || a.indexOf("data:") === 0) && i.setPath(void 0));
    const c = i.load(a);
    return i.setPath(o), c;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in re.Objects) {
      const s = re.Objects.Material;
      for (const n in s) {
        const i = this.parseMaterial(s[n], e);
        i !== null && t.set(parseInt(n), i);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const s = e.id, n = e.attrName;
    let i = e.ShadingModel;
    if (typeof i == "object" && (i = i.value), !De.has(s)) return null;
    const o = this.parseParameters(e, t, s);
    let r;
    switch (i.toLowerCase()) {
      case "phong":
        r = new Pn();
        break;
      case "lambert":
        r = new Pa();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), r = new Pn();
        break;
    }
    return r.setValues(o), r.name = n, r;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, s) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = Ve.toWorkingColorSpace(new Se().fromArray(e.Diffuse.value), ge) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = Ve.toWorkingColorSpace(new Se().fromArray(e.DiffuseColor.value), ge)), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = Ve.toWorkingColorSpace(new Se().fromArray(e.Emissive.value), ge) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = Ve.toWorkingColorSpace(new Se().fromArray(e.EmissiveColor.value), ge)), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = Ve.toWorkingColorSpace(new Se().fromArray(e.Specular.value), ge) : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = Ve.toWorkingColorSpace(new Se().fromArray(e.SpecularColor.value), ge));
    const i = this;
    return De.get(s).children.forEach(function(o) {
      const r = o.relationship;
      switch (r) {
        case "Bump":
          n.bumpMap = i.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = i.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = i.getTexture(t, o.ID), n.map !== void 0 && (n.map.colorSpace = ge);
          break;
        case "DisplacementColor":
          n.displacementMap = i.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = i.getTexture(t, o.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = ge);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = i.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          n.envMap = i.getTexture(t, o.ID), n.envMap !== void 0 && (n.envMap.mapping = Oa, n.envMap.colorSpace = ge);
          break;
        case "SpecularColor":
          n.specularMap = i.getTexture(t, o.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = ge);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = i.getTexture(t, o.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        // AKA glossiness map
        case "SpecularFactor":
        // AKA specularLevel
        case "VectorDisplacementColor":
        // NOTE: Seems to be a copy of DisplacementColor
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", r);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in re.Objects && t in re.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = De.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in re.Objects) {
      const s = re.Objects.Deformer;
      for (const n in s) {
        const i = s[n], o = De.get(parseInt(n));
        if (i.attrType === "Skin") {
          const r = this.parseSkeleton(o, s);
          r.ID = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), r.geometryID = o.parents[0].ID, e[n] = r;
        } else if (i.attrType === "BlendShape") {
          const r = {
            id: n
          };
          r.rawTargets = this.parseMorphTargets(o, s), r.id = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = r;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const s = [];
    return e.children.forEach(function(n) {
      const i = t[n.ID];
      if (i.attrType !== "Cluster") return;
      const o = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new ue().fromArray(i.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in i && (o.indices = i.Indexes.a, o.weights = i.Weights.a), s.push(o);
    }), {
      rawBones: s,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const s = [];
    for (let n = 0; n < e.children.length; n++) {
      const i = e.children[n], o = t[i.ID], r = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel") return;
      r.geoID = De.get(parseInt(i.ID)).children.filter(function(a) {
        return a.relationship === void 0;
      })[0].ID, s.push(r);
    }
    return s;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, s) {
    ze = new nn();
    const n = this.parseModels(e.skeletons, t, s), i = re.Objects.Model, o = this;
    n.forEach(function(a) {
      const c = i[a.ID];
      o.setLookAtProperties(a, c), De.get(a.ID)?.parents?.forEach(function(h) {
        const g = n.get(h.ID);
        g !== void 0 && g.add(a);
      }), a.parent === null && ze.add(a);
    }), this.bindSkeleton(e.skeletons, t, n), this.addGlobalSceneSettings(), ze.traverse(function(a) {
      if (a.userData.transformData) {
        a.parent && (a.userData.transformData.parentMatrix = a.parent.matrix, a.userData.transformData.parentMatrixWorld = a.parent.matrixWorld);
        const c = Dr(a.userData.transformData);
        a.applyMatrix4(c), a.updateWorldMatrix();
      }
      a.isSkinnedMesh && (a.computeBoundingBox(), a.computeBoundingSphere(), a.boundingBox.expandByScalar(3), a.boundingSphere.radius *= 3);
    });
    const r = new Wc().parse();
    ze.children.length === 1 && ze.children[0].isGroup && (ze.children[0].animations = r, ze = ze.children[0]), ze.animations = r;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, s) {
    const n = /* @__PURE__ */ new Map(), i = re.Objects.Model;
    for (const o in i) {
      const r = parseInt(o), a = i[o], c = De.get(r);
      let l = this.buildSkeleton(c, e, r, a.attrName);
      if (!l) {
        switch (a.attrType) {
          case "Camera":
            l = this.createCamera(c);
            break;
          case "Light":
            l = this.createLight(c);
            break;
          case "Mesh":
            l = this.createMesh(c, t, s);
            break;
          case "NurbsCurve":
            l = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            l = new Ys();
            break;
          case "Null":
          default:
            l = new nn();
            break;
        }
        l.name = a.attrName ? Lt.sanitizeNodeName(a.attrName) : "", l.userData.originalName = a.attrName, l.ID = r;
      }
      this.getTransformData(l, a), n.set(r, l);
    }
    return n;
  }
  buildSkeleton(e, t, s, n) {
    let i = null;
    return e?.parents.forEach(function(o) {
      for (const r in t) {
        const a = t[r];
        a.rawBones.forEach(function(c, l) {
          if (c.ID === o.ID) {
            const h = i;
            i = new Ys(), i.matrixWorld.copy(c.transformLink), i.name = n ? Lt.sanitizeNodeName(n) : "", i.userData.originalName = n, i.ID = s, a.bones[l] = i, h !== null && i.add(h);
          }
        });
      }
    }), i;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, s;
    if (e.children.forEach(function(n) {
      const i = re.Objects.NodeAttribute[n.ID];
      i !== void 0 && (s = i);
    }), s === void 0)
      t = new xt();
    else {
      let n = 0;
      s.CameraProjectionType !== void 0 && s.CameraProjectionType.value === 1 && (n = 1);
      let i = 1;
      s.NearPlane !== void 0 && (i = s.NearPlane.value / 1e3);
      let o = 1e3;
      s.FarPlane !== void 0 && (o = s.FarPlane.value / 1e3);
      let r = window.innerWidth, a = window.innerHeight;
      s.AspectWidth !== void 0 && s.AspectHeight !== void 0 && (r = s.AspectWidth.value, a = s.AspectHeight.value);
      const c = r / a;
      let l = 45;
      s.FieldOfView !== void 0 && (l = s.FieldOfView.value);
      const h = s.FocalLength ? s.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new gs(l, c, i, o), h !== null && t.setFocalLength(h);
          break;
        case 1:
          console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."), t = new xt();
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new xt();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, s;
    if (e.children.forEach(function(n) {
      const i = re.Objects.NodeAttribute[n.ID];
      i !== void 0 && (s = i);
    }), s === void 0)
      t = new xt();
    else {
      let n;
      s.LightType === void 0 ? n = 0 : n = s.LightType.value;
      let i = 16777215;
      s.Color !== void 0 && (i = Ve.toWorkingColorSpace(new Se().fromArray(s.Color.value), ge));
      let o = s.Intensity === void 0 ? 1 : s.Intensity.value / 100;
      s.CastLightOnObject !== void 0 && s.CastLightOnObject.value === 0 && (o = 0);
      let r = 0;
      s.FarAttenuationEnd !== void 0 && (s.EnableFarAttenuation !== void 0 && s.EnableFarAttenuation.value === 0 ? r = 0 : r = s.FarAttenuationEnd.value);
      const a = 1;
      switch (n) {
        case 0:
          t = new zs(i, o, r, a);
          break;
        case 1:
          t = new _o(i, o);
          break;
        case 2:
          let c = Math.PI / 3;
          s.InnerAngle !== void 0 && (c = Qe.degToRad(s.InnerAngle.value));
          let l = 0;
          s.OuterAngle !== void 0 && (l = Qe.degToRad(s.OuterAngle.value), l = Math.max(l, 1)), t = new Ro(i, o, r, c, l, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + s.LightType.value + ", defaulting to a PointLight."), t = new zs(i, o);
          break;
      }
      s.CastShadows !== void 0 && s.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, s) {
    let n, i = null, o = null;
    const r = [];
    if (e.children.forEach(function(a) {
      t.has(a.ID) && (i = t.get(a.ID)), s.has(a.ID) && r.push(s.get(a.ID));
    }), r.length > 1 ? o = r : r.length > 0 ? o = r[0] : (o = new Pn({
      name: kt.DEFAULT_MATERIAL_NAME,
      color: 13421772
    }), r.push(o)), "color" in i.attributes && r.forEach(function(a) {
      a.vertexColors = !0;
    }), i.groups.length > 0) {
      let a = !1;
      for (let c = 0, l = i.groups.length; c < l; c++) {
        const h = i.groups[c];
        (h.materialIndex < 0 || h.materialIndex >= r.length) && (h.materialIndex = r.length, a = !0);
      }
      if (a) {
        const c = new fi();
        r.push(c);
      }
    }
    return i.FBX_Deformer ? (n = new Lo(i, o), n.normalizeSkinWeights()) : n = new q(i, o), n;
  }
  createCurve(e, t) {
    const s = e.children.reduce(function(i, o) {
      return t.has(o.ID) && (i = t.get(o.ID)), i;
    }, null), n = new Ft({
      name: kt.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new pt(s, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const s = {};
    "InheritType" in t && (s.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? s.eulerOrder = Hn(t.RotationOrder.value) : s.eulerOrder = Hn(0), "Lcl_Translation" in t && (s.translation = t.Lcl_Translation.value), "PreRotation" in t && (s.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (s.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (s.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (s.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (s.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (s.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (s.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (s.rotationPivot = t.RotationPivot.value), e.userData.transformData = s;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && De.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const i = re.Objects.Model[n.ID];
        if ("Lcl_Translation" in i) {
          const o = i.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), ze.add(e.target)) : e.lookAt(new P().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, s) {
    const n = this.parsePoseNodes();
    for (const i in e) {
      const o = e[i];
      De.get(parseInt(o.ID)).parents.forEach(function(a) {
        if (t.has(a.ID)) {
          const c = a.ID;
          De.get(c).parents.forEach(function(h) {
            s.has(h.ID) && s.get(h.ID).bind(new Uo(o.bones), n[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in re.Objects) {
      const t = re.Objects.Pose;
      for (const s in t)
        if (t[s].attrType === "BindPose" && t[s].NbPoseNodes > 0) {
          const n = t[s].PoseNode;
          Array.isArray(n) ? n.forEach(function(i) {
            e[i.Node] = new ue().fromArray(i.Matrix.a);
          }) : e[n.Node] = new ue().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  addGlobalSceneSettings() {
    if ("GlobalSettings" in re) {
      if ("AmbientColor" in re.GlobalSettings) {
        const e = re.GlobalSettings.AmbientColor.value, t = e[0], s = e[1], n = e[2];
        if (t !== 0 || s !== 0 || n !== 0) {
          const i = new Se().setRGB(t, s, n, ge);
          ze.add(new Ha(i, 1));
        }
      }
      "UnitScaleFactor" in re.GlobalSettings && (ze.userData.unitScaleFactor = re.GlobalSettings.UnitScaleFactor.value);
    }
  }
}
class Vc {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in re.Objects) {
      const s = re.Objects.Geometry;
      for (const n in s) {
        const i = De.get(parseInt(n)), o = this.parseGeometry(i, s[n], e);
        t.set(parseInt(n), o);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, s) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, s);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, s) {
    const n = s.skeletons, i = [], o = e.parents.map(function(h) {
      return re.Objects.Model[h.ID];
    });
    if (o.length === 0) return;
    const r = e.children.reduce(function(h, g) {
      return n[g.ID] !== void 0 && (h = n[g.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      s.morphTargets[h.ID] !== void 0 && i.push(s.morphTargets[h.ID]);
    });
    const a = o[0], c = {};
    "RotationOrder" in a && (c.eulerOrder = Hn(a.RotationOrder.value)), "InheritType" in a && (c.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (c.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (c.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (c.scale = a.GeometricScaling.value);
    const l = Dr(c);
    return this.genGeometry(t, r, i, l);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, s, n) {
    const i = new ut();
    e.attrName && (i.name = e.attrName);
    const o = this.parseGeoNode(e, t), r = this.genBuffers(o), a = new Fe(r.vertex, 3);
    if (a.applyMatrix4(n), i.setAttribute("position", a), r.colors.length > 0 && i.setAttribute("color", new Fe(r.colors, 3)), t && (i.setAttribute("skinIndex", new ja(r.weightsIndices, 4)), i.setAttribute("skinWeight", new Fe(r.vertexWeights, 4)), i.FBX_Deformer = t), r.normal.length > 0) {
      const c = new Jo().getNormalMatrix(n), l = new Fe(r.normal, 3);
      l.applyNormalMatrix(c), i.setAttribute("normal", l);
    }
    if (r.uvs.forEach(function(c, l) {
      const h = l === 0 ? "uv" : `uv${l}`;
      i.setAttribute(h, new Fe(r.uvs[l], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let c = r.materialIndex[0], l = 0;
      if (r.materialIndex.forEach(function(h, g) {
        h !== c && (i.addGroup(l, g - l, c), c = h, l = g);
      }), i.groups.length > 0) {
        const h = i.groups[i.groups.length - 1], g = h.start + h.count;
        g !== r.materialIndex.length && i.addGroup(g, r.materialIndex.length - g, c);
      }
      i.groups.length === 0 && i.addGroup(0, r.materialIndex.length, r.materialIndex[0]);
    }
    return this.addMorphTargets(i, e, s, n), i;
  }
  parseGeoNode(e, t) {
    const s = {};
    if (s.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], s.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (s.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (s.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (s.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      s.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && s.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return s.weightTable = {}, t !== null && (s.skeleton = t, t.rawBones.forEach(function(n, i) {
      n.indices.forEach(function(o, r) {
        s.weightTable[o] === void 0 && (s.weightTable[o] = []), s.weightTable[o].push({
          id: i,
          weight: n.weights[r]
        });
      });
    })), s;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let s = 0, n = 0, i = !1, o = [], r = [], a = [], c = [], l = [], h = [];
    const g = this;
    return e.vertexIndices.forEach(function(d, f) {
      let I, m = !1;
      d < 0 && (d = d ^ -1, m = !0);
      let C = [], w = [];
      if (o.push(d * 3, d * 3 + 1, d * 3 + 2), e.color) {
        const b = Xn(f, s, d, e.color);
        a.push(b[0], b[1], b[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[d] !== void 0 && e.weightTable[d].forEach(function(b) {
          w.push(b.weight), C.push(b.id);
        }), w.length > 4) {
          i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0);
          const b = [0, 0, 0, 0], B = [0, 0, 0, 0];
          w.forEach(function(Q, D) {
            let R = Q, x = C[D];
            B.forEach(function(T, U, L) {
              if (R > T) {
                L[U] = R, R = T;
                const H = b[U];
                b[U] = x, x = H;
              }
            });
          }), C = b, w = B;
        }
        for (; w.length < 4; )
          w.push(0), C.push(0);
        for (let b = 0; b < 4; ++b)
          l.push(w[b]), h.push(C[b]);
      }
      if (e.normal) {
        const b = Xn(f, s, d, e.normal);
        r.push(b[0], b[1], b[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (I = Xn(f, s, d, e.material)[0], I < 0 && (g.negativeMaterialIndices = !0, I = 0)), e.uv && e.uv.forEach(function(b, B) {
        const Q = Xn(f, s, d, b);
        c[B] === void 0 && (c[B] = []), c[B].push(Q[0]), c[B].push(Q[1]);
      }), n++, m && (g.genFace(t, e, o, I, r, a, c, l, h, n), s++, n = 0, o = [], r = [], a = [], c = [], l = [], h = []);
    }), t;
  }
  // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
  getNormalNewell(e) {
    const t = new P(0, 0, 0);
    for (let s = 0; s < e.length; s++) {
      const n = e[s], i = e[(s + 1) % e.length];
      t.x += (n.y - i.y) * (n.z + i.z), t.y += (n.z - i.z) * (n.x + i.x), t.z += (n.x - i.x) * (n.y + i.y);
    }
    return t.normalize(), t;
  }
  getNormalTangentAndBitangent(e) {
    const t = this.getNormalNewell(e), n = (Math.abs(t.z) > 0.5 ? new P(0, 1, 0) : new P(0, 0, 1)).cross(t).normalize(), i = t.clone().cross(n).normalize();
    return {
      normal: t,
      tangent: n,
      bitangent: i
    };
  }
  flattenVertex(e, t, s) {
    return new Le(
      e.dot(t),
      e.dot(s)
    );
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, s, n, i, o, r, a, c, l) {
    let h;
    if (l > 3) {
      const g = [], d = t.baseVertexPositions || t.vertexPositions;
      for (let C = 0; C < s.length; C += 3)
        g.push(
          new P(
            d[s[C]],
            d[s[C + 1]],
            d[s[C + 2]]
          )
        );
      const { tangent: f, bitangent: I } = this.getNormalTangentAndBitangent(g), m = [];
      for (const C of g)
        m.push(this.flattenVertex(C, f, I));
      h = qa.triangulateShape(m, []);
    } else l === 2 ? (console.warn("THREE.FBXLoader: Edge topology detected. This is currently not supported. The resulting mesh will not be correct."), h = [[0, 1, 2]]) : h = [[0, 1, 2]];
    for (const [g, d, f] of h)
      e.vertex.push(t.vertexPositions[s[g * 3]]), e.vertex.push(t.vertexPositions[s[g * 3 + 1]]), e.vertex.push(t.vertexPositions[s[g * 3 + 2]]), e.vertex.push(t.vertexPositions[s[d * 3]]), e.vertex.push(t.vertexPositions[s[d * 3 + 1]]), e.vertex.push(t.vertexPositions[s[d * 3 + 2]]), e.vertex.push(t.vertexPositions[s[f * 3]]), e.vertex.push(t.vertexPositions[s[f * 3 + 1]]), e.vertex.push(t.vertexPositions[s[f * 3 + 2]]), t.skeleton && (e.vertexWeights.push(a[g * 4]), e.vertexWeights.push(a[g * 4 + 1]), e.vertexWeights.push(a[g * 4 + 2]), e.vertexWeights.push(a[g * 4 + 3]), e.vertexWeights.push(a[d * 4]), e.vertexWeights.push(a[d * 4 + 1]), e.vertexWeights.push(a[d * 4 + 2]), e.vertexWeights.push(a[d * 4 + 3]), e.vertexWeights.push(a[f * 4]), e.vertexWeights.push(a[f * 4 + 1]), e.vertexWeights.push(a[f * 4 + 2]), e.vertexWeights.push(a[f * 4 + 3]), e.weightsIndices.push(c[g * 4]), e.weightsIndices.push(c[g * 4 + 1]), e.weightsIndices.push(c[g * 4 + 2]), e.weightsIndices.push(c[g * 4 + 3]), e.weightsIndices.push(c[d * 4]), e.weightsIndices.push(c[d * 4 + 1]), e.weightsIndices.push(c[d * 4 + 2]), e.weightsIndices.push(c[d * 4 + 3]), e.weightsIndices.push(c[f * 4]), e.weightsIndices.push(c[f * 4 + 1]), e.weightsIndices.push(c[f * 4 + 2]), e.weightsIndices.push(c[f * 4 + 3])), t.color && (e.colors.push(o[g * 3]), e.colors.push(o[g * 3 + 1]), e.colors.push(o[g * 3 + 2]), e.colors.push(o[d * 3]), e.colors.push(o[d * 3 + 1]), e.colors.push(o[d * 3 + 2]), e.colors.push(o[f * 3]), e.colors.push(o[f * 3 + 1]), e.colors.push(o[f * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(i[g * 3]), e.normal.push(i[g * 3 + 1]), e.normal.push(i[g * 3 + 2]), e.normal.push(i[d * 3]), e.normal.push(i[d * 3 + 1]), e.normal.push(i[d * 3 + 2]), e.normal.push(i[f * 3]), e.normal.push(i[f * 3 + 1]), e.normal.push(i[f * 3 + 2])), t.uv && t.uv.forEach(function(I, m) {
        e.uvs[m] === void 0 && (e.uvs[m] = []), e.uvs[m].push(r[m][g * 2]), e.uvs[m].push(r[m][g * 2 + 1]), e.uvs[m].push(r[m][d * 2]), e.uvs[m].push(r[m][d * 2 + 1]), e.uvs[m].push(r[m][f * 2]), e.uvs[m].push(r[m][f * 2 + 1]);
      });
  }
  addMorphTargets(e, t, s, n) {
    if (s.length === 0) return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const i = this;
    s.forEach(function(o) {
      o.rawTargets.forEach(function(r) {
        const a = re.Objects.Geometry[r.geoID];
        a !== void 0 && i.genMorphGeometry(e, t, a, n, r.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, s, n, i) {
    const o = t.Vertices !== void 0 ? t.Vertices.a : [], r = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = s.Vertices !== void 0 ? s.Vertices.a : [], c = s.Indexes !== void 0 ? s.Indexes.a : [], l = e.attributes.position.count * 3, h = new Float32Array(l);
    for (let I = 0; I < c.length; I++) {
      const m = c[I] * 3;
      h[m] = a[I * 3], h[m + 1] = a[I * 3 + 1], h[m + 2] = a[I * 3 + 2];
    }
    const g = {
      vertexIndices: r,
      vertexPositions: h,
      baseVertexPositions: o
    }, d = this.genBuffers(g), f = new Fe(d.vertex, 3);
    f.name = i || s.attrName, f.applyMatrix4(n), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.Normals.a;
    let i = [];
    return s === "IndexToDirect" && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.UV.a;
    let i = [];
    return s === "IndexToDirect" && (i = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    if (!e.Colors) return;
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.Colors.a;
    let i = [];
    s === "IndexToDirect" && (i = e.ColorIndex.a);
    for (let o = 0, r = new Se(); o < n.length; o += 4)
      r.fromArray(n, o), Ve.toWorkingColorSpace(r, ge), r.toArray(n, o);
    return {
      dataSize: 4,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: s
      };
    const n = e.Materials.a, i = [];
    for (let o = 0; o < n.length; ++o)
      i.push(o);
    return {
      dataSize: 1,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new ut();
    const s = t - 1, n = e.KnotVector.a, i = [], o = e.Points.a;
    for (let h = 0, g = o.length; h < g; h += 4)
      i.push(new Nt().fromArray(o, h));
    let r, a;
    if (e.Form === "Closed")
      i.push(i[0]);
    else if (e.Form === "Periodic") {
      r = s, a = n.length - 1 - r;
      for (let h = 0; h < s; ++h)
        i.push(i[h]);
    }
    const l = new Kc(s, n, i, r, a).getPoints(i.length * 12);
    return new ut().setFromPoints(l);
  }
}
class Wc {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const s in t) {
        const n = t[s], i = this.addClip(n);
        e.push(i);
      }
    return e;
  }
  parseClips() {
    if (re.Objects.AnimationCurve === void 0) return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = re.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const s in e) {
      const n = e[s];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const i = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(i.id, i);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = re.Objects.AnimationCurve;
    for (const s in t) {
      const n = {
        id: t[s].id,
        times: t[s].KeyTime.a.map(tl),
        values: t[s].KeyValueFloat.a
      }, i = De.get(n.id);
      if (i !== void 0) {
        const o = i.parents[0].ID, r = i.parents[0].relationship;
        r.match(/X/) ? e.get(o).curves.x = n : r.match(/Y/) ? e.get(o).curves.y = n : r.match(/Z/) ? e.get(o).curves.z = n : r.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = re.Objects.AnimationLayer, s = /* @__PURE__ */ new Map();
    for (const n in t) {
      const i = [], o = De.get(parseInt(n));
      o !== void 0 && (o.children.forEach(function(a, c) {
        if (e.has(a.ID)) {
          const l = e.get(a.ID);
          if (l.curves.x !== void 0 || l.curves.y !== void 0 || l.curves.z !== void 0) {
            if (i[c] === void 0) {
              const h = De.get(a.ID).parents.filter(function(g) {
                return g.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const g = re.Objects.Model[h.toString()];
                if (g === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", a);
                  return;
                }
                const d = {
                  modelName: g.attrName ? Lt.sanitizeNodeName(g.attrName) : "",
                  ID: g.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                ze.traverse(function(f) {
                  f.ID === g.id && (d.transform = f.matrix, f.userData.transformData && (d.eulerOrder = f.userData.transformData.eulerOrder));
                }), d.transform || (d.transform = new ue()), "PreRotation" in g && (d.preRotation = g.PreRotation.value), "PostRotation" in g && (d.postRotation = g.PostRotation.value), i[c] = d;
              }
            }
            i[c] && (i[c][l.attr] = l);
          } else if (l.curves.morph !== void 0) {
            if (i[c] === void 0) {
              const h = De.get(a.ID).parents.filter(function(C) {
                return C.relationship !== void 0;
              })[0].ID, g = De.get(h).parents[0].ID, d = De.get(g).parents[0].ID, f = De.get(d).parents[0].ID, I = re.Objects.Model[f], m = {
                modelName: I.attrName ? Lt.sanitizeNodeName(I.attrName) : "",
                morphName: re.Objects.Deformer[h].attrName
              };
              i[c] = m;
            }
            i[c][l.attr] = l;
          }
        }
      }), s.set(parseInt(n), i));
    }
    return s;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = re.Objects.AnimationStack, s = {};
    for (const n in t) {
      const i = De.get(parseInt(n)).children;
      i.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const o = e.get(i[0].ID);
      s[n] = {
        name: t[n].attrName,
        layer: o
      };
    }
    return s;
  }
  addClip(e) {
    let t = [];
    const s = this;
    return e.layer.forEach(function(n) {
      t = t.concat(s.generateTracks(n));
    }), new Go(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let s = new P(), n = new P();
    if (e.transform && e.transform.decompose(s, new Te(), n), s = s.toArray(), n = n.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const i = this.generateVectorTrack(e.modelName, e.T.curves, s, "position");
      i !== void 0 && t.push(i);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const i = this.generateRotationTrack(e.modelName, e.R.curves, e.preRotation, e.postRotation, e.eulerOrder);
      i !== void 0 && t.push(i);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const i = this.generateVectorTrack(e.modelName, e.S.curves, n, "scale");
      i !== void 0 && t.push(i);
    }
    if (e.DeformPercent !== void 0) {
      const i = this.generateMorphTrack(e);
      i !== void 0 && t.push(i);
    }
    return t;
  }
  generateVectorTrack(e, t, s, n) {
    const i = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(i, t, s);
    return new Js(e + "." + n, i, o);
  }
  generateRotationTrack(e, t, s, n, i) {
    let o, r;
    if (t.x === void 0 || t.y === void 0 || t.z === void 0) {
      console.warn("THREE.FBXLoader: Missing rotation curves " + (t.x === void 0 ? "x " : "") + (t.y === void 0 ? "y " : "") + (t.z === void 0 ? "z " : "") + " for animation of " + e + ". This is currently not supported.");
      return;
    }
    if (t.x !== void 0 && t.y !== void 0 && t.z !== void 0) {
      const g = this.interpolateRotations(t.x, t.y, t.z, i);
      o = g[0], r = g[1];
    }
    const a = Hn(0);
    s !== void 0 && (s = s.map(Qe.degToRad), s.push(a), s = new qt().fromArray(s), s = new Te().setFromEuler(s)), n !== void 0 && (n = n.map(Qe.degToRad), n.push(a), n = new qt().fromArray(n), n = new Te().setFromEuler(n).invert());
    const c = new Te(), l = new qt(), h = [];
    if (!(!r || !o)) {
      for (let g = 0; g < r.length; g += 3)
        l.set(r[g], r[g + 1], r[g + 2], i), c.setFromEuler(l), s !== void 0 && c.premultiply(s), n !== void 0 && c.multiply(n), g > 2 && new Te().fromArray(
          h,
          (g - 3) / 3 * 4
        ).dot(c) < 0 && c.set(-c.x, -c.y, -c.z, -c.w), c.toArray(h, g / 3 * 4);
      return new Ws(e + ".quaternion", o, h);
    }
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, s = t.values.map(function(i) {
      return i / 100;
    }), n = ze.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Vs(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, s);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(s, n) {
      return s - n;
    }), t.length > 1) {
      let s = 1, n = t[0];
      for (let i = 1; i < t.length; i++) {
        const o = t[i];
        o !== n && (t[s] = o, n = o, s++);
      }
      t = t.slice(0, s);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, s) {
    const n = s, i = [];
    let o = -1, r = -1, a = -1;
    return e.forEach(function(c) {
      if (t.x && (o = t.x.times.indexOf(c)), t.y && (r = t.y.times.indexOf(c)), t.z && (a = t.z.times.indexOf(c)), o !== -1) {
        const l = t.x.values[o];
        i.push(l), n[0] = l;
      } else
        i.push(n[0]);
      if (r !== -1) {
        const l = t.y.values[r];
        i.push(l), n[1] = l;
      } else
        i.push(n[1]);
      if (a !== -1) {
        const l = t.z.values[a];
        i.push(l), n[2] = l;
      } else
        i.push(n[2]);
    }), i;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e, t, s, n) {
    const i = [], o = [];
    i.push(e.times[0]), o.push(Qe.degToRad(e.values[0])), o.push(Qe.degToRad(t.values[0])), o.push(Qe.degToRad(s.values[0]));
    for (let r = 1; r < e.values.length; r++) {
      const a = [
        e.values[r - 1],
        t.values[r - 1],
        s.values[r - 1]
      ];
      if (isNaN(a[0]) || isNaN(a[1]) || isNaN(a[2]))
        continue;
      const c = a.map(Qe.degToRad), l = [
        e.values[r],
        t.values[r],
        s.values[r]
      ];
      if (isNaN(l[0]) || isNaN(l[1]) || isNaN(l[2]))
        continue;
      const h = l.map(Qe.degToRad), g = [
        l[0] - a[0],
        l[1] - a[1],
        l[2] - a[2]
      ], d = [
        Math.abs(g[0]),
        Math.abs(g[1]),
        Math.abs(g[2])
      ];
      if (d[0] >= 180 || d[1] >= 180 || d[2] >= 180) {
        const I = Math.max(...d) / 180, m = new qt(...c, n), C = new qt(...h, n), w = new Te().setFromEuler(m), b = new Te().setFromEuler(C);
        w.dot(b) && b.set(-b.x, -b.y, -b.z, -b.w);
        const B = e.times[r - 1], Q = e.times[r] - B, D = new Te(), R = new qt();
        for (let x = 0; x < 1; x += 1 / I)
          D.copy(w.clone().slerp(b.clone(), x)), i.push(B + x * Q), R.setFromQuaternion(D, n), o.push(R.x), o.push(R.y), o.push(R.z);
      } else
        i.push(e.times[r]), o.push(Qe.degToRad(e.values[r])), o.push(Qe.degToRad(t.values[r])), o.push(Qe.degToRad(s.values[r]));
    }
    return [i, o];
  }
}
class Xc {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new vr(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, s = e.split(/[\r\n]+/);
    return s.forEach(function(n, i) {
      const o = n.match(/^[\s\t]*;/), r = n.match(/^[\s\t]*$/);
      if (o || r) return;
      const a = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), l = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      a ? t.parseNodeBegin(n, a) : c ? t.parseNodeProperty(n, c, s[++i]) : l ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const s = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(a) {
      return a.trim().replace(/^"/, "").replace(/"$/, "");
    }), i = { name: s }, o = this.parseNodeAttr(n), r = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(s, i) : s in r ? (s === "PoseNode" ? r.PoseNode.push(i) : r[s].id !== void 0 && (r[s] = {}, r[s][r[s].id] = r[s]), o.id !== "" && (r[s][o.id] = i)) : typeof o.id == "number" ? (r[s] = {}, r[s][o.id] = i) : s !== "Properties70" && (s === "PoseNode" ? r[s] = [i] : r[s] = i), typeof o.id == "number" && (i.id = o.id), o.name !== "" && (i.attrName = o.name), o.type !== "" && (i.attrType = o.type), this.pushStack(i);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let s = "", n = "";
    return e.length > 1 && (s = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: s, type: n };
  }
  parseNodeProperty(e, t, s) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && i === "," && (i = s.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, i);
      return;
    }
    if (n === "C") {
      const a = i.split(",").slice(1), c = parseInt(a[0]), l = parseInt(a[1]);
      let h = i.split(",").slice(3);
      h = h.map(function(g) {
        return g.trim().replace(/^"/, "");
      }), n = "connections", i = [c, l], sl(i, h), o[n] === void 0 && (o[n] = []);
    }
    n === "Node" && (o.id = i), n in o && Array.isArray(o[n]) ? o[n].push(i) : n !== "a" ? o[n] = i : o.a = i, this.setCurrentProp(o, n), n === "a" && i.slice(-1) !== "," && (o.a = ks(i));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = ks(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, s) {
    const n = s.split('",').map(function(l) {
      return l.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), i = n[0], o = n[1], r = n[2], a = n[3];
    let c = n[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = ks(c);
        break;
    }
    this.getPrevNode()[i] = {
      type: o,
      type2: r,
      flag: a,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), i);
  }
}
class Zc {
  parse(e) {
    const t = new ro(e);
    t.skip(23);
    const s = t.getUint32();
    if (s < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + s);
    const n = new vr();
    for (; !this.endOfContent(t); ) {
      const i = this.parseNode(t, s);
      i !== null && n.add(i.name, i);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const s = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), r = e.getString(o);
    if (n === 0) return null;
    const a = [];
    for (let g = 0; g < i; g++)
      a.push(this.parseProperty(e));
    const c = a.length > 0 ? a[0] : "", l = a.length > 1 ? a[1] : "", h = a.length > 2 ? a[2] : "";
    for (s.singleProperty = i === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const g = this.parseNode(e, t);
      g !== null && this.parseSubNode(r, s, g);
    }
    return s.propertyList = a, typeof c == "number" && (s.id = c), l !== "" && (s.attrName = l), h !== "" && (s.attrType = h), r !== "" && (s.name = r), s;
  }
  parseSubNode(e, t, s) {
    if (s.singleProperty === !0) {
      const n = s.propertyList[0];
      Array.isArray(n) ? (t[s.name] = s, s.a = n) : t[s.name] = n;
    } else if (e === "Connections" && s.name === "C") {
      const n = [];
      s.propertyList.forEach(function(i, o) {
        o !== 0 && n.push(i);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (s.name === "Properties70")
      Object.keys(s).forEach(function(i) {
        t[i] = s[i];
      });
    else if (e === "Properties70" && s.name === "P") {
      let n = s.propertyList[0], i = s.propertyList[1];
      const o = s.propertyList[2], r = s.propertyList[3];
      let a;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), i === "Color" || i === "ColorRGB" || i === "Vector" || i === "Vector3D" || i.indexOf("Lcl_") === 0 ? a = [
        s.propertyList[4],
        s.propertyList[5],
        s.propertyList[6]
      ] : a = s.propertyList[4], t[n] = {
        type: i,
        type2: o,
        flag: r,
        value: a
      };
    } else t[s.name] === void 0 ? typeof s.id == "number" ? (t[s.name] = {}, t[s.name][s.id] = s) : t[s.name] = s : s.name === "PoseNode" ? (Array.isArray(t[s.name]) || (t[s.name] = [t[s.name]]), t[s.name].push(s)) : t[s.name][s.id] === void 0 && (t[s.name][s.id] = s);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let s;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return s = e.getUint32(), e.getArrayBuffer(s);
      case "S":
        return s = e.getUint32(), e.getString(s);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), i = e.getUint32(), o = e.getUint32();
        if (i === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const r = Ln(new Uint8Array(e.getArrayBuffer(o))), a = new ro(r.buffer);
        switch (t) {
          case "b":
          case "c":
            return a.getBooleanArray(n);
          case "d":
            return a.getFloat64Array(n);
          case "f":
            return a.getFloat32Array(n);
          case "i":
            return a.getInt32Array(n);
          case "l":
            return a.getInt64Array(n);
        }
        break;
      // cannot happen but is required by the DeepScan
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class ro {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let s = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const n = s.indexOf(0);
    return n >= 0 && (s = new Uint8Array(this.dv.buffer, t, n)), this._textDecoder.decode(s);
  }
}
class vr {
  add(e, t) {
    this[e] = t;
  }
}
function $c(A) {
  const e = "Kaydara FBX Binary  \0";
  return A.byteLength >= e.length && e === Rr(A, 0, e.length);
}
function el(A) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function s(n) {
    const i = A[n - 1];
    return A = A.slice(t + n), t++, i;
  }
  for (let n = 0; n < e.length; ++n)
    if (s(1) === e[n])
      return !1;
  return !0;
}
function ao(A) {
  const e = /FBXVersion: (\d+)/, t = A.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function tl(A) {
  return A / 46186158e3;
}
const nl = [];
function Xn(A, e, t, s) {
  let n;
  switch (s.mappingType) {
    case "ByPolygonVertex":
      n = A;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = s.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + s.mappingType);
  }
  s.referenceType === "IndexToDirect" && (n = s.indices[n]);
  const i = n * s.dataSize, o = i + s.dataSize;
  return il(nl, s.buffer, i, o);
}
const Fs = new qt(), ln = new P();
function Dr(A) {
  const e = new ue(), t = new ue(), s = new ue(), n = new ue(), i = new ue(), o = new ue(), r = new ue(), a = new ue(), c = new ue(), l = new ue(), h = new ue(), g = new ue(), d = A.inheritType ? A.inheritType : 0;
  A.translation && e.setPosition(ln.fromArray(A.translation));
  const f = Hn(0);
  if (A.preRotation) {
    const L = A.preRotation.map(Qe.degToRad);
    L.push(f), t.makeRotationFromEuler(Fs.fromArray(L));
  }
  if (A.rotation) {
    const L = A.rotation.map(Qe.degToRad);
    L.push(A.eulerOrder || f), s.makeRotationFromEuler(Fs.fromArray(L));
  }
  if (A.postRotation) {
    const L = A.postRotation.map(Qe.degToRad);
    L.push(f), n.makeRotationFromEuler(Fs.fromArray(L)), n.invert();
  }
  A.scale && i.scale(ln.fromArray(A.scale)), A.scalingOffset && r.setPosition(ln.fromArray(A.scalingOffset)), A.scalingPivot && o.setPosition(ln.fromArray(A.scalingPivot)), A.rotationOffset && a.setPosition(ln.fromArray(A.rotationOffset)), A.rotationPivot && c.setPosition(ln.fromArray(A.rotationPivot)), A.parentMatrixWorld && (h.copy(A.parentMatrix), l.copy(A.parentMatrixWorld));
  const I = t.clone().multiply(s).multiply(n), m = new ue();
  m.extractRotation(l);
  const C = new ue();
  C.copyPosition(l);
  const w = C.clone().invert().multiply(l), b = m.clone().invert().multiply(w), B = i, Q = new ue();
  if (d === 0)
    Q.copy(m).multiply(I).multiply(b).multiply(B);
  else if (d === 1)
    Q.copy(m).multiply(b).multiply(I).multiply(B);
  else {
    const H = new ue().scale(new P().setFromMatrixScale(h)).clone().invert(), Z = b.clone().multiply(H);
    Q.copy(m).multiply(I).multiply(Z).multiply(B);
  }
  const D = c.clone().invert(), R = o.clone().invert();
  let x = e.clone().multiply(a).multiply(c).multiply(t).multiply(s).multiply(n).multiply(D).multiply(r).multiply(o).multiply(i).multiply(R);
  const T = new ue().copyPosition(x), U = l.clone().multiply(T);
  return g.copyPosition(U), x = g.clone().multiply(Q), x.premultiply(l.invert()), x;
}
function Hn(A) {
  A = A || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return A === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[A];
}
function ks(A) {
  return A.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Rr(A, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = A.byteLength), new TextDecoder().decode(new Uint8Array(A, e, t));
}
function sl(A, e) {
  for (let t = 0, s = A.length, n = e.length; t < n; t++, s++)
    A[s] = e[t];
}
function il(A, e, t, s) {
  for (let n = t, i = 0; n < s; n++, i++)
    A[i] = e[n];
  return A;
}
class ol extends kt {
  constructor(e) {
    super(e);
  }
  /**
   * Loads and parses a MTL asset from a URL.
   *
   * @param {String} url - URL to the MTL file.
   * @param {Function} [onLoad] - Callback invoked with the loaded object.
   * @param {Function} [onProgress] - Callback for download progress.
   * @param {Function} [onError] - Callback for download errors.
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to load.
   */
  load(e, t, s, n) {
    const i = this, o = this.path === "" ? tn.extractUrlBase(e) : this.path, r = new It(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, function(a) {
      try {
        t(i.parse(a, o));
      } catch (c) {
        n ? n(c) : console.error(c), i.manager.itemError(e);
      }
    }, s, n);
  }
  setMaterialOptions(e) {
    return this.materialOptions = e, this;
  }
  /**
   * Parses a MTL file.
   *
   * @param {String} text - Content of MTL file
   * @return {MaterialCreator}
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to parse.
   */
  parse(e, t) {
    const s = e.split(`
`);
    let n = {};
    const i = /\s+/, o = {};
    for (let a = 0; a < s.length; a++) {
      let c = s[a];
      if (c = c.trim(), c.length === 0 || c.charAt(0) === "#")
        continue;
      const l = c.indexOf(" ");
      let h = l >= 0 ? c.substring(0, l) : c;
      h = h.toLowerCase();
      let g = l >= 0 ? c.substring(l + 1) : "";
      if (g = g.trim(), h === "newmtl")
        n = { name: g }, o[g] = n;
      else if (h === "ka" || h === "kd" || h === "ks" || h === "ke") {
        const d = g.split(i, 3);
        n[h] = [parseFloat(d[0]), parseFloat(d[1]), parseFloat(d[2])];
      } else
        n[h] = g;
    }
    const r = new rl(this.resourcePath || t, this.materialOptions);
    return r.setCrossOrigin(this.crossOrigin), r.setManager(this.manager), r.setMaterials(o), r;
  }
}
class rl {
  constructor(e = "", t = {}) {
    this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : Oo, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : on;
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setManager(e) {
    this.manager = e;
  }
  setMaterials(e) {
    this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
  }
  convert(e) {
    if (!this.options) return e;
    const t = {};
    for (const s in e) {
      const n = e[s], i = {};
      t[s] = i;
      for (const o in n) {
        let r = !0, a = n[o];
        const c = o.toLowerCase();
        switch (c) {
          case "kd":
          case "ka":
          case "ks":
            this.options && this.options.normalizeRGB && (a = [a[0] / 255, a[1] / 255, a[2] / 255]), this.options && this.options.ignoreZeroRGBs && a[0] === 0 && a[1] === 0 && a[2] === 0 && (r = !1);
            break;
        }
        r && (i[c] = a);
      }
    }
    return t;
  }
  preload() {
    for (const e in this.materialsInfo)
      this.create(e);
  }
  getIndex(e) {
    return this.nameLookup[e];
  }
  getAsArray() {
    let e = 0;
    for (const t in this.materialsInfo)
      this.materialsArray[e] = this.create(t), this.nameLookup[t] = e, e++;
    return this.materialsArray;
  }
  create(e) {
    return this.materials[e] === void 0 && this.createMaterial_(e), this.materials[e];
  }
  createMaterial_(e) {
    const t = this, s = this.materialsInfo[e], n = {
      name: e,
      side: this.side
    };
    function i(r, a) {
      return typeof a != "string" || a === "" ? "" : /^https?:\/\//i.test(a) ? a : r + a;
    }
    function o(r, a) {
      if (n[r]) return;
      const c = t.getTextureParams(a, n), l = t.loadTexture(i(t.baseUrl, c.url));
      l.repeat.copy(c.scale), l.offset.copy(c.offset), l.wrapS = t.wrap, l.wrapT = t.wrap, (r === "map" || r === "emissiveMap") && (l.colorSpace = ge), n[r] = l;
    }
    for (const r in s) {
      const a = s[r];
      let c;
      if (a !== "")
        switch (r.toLowerCase()) {
          // Ns is material specular exponent
          case "kd":
            n.color = Ve.toWorkingColorSpace(new Se().fromArray(a), ge);
            break;
          case "ks":
            n.specular = Ve.toWorkingColorSpace(new Se().fromArray(a), ge);
            break;
          case "ke":
            n.emissive = Ve.toWorkingColorSpace(new Se().fromArray(a), ge);
            break;
          case "map_kd":
            o("map", a);
            break;
          case "map_ks":
            o("specularMap", a);
            break;
          case "map_ke":
            o("emissiveMap", a);
            break;
          case "norm":
            o("normalMap", a);
            break;
          case "map_bump":
          case "bump":
            o("bumpMap", a);
            break;
          case "map_d":
            o("alphaMap", a), n.transparent = !0;
            break;
          case "ns":
            n.shininess = parseFloat(a);
            break;
          case "d":
            c = parseFloat(a), c < 1 && (n.opacity = c, n.transparent = !0);
            break;
          case "tr":
            c = parseFloat(a), this.options && this.options.invertTrProperty && (c = 1 - c), c > 0 && (n.opacity = 1 - c, n.transparent = !0);
            break;
        }
    }
    return this.materials[e] = new Pn(n), this.materials[e];
  }
  getTextureParams(e, t) {
    const s = {
      scale: new Le(1, 1),
      offset: new Le(0, 0)
    }, n = e.split(/\s+/);
    let i;
    return i = n.indexOf("-bm"), i >= 0 && (t.bumpScale = parseFloat(n[i + 1]), n.splice(i, 2)), i = n.indexOf("-s"), i >= 0 && (s.scale.set(parseFloat(n[i + 1]), parseFloat(n[i + 2])), n.splice(i, 4)), i = n.indexOf("-o"), i >= 0 && (s.offset.set(parseFloat(n[i + 1]), parseFloat(n[i + 2])), n.splice(i, 4)), s.url = n.join(" ").trim(), s;
  }
  loadTexture(e, t, s, n, i) {
    const o = this.manager !== void 0 ? this.manager : za;
    let r = o.getHandler(e);
    r === null && (r = new di(o)), r.setCrossOrigin && r.setCrossOrigin(this.crossOrigin);
    const a = r.load(e, s, n, i);
    return t !== void 0 && (a.mapping = t), a;
  }
}
const al = /^[og]\s*(.+)?/, Al = /^mtllib /, cl = /^usemtl /, ll = /^usemap /, Ao = /\s+/, co = new P(), Ls = new P(), lo = new P(), ho = new P(), lt = new P(), Zn = new Se();
function hl() {
  const A = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(e, t) {
      if (this.object && this.object.fromDeclaration === !1) {
        this.object.name = e, this.object.fromDeclaration = t !== !1;
        return;
      }
      const s = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
        name: e || "",
        fromDeclaration: t !== !1,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: !1
        },
        materials: [],
        smooth: !0,
        startMaterial: function(n, i) {
          const o = this._finalize(!1);
          o && (o.inherited || o.groupCount <= 0) && this.materials.splice(o.index, 1);
          const r = {
            index: this.materials.length,
            name: n || "",
            mtllib: Array.isArray(i) && i.length > 0 ? i[i.length - 1] : "",
            smooth: o !== void 0 ? o.smooth : this.smooth,
            groupStart: o !== void 0 ? o.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: !1,
            clone: function(a) {
              const c = {
                index: typeof a == "number" ? a : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: !1
              };
              return c.clone = this.clone.bind(c), c;
            }
          };
          return this.materials.push(r), r;
        },
        currentMaterial: function() {
          if (this.materials.length > 0)
            return this.materials[this.materials.length - 1];
        },
        _finalize: function(n) {
          const i = this.currentMaterial();
          if (i && i.groupEnd === -1 && (i.groupEnd = this.geometry.vertices.length / 3, i.groupCount = i.groupEnd - i.groupStart, i.inherited = !1), n && this.materials.length > 1)
            for (let o = this.materials.length - 1; o >= 0; o--)
              this.materials[o].groupCount <= 0 && this.materials.splice(o, 1);
          return n && this.materials.length === 0 && this.materials.push({
            name: "",
            smooth: this.smooth
          }), i;
        }
      }, s && s.name && typeof s.clone == "function") {
        const n = s.clone(0);
        n.inherited = !0, this.object.materials.push(n);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
    },
    parseVertexIndex: function(e, t) {
      const s = parseInt(e, 10);
      return (s >= 0 ? s - 1 : s + t / 3) * 3;
    },
    parseNormalIndex: function(e, t) {
      const s = parseInt(e, 10);
      return (s >= 0 ? s - 1 : s + t / 3) * 3;
    },
    parseUVIndex: function(e, t) {
      const s = parseInt(e, 10);
      return (s >= 0 ? s - 1 : s + t / 2) * 2;
    },
    addVertex: function(e, t, s) {
      const n = this.vertices, i = this.object.geometry.vertices;
      i.push(n[e + 0], n[e + 1], n[e + 2]), i.push(n[t + 0], n[t + 1], n[t + 2]), i.push(n[s + 0], n[s + 1], n[s + 2]);
    },
    addVertexPoint: function(e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addVertexLine: function(e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addNormal: function(e, t, s) {
      const n = this.normals, i = this.object.geometry.normals;
      i.push(n[e + 0], n[e + 1], n[e + 2]), i.push(n[t + 0], n[t + 1], n[t + 2]), i.push(n[s + 0], n[s + 1], n[s + 2]);
    },
    addFaceNormal: function(e, t, s) {
      const n = this.vertices, i = this.object.geometry.normals;
      co.fromArray(n, e), Ls.fromArray(n, t), lo.fromArray(n, s), lt.subVectors(lo, Ls), ho.subVectors(co, Ls), lt.cross(ho), lt.normalize(), i.push(lt.x, lt.y, lt.z), i.push(lt.x, lt.y, lt.z), i.push(lt.x, lt.y, lt.z);
    },
    addColor: function(e, t, s) {
      const n = this.colors, i = this.object.geometry.colors;
      n[e] !== void 0 && i.push(n[e + 0], n[e + 1], n[e + 2]), n[t] !== void 0 && i.push(n[t + 0], n[t + 1], n[t + 2]), n[s] !== void 0 && i.push(n[s + 0], n[s + 1], n[s + 2]);
    },
    addUV: function(e, t, s) {
      const n = this.uvs, i = this.object.geometry.uvs;
      i.push(n[e + 0], n[e + 1]), i.push(n[t + 0], n[t + 1]), i.push(n[s + 0], n[s + 1]);
    },
    addDefaultUV: function() {
      const e = this.object.geometry.uvs;
      e.push(0, 0), e.push(0, 0), e.push(0, 0);
    },
    addUVLine: function(e) {
      const t = this.uvs;
      this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
    },
    addFace: function(e, t, s, n, i, o, r, a, c) {
      const l = this.vertices.length;
      let h = this.parseVertexIndex(e, l), g = this.parseVertexIndex(t, l), d = this.parseVertexIndex(s, l);
      if (this.addVertex(h, g, d), this.addColor(h, g, d), r !== void 0 && r !== "") {
        const f = this.normals.length;
        h = this.parseNormalIndex(r, f), g = this.parseNormalIndex(a, f), d = this.parseNormalIndex(c, f), this.addNormal(h, g, d);
      } else
        this.addFaceNormal(h, g, d);
      if (n !== void 0 && n !== "") {
        const f = this.uvs.length;
        h = this.parseUVIndex(n, f), g = this.parseUVIndex(i, f), d = this.parseUVIndex(o, f), this.addUV(h, g, d), this.object.geometry.hasUVIndices = !0;
      } else
        this.addDefaultUV();
    },
    addPointGeometry: function(e) {
      this.object.geometry.type = "Points";
      const t = this.vertices.length;
      for (let s = 0, n = e.length; s < n; s++) {
        const i = this.parseVertexIndex(e[s], t);
        this.addVertexPoint(i), this.addColor(i);
      }
    },
    addLineGeometry: function(e, t) {
      this.object.geometry.type = "Line";
      const s = this.vertices.length, n = this.uvs.length;
      for (let i = 0, o = e.length; i < o; i++)
        this.addVertexLine(this.parseVertexIndex(e[i], s));
      for (let i = 0, o = t.length; i < o; i++)
        this.addUVLine(this.parseUVIndex(t[i], n));
    }
  };
  return A.startObject("", !1), A;
}
class Gh extends kt {
  constructor(e) {
    super(e), this.materials = null, this.materialsLoader = new ol(e);
  }
  load(e, t, s, n) {
    const i = this, o = new It(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, async function(r) {
      try {
        const a = i.parse(r, !0);
        for (let c = 0, l = a.materialLibraries.length; c < l; c++) {
          const h = a.materialLibraries[c], g = e.startsWith("blob:") ? e + "/" + h : new URL(h, e);
          console.debug("Loading MTL file: " + g), await new Promise((d, f) => {
            i.materialsLoader.load(g.toString(), (I) => {
              i.setMaterials(I), d();
            }, null, f);
          });
        }
        t(i.createObjects(a));
      } catch (a) {
        n ? n(a) : console.error(a), i.manager.itemError(e);
      }
    }, s, n);
  }
  setMTLLoader(e) {
    return this.materialsLoader = e, this;
  }
  setMaterials(e) {
    return this.materials = e, this;
  }
  parse(e, t = !1) {
    const s = new hl();
    e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
    const n = e.split(`
`);
    let i = [];
    for (let o = 0, r = n.length; o < r; o++) {
      const a = n[o].trimStart();
      if (a.length === 0) continue;
      const c = a.charAt(0);
      if (c !== "#")
        if (c === "v") {
          const l = a.split(Ao);
          switch (l[0]) {
            case "v":
              s.vertices.push(
                parseFloat(l[1]),
                parseFloat(l[2]),
                parseFloat(l[3])
              ), l.length >= 7 ? (Zn.setRGB(
                parseFloat(l[4]),
                parseFloat(l[5]),
                parseFloat(l[6]),
                ge
              ), s.colors.push(Zn.r, Zn.g, Zn.b)) : s.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              s.normals.push(
                parseFloat(l[1]),
                parseFloat(l[2]),
                parseFloat(l[3])
              );
              break;
            case "vt":
              s.uvs.push(
                parseFloat(l[1]),
                parseFloat(l[2])
              );
              break;
          }
        } else if (c === "f") {
          const h = a.slice(1).trim().split(Ao), g = [];
          for (let f = 0, I = h.length; f < I; f++) {
            const m = h[f];
            if (m.length > 0) {
              const C = m.split("/");
              g.push(C);
            }
          }
          const d = g[0];
          for (let f = 1, I = g.length - 1; f < I; f++) {
            const m = g[f], C = g[f + 1];
            s.addFace(
              d[0],
              m[0],
              C[0],
              d[1],
              m[1],
              C[1],
              d[2],
              m[2],
              C[2]
            );
          }
        } else if (c === "l") {
          const l = a.substring(1).trim().split(" ");
          let h = [];
          const g = [];
          if (a.indexOf("/") === -1)
            h = l;
          else
            for (let d = 0, f = l.length; d < f; d++) {
              const I = l[d].split("/");
              I[0] !== "" && h.push(I[0]), I[1] !== "" && g.push(I[1]);
            }
          s.addLineGeometry(h, g);
        } else if (c === "p") {
          const h = a.slice(1).trim().split(" ");
          s.addPointGeometry(h);
        } else if ((i = al.exec(a)) !== null) {
          const l = (" " + i[0].slice(1).trim()).slice(1);
          s.startObject(l);
        } else if (cl.test(a))
          s.object.startMaterial(a.substring(7).trim(), s.materialLibraries);
        else if (Al.test(a))
          s.materialLibraries.push(a.substring(7).trim());
        else if (ll.test(a))
          console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
        else if (c === "s") {
          if (i = a.split(" "), i.length > 1) {
            const h = i[1].trim().toLowerCase();
            s.object.smooth = h !== "0" && h !== "off";
          } else
            s.object.smooth = !0;
          const l = s.object.currentMaterial();
          l && (l.smooth = s.object.smooth);
        } else {
          if (a === "\0") continue;
          console.warn('THREE.OBJLoader: Unexpected line: "' + a + '"');
        }
    }
    return s.finalize(), t ? s : this.createObjects(s);
  }
  createObjects(e) {
    const t = new nn();
    if (t.materialLibraries = [].concat(e.materialLibraries), !(e.objects.length === 1 && e.objects[0].geometry.vertices.length === 0) === !0)
      for (let n = 0, i = e.objects.length; n < i; n++) {
        const o = e.objects[n], r = o.geometry, a = o.materials, c = r.type === "Line", l = r.type === "Points";
        let h = !1;
        if (r.vertices.length === 0) continue;
        const g = new ut();
        g.setAttribute("position", new Fe(r.vertices, 3)), r.normals.length > 0 && g.setAttribute("normal", new Fe(r.normals, 3)), r.colors.length > 0 && (h = !0, g.setAttribute("color", new Fe(r.colors, 3))), r.hasUVIndices === !0 && g.setAttribute("uv", new Fe(r.uvs, 2));
        const d = [];
        for (let I = 0, m = a.length; I < m; I++) {
          const C = a[I], w = C.name + "_" + C.smooth + "_" + h;
          let b = e.materials[w];
          if (this.materials !== null) {
            if (b = this.materials.create(C.name), c && b && !(b instanceof Ft)) {
              const B = new Ft();
              en.prototype.copy.call(B, b), B.color.copy(b.color), b = B;
            } else if (l && b && !(b instanceof _n)) {
              const B = new _n({ size: 10, sizeAttenuation: !1 });
              en.prototype.copy.call(B, b), B.color.copy(b.color), B.map = b.map, b = B;
            }
          }
          b === void 0 && (c ? b = new Ft() : l ? b = new _n({ size: 1, sizeAttenuation: !1 }) : b = new Pn(), b.name = C.name, b.flatShading = !C.smooth, b.vertexColors = h, e.materials[w] = b), d.push(b);
        }
        let f;
        if (d.length > 1) {
          for (let I = 0, m = a.length; I < m; I++) {
            const C = a[I];
            g.addGroup(C.groupStart, C.groupCount, I);
          }
          c ? f = new hs(g, d) : l ? f = new is(g, d) : f = new q(g, d);
        } else
          c ? f = new hs(g, d[0]) : l ? f = new is(g, d[0]) : f = new q(g, d[0]);
        f.name = o.name, t.add(f);
      }
    else if (e.vertices.length > 0) {
      const n = new _n({ size: 1, sizeAttenuation: !1 }), i = new ut();
      i.setAttribute("position", new Fe(e.vertices, 3)), e.colors.length > 0 && e.colors[0] !== void 0 && (i.setAttribute("color", new Fe(e.colors, 3)), n.vertexColors = !0);
      const o = new is(i, n);
      t.add(o);
    }
    return t;
  }
}
const uo = { type: "change" }, xi = { type: "start" }, _r = { type: "end" }, ul = { type: "endMovement" }, $n = new Ya(), go = new Ka(), gl = Math.cos(70 * Qe.DEG2RAD), Me = new P();
new P();
const Ke = 2 * Math.PI, de = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, Xt = 1e-6;
let Ph = class extends Yo {
  constructor(e, t = null) {
    super(e, t), this.state = de.NONE, this.enabled = !0, this.target = new P(), this.cursor = new P(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: fn.ROTATE, MIDDLE: fn.DOLLY, RIGHT: fn.PAN }, this.touches = { ONE: pn.ROTATE, TWO: pn.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new P(), this._lastQuaternion = new Te(), this._lastTargetPosition = new P(), this._quat = new Te().setFromUnitVectors(e.up, new P(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new Li(), this._sphericalDelta = new Li(), this._scale = 1, this._currentScale = 1, this._panOffset = new P(), this._rotateStart = new Le(), this._rotateEnd = new Le(), this._rotateDelta = new Le(), this._panStart = new Le(), this._panEnd = new Le(), this._panDelta = new Le(), this._dollyStart = new Le(), this._dollyEnd = new Le(), this._dollyDelta = new Le(), this._dollyDirection = new P(), this._mouse = new Le(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._lastIsDamping = !1, this._isDamping = !1, this._onPointerMove = pl.bind(this), this._onPointerDown = dl.bind(this), this._onPointerUp = fl.bind(this), this._onContextMenu = wl.bind(this), this._onMouseWheel = El.bind(this), this._onKeyDown = bl.bind(this), this._onTouchStart = Cl.bind(this), this._onTouchMove = Bl.bind(this), this._onMouseDown = Il.bind(this), this._onMouseMove = ml.bind(this), this._interceptControlDown = yl.bind(this), this._interceptControlUp = Ql.bind(this), this.domElement !== null && this.connect(), this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(uo), this.update(), this.state = de.NONE, this._isDamping = !1;
  }
  update(e = null) {
    if (this.enableDamping && e === null) return;
    const t = this.object.getWorldPosition(this.object.position);
    Me.copy(t).sub(this.target), Me.applyQuaternion(this._quat), this._spherical.setFromVector3(Me), this.autoRotate && this.state === de.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let s = this.minAzimuthAngle, n = this.maxAzimuthAngle;
    isFinite(s) && isFinite(n) && (s < -Math.PI ? s += Ke : s > Math.PI && (s -= Ke), n < -Math.PI ? n += Ke : n > Math.PI && (n -= Ke), s <= n ? this._spherical.theta = Math.max(s, Math.min(n, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (s + n) / 2 ? Math.max(s, this._spherical.theta) : Math.min(n, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let i = !1;
    if (this.enableDamping ? this._currentScale = Qe.lerp(this._currentScale, this._scale, this.dampingFactor) : this._currentScale = this._scale, this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._currentScale), i = Math.abs(o - this._spherical.radius) > Xt * 100;
    }
    if (Me.setFromSpherical(this._spherical), Me.applyQuaternion(this._quatInverse), t.copy(this.target).add(Me), this.object.parent ? this.object.parent.worldToLocal(t) : this.object.position.copy(t), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const r = Me.length();
        o = this._clampDistance(r * this._currentScale);
        const a = r - o;
        this.object.position.addScaledVector(this._dollyDirection, a), this.object.updateMatrixWorld(), i = Math.abs(a) > Xt;
      } else if (this.object.isOrthographicCamera) {
        const r = new P(this._mouse.x, this._mouse.y, 0);
        r.unproject(this.object);
        const a = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._currentScale)), this.object.updateProjectionMatrix(), i = Math.abs(a - this.object.zoom) > Xt;
        const c = new P(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object), this.object.position.sub(c).add(r), this.object.updateMatrixWorld(), o = Me.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : ($n.origin.copy(this.object.position), $n.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot($n.direction)) < gl ? this.object.lookAt(this.target) : (go.setFromNormalAndCoplanarPoint(this.object.up, this.target), $n.intersectPlane(go, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), Math.abs(o - this.object.zoom) > Xt && (this.object.updateProjectionMatrix(), i = !0);
    }
    return this._scale = 1, i || this._lastPosition.distanceToSquared(this.object.position) > Xt || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Xt || this._lastTargetPosition.distanceToSquared(this.target) > Xt ? (this.dispatchEvent(uo), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), this._lastIsDamping = !0, this._isDamping = !0, !0) : (this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), this.state === de.NONE && (this._lastIsDamping = this._isDamping, this._isDamping = !1), this._lastIsDamping && !this._isDamping && this.state === de.NONE && (this._isDamping = !1, this._lastIsDamping = !1, this.dispatchEvent(ul)), this._performCursorZoom = !1, !1);
  }
  _getAutoRotationAngle(e) {
    return e !== null ? Ke / 60 * this.autoRotateSpeed * e : Ke / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const t = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * t);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, t) {
    Me.setFromMatrixColumn(t, 0), Me.multiplyScalar(-e), this._panOffset.add(Me);
  }
  _panUp(e, t) {
    this.screenSpacePanning === !0 ? Me.setFromMatrixColumn(t, 1) : (Me.setFromMatrixColumn(t, 0), Me.crossVectors(this.object.up, Me)), Me.multiplyScalar(e), this._panOffset.add(Me);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, t) {
    const s = this.domElement;
    if (this.object.isPerspectiveCamera) {
      this.object.getWorldPosition(Me).sub(this.target);
      let n = Me.length();
      n *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * n / s.clientHeight, this.object.matrixWorld), this._panUp(2 * t * n / s.clientHeight, this.object.matrixWorld);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / s.clientWidth, this.object.matrixWorld), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / s.clientHeight, this.object.matrixWorld)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, t) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const s = this.domElement.getBoundingClientRect(), n = e - s.left, i = t - s.top, o = s.width, r = s.height;
    this._mouse.x = n / o * 2 - 1, this._mouse.y = -(i / r) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(Ke * this._rotateDelta.x / t.clientHeight), this._rotateUp(Ke * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let t = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Ke * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed), t = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Ke * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed), t = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Ke * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0), t = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Ke * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0), t = !0;
        break;
    }
    t && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._rotateStart.set(s, n);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._panStart.set(s, n);
    }
  }
  _handleTouchStartDolly(e) {
    const t = this._getSecondPointerPosition(e), s = e.pageX - t.x, n = e.pageY - t.y, i = Math.sqrt(s * s + n * n);
    this._dollyStart.set(0, i);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const s = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + s.x), i = 0.5 * (e.pageY + s.y);
      this._rotateEnd.set(n, i);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(Ke * this._rotateDelta.x / t.clientHeight), this._rotateUp(Ke * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._panEnd.set(s, n);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const t = this._getSecondPointerPosition(e), s = e.pageX - t.x, n = e.pageY - t.y, i = Math.sqrt(s * s + n * n);
    this._dollyEnd.set(0, i), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + t.x) * 0.5, r = (e.pageY + t.y) * 0.5;
    this._updateZoomParameters(o, r);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) {
        this._pointers.splice(t, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && (t = new Le(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t];
  }
  //
  _customWheelEvent(e) {
    const t = e.deltaMode, s = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (t) {
      case 1:
        s.deltaY *= 16;
        break;
      case 2:
        s.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (s.deltaY *= 10), s;
  }
};
function dl(A) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(A.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), window.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(A) && (this._addPointer(A), A.pointerType === "touch" ? this._onTouchStart(A) : this._onMouseDown(A)));
}
function pl(A) {
  this.enabled !== !1 && (A.pointerType === "touch" ? this._onTouchMove(A) : this._onMouseMove(A));
}
function fl(A) {
  switch (this._removePointer(A), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(A.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), window.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(_r), this.state = de.NONE;
      break;
    case 1:
      const e = this._pointers[0], t = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: t.x, pageY: t.y });
      break;
  }
}
function Il(A) {
  let e;
  switch (A.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case fn.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(A), this.state = de.DOLLY;
      break;
    case fn.ROTATE:
      if (A.ctrlKey || A.metaKey || A.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(A), this.state = de.PAN;
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(A), this.state = de.ROTATE;
      }
      break;
    case fn.PAN:
      if (A.ctrlKey || A.metaKey || A.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(A), this.state = de.ROTATE;
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(A), this.state = de.PAN;
      }
      break;
    default:
      this.state = de.NONE;
  }
  this.state !== de.NONE && this.dispatchEvent(xi);
}
function ml(A) {
  switch (this.state) {
    case de.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(A);
      break;
    case de.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(A);
      break;
    case de.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(A);
      break;
  }
}
function El(A) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== de.NONE || (A.preventDefault(), this.dispatchEvent(xi), this._handleMouseWheel(this._customWheelEvent(A)), this.dispatchEvent(_r));
}
function bl(A) {
  this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(A);
}
function Cl(A) {
  switch (this._trackPointer(A), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case pn.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(A), this.state = de.TOUCH_ROTATE;
          break;
        case pn.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(A), this.state = de.TOUCH_PAN;
          break;
        default:
          this.state = de.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case pn.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(A), this.state = de.TOUCH_DOLLY_PAN;
          break;
        case pn.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(A), this.state = de.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = de.NONE;
      }
      break;
    default:
      this.state = de.NONE;
  }
  this.state !== de.NONE && this.dispatchEvent(xi);
}
function Bl(A) {
  switch (this._trackPointer(A), this.state) {
    case de.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(A), this.update();
      break;
    case de.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(A), this.update();
      break;
    case de.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(A), this.update();
      break;
    case de.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(A), this.update();
      break;
    default:
      this.state = de.NONE;
  }
}
function wl(A) {
  this.enabled !== !1 && A.preventDefault();
}
function yl(A) {
  A.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function Ql(A) {
  A.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
class Hh extends pt {
  constructor(e, t = 1, s = 16, n = 2) {
    const i = new ut(), o = s + n * 2, r = new Float32Array((o * 3 + 3) * 3);
    i.setAttribute("position", new st(r, 3));
    const a = new Ft({ color: 65280 }), c = new Ft({ color: 16776960 });
    super(i, [c, a]), this.audio = e, this.range = t, this.divisionsInnerAngle = s, this.divisionsOuterAngle = n, this.type = "PositionalAudioHelper", this.update();
  }
  update() {
    const e = this.audio, t = this.range, s = this.divisionsInnerAngle, n = this.divisionsOuterAngle, i = Qe.degToRad(e.panner.coneInnerAngle), o = Qe.degToRad(e.panner.coneOuterAngle), r = i / 2, a = o / 2;
    let c = 0, l = 0, h, g;
    const d = this.geometry, f = d.attributes.position;
    d.clearGroups();
    function I(m, C, w, b) {
      const B = (C - m) / w;
      for (f.setXYZ(c, 0, 0, 0), l++, h = m; h < C; h += B)
        g = c + l, f.setXYZ(g, Math.sin(h) * t, 0, Math.cos(h) * t), f.setXYZ(g + 1, Math.sin(Math.min(h + B, C)) * t, 0, Math.cos(Math.min(h + B, C)) * t), f.setXYZ(g + 2, 0, 0, 0), l += 3;
      d.addGroup(c, l, b), c += l, l = 0;
    }
    I(-a, -r, n, 0), I(-r, r, s, 1), I(r, a, n, 0), f.needsUpdate = !0, i === o && (this.material[0].visible = !1);
  }
  dispose() {
    this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose();
  }
}
const jh = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, qh = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};
let vn, Ns, hn, es;
function Us(A, e = 1 / 0, t = null) {
  Ns || (Ns = new Ci(2, 2, 1, 1)), hn || (hn = new Vo({
    uniforms: { blitTexture: new Ja(A) },
    vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
    fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
  })), hn.uniforms.blitTexture.value = A, hn.defines.IS_SRGB = A.colorSpace == ge, hn.needsUpdate = !0, es || (es = new q(Ns, hn), es.frustumCulled = !1);
  const s = new gs(), n = new ti();
  n.add(es), t === null && (t = vn = new Va({ antialias: !1 }));
  const i = Math.min(A.image.width, e), o = Math.min(A.image.height, e);
  t.setSize(i, o), t.clear(), t.render(n, s);
  const r = document.createElement("canvas"), a = r.getContext("2d");
  r.width = i, r.height = o, a.drawImage(t.domElement, 0, 0, i, o);
  const c = new Wo(r);
  return c.minFilter = A.minFilter, c.magFilter = A.magFilter, c.wrapS = A.wrapS, c.wrapT = A.wrapT, c.colorSpace = A.colorSpace, c.name = A.name, vn && (vn.forceContextLoss(), vn.dispose(), vn = null), c;
}
const po = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: [
    "byte normalized",
    "short normalized"
  ],
  TANGENT: [
    "byte normalized",
    "short normalized"
  ],
  TEXCOORD: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "short",
    "short normalized",
    "unsigned short"
  ]
};
class Mr {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new kl(e);
    }), this.register(function(e) {
      return new Ll(e);
    }), this.register(function(e) {
      return new Pl(e);
    }), this.register(function(e) {
      return new Ol(e);
    }), this.register(function(e) {
      return new Hl(e);
    }), this.register(function(e) {
      return new jl(e);
    }), this.register(function(e) {
      return new Nl(e);
    }), this.register(function(e) {
      return new Ul(e);
    }), this.register(function(e) {
      return new Gl(e);
    }), this.register(function(e) {
      return new ql(e);
    }), this.register(function(e) {
      return new zl(e);
    }), this.register(function(e) {
      return new Yl(e);
    }), this.register(function(e) {
      return new Kl(e);
    }), this.register(function(e) {
      return new Jl(e);
    });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(e, t, s, n) {
    const i = new Fl(), o = [];
    for (let r = 0, a = this.pluginCallbacks.length; r < a; r++)
      o.push(this.pluginCallbacks[r](i));
    i.setPlugins(o), i.write(e, t, n).catch(s);
  }
  parseAsync(e, t) {
    const s = this;
    return new Promise(function(n, i) {
      s.parse(e, n, i, t);
    });
  }
}
const Ae = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, Gs = "KHR_mesh_quantization", ot = {};
ot[cs] = Ae.NEAREST;
ot[pi] = Ae.NEAREST_MIPMAP_NEAREST;
ot[Mo] = Ae.NEAREST_MIPMAP_LINEAR;
ot[rt] = Ae.LINEAR;
ot[Fo] = Ae.LINEAR_MIPMAP_NEAREST;
ot[jn] = Ae.LINEAR_MIPMAP_LINEAR;
ot[ls] = Ae.CLAMP_TO_EDGE;
ot[on] = Ae.REPEAT;
ot[ko] = Ae.MIRRORED_REPEAT;
const fo = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, xl = new Se(), Io = 12, Sl = 1179937895, Tl = 2, mo = 8, vl = 1313821514, Dl = 5130562;
function Nn(A, e) {
  return A.length === e.length && A.every(function(t, s) {
    return t === e[s];
  });
}
function Rl(A) {
  return new TextEncoder().encode(A).buffer;
}
function _l(A) {
  return Nn(A.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function Ml(A, e, t) {
  const s = {
    min: new Array(A.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(A.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let n = e; n < e + t; n++)
    for (let i = 0; i < A.itemSize; i++) {
      let o;
      A.itemSize > 4 ? o = A.array[n * A.itemSize + i] : (i === 0 ? o = A.getX(n) : i === 1 ? o = A.getY(n) : i === 2 ? o = A.getZ(n) : i === 3 && (o = A.getW(n)), A.normalized === !0 && (o = Qe.normalize(o, A.array))), s.min[i] = Math.min(s.min[i], o), s.max[i] = Math.max(s.max[i], o);
    }
  return s;
}
function Fr(A) {
  return Math.ceil(A / 4) * 4;
}
function Ps(A, e = 0) {
  const t = Fr(A.byteLength);
  if (t !== A.byteLength) {
    const s = new Uint8Array(t);
    if (s.set(new Uint8Array(A)), e !== 0)
      for (let n = A.byteLength; n < t; n++)
        s[n] = e;
    return s.buffer;
  }
  return A;
}
function Eo() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function bo(A, e) {
  if (A.toBlob !== void 0)
    return new Promise((s) => A.toBlob(s, e));
  let t;
  return e === "image/jpeg" ? t = 0.92 : e === "image/webp" && (t = 0.8), A.convertToBlob({
    type: e,
    quality: t
  });
}
class Fl {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter r" + Wa
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(e, t, s = {}) {
    this.options = Object.assign({
      // default options
      binary: !1,
      trs: !1,
      onlyVisible: !0,
      maxTextureSize: 1 / 0,
      animations: [],
      includeCustomExtensions: !1
    }, s), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
    const n = this, i = n.buffers, o = n.json;
    s = n.options;
    const r = n.extensionsUsed, a = n.extensionsRequired, c = new Blob(i, { type: "application/octet-stream" }), l = Object.keys(r), h = Object.keys(a);
    if (l.length > 0 && (o.extensionsUsed = l), h.length > 0 && (o.extensionsRequired = h), o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = c.size), s.binary === !0) {
      const g = new FileReader();
      g.readAsArrayBuffer(c), g.onloadend = function() {
        const d = Ps(g.result), f = new DataView(new ArrayBuffer(mo));
        f.setUint32(0, d.byteLength, !0), f.setUint32(4, Dl, !0);
        const I = Ps(Rl(JSON.stringify(o)), 32), m = new DataView(new ArrayBuffer(mo));
        m.setUint32(0, I.byteLength, !0), m.setUint32(4, vl, !0);
        const C = new ArrayBuffer(Io), w = new DataView(C);
        w.setUint32(0, Sl, !0), w.setUint32(4, Tl, !0);
        const b = Io + m.byteLength + I.byteLength + f.byteLength + d.byteLength;
        w.setUint32(8, b, !0);
        const B = new Blob([
          C,
          m,
          I,
          f,
          d
        ], { type: "application/octet-stream" }), Q = new FileReader();
        Q.readAsArrayBuffer(B), Q.onloadend = function() {
          t(Q.result);
        };
      };
    } else if (o.buffers && o.buffers.length > 0) {
      const g = new FileReader();
      g.readAsDataURL(c), g.onloadend = function() {
        const d = g.result;
        o.buffers[0].uri = d, t(o);
      };
    } else
      t(o);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(e, t) {
    if (Object.keys(e.userData).length === 0) return;
    const s = this.options, n = this.extensionsUsed;
    try {
      const i = JSON.parse(JSON.stringify(e.userData));
      if (s.includeCustomExtensions && i.gltfExtensions) {
        t.extensions === void 0 && (t.extensions = {});
        for (const o in i.gltfExtensions)
          t.extensions[o] = i.gltfExtensions[o], n[o] = !0;
        delete i.gltfExtensions;
      }
      Object.keys(i).length > 0 && (t.extras = i);
    } catch (i) {
      console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + i.message);
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(e, t = !1) {
    if (this.uids.has(e) === !1) {
      const n = /* @__PURE__ */ new Map();
      n.set(!0, this.uid++), n.set(!1, this.uid++), this.uids.set(e, n);
    }
    return this.uids.get(e).get(t);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e)) return !1;
    const s = new P();
    for (let n = 0, i = e.count; n < i; n++)
      if (Math.abs(s.fromBufferAttribute(e, n).length() - 1) > 5e-4) return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(e) {
    const t = this.cache;
    if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
    const s = e.clone(), n = new P();
    for (let i = 0, o = s.count; i < o; i++)
      n.fromBufferAttribute(s, i), n.x === 0 && n.y === 0 && n.z === 0 ? n.setX(1) : n.normalize(), s.setXYZ(i, n.x, n.y, n.z);
    return t.attributesNormalized.set(e, s), s;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(e, t) {
    let s = !1;
    const n = {};
    (t.offset.x !== 0 || t.offset.y !== 0) && (n.offset = t.offset.toArray(), s = !0), t.rotation !== 0 && (n.rotation = t.rotation, s = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (n.scale = t.repeat.toArray(), s = !0), s && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = n, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(e, t) {
    if (e === t) return e;
    function s(d) {
      return d.colorSpace === ge ? function(I) {
        return I < 0.04045 ? I * 0.0773993808 : Math.pow(I * 0.9478672986 + 0.0521327014, 2.4);
      } : function(I) {
        return I;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof Gn && (e = Us(e)), t instanceof Gn && (t = Us(t));
    const n = e ? e.image : null, i = t ? t.image : null, o = Math.max(n ? n.width : 0, i ? i.width : 0), r = Math.max(n ? n.height : 0, i ? i.height : 0), a = Eo();
    a.width = o, a.height = r;
    const c = a.getContext("2d", {
      willReadFrequently: !0
    });
    c.fillStyle = "#00ffff", c.fillRect(0, 0, o, r);
    const l = c.getImageData(0, 0, o, r);
    if (n) {
      c.drawImage(n, 0, 0, o, r);
      const d = s(e), f = c.getImageData(0, 0, o, r).data;
      for (let I = 2; I < f.length; I += 4)
        l.data[I] = d(f[I] / 256) * 256;
    }
    if (i) {
      c.drawImage(i, 0, 0, o, r);
      const d = s(t), f = c.getImageData(0, 0, o, r).data;
      for (let I = 1; I < f.length; I += 4)
        l.data[I] = d(f[I] / 256) * 256;
    }
    c.putImageData(l, 0, 0);
    const g = (e || t).clone();
    return g.source = new Xa(a), g.colorSpace = us, g.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), g;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(e) {
    const t = this.json, s = this.buffers;
    return t.buffers || (t.buffers = [{ byteLength: 0 }]), s.push(e), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(e, t, s, n, i) {
    const o = this.json;
    o.bufferViews || (o.bufferViews = []);
    let r;
    switch (t) {
      case Ae.BYTE:
      case Ae.UNSIGNED_BYTE:
        r = 1;
        break;
      case Ae.SHORT:
      case Ae.UNSIGNED_SHORT:
        r = 2;
        break;
      default:
        r = 4;
    }
    let a = e.itemSize * r;
    i === Ae.ARRAY_BUFFER && (a = Math.ceil(a / 4) * 4);
    const c = Fr(n * a), l = new DataView(new ArrayBuffer(c));
    let h = 0;
    for (let f = s; f < s + n; f++) {
      for (let I = 0; I < e.itemSize; I++) {
        let m;
        e.itemSize > 4 ? m = e.array[f * e.itemSize + I] : (I === 0 ? m = e.getX(f) : I === 1 ? m = e.getY(f) : I === 2 ? m = e.getZ(f) : I === 3 && (m = e.getW(f)), e.normalized === !0 && (m = Qe.normalize(m, e.array))), t === Ae.FLOAT ? l.setFloat32(h, m, !0) : t === Ae.INT ? l.setInt32(h, m, !0) : t === Ae.UNSIGNED_INT ? l.setUint32(h, m, !0) : t === Ae.SHORT ? l.setInt16(h, m, !0) : t === Ae.UNSIGNED_SHORT ? l.setUint16(h, m, !0) : t === Ae.BYTE ? l.setInt8(h, m) : t === Ae.UNSIGNED_BYTE && l.setUint8(h, m), h += r;
      }
      h % a !== 0 && (h += a - h % a);
    }
    const g = {
      buffer: this.processBuffer(l.buffer),
      byteOffset: this.byteOffset,
      byteLength: c
    };
    return i !== void 0 && (g.target = i), i === Ae.ARRAY_BUFFER && (g.byteStride = a), this.byteOffset += c, o.bufferViews.push(g), {
      id: o.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(e) {
    const t = this, s = t.json;
    return s.bufferViews || (s.bufferViews = []), new Promise(function(n) {
      const i = new FileReader();
      i.readAsArrayBuffer(e), i.onloadend = function() {
        const o = Ps(i.result), r = {
          buffer: t.processBuffer(o),
          byteOffset: t.byteOffset,
          byteLength: o.byteLength
        };
        t.byteOffset += o.byteLength, n(s.bufferViews.push(r) - 1);
      };
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer|undefined} start (Optional)
   * @param  {Integer|undefined} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(e, t, s, n) {
    const i = this.json, o = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let r;
    if (e.array.constructor === Float32Array)
      r = Ae.FLOAT;
    else if (e.array.constructor === Int32Array)
      r = Ae.INT;
    else if (e.array.constructor === Uint32Array)
      r = Ae.UNSIGNED_INT;
    else if (e.array.constructor === Int16Array)
      r = Ae.SHORT;
    else if (e.array.constructor === Uint16Array)
      r = Ae.UNSIGNED_SHORT;
    else if (e.array.constructor === Int8Array)
      r = Ae.BYTE;
    else if (e.array.constructor === Uint8Array)
      r = Ae.UNSIGNED_BYTE;
    else
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name);
    if (s === void 0 && (s = 0), (n === void 0 || n === 1 / 0) && (n = e.count), n === 0) return null;
    const a = Ml(e, s, n);
    let c;
    t !== void 0 && (c = e === t.index ? Ae.ELEMENT_ARRAY_BUFFER : Ae.ARRAY_BUFFER);
    const l = this.processBufferView(e, r, s, n, c), h = {
      bufferView: l.id,
      byteOffset: l.byteOffset,
      componentType: r,
      count: n,
      max: a.max,
      min: a.min,
      type: o[e.itemSize]
    };
    return e.normalized === !0 && (h.normalized = !0), i.accessors || (i.accessors = []), i.accessors.push(h) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(e, t, s, n = "image/png") {
    if (e !== null) {
      const i = this, o = i.cache, r = i.json, a = i.options, c = i.pending;
      o.images.has(e) || o.images.set(e, {});
      const l = o.images.get(e), h = n + ":flipY/" + s.toString();
      if (l[h] !== void 0) return l[h];
      r.images || (r.images = []);
      const g = { mimeType: n }, d = Eo();
      d.width = Math.min(e.width, a.maxTextureSize), d.height = Math.min(e.height, a.maxTextureSize);
      const f = d.getContext("2d", {
        willReadFrequently: !0
      });
      if (s === !0 && (f.translate(0, d.height), f.scale(1, -1)), e.data !== void 0) {
        t !== zt && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > a.maxTextureSize || e.height > a.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const m = new Uint8ClampedArray(e.height * e.width * 4);
        for (let C = 0; C < m.length; C += 4)
          m[C + 0] = e.data[C + 0], m[C + 1] = e.data[C + 1], m[C + 2] = e.data[C + 2], m[C + 3] = e.data[C + 3];
        f.putImageData(new ImageData(m, e.width, e.height), 0, 0);
      } else if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas)
        f.drawImage(e, 0, 0, d.width, d.height);
      else
        throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");
      a.binary === !0 ? c.push(
        bo(d, n).then((m) => i.processBufferViewImage(m)).then((m) => {
          g.bufferView = m;
        })
      ) : d.toDataURL !== void 0 ? g.uri = d.toDataURL(n) : c.push(
        bo(d, n).then((m) => new FileReader().readAsDataURL(m)).then((m) => {
          g.uri = m;
        })
      );
      const I = r.images.push(g) - 1;
      return l[h] = I, I;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(e) {
    const t = this.json;
    t.samplers || (t.samplers = []);
    const s = {
      magFilter: ot[e.magFilter],
      minFilter: ot[e.minFilter],
      wrapS: ot[e.wrapS],
      wrapT: ot[e.wrapT]
    };
    return t.samplers.push(s) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(e) {
    const s = this.options, n = this.cache, i = this.json;
    if (n.textures.has(e)) return n.textures.get(e);
    const o = { keep: !0, newTexture: null };
    if (this._invokeAll(function(l) {
      l.beforeWriteTexture && l.beforeWriteTexture(e, o);
    }), o.keep === !1) return null;
    o.newTexture != null && (e = o.newTexture), i.textures || (i.textures = []), e instanceof Gn && (e = Us(e, s.maxTextureSize));
    let r = e.userData.mimeType;
    r === "image/webp" && (r = "image/png");
    const a = {
      sampler: this.processSampler(e),
      source: this.processImage(e.image, e.format, e.flipY, r)
    };
    e.name && (a.name = e.name), this._invokeAll(function(l) {
      l.writeTexture && l.writeTexture(e, a);
    });
    const c = i.textures.push(a) - 1;
    return n.textures.set(e, c), c;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(e) {
    const t = this.cache, s = this.json;
    if (t.materials.has(e)) return t.materials.get(e);
    if (e.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    s.materials || (s.materials = []);
    const n = { pbrMetallicRoughness: {} };
    e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const i = e.color.toArray().concat([e.opacity]);
    Nn(i, [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (n.pbrMetallicRoughness.metallicFactor = e.metalness, n.pbrMetallicRoughness.roughnessFactor = e.roughness) : (n.pbrMetallicRoughness.metallicFactor = 0.5, n.pbrMetallicRoughness.roughnessFactor = 0.5);
    const o = e.metalnessMap?.image ? e.metalnessMap : void 0, r = e.roughnessMap?.image ? e.roughnessMap : void 0;
    if (o || r) {
      const c = this.buildMetalRoughTexture(o, r), l = {
        index: this.processTexture(c),
        channel: c.channel
      };
      this.applyTextureTransform(l, c), n.pbrMetallicRoughness.metallicRoughnessTexture = l;
    }
    if (e.map) {
      const c = {
        index: this.processTexture(e.map),
        texCoord: e.map.channel
      };
      this.applyTextureTransform(c, e.map), n.pbrMetallicRoughness.baseColorTexture = c;
    }
    if (e.emissive) {
      const c = e.emissive;
      if (Math.max(c.r, c.g, c.b) > 0 && (n.emissiveFactor = e.emissive.toArray()), e.emissiveMap?.image) {
        const h = {
          index: this.processTexture(e.emissiveMap),
          texCoord: e.emissiveMap.channel
        };
        this.applyTextureTransform(h, e.emissiveMap), n.emissiveTexture = h;
      }
    }
    if (e.normalMap?.image) {
      const c = {
        index: this.processTexture(e.normalMap),
        texCoord: e.normalMap.channel
      };
      e.normalScale && e.normalScale.x !== 1 && (c.scale = e.normalScale.x), this.applyTextureTransform(c, e.normalMap), n.normalTexture = c;
    }
    if (e.aoMap?.image) {
      const c = {
        index: this.processTexture(e.aoMap),
        texCoord: e.aoMap.channel
      };
      e.aoMapIntensity !== 1 && (c.strength = e.aoMapIntensity), this.applyTextureTransform(c, e.aoMap), n.occlusionTexture = c;
    }
    e.transparent ? n.alphaMode = "BLEND" : e.alphaTest > 0 && (n.alphaMode = "MASK", n.alphaCutoff = e.alphaTest), e.side === Ii && (n.doubleSided = !0), e.name !== "" && (n.name = e.name), this.serializeUserData(e, n), this._invokeAll(function(c) {
      c.writeMaterial && c.writeMaterial(e, n);
    });
    const a = s.materials.push(n) - 1;
    return t.materials.set(e, a), a;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(e) {
    const t = { keep: !0 };
    if (this._invokeAll(function(Q) {
      Q.beforeWriteMesh && Q.beforeWriteMesh(e, t);
    }), t.keep != !0)
      return null;
    const s = this.cache, n = this.json, i = [e.geometry.uuid];
    if (Array.isArray(e.material))
      for (let Q = 0, D = e.material.length; Q < D; Q++)
        i.push(e.material[Q].uuid);
    else
      i.push(e.material.uuid);
    const o = i.join(":");
    if (s.meshes.has(o)) return s.meshes.get(o);
    const r = e.geometry;
    let a;
    e.isLineSegments ? a = Ae.LINES : e.isLineLoop ? a = Ae.LINE_LOOP : e.isLine ? a = Ae.LINE_STRIP : e.isPoints ? a = Ae.POINTS : a = e.material.wireframe ? Ae.LINES : Ae.TRIANGLES;
    const c = {}, l = {}, h = [], g = [], d = {
      uv: "TEXCOORD_0",
      uv1: "TEXCOORD_1",
      uv2: "TEXCOORD_2",
      uv3: "TEXCOORD_3",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, f = r.getAttribute("normal");
    f !== void 0 && !this.isNormalizedNormalAttribute(f) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r.setAttribute("normal", this.createNormalizedNormalAttribute(f)));
    let I = null;
    for (let Q in r.attributes) {
      if (Q.slice(0, 5) === "morph") continue;
      const D = r.attributes[Q];
      if (Q = d[Q] || Q.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(Q) || (Q = "_" + Q), s.attributes.has(this.getUID(D))) {
        l[Q] = s.attributes.get(this.getUID(D));
        continue;
      }
      I = null;
      const x = D.array;
      Q === "JOINTS_0" && !(x instanceof Uint16Array) && !(x instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), I = new st(new Uint16Array(x), D.itemSize, D.normalized));
      const T = this.processAccessor(I || D, r);
      T !== null && (Q.startsWith("_") || this.detectMeshQuantization(Q, D), l[Q] = T, s.attributes.set(this.getUID(D), T));
    }
    if (f !== void 0 && r.setAttribute("normal", f), Object.keys(l).length === 0) return null;
    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
      const Q = [], D = [], R = {};
      if (e.morphTargetDictionary !== void 0)
        for (const x in e.morphTargetDictionary)
          R[e.morphTargetDictionary[x]] = x;
      for (let x = 0; x < e.morphTargetInfluences.length; ++x) {
        const T = {};
        let U = !1;
        for (const L in r.morphAttributes) {
          if (L !== "position" && L !== "normal" && L !== "color") {
            U || (console.warn("GLTFExporter: Only POSITION, NORMAL and COLOR morph are supported."), U = !0);
            continue;
          }
          const H = r.morphAttributes[L][x], Z = L.toUpperCase() + (L === "color" ? "_0" : ""), N = r.attributes[L];
          if (s.attributes.has(this.getUID(H, !0))) {
            T[Z] = s.attributes.get(this.getUID(H, !0));
            continue;
          }
          const K = H.clone();
          if (!r.morphTargetsRelative)
            for (let O = 0, $ = H.count; O < $; O++)
              for (let oe = 0; oe < H.itemSize; oe++)
                oe === 0 && K.setX(O, H.getX(O) - N.getX(O)), oe === 1 && K.setY(O, H.getY(O) - N.getY(O)), oe === 2 && K.setZ(O, H.getZ(O) - N.getZ(O)), oe === 3 && K.setW(O, H.getW(O) - N.getW(O));
          T[Z] = this.processAccessor(K, r), s.attributes.set(this.getUID(N, !0), T[Z]);
        }
        g.push(T), Q.push(e.morphTargetInfluences[x]), e.morphTargetDictionary !== void 0 && D.push(R[x]);
      }
      c.weights = Q, D.length > 0 && (c.extras = {}, c.extras.targetNames = D);
    }
    const m = Array.isArray(e.material);
    if (m && r.groups.length === 0) return null;
    let C = !1;
    if (m && r.index === null) {
      const Q = [];
      for (let D = 0, R = r.attributes.position.count; D < R; D++)
        Q[D] = D;
      r.setIndex(Q), C = !0;
    }
    const w = m ? e.material : [e.material], b = m ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let Q = 0, D = b.length; Q < D; Q++) {
      const R = {
        mode: a,
        attributes: l
      };
      if (this.serializeUserData(r, R), g.length > 0 && (R.targets = g), r.index !== null) {
        let T = this.getUID(r.index);
        (b[Q].start !== void 0 || b[Q].count !== void 0) && (T += ":" + b[Q].start + ":" + b[Q].count), s.attributes.has(T) ? R.indices = s.attributes.get(T) : (R.indices = this.processAccessor(r.index, r, b[Q].start, b[Q].count), s.attributes.set(T, R.indices)), R.indices === null && delete R.indices;
      }
      const x = this.processMaterial(w[b[Q].materialIndex]);
      x !== null && (R.material = x), h.push(R);
    }
    C === !0 && r.setIndex(null), c.primitives = h, n.meshes || (n.meshes = []), this._invokeAll(function(Q) {
      Q.writeMesh && Q.writeMesh(e, c);
    });
    const B = n.meshes.push(c) - 1;
    return s.meshes.set(o, B), B;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(e, t) {
    if (this.extensionsUsed[Gs]) return;
    let s;
    switch (t.array.constructor) {
      case Int8Array:
        s = "byte";
        break;
      case Uint8Array:
        s = "unsigned byte";
        break;
      case Int16Array:
        s = "short";
        break;
      case Uint16Array:
        s = "unsigned short";
        break;
      default:
        return;
    }
    t.normalized && (s += " normalized");
    const n = e.split("_", 1)[0];
    po[n] && po[n].includes(s) && (this.extensionsUsed[Gs] = !0, this.extensionsRequired[Gs] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(e) {
    const t = this.json;
    t.cameras || (t.cameras = []);
    const s = e.isOrthographicCamera, n = {
      type: s ? "orthographic" : "perspective"
    };
    return s ? n.orthographic = {
      xmag: e.right * 2,
      ymag: e.top * 2,
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    } : n.perspective = {
      aspectRatio: e.aspect,
      yfov: Qe.degToRad(e.fov),
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    }, e.name !== "" && (n.name = e.type), t.cameras.push(n) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(e, t) {
    const s = this.json, n = this.nodeMap;
    s.animations || (s.animations = []), e = Mr.Utils.mergeMorphTargetTracks(e.clone(), t);
    const i = e.tracks, o = [], r = [];
    for (let a = 0; a < i.length; ++a) {
      const c = i[a], l = Lt.parseTrackName(c.name);
      let h = Lt.findNode(t, l.nodeName);
      const g = fo[l.propertyName];
      if (l.objectName === "bones" && (h.isSkinnedMesh === !0 ? h = h.skeleton.getBoneByName(l.objectIndex) : h = void 0), !h || !g) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name);
        continue;
      }
      const d = 1;
      let f = c.values.length / c.times.length;
      g === fo.morphTargetInfluences && (f /= h.morphTargetInfluences.length);
      let I;
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (I = "CUBICSPLINE", f /= 3) : c.getInterpolation() === Po ? I = "STEP" : I = "LINEAR", r.push({
        input: this.processAccessor(new st(c.times, d)),
        output: this.processAccessor(new st(c.values, f)),
        interpolation: I
      }), o.push({
        sampler: r.length - 1,
        target: {
          node: n.get(h),
          path: g
        }
      });
    }
    return s.animations.push({
      name: e.name || "clip_" + s.animations.length,
      samplers: r,
      channels: o
    }), s.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(e) {
    const t = this.json, s = this.nodeMap, n = t.nodes[s.get(e)], i = e.skeleton;
    if (i === void 0) return null;
    const o = e.skeleton.bones[0];
    if (o === void 0) return null;
    const r = [], a = new Float32Array(i.bones.length * 16), c = new ue();
    for (let h = 0; h < i.bones.length; ++h)
      r.push(s.get(i.bones[h])), c.copy(i.boneInverses[h]), c.multiply(e.bindMatrix).toArray(a, h * 16);
    return t.skins === void 0 && (t.skins = []), t.skins.push({
      inverseBindMatrices: this.processAccessor(new st(a, 16)),
      joints: r,
      skeleton: s.get(o)
    }), n.skin = t.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(e) {
    const t = { keep: !0 };
    if (this._invokeAll(function(a) {
      a.beforeWriteNode && a.beforeWriteNode(e, t);
    }), t.keep != !0)
      return null;
    const s = this.json, n = this.options, i = this.nodeMap;
    s.nodes || (s.nodes = []);
    const o = {};
    if (n.trs) {
      const a = e.quaternion.toArray(), c = e.position.toArray(), l = e.scale.toArray();
      Nn(a, [0, 0, 0, 1]) || (o.rotation = a), Nn(c, [0, 0, 0]) || (o.translation = c), Nn(l, [1, 1, 1]) || (o.scale = l);
    } else
      e.matrixAutoUpdate && e.updateMatrix(), _l(e.matrix) === !1 && (o.matrix = e.matrix.elements);
    if (e.name !== "" && (o.name = String(e.name)), this.serializeUserData(e, o), e.isMesh || e.isLine || e.isPoints) {
      const a = this.processMesh(e);
      a !== null && (o.mesh = a);
    } else e.isCamera && (o.camera = this.processCamera(e));
    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
      const a = [];
      for (let c = 0, l = e.children.length; c < l; c++) {
        const h = e.children[c];
        if (h.visible || n.onlyVisible === !1) {
          const g = this.processNode(h);
          g !== null && a.push(g);
        }
      }
      a.length > 0 && (o.children = a);
    }
    this._invokeAll(function(a) {
      a.writeNode && a.writeNode(e, o);
    });
    const r = s.nodes.push(o) - 1;
    return i.set(e, r), r;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(e) {
    const t = this.json, s = this.options;
    t.scenes || (t.scenes = [], t.scene = 0);
    const n = {};
    e.name !== "" && (n.name = e.name), t.scenes.push(n);
    const i = [];
    for (let o = 0, r = e.children.length; o < r; o++) {
      const a = e.children[o];
      if (a.visible || s.onlyVisible === !1) {
        const c = this.processNode(a);
        c !== null && i.push(c);
      }
    }
    i.length > 0 && (n.nodes = i), this.serializeUserData(e, n);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(e) {
    const t = new ti();
    t.name = "AuxScene";
    for (let s = 0; s < e.length; s++)
      t.children.push(e[s]);
    this.processScene(t);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(e) {
    const t = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(n) {
      n.beforeParse && n.beforeParse(e);
    });
    const s = [];
    for (let n = 0; n < e.length; n++)
      e[n] instanceof ti ? this.processScene(e[n]) : s.push(e[n]);
    s.length > 0 && this.processObjects(s);
    for (let n = 0; n < this.skins.length; ++n)
      this.processSkin(this.skins[n]);
    for (let n = 0; n < t.animations.length; ++n)
      this.processAnimation(t.animations[n], e[0]);
    this._invokeAll(function(n) {
      n.afterParse && n.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let t = 0, s = this.plugins.length; t < s; t++)
      e(this.plugins[t]);
  }
}
class kl {
  constructor(e) {
    this.writer = e, this.name = "KHR_lights_punctual";
  }
  writeNode(e, t) {
    if (!e.isLight) return;
    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      return;
    }
    const s = this.writer, n = s.json, i = s.extensionsUsed, o = {};
    e.name && (o.name = e.name), o.color = e.color.toArray(), o.intensity = e.intensity, e.isDirectionalLight ? o.type = "directional" : e.isPointLight ? (o.type = "point", e.distance > 0 && (o.range = e.distance)) : e.isSpotLight && (o.type = "spot", e.distance > 0 && (o.range = e.distance), o.spot = {}, o.spot.innerConeAngle = (1 - e.penumbra) * e.angle, o.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i[this.name] || (n.extensions = n.extensions || {}, n.extensions[this.name] = { lights: [] }, i[this.name] = !0);
    const r = n.extensions[this.name].lights;
    r.push(o), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: r.length - 1 };
  }
}
class Ll {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, t) {
    if (!e.isMeshBasicMaterial) return;
    const n = this.writer.extensionsUsed;
    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, n[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}
class Nl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0) return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
      const o = {
        index: s.processTexture(e.clearcoatMap),
        texCoord: e.clearcoatMap.channel
      };
      s.applyTextureTransform(o, e.clearcoatMap), i.clearcoatTexture = o;
    }
    if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
      const o = {
        index: s.processTexture(e.clearcoatRoughnessMap),
        texCoord: e.clearcoatRoughnessMap.channel
      };
      s.applyTextureTransform(o, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = o;
    }
    if (e.clearcoatNormalMap) {
      const o = {
        index: s.processTexture(e.clearcoatNormalMap),
        texCoord: e.clearcoatNormalMap.channel
      };
      e.clearcoatNormalScale.x !== 1 && (o.scale = e.clearcoatNormalScale.x), s.applyTextureTransform(o, e.clearcoatNormalMap), i.clearcoatNormalTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Ul {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_dispersion";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.dispersion === 0) return;
    const n = this.writer.extensionsUsed, i = {};
    i.dispersion = e.dispersion, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Gl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.iridescence === 0) return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
      const o = {
        index: s.processTexture(e.iridescenceMap),
        texCoord: e.iridescenceMap.channel
      };
      s.applyTextureTransform(o, e.iridescenceMap), i.iridescenceTexture = o;
    }
    if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
      const o = {
        index: s.processTexture(e.iridescenceThicknessMap),
        texCoord: e.iridescenceThicknessMap.channel
      };
      s.applyTextureTransform(o, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Pl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0) return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (i.transmissionFactor = e.transmission, e.transmissionMap) {
      const o = {
        index: s.processTexture(e.transmissionMap),
        texCoord: e.transmissionMap.channel
      };
      s.applyTextureTransform(o, e.transmissionMap), i.transmissionTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Ol {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_volume";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0) return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (i.thicknessFactor = e.thickness, e.thicknessMap) {
      const o = {
        index: s.processTexture(e.thicknessMap),
        texCoord: e.thicknessMap.channel
      };
      s.applyTextureTransform(o, e.thicknessMap), i.thicknessTexture = o;
    }
    e.attenuationDistance !== 1 / 0 && (i.attenuationDistance = e.attenuationDistance), i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Hl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_ior";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.ior === 1.5) return;
    const n = this.writer.extensionsUsed, i = {};
    i.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class jl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_specular";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(xl) && !e.specularIntensityMap && !e.specularColorMap) return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (e.specularIntensityMap) {
      const o = {
        index: s.processTexture(e.specularIntensityMap),
        texCoord: e.specularIntensityMap.channel
      };
      s.applyTextureTransform(o, e.specularIntensityMap), i.specularTexture = o;
    }
    if (e.specularColorMap) {
      const o = {
        index: s.processTexture(e.specularColorMap),
        texCoord: e.specularColorMap.channel
      };
      s.applyTextureTransform(o, e.specularColorMap), i.specularColorTexture = o;
    }
    i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class ql {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.sheen == 0) return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (e.sheenRoughnessMap) {
      const o = {
        index: s.processTexture(e.sheenRoughnessMap),
        texCoord: e.sheenRoughnessMap.channel
      };
      s.applyTextureTransform(o, e.sheenRoughnessMap), i.sheenRoughnessTexture = o;
    }
    if (e.sheenColorMap) {
      const o = {
        index: s.processTexture(e.sheenColorMap),
        texCoord: e.sheenColorMap.channel
      };
      s.applyTextureTransform(o, e.sheenColorMap), i.sheenColorTexture = o;
    }
    i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class zl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0) return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (e.anisotropyMap) {
      const o = { index: s.processTexture(e.anisotropyMap) };
      s.applyTextureTransform(o, e.anisotropyMap), i.anisotropyTexture = o;
    }
    i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Yl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1) return;
    const n = this.writer.extensionsUsed, i = {};
    i.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Kl {
  constructor(e) {
    this.writer = e, this.name = "EXT_materials_bump";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.bumpScale === 1 && !e.bumpMap) return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (e.bumpMap) {
      const o = {
        index: s.processTexture(e.bumpMap),
        texCoord: e.bumpMap.channel
      };
      s.applyTextureTransform(o, e.bumpMap), i.bumpTexture = o;
    }
    i.bumpFactor = e.bumpScale, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Jl {
  constructor(e) {
    this.writer = e, this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(e, t) {
    if (!e.isInstancedMesh) return;
    const s = this.writer, n = e, i = new Float32Array(n.count * 3), o = new Float32Array(n.count * 4), r = new Float32Array(n.count * 3), a = new ue(), c = new P(), l = new Te(), h = new P();
    for (let d = 0; d < n.count; d++)
      n.getMatrixAt(d, a), a.decompose(c, l, h), c.toArray(i, d * 3), l.toArray(o, d * 4), h.toArray(r, d * 3);
    const g = {
      TRANSLATION: s.processAccessor(new st(i, 3)),
      ROTATION: s.processAccessor(new st(o, 4)),
      SCALE: s.processAccessor(new st(r, 3))
    };
    n.instanceColor && (g._COLOR_0 = s.processAccessor(n.instanceColor)), t.extensions = t.extensions || {}, t.extensions[this.name] = { attributes: g }, s.extensionsUsed[this.name] = !0, s.extensionsRequired[this.name] = !0;
  }
}
Mr.Utils = {
  insertKeyframe: function(A, e) {
    const s = A.getValueSize(), n = new A.TimeBufferType(A.times.length + 1), i = new A.ValueBufferType(A.values.length + s), o = A.createInterpolant(new A.ValueBufferType(s));
    let r;
    if (A.times.length === 0) {
      n[0] = e;
      for (let a = 0; a < s; a++)
        i[a] = 0;
      r = 0;
    } else if (e < A.times[0]) {
      if (Math.abs(A.times[0] - e) < 1e-3) return 0;
      n[0] = e, n.set(A.times, 1), i.set(o.evaluate(e), 0), i.set(A.values, s), r = 0;
    } else if (e > A.times[A.times.length - 1]) {
      if (Math.abs(A.times[A.times.length - 1] - e) < 1e-3)
        return A.times.length - 1;
      n[n.length - 1] = e, n.set(A.times, 0), i.set(A.values, 0), i.set(o.evaluate(e), A.values.length), r = n.length - 1;
    } else
      for (let a = 0; a < A.times.length; a++) {
        if (Math.abs(A.times[a] - e) < 1e-3) return a;
        if (A.times[a] < e && A.times[a + 1] > e) {
          n.set(A.times.slice(0, a + 1), 0), n[a + 1] = e, n.set(A.times.slice(a + 1), a + 2), i.set(A.values.slice(0, (a + 1) * s), 0), i.set(o.evaluate(e), (a + 1) * s), i.set(A.values.slice((a + 1) * s), (a + 2) * s), r = a + 1;
          break;
        }
      }
    return A.times = n, A.values = i, r;
  },
  mergeMorphTargetTracks: function(A, e) {
    const t = [], s = {}, n = A.tracks;
    for (let i = 0; i < n.length; ++i) {
      let o = n[i];
      const r = Lt.parseTrackName(o.name), a = Lt.findNode(e, r.nodeName);
      if (r.propertyName !== "morphTargetInfluences" || r.propertyIndex === void 0) {
        t.push(o);
        continue;
      }
      if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
        if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(mi);
      }
      const c = a.morphTargetInfluences.length, l = a.morphTargetDictionary[r.propertyIndex];
      if (l === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + r.propertyIndex);
      let h;
      if (s[a.uuid] === void 0) {
        h = o.clone();
        const d = new h.ValueBufferType(c * h.times.length);
        for (let f = 0; f < h.times.length; f++)
          d[f * c + l] = h.values[f];
        h.name = (r.nodeName || "") + ".morphTargetInfluences", h.values = d, s[a.uuid] = h, t.push(h);
        continue;
      }
      const g = o.createInterpolant(new o.ValueBufferType(1));
      h = s[a.uuid];
      for (let d = 0; d < h.times.length; d++)
        h.values[d * c + l] = g.evaluate(h.times[d]);
      for (let d = 0; d < o.times.length; d++) {
        const f = this.insertKeyframe(h, o.times[d]);
        h.values[f * c + l] = o.values[d];
      }
    }
    return A.tracks = t, A;
  }
};
const ve = {
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function kr(A) {
  const e = await fetch(A);
  if (e.ok)
    return e.json();
  throw new Error(e.statusText);
}
async function Vl(A) {
  if (!A)
    throw new Error("No basePath supplied");
  return await kr(`${A}/profilesList.json`);
}
async function Wl(A, e, t = null, s = !0) {
  if (!A)
    throw new Error("No xrInputSource supplied");
  if (!e)
    throw new Error("No basePath supplied");
  const n = await Vl(e);
  let i;
  if (A.profiles.some((a) => {
    const c = n[a];
    return c && (i = {
      profileId: a,
      profilePath: `${e}/${c.path}`,
      deprecated: !!c.deprecated
    }), !!i;
  }), !i) {
    if (!t)
      throw new Error("No matching profile name found");
    const a = n[t];
    if (!a)
      throw new Error(`No matching profile name found and default profile "${t}" missing.`);
    i = {
      profileId: t,
      profilePath: `${e}/${a.path}`,
      deprecated: !!a.deprecated
    };
  }
  const o = await kr(i.profilePath);
  let r;
  if (s) {
    let a;
    if (A.handedness === "any" ? a = o.layouts[Object.keys(o.layouts)[0]] : a = o.layouts[A.handedness], !a)
      throw new Error(
        `No matching handedness, ${A.handedness}, in profile ${i.profileId}`
      );
    a.assetPath && (r = i.profilePath.replace("profile.json", a.assetPath));
  }
  return { profile: o, assetPath: r };
}
const Xl = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: ve.ComponentState.DEFAULT
};
function Zl(A = 0, e = 0) {
  let t = A, s = e;
  if (Math.sqrt(A * A + e * e) > 1) {
    const o = Math.atan2(e, A);
    t = Math.cos(o), s = Math.sin(o);
  }
  return {
    normalizedXAxis: t * 0.5 + 0.5,
    normalizedYAxis: s * 0.5 + 0.5
  };
}
class $l {
  constructor(e) {
    this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === ve.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(Xl);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: e,
    yAxis: t,
    button: s,
    state: n
  }) {
    const { normalizedXAxis: i, normalizedYAxis: o } = Zl(e, t);
    switch (this.componentProperty) {
      case ve.ComponentProperty.X_AXIS:
        this.value = this.states.includes(n) ? i : 0.5;
        break;
      case ve.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(n) ? o : 0.5;
        break;
      case ve.ComponentProperty.BUTTON:
        this.value = this.states.includes(n) ? s : 0;
        break;
      case ve.ComponentProperty.STATE:
        this.valueNodeProperty === ve.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(n) : this.value = this.states.includes(n) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class eh {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(e, t) {
    if (!e || !t || !t.visualResponses || !t.gamepadIndices || Object.keys(t.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = e, this.type = t.type, this.rootNodeName = t.rootNodeName, this.touchPointNodeName = t.touchPointNodeName, this.visualResponses = {}, Object.keys(t.visualResponses).forEach((s) => {
      const n = new $l(t.visualResponses[s]);
      this.visualResponses[s] = n;
    }), this.gamepadIndices = Object.assign({}, t.gamepadIndices), this.values = {
      state: ve.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(e) {
    if (this.values.state = ve.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) {
      const t = e.buttons[this.gamepadIndices.button];
      this.values.button = t.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, t.pressed || this.values.button === 1 ? this.values.state = ve.ComponentState.PRESSED : (t.touched || this.values.button > ve.ButtonTouchThreshold) && (this.values.state = ve.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === ve.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > ve.AxisTouchThreshold && (this.values.state = ve.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === ve.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > ve.AxisTouchThreshold && (this.values.state = ve.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((t) => {
      t.updateFromComponent(this.values);
    });
  }
}
class th {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(e, t, s) {
    if (!e)
      throw new Error("No xrInputSource supplied");
    if (!t)
      throw new Error("No profile supplied");
    this.xrInputSource = e, this.assetUrl = s, this.id = t.profileId, this.layoutDescription = t.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((n) => {
      const i = this.layoutDescription.components[n];
      this.components[n] = new eh(n, i);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const e = [];
    return Object.values(this.components).forEach((t) => {
      e.push(t.data);
    }), e;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((e) => {
      e.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const nh = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", sh = "generic-trigger";
class ih extends xt {
  constructor() {
    super(), this.motionController = null, this.envMap = null;
  }
  setEnvironmentMap(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((t) => {
      t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
    }), this);
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t) => {
      Object.values(t.visualResponses).forEach((s) => {
        const { valueNode: n, minNode: i, maxNode: o, value: r, valueNodeProperty: a } = s;
        n && (a === ve.VisualResponseProperty.VISIBILITY ? n.visible = r : a === ve.VisualResponseProperty.TRANSFORM && (n.quaternion.slerpQuaternions(
          i.quaternion,
          o.quaternion,
          r
        ), n.position.lerpVectors(
          i.position,
          o.position,
          r
        )));
      });
    }));
  }
}
function oh(A, e) {
  Object.values(A.components).forEach((t) => {
    const { type: s, touchPointNodeName: n, visualResponses: i } = t;
    if (s === ve.ComponentType.TOUCHPAD)
      if (t.touchPointNode = e.getObjectByName(n), t.touchPointNode) {
        const o = new ui(1e-3), r = new Qt({ color: 255 }), a = new q(o, r);
        t.touchPointNode.add(a);
      } else
        console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);
    Object.values(i).forEach((o) => {
      const { valueNodeName: r, minNodeName: a, maxNodeName: c, valueNodeProperty: l } = o;
      if (l === ve.VisualResponseProperty.TRANSFORM) {
        if (o.minNode = e.getObjectByName(a), o.maxNode = e.getObjectByName(c), !o.minNode) {
          console.warn(`Could not find ${a} in the model`);
          return;
        }
        if (!o.maxNode) {
          console.warn(`Could not find ${c} in the model`);
          return;
        }
      }
      o.valueNode = e.getObjectByName(r), o.valueNode || console.warn(`Could not find ${r} in the model`);
    });
  });
}
function Co(A, e) {
  oh(A.motionController, e), A.envMap && e.traverse((t) => {
    t.isMesh && (t.material.envMap = A.envMap, t.material.needsUpdate = !0);
  }), A.layers.mask != 0 && e.traverse((t) => {
    t.layers.mask = A.layers.mask;
  }), A.add(e);
}
class zh {
  constructor(e = null, t = null) {
    this.gltfLoader = e, this.path = nh, this._assetCache = {}, this.onLoad = t, this.gltfLoader || (this.gltfLoader = new Zo());
  }
  setPath(e) {
    return this.path = e, this;
  }
  createControllerModel(e) {
    const t = new ih();
    let s = null;
    return e.addEventListener("connected", (n) => {
      const i = n.data;
      i.targetRayMode !== "tracked-pointer" || !i.gamepad || i.hand || Wl(i, this.path, sh).then(({ profile: o, assetPath: r }) => {
        t.motionController = new th(
          i,
          o,
          r
        );
        const a = this._assetCache[t.motionController.assetUrl];
        if (a)
          s = a.scene.clone(), Co(t, s), this.onLoad && this.onLoad(s);
        else {
          if (!this.gltfLoader)
            throw new Error("GLTFLoader not set.");
          this.gltfLoader.setPath(""), this.gltfLoader.load(
            t.motionController.assetUrl,
            (c) => {
              this._assetCache[t.motionController.assetUrl] = c, s = c.scene.clone(), Co(t, s), this.onLoad && this.onLoad(s);
            },
            null,
            () => {
              throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((o) => {
        console.warn(o);
      });
    }), e.addEventListener("disconnected", () => {
      t.motionController = null, t.remove(s), s = null;
    }), t;
  }
}
const rh = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
class Yh {
  constructor(e, t, s, n, i = null, o = null) {
    this.controller = t, this.handModel = e, this.bones = [], i === null && (i = new Zo(), i.setPath(s || rh)), i.load(`${n}.glb`, (r) => {
      const a = r.scene.children[0];
      this.handModel.add(a), a.layers.mask = this.handModel.layers.mask;
      const c = a.getObjectByProperty("type", "SkinnedMesh");
      c.frustumCulled = !1, c.castShadow = !0, c.receiveShadow = !0, [
        "wrist",
        "thumb-metacarpal",
        "thumb-phalanx-proximal",
        "thumb-phalanx-distal",
        "thumb-tip",
        "index-finger-metacarpal",
        "index-finger-phalanx-proximal",
        "index-finger-phalanx-intermediate",
        "index-finger-phalanx-distal",
        "index-finger-tip",
        "middle-finger-metacarpal",
        "middle-finger-phalanx-proximal",
        "middle-finger-phalanx-intermediate",
        "middle-finger-phalanx-distal",
        "middle-finger-tip",
        "ring-finger-metacarpal",
        "ring-finger-phalanx-proximal",
        "ring-finger-phalanx-intermediate",
        "ring-finger-phalanx-distal",
        "ring-finger-tip",
        "pinky-finger-metacarpal",
        "pinky-finger-phalanx-proximal",
        "pinky-finger-phalanx-intermediate",
        "pinky-finger-phalanx-distal",
        "pinky-finger-tip"
      ].forEach((h) => {
        const g = a.getObjectByName(h);
        g !== void 0 ? g.jointName = h : console.warn(`Couldn't find ${h} in ${n} hand mesh`), this.bones.push(g);
      }), o && o(a);
    });
  }
  updateMesh() {
    const e = this.controller.joints;
    for (let t = 0; t < this.bones.length; t++) {
      const s = this.bones[t];
      if (s) {
        const n = e[s.jointName];
        if (n.visible) {
          const i = n.position;
          s.position.copy(i), s.quaternion.copy(n.quaternion);
        }
      }
    }
  }
}
const Bo = new ds(), ts = new P();
class Lr extends Za {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], s = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(s), this.setAttribute("position", new Fe(e, 3)), this.setAttribute("uv", new Fe(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, s = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), s.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const s = new ni(t, 6, 1);
    return this.setAttribute("instanceStart", new $t(s, 3, 0)), this.setAttribute("instanceEnd", new $t(s, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const s = new ni(t, 6, 1);
    return this.setAttribute("instanceColorStart", new $t(s, 3, 0)), this.setAttribute("instanceColorEnd", new $t(s, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new $a(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ds());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Bo.setFromBufferAttribute(t), this.boundingBox.union(Bo));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ei()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const s = this.boundingSphere.center;
      this.boundingBox.getCenter(s);
      let n = 0;
      for (let i = 0, o = e.count; i < o; i++)
        ts.fromBufferAttribute(e, i), n = Math.max(n, s.distanceToSquared(ts)), ts.fromBufferAttribute(t, i), n = Math.max(n, s.distanceToSquared(ts));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
Un.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Le(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
wt.line = {
  uniforms: gi.merge([
    Un.common,
    Un.fog,
    Un.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class Nr extends Vo {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: gi.clone(wt.line.uniforms),
      vertexShader: wt.line.vertexShader,
      fragmentShader: wt.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const Os = new Nt(), wo = new P(), yo = new P(), Ne = new Nt(), Ue = new Nt(), Ct = new Nt(), Hs = new P(), js = new ue(), Pe = new eA(), Qo = new P(), ns = new ds(), ss = new Ei(), Bt = new Nt();
let yt, sn;
function xo(A, e, t) {
  return Bt.set(0, 0, -e, 1).applyMatrix4(A.projectionMatrix), Bt.multiplyScalar(1 / Bt.w), Bt.x = sn / t.width, Bt.y = sn / t.height, Bt.applyMatrix4(A.projectionMatrixInverse), Bt.multiplyScalar(1 / Bt.w), Math.abs(Math.max(Bt.x, Bt.y));
}
function ah(A, e) {
  const t = A.matrixWorld, s = A.geometry, n = s.attributes.instanceStart, i = s.attributes.instanceEnd, o = Math.min(s.instanceCount, n.count);
  for (let r = 0, a = o; r < a; r++) {
    Pe.start.fromBufferAttribute(n, r), Pe.end.fromBufferAttribute(i, r), Pe.applyMatrix4(t);
    const c = new P(), l = new P();
    yt.distanceSqToSegment(Pe.start, Pe.end, l, c), l.distanceTo(c) < sn * 0.5 && e.push({
      point: l,
      pointOnLine: c,
      distance: yt.origin.distanceTo(l),
      object: A,
      face: null,
      faceIndex: r,
      uv: null,
      uv1: null
    });
  }
}
function Ah(A, e, t) {
  const s = e.projectionMatrix, i = A.material.resolution, o = A.matrixWorld, r = A.geometry, a = r.attributes.instanceStart, c = r.attributes.instanceEnd, l = Math.min(r.instanceCount, a.count), h = -e.near;
  yt.at(1, Ct), Ct.w = 1, Ct.applyMatrix4(e.matrixWorldInverse), Ct.applyMatrix4(s), Ct.multiplyScalar(1 / Ct.w), Ct.x *= i.x / 2, Ct.y *= i.y / 2, Ct.z = 0, Hs.copy(Ct), js.multiplyMatrices(e.matrixWorldInverse, o);
  for (let g = 0, d = l; g < d; g++) {
    if (Ne.fromBufferAttribute(a, g), Ue.fromBufferAttribute(c, g), Ne.w = 1, Ue.w = 1, Ne.applyMatrix4(js), Ue.applyMatrix4(js), Ne.z > h && Ue.z > h)
      continue;
    if (Ne.z > h) {
      const b = Ne.z - Ue.z, B = (Ne.z - h) / b;
      Ne.lerp(Ue, B);
    } else if (Ue.z > h) {
      const b = Ue.z - Ne.z, B = (Ue.z - h) / b;
      Ue.lerp(Ne, B);
    }
    Ne.applyMatrix4(s), Ue.applyMatrix4(s), Ne.multiplyScalar(1 / Ne.w), Ue.multiplyScalar(1 / Ue.w), Ne.x *= i.x / 2, Ne.y *= i.y / 2, Ue.x *= i.x / 2, Ue.y *= i.y / 2, Pe.start.copy(Ne), Pe.start.z = 0, Pe.end.copy(Ue), Pe.end.z = 0;
    const I = Pe.closestPointToPointParameter(Hs, !0);
    Pe.at(I, Qo);
    const m = Qe.lerp(Ne.z, Ue.z, I), C = m >= -1 && m <= 1, w = Hs.distanceTo(Qo) < sn * 0.5;
    if (C && w) {
      Pe.start.fromBufferAttribute(a, g), Pe.end.fromBufferAttribute(c, g), Pe.start.applyMatrix4(o), Pe.end.applyMatrix4(o);
      const b = new P(), B = new P();
      yt.distanceSqToSegment(Pe.start, Pe.end, B, b), t.push({
        point: B,
        pointOnLine: b,
        distance: yt.origin.distanceTo(B),
        object: A,
        face: null,
        faceIndex: g,
        uv: null,
        uv1: null
      });
    }
  }
}
class ch extends q {
  constructor(e = new Lr(), t = new Nr({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, s = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let o = 0, r = 0, a = t.count; o < a; o++, r += 2)
      wo.fromBufferAttribute(t, o), yo.fromBufferAttribute(s, o), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + wo.distanceTo(yo);
    const i = new ni(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new $t(i, 1, 0)), e.setAttribute("instanceDistanceEnd", new $t(i, 1, 1)), this;
  }
  raycast(e, t) {
    const s = this.material.worldUnits, n = e.camera;
    n === null && !s && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    yt = e.ray;
    const o = this.matrixWorld, r = this.geometry, a = this.material;
    sn = a.linewidth + i, r.boundingSphere === null && r.computeBoundingSphere(), ss.copy(r.boundingSphere).applyMatrix4(o);
    let c;
    if (s)
      c = sn * 0.5;
    else {
      const h = Math.max(n.near, ss.distanceToPoint(yt.origin));
      c = xo(n, h, a.resolution);
    }
    if (ss.radius += c, yt.intersectsSphere(ss) === !1)
      return;
    r.boundingBox === null && r.computeBoundingBox(), ns.copy(r.boundingBox).applyMatrix4(o);
    let l;
    if (s)
      l = sn * 0.5;
    else {
      const h = Math.max(n.near, ns.distanceToPoint(yt.origin));
      l = xo(n, h, a.resolution);
    }
    ns.expandByScalar(l), yt.intersectsBox(ns) !== !1 && (s ? ah(this, t) : Ah(this, n, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(Os), this.material.uniforms.resolution.value.set(Os.z, Os.w));
  }
}
class lh extends Lr {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, s = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      s[2 * n] = e[n], s[2 * n + 1] = e[n + 1], s[2 * n + 2] = e[n + 2], s[2 * n + 3] = e[n + 3], s[2 * n + 4] = e[n + 4], s[2 * n + 5] = e[n + 5];
    return super.setPositions(s), this;
  }
  setColors(e) {
    const t = e.length - 3, s = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      s[2 * n] = e[n], s[2 * n + 1] = e[n + 1], s[2 * n + 2] = e[n + 2], s[2 * n + 3] = e[n + 3], s[2 * n + 4] = e[n + 4], s[2 * n + 5] = e[n + 5];
    return super.setColors(s), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class Kh extends ch {
  constructor(e = new lh(), t = new Nr({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class Jh extends q {
  constructor(e) {
    const t = new hh(e), s = new Ci(t.image.width * 1e-3, t.image.height * 1e-3), n = new Qt({ map: t, toneMapped: !1, transparent: !0 });
    super(s, n);
    function i(o) {
      n.map.dispatchDOMEvent(o);
    }
    this.addEventListener("mousedown", i), this.addEventListener("mousemove", i), this.addEventListener("mouseup", i), this.addEventListener("click", i), this.dispose = function() {
      s.dispose(), n.dispose(), n.map.dispose(), hi.delete(e), this.removeEventListener("mousedown", i), this.removeEventListener("mousemove", i), this.removeEventListener("mouseup", i), this.removeEventListener("click", i);
    };
  }
}
class hh extends Wo {
  constructor(e) {
    super(So(e)), this.dom = e, this.anisotropy = 16, this.colorSpace = ge, this.minFilter = rt, this.magFilter = rt;
    const t = new MutationObserver(() => {
      this.scheduleUpdate || (this.scheduleUpdate = setTimeout(() => this.update(), 16));
    }), s = { attributes: !0, childList: !0, subtree: !0, characterData: !0 };
    t.observe(e, s), this.observer = t;
  }
  dispatchDOMEvent(e) {
    e.data && uh(this.dom, e.type, e.data.x, e.data.y);
  }
  update() {
    this.image = So(this.dom), this.needsUpdate = !0, this.scheduleUpdate = null;
  }
  dispose() {
    this.observer && this.observer.disconnect(), this.scheduleUpdate = clearTimeout(this.scheduleUpdate), super.dispose();
  }
}
const hi = /* @__PURE__ */ new WeakMap();
function So(A) {
  const e = document.createRange(), t = new Se();
  function s(g) {
    const d = [];
    let f = !1;
    function I() {
      if (f && (f = !1, g.restore()), d.length === 0) return;
      let m = -1 / 0, C = -1 / 0, w = 1 / 0, b = 1 / 0;
      for (let B = 0; B < d.length; B++) {
        const Q = d[B];
        m = Math.max(m, Q.x), C = Math.max(C, Q.y), w = Math.min(w, Q.x + Q.width), b = Math.min(b, Q.y + Q.height);
      }
      g.save(), g.beginPath(), g.rect(m, C, w - m, b - C), g.clip(), f = !0;
    }
    return {
      add: function(m) {
        d.push(m), I();
      },
      remove: function() {
        d.pop(), I();
      }
    };
  }
  function n(g, d, f, I) {
    I !== "" && (g.textTransform === "uppercase" && (I = I.toUpperCase()), l.font = g.fontWeight + " " + g.fontSize + " " + g.fontFamily, l.textBaseline = "top", l.fillStyle = g.color, l.fillText(I, d, f + parseFloat(g.fontSize) * 0.1));
  }
  function i(g, d, f, I, m) {
    f < 2 * m && (m = f / 2), I < 2 * m && (m = I / 2), l.beginPath(), l.moveTo(g + m, d), l.arcTo(g + f, d, g + f, d + I, m), l.arcTo(g + f, d + I, g, d + I, m), l.arcTo(g, d + I, g, d, m), l.arcTo(g, d, g + f, d, m), l.closePath();
  }
  function o(g, d, f, I, m, C) {
    const w = g[d + "Width"], b = g[d + "Style"], B = g[d + "Color"];
    w !== "0px" && b !== "none" && B !== "transparent" && B !== "rgba(0, 0, 0, 0)" && (l.strokeStyle = B, l.lineWidth = parseFloat(w), l.beginPath(), l.moveTo(f, I), l.lineTo(f + m, I + C), l.stroke());
  }
  function r(g, d) {
    if (g.nodeType === Node.COMMENT_NODE || g.nodeName === "SCRIPT" || g.style && g.style.display === "none")
      return;
    let f = 0, I = 0, m = 0, C = 0;
    if (g.nodeType === Node.TEXT_NODE) {
      e.selectNode(g);
      const b = e.getBoundingClientRect();
      f = b.left - a.left - 0.5, I = b.top - a.top - 0.5, m = b.width, C = b.height, n(d, f, I, g.nodeValue.trim());
    } else if (g instanceof HTMLCanvasElement) {
      const b = g.getBoundingClientRect();
      f = b.left - a.left - 0.5, I = b.top - a.top - 0.5, l.save();
      const B = window.devicePixelRatio;
      l.scale(1 / B, 1 / B), l.drawImage(g, f, I), l.restore();
    } else if (g instanceof HTMLImageElement) {
      const b = g.getBoundingClientRect();
      f = b.left - a.left - 0.5, I = b.top - a.top - 0.5, m = b.width, C = b.height, l.drawImage(g, f, I, m, C);
    } else {
      const b = g.getBoundingClientRect();
      f = b.left - a.left - 0.5, I = b.top - a.top - 0.5, m = b.width, C = b.height, d = window.getComputedStyle(g), i(f, I, m, C, parseFloat(d.borderRadius));
      const B = d.backgroundColor;
      B !== "transparent" && B !== "rgba(0, 0, 0, 0)" && (l.fillStyle = B, l.fill());
      const Q = ["borderTop", "borderLeft", "borderBottom", "borderRight"];
      let D = !0, R = null;
      for (const x of Q) {
        if (R !== null && (D = d[x + "Width"] === d[R + "Width"] && d[x + "Color"] === d[R + "Color"] && d[x + "Style"] === d[R + "Style"]), D === !1) break;
        R = x;
      }
      if (D === !0) {
        const x = parseFloat(d.borderTopWidth);
        d.borderTopWidth !== "0px" && d.borderTopStyle !== "none" && d.borderTopColor !== "transparent" && d.borderTopColor !== "rgba(0, 0, 0, 0)" && (l.strokeStyle = d.borderTopColor, l.lineWidth = x, l.stroke());
      } else
        o(d, "borderTop", f, I, m, 0), o(d, "borderLeft", f, I, 0, C), o(d, "borderBottom", f, I + C, m, 0), o(d, "borderRight", f + m, I, 0, C);
      if (g instanceof HTMLInputElement) {
        let x = d.accentColor;
        (x === void 0 || x === "auto") && (x = d.color), t.set(x);
        const U = Math.sqrt(0.299 * t.r ** 2 + 0.587 * t.g ** 2 + 0.114 * t.b ** 2) < 0.5 ? "white" : "#111111";
        if (g.type === "radio" && (i(f, I, m, C, C), l.fillStyle = "white", l.strokeStyle = x, l.lineWidth = 1, l.fill(), l.stroke(), g.checked && (i(f + 2, I + 2, m - 4, C - 4, C), l.fillStyle = x, l.strokeStyle = U, l.lineWidth = 2, l.fill(), l.stroke())), g.type === "checkbox" && (i(f, I, m, C, 2), l.fillStyle = g.checked ? x : "white", l.strokeStyle = g.checked ? U : x, l.lineWidth = 1, l.stroke(), l.fill(), g.checked)) {
          const L = l.textAlign;
          l.textAlign = "center";
          const H = {
            color: U,
            fontFamily: d.fontFamily,
            fontSize: C + "px",
            fontWeight: "bold"
          };
          n(H, f + m / 2, I, ""), l.textAlign = L;
        }
        if (g.type === "range") {
          const [L, H, Z] = ["min", "max", "value"].map((K) => parseFloat(g[K])), N = (Z - L) / (H - L) * (m - C);
          i(f, I + C / 4, m, C / 2, C / 4), l.fillStyle = U, l.strokeStyle = x, l.lineWidth = 1, l.fill(), l.stroke(), i(f, I + C / 4, N + C / 2, C / 2, C / 4), l.fillStyle = x, l.fill(), i(f + N, I, C, C, C / 2), l.fillStyle = x, l.fill();
        }
        (g.type === "color" || g.type === "text" || g.type === "number") && (h.add({ x: f, y: I, width: m, height: C }), n(d, f + parseInt(d.paddingLeft), I + parseInt(d.paddingTop), g.value), h.remove());
      }
    }
    const w = d.overflow === "auto" || d.overflow === "hidden";
    w && h.add({ x: f, y: I, width: m, height: C });
    for (let b = 0; b < g.childNodes.length; b++)
      r(g.childNodes[b], d);
    w && h.remove();
  }
  const a = A.getBoundingClientRect();
  let c = hi.get(A);
  c === void 0 && (c = document.createElement("canvas"), c.width = a.width, c.height = a.height, hi.set(A, c));
  const l = c.getContext(
    "2d"
    /*, { alpha: false }*/
  ), h = new s(l);
  return l.clearRect(0, 0, c.width, c.height), r(A), c;
}
function uh(A, e, t, s) {
  const n = {
    clientX: t * A.offsetWidth + A.offsetLeft,
    clientY: s * A.offsetHeight + A.offsetTop,
    view: A.ownerDocument.defaultView
  };
  window.dispatchEvent(new MouseEvent(e, n));
  const i = A.getBoundingClientRect();
  t = t * i.width + i.left, s = s * i.height + i.top;
  function o(r) {
    if (r.nodeType !== Node.TEXT_NODE && r.nodeType !== Node.COMMENT_NODE) {
      const a = r.getBoundingClientRect();
      if (t > a.left && t < a.right && s > a.top && s < a.bottom && (r.dispatchEvent(new MouseEvent(e, n)), r instanceof HTMLInputElement && r.type === "range" && (e === "mousedown" || e === "click"))) {
        const [c, l] = ["min", "max"].map((f) => parseFloat(r[f])), h = a.width, d = (t - a.x) / h;
        r.value = c + (l - c) * d, r.dispatchEvent(new InputEvent("input", { bubbles: !0 }));
      }
      for (let c = 0; c < r.childNodes.length; c++)
        o(r.childNodes[c]);
    }
  }
  o(A);
}
const As = new Le(), un = { type: "", data: As }, To = new bi();
class Vh extends nn {
  listenToPointerEvents(e, t) {
    const s = this, n = new bi(), i = e.domElement;
    function o(r) {
      r.stopPropagation();
      const a = e.domElement.getBoundingClientRect();
      As.x = (r.clientX - a.left) / a.width * 2 - 1, As.y = -(r.clientY - a.top) / a.height * 2 + 1, n.setFromCamera(As, t);
      const c = n.intersectObjects(s.children, !1);
      if (c.length > 0) {
        const l = c[0], h = l.object, g = l.uv;
        un.type = r.type, un.data.set(g.x, 1 - g.y), h.dispatchEvent(un);
      }
    }
    i.addEventListener("pointerdown", o), i.addEventListener("pointerup", o), i.addEventListener("pointermove", o), i.addEventListener("mousedown", o), i.addEventListener("mouseup", o), i.addEventListener("mousemove", o), i.addEventListener("click", o);
  }
  listenToXRControllerEvents(e) {
    const t = this, s = {
      move: "mousemove",
      select: "click",
      selectstart: "mousedown",
      selectend: "mouseup"
    };
    function n(i) {
      const o = i.target;
      To.setFromXRController(o);
      const r = To.intersectObjects(t.children, !1);
      if (r.length > 0) {
        const a = r[0], c = a.object, l = a.uv;
        un.type = s[i.type], un.data.set(l.x, 1 - l.y), c.dispatchEvent(un);
      }
    }
    e.addEventListener("move", n), e.addEventListener("select", n), e.addEventListener("selectstart", n), e.addEventListener("selectend", n);
  }
}
const Dn = new P(), Rn = new P(), vo = new Jo();
class Wh extends hs {
  constructor(e, t = 1, s = 16711680) {
    const n = new ut(), i = e.geometry.attributes.normal.count, o = new Fe(i * 2 * 3, 3);
    n.setAttribute("position", o), super(n, new Ft({ color: s, toneMapped: !1 })), this.object = e, this.size = t, this.type = "VertexNormalsHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update() {
    this.object.updateMatrixWorld(!0), vo.getNormalMatrix(this.object.matrixWorld);
    const e = this.object.matrixWorld, t = this.geometry.attributes.position, s = this.object.geometry;
    if (s) {
      const n = s.attributes.position, i = s.attributes.normal;
      let o = 0;
      for (let r = 0, a = n.count; r < a; r++)
        Dn.fromBufferAttribute(n, r).applyMatrix4(e), Rn.fromBufferAttribute(i, r), Rn.applyMatrix3(vo).normalize().multiplyScalar(this.size).add(Dn), t.setXYZ(o, Dn.x, Dn.y, Dn.z), o = o + 1, t.setXYZ(o, Rn.x, Rn.y, Rn.z), o = o + 1;
    }
    t.needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Xh {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
new No(-1, 1, 1, -1, 0, 1);
class gh extends ut {
  constructor() {
    super(), this.setAttribute("position", new Fe([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Fe([0, 2, 0, 0, 2, 0], 2));
  }
}
new gh();
export {
  Rh as DRACOLoader,
  Uc as EXRLoader,
  Lh as EXRLoader$1,
  Uh as FBXLoader,
  lc as Font,
  Mh as FontLoader,
  Mr as GLTFExporter,
  Zo as GLTFLoader,
  ph as GroundedSkybox,
  Jh as HTMLMesh,
  jh as HorizontalBlurShader,
  Vh as InteractiveGroup,
  ft as KTX2Loader,
  Kh as Line2,
  lh as LineGeometry,
  Nr as LineMaterial,
  Dh as MeshoptDecoder,
  Gh as OBJLoader,
  Ph as OrbitControls,
  Xh as Pass,
  Hh as PositionalAudioHelper,
  Gc as RGBELoader,
  Nh as RGBELoader$1,
  rs as Stats,
  _h as TextGeometry,
  Fh as TransformControls,
  Ec as TransformControlsGizmo,
  Wh as VertexNormalsHelper,
  qh as VerticalBlurShader,
  zh as XRControllerModelFactory,
  Yh as XRHandMeshModel,
  fh as mergeVertices,
  nt as nodeFrame,
  io as strToU8,
  kh as zipSync
};
