import { Vector2 as J, Vector3 as y, Vector4 as fe, Quaternion as U, PlaneGeometry as Nn, WebGLRenderer as mr, PerspectiveCamera as de, OrthographicCamera as zd, Scene as wi, Mesh as G, Texture as Te, Uniform$1 as $i, Color as se, ShaderMaterial as Ln, Box3 as bi, ShadowMaterial as Sb, Euler as ot, MeshStandardMaterial as ut, Box3Helper as lx, GridHelper as bm, Object3D as M, Material as _e, Matrix3 as Cb, Matrix4 as ee, Layers as ho, Ray as uo, MathUtils as ys, AxesHelper as vi, MeshBasicMaterial as we, DoubleSide as xi, BufferGeometry as an, Group as so, CylinderGeometry as Pb, SphereGeometry as Ud, BoxGeometry as pa, SpriteMaterial as cx, Sprite as hx, Shape as dx, ExtrudeGeometry as ux, Fog as Ob, DirectionalLight as fp, PointLight as vm, EdgesGeometry as fx, LineSegments as kb, LineBasicMaterial as wm, Line as ma, BufferAttribute as ft, Raycaster as Nd, Sphere as $d, ArrayCamera as px, Plane as rr, SkinnedMesh as oo, InterleavedBufferAttribute as Mb, Skeleton as mx, Bone as gx, WebGLCubeRenderTarget as yx, CubeCamera as _x, AnimationClip as ro, FileLoader as xm, TextureLoader as lc, PropertyBinding as ga, LinearSRGBColorSpace as Ss, ShaderChunk as Ht, UniformsLib as bx, DataTexture as Sm, RGBAFormat as Wd, EquirectangularReflectionMapping as _s, SRGBColorSpace as Cs, Clock as vx, NeutralToneMapping as ya, AgXToneMapping as Vd, ACESFilmicToneMapping as Hd, NoToneMapping as id, PCFSoftShadowMap$1 as wx, BasicNodeLibrary as xx, WebGLRenderTarget as Dn, DepthTexture as Rb, NearestFilter as nd, LoopRepeat as Sx, LoopOnce as pp, AnimationMixer as Cm, CompressedTexture as Cx, FrontSide as fo, Camera as Px, Frustum as ay, AudioListener as Ox, PositionalAudio as kx, AudioLoader as mp, EventDispatcher as Pm, BackSide as Gd, MeshDepthMaterial as Mx, CustomBlending as Rx, MaxEquation as Tx, AmbientLight as Ex, HemisphereLight as Ax, AlwaysStencilFunc as Ix, GreaterEqualStencilFunc as Lx, NotEqualStencilFunc as Dx, GreaterStencilFunc as jx, LessEqualStencilFunc as Bx, EqualStencilFunc as Fx, LessStencilFunc as zx, NeverStencilFunc as ly, InvertStencilOp as Ux, DecrementWrapStencilOp as Nx, IncrementWrapStencilOp as $x, DecrementStencilOp as Wx, IncrementStencilOp as Vx, ReplaceStencilOp as Hx, ZeroStencilOp as Gx, KeepStencilOp as qx, RawShaderMaterial as Tb, GLSL3 as Xx, AlwaysDepth as Qx, GreaterEqualDepth as Yx, GreaterDepth as Kx, LessEqualDepth as Zx, LessDepth as Jx, NotEqualDepth as eS, EqualDepth as tS, BatchedMesh as cy, MeshPhysicalMaterial as gp, LinearFilter as sd, UnsignedByteType as iS, RingGeometry as nS, Line3 as sS, AdditiveBlending as Eb, BoxHelper as oS, SpotLight as rS, DirectionalLightHelper as aS, CameraHelper as lS, LOD as cS, Triangle as hS, NormalBlending as dS, ReinhardToneMapping as Om, LinearToneMapping as km, HalfFloatType as tf, VideoTexture as uS, CubeUVReflectionMapping as Ab, CubeTexture as fS, CompressedCubeTexture as pS, EquirectangularRefractionMapping as mS, CatmullRomCurve3 as gS, VectorKeyframeTrack as yS, QuaternionKeyframeTrack as _S, Audio as bS, ShaderLib as od, UniformsUtils as Ib, MirroredRepeatWrapping as hy, MeshNormalMaterial as vS, AudioContext as wS, PMREMGenerator$1 as xS } from "./three-CsHK73Zc.js";
import { createLoaders as Mm, getRaycastMesh as Lb, LODsManager as Do, NEEDLE_progressive as We, addDracoAndKTX2Loaders as SS, configureLoader as CS, setKTX2TranscoderLocation as PS, setDracoDecoderLocation as OS } from "./gltf-progressive-egsMzRdv.js";
import { GroundedSkybox as _a, Font as kS, TextGeometry as MS, FontLoader as RS, GLTFLoader as Ps, TransformControlsGizmo as Db, EXRLoader as Rm, RGBELoader as jb, Stats as TS, nodeFrame as ES, OrbitControls as Bb, PositionalAudioHelper as AS, HorizontalBlurShader as IS, VerticalBlurShader as LS, GLTFExporter as Fb, strToU8 as zb, zipSync as DS, XRControllerModelFactory as jS, XRHandMeshModel as BS, Line2 as FS, LineGeometry as zS, LineMaterial as US, TransformControls as NS, InteractiveGroup as $S, HTMLMesh as WS, VertexNormalsHelper as VS, OBJLoader as Tm, FBXLoader as Ub, mergeVertices as HS } from "./three-examples-BvMpKSun.js";
import { fetchProfile as GS, MotionController as qS, $70d766613f57b014$export$2e2bcd8739ae039 as dy, ByteBuffer as XS, v5 as uy, md5 as fy, SIZE_PREFIX_LENGTH as Nb, Builder as Em, createNoise4D as QS, Matrix4 as nf, BatchedParticleRenderer as YS, ParticleSystem as KS, RenderMode as ls, ConstantColor as ZS, Vector4 as JS, ConstantValue as eC, TrailParticle as py, WorkerBase as tC, MeshBVH as iC } from "./vendor-k9i6CeGi.js";
import { __webpack_exports__default as Ce, __webpack_exports__Text as $b, __webpack_exports__Block as Wb, __webpack_exports__update as nC, SimpleStateBehavior as sC, __webpack_exports__Inline as sf, __webpack_exports__FontLibrary as my, ThreeMeshUI as gy } from "./three-mesh-ui-CN6aRT7i.js";
import { EffectAttribute as oC } from "./postprocessing-BzFF7i-7.js";
const of = /* @__PURE__ */ new Map();
function hn(s = globalThis.location?.hostname) {
  if (of.has(s)) return of.get(s);
  const e = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|localhost/.test(s);
  return of.set(s, e), e === !0;
}
function rC() {
  return window.location.hostname.includes("glitch.me");
}
const aC = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 160 187.74"><defs><linearGradient id="a" x1="89.64" y1="184.81" x2="90.48" y2="21.85" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#62d399"/><stop offset=".51" stop-color="#acd842"/><stop offset=".9" stop-color="#d7db0a"/></linearGradient><linearGradient id="b" x1="69.68" y1="178.9" x2="68.08" y2="16.77" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#0ba398"/><stop offset=".5" stop-color="#4ca352"/><stop offset="1" stop-color="#76a30a"/></linearGradient><linearGradient id="c" x1="36.6" y1="152.17" x2="34.7" y2="84.19" gradientUnits="userSpaceOnUse"><stop offset=".19" stop-color="#36a382"/><stop offset=".54" stop-color="#49a459"/><stop offset="1" stop-color="#76a30b"/></linearGradient><linearGradient id="d" x1="15.82" y1="153.24" x2="18" y2="90.86" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#267880"/><stop offset=".51" stop-color="#457a5c"/><stop offset="1" stop-color="#717516"/></linearGradient><linearGradient id="e" x1="135.08" y1="135.43" x2="148.93" y2="63.47" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#b0d939"/><stop offset="1" stop-color="#eadb04"/></linearGradient><linearGradient id="f" x1="-4163.25" y1="2285.12" x2="-4160.81" y2="2215.34" gradientTransform="rotate(20 4088.49 13316.712)" gradientUnits="userSpaceOnUse"><stop offset=".17" stop-color="#74af52"/><stop offset=".48" stop-color="#99be32"/><stop offset="1" stop-color="#c0c40a"/></linearGradient><symbol id="g" viewBox="0 0 160 187.74"><path style="fill:url(#a)" d="M79.32 36.98v150.76L95 174.54l6.59-156.31-22.27 18.75z"/><path style="fill:url(#b)" d="M79.32 36.98 57.05 18.23l6.59 156.31 15.68 13.2V36.98z"/><path style="fill:url(#c)" d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33z"/><path style="fill:url(#d)" d="M25.19 104.83 0 90.24l16.97 53.86 16.85 9.77-8.63-49.04z"/><path style="fill:#9c3" d="M43.86 82.5 18.69 67.98 0 90.24l25.18 14.59L43.86 82.5z"/><path style="fill:url(#e)" d="m134.82 78.69-9.97 56.5 15.58-9.04L160 64.1l-25.18 14.59z"/><path style="fill:url(#f)" d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5z"/><path style="fill:#ffe113" d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33L160 64.1z"/><path style="fill:#f3e600" d="M101.59 18.23 79.32 0 57.05 18.23l22.27 18.75 22.27-18.75z"/></symbol></defs><use width="160" height="187.74" xlink:href="#g"/></svg>', lC = btoa(aC), cC = "data:image/svg+xml;base64," + lC, Vb = cC, hC = `<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'> <svg clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" version="1.1" viewBox="0 0 1014 282" xml:space="preserve" xmlns="http://www.w3.org/2000/svg"> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m665.95 132.73v44.88l-10.56-8.4c-0.8-0.64-1.2-1.44-1.2-2.4v-32.4c0-6.48-4.12-9.72-12.36-9.72-2.16 0-4.18 0.4-6.06 1.2s-3.54 1.8-4.98 3-2.56 2.5-3.36 3.9-1.2 2.7-1.2 3.9v40.92l-10.68-8.4c-0.72-0.64-1.08-1.44-1.08-2.4v-53.76l10.92 8.52c0.32 0.24 0.56 0.44 0.72 0.6s0.36 0.32 0.6 0.48c0.96-1.2 2.14-2.28 3.54-3.24s2.92-1.76 4.56-2.4 3.34-1.14 5.1-1.5 3.44-0.54 5.04-0.54c1.44 0 2.92 0.04 4.44 0.12s2.84 0.28 3.96 0.6c4.56 1.12 7.8 3.12 9.72 6s2.88 6.56 2.88 11.04z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m732.38 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m795.93 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m858.57 97.21c0.64 0.48 0.96 1.16 0.96 2.04v74.88c-0.08 1.04-0.12 2.12-0.12 3.24-1.84-1.52-3.56-2.92-5.16-4.2-1.36-1.12-2.66-2.18-3.9-3.18s-2.06-1.66-2.46-1.98c-1.76 2.48-4.26 4.44-7.5 5.88s-7.02 2.16-11.34 2.16c-3.84 0-7.4-0.7-10.68-2.1s-6.14-3.44-8.58-6.12-4.34-5.94-5.7-9.78-2.04-8.16-2.04-12.96c0-4.32 0.78-8.34 2.34-12.06s3.6-6.92 6.12-9.6 5.38-4.78 8.58-6.3 6.48-2.28 9.84-2.28c2.56 0 4.82 0.22 6.78 0.66s3.68 1.06 5.16 1.86 2.78 1.74 3.9 2.82 2.16 2.22 3.12 3.42v-35.04l10.68 8.64zm-27.96 67.92c3.6 0 6.52-0.68 8.76-2.04s3.98-3.06 5.22-5.1 2.1-4.22 2.58-6.54 0.72-4.44 0.72-6.36v-1.2c0-1.12-0.22-2.7-0.66-4.74s-1.28-4.06-2.52-6.06-3-3.7-5.28-5.1-5.22-2.02-8.82-1.86c-3.44 0-6.26 0.74-8.46 2.22s-3.96 3.26-5.28 5.34-2.24 4.2-2.76 6.36-0.78 3.92-0.78 5.28c0 1.84 0.24 3.92 0.72 6.24s1.36 4.48 2.64 6.48 3.04 3.68 5.28 5.04 5.12 2.04 8.64 2.04z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m882.81 97.09c0.64 0.48 0.96 1.12 0.96 1.92l-0.12 41.04v37.08l-10.56-8.4c-0.72-0.64-1.08-1.44-1.08-2.4v-77.88l10.8 8.64z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m950.36 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.8559 0 0 .7642 45.348 36.475)"> <g transform="translate(2.7114)"> <path d="m3.935 173.02c-0.331 0-0.497-0.402-0.497-1.207v-51.002c0-0.738 0.138-1.107 0.414-1.107h1.781c0.277 0 0.415 0.335 0.415 1.006v5.935c0 0.336 0.027 0.553 0.083 0.654 0.055 0.101 0.151-0.017 0.289-0.352 0.912-1.744 1.754-3.236 2.527-4.477 0.773-1.24 1.554-2.179 2.341-2.816s1.65-0.956 2.588-0.956c1.685 0 3.011 0.922 3.977 2.766 0.967 1.845 1.602 3.84 1.905 5.986 0.056 0.268 0.139 0.369 0.249 0.302s0.221-0.235 0.331-0.503c0.939-1.811 1.802-3.353 2.589-4.628 0.787-1.274 1.581-2.246 2.382-2.917s1.671-1.006 2.61-1.006c2.016 0 3.569 1.392 4.66 4.175 1.09 2.783 1.636 6.421 1.636 10.915v37.925c0 0.871-0.18 1.307-0.539 1.307h-1.739c-0.138 0-0.249-0.1-0.332-0.301-0.083-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.338-6.321-1.015-8.3-0.676-1.978-1.76-2.967-3.251-2.967-0.884 0-1.726 0.386-2.527 1.157s-1.519 1.727-2.154 2.867-1.201 2.213-1.699 3.219c-0.248 0.469-0.421 0.905-0.517 1.308-0.097 0.402-0.145 0.972-0.145 1.71v37.221c0 0.871-0.166 1.307-0.497 1.307h-1.74c-0.166 0-0.29-0.1-0.373-0.301-0.083-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.332-6.321-0.994-8.3-0.663-1.978-1.754-2.967-3.273-2.967-1.242 0-2.375 0.704-3.396 2.112-1.022 1.409-2.223 3.555-3.604 6.439v39.031c0 0.805-0.18 1.207-0.539 1.207h-1.698z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m53.642 166.28c-1.077 2.549-2.237 4.477-3.479 5.785-1.243 1.307-2.61 1.961-4.101 1.961-2.154 0-3.853-1.324-5.095-3.973-1.243-2.649-1.864-6.187-1.864-10.613 0-3.488 0.4-6.489 1.201-9.004s1.988-4.51 3.562-5.985c1.574-1.476 3.521-2.414 5.841-2.817l3.686-0.704c0.221-0.067 0.394-0.218 0.518-0.453 0.124-0.234 0.187-0.587 0.187-1.056v-2.917c0-3.89-0.504-6.975-1.512-9.255s-2.354-3.42-4.039-3.42c-1.298 0-2.472 0.72-3.521 2.162s-2.002 3.572-2.858 6.388c-0.083 0.268-0.159 0.453-0.228 0.554-0.069 0.1-0.172 0.083-0.311-0.051l-1.698-1.71c-0.083-0.134-0.138-0.285-0.166-0.453-0.027-0.167 0.014-0.452 0.125-0.855 0.856-3.353 2.009-6.052 3.459-8.098 1.449-2.045 3.224-3.068 5.322-3.068 1.74 0 3.211 0.687 4.412 2.062s2.112 3.37 2.734 5.986c0.621 2.615 0.932 5.7 0.932 9.255v35.712c0 0.536-0.035 0.888-0.104 1.056s-0.2 0.251-0.393 0.251h-1.533c-0.166 0-0.29-0.117-0.373-0.352-0.083-0.234-0.124-0.553-0.124-0.955l-0.083-5.231c-0.055-0.939-0.221-1.006-0.497-0.202zm0.456-19.314c0-1.14-0.194-1.643-0.58-1.509l-3.107 0.603c-1.436 0.202-2.686 0.638-3.749 1.308-1.063 0.671-1.953 1.543-2.671 2.616s-1.257 2.33-1.616 3.772-0.538 3.102-0.538 4.98c0 3.152 0.455 5.616 1.367 7.393 0.911 1.778 2.14 2.666 3.686 2.666 0.939 0 1.85-0.419 2.734-1.257s1.671-1.895 2.361-3.169c0.663-1.408 1.181-2.85 1.553-4.326 0.373-1.475 0.56-2.883 0.56-4.225v-8.852z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m79.034 173.02c-0.166 0-0.297-0.117-0.394-0.352-0.096-0.234-0.145-0.553-0.145-0.955v-4.628c0-0.536-0.041-0.838-0.124-0.905s-0.207 0.1-0.373 0.503c-0.276 0.67-0.69 1.593-1.242 2.766-0.553 1.174-1.271 2.23-2.154 3.169-0.884 0.939-1.961 1.408-3.231 1.408-1.74 0-3.314-0.989-4.722-2.967-1.409-1.979-2.534-4.963-3.376-8.953-0.843-3.991-1.264-8.937-1.264-14.838 0-5.701 0.415-10.68 1.243-14.939s1.988-7.595 3.479-10.009c1.492-2.415 3.204-3.622 5.137-3.622 1.436 0 2.616 0.57 3.541 1.71 0.926 1.14 1.719 2.381 2.382 3.722 0.249 0.47 0.414 0.637 0.497 0.503s0.125-0.536 0.125-1.207v-23.841c0-0.805 0.151-1.208 0.455-1.208h1.864c0.276 0 0.414 0.369 0.414 1.107v72.128c0 0.537-0.041 0.905-0.124 1.107-0.083 0.201-0.235 0.301-0.455 0.301h-1.533zm-0.621-42.049c-0.939-2.213-1.885-3.94-2.838-5.181s-2.009-1.861-3.169-1.861c-1.463 0-2.768 0.889-3.914 2.666s-2.044 4.376-2.693 7.796-0.973 7.578-0.973 12.474c0 5.097 0.338 9.272 1.015 12.524 0.676 3.253 1.567 5.651 2.672 7.193 1.104 1.543 2.305 2.314 3.603 2.314 1.188 0 2.258-0.704 3.211-2.113 0.952-1.408 1.705-3.118 2.257-5.13s0.829-3.957 0.829-5.835v-24.847z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m89.514 149.38c0 3.42 0.345 6.606 1.035 9.557 0.691 2.951 1.609 5.315 2.755 7.092s2.437 2.666 3.873 2.666c1.519 0 2.837-0.738 3.956-2.213 1.118-1.476 2.064-3.655 2.837-6.539 0.083-0.336 0.166-0.52 0.249-0.554 0.083-0.033 0.179 0.017 0.29 0.151l1.408 1.912c0.221 0.268 0.235 0.67 0.041 1.207-0.69 2.548-1.47 4.661-2.34 6.337-0.87 1.677-1.857 2.935-2.962 3.773-1.104 0.838-2.319 1.257-3.645 1.257-2.043 0-3.838-1.14-5.385-3.42-1.546-2.28-2.761-5.482-3.645-9.607-0.884-4.124-1.325-8.836-1.325-14.134 0-5.901 0.455-10.931 1.367-15.089 0.911-4.158 2.14-7.377 3.686-9.658 1.547-2.28 3.3-3.42 5.261-3.42 1.988 0 3.714 1.073 5.178 3.219 1.463 2.146 2.595 5.231 3.396 9.255s1.201 8.886 1.201 14.587c0 0.469-0.02 0.939-0.062 1.408-0.041 0.469-0.214 0.704-0.517 0.704h-16.362c-0.083 0-0.152 0.151-0.207 0.453-0.056 0.302-0.083 0.654-0.083 1.056zm13.752-6.237c0.304 0 0.497-0.1 0.58-0.302 0.083-0.201 0.124-0.57 0.124-1.106 0-3.219-0.283-6.187-0.849-8.903s-1.367-4.896-2.402-6.539c-1.036-1.643-2.272-2.464-3.708-2.464-1.629 0-2.996 0.955-4.101 2.867-1.104 1.911-1.94 4.342-2.506 7.293s-0.849 6.002-0.849 9.154h13.711z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m148.54 119.7c0.165 0 0.283 0.117 0.352 0.352s0.076 0.52 0.02 0.855l-6.254 50.902c-0.028 0.47-0.104 0.788-0.228 0.956s-0.297 0.251-0.518 0.251h-1.615c-0.442 0-0.718-0.402-0.829-1.207l-5.26-40.138c-0.111-0.604-0.201-0.905-0.27-0.905s-0.131 0.301-0.186 0.905l-5.012 40.138c-0.028 0.47-0.097 0.788-0.207 0.956-0.111 0.168-0.277 0.251-0.497 0.251h-1.74c-0.442 0-0.718-0.402-0.829-1.207l-6.503-50.801c-0.055-0.403-0.048-0.721 0.021-0.956s0.2-0.352 0.393-0.352h1.823c0.166 0 0.297 0.067 0.393 0.201 0.097 0.134 0.159 0.403 0.187 0.805l5.302 41.848c0.083 0.671 0.179 0.989 0.29 0.956 0.11-0.034 0.207-0.386 0.29-1.056l5.219-41.949c0.055-0.268 0.124-0.47 0.207-0.604s0.193-0.201 0.331-0.201h1.533c0.138 0 0.262 0.067 0.373 0.201 0.11 0.134 0.179 0.403 0.207 0.805l5.468 41.848c0.083 0.671 0.179 0.989 0.29 0.956 0.11-0.034 0.207-0.386 0.29-1.056l5.053-41.849c0.055-0.335 0.138-0.57 0.249-0.704 0.11-0.134 0.234-0.201 0.373-0.201h1.284z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m156.49 171.51c0 0.604-0.042 1.006-0.125 1.208-0.082 0.201-0.262 0.301-0.538 0.301h-1.533c-0.221 0-0.366-0.083-0.435-0.251s-0.103-0.486-0.103-0.956v-50.902c0-0.805 0.152-1.207 0.456-1.207h1.822c0.304 0 0.456 0.402 0.456 1.207v50.6zm0.165-63.979c0 1.207-0.207 1.811-0.621 1.811h-1.905c-0.221 0-0.366-0.135-0.435-0.403s-0.104-0.67-0.104-1.207v-7.847c0-1.006 0.18-1.509 0.539-1.509h1.988c0.359 0 0.538 0.47 0.538 1.409v7.746z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m168.3 124.83c-0.221 0-0.331 0.269-0.331 0.805v33.801c0 3.42 0.221 5.667 0.663 6.74 0.441 1.073 1.09 1.609 1.946 1.609h3.024c0.138 0 0.242 0.084 0.311 0.252 0.069 0.167 0.103 0.419 0.103 0.754v2.716c0 0.537-0.138 0.906-0.414 1.107-0.248 0.067-0.614 0.134-1.098 0.201-0.483 0.067-0.959 0.118-1.429 0.151-0.469 0.034-0.828 0.05-1.077 0.05-1.712 0-2.934-0.955-3.665-2.867-0.732-1.911-1.098-5.013-1.098-9.305v-35.108c0-0.604-0.124-0.906-0.373-0.906h-3.521c-0.248 0-0.373-0.268-0.373-0.804v-3.521c0-0.537 0.111-0.805 0.332-0.805h3.686c0.166 0 0.263-0.268 0.29-0.805l0.415-16.095c0-0.805 0.124-1.207 0.372-1.207h1.492c0.303 0 0.455 0.436 0.455 1.307v15.995c0 0.537 0.097 0.805 0.29 0.805h5.468c0.221 0 0.331 0.268 0.331 0.805v3.521c0 0.536-0.124 0.804-0.373 0.804h-5.426z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m179.4 173.02c-0.331 0-0.497-0.402-0.497-1.207v-72.329c0-0.738 0.138-1.107 0.414-1.107h1.782c0.276 0 0.414 0.336 0.414 1.006v27.162c0 0.335 0.034 0.536 0.103 0.603s0.159-0.033 0.27-0.302c0.994-1.81 1.898-3.319 2.713-4.526 0.814-1.208 1.629-2.113 2.444-2.717 0.814-0.603 1.691-0.905 2.63-0.905 2.182 0 3.839 1.375 4.971 4.125 1.132 2.749 1.698 6.404 1.698 10.965v37.925c0 0.871-0.166 1.307-0.497 1.307h-1.74c-0.165 0-0.29-0.1-0.373-0.301-0.082-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.366-6.321-1.097-8.3-0.732-1.978-1.899-2.967-3.501-2.967-0.883 0-1.705 0.318-2.464 0.956-0.76 0.637-1.526 1.576-2.299 2.816-0.773 1.241-1.643 2.834-2.61 4.779v39.031c0 0.805-0.179 1.207-0.538 1.207h-1.699z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> </g> <g transform="matrix(.80638 0 0 .80638 452.53 65.421)" fill-rule="nonzero"> <path d="m79.32 36.98v150.76l15.68-13.2 6.59-156.31-22.27 18.75z" fill="url(#f)"/> <path d="m79.32 36.98-22.27-18.75 6.59 156.31 15.68 13.2v-150.76z" fill="url(#e)"/> <path d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33z" fill="url(#d)"/> <path d="m25.19 104.83-25.19-14.59 16.97 53.86 16.85 9.77-8.63-49.04z" fill="url(#c)"/> <path d="M43.86,82.5L18.69,67.98L0,90.24L25.18,104.83L43.86,82.5Z" fill="#9c3"/> <path d="m134.82 78.69-9.97 56.5 15.58-9.04 19.57-62.05-25.18 14.59z" fill="url(#b)"/> <path d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5z" fill="url(#a)"/> <path d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33 25.19-14.59z" fill="#ffe113"/> <path d="M101.59,18.23L79.32,0L57.05,18.23L79.32,36.98L101.59,18.23Z" fill="#f3e600"/> </g> <defs> <linearGradient id="f" x2="1" gradientTransform="matrix(.84 -162.96 162.96 .84 89.64 184.81)" gradientUnits="userSpaceOnUse"><stop stop-color="#62d399" offset="0"/><stop stop-color="#acd842" offset=".51"/><stop stop-color="#d7db0a" offset=".9"/><stop stop-color="#d7db0a" offset="1"/></linearGradient> <linearGradient id="e" x2="1" gradientTransform="matrix(-1.6,-162.13,162.13,-1.6,69.68,178.9)" gradientUnits="userSpaceOnUse"><stop stop-color="#0ba398" offset="0"/><stop stop-color="#4ca352" offset=".5"/><stop stop-color="#76a30a" offset="1"/></linearGradient> <linearGradient id="d" x2="1" gradientTransform="matrix(-1.9,-67.98,67.98,-1.9,36.6,152.17)" gradientUnits="userSpaceOnUse"><stop stop-color="#36a382" offset="0"/><stop stop-color="#36a382" offset=".19"/><stop stop-color="#49a459" offset=".54"/><stop stop-color="#76a30b" offset="1"/></linearGradient> <linearGradient id="c" x2="1" gradientTransform="matrix(2.18,-62.38,62.38,2.18,15.82,153.24)" gradientUnits="userSpaceOnUse"><stop stop-color="#267880" offset="0"/><stop stop-color="#457a5c" offset=".51"/><stop stop-color="#717516" offset="1"/></linearGradient> <linearGradient id="b" x2="1" gradientTransform="matrix(13.85,-71.96,71.96,13.85,135.08,135.43)" gradientUnits="userSpaceOnUse"><stop stop-color="#b0d939" offset="0"/><stop stop-color="#eadb04" offset="1"/></linearGradient> <linearGradient id="a" x2="1" gradientTransform="matrix(26.159 -64.737 64.737 26.159 107.42 128.14)" gradientUnits="userSpaceOnUse"><stop stop-color="#74af52" offset="0"/><stop stop-color="#74af52" offset=".17"/><stop stop-color="#99be32" offset=".48"/><stop stop-color="#c0c40a" offset="1"/></linearGradient> </defs> </svg>`;
btoa(hC);
const dC = '<svg viewBox="0 0 509 154" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M665.95 132.73v44.88l-10.56-8.4c-.8-.64-1.2-1.44-1.2-2.4v-32.4c0-6.48-4.12-9.72-12.36-9.72-2.16 0-4.18.4-6.06 1.2-1.88.8-3.54 1.8-4.98 3-1.44 1.2-2.56 2.5-3.36 3.9-.8 1.4-1.2 2.7-1.2 3.9v40.92l-10.68-8.4c-.72-.64-1.08-1.44-1.08-2.4v-53.76l10.92 8.52c.32.24.56.44.72.6.16.16.36.32.6.48.96-1.2 2.14-2.28 3.54-3.24 1.4-.96 2.92-1.76 4.56-2.4 1.64-.64 3.34-1.14 5.1-1.5 1.76-.36 3.44-.54 5.04-.54 1.44 0 2.92.04 4.44.12 1.52.08 2.84.28 3.96.6 4.56 1.12 7.8 3.12 9.72 6 1.92 2.88 2.88 6.56 2.88 11.04ZM732.38 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14ZM795.93 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14ZM858.57 97.21c.64.48.96 1.16.96 2.04v74.88c-.08 1.04-.12 2.12-.12 3.24-1.84-1.52-3.56-2.92-5.16-4.2-1.36-1.12-2.66-2.18-3.9-3.18-1.24-1-2.06-1.66-2.46-1.98-1.76 2.48-4.26 4.44-7.5 5.88-3.24 1.44-7.02 2.16-11.34 2.16-3.84 0-7.4-.7-10.68-2.1-3.28-1.4-6.14-3.44-8.58-6.12-2.44-2.68-4.34-5.94-5.7-9.78-1.36-3.84-2.04-8.16-2.04-12.96 0-4.32.78-8.34 2.34-12.06 1.56-3.72 3.6-6.92 6.12-9.6 2.52-2.68 5.38-4.78 8.58-6.3 3.2-1.52 6.48-2.28 9.84-2.28 2.56 0 4.82.22 6.78.66 1.96.44 3.68 1.06 5.16 1.86s2.78 1.74 3.9 2.82a35.92 35.92 0 0 1 3.12 3.42V88.57l10.68 8.64Zm-27.96 67.92c3.6 0 6.52-.68 8.76-2.04 2.24-1.36 3.98-3.06 5.22-5.1a20.5 20.5 0 0 0 2.58-6.54c.48-2.32.72-4.44.72-6.36v-1.2c0-1.12-.22-2.7-.66-4.74-.44-2.04-1.28-4.06-2.52-6.06s-3-3.7-5.28-5.1c-2.28-1.4-5.22-2.02-8.82-1.86-3.44 0-6.26.74-8.46 2.22-2.2 1.48-3.96 3.26-5.28 5.34-1.32 2.08-2.24 4.2-2.76 6.36-.52 2.16-.78 3.92-.78 5.28 0 1.84.24 3.92.72 6.24.48 2.32 1.36 4.48 2.64 6.48s3.04 3.68 5.28 5.04c2.24 1.36 5.12 2.04 8.64 2.04ZM882.81 97.09c.64.48.96 1.12.96 1.92l-.12 41.04v37.08l-10.56-8.4c-.72-.64-1.08-1.44-1.08-2.4V88.45l10.8 8.64ZM950.36 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14Z" style="fill-rule:nonzero" transform="translate(-452.406 -63.709) scale(1.00797)"/><path d="M79.32 36.98v150.76L95 174.54l6.59-156.31-22.27 18.75Z" style="fill:url(#a);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M79.32 36.98 57.05 18.23l6.59 156.31 15.68 13.2V36.98Z" style="fill:url(#b);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33Z" style="fill:url(#c);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M25.19 104.83 0 90.24l16.97 53.86 16.85 9.77-8.63-49.04Z" style="fill:url(#d);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M43.86 82.5 18.69 67.98 0 90.24l25.18 14.59L43.86 82.5Z" style="fill:#9c3;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m134.82 78.69-9.97 56.5 15.58-9.04L160 64.1l-25.18 14.59Z" style="fill:url(#e);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5Z" style="fill:url(#f);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33L160 64.1Z" style="fill:#ffe113;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M101.59 18.23 79.32 0 57.05 18.23l22.27 18.75 22.27-18.75Z" style="fill:#f3e600;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><defs><linearGradient id="a" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="matrix(.84 -162.96 162.96 .84 89.64 184.81)"><stop offset="0" style="stop-color:#62d399;stop-opacity:1"/><stop offset=".51" style="stop-color:#acd842;stop-opacity:1"/><stop offset=".9" style="stop-color:#d7db0a;stop-opacity:1"/><stop offset="1" style="stop-color:#d7db0a;stop-opacity:1"/></linearGradient><linearGradient id="b" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-90.565 123.412 54.953) scale(162.14)"><stop offset="0" style="stop-color:#0ba398;stop-opacity:1"/><stop offset=".5" style="stop-color:#4ca352;stop-opacity:1"/><stop offset="1" style="stop-color:#76a30a;stop-opacity:1"/></linearGradient><linearGradient id="c" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="scale(-68) rotate(88.4 .881 -1.396)"><stop offset="0" style="stop-color:#36a382;stop-opacity:1"/><stop offset=".19" style="stop-color:#36a382;stop-opacity:1"/><stop offset=".54" style="stop-color:#49a459;stop-opacity:1"/><stop offset="1" style="stop-color:#76a30b;stop-opacity:1"/></linearGradient><linearGradient id="d" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-88 87.255 68.431) scale(62.42)"><stop offset="0" style="stop-color:#267880;stop-opacity:1"/><stop offset=".51" style="stop-color:#457a5c;stop-opacity:1"/><stop offset="1" style="stop-color:#717516;stop-opacity:1"/></linearGradient><linearGradient id="e" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-79.1 149.53 -14.065) scale(73.28)"><stop offset="0" style="stop-color:#b0d939;stop-opacity:1"/><stop offset="1" style="stop-color:#eadb04;stop-opacity:1"/></linearGradient><linearGradient id="f" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-67.997 148.705 -15.558) scale(69.8226)"><stop offset="0" style="stop-color:#74af52;stop-opacity:1"/><stop offset=".17" style="stop-color:#74af52;stop-opacity:1"/><stop offset=".48" style="stop-color:#99be32;stop-opacity:1"/><stop offset="1" style="stop-color:#c0c40a;stop-opacity:1"/></linearGradient></defs></svg>', uC = btoa(dC), fC = "data:image/svg+xml;charset=utf-8;base64," + uC, pC = fC, yy = typeof window !== void 0 ? window.location.search.includes("debugcontext") : !1;
var he = /* @__PURE__ */ ((s) => (s.ContextRegistered = "ContextRegistered", s.ContextCreationStart = "ContextCreationStart", s.ContextCreated = "ContextCreated", s.ContextFirstFrameRendered = "ContextFirstFrameRendered", s.ContextDestroying = "ContextDestroying", s.ContextDestroyed = "ContextDestroyed", s.MissingCamera = "MissingCamera", s.ContextClearing = "ContextClearing", s.ContextCleared = "ContextCleared", s))(he || {});
class ue {
  /** The currently active (rendering) Needle Engine context */
  static get Current() {
    return globalThis["NeedleEngine.Context.Current"];
  }
  /** @internal */
  static set Current(e) {
    globalThis["NeedleEngine.Context.Current"] = e;
  }
  /** Returns the array of all registered Needle Engine contexts. Do not modify */
  static get All() {
    return this.Registered;
  }
  /** All currently registered Needle Engine contexts. Do not modify */
  static Registered = [];
  /** @internal Internal use only */
  static register(e) {
    this.Registered.indexOf(e) === -1 && (yy && console.warn("Registering context"), this.Registered.push(e), this.dispatchCallback("ContextRegistered", e));
  }
  /** @internal Internal use only */
  static unregister(e) {
    const t = this.Registered.indexOf(e);
    t !== -1 && (yy && console.warn("Unregistering context"), this.Registered.splice(t, 1));
  }
  static _callbacks = {};
  /**
   * Register a callback to be called when the given event occurs
   */
  static registerCallback(e, t) {
    this._callbacks[e] || (this._callbacks[e] = []), this._callbacks[e].push(t);
  }
  /** Unregister a callback */
  static unregisterCallback(e, t) {
    if (!this._callbacks[e]) return;
    const i = this._callbacks[e].indexOf(t);
    i !== -1 && this._callbacks[e].splice(i, 1);
  }
  /** @internal */
  static dispatchCallback(e, t, i) {
    if (!this._callbacks[e]) return !0;
    const n = { event: e, context: t };
    if (i)
      for (const r in i)
        n[r] = i[r];
    const o = new Array();
    return this._callbacks[e].forEach((r) => {
      const a = r(n);
      a instanceof Promise && o.push(a);
    }), Promise.all(o);
  }
  /**
   * Register a callback to be called when a context is created
   */
  static addContextCreatedCallback(e) {
    this.registerCallback("ContextCreated", e);
  }
  /**
   * Register a callback to be called when a context is registered
   */
  static addContextDestroyedCallback(e) {
    this.registerCallback("ContextDestroyed", e);
  }
}
const mC = () => (s) => s;
function OI(s) {
  return mC()(s);
}
function kI() {
  return !!w("debug");
}
class Hi {
  _factory;
  _cache = [];
  _maxSize;
  _index = 0;
  constructor(e, t) {
    this._factory = e, this._maxSize = t;
  }
  get() {
    const e = this._index % this._maxSize;
    return this._index++, this._cache.length <= e && (this._cache[e] = this._factory()), this._cache[e];
  }
}
let Vo = !1;
const yp = new Array();
typeof window < "u" && setTimeout(() => {
  if (Vo) {
    const s = {}, e = new URL(window.location.href), t = new URL(e);
    t.searchParams.append("console", "");
    const i = t.toString().replace(/=$|=(?=&)/g, "");
    for (const o of yp) {
      const r = new URL(e);
      r.searchParams.append(o, ""), s[o] = r.toString().replace(/=$|=(?=&)/g, "");
    }
    console.log(
      `🌵 ?help: Debug Options for Needle Engine.
Append any of these parameters to the URL to enable specific debug options.
Example: ${i} will show an onscreen console window.`
    );
    const n = Vo === !0 ? "" : ` (containing "${Vo}")`;
    console.group("Available URL parameters:" + n);
    for (const o of Object.keys(s).sort())
      typeof Vo == "string" && !o.toLowerCase().includes(Vo.toLowerCase()) || (console.groupCollapsed(o), console.log("Reload with this flag enabled:"), console.log(s[o]), console.groupEnd());
    console.groupEnd();
  }
}, 100);
function qd() {
  return new URLSearchParams(globalThis.location?.search);
}
function w(s) {
  Vo && !yp.includes(s) && yp.push(s);
  const e = qd();
  if (e.has(s)) {
    const t = e.get(s);
    if (t) {
      const i = Number(t);
      return isNaN(i) ? t : i;
    } else return !0;
  }
  return !1;
}
Vo = w("help");
function MI(s, e) {
  const t = qd();
  t.has(s) ? t.set(s, e) : t.append(s, e), document.location.search = t.toString();
}
function rd(s, e, t = !0) {
  const i = qd();
  i.has(s) ? e === null ? i.delete(s) : i.set(s, e) : e !== null && i.append(s, e), t ? gC(s, i) : Hb(s, i);
}
function _y(s, e, t) {
  s.has(e) ? s.set(e, t.toString()) : s.append(e, t.toString());
}
function gC(s, e, t) {
  window.history.pushState(t, s, "?" + e.toString());
}
function Hb(s, e, t) {
  window.history.replaceState(t, s, "?" + e.toString());
}
function RI(s) {
  for (var e = "", t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", i = t.length, n = 0; n < s; n++)
    e += t.charAt(Math.floor(Math.random() * i));
  return e;
}
function TI(s, e) {
  return Math.floor(Math.random() * (e - s + 1)) + s;
}
const by = ["smol", "tiny", "giant", "interesting", "smart", "bright", "dull", "extreme", "beautiful", "pretty", "dark", "epic", "salty", "silly", "funny", "lame", "lazy", "loud", "lucky", "mad", "mean", "mighty", "mysterious", "nasty", "odd", "old", "powerful", "quiet", "rapid", "scary", "shiny", "shy", "silly", "smooth", "sour", "spicy", "stupid", "sweet", "tasty", "terrible", "ugly", "unusual", "vast", "wet", "wild", "witty", "wrong", "zany", "zealous", "zippy", "zombie", "zorro"], vy = ["cat", "dog", "mouse", "pig", "cow", "horse", "sheep", "chicken", "duck", "goat", "panda", "tiger", "lion", "elephant", "monkey", "bird", "fish", "snake", "frog", "turtle", "hamster", "penguin", "kangaroo", "whale", "dolphin", "crocodile", "snail", "ant", "bee", "beetle", "butterfly", "dragon", "eagle", "fish", "giraffe", "lizard", "panda", "penguin", "rabbit", "snake", "spider", "tiger", "zebra"];
function yC() {
  const s = by[Math.floor(Math.random() * by.length)], e = vy[Math.floor(Math.random() * vy.length)];
  return s + "_" + e;
}
function _C(s) {
  return s = s.replace(/[^a-z0-9áéíóúñü \.,_-]/gim, ""), s.trim();
}
function cc(s, e, t = !0, i = !1) {
  if (e == null) return null;
  if (e.userData && e.userData.guid === s) return e;
  if (e.guid == s) return e;
  if (i && e.userData?.components) {
    for (const n of e.userData.components)
      if (n.guid === s) return n;
  }
  if (t) {
    if (e.scenes)
      for (const n in e.scenes) {
        const o = e.scenes[n], r = cc(s, o, t, i);
        if (r) return r;
      }
    if (e.children)
      for (const n in e.children) {
        const o = e.children[n], r = cc(s, o, t, i);
        if (r) return r;
      }
  }
}
function Xd(s, e) {
  if (s != null && typeof s == "object") {
    let t;
    Array.isArray(s) ? t = [] : (t = Object.create(s), Object.assign(t, s));
    for (const i of Object.keys(s)) {
      const n = s[i];
      e && !e(s, i, n) ? t[i] = n : n?.clone !== void 0 && typeof n.clone == "function" ? t[i] = n.clone() : t[i] = Xd(n, e);
    }
    return t;
  }
  return s;
}
function Os(s) {
  return new Promise((e, t) => {
    setTimeout(e, s);
  });
}
function Qd(s, e) {
  if (s <= 0) return Promise.resolve();
  if (e || (e = ue.Current), !e) return Promise.reject("No context");
  const t = e.time.frameCount + s;
  return new Promise((i, n) => {
    if (!e) return n("No context");
    const o = () => {
      e.time.frameCount >= t && (e.pre_update_callbacks.splice(e.pre_update_callbacks.indexOf(o), 1), i());
    };
    e.pre_update_callbacks.push(o);
  });
}
const eh = w("debugresolveurl"), bC = "rel:";
function EI(s, e) {
  return gr(s, e);
}
function gr(s, e) {
  if (e === void 0)
    return eh && console.warn("getPath: uri is undefined, returning uri", e), e;
  if (e.startsWith("./"))
    return e;
  if (e.startsWith("http"))
    return eh && console.warn("getPath: uri is absolute, returning uri", e), e;
  if (s === void 0)
    return eh && console.warn("getPath: source is undefined, returning uri", e), e;
  e.startsWith(bC) && (e = e.substring(4));
  const t = s.lastIndexOf("/");
  if (t >= 0) {
    const i = s.substring(0, t + 1);
    for (; i.endsWith("/") && e.startsWith("/"); ) e = e.substring(1);
    const n = i + e;
    return eh && console.log("source:", s, `changed uri 
from`, e, `
to `, n, `
basePath: ` + i), n;
  }
  return e;
}
class vC {
  subscribeWrite(e) {
    this.writeCallbacks.push(e);
  }
  unsubscribeWrite(e) {
    const t = this.writeCallbacks.indexOf(e);
    t !== -1 && this.writeCallbacks.splice(t, 1);
  }
  writeCallbacks = [];
  constructor(e, t) {
    this._object = e, this._prop = t, this._wrapperProp = Symbol("$" + t), this.apply();
  }
  _applied = !1;
  _object;
  _prop;
  _wrapperProp;
  apply() {
    if (this._applied || !this._object) return;
    const e = this._object, t = this._prop;
    if (e[t] === void 0) return;
    this._applied = !0, e[this._wrapperProp] !== void 0 && console.warn("Watcher is being applied to an object that already has a wrapper property. This is not (yet) supported");
    const i = e[t];
    e[this._wrapperProp] = i, Object.defineProperty(e, t, {
      get: () => e[this._wrapperProp],
      set: (r) => {
        e[this._wrapperProp] = r;
        for (const a of this.writeCallbacks)
          a(r, this._prop);
      }
    });
  }
  revoke() {
    if (!this._applied || !this._object) return;
    this._applied = !1;
    const e = this._object, t = this._prop;
    Reflect.deleteProperty(e, t);
    const i = e[this._wrapperProp];
    e[t] = i, Reflect.deleteProperty(e, this._wrapperProp);
  }
  dispose() {
    this.revoke(), this.writeCallbacks.length = 0, this._object = null;
  }
}
class ao {
  _watches = [];
  constructor(e, t) {
    if (Array.isArray(t))
      for (const i of t)
        this._watches.push(new ao(e, i));
    else
      this._watches.push(new vC(e, t));
  }
  subscribeWrite(e) {
    for (const t of this._watches)
      t.subscribeWrite(e);
  }
  unsubscribeWrite(e) {
    for (const t of this._watches)
      t.unsubscribeWrite(e);
  }
  apply() {
    for (const e of this._watches)
      e.apply();
  }
  revoke() {
    for (const e of this._watches)
      e.revoke();
  }
  dispose() {
    for (const e of this._watches)
      e.dispose();
    this._watches.length = 0;
  }
}
const Nr = Symbol("needle:watches");
function Am(s, e) {
  if (!s[Nr])
    if (s instanceof J)
      s[Nr] = new ao(s, ["x", "y"]);
    else if (s instanceof y)
      s[Nr] = new ao(s, ["x", "y", "z"]);
    else if (s instanceof fe || s instanceof U)
      s[Nr] = new ao(s, ["x", "y", "z", "w"]);
    else
      return !1;
  return s[Nr].subscribeWrite(e), !0;
}
function Gb(s, e) {
  if (!s) return;
  const t = s[Nr];
  t && t.unsubscribeWrite(e);
}
var q;
((s) => {
  let e;
  function t() {
    if (e !== void 0) return e;
    const V = window.navigator.userAgent, ne = /Windows|MacOS|Mac OS/.test(V), re = /Windows NT/.test(V) && /Edg/.test(V) && !/Win64/.test(V);
    return e = ne && !re && !_();
  }
  s.isDesktop = t;
  let i;
  function n() {
    return i !== void 0 ? i : typeof window.orientation < "u" || navigator.userAgent.indexOf("IEMobile") !== -1 ? i = !0 : i = /iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent);
  }
  s.isMobileDevice = n;
  function o() {
    return a();
  }
  s.isIPad = o;
  let r;
  function a() {
    return r !== void 0 ? r : r = /iPad/.test(navigator.userAgent);
  }
  s.isiPad = a;
  let l;
  function c() {
    return l !== void 0 ? l : l = /Android/.test(navigator.userAgent);
  }
  s.isAndroidDevice = c;
  let h;
  function d() {
    return h !== void 0 ? h : h = /WebXRViewer\//i.test(navigator.userAgent);
  }
  s.isMozillaXR = d;
  let f;
  function p() {
    if (f !== void 0) return f;
    if (navigator.userAgentData)
      return f = navigator.userAgentData.platform === "macOS";
    {
      const V = navigator.userAgent.toLowerCase();
      return f = V.includes("mac os x") || V.includes("macintosh");
    }
  }
  s.isMacOS = p;
  let g;
  function b() {
    return g !== void 0 ? g : g = p() && "xr" in navigator;
  }
  s.isVisionOS = b;
  let m;
  const v = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"];
  function _() {
    return m !== void 0 ? m : m = v.includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  s.isiOS = _;
  let x;
  function I() {
    return x !== void 0 || (x = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), x;
  }
  s.isSafari = I;
  let O;
  function k() {
    return O !== void 0 ? O : O = navigator.userAgent.includes("OculusBrowser");
  }
  s.isQuest = k;
  let E;
  function B() {
    return E !== void 0 || (E = document.createElement("a").relList.supports("ar")), E;
  }
  s.supportsQuickLookAR = B;
  async function D() {
    try {
      return (await navigator.permissions.query({ name: "microphone" })).state !== "denied";
    } catch (V) {
      return console.error("Error querying `microphone` permissions.", V), !1;
    }
  }
  s.microphonePermissionsGranted = D;
  let W;
  function X() {
    if (W !== void 0) return W;
    const V = navigator.userAgent.match(/iPhone OS (\d+_\d+)/);
    if (V && (W = V[1].replace("_", ".")), !W) {
      const ne = navigator.userAgent.match(/(?:\(Macintosh;|iPhone;|iPad;).*Version\/(\d+\.\d+)/);
      ne && (W = ne[1]);
    }
    return W || (W = null), W;
  }
  s.getiOSVersion = X;
  let A;
  function $() {
    if (A !== void 0) return A;
    const V = navigator.userAgent.match(/(?:CriOS|Chrome)\/(\d+\.\d+\.\d+\.\d+)/);
    return V ? A = V[1].replace("_", ".") : A = null, A;
  }
  s.getChromeVersion = $;
})(q || (q = {}));
function AI() {
  return q.isDesktop();
}
function II() {
  return q.isMobileDevice();
}
function LI() {
  return q.isiPad();
}
function DI() {
  return q.isiPad();
}
function jI() {
  return q.isAndroidDevice();
}
function BI() {
  return q.isMozillaXR();
}
function FI() {
  return q.isMacOS();
}
function zI() {
  return q.isiOS();
}
function UI() {
  return q.isSafari();
}
function NI() {
  return q.isQuest();
}
async function $I() {
  return q.microphonePermissionsGranted();
}
const eo = /* @__PURE__ */ new WeakMap();
function wC(s, e, t) {
  if (!eo.get(s)) {
    const n = new MutationObserver((o) => {
      SC(s, o);
    });
    eo.set(s, {
      observer: n,
      attributeChangedListeners: /* @__PURE__ */ new Map()
    }), n.observe(s, { attributes: !0 });
  }
  const i = eo.get(s).attributeChangedListeners;
  i.has(e) || i.set(e, []), i.get(e).push(t);
}
function xC(s, e, t) {
  if (!eo.get(s)) return;
  const i = eo.get(s).attributeChangedListeners;
  if (!i.has(e)) return;
  const n = i.get(e), o = n.indexOf(t);
  o !== -1 && (n.splice(o, 1), n.length <= 0 && (i.delete(e), eo.get(s)?.observer.disconnect(), eo.delete(s)));
}
function SC(s, e) {
  const t = eo.get(s).attributeChangedListeners;
  for (const i of e)
    if (i.type === "attributes") {
      const n = i.attributeName, o = s.getAttribute(n);
      if (t.has(n))
        for (const r of t.get(n))
          r(o);
    }
}
class wy {
  reason;
  constructor(e) {
    this.reason = e;
  }
}
async function qb(s) {
  const e = await Promise.allSettled(s).catch((n) => [
    new wy(n.message)
  ]);
  let t = !1;
  const i = e.map((n) => "value" in n ? n.value : (t = !0, new wy(n.reason)));
  return {
    anyFailed: t,
    results: i
  };
}
async function CC(s) {
  if (!globalThis.QRCode) {
    const l = "https://cdn.jsdelivr.net/gh/davidshimjs/qrcodejs@gh-pages/qrcode.min.js";
    let c = document.head.querySelector(`script[src="${l}"]`);
    c || (c = document.createElement("script"), c.src = l, document.head.appendChild(c)), await new Promise((h, d) => {
      c.addEventListener("load", () => {
        h(!0);
      });
    });
  }
  const e = globalThis.QRCode, t = s.domElement ?? document.createElement("div"), i = new e(t, {
    width: s.width ?? 256,
    height: s.height ?? 256,
    colorDark: "#000000",
    colorLight: "#ffffff",
    correctLevel: s.showLogo ? e.CorrectionLevel.H : e.CorrectLevel.M,
    ...s
  }), n = i?._oQRCode.moduleCount || 0, o = i?._oDrawing?._elCanvas;
  let r = 0.25;
  n < 40 ? r = Math.floor(n / 4) / n : r = Math.floor(n / 6) / n;
  const a = Math.floor(n / 20) / n;
  try {
    const l = await PC(o, { showLogo: s.showLogo, logoSize: r, logoPadding: a }).catch((c) => {
    });
    l && (t.innerHTML = "", t.append(l));
  } catch {
  }
  if (s.showUrl !== !1 && s.text) {
    const l = t.querySelector(".qr-code-link-label");
    let c = s.text.replace(/^(https?:\/\/)?(www\.)?/, "").replace(/\/+$/, "").replace(/\?+$/, "");
    if (c = "Scan to visit " + c, l)
      l.textContent = c;
    else {
      const h = document.createElement("div");
      h.classList.add("qr-code-link-label"), s.text = c, h.textContent = s.text, h.addEventListener("click", (d) => {
        d.stopImmediatePropagation();
      }), h.style.textAlign = "center", h.style.fontSize = "0.8em", h.style.marginTop = "0.1em", h.style.color = "#000000", h.style.fontFamily = "'Roboto Flex', sans-serif", h.style.opacity = "0.5", h.style.wordBreak = "break-all", h.style.wordWrap = "break-word", h.style.marginBottom = "0.3em", t.style.width = "calc(210px + 20px)", t.appendChild(h);
    }
  }
  return t;
}
async function PC(s, e) {
  if (!s) return;
  const t = 8, i = 20, n = e.logoPadding || 1 / 32, o = "transparent", r = 0, a = new Image(), c = document.querySelector("needle-engine")?.getAttribute("loading-logo-src") || Vb;
  if (!c) return;
  let h = !1;
  e.showLogo !== !1 && (a.src = c, h = await new Promise((_, x) => {
    a.onload = () => _(!0), a.onerror = (I) => {
      console.error("Error loading favicon image for QR code", I), _(!1);
    };
  }));
  const d = document.createElement("canvas");
  d.width = s.width + t, d.height = s.height + t;
  const f = d.getContext("2d");
  if (!f)
    return;
  f.fillStyle = "#ffffff", f.fillRect(0, 0, d.width, d.height), f.drawImage(s, t / 2, t / 2), f.imageSmoothingEnabled = !0, f.imageSmoothingQuality = "high", f.mozImageSmoothingEnabled = !0, f.webkitImageSmoothingEnabled = !0, f.globalCompositeOperation = "lighten";
  const p = f.createLinearGradient(0, 0, 0, d.height);
  p.addColorStop(0, "rgb(45, 45, 45)"), p.addColorStop(1, "rgb(45, 45, 45)"), f.fillStyle = p, f.fillRect(0, 0, d.width, d.height), f.globalCompositeOperation = "source-over";
  let g = Math.min(s.width, s.height) * (e.logoSize || 0.25), b = g;
  if (h) {
    const _ = a.width / a.height;
    _ > 1 ? b = g / _ : g = b * _;
    const x = n * s.width, I = Math.max(g, b), O = Math.round(I + x), k = Math.round(I + x), E = (d.width - I) / 2, B = (d.height - I) / 2;
    f.shadowColor = o, f.shadowBlur = i;
    const D = r, W = Math.round(E - x / 2), X = Math.round(B - x / 2);
    f.beginPath(), f.moveTo(W + D, X), f.lineTo(W + O - D, X), f.quadraticCurveTo(W + O, X, W + O, X + D), f.lineTo(W + O, X + k - D), f.quadraticCurveTo(W + O, X + k, W + O - D, X + k), f.lineTo(W + D, X + k), f.quadraticCurveTo(W, X + k, W, X + k - D), f.lineTo(W, X + D), f.quadraticCurveTo(W, X, W + D, X), f.fillStyle = "#ffffff", f.closePath(), f.fill(), f.clip(), f.shadowColor = "transparent";
    const A = (d.width - g) / 2, $ = (d.height - b) / 2;
    f.drawImage(a, A, $, g, b);
  }
  const m = d.toDataURL("image/png"), v = document.createElement("img");
  return v.src = m, v.style.width = "100%", v.style.height = "auto", v;
}
const OC = w("debugdebug");
let Im = !1;
(w("noerrors") || w("nooverlaymessages")) && (Im = !0);
const rf = "needle_engine_global_error_container";
var Wi = /* @__PURE__ */ ((s) => (s[s.Log = 0] = "Log", s[s.Warn = 1] = "Warn", s[s.Error = 2] = "Error", s))(Wi || {});
function Xb() {
  return Yb;
}
const _p = new Array();
function kC(s) {
  _p.push(s);
}
let af = !1;
function MC(...s) {
  if (!af) {
    af = !0;
    try {
      for (let e = 0; e < _p.length; e++)
        _p[e](...s);
    } catch (e) {
      console.error(e);
    }
    af = !1;
  }
}
const Qb = console.error, RC = function(...s) {
  Qb.apply(console, s), AC(s), Qo(2, s), EC(...s);
};
function TC(s) {
  Im = !s, s ? console.error = RC : console.error = Qb;
}
function WI(s) {
  return TC(s);
}
let Yb = 0;
function EC(...s) {
  Yb += 1, MC(...s);
}
function AC(s) {
  if (Array.isArray(s))
    for (let e = 0; e < s.length; e++) {
      const t = s[e];
      typeof t == "string" && t.startsWith("THREE.PropertyBinding: Trying to update node for track:") && (s[e] = "Some animated objects couldn't be found: see console for details");
    }
}
function Qo(s, e, t, i) {
  if (Im) return;
  const o = ue.Current?.domElement ?? document.querySelector("needle-engine");
  if (o) {
    if (Array.isArray(e)) {
      let r = "";
      for (let a = 0; a < e.length; a++) {
        let l = e[a];
        l instanceof Error && (l = l.message), typeof l != "object" && (a > 0 && (r += " "), r += l);
      }
      e = r;
    }
    !e || e.length <= 0 || IC(s, o, e);
  }
}
const Hl = /* @__PURE__ */ new Map();
function IC(s, e, t) {
  if (t == null) return;
  const i = DC(e);
  if (i.childElementCount >= 20) {
    const a = i.lastElementChild;
    xy(a);
  }
  t.length > 400 && (t = t.substring(0, 400) + "...");
  const n = t;
  if (Hl.has(n))
    return;
  const o = jC(s, t);
  i.prepend(o);
  const r = () => {
    Hl.delete(n), xy(o);
  };
  Hl.set(n, r), setTimeout(r, 1e4);
}
function VI() {
  OC && console.log("Clearing messages");
  for (const s of Hl.values())
    s?.call(s);
  Hl.clear();
}
const LC = `

@import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

div[data-needle_engine_debug_overlay] {
    font-family: 'Roboto Flex', sans-serif;
    font-weight: 400;
    font-size: 16px;
}

div[data-needle_engine_debug_overlay] strong {
    font-weight: 700;
}

div[data-needle_engine_debug_overlay] a {
    color: white;
    text-decoration: none;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

div[data-needle_engine_debug_overlay] a:hover {
    text-decoration: none;
    border: none;
}

div[data-needle_engine_debug_overlay] .log strong {
    color: rgba(200,200,200,.9);
}

div[data-needle_engine_debug_overlay] .warn strong {
    color: rgba(255,255,230, 1);
}

div[data-needle_engine_debug_overlay] .error strong {
    color: rgba(255,100,120, 1);
}
`;
function DC(s) {
  globalThis[rf] || (globalThis[rf] = /* @__PURE__ */ new Map());
  const e = globalThis[rf];
  if (e.has(s))
    return e.get(s);
  {
    const t = document.createElement("div");
    e.set(s, t), t.setAttribute("data-needle_engine_debug_overlay", ""), t.classList.add("debug-container"), t.style.cssText = `
            position: absolute;
            top: 0;
            right: 5px;
            padding-top: 0px;
            max-width: 70%;
            max-height: calc(100% - 5px);
            z-index: 9999999999;
            pointer-events: scroll;
            display: flex;
            align-items: end;
            flex-direction: column;
            color: white;
            overflow: auto;
            word-break: break-word;
        `, s.shadowRoot ? s.shadowRoot.appendChild(t) : s.appendChild(t);
    const i = document.createElement("style");
    return i.innerHTML = LC, t.appendChild(i), t;
  }
}
const Kb = Symbol("logtype"), ad = /* @__PURE__ */ new Map();
function xy(s) {
  s.remove();
  const e = s[Kb], t = ad.get(e) ?? [];
  t.push(s), ad.set(e, t);
}
function jC(s, e) {
  if (ad.has(s)) {
    const i = ad.get(s);
    if (i.length > 0) {
      const n = i.pop();
      return n.innerHTML = e, n;
    }
  }
  const t = document.createElement("div");
  switch (t.setAttribute("data-id", "__needle_engine_debug_overlay"), t.style.marginRight = "5px", t.style.padding = ".5em", t.style.backgroundColor = "rgba(0,0,0,.9)", t.style.marginTop = "5px", t.style.marginBottom = "3px", t.style.borderRadius = "8px", t.style.pointerEvents = "all", t.style.userSelect = "text", t.style.maxWidth = "250px", t.style.whiteSpace = "pre-wrap", t.style["backdrop-filter"] = "blur(10px)", t.style["-webkit-backdrop-filter"] = "blur(10px)", t.style.backgroundColor = "rgba(20,20,20,.8)", t.style.boxShadow = "inset 0 0 80px rgba(0,0,0,.2), 0 0 5px rgba(0,0,0,.2)", t.style.border = "1px solid rgba(160,160,160,.2)", t[Kb] = s, s) {
    case 0:
      t.classList.add("log"), t.style.color = "rgba(200,200,200,.7)", t.style.backgroundColor = "rgba(40,40,40,.7)";
      break;
    case 1:
      t.classList.add("warn"), t.style.color = "rgb(255, 255, 150)", t.style.backgroundColor = "rgba(50,50,20,.8)";
      break;
    case 2:
      t.classList.add("error"), t.style.color = "rgb(255, 50, 50", t.style.backgroundColor = "rgba(50,20,20,.8)";
      break;
  }
  return t.title = "Open the browser console (F12) for more information", t.innerHTML = e, t;
}
class BC {
  random(e, t) {
    return Array.isArray(e) ? e.length <= 0 ? null : e[Math.floor(Math.random() * e.length)] : e !== void 0 && t !== void 0 ? Math.random() * (t - e) + e : Math.random();
  }
  randomVector3(e, t = 0, i = 1) {
    e.x = this.random(t, i), e.y = this.random(t, i), e.z = this.random(t, i);
  }
  clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  clamp01(e) {
    return this.clamp(e, 0, 1);
  }
  /**
   * Linear interpolate
   */
  lerp(e, t, i) {
    return i = i < 0 ? 0 : i, i = i > 1 ? 1 : i, e + (t - e) * i;
  }
  /**
   * 
   */
  inverseLerp(e, t, i) {
    return (i - e) / (t - e);
  }
  /**
   * Remaps a value from one range to another.
   * @param value The value to remap.
   * @param min1 The minimum value of the current range.
   * @param max1 The maximum value of the current range.
   * @param min2 The minimum value of the target range.
   * @param max2 The maximum value of the target range.
   */
  remap(e, t, i, n, o) {
    return n + (o - n) * (e - t) / (i - t);
  }
  moveTowards(e, t, i) {
    return e += i, (i < 0 && e < t || i > 0 && e > t) && (e = t), e;
  }
  Rad2Deg = 180 / Math.PI;
  Deg2Rad = Math.PI / 180;
  Epsilon = 1e-5;
  /**
   * Converts radians to degrees
   */
  toDegrees(e) {
    return e * 180 / Math.PI;
  }
  /**
   * Converts degrees to radians
   */
  toRadians(e) {
    return e * Math.PI / 180;
  }
  tan(e) {
    return Math.tan(e);
  }
  gammaToLinear(e) {
    return Math.pow(e, 2.2);
  }
  linearToGamma(e) {
    return Math.pow(e, 1 / 2.2);
  }
  approximately(e, t, i = Number.EPSILON) {
    for (const n of FC) {
      const o = e[n], r = t[n];
      if (o === void 0 || r === void 0) break;
      if (Math.abs(o - r) > i)
        return !1;
    }
    return !0;
  }
  easeInOutCubic(e) {
    return e < 0.5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2;
  }
}
const FC = ["x", "y", "z", "w"], j = new BC();
class Sy {
  y;
  s;
  alpha = 0;
  constructor(e) {
    this.setAlpha(e), this.y = null, this.s = null;
  }
  setAlpha(e) {
    if (e <= 0 || e > 1)
      throw new Error();
    this.alpha = e;
  }
  filter(e, t) {
    t && this.setAlpha(t);
    let i;
    return this.y ? i = this.alpha * e + (1 - this.alpha) * this.s : i = e, this.y = e, this.s = i, i;
  }
  lastValue() {
    return this.y;
  }
  reset(e) {
    this.y = e, this.s = e;
  }
}
class lf {
  /**
   * An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   */
  freq;
  /**
   * Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   */
  minCutOff;
  /**
   * Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   */
  beta;
  /**
   * Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  dCutOff;
  /**
   * The low-pass filter for the signal.
   */
  x;
  /**
   * The low-pass filter for the derivates.
   */
  dx;
  /**
   * The last time the filter was called.
   */
  lasttime;
  /** Create a new OneEuroFilter
   * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  constructor(e, t = 1, i = 0, n = 1) {
    if (e <= 0 || t <= 0 || n <= 0)
      throw new Error();
    this.freq = e, this.minCutOff = t, this.beta = i, this.dCutOff = n, this.x = new Sy(this.alpha(this.minCutOff)), this.dx = new Sy(this.alpha(this.dCutOff)), this.lasttime = null;
  }
  alpha(e) {
    const t = 1 / this.freq;
    return 1 / (1 + 1 / (2 * Math.PI * e) / t);
  }
  /** Filter your value: call with your value and the current timestamp (e.g. from this.context.time.time) */
  filter(e, t = null) {
    this.lasttime && t && (this.freq = 1 / (t - this.lasttime)), this.lasttime = t;
    const i = this.x.lastValue(), n = i ? (e - i) * this.freq : 0, o = this.dx.filter(n, this.alpha(this.dCutOff)), r = this.minCutOff + this.beta * Math.abs(o);
    return this.x.filter(e, this.alpha(r));
  }
  reset(e) {
    e != null && this.x.reset(e), this.x.alpha = this.alpha(this.minCutOff), this.dx.alpha = this.alpha(this.dCutOff), this.lasttime = null;
  }
}
class Zb {
  x;
  y;
  z;
  /** Create a new OneEuroFilter
   * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  constructor(e, t = 1, i = 0, n = 1) {
    this.x = new lf(e, t, i, n), this.y = new lf(e, t, i, n), this.z = new lf(e, t, i, n);
  }
  filter(e, t, i = null) {
    t.x = this.x.filter(e.x, i), t.y = this.y.filter(e.y, i), t.z = this.z.filter(e.z, i);
  }
  reset(e) {
    this.x.reset(e?.x), this.y.reset(e?.y), this.z.reset(e?.z);
  }
}
const Bh = "needle:cameraController";
function zC(s) {
  return s[Bh];
}
function Cy(s, e, t) {
  t ? s[Bh] = e : s[Bh] === e && (s[Bh] = null);
}
const bp = "needle:autofit";
function UC(s) {
  return s[bp] === void 0 ? !0 : s[bp] !== !1;
}
function vp(s, e) {
  s[bp] = e;
}
let Kn;
const NC = { x: 0, y: 0, width: 0, height: 0 };
function $C(s, e, t, i) {
  s instanceof Element && (s = s.getBoundingClientRect()), Kn = i.domElement.getBoundingClientRect();
  const n = NC;
  n.x = s.x, n.y = s.y, n.width = s.width, n.height = s.height, n.x -= Kn.x, n.y -= Kn.y;
  const o = n.width / -2 - (n.x - Kn.width / 2), r = n.height / -2 - (n.y - Kn.height / 2), a = t.view;
  let l = a?.offsetX || 0, c = a?.offsetY || 0;
  l = j.lerp(l, o, e), c = j.lerp(c, r, e), t.setViewOffset(Kn.width, Kn.height, l, c, Kn.width, Kn.height), t.updateProjectionMatrix();
}
function HI(s, e, t) {
  const i = s.length(), n = e.length(), o = j.lerp(i, n, t);
  return s.lerp(e, t).normalize().multiplyScalar(o);
}
const cf = new U(), Jb = new U().setFromAxisAngle(new y(0, 1, 0), Math.PI);
function GI(s, e) {
  s.lookAt(e), s.quaternion.multiply(Jb);
}
function Yd(s, e, t = !0, i = !1) {
  if (s === e) return;
  cf.copy(s.quaternion);
  const n = Z(e), o = Z(s);
  if (i) {
    if (jn(s, be(e)), t) {
      const r = o.y, a = o.sub(KC(s));
      a.y = r, s.lookAt(a), s.quaternion.multiply(Jb);
    }
    Number.isNaN(s.quaternion.x) && s.quaternion.copy(cf);
    return;
  }
  t && (n.y = o.y), s.lookAt(n), Number.isNaN(s.quaternion.x) && s.quaternion.copy(cf);
}
function qI(s, e, t, i = 1) {
  if (t) {
    const n = H(0, 0, 0), o = e.x / window.innerWidth * 2 - 1, r = -(e.y / window.innerHeight) * 2 + 1;
    n.set(
      o,
      r,
      0
    ), n.unproject(t);
    const a = t.worldPosition, l = s.worldPosition.distanceTo(a), c = n.sub(a);
    c.multiplyScalar(i * 3.6 * l);
    const h = t.worldPosition.add(c);
    return s.lookAt(h), h;
  }
  return null;
}
const WC = new Hi(() => new y(), 100);
function H(s, e, t) {
  const i = WC.get();
  return i.set(0, 0, 0), s instanceof y ? i.copy(s) : Array.isArray(s) ? i.set(s[0], s[1], s[2]) : s instanceof DOMPointReadOnly ? i.set(s.x, s.y, s.z) : typeof s == "number" ? (i.x = s, i.y = e !== void 0 ? e : i.x, i.z = t !== void 0 ? t : i.x) : typeof s == "object" && (i.x = s.x, i.y = s.y, i.z = s.z), i;
}
const VC = new Hi(() => new se(), 30);
function HC(s) {
  const e = VC.get();
  return s ? e.copy(s) : e.set(0, 0, 0), e;
}
const GC = new Hi(() => new U(), 100);
function ui(s) {
  const e = GC.get();
  return e.identity(), s instanceof U ? e.copy(s) : s instanceof DOMPointReadOnly && e.set(s.x, s.y, s.z, s.w), e;
}
const Lm = new Hi(() => new y(), 100), Py = Symbol("lastMatrixWorldUpdateKey");
function Z(s, e = null, t = !0) {
  const i = e ?? Lm.get();
  return s ? s.parent ? (t && s.updateWorldMatrix(!0, !1), s.matrixWorldNeedsUpdate && s[Py] !== Date.now() && (s[Py] = Date.now(), s.updateMatrixWorld()), i.setFromMatrixPosition(s.matrixWorld), i) : i.copy(s.position) : i.set(0, 0, 0);
}
function Ot(s, e) {
  if (!s) return s;
  const t = Lm.get();
  return e !== t && t.copy(e), (s?.parent ?? s).worldToLocal(t), s.position.set(t.x, t.y, t.z), s;
}
function ba(s, e, t, i) {
  const n = Lm.get();
  return n.set(e, t, i), Ot(s, n), s;
}
const ld = new Hi(() => new U(), 100), Ko = new U(), hf = new U();
function be(s, e = null) {
  if (!s) return ld.get().identity();
  const t = e ?? ld.get();
  return s.parent ? (s.getWorldQuaternion(t), t) : t.copy(s.quaternion);
}
function jn(s, e) {
  if (!s) return;
  e !== Ko && Ko.copy(e);
  const t = Ko;
  s?.parent?.getWorldQuaternion(hf), hf.invert();
  const n = hf.multiply(t);
  s.quaternion.set(n.x, n.y, n.z, n.w);
}
function e0(s, e, t, i, n) {
  Ko.set(e, t, i, n), jn(s, Ko);
}
const qC = new Hi(() => new y(), 100), XC = new y();
function Qe(s, e = null) {
  return e || (e = qC.get()), s ? s.parent ? (s.getWorldScale(e), e) : e.copy(s.scale) : e.set(0, 0, 0);
}
function hc(s, e) {
  if (!s) return;
  if (!s.parent) {
    s.scale.copy(e);
    return;
  }
  const t = XC;
  s.parent.getWorldScale(t), s.scale.copy(e), s.scale.divide(t);
}
const QC = new y(), Oy = new U();
function XI(s) {
  return be(s, Oy), QC.set(0, 0, 1).applyQuaternion(Oy);
}
const YC = new Hi(() => new y(), 100), ky = new U();
function KC(s, e) {
  return e || (e = YC.get().set(0, 0, 1)), be(s, ky), e.applyQuaternion(ky);
}
const My = new ot(), Ry = new ot(), ZC = new y();
function t0(s) {
  const e = ld.get();
  return s.getWorldQuaternion(e), Ry.setFromQuaternion(e), Ry;
}
function i0(s, e) {
  const t = ld.get();
  jn(s, t.setFromEuler(e));
}
function Dm(s) {
  const e = t0(s), t = ZC;
  return t.set(e.x, e.y, e.z), t.x = j.toDegrees(t.x), t.y = j.toDegrees(t.y), t.z = j.toDegrees(t.z), t;
}
function JC(s, e) {
  Kd(s, e.x, e.y, e.z, !0);
}
function Kd(s, e, t, i, n = !0) {
  n && (e = j.toRadians(e), t = j.toRadians(t), i = j.toRadians(i)), My.set(e, t, i), Ko.setFromEuler(My), jn(s, Ko);
}
function wp(s, e = !0) {
  s && (e ? (function t(i) {
    console.groupCollapsed((i.name ? i.name : "(no name : " + i.type + ")") + " %o", i), i.children.forEach(t), console.groupEnd();
  })(s) : s.traverse(function(t) {
    for (var i = "|___", n = t; n.parent !== null; )
      i = "	" + i, n = n.parent;
    console.log(i + t.name + " <" + t.type + ">");
  }));
}
function QI(s) {
  let e = s?.name || "";
  if (!s) return e;
  let t = s.parent;
  for (; t; )
    e = t.name + "/" + e, t = t.parent;
  return e;
}
function e1(s) {
  if (s) {
    const e = s;
    return e.blendMode !== void 0 && e.clampWhenFinished !== void 0 && e.enabled !== void 0 && e.fadeIn !== void 0 && e.getClip !== void 0;
  }
  return !1;
}
class cd extends Ln {
  static vertex = `
varying vec2 vUv;
void main(){
    vUv = uv;
    gl_Position = vec4(position.xy, 0., 1.0);
}`;
  constructor() {
    super({
      vertexShader: cd.vertex,
      uniforms: {
        map: new $i(null),
        flipY: new $i(!0),
        writeDepth: new $i(!1),
        depthTexture: new $i(null)
      },
      fragmentShader: `
uniform sampler2D map;
uniform bool flipY;
uniform bool writeDepth;
uniform sampler2D depthTexture;

varying vec2 vUv;

void main(){ 
    vec2 uv = vUv;
    if (flipY) uv.y = 1.0 - uv.y;
    gl_FragColor = texture2D(map, uv);

    if (writeDepth) {
        float depth = texture2D(depthTexture, uv).r;
        gl_FragDepth = depth;

        // float linearDepth = (depth - 0.99) * 100.0; // Enhance near 1.0 values
        // gl_FragColor = vec4(linearDepth, linearDepth, linearDepth, 1.0);
    }
}`
    });
  }
  reset() {
    this.uniforms.map.value = null, this.uniforms.flipY.value = !0, this.uniforms.writeDepth.value = !1, this.uniforms.depthTexture.value = null, this.needsUpdate = !0, this.uniformsNeedUpdate = !0;
  }
}
class ar {
  static planeGeometry = new Nn(2, 2, 1, 1);
  static renderer = new mr({ antialias: !1, alpha: !0 });
  static perspectiveCam = new de();
  static orthographicCam = new zd();
  static scene = new wi();
  static blitMaterial = new cd();
  static mesh = new G(ar.planeGeometry, ar.blitMaterial);
  /** 
   * Copy a texture to a new texture
   * @param texture the texture to copy
   * @param blitMaterial the material to use for copying (optional)
   * @returns the newly created, copied texture
  */
  static copyTexture(e, t) {
    t || (t = this.blitMaterial), this.blitMaterial.reset();
    const i = t || this.blitMaterial;
    i.uniforms.map.value = e, i.needsUpdate = !0, i.uniformsNeedUpdate = !0;
    const n = i.vertexShader;
    i.vertexShader = cd.vertex;
    const o = this.mesh;
    o.material = i, o.frustumCulled = !1, this.scene.children.length = 0, this.scene.add(o), this.renderer.setSize(e.image.width, e.image.height), this.renderer.clear(), this.renderer.render(this.scene, this.perspectiveCam);
    const r = new Te(this.renderer.domElement);
    return r.name = "Copy", r.needsUpdate = !0, i.vertexShader = n, r;
  }
  static blit(e, t, i) {
    const {
      renderer: n = this.renderer,
      blitMaterial: o = this.blitMaterial,
      flipY: r = !1,
      depthTexture: a = null,
      depthTest: l = !0,
      depthWrite: c = !0
    } = i || {};
    this.blitMaterial.reset(), o.uniforms.map && (o.uniforms.map.value = e), o.uniforms.flipY && (o.uniforms.flipY.value = r), a ? (o.uniforms.writeDepth = new $i(!0), o.uniforms.depthTexture.value = a) : (o.uniforms.writeDepth = new $i(!1), o.uniforms.depthTexture.value = null), o.needsUpdate = !0, o.uniformsNeedUpdate = !0;
    const h = this.mesh;
    h.material = o, h.frustumCulled = !1, this.scene.children.length = 0, this.scene.add(h);
    const d = n.getRenderTarget(), f = n.getContext(), p = f.getParameter(f.DEPTH_TEST), g = f.getParameter(f.DEPTH_WRITEMASK), b = f.getParameter(f.DEPTH_FUNC);
    l ? n.getContext().enable(n.getContext().DEPTH_TEST) : n.getContext().disable(n.getContext().DEPTH_TEST), n.state.buffers.depth.setMask(c), n.setClearColor(new se(0, 0, 0), 0), n.pixelRatio !== window.devicePixelRatio && n.xr.isPresenting === !1 && n.setPixelRatio(window.devicePixelRatio), n.setRenderTarget(t), n.clear(), n.render(this.scene, this.perspectiveCam), n.setRenderTarget(d);
    const m = n.state.buffers.depth;
    m.setTest(p), m.setMask(g), m.setFunc(b);
  }
  /**
   * Copy a texture to a HTMLCanvasElement
   * @param texture the texture convert
   * @param force if true the texture will be copied to a new texture before converting
   * @returns the HTMLCanvasElement with the texture or null if the texture could not be copied
   */
  static textureToCanvas(e, t = !1) {
    if (!e)
      return null;
    (t === !0 || e.isCompressedTexture === !0) && (e = t1(e));
    const i = e.image;
    if (i1(i)) {
      const n = document.createElement("canvas");
      n.width = i.width, n.height = i.height;
      const o = n.getContext("2d");
      return o ? (o.drawImage(i, 0, 0, i.width, i.height, 0, 0, n.width, n.height), n) : (console.error("Failed getting canvas 2d context"), null);
    }
    return null;
  }
}
function t1(s) {
  return ar.copyTexture(s);
}
function YI(s, e = !1) {
  return ar.textureToCanvas(s, e);
}
function i1(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas || typeof ImageBitmap < "u" && s instanceof ImageBitmap;
}
function n1(s) {
  const e = s.type;
  return e === "Mesh" || e === "SkinnedMesh";
}
function n0(s, e) {
  e ? s["needle:rendercustomshadow"] = !0 : s["needle:rendercustomshadow"] = !1;
}
function s1(s) {
  if (s) {
    if (s["needle:rendercustomshadow"] === !0)
      return !0;
    if (s["needle:rendercustomshadow"] == null)
      return !0;
  }
  return !1;
}
function ii(s, e = void 0, t = void 0, i = void 0) {
  const n = i || new bi();
  n.makeEmpty();
  const o = [];
  function r(l) {
    let c = !0;
    if (l.visible && UC(l) !== !1 && !(l.type === "TransformControlsGizmo" || l.type === "TransformControlsPlane")) {
      if (l instanceof lx && (c = !1), l instanceof bm && (c = !1), l instanceof _a && (c = !1), l.isGizmo === !0 && (c = !1), l.material instanceof Sb && (c = !1), n1(l) || (c = !1), t && l.layers.test(t) === !1 && (c = !1), c) {
        if (e && Array.isArray(e) && e?.includes(l)) return;
        if (typeof e == "function" && e(l) === !0)
          return;
      }
      if (l.isUI !== !0) {
        if (c) {
          const h = l.children;
          l.children = o;
          const d = l.position, f = l.scale;
          if (Number.isNaN(d.x) || Number.isNaN(d.y) || Number.isNaN(d.z)) {
            console.warn(`Object "${l.name}" has NaN values in position or scale.... will ignore it`, d, f);
            return;
          }
          l.geometry === null && (l.geometry = void 0), n.expandByObject(l, !0), l.children = h;
        }
        for (const h of l.children)
          r(h);
      }
    }
  }
  let a = !1;
  Array.isArray(s) || (s = [s]);
  for (const l of s)
    l && (a = !0, l.updateMatrixWorld(), r(l));
  return a || console.warn("No objects to fit camera to..."), n;
}
function o1(s, e, t) {
  const i = ii([s], t?.ignore), n = new y();
  i.getSize(n);
  const o = new y();
  i.getCenter(o);
  const r = new y();
  e.getSize(r);
  const a = new y();
  e.getCenter(a);
  const l = new y();
  l.set(r.x / n.x, r.y / n.y, r.z / n.z);
  const c = Math.min(l.x, l.y, l.z), h = t?.scale !== !1;
  if (h && hc(s, Qe(s).multiplyScalar(c)), t?.position !== !1) {
    const d = new y();
    i.getCenter(d), d.y = i.min.y;
    const f = new y();
    e.getCenter(f), f.y = e.min.y;
    const p = f.clone().sub(d);
    h && p.multiplyScalar(c), Ot(s, Z(s).add(p));
  }
  return {
    boundsBefore: i,
    scale: l
  };
}
function r1(s, e) {
  const t = ii([s]), i = new y();
  t.getCenter(i), i.y = t.min.y;
  const n = e.clone().sub(i), o = Z(s);
  return Ot(s, o.add(n)), {
    offset: n,
    bounds: t
  };
}
function s0(s, e, t, i) {
  if (Array.isArray(e)) {
    let r = !0;
    for (let a = 0; a < e.length; a++)
      s0(s, e[a], a, e) || (r = !1);
    return r;
  }
  if (e.type === "MeshStandardMaterial" || e.type === "MeshBasicMaterial")
    return !1;
  if (e["material:fbx"] != null)
    return !0;
  const n = new ut();
  n["material:fbx"] = e;
  const o = e;
  return o && (o.map ? n.color.set(1, 1, 1) : n.color.copyLinearToSRGB(o.color), n.emissive.copyLinearToSRGB(o.emissive), n.emissiveIntensity = o.emissiveIntensity, n.opacity = o.opacity, n.displacementScale = o.displacementScale, n.transparent = o.transparent, n.bumpMap = o.bumpMap, n.aoMap = o.aoMap, n.map = o.map, n.displacementMap = o.displacementMap, n.emissiveMap = o.emissiveMap, n.normalMap = o.normalMap, n.envMap = o.envMap, n.alphaMap = o.alphaMap, n.metalness = o.reflectivity, n.vertexColors = o.vertexColors, o.shininess && (n.roughness = 1 - Math.sqrt(o.shininess) / 10), n.needsUpdate = !0), t === void 0 ? s.material = n : i[t] = n, !0;
}
let th = !1;
kC((...s) => {
  L() && ue.Current?.isInXR && (ia(!0), o0("error", ...s));
});
function ia(s) {
  if (s) {
    if (th) return;
    th = !0, l1();
  } else {
    if (!th) return;
    th = !1, c1();
  }
}
const Gl = {
  log: void 0,
  warn: void 0,
  error: void 0
};
class a1 {
  familyName = "needle-xr";
  root = null;
  context = null;
  defaultFontSize = 0.06;
  constructor() {
    this.ensureFont();
  }
  onEnable() {
    this.context = ue.Current || ue.All[0], this.context.pre_render_callbacks.push(this.onBeforeRender);
  }
  onDisable() {
    this.context?.pre_render_callbacks.splice(this.context?.pre_render_callbacks.indexOf(this.onBeforeRender), 1), this.root?.removeFromParent();
  }
  targetObject = new M();
  /** this is a point in forward view of the user */
  userForwardViewPoint = new y();
  oneEuroFilter = new Zb(90, 0.8);
  _lastElementRemoveTime = 0;
  onBeforeRender = () => {
    const e = this.context?.mainCamera;
    if (this.context && e instanceof de) {
      const t = this.getRoot();
      Number.isNaN(t.position.x) && t.position.set(0, 0, 0), Number.isNaN(t.quaternion.x) && t.quaternion.set(0, 0, 0, 1), this.context.scene.add(this.targetObject);
      const i = this.context.xr?.rigScale ?? 1, n = 3.5 * i, o = e.worldForward;
      o.y = 0, o.normalize().multiplyScalar(n), this.userForwardViewPoint.copy(e.worldPosition).sub(o), this.targetObject.position.distanceTo(this.userForwardViewPoint) > 2 * i && (this.targetObject.position.copy(this.userForwardViewPoint), Yd(this.targetObject, e, !0, !0), this.targetObject.rotateY(Math.PI)), this.oneEuroFilter.filter(this.targetObject.position, t.position, this.context.time.time);
      const a = this.context.time.deltaTime;
      if (t.quaternion.slerp(this.targetObject.quaternion, a * 5), t.scale.setScalar(i), this.targetObject.removeFromParent(), this.context.scene.add(t), this.context.time.time - this._lastElementRemoveTime > 0.1) {
        this._lastElementRemoveTime = this.context.time.time;
        const l = Date.now();
        for (let c = 0; c < this._activeTexts.length; c++) {
          const h = this._activeTexts[c];
          if (h instanceof Ce.Text && l - h._activatedTime > 2e4) {
            h.removeFromParent(), this._textBuffer.push(h), this._activeTexts.splice(c, 1);
            break;
          }
        }
      }
    }
  };
  addLog(e, t) {
    const i = this.getRoot(), n = this.getText();
    let o = 16777215, r = 0;
    switch (e) {
      case "log":
        o = 16777215, r = 0;
        break;
      case "warn":
        o = 16772761, r = 4465152;
        break;
      case "error":
        o = 16755370, r = 7798784;
        break;
    }
    t.length > 1e3 && (t = t.substring(0, 1e3) + "...");
    const a = (/* @__PURE__ */ new Date()).toISOString().split("T")[1].split(".")[0];
    n.textContent = "[" + a + "] " + t, n.visible = !0, n._activatedTime = Date.now(), i.add(n), this._activeTexts.push(n), this.context && this.context.scene.add(i), n.set({
      backgroundColor: o,
      color: r
    }), Ce.update();
  }
  ensureFont() {
    let e = Ce.FontLibrary.getFontFamily(this.familyName);
    e || (e = Ce.FontLibrary.addFontFamily(this.familyName), e.addVariant("normal", "normal", "./include/needle/arial-msdf.json", "./include/needle/arial.png")?.addEventListener("ready", () => {
      Ce.update();
    }));
  }
  textOptions = {
    fontSize: this.defaultFontSize,
    fontFamily: this.familyName,
    padding: 0.03,
    margin: 5e-3,
    color: 0,
    backgroundColor: 16777215,
    backgroundOpacity: 0.4,
    borderRadius: 0.03,
    offset: 0.025
  };
  _textBuffer = [];
  _activeTexts = [];
  getText() {
    const e = this.getRoot();
    if (this._textBuffer.length > 0) {
      const i = this._textBuffer.pop();
      return i.visible = !0, setTimeout(() => this.disableDepthTestRecursive(i), 100), i;
    }
    if (e.children.length > 20 && this._activeTexts.length > 0)
      return this._activeTexts.shift();
    const t = new Ce.Text(this.textOptions);
    return setTimeout(() => this.disableDepthTestRecursive(t), 500), setTimeout(() => this.disableDepthTestRecursive(t), 1500), t;
  }
  disableDepthTestRecursive(e, t = 0) {
    for (let n = 0; n < e.children.length; n++) {
      const o = e.children[n];
      o instanceof M && this.disableDepthTestRecursive(o, t + 1);
    }
    e.renderOrder = 10 * t, e.layers.set(2);
    const i = e.material;
    i && (i.depthWrite = !1, i.depthTest = !1, i.transparent = !0), t === 0 && Ce.update();
  }
  getRoot() {
    if (this.root)
      return this.root;
    const e = this.defaultFontSize, t = {
      boxSizing: "border-box",
      fontFamily: this.familyName,
      width: "2.6",
      fontSize: e,
      color: 0,
      lineHeight: 1,
      backgroundColor: 16777215,
      backgroundOpacity: 0,
      // borderColor: 0xffffff,
      // borderOpacity: .5,
      // borderWidth: 0.01,
      // padding: 0.01,
      whiteSpace: "pre-wrap",
      flexDirection: "column-reverse"
    };
    return this.root = new Ce.Block(t), this.root;
  }
}
let Zo = null;
function l1() {
  Zo || (Zo = new a1()), Zo.onEnable();
  for (const s in Gl) {
    Gl[s] = console[s];
    let e = !1;
    console[s] = function() {
      if (Gl[s]?.apply(console, arguments), !e)
        try {
          e = !0, o0(s, ...arguments);
        } finally {
          e = !1;
        }
    };
  }
}
function c1() {
  Zo?.onDisable();
  for (const s in Gl)
    console[s] = Gl[s];
}
const ll = /* @__PURE__ */ new Map();
function o0(s, ...e) {
  try {
    switch (ll.clear(), s) {
      case "log":
        Zo?.addLog("log", t());
        break;
      case "warn":
        Zo?.addLog("warn", t());
        break;
      case "error":
        Zo?.addLog("error", t());
        break;
    }
  } catch (o) {
    console.error("Error in spatial console", o);
  } finally {
    ll.clear();
  }
  function t() {
    let o = "";
    for (let r = 0; r < e.length; r++) {
      const a = e[r];
      o += i(a), r < e.length - 1 && (o += ", ");
    }
    return o;
  }
  function i(o, r = 0) {
    if (typeof o == "string")
      return '"' + o + '"';
    if (typeof o == "number") {
      if (o % 1 !== 0) {
        const l = o.toFixed(5), c = l.indexOf(".");
        let h = l.length - 1;
        for (; h > c && l[h] === "0"; ) h--;
        return l.substring(0, h + 1);
      }
      return o.toString();
    } else if (Array.isArray(o)) {
      let a = "[";
      for (let l = 0; l < o.length; l++) {
        const c = o[l];
        a += i(c, r + 1), l < o.length - 1 && (a += ", ");
      }
      return a += "]", a;
    } else {
      if (o === null)
        return "null";
      if (o === void 0)
        return "undefined";
      if (typeof o == "function")
        return o.name + "()";
    }
    if (o instanceof J) return `(${i(o.x)}, ${i(o.y)})`;
    if (o instanceof y) return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)})`;
    if (o instanceof fe) return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)}, ${i(o.w)})`;
    if (o instanceof U) return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)}, ${i(o.w)})`;
    if (o instanceof _e || o instanceof Te) return o.name;
    if (o instanceof Cb) return `[${o.elements.join(", ")}]`;
    if (o instanceof ee) return `[${o.elements.join(", ")}]`;
    if (o instanceof ho) return o.mask.toString();
    if (typeof o == "object") {
      if (ll.has(o)) return "*";
      let a = `{
`;
      a += n(r);
      const l = Object.keys(o);
      let c = "";
      for (let h = 0; h < l.length; h++) {
        const d = l[h], f = o[d];
        if (ll.has(f)) {
          c += "";
          continue;
        }
        ll.set(f, !0), c += d + ":" + i(f, r + 1), h < l.length - 1 && (c += ", "), c.length >= 60 && (c += `
`, c += n(r), a += c, c = "");
      }
      return a += c, a += `
}`, a;
    }
    return o;
  }
  function n(o) {
    let r = "";
    for (let a = 0; a < o; a++)
      r += " ";
    return r;
  }
}
const h1 = w("nodevlogs");
function Be(s, e = Wi.Log) {
  Qo(e, s);
}
function ge(s) {
  Be(s, Wi.Warn);
}
function Zd(s) {
  Be(s, Wi.Error);
}
let xp, df;
function L() {
  if (h1) return !1;
  if (xp !== void 0) return xp;
  if (df !== void 0) return df;
  let s = hn();
  return s || (s = window.location.hostname.endsWith(".local-credentialless.webcontainer.io")), df = s, s;
}
function KI(s) {
  xp = s;
}
let Ui, jo = null, On = null, cl = !1, Ty = null;
const r0 = "terminal", d1 = w("console");
d1 && a0();
const u1 = Symbol("consoleParent");
function a0() {
  if (Ui) {
    Ui.showSwitch();
    return;
  }
  _1();
}
function f1() {
  Ui && (Ui.hide(), Ui.hideSwitch());
}
function p1() {
  Ty || (Ty = setInterval(m1, 500));
}
let Ey = 0;
function m1() {
  const s = Xb(), e = s !== Ey;
  Ey = s, e && g1();
}
function g1() {
  a0(), On && (On.setAttribute("error", "true"), On.innerText = "🤬");
}
function y1() {
  On && (On.removeAttribute("error"), On.innerText = r0);
}
function _1(s = !1) {
  if (Ui !== void 0 || cl) return;
  cl = !0;
  const e = document.createElement("script");
  e.onload = () => {
    if (!globalThis.VConsole) {
      console.warn("🌵 Debug console failed to load."), cl = !1, Ui = null;
      return;
    }
    cl = !1, p1(), Ui = new VConsole({
      // defaultPlugins: ['system', 'network'],
      pluginOrder: ["default", "needle-console"]
    });
    const t = globalThis["needle:codegen_files"];
    if (t && t.length > 0 && Ui.addPlugin(b1()), jo = w1(), jo && (jo[u1] = jo.parentElement, jo.style.position = "absolute", jo.style.zIndex = Number.MAX_SAFE_INTEGER.toString()), Ui.setSwitchPosition(20, 30), On = v1(), On) {
      On.innerText = r0, On.addEventListener("click", y1);
      const i = document.createElement("style"), n = 40;
      i.innerHTML = `
                #__vconsole .vc-switch {
                    border: 1px solid rgba(255, 255, 255, .1);
                    border-radius: 50%;
                    width: ${n}px;
                    height: ${n}px;
                    padding: 0;
                    line-height: ${n}px;
                    font-size: ${n * 0.4}px;
                    text-align: center;
                    background: #ffffff5c;
                    backdrop-filter: blur(16px);
                    -webkit-backdrop-filter: blur(16px);
                    user-select: none;
                    pointer-events: auto;
                    transition: transform .2s ease-in-out;
                    box-shadow: 0px 7px 0.5rem 0px rgb(0 0 0 / 6%), inset 0px 0px 1.3rem rgba(0,0,0,.05);

                    font-family: 'Material Symbols Outlined';
                    color: black;
                    font-size: 2.3em;
                    font-weight: 100;
                }
                #__vconsole .vc-switch:hover {
                    cursor: pointer;
                    transform: scale(1.1);
                    transition: transform .1s ease-in-out, background .1s linear;
                    background: rgba(245, 245, 245, .8);
                    outline: rgba(0, 0, 0, .05) 1px solid;
                }
                #__vconsole .vc-switch[error] {
                    background: rgba(255,0,0,.2);
                    animation: vconsole-notify 1s ease-in-out;
                    line-height: 35px;
                }
                @keyframes vconsole-notify {
                    from {
                        transform: scale(1, 1);
                    }
                    10% {
                        transform: scale(1.3, 1.3);
                    }
                    70% {
                        transform: scale(1.4, 1.4);
                    }
                    to {
                        transform: scale(1, 1);
                    }
                }
                #__vconsole .vc-panel {
                    font-family: monospace;
                    font-size: 11px;
                }
                #__vconsole .vc-plugin-box.vc-actived {
                    height: 100%;
                }
                #__vconsole .vc-mask {
                    overflow: hidden;
                }
            `, jo?.prepend(i), s === !0 && Xb() <= 0 && f1(), console.log("🌵 Debug console has loaded");
    }
  }, e.onerror = () => {
    console.warn("🌵 Debug console failed to load." + (window.crossOriginIsolated ? "This page is using cross-origin isolation, so external scripts can't be loaded." : "")), cl = !1, Ui = null;
  }, e.src = "https://cdn.jsdelivr.net/npm/vconsole@3.15.1/dist/vconsole.min.js", document.body.appendChild(e);
}
function b1() {
  if (!globalThis.VConsole) return;
  const s = new VConsole.VConsolePlugin("needle-console", "🌵 Inspect glTF"), e = () => document.querySelector("#__vc_plug_" + s._id + " iframe");
  return s.on("renderTab", function(t) {
    const i = globalThis["needle:codegen_files"];
    if (!i || i.length === 0) return;
    let n = globalThis["needle:codegen_files"][0];
    const o = n.indexOf("?");
    o > -1 && (n = n.substring(0, o));
    const a = location.protocol + "//" + location.host + location.pathname + "/" + n, l = encodeURIComponent(a);
    s.fullUrl = "https://viewer.needle.tools?inspect&file=" + l;
    var c = '<iframe src="" style="width: 100%; height: 99%; border: none;"></iframe>';
    t(c);
  }), s.on("show", function() {
    const t = e();
    t && t.src !== s.fullUrl && (t.src = s.fullUrl);
  }), s.on("hide", function() {
    const t = e();
    t && (t.src = "");
  }), s.on("addTopBar", function(t) {
    var i = new Array();
    i.push({
      name: "Open in new window ↗",
      onClick: function(n) {
        window.open(s.fullUrl, "_blank"), Ui?.hide();
      }
    }), i.push({
      name: "Reload",
      onClick: function(n) {
        const o = e();
        o && (o.src = s.fullUrl);
      }
    }), i.push({
      name: "Fullscreen",
      onClick: function(n) {
        const o = e();
        o.requestFullscreen ? o.requestFullscreen() : o.webkitRequestFullscreen instanceof Function && o.webkitRequestFullscreen();
      }
    }), t(i);
  }), s;
}
function v1() {
  const s = document.querySelector("#__vconsole .vc-switch");
  return s || null;
}
function w1() {
  const s = document.querySelector("#__vconsole");
  return s || null;
}
const l0 = w("debugdefines");
go('if(!globalThis["NEEDLE_ENGINE_VERSION"]) globalThis["NEEDLE_ENGINE_VERSION"] = "0.0.0";');
go('if(!globalThis["NEEDLE_ENGINE_GENERATOR"]) globalThis["NEEDLE_ENGINE_GENERATOR"] = "unknown";');
go('if(!globalThis["NEEDLE_PROJECT_BUILD_TIME"]) globalThis["NEEDLE_PROJECT_BUILD_TIME"] = "unknown";');
go('if(!globalThis["NEEDLE_PUBLIC_KEY"]) globalThis["NEEDLE_PUBLIC_KEY"] = "unknown";');
go('globalThis["__NEEDLE_ENGINE_VERSION__"] = "4.9.3";');
go('globalThis["__NEEDLE_ENGINE_GENERATOR__"] = "undefined";');
go('globalThis["__NEEDLE_PROJECT_BUILD_TIME__"] = "Mon Sep 15 2025 07:49:39 GMT+0000 (Coordinated Universal Time)";');
go('globalThis["__NEEDLE_PUBLIC_KEY__"] = "' + NEEDLE_PUBLIC_KEY + '";');
const En = "4.9.3", jm = "undefined", c0 = "Mon Sep 15 2025 07:49:39 GMT+0000 (Coordinated Universal Time)";
l0 && console.log(`Engine version: ${En} (generator: ${jm})
Project built at ${c0}`);
const Rl = NEEDLE_PUBLIC_KEY, lo = "needle_isActiveInHierarchy", $r = "builtin_components", Fh = "needle_editor_guid";
function go(s) {
  try {
    (0, eval)(s);
  } catch (e) {
    l0 && console.error(e);
  }
}
let h0, Ay = null;
function Bn() {
  return h0;
}
function d0(s) {
  if (s == null) {
    console.warn("Oh no: someone tried registering a non-existend gltf-loader. When you see this log it might mean that needle-engine is being imported multiple times. Please check your project setup.");
    return;
  }
  Ay !== s && (Ay = s, h0 = new s());
}
const pi = Symbol("shadowDomOwner"), x1 = w("debugpatch");
function Bm(s, e, t, i) {
  const n = x1 === e;
  if (!t && !i)
    return;
  const o = e + "___needle";
  S1(s, e, t, i);
  const r = Object.getOwnPropertyDescriptor(s, e), a = s[e];
  n && console.log("Patch", s.constructor.name, e, r, a), r ? (n && console.log("Apply patch with existing descriptor", s.constructor.name, e, r), typeof r.value == "function" && (s[e] = Ly(r.value, s, e))) : (n && console.log("Create patch with new property", s.constructor.name, e, r), Object.defineProperty(s, e, {
    set: function(l) {
      if (typeof l == "function")
        this[o] = Ly(l, s, e);
      else {
        const c = this[o];
        u0(s, e, this, c, l), this[o] = l, f0(s, e, this, c, l);
      }
    },
    get: function() {
      const l = this[o];
      return typeof l == "function" && l[o] ? l[o] : l;
    }
  }));
}
function ZI(s, e, t) {
  const i = Fm(s, e);
  if (i)
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      o.prefix === t && (o.prefix = null), o.postfix === t && (o.postfix = null), !o.prefix && !o.postfix && i.splice(n, 1);
    }
}
const Iy = Symbol("Needle:Patches:WrappedFunction");
function Ly(s, e, t) {
  if (s[Iy])
    return s;
  const i = function(...n) {
    u0(e, t, this, ...n);
    const o = s.apply(this, n);
    return f0(e, t, this, o, ...n), o;
  };
  return i[Iy] = !0, i;
}
const uf = "Needle:Patches";
function Sp() {
  return globalThis[uf] || (globalThis[uf] = /* @__PURE__ */ new WeakMap()), globalThis[uf];
}
function Fm(s, e) {
  const t = Sp().get(s);
  return t ? t.get(e) : null;
}
function S1(s, e, t, i) {
  let n = Sp().get(s);
  n || (n = /* @__PURE__ */ new Map(), Sp().set(s, n));
  let o = n.get(e);
  o || (o = [], n.set(e, o)), o.push({
    prefix: t,
    postfix: i
  });
}
function u0(s, e, t, ...i) {
  if (!t) return;
  const n = Fm(s, e);
  if (n)
    for (const o of n)
      o.prefix?.call(t, ...i);
}
function f0(s, e, t, i, ...n) {
  if (!t) return;
  const o = Fm(s, e);
  if (o)
    for (const r of o)
      r.postfix?.call(t, i, ...n);
}
const va = [];
function zm(s) {
  va.indexOf(s) === -1 && va.push(s);
}
function JI(s) {
  const e = va.indexOf(s);
  e !== -1 && va.splice(e, 1);
}
const wa = [];
function p0(s) {
  wa.indexOf(s) === -1 && wa.push(s);
}
function eL(s) {
  const e = wa.indexOf(s);
  e !== -1 && wa.splice(e, 1);
}
function C1(s) {
  globalThis.dispatchEvent(new CustomEvent("needle-xrsession-start", { detail: s }));
  for (let e = 0; e < va.length; e++)
    va[e](s);
}
function P1(s) {
  globalThis.dispatchEvent(new CustomEvent("needle-xrsession-end", { detail: s }));
  for (let e = 0; e < wa.length; e++)
    wa[e](s);
}
const tt = w("debuginput");
var Um = /* @__PURE__ */ ((s) => (s.Mouse = "mouse", s.Touch = "touch", s.Controller = "controller", s.Hand = "hand", s))(Um || {}), De = /* @__PURE__ */ ((s) => (s.PointerDown = "pointerdown", s.PointerUp = "pointerup", s.PointerMove = "pointermove", s.KeyDown = "keydown", s.KeyUp = "keyup", s.KeyPressed = "keypress", s))(De || {});
class Hs extends PointerEvent {
  /**
   * Spatial input data
   */
  clientZ;
  /** the device index: mouse and touch are always 0, otherwise e.g. index of the connected Gamepad or XRController */
  deviceIndex;
  /** The origin of the event contains a reference to the creator of this event.   
   * This can be the Needle Engine input system or e.g. a XR controller.  
   * Implement `onPointerHits` to receive the intersections of this event.
   */
  origin;
  /** the browser event that triggered this event (if any) */
  source;
  /** Is the pointer event created via a touch on screen or a spatial device like a XR controller or hand tracking? */
  mode;
  /** Returns true if the input was emitted in 3D space (and not by e.g. clicking on a 2D screen). You can use {@link mode} if you need more information about the input source */
  get isSpatial() {
    return this.mode != "screen";
  }
  /** A ray in worldspace for the event.    
   * If the ray is undefined you can also use `space.worldForward` and `space.worldPosition` */
  get ray() {
    return this._ray || (this._ray = new uo(this.space.worldPosition.clone(), this.space.worldForward.clone())), this._ray;
  }
  set ray(e) {
    this._ray = e;
  }
  /**@returns true if this event has a ray. If you access the ray property a ray will automatically created */
  get hasRay() {
    return this._ray !== void 0;
  }
  _ray;
  /** The device space (this object is not necessarily rendered in the scene but you can access or copy the matrix)   
   * E.g. you can access the input world space source position with `space.worldPosition` or world direction with `space.worldForward`
  */
  space;
  /** true if this event is a click */
  isClick = !1;
  /** true if this event is a double click */
  isDoubleClick = !1;
  /** @returns `true` if the event is marked to be used (when `use()` has been called). Default: `false` */
  get used() {
    return this._used;
  }
  _used = !1;
  /** Call to mark an event to be used */
  use() {
    this._used = !0;
  }
  /** Unique identifier for this input: a combination of the deviceIndex + button to uniquely identify the exact input (e.g. LeftController:Button0 = 0, RightController:Button1 = 11) */
  get pointerId() {
    return this._pointerid;
  }
  _pointerid;
  // this is set via the init arguments (we override it here for intellisense to show the string options)
  /** What type of input created this event: touch, mouse, xr controller, xr hand tracking... */
  get pointerType() {
    return this._pointerType;
  }
  _pointerType;
  // this is set via the init arguments (we override it here for intellisense to show the string options)
  /** The input that raised this event like `pointerdown` */
  get type() {
    return this._type;
  }
  _type;
  /** metadata can be used to associate additional information with the event */
  metadata = {};
  /** intersections that were generated from this event (or are associated with this event in any way) */
  intersections = new Array();
  constructor(e, t, i) {
    super(e, i), this.clientZ = i.clientZ, this._pointerid = i.pointerId, this._pointerType = i.pointerType, this._type = e, this.deviceIndex = i.deviceIndex, this.origin = i.origin, this.source = t, this.mode = i.mode, this._ray = i.ray, this.space = i.device;
  }
  _immediatePropagationStopped = !1;
  get immediatePropagationStopped() {
    return this._immediatePropagationStopped;
  }
  _propagationStopped = !1;
  get propagationStopped() {
    return this._immediatePropagationStopped || this._propagationStopped;
  }
  stopImmediatePropagation() {
    this._immediatePropagationStopped = !0, super.stopImmediatePropagation(), this.source?.stopImmediatePropagation();
  }
  stopPropagation() {
    this._propagationStopped = !0, super.stopPropagation(), this.source?.stopPropagation(), tt && console.warn("Stop propagation...", this.pointerId, this.pointerType);
  }
}
class ih extends KeyboardEvent {
  source;
  constructor(e, t, i) {
    super(e, i), this.source = t;
  }
  stopImmediatePropagation() {
    super.stopImmediatePropagation(), this.source?.stopImmediatePropagation();
  }
}
class tL {
  key;
  keyType;
  source;
  constructor(e) {
    this.key = e.key, this.keyType = e.type, this.source = e;
  }
}
var fi = /* @__PURE__ */ ((s) => (s[s.Early = -100] = "Early", s[s.Default = 0] = "Default", s[s.Late = 100] = "Late", s))(fi || {});
class O1 {
  /** This is a list of event listeners per event type (e.g. pointerdown, pointerup, keydown...). Each entry contains a priority and list of listeners.  
   * That way users can control if they want to receive events before or after other listeners (e.g subscribe to pointer events before the EventSystem receives them) - this allows certain listeners to be always invoked first (or last) and stop propagation  
   * Listeners per event are sorted
   */
  _eventListeners = {};
  addEventListener(e, t, i) {
    if (this._eventListeners[e] || (this._eventListeners[e] = []), !t || typeof t != "function") {
      console.error("Invalid call to addEventListener: callback is required and must be a function!");
      return;
    }
    i ? i = { ...i } : i = {};
    let n = 0;
    i?.queue != null && (n = i.queue);
    const o = this._eventListeners[e], r = o.find((a) => a.priority === n);
    r ? r.listeners.push({ callback: t, options: i }) : (o.push({ priority: n, listeners: [{ callback: t, options: i }] }), o.sort((a, l) => a.priority - l.priority));
  }
  removeEventListener(e, t, i) {
    if (!this._eventListeners[e] || !t) return;
    const n = this._eventListeners[e];
    if (i?.queue != null) {
      const o = n.find((a) => a.priority === i.queue);
      if (!o) return;
      const r = o.listeners.findIndex((a) => a.callback === t);
      r >= 0 && o.listeners.splice(r, 1);
    } else
      for (const o of n) {
        const r = o.listeners.findIndex((a) => a.callback === t);
        r >= 0 && o.listeners.splice(r, 1);
      }
  }
  dispatchEvent(e) {
    let t = !1;
    if (e instanceof ih) {
      const i = this._eventListeners[e.type];
      if (i)
        for (const n of i)
          for (let o = 0; o < n.listeners.length; o++) {
            const r = n.listeners[o];
            if (r.options?.signal?.aborted) {
              n.listeners.splice(o, 1), o--;
              continue;
            }
            r.options.once && (n.listeners.splice(o, 1), o--), r.callback(e);
          }
    }
    if (e instanceof Hs) {
      const i = this._eventListeners[e.type];
      if (i)
        for (const n of i) {
          if (t) break;
          for (let o = 0; o < n.listeners.length; o++) {
            const r = n.listeners[o];
            if (r.options?.signal?.aborted) {
              n.listeners.splice(o, 1), o--;
              continue;
            }
            if (e.immediatePropagationStopped) {
              t = !0, tt && console.log("immediatePropagationStopped", e.type);
              break;
            } else e.propagationStopped && (t = !0, tt && console.log("propagationStopped", e.type));
            r.options.once && (n.listeners.splice(o, 1), o--), r.callback(e);
          }
        }
    }
  }
  _doubleClickTimeThreshold = 0.2;
  _longPressTimeThreshold = 1;
  get mousePosition() {
    return this._pointerPositions[0];
  }
  get mousePositionRC() {
    return this._pointerPositionsRC[0];
  }
  get mouseDown() {
    return this._pointerDown[0];
  }
  get mouseUp() {
    return this._pointerUp[0];
  }
  /** Is the primary pointer clicked (usually the left button). This is equivalent to `input.click` */
  get mouseClick() {
    return this._pointerClick[0];
  }
  /** Was a double click detected for the primary pointer? This is equivalent to `input.doubleClick` */
  get mouseDoubleClick() {
    return this._pointerDoubleClick[0];
  }
  get mousePressed() {
    return this._pointerPressed[0];
  }
  get mouseWheelChanged() {
    return this.getMouseWheelChanged(0);
  }
  /** Is the primary pointer double clicked (usually the left button). This is equivalent to `input.mouseDoubleClick` */
  get click() {
    return this._pointerClick[0];
  }
  /** Was a double click detected for the primary pointer? */
  get doubleClick() {
    return this._pointerDoubleClick[0];
  }
  /**
   * Get a connected Gamepad    
   * Note: For a gamepad to be available to the browser it must have received input before while the page was focused.  
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API
   * @returns The gamepad or null if no gamepad is connected
   */
  getGamepad(e = 0) {
    return typeof navigator < "u" && "getGamepads" in navigator && navigator.getGamepads()[e] || null;
  }
  _setCursorTypes = [];
  /** @deprecated use setCursor("pointer") */
  setCursorPointer() {
    this.setCursor("pointer");
  }
  /** @deprecated use unsetCursor() */
  setCursorNormal() {
    this.unsetCursor("pointer");
  }
  /**
   * Set a custom cursor. This will set the cursor type until unsetCursor is called
   */
  setCursor(e) {
    this._setCursorTypes.push(e), this._setCursorTypes.length > 10 && this._setCursorTypes.shift(), this.updateCursor();
  }
  /**
   * Unset a custom cursor. This will set the cursor type to the previous type or default
   */
  unsetCursor(e) {
    for (let t = this._setCursorTypes.length - 1; t >= 0; t--)
      if (this._setCursorTypes[t] === e) {
        this._setCursorTypes.splice(t, 1), this.updateCursor();
        break;
      }
  }
  updateCursor() {
    this._setCursorTypes?.length == 0 ? this.context.domElement.style.cursor = "default" : this.context.domElement.style.cursor = this._setCursorTypes[this._setCursorTypes.length - 1];
  }
  /**
   * Check if a pointer id is currently used.
   */
  getIsPointerIdInUse(e) {
    for (const t of this._pointerEventsPressed)
      if (t.pointerId === e && t.used)
        return !0;
    return !1;
  }
  /** how many pointers are currently pressed */
  getPointerPressedCount() {
    let e = 0;
    for (let t = 0; t < this._pointerPressed.length; t++)
      this._pointerPressed[t] && e++;
    return e;
  }
  /**
   * Gets the position of the given pointer index in pixel
   * @param i The pointer index
   * @returns The position of the pointer in pixel
   */
  getPointerPosition(e) {
    return e >= this._pointerPositions.length ? null : this._pointerPositions[e];
  }
  getPointerPositionLastFrame(e) {
    return e >= this._pointerPositionsLastFrame.length ? null : this._pointerPositionsLastFrame[e];
  }
  getPointerPositionDelta(e) {
    return e >= this._pointerPositionsDelta.length ? null : this._pointerPositionsDelta[e];
  }
  /**
   * The pointer position in screenspace coordinates (-1 to 1) where 0 is the center of the screen.  
   * This can be useful for e.g. raycasting (see https://threejs.org/docs/#api/en/core/Raycaster.setFromCamera)
   */
  getPointerPositionRC(e) {
    return e >= this._pointerPositionsRC.length ? null : this._pointerPositionsRC[e];
  }
  getPointerDown(e) {
    return e >= this._pointerDown.length ? !1 : this._pointerDown[e];
  }
  getPointerUp(e) {
    return e >= this._pointerUp.length ? !1 : this._pointerUp[e];
  }
  getPointerPressed(e) {
    return e >= this._pointerPressed.length ? !1 : this._pointerPressed[e];
  }
  getPointerClicked(e) {
    return e >= this._pointerClick.length ? !1 : this._pointerClick[e];
  }
  getPointerDoubleClicked(e) {
    return e >= this._pointerDoubleClick.length ? !1 : this._pointerDoubleClick[e];
  }
  getPointerDownTime(e) {
    return e >= this._pointerDownTime.length ? -1 : this._pointerDownTime[e];
  }
  getPointerUpTime(e) {
    return e >= this._pointerUpTime.length ? -1 : this._pointerUpTime[e];
  }
  getPointerLongPress(e) {
    return e >= this._pointerDownTime.length ? !1 : this.getPointerPressed(e) && this.context.time.time - this._pointerDownTime[e] > this._longPressTimeThreshold;
  }
  getIsMouse(e) {
    return e < 0 || e >= this._pointerTypes.length ? !1 : this._pointerTypes[e] === "mouse";
  }
  getIsTouch(e) {
    return e < 0 || e >= this._pointerTypes.length ? !1 : this._pointerTypes[e] === "touch";
  }
  getTouchesPressedCount() {
    let e = 0;
    for (let t = 0; t < this._pointerPressed.length; t++)
      this._pointerPressed[t] && this.getIsTouch(t) && e++;
    return e;
  }
  getMouseWheelChanged(e = 0) {
    return e >= this._mouseWheelChanged.length ? !1 : this._mouseWheelChanged[e];
  }
  getMouseWheelDeltaY(e = 0) {
    return e >= this._mouseWheelDeltaY.length ? 0 : this._mouseWheelDeltaY[e];
  }
  getPointerEvent(e) {
    if (!(e >= this._pointerEvent.length))
      return this._pointerEvent[e] ?? void 0;
  }
  *foreachPointerId(e) {
    for (let t = 0; t < this._pointerTypes.length; t++)
      if (this._pointerIsActive(t)) {
        if (e !== void 0) {
          const i = this._pointerTypes[t];
          if (Array.isArray(e)) {
            let n = !1;
            for (const o of e)
              if (i === o) {
                n = !0;
                break;
              }
            if (!n) continue;
          } else if (e !== i) continue;
        }
        yield t;
      }
  }
  *foreachTouchId() {
    for (let e = 0; e < this._pointerTypes.length; e++)
      this._pointerTypes[e] === "touch" && this._pointerIsActive[e] && (yield e);
  }
  _pointerIsActive(e) {
    return e < 0 ? !1 : this._pointerPressed[e] || this._pointerDown[e] || this._pointerUp[e];
  }
  context;
  _pointerDown = [!1];
  _pointerUp = [!1];
  _pointerClick = [!1];
  _pointerDoubleClick = [!1];
  _pointerPressed = [!1];
  _pointerPositions = [new J()];
  _pointerPositionsLastFrame = [new J()];
  _pointerPositionsDelta = [new J()];
  _pointerPositionsRC = [new J()];
  _pointerPositionDown = [new y()];
  _pointerDownTime = [];
  _pointerUpTime = [];
  _pointerUpTimestamp = [];
  _pointerIds = [];
  _pointerTypes = [""];
  _mouseWheelChanged = [!1];
  _mouseWheelDeltaY = [0];
  _pointerEvent = [];
  /** current pressed pointer events. Used to check if any of those events was used  */
  _pointerEventsPressed = [];
  /** This is added/updated for pointers. screenspace pointers set this to the camera near plane  */
  _pointerSpace = [];
  _pressedStack = /* @__PURE__ */ new Map();
  onDownButton(e, t) {
    let i = this._pressedStack.get(e);
    i || (i = [], this._pressedStack.set(e, i)), i.push(t);
  }
  onReleaseButton(e, t) {
    const i = this._pressedStack.get(e);
    if (!i) return;
    const n = i.indexOf(t);
    n >= 0 && i.splice(n, 1);
  }
  /** the first button that was down and is currently pressed */
  getFirstPressedButtonForPointer(e) {
    const t = this._pressedStack.get(e);
    if (t)
      return t[0];
  }
  /** the last (most recent) button that was down and is currently pressed */
  getLatestPressedButtonForPointer(e) {
    const t = this._pressedStack.get(e);
    if (t)
      return t[t.length - 1];
  }
  getKeyDown(e) {
    if (e !== void 0)
      return this.isKeyDown(e);
    for (const t in this.keysPressed) {
      const i = this.keysPressed[t];
      if (i.startFrame === this.context.time.frameCount) return i.key;
    }
    return null;
  }
  getKeyPressed(e) {
    if (e !== void 0)
      return this.isKeyPressed(e);
    for (const t in this.keysPressed) {
      const i = this.keysPressed[t];
      if (i.pressed)
        return i.key;
    }
    return null;
  }
  getKeyUp(e) {
    if (e !== void 0)
      return this.isKeyUp(e);
    for (const t in this.keysPressed) {
      const i = this.keysPressed[t];
      return i.pressed === !1 && i.frame === this.context.time.frameCount;
    }
    return null;
  }
  isKeyDown(e) {
    if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1;
    const t = this.getCodeForCommonKeyName(e);
    if (t !== null) {
      for (const n of t) if (this.isKeyDown(n)) return !0;
      return !1;
    }
    const i = this.keysPressed[e];
    return i ? i.startFrame === this.context.time.frameCount && i.pressed : !1;
  }
  isKeyUp(e) {
    if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1;
    const t = this.getCodeForCommonKeyName(e);
    if (t !== null) {
      for (const n of t) if (this.isKeyUp(n)) return !0;
      return !1;
    }
    const i = this.keysPressed[e];
    return i ? i.frame === this.context.time.frameCount && i.pressed === !1 : !1;
  }
  isKeyPressed(e) {
    if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1;
    const t = this.getCodeForCommonKeyName(e);
    if (t !== null) {
      for (const n of t) if (this.isKeyPressed(n)) return !0;
      return !1;
    }
    const i = this.keysPressed[e];
    return i && i.pressed || !1;
  }
  // utility helper for mapping common names to actual codes; e.g. "Shift" -> "ShiftLeft" and "ShiftRight" or "a" -> "KeyA"
  getCodeForCommonKeyName(e) {
    if (e.length === 1) {
      if (e >= "0" && e <= "9")
        return ["Digit" + e];
      if (e >= "a" && e <= "z")
        return ["Key" + e.toUpperCase()];
      if (e == " ")
        return ["Space"];
    }
    switch (e) {
      case "shift":
      case "Shift":
        return ["ShiftLeft", "ShiftRight"];
      case "control":
      case "Control":
        return ["ControlLeft", "ControlRight"];
      case "alt":
      case "Alt":
        return ["AltLeft", "AltRight"];
    }
    return null;
  }
  createInputEvent(e) {
    switch (e.type) {
      case "pointerdown":
        tt && Be("Create Pointer down"), this.onDownButton(e.deviceIndex, e.button), this.onDown(e);
        break;
      case "pointermove":
        tt && Be("Create Pointer move"), this.onMove(e);
        break;
      case "pointerup":
        tt && Be("Create Pointer up"), this.onUp(e), this.onReleaseButton(e.deviceIndex, e.button);
        break;
    }
  }
  convertScreenspaceToRaycastSpace(e) {
    return e.x = (e.x - this.context.domX) / this.context.domWidth * 2 - 1, e.y = -((e.y - this.context.domY) / this.context.domHeight) * 2 + 1, e;
  }
  /** @internal */
  constructor(e) {
    this.context = e, this.context.post_render_callbacks.push(this.onEndOfFrame);
  }
  /** this is the html element we subscribed to for events */
  _htmlEventSource;
  bindEvents() {
    this.unbindEvents(), this._htmlEventSource = this.context.renderer.domElement, window.addEventListener("contextmenu", this.onContextMenu), this._htmlEventSource.addEventListener("pointerdown", this.onPointerDown, { passive: !0 }), window.addEventListener("pointermove", this.onPointerMove, { passive: !0, capture: !0 }), window.addEventListener("pointerup", this.onPointerUp, { passive: !0 }), window.addEventListener("pointercancel", this.onPointerCancel, { passive: !0 }), window.addEventListener("touchstart", this.onTouchStart, { passive: !0 }), window.addEventListener("touchmove", this.onTouchMove, { passive: !0 }), window.addEventListener("touchend", this.onTouchEnd, { passive: !0 }), this._htmlEventSource.addEventListener("wheel", this.onMouseWheel, { passive: !0 }), window.addEventListener("wheel", this.onWheelWindow, { passive: !0 }), window.addEventListener("keydown", this.onKeyDown, !1), window.addEventListener("keypress", this.onKeyPressed, !1), window.addEventListener("keyup", this.onKeyUp, !1), window.addEventListener("blur", this.onLostFocus);
  }
  unbindEvents() {
    for (const e in this._eventListeners)
      this._eventListeners[e].length = 0;
    window.removeEventListener("contextmenu", this.onContextMenu), this._htmlEventSource?.removeEventListener("pointerdown", this.onPointerDown), window.removeEventListener("pointermove", this.onPointerMove), window.removeEventListener("pointerup", this.onPointerUp), window.removeEventListener("pointercancel", this.onPointerCancel), window.removeEventListener("touchstart", this.onTouchStart), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd), this._htmlEventSource?.removeEventListener("wheel", this.onMouseWheel, !1), window.removeEventListener("wheel", this.onWheelWindow, !1), window.removeEventListener("keydown", this.onKeyDown, !1), window.removeEventListener("keypress", this.onKeyPressed, !1), window.removeEventListener("keyup", this.onKeyUp, !1), window.removeEventListener("blur", this.onLostFocus);
  }
  dispose() {
    const e = this.context.post_render_callbacks.indexOf(this.onEndOfFrame);
    e >= 0 && this.context.post_render_callbacks.splice(e, 1), this.unbindEvents();
  }
  onLostFocus = () => {
    for (const e in this.keysPressed)
      this.keysPressed[e].pressed = !1;
  };
  _receivedPointerMoveEventsThisFrame = new Array();
  onEndOfFrame = () => {
    this._receivedPointerMoveEventsThisFrame.length = 0;
    for (let e = 0; e < this._pointerUp.length; e++)
      this._pointerUp[e] = !1;
    for (let e = 0; e < this._pointerDown.length; e++)
      this._pointerDown[e] = !1;
    for (let e = 0; e < this._pointerClick.length; e++)
      this._pointerClick[e] = !1;
    for (let e = 0; e < this._pointerDoubleClick.length; e++)
      this._pointerDoubleClick[e] = !1;
    for (const e of this._pointerPositionsDelta)
      e.set(0, 0);
    for (let e = 0; e < this._mouseWheelChanged.length; e++)
      this._mouseWheelChanged[e] = !1;
    for (let e = 0; e < this._mouseWheelDeltaY.length; e++)
      this._mouseWheelDeltaY[e] = 0;
  };
  canReceiveInput(e) {
    return e.target === this.context.renderer?.domElement || e.target === this.context.domElement || this.context.isInAR || this.context.isInAR && e.target === document.body && q.isMozillaXR() ? !0 : (tt && console.warn("CanReceiveInput:False for", e.target), !1);
  }
  onContextMenu = (e) => {
    this.canReceiveInput(e) !== !1 && e instanceof PointerEvent && e.pointerType;
  };
  keysPressed = {};
  onKeyDown = (e) => {
    if (tt && console.log(`key down ${e.code}, ${this.context.application.hasFocus}`, e), !this.context.application.hasFocus)
      return;
    const t = this.keysPressed[e.code];
    if (t && t.pressed) return;
    this.keysPressed[e.code] = { pressed: !0, frame: this.context.time.frameCount + 1, startFrame: this.context.time.frameCount + 1, key: e.key, code: e.code };
    const i = new ih("keydown", e, e);
    this.onDispatchEvent(i);
  };
  onKeyPressed = (e) => {
    if (!this.context.application.hasFocus)
      return;
    const t = this.keysPressed[e.code];
    if (!t) return;
    t.pressed = !0, t.frame = this.context.time.frameCount + 1;
    const i = new ih("keypress", e, e);
    this.onDispatchEvent(i);
  };
  onKeyUp = (e) => {
    if (!this.context.application.hasFocus)
      return;
    const t = this.keysPressed[e.code];
    if (!t) return;
    t.pressed = !1, t.frame = this.context.time.frameCount + 1;
    const i = new ih("keyup", e, e);
    this.onDispatchEvent(i);
  };
  onWheelWindow = (e) => {
    document.pointerLockElement && this.onMouseWheel(e);
  };
  onMouseWheel = (e) => {
    if (this.canReceiveInput(e) === !1) return;
    this._mouseWheelDeltaY.length <= 0 && this._mouseWheelDeltaY.push(0), this._mouseWheelChanged.length <= 0 && this._mouseWheelChanged.push(!1), this._mouseWheelChanged[0] = !0;
    const t = this._mouseWheelDeltaY[0];
    this._mouseWheelDeltaY[0] = t + e.deltaY;
  };
  onPointerDown = (e) => {
    if (this.context.isInAR || this.canReceiveInput(e) === !1) return;
    e.target instanceof HTMLElement && e.target.setPointerCapture(e.pointerId);
    const t = this.getPointerId(e);
    tt && Be(`pointer down #${t}, identifier:${e.pointerId}`);
    const i = this.getAndUpdateSpatialObjectForScreenPosition(t, e.clientX, e.clientY), n = new Hs("pointerdown", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: t, button: e.button, clientX: e.clientX, clientY: e.clientY, pointerType: e.pointerType, buttonName: this.getButtonName(e), device: i, pressure: e.pressure });
    this.onDown(n);
  };
  onPointerMove = (e) => {
    if (this.context.isInAR || this._receivedPointerMoveEventsThisFrame.includes(e.pointerId)) return;
    this._receivedPointerMoveEventsThisFrame.push(e.pointerId);
    let t = e.button;
    e.pointerType === "mouse" && (t = this.getFirstPressedButtonForPointer(0) ?? 0);
    const i = this.getPointerId(e, t);
    t === -1 && (t = i);
    const n = this.getAndUpdateSpatialObjectForScreenPosition(i, e.clientX, e.clientY), o = new Hs("pointermove", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: i, button: t, clientX: e.clientX, clientY: e.clientY, pointerType: e.pointerType, buttonName: this.getButtonName(e), device: n, pressure: e.pressure });
    this.onMove(o);
  };
  onPointerCancel = (e) => {
    this.context.isInAR || (tt && console.log("Pointer cancel", e), this.onPointerUp(e));
  };
  onPointerUp = (e) => {
    if (this.context.isInAR) return;
    e.target instanceof HTMLElement && e.target.releasePointerCapture(e.pointerId);
    const t = this.getPointerId(e), i = new Hs("pointerup", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: t, button: e.button, clientX: e.clientX, clientY: e.clientY, pointerType: e.pointerType, buttonName: this.getButtonName(e), device: this.getAndUpdateSpatialObjectForScreenPosition(t, e.clientX, e.clientY), pressure: e.pressure });
    this.onUp(i), this._pointerIds[t] = -1, tt && console.log("ID=" + t, "PointerId=" + e.pointerId, "ALL:", [...this._pointerIds]);
  };
  getPointerId(e, t) {
    return e.pointerType === "mouse" ? 0 + (t ?? e.button) : this.getPointerIndex(e.pointerId);
  }
  getButtonName(e) {
    const t = e.button;
    if (e.pointerType === "mouse")
      switch (t) {
        case 0:
          return "left";
        case 1:
          return "middle";
        case 2:
          return "right";
      }
    return "unknown";
  }
  // the touch events are currently only used for AR support on android
  onTouchStart = (e) => {
    if (this.context.isInAR)
      for (let t = 0; t < e.changedTouches.length; t++) {
        const i = e.changedTouches[t], n = this.getPointerIndex(i.identifier), o = this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), r = new Hs("pointerdown", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: o, pressure: i.force });
        this.onDown(r);
      }
  };
  onTouchMove = (e) => {
    if (this.context.isInAR)
      for (let t = 0; t < e.changedTouches.length; t++) {
        const i = e.changedTouches[t], n = this.getPointerIndex(i.identifier), o = this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), r = new Hs("pointermove", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: o, pressure: i.force });
        this.onMove(r);
      }
  };
  onTouchEnd = (e) => {
    if (this.context.isInAR)
      for (let t = 0; t < e.changedTouches.length; t++) {
        const i = e.changedTouches[t], n = this.getPointerIndex(i.identifier), o = new Hs("pointerup", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), pressure: i.force });
        this.onUp(o), this._pointerIds[n] = -1;
      }
  };
  tempNearPlaneVector = new y();
  tempFarPlaneVector = new y();
  tempLookMatrix = new ee();
  getAndUpdateSpatialObjectForScreenPosition(e, t, i) {
    let n = this._pointerSpace[e];
    n || (n = new M(), this._pointerSpace[e] = n), this._pointerSpace[e] = n;
    const o = this.context.mainCamera;
    if (o) {
      const r = this.tempNearPlaneVector.set(t, i, -1);
      this.convertScreenspaceToRaycastSpace(r);
      const a = this.tempFarPlaneVector.set(r.x, r.y, 1);
      r.unproject(o), a.unproject(o);
      const l = o.worldUp || H(0, 1, 0).applyQuaternion(be(o));
      this.tempLookMatrix.lookAt(a, r, l), n.position.set(r.x, r.y, r.z), n.quaternion.setFromRotationMatrix(this.tempLookMatrix);
    }
    return n;
  }
  // Prevent the same event being handled twice (e.g. on touch we get a mouseUp and touchUp evt with the same timestamp)
  // private isNewEvent(timestamp: number, index: number, arr: number[]): boolean {
  //     while (arr.length <= index) arr.push(-1);
  //     if (timestamp === arr[index]) return false;
  //     arr[index] = timestamp;
  //     return true;
  // }
  isInRect(e) {
    if (this.context.isInXR) return !0;
    const t = this.context.domElement.getBoundingClientRect(), i = e.clientX, n = e.clientY, o = i >= t.x && i <= t.right && n >= t.y && n <= t.bottom;
    return tt && !o && console.log("Not in rect", t, i, n), o;
  }
  onDown(e) {
    const t = e.pointerId;
    if (this.getPointerPressed(t) && console.warn(`Received pointerDown for pointerId that is already pressed: ${t}`, tt ? e : ""), tt && console.log(e.pointerType, "DOWN", t), !!this.isInRect(e)) {
      for (this.setPointerState(t, this._pointerPressed, !0), this.setPointerState(t, this._pointerDown, !0), this.setPointerStateT(t, this._pointerEvent, e.source); t >= this._pointerTypes.length; ) this._pointerTypes.push(e.pointerType);
      for (this._pointerTypes[t] = e.pointerType; t >= this._pointerPositionDown.length; ) this._pointerPositionDown.push(new y());
      for (this._pointerPositionDown[t].set(e.clientX, e.clientY, e.clientZ ?? 0); t >= this._pointerPositions.length; ) this._pointerPositions.push(new J());
      this._pointerPositions[t].set(e.clientX, e.clientY), t >= this._pointerDownTime.length && this._pointerDownTime.push(0), this._pointerDownTime[t] = this.context.time.realtimeSinceStartup, this.updatePointerPosition(e), this._pointerEventsPressed.push(e), this.onDispatchEvent(e);
    }
  }
  // moveEvent?: Event;
  onMove(e) {
    const t = e.pointerId, i = this.getPointerPressed(t);
    i === !1 && !this.isInRect(e) || e.pointerType === "touch" && !i || (this.updatePointerPosition(e), this.setPointerStateT(t, this._pointerEvent, e.source), this.onDispatchEvent(e));
  }
  onUp(e) {
    const t = e.pointerId;
    if (!this.getPointerPressed(t)) {
      tt && console.log(e.pointerType, "UP", t, "was not down");
      return;
    }
    tt && console.log(e.pointerType, "UP", t), this.setPointerState(t, this._pointerPressed, !1), this.setPointerStateT(t, this._pointerEvent, e.source), this.setPointerState(t, this._pointerUp, !0), this.updatePointerPosition(e);
    for (let l = this._pointerEventsPressed.length - 1; l >= 0; l--)
      if (this._pointerEventsPressed[l].pointerId === t) {
        this._pointerEventsPressed.splice(l, 1);
        break;
      }
    if (!this._pointerPositionDown[t]) {
      tt && ge("Received pointer up event without matching down event for button: " + t), console.warn("Received pointer up event without matching down event for button: " + t);
      return;
    }
    const n = this._pointerUpTime[t], o = this._pointerDownTime[t], r = this.context.time.realtimeSinceStartup, a = r - o;
    if (t >= this._pointerUpTime.length && this._pointerUpTime.push(-99), this._pointerUpTime[t] = r, a < 1) {
      let l = e.clientX - this._pointerPositionDown[t].x, c = e.clientY - this._pointerPositionDown[t].y, h = 0;
      if (e.isSpatial && e.clientZ != null && (h = e.clientZ - this._pointerPositionDown[t].z, l *= 200, c *= 200, h *= 200), Math.abs(l) < 5 && Math.abs(c) < 5 && Math.abs(h) < 5) {
        this.setPointerState(t, this._pointerClick, !0), e.isClick = !0;
        const d = r - n;
        tt && console.log("CLICK", t, l, c, h, d), d < this._doubleClickTimeThreshold && d > 0 && (this.setPointerState(t, this._pointerDoubleClick, !0), e.isDoubleClick = !0);
      }
    }
    this.onDispatchEvent(e);
  }
  updatePointerPosition(e) {
    const t = e.pointerId;
    for (; t >= this._pointerPositions.length; ) this._pointerPositions.push(new J());
    for (; t >= this._pointerPositionsLastFrame.length; ) this._pointerPositionsLastFrame.push(new J());
    for (; t >= this._pointerPositionsDelta.length; ) this._pointerPositionsDelta.push(new J());
    const i = this._pointerPositionsLastFrame[t];
    i.copy(this._pointerPositions[t]);
    const n = this._pointerPositionsDelta[t];
    let o = e.clientX - i.x, r = e.clientY - i.y;
    if (e.source instanceof MouseEvent || e.source instanceof TouchEvent) {
      const h = e.source;
      o === 0 && h.movementX !== 0 && (o = h.movementX || 0), r === 0 && h.movementY !== 0 && (r = h.movementY || 0);
    }
    n.x += o, n.y += r, this._pointerPositions[t].x = e.clientX, this._pointerPositions[t].y = e.clientY;
    const a = e.clientX, l = e.clientY;
    for (; t >= this._pointerPositionsRC.length; ) this._pointerPositionsRC.push(new J());
    const c = this._pointerPositionsRC[t];
    c.set(a, l), this.convertScreenspaceToRaycastSpace(c);
  }
  /** get the next free id */
  getPointerIndex(e) {
    let t = -1;
    for (let i = 0; i < this._pointerIds.length; i++) {
      if (this._pointerIds[i] === e) return i;
      t === -1 && this._pointerIds[i] === -1 && (t = i);
    }
    return t !== -1 ? (this._pointerIds[t] = e, t) : (tt && console.log("PUSH pointerId:", e), this._pointerIds.push(e), this._pointerIds.length - 1);
  }
  setPointerState(e, t, i) {
    t[e] = i;
  }
  setPointerStateT(e, t, i) {
    return t[e] = i, i;
  }
  onDispatchEvent(e) {
    const t = N.Current;
    try {
      N.Current = this.context, this.dispatchEvent(e);
    } finally {
      N.Current = t;
    }
  }
}
const na = new ee().makeRotationY(Math.PI), zi = new U().setFromAxisAngle(new y(0, 1, 0), Math.PI), k1 = w("debugwebxr");
class M1 {
  priority = -1e5;
  gameObject;
  isXRRig() {
    return !0;
  }
  get isActive() {
    return this.gameObject.visible;
  }
  constructor() {
    if (this.gameObject = new M(), this.gameObject.name = "Implicit XR Rig", k1) {
      const e = Wm(16733661);
      e.position.y += 0.5, this.gameObject.add(e);
    }
  }
}
const Zn = w("debugwebxr"), nh = w("debugcustomgesture"), R1 = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", T1 = "generic-trigger", E1 = new U().setFromEuler(new ot(ys.degToRad(0), ys.degToRad(-90), ys.degToRad(-90))), A1 = new y(0.04, -0.04, 0);
class m0 {
  /** the Needle XR Session */
  xr;
  get context() {
    return this.xr.context;
  }
  /**
   * https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource
   */
  inputSource;
  /** the input source index */
  index = 0;
  /** When enabled the controller will create input events in the Needle Engine input system (e.g. when a button is pressed or the controller is moved)   
   * You can disable this if you don't want inputs to go through the input system but be aware that this will result in `onPointerDown` component callbacks to not be invoked anymore for this XRController
  */
  emitEvents = !0;
  /** Is the controller still connected?  */
  get connected() {
    return this._connected;
  }
  _connected = !0;
  get isTracking() {
    return this._isTracking;
  }
  _isTracking = !1;
  /** the input source gamepad giving raw access to the gamepad values  
   * You should usually use the `getButton` and `getStick` methods instead to get access to named buttons and sticks   
   */
  get gamepad() {
    return this.__gamepad ??= this.inputSource.gamepad;
  }
  __gamepad;
  /** @returns true if this is a hand (otherwise this is a controller) */
  get isHand() {
    return this.hand != null;
  }
  /** 
   * If this is a hand then this is the hand info (XRHand)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRHand
   */
  get hand() {
    return this.__hand ??= this.inputSource.hand;
  }
  __hand;
  /** threejs XRHandSpace, shorthand for `context.renderer.xr.getHand(controllerIndex)` 
   * @link https://threejs.org/docs/#api/en/renderers/webxr/WebXRManager.getHand
  */
  get handObject() {
    return this.context.renderer.xr.getHand(this.index);
  }
  /** The input source profiles */
  get profiles() {
    return this.inputSource.profiles;
  }
  /** The device input layout */
  get layout() {
    return this._layout;
  }
  /** shorthand for `inputSource.targetRayMode` */
  get targetRayMode() {
    return this.inputSource.targetRayMode;
  }
  /** shorthand for `inputSource.targetRaySpace` */
  get targetRaySpace() {
    return this.inputSource.targetRaySpace;
  }
  /** shorthand for `inputSource.gripSpace` */
  get gripSpace() {
    return this.inputSource.gripSpace;
  }
  /** 
   * If the controller if held in the left or right hand (or if it's a left or right hand) 
   **/
  get side() {
    return this.__side ??= this.inputSource.handedness;
  }
  __side = void 0;
  /** is right side. shorthand for `side === 'right'` */
  get isRight() {
    return this.side === "right";
  }
  /** is left side. shorthand for `side === 'left'` */
  get isLeft() {
    return this.side === "left";
  }
  /** is XR stylus, e.g. Logitech MX Ink */
  get isStylus() {
    return this._isMxInk;
  }
  /** The XRTransientInputHitTestSource can be used to perform hit tests with the controller ray against the real world.   
   * see https://developer.mozilla.org/en-US/docs/Web/API/XRSession/requestHitTestSourceForTransientInput for more information
   * Requires the hit-test feature to be enabled in the XRSession   
   * 
   * NOTE: The hit test source should be cancelled once it's not needed anymore. Call `cancelHitTestSource` to do this
   */
  getHitTestSource() {
    return this._hitTestSource || this._requestHitTestSource(), this._hitTestSource;
  }
  get hasHitTestSource() {
    return this._hitTestSource;
  }
  /** Make sure to cancel the hittest source once it's not needed anymore */
  cancelHitTestSource() {
    this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0);
  }
  _hitTestSource = void 0;
  _hasSelectEvent = !1;
  get hasSelectEvent() {
    return this._hasSelectEvent;
  }
  _isMxInk = !1;
  _isMetaQuestTouchController = !1;
  /** Perform a hit test against the XR planes or meshes. shorthand for `xr.getHitTest(controller)`
   * @returns the hit test result (with position and rotation in worldspace) or null if no hit was found
   */
  getHitTest() {
    return this.xr.getHitTest(this);
  }
  /** This is cleared at the beginning of each frame */
  _handJointPoses = /* @__PURE__ */ new Map();
  /** Get the hand joint pose from the current XRFrame. Results are cached for a frame to avoid calling getJointPose multiple times */
  getHandJointPose(e, t) {
    if (t = t || this.xr.frame, !this.hand || !t?.getJointPose || !this.xr.referenceSpace) return null;
    let i = this._handJointPoses?.get(e);
    return i || (i = t.getJointPose(e, this.xr.referenceSpace), i && this._handJointPoses.set(e, i), i);
  }
  /** Grip matrix in grip space */
  _gripMatrix = new ee();
  /** Grip position in grip space */
  _gripPosition = new y();
  /** Grip rotation in grip space */
  _gripQuaternion = new U();
  _linearVelocity = new y();
  _rayPositionRaw = new y();
  _rayRotationRaw = new U();
  /** ray matrix in grip space */
  _rayMatrix = new ee();
  /** Ray position in rig space */
  _rayPosition = new y();
  /** Ray rotation in rig space */
  _rayQuaternion = new U();
  /** Grip position in rig space */
  get gripPosition() {
    return H(this._gripPosition);
  }
  /** Grip rotation in rig space */
  get gripQuaternion() {
    return ui(this._gripQuaternion);
  }
  get gripMatrix() {
    return this._gripMatrix;
  }
  /** Grip linear velocity in rig space
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRPose/linearVelocity
   */
  get gripLinearVelocity() {
    return H(this._linearVelocity).applyQuaternion(zi);
  }
  /** Ray position in rig space */
  get rayPosition() {
    return H(this._rayPosition);
  }
  /** Ray rotation in rig space */
  get rayQuaternion() {
    return ui(this._rayQuaternion);
  }
  /** Controller grip position in worldspace */
  get gripWorldPosition() {
    return H(this._gripWorldPosition);
  }
  _gripWorldPosition = new y();
  /** Controller grip rotation in wordspace */
  get gripWorldQuaternion() {
    return ui(this._gripWorldQuaternion);
  }
  _gripWorldQuaternion = new U();
  /** Controller ray position in worldspace (this value is calculated once per frame by default - call `updateRayWorldPosition` to force an update) */
  get rayWorldPosition() {
    return H(this._rayWorldPosition);
  }
  _rayWorldPosition = new y();
  /** Recalculates the ray world position */
  updateRayWorldPosition() {
    const e = this.xr.context.mainCamera?.parent;
    this._rayWorldPosition.copy(this._rayPositionRaw), e && this._rayWorldPosition.applyMatrix4(e.matrixWorld);
  }
  /** Controller ray rotation in wordspace (this value is calculated once per frame by default - call `updateRayWorldQuaternion` to force an update) */
  get rayWorldQuaternion() {
    return ui(this._rayWorldQuaternion);
  }
  _rayWorldQuaternion = new U();
  get pinchPosition() {
    return H(this._pinchPosition);
  }
  _pinchPosition = new y();
  /** Recalculates the ray world quaternion */
  updateRayWorldQuaternion() {
    const e = this.xr.context.mainCamera?.parent, t = e ? be(e) : void 0;
    this._rayWorldQuaternion.copy(this._rayRotationRaw).multiply(zi), t && this._rayWorldQuaternion.premultiply(t);
  }
  /** The controller ray in worldspace */
  get ray() {
    return this._ray.origin.copy(this.rayWorldPosition), this._ray.direction.copy(H(0, 0, 1).applyQuaternion(this.rayWorldQuaternion)), this._ray;
  }
  _ray;
  /** Recalculated once per update */
  _hand_wristDotUp = void 0;
  /**
   * The dot product of the hand palm with the up vector. 
   * This is a number between -1 and 1, where 1 means the palm is directly up and -1 means the palm is directly down (upside down).
   * This value is undefined if there's no hand
   */
  get handWristDotUp() {
    if (this._hand_wristDotUp !== void 0) return this._hand_wristDotUp;
    const e = this.handObject?.joints.wrist;
    if (e) {
      const t = H(0, 1, 0).applyQuaternion(e.quaternion), i = H(0, 1, 0).dot(t);
      return this._hand_wristDotUp = i;
    }
  }
  /**
   * @returns true if the hand is upside down
   */
  get isHandUpsideDown() {
    return this.handWristDotUp !== void 0 ? this.handWristDotUp < -0.7 : !1;
  }
  /**
   * @returns true if the hand is upside down and we got a pinch down event this frame.
   */
  get isTeleportGesture() {
    return this.isHandUpsideDown && this.getGesture("pinch")?.isDown;
  }
  /** The controller object space.  
   * You can use it to attach objects to the controller.   
   * Children will be automatically detached and put into the scene when the controller disconnects
   */
  get object() {
    return this._object;
  }
  _object;
  _gripSpaceObject;
  _raySpaceObject;
  /** Assigned the model that you use for rendering. This can be used as a hint for other components */
  model = null;
  _debugAxesHelper = new vi(0.15);
  _debugGripAxesHelper = new vi(0.07);
  _debugRayAxesHelper = new vi(0.07);
  /** returns the URL of the default controller model */
  async getModelUrl() {
    return this.getMotionController?.then((e) => e?.assetUrl || null);
  }
  constructor(e, t, i) {
    this.xr = e, this.inputSource = t, this.index = i, this._object = new M(), this._object.name = `NeedleXRController_${i}`, Zn && (this._object.add(this._debugAxesHelper), this._gripSpaceObject = new M(), this._raySpaceObject = new M(), this._gripSpaceObject.name = `NeedleXRController_${i}_gripSpace`, this._raySpaceObject.name = `NeedleXRController_${i}_raySpace`, this._gripSpaceObject.add(this._debugGripAxesHelper), this._raySpaceObject.add(this._debugRayAxesHelper), this.xr.context.scene.add(this._gripSpaceObject), this.xr.context.scene.add(this._raySpaceObject)), this.xr.context.scene.add(this._object), this._ray = new uo(), this.pointerInit = {
      origin: this,
      pointerType: this.hand ? "hand" : "controller",
      deviceIndex: this.index,
      pointerId: -1,
      // < this will be updated in the emitPointerEvent method
      mode: this.inputSource.targetRayMode,
      ray: this._ray,
      device: this._object,
      buttonName: "none"
    }, this.initialize(), this.subscribeEvents();
  }
  _hitTestSourcePromise = null;
  _requestHitTestSource() {
    return this._hitTestSourcePromise ? this._hitTestSourcePromise : this.xr.mode === "immersive-ar" && this.inputSource.targetRayMode === "tracked-pointer" && this.xr.session.requestHitTestSourceForTransientInput ? this._hitTestSourcePromise = this.xr.session.requestHitTestSourceForTransientInput({
      profile: this.inputSource.profiles[0],
      offsetRay: new XRRay()
    })?.then((e) => (this._hitTestSourcePromise = null, this.connected ? this._hitTestSource = e : (e.cancel(), null))) ?? null : null;
  }
  onPointerHits = (e) => {
  };
  onUpdate(e) {
    this.onUpdateFrame(e), this.updateInputEvents(), this.onUpdateMove();
  }
  onRenderDebug() {
    z.DrawSphere(this.rayWorldPosition, 3e-3), z.DrawDirection(this.rayWorldPosition, H(0, 0, 10).applyQuaternion(this.rayWorldQuaternion));
    const t = (this.inputSource.gripSpace ? this.gripWorldPosition : this.object.worldPosition).sub(this.object.worldForward.multiplyScalar(0.1)), i = this.inputSource.profiles.join(`
`);
    let n = `Controller[${this.index}] (${this.inputSource.targetRayMode}, ${this.side})
C:${this.connected ? "x" : "-"} T:${this.isTracking ? "x" : "-"} Hand:${this.inputSource.hand ? "x" : "-"} Pen: ${this._isMxInk ? "x" : "-"}`;
    if (this.inputSource.hand && (n += `
Pinch: ${this.getGesture("pinch")?.value.toFixed(3)}`), n += `
` + i, n += `
` + (this.inputSource.targetRaySpace ? "Ray: x" : "Ray: -") + (this.inputSource.gripSpace ? " Grip: x" : " Grip: -") + (this.inputSource.gamepad ? ` Gamepad: ${this.inputSource.gamepad.mapping}` : " Gamepad: -"), this.inputSource.gamepad) {
      const o = this.inputSource.gamepad;
      let r = "[btns " + o.buttons.length + "]: " + o.buttons.map((a) => a.value.toPrecision(1)).join(",");
      r += `
[axes ` + o.axes.length + "]: " + o.axes.map((a) => a.toPrecision(1)).join(","), n += `
` + r;
    }
    z.DrawLabel(t, n, 6e-3);
  }
  onUpdateFrame(e) {
    if (this._handJointPoses.clear(), this._hand_wristDotUp = void 0, !this.xr.referenceSpace || !this.inputSource.gamepad?.connected) {
      this._isTracking = !1;
      return;
    }
    const t = e.getPose(this.inputSource.targetRaySpace, this.xr.referenceSpace);
    this._isTracking = t != null;
    let i = null, n = null, o = null, r = null;
    if (t) {
      const h = t.transform;
      this._rayMatrix.fromArray(h.matrix).premultiply(na), this._rayMatrix.decompose(this._rayPosition, this._rayQuaternion, H(1, 1, 1)), o = H(h.position), r = ui(h.orientation), this._rayPositionRaw.copy(o), this._rayRotationRaw.copy(r);
    }
    if (this.inputSource.gripSpace) {
      const h = e.getPose(this.inputSource.gripSpace, this.xr.referenceSpace);
      if (h) {
        const d = h.transform;
        if (i = H(d.position), n = ui(d.orientation), this._gripMatrix.fromArray(d.matrix).premultiply(na), this._gripMatrix.decompose(this._gripPosition, this._gripQuaternion, H(1, 1, 1)), "linearVelocity" in h && h.linearVelocity) {
          const f = h.linearVelocity;
          this._linearVelocity.set(f.x, f.y, f.z);
        }
      }
    }
    this.xr.context.mainCamera?.parent && (this._object.parent !== this.xr.context.mainCamera?.parent && this.xr.context.mainCamera.parent.add(this._object), this._gripSpaceObject !== void 0 && this._gripSpaceObject?.parent !== this.xr.context.mainCamera?.parent && this.xr.context.mainCamera.parent.add(this._gripSpaceObject), this._raySpaceObject !== void 0 && this._raySpaceObject?.parent !== this.xr.context.mainCamera?.parent && this.xr.context.mainCamera.parent.add(this._raySpaceObject));
    const a = this.hand;
    if (a) {
      let h = !1;
      const d = a.get("wrist"), f = d && this.getHandJointPose(d, e);
      if (f) {
        h = !0;
        const b = f.transform.position, m = f.transform.orientation;
        this._object.position.set(b.x, b.y, b.z), this._object.quaternion.set(m.x, m.y, m.z, m.w).multiply(zi);
      }
      h || (this._object.position.copy(this._rayPosition), this._object.quaternion.copy(this._rayQuaternion).multiply(zi));
      const p = a.get("middle-finger-metacarpal"), g = p && this.getHandJointPose(p, e);
      g && (this._gripMatrix.fromArray(g.transform.matrix).premultiply(na), this._gripMatrix.decompose(this._gripPosition, this._gripQuaternion, H(1, 1, 1)), i = H().copy(g.transform.position), n = ui().copy(g.transform.orientation), n.multiply(E1), i.add(H(A1).applyQuaternion(n)));
    } else this.inputSource.gripSpace && this.targetRayMode === "transient-pointer" && i && n ? (this._object.position.copy(i), this._object.quaternion.copy(n).multiply(zi)) : o && r && (this._object.position.copy(o), this._object.quaternion.copy(r).multiply(zi));
    Zn && (o && r && (this._raySpaceObject?.position.copy(o), this._raySpaceObject?.quaternion.copy(r).multiply(zi)), i && n && (this._gripSpaceObject?.position.copy(i), this._gripSpaceObject?.quaternion.copy(n).multiply(zi)));
    const l = this.xr.context.mainCamera?.parent, c = l ? be(l) : void 0;
    i && n && (this._gripWorldPosition.copy(i), l && this._gripWorldPosition.applyMatrix4(l.matrixWorld), this._gripWorldQuaternion.copy(n), this._gripWorldQuaternion.multiply(zi), c && this._gripWorldQuaternion.premultiply(c)), this.updateRayWorldPosition(), this.updateRayWorldQuaternion();
  }
  /** Called when the input source disconnects */
  onDisconnected() {
    this._connected = !1, Zn && console.warn("Controller disconnected", this.index);
    for (const e of this._object.children)
      this.xr.context.scene.attach(e);
    this._object?.removeFromParent(), this._debugAxesHelper?.removeFromParent(), this._debugGripAxesHelper?.removeFromParent(), this._debugRayAxesHelper?.removeFromParent(), this._gripSpaceObject?.removeFromParent(), this._raySpaceObject?.removeFromParent(), this.unsubscribeEvents(), this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0);
  }
  /**
   * Get a gamepad button
   * @link https://github.com/immersive-web/webxr-gamepads-module/blob/main/gamepads-module-explainer.md
   * @param key the controller button name e.g. x-button
   * @returns the gamepad button if it exists on the controller - otherwise undefined
   */
  getButton(e) {
    if (!this._layout) return;
    switch (e) {
      case "primary-button":
        if (this.isLeft) e = "x-button";
        else if (this.isRight) e = "a-button";
        else return;
        break;
      case "primary":
        return this.hand ? this.getGesture("pinch") : this.toNeedleGamepadButton(0, e);
      case "xr-standard-trigger":
        if (this.inputSource.gamepad)
          return this.toNeedleGamepadButton(0, e);
        break;
      case "xr-standard-squeeze":
        if (this.inputSource.gamepad)
          return this.toNeedleGamepadButton(1, e);
        break;
      case "xr-standard-thumbstick":
        if (this.inputSource.gamepad)
          return this.toNeedleGamepadButton(3, e);
        break;
    }
    if (this._buttonMap.has(e))
      return this.toNeedleGamepadButton(this._buttonMap.get(e), e);
    const t = this._layout?.components[e];
    if (t?.gamepadIndices)
      switch (t.type) {
        case "button":
        case "squeeze":
          if (this.inputSource.gamepad) {
            const i = t.gamepadIndices.button;
            return this._buttonMap.set(e, i), this.toNeedleGamepadButton(i, e);
          }
          break;
        default:
          console.warn("Unsupported component type", t.type);
          break;
      }
    this._buttonMap.set(e, void 0);
  }
  /** Get a gesture state */
  getGesture(e) {
    const t = this.states[e];
    if (!t) return null;
    this.states[e] = t;
    const i = this._needleGamepadButtons[e] || new jy(void 0, e);
    return i.pressed = t.pressed, i.value = t.value, i.isDown = t.isDown, i.isUp = t.isUp, this._needleGamepadButtons[e] = i, i;
  }
  getPointerId(e) {
    if ((e === "primary" || e === "pinch") && (e = 0), typeof e != "number") {
      const t = this._buttonMap.get(e);
      if (t === void 0)
        return;
      e = t;
    }
    return this.index * 10 + e;
  }
  _needleGamepadButtons = {};
  /** combine the InputState information + the GamepadButton information (since GamepadButtons can not be extended) */
  toNeedleGamepadButton(e, t) {
    if (!this.inputSource.gamepad?.buttons) return;
    const i = this.inputSource.gamepad?.buttons[e], n = this.states[e], o = this._needleGamepadButtons[e] || new jy(e, t);
    return i && (o.pressed = i.pressed, o.value = i.value, o.touched = i.touched), n && (o.isDown = n.isDown, o.isUp = n.isUp), this._needleGamepadButtons[e] = o, o;
  }
  /**
   * Get the values of a controller joystick
   * @link https://github.com/immersive-web/webxr-gamepads-module/blob/main/gamepads-module-explainer.md
   * @returns the stick values where x is left/right, y is up/down and z is the button value
   */
  getStick(e) {
    if (!this._layout) return { x: 0, y: 0, z: 0 };
    if (this.isHand)
      return { x: 0, y: 0, z: 0 };
    e === "primary" && this._layout.components["xr-standard-thumbstick"] && (e = "xr-standard-thumbstick");
    const t = this._layout?.components[e];
    if (t?.gamepadIndices)
      switch (t.type) {
        case "thumbstick":
          if (this.inputSource.gamepad) {
            const i = t.gamepadIndices.xAxis, n = t.gamepadIndices.yAxis;
            let o = this.inputSource.gamepad.axes[i] || 0, r = this.inputSource.gamepad.axes[n] || 0;
            o *= -1, r *= -1;
            const a = t.gamepadIndices.button, l = this.inputSource.gamepad?.buttons[a]?.value || 0;
            return { x: o, y: r, z: l };
          }
      }
    return { x: 0, y: 0, z: 0 };
  }
  _buttonMap = /* @__PURE__ */ new Map();
  // the motion controller contains the controller scheme, we use this to simplify button access
  _motioncontroller;
  _layout;
  getMotionController;
  initialize() {
    if (this._hasSelectEvent = this.profiles.includes("generic-hand-select") || this.profiles.some((e) => e.startsWith("generic-trigger")), this._isMetaQuestTouchController = this.profiles.includes("meta-quest-touch-plus") || this.profiles.includes("oculus-touch-v3"), this._isMxInk = this.profiles.includes("logitech-mx-ink"), !this._layout) {
      if (this.inputSource.targetRayMode === "transient-pointer") return;
      const e = GS(this.inputSource, R1, T1);
      this.getMotionController = e.then((t) => {
        if (!this.connected) return null;
        this._motioncontroller = new qS(
          this.inputSource,
          t.profile,
          t.assetPath || ""
        );
        const n = t.profile.layouts[this.inputSource.handedness];
        if (this._layout = n, this._layout && !this._layout.gamepad?.length) {
          this._layout.gamepad = [];
          for (const o in this._layout.components) {
            const r = this._layout.components[o];
            this._layout.gamepad[r.gamepadIndices.button] = o;
          }
        }
        return this._motioncontroller;
      }).catch((t) => (this.inputSource && console.warn("Couldn't initialize motion controller profile for ", this.inputSource, t), null));
    }
  }
  /**
   * When enabled the controller will automatically emit pointer down events to the Needle Engine Input System.   
   * @default true
   */
  emitPointerDownEvent = !0;
  /**
   * When enabled the controller will automatically emit pointer up events to the Needle Engine Input System.   
   * @default true
   */
  emitPointerUpEvent = !0;
  /**
   * When enabled the controller will automatically emit pointer move events to the Needle Engine Input System.   
   * @default true
   */
  emitPointerMoveEvent = !0;
  /**
   * The distance threshold for pointer move events. This value is in units in rig space
   * @default 0.03
   */
  pointerMoveDistanceThreshold = 0.03;
  /**
   * The angle threshold for pointer move events. This value is in radians.
   * @default 0.05
   */
  pointerMoveAngleThreshold = 0.05;
  subscribeEvents() {
    this.xr.session.addEventListener("selectstart", this.onSelectStart), this.xr.session.addEventListener("selectend", this.onSelectEnd), this.xr.session.addEventListener("squeezestart", this.onSequeezeStart), this.xr.session.addEventListener("squeezeend", this.onSequeezeEnd);
  }
  unsubscribeEvents() {
    this.xr.session.removeEventListener("selectstart", this.onSelectStart), this.xr.session.removeEventListener("selectend", this.onSelectEnd), this.xr.session.removeEventListener("squeezestart", this.onSequeezeStart), this.xr.session.removeEventListener("squeezeend", this.onSequeezeEnd);
  }
  _selectButtonIndex = void 0;
  _squeezeButtonIndex = void 0;
  onSelectStart = (e) => {
    if (!this.emitPointerDownEvent || this.inputSource !== e.inputSource) return;
    this.onUpdateFrame(e.frame), this._hasSelectEvent = !0;
    const t = this._layout?.selectComponentId, i = this._layout?.components[t]?.gamepadIndices?.button;
    i !== void 0 && (this._selectButtonIndex = i), !nh && (Zn && z.DrawDirection(this.rayWorldPosition, H(0, 0.01, 1).applyQuaternion(this.rayWorldQuaternion), 16711680, 10), this.emitPointerEvent(De.PointerDown, this._selectButtonIndex || 0, "xr-standard-trigger", !0, e));
  };
  onSelectEnd = (e) => {
    this.emitPointerUpEvent && (nh || this.inputSource === e.inputSource && this.emitPointerEvent(De.PointerUp, this._selectButtonIndex || 0, "xr-standard-trigger", !0, e));
  };
  onSequeezeStart = (e) => {
    this.emitPointerDownEvent && this.inputSource === e.inputSource && (this._squeezeButtonIndex = this._layout?.components["xr-standard-squeeze"]?.gamepadIndices?.button, this._squeezeButtonIndex !== void 0 && (Zn && z.DrawDirection(this.rayWorldPosition, H(0, 0.01, 1).applyQuaternion(this.rayWorldQuaternion), 255, 10), this.emitPointerEvent(De.PointerDown, this._squeezeButtonIndex || 0, "xr-standard-squeeze", !0, e)));
  };
  onSequeezeEnd = (e) => {
    this.emitPointerUpEvent && this.inputSource === e.inputSource && this._squeezeButtonIndex !== void 0 && this.emitPointerEvent(De.PointerUp, this._squeezeButtonIndex || 0, "xr-standard-squeeze", !0, e);
  };
  /** Index = button index */
  states = {};
  // If we want to invoke button events for ALL buttons we need to keep track of the previous state
  // instead of using XR input select start events which is only raised for the primary button
  // we should probably do both but then we need to ignore the primary index in the following function (to not raise an event for the same button twice)
  // and start with index = 1
  updateInputEvents() {
    if (this.gamepad?.buttons) {
      for (let e = 0; e < this.gamepad.buttons.length; e++) {
        const t = this.gamepad.buttons[e], i = this.states[e] || new Dy();
        let n = null;
        this._isMxInk && (e === 4 || e === 5) ? (t.value > 0 && !i.pressed ? (n = "pointerdown", i.isDown = !0, i.isUp = !1) : t.value === 0 && i.pressed ? (n = "pointerup", i.isDown = !1, i.isUp = !0) : i.pressed && (n = "pointermove", i.isDown = !1, i.isUp = !1), i.pressed = t.value > 0, i.value = t.value) : (t.pressed && !i.pressed ? (n = "pointerdown", i.isDown = !0, i.isUp = !1) : !t.pressed && i.pressed ? (n = "pointerup", i.isDown = !1, i.isUp = !0) : (i.isDown = !1, i.isUp = !1), i.pressed = t.pressed, i.value = t.value), this.states[e] = i;
        const o = e !== this._selectButtonIndex && e !== this._squeezeButtonIndex;
        if (n != null && o) {
          let r = this._layout?.gamepad[e];
          this._isMxInk && e === 4 && (r = "stylus-touch"), this._isMxInk && e === 5 && (r = "stylus-tip"), (Zn || nh) && console.log("Emitting pointer event", n, e, r, t.value, this.gamepad, this._layout), this.emitPointerEvent(n, e, r ?? "none", !1, null, t.value);
        }
      }
      if (this._isMetaQuestTouchController) {
        const e = this.gamepad.buttons.length - 1, t = this.states[e];
        if (t && t.isDown) {
          const i = this.context.menu;
          i.spatialMenuIsVisible ? i.setSpatialMenuVisible(!1) : this.context.menu.setSpatialMenuVisible(!0);
        }
      }
    }
    if (this.hand) {
      const e = this.handObject;
      if (e) {
        const t = e.joints["index-finger-tip"], i = e.joints["thumb-tip"];
        if (t && i) {
          const n = t.position.distanceTo(i.position);
          this._pinchPosition.lerpVectors(t.position, i.position, 0.5);
          const o = this.xr.context.mainCamera?.parent;
          if (o && this._pinchPosition.applyMatrix4(o.matrixWorld), n !== 0) {
            const l = this.states.pinch || new Dy(), c = (0.02 + 0.01) * 1.5;
            l.value = 1 - (n - 0.02) / c;
            const h = n < 0.02 - 0.01, d = n > 0.02 + 0.01;
            h && !l.pressed ? (nh && console.log("pinch start", n), l.isDown = !0, l.isUp = !1, l.pressed = !0) : d && l.pressed ? (l.isDown = !1, l.isUp = !0, l.pressed = !1) : (l.isDown = !1, l.isUp = !1), this.states.pinch = l;
          }
        }
      }
    }
  }
  _didMoveLastFrame = !1;
  _lastPointerMovePosition = new y();
  _lastPointerMoveQuaternion = new U();
  onUpdateMove() {
    if (!this.emitPointerMoveEvent) return;
    let e = !1;
    if (this._lastPointerMovePosition.distanceTo(this.gripWorldPosition) > this.pointerMoveDistanceThreshold * this.xr.rigScale && (e = !0), e || this._lastPointerMoveQuaternion.angleTo(this.gripWorldQuaternion) > this.pointerMoveAngleThreshold && (e = !0), e) {
      this._didMoveLastFrame = !0, this._lastPointerMovePosition.copy(this.gripWorldPosition), this._lastPointerMoveQuaternion.copy(this.gripWorldQuaternion), Zn && z.DrawLabel(this.rayWorldPosition.add(this.object.worldForward.multiplyScalar(0.1)), "move", 0.01);
      let i = this.xr.context.input.getFirstPressedButtonForPointer(this.index);
      i === void 0 && (i = 0);
      const n = this.gamepad?.buttons[i]?.value;
      this.emitPointerEvent("pointermove", i, "none", !1, null, n);
    } else
      this._didMoveLastFrame = !1;
  }
  /** cached spatial pointer init object. We re-use it to not have */
  pointerInit;
  emitPointerEvent(e, t, i, n, o = null, r) {
    if (!this.emitEvents) {
      Zn && e !== De.PointerMove && console.warn("Pointer events are disabled for this controller", this.index, e, t);
      return;
    }
    if (this.xr.mode === "immersive-vr" || this.xr.isPassThrough) {
      this.pointerInit.origin = this, this.pointerInit.pointerId = this.getPointerId(t), this.pointerInit.pointerType = this.hand ? "hand" : "controller", this.pointerInit.button = t, this.pointerInit.buttonName = i, this.pointerInit.isPrimary = n, this.pointerInit.mode = this.inputSource.targetRayMode, this.pointerInit.ray = this.ray, this.pointerInit.device = this.object, this.pointerInit.pressure = r, this.pointerInit.clientX = this._rayPosition.x / this.xr.rigScale, this.pointerInit.clientY = this._rayPosition.y / this.xr.rigScale, this.pointerInit.clientZ = this._rayPosition.z / this.xr.rigScale;
      const a = N.Current;
      N.Current = this.xr.context, Zn && e !== "pointermove" && console.warn("Pointer event", e, t, i, { ...this.pointerInit }), this.xr.context.input.createInputEvent(new Hs(e, o, this.pointerInit)), N.Current = a;
    }
  }
}
class Dy {
  /** if the button was pressed the last update */
  isDown = !1;
  /** if the button was released the last update */
  isUp = !1;
  pressed = !1;
  value = 0;
}
class jy {
  /** The index of the button in the input gamepad */
  index;
  name;
  touched = !1;
  pressed = !1;
  value = 0;
  /** was the button just pressed down the last update */
  isDown = !1;
  /** was the button just released the last update */
  isUp = !1;
  constructor(e, t) {
    this.index = e, this.name = t;
  }
}
var Cp = /* @__PURE__ */ ((s) => (s.Visible = "application-visible", s.Hidden = "application-hidden", s.MuteChanged = "application-mutechanged", s))(Cp || {});
let hd = !1;
const Yr = [];
function yr() {
  if (hd) return;
  L() && console.debug("User interaction registered: audio can now be played"), hd = !0;
  const s = [...Yr];
  Yr.length = 0, s.forEach((e) => e());
}
document.addEventListener("mousedown", yr);
document.addEventListener("pointerup", yr);
document.addEventListener("click", yr);
document.addEventListener("dragstart", yr);
document.addEventListener("touchend", yr);
document.addEventListener("keydown", yr);
class Fn extends EventTarget {
  static get userInteractionRegistered() {
    return hd;
  }
  /**  @deprecated use Application.registerWaitForInteraction instead */
  static registerWaitForAllowAudio = Fn.registerWaitForInteraction;
  /**
   * Register a callback that will be called when the user interacts with the page (click, touch, keypress, etc).  
   * If the user has already interacted with the page, the callback will be called immediately.  
   * This can be used to wait for user interaction before playing audio, for example.
   */
  static registerWaitForInteraction(e) {
    if (e !== null) {
      if (hd) {
        e();
        return;
      }
      Yr.indexOf(e) === -1 && Yr.push(e);
    }
  }
  /**
   * Unregister a callback that was previously registered with registerWaitForInteraction.
   */
  static unregisterWaitForInteraction(e) {
    const t = Yr.indexOf(e);
    t !== -1 && Yr.splice(t, 1);
  }
  _mute = !1;
  /** audio muted? */
  get muted() {
    return this._mute;
  }
  /** set global audio mute */
  set muted(e) {
    e !== this._mute && (this._mute = e, this.dispatchEvent(new Event(
      "application-mutechanged"
      /* MuteChanged */
    )));
  }
  context;
  /** @returns true if the document is focused */
  get hasFocus() {
    return document.hasFocus();
  }
  /**
   * @returns true if the application is currently visible (it's tab is active and not minimized)
   */
  get isVisible() {
    return this._isVisible;
  }
  _isVisible = !0;
  /** @internal */
  constructor(e) {
    super(), this.context = e, window.addEventListener("visibilitychange", this.onVisiblityChanged.bind(this), !1);
  }
  onVisiblityChanged(e) {
    switch (e.target.visibilityState) {
      case "hidden":
        this._isVisible = !1, this.dispatchEvent(new Event(
          "application-hidden"
          /* Hidden */
        ));
        break;
      case "visible":
        this._isVisible = !0, this.dispatchEvent(new Event(
          "application-visible"
          /* Visible */
        ));
        break;
    }
  }
}
const sa = /* @__PURE__ */ new Map(), Kr = /* @__PURE__ */ new Map();
let By = 0;
function Ms(s, e, t) {
  if (sa.has(e) || sa.set(e, new Array()), sa.get(e).push({
    method: s,
    options: { once: !1, ...t }
  }), By < 30) {
    const i = Kr.get(e);
    i && i?.length > 100 && (By += 1, console.warn(`You have ${i.length} methods registered for Event ${e}.

This might be a performance issue!
Consider unregistering the methods when they are not needed anymore!

To unregister you can call the function returned by your event hook (e.g.const unregister = onStart(...)) 

or by using the once option like onStart(()=>{}, { once:true }).

See https://engine.needle.tools/docs/scripting.html#special-lifecycle-hooks for more information.`));
  }
}
function yo(s, e) {
  const t = Kr.get(e);
  if (t) {
    for (let n = 0; n < t.length; n++)
      if (t[n].method === s) {
        t.splice(n, 1);
        return;
      }
  }
  const i = sa.get(e);
  if (i) {
    for (let n = 0; n < i.length; n++)
      if (i[n].method === s) {
        i.splice(n, 1);
        return;
      }
  }
}
function yn(s, e) {
  e === he.ContextCreated && Pp.delete(s), g0(s, e);
}
function g0(s, e) {
  e === xe.Start && sa.get(he.ContextCreated) && g0(s, he.ContextCreated);
  const t = e === xe.Start || e === he.ContextCreated, i = Kr.get(e);
  i && i.length > 0 && zy(s, i, t);
  const n = sa.get(e);
  if (n && n.length > 0) {
    const o = [...n];
    n.length = 0, zy(s, o, t), o.length > 0 && (Kr.has(e) || Kr.set(e, new Array()), Kr.get(e).push(...o));
  }
}
const sh = new Array(), Fy = {
  context: null
};
function zy(s, e, t) {
  sh.length = 0;
  for (let n = 0; n < e.length; n++)
    sh.push(e[n]);
  let i = Pp.get(s);
  for (let n = 0; n < sh.length; n++) {
    const o = sh[n];
    let r = !0;
    if (i && i.has(o) && (r = !1), r)
      try {
        Fy.context = s, o.method?.call(Fy, s);
      } catch (a) {
        console.error("Error in lifecycle method", a);
      }
    if (o.options?.once) {
      for (let a = 0; a < e.length; a++)
        if (e[a] === o) {
          e.splice(a, 1);
          break;
        }
    } else t && (i || (i = /* @__PURE__ */ new Set(), Pp.set(s, i)), i.add(o));
  }
}
const Pp = /* @__PURE__ */ new WeakMap(), y0 = {};
function _0(s, e) {
  y0[s] = e;
}
function I1(s) {
  const e = s.getBufferIdentifier(), t = y0[e];
  return t(s);
}
function L1(s) {
  return typeof s.guid == "function" ? s.guid() : null;
}
let Nm;
function iL() {
  return Nm;
}
function nL(s) {
  Nm = s;
}
function D1(s, e) {
  return e || (e = {}), e = {
    ...Nm,
    ...e
  }, s ? new dy(s, e) : new dy(e);
}
async function Uy() {
  const s = await import("./vendor-k9i6CeGi.js").then((e) => e.bundler);
  return console.log(s), s.default === void 0 ? s : s.default;
}
class j1 {
  get isHost() {
    return this._host !== void 0;
  }
  _host;
  _client;
  _clientData;
  constructor() {
    this.onEnable();
  }
  onEnable() {
    this.trySetupHost("HOST-5980e65c-8438-453e-8b35-f13c736dcd81");
  }
  async trySetupHost(e) {
    const t = await Uy(), i = new t(e);
    i.on("error", (n) => {
      console.error(n), this._host = void 0, this.trySetupClient(e);
    }), i.on("open", (n) => {
      this._host = new F1(i);
    });
  }
  async trySetupClient(e) {
    const t = await Uy();
    this._client = new t(), this._client.on("error", (i) => {
      console.error("Client error", i);
    }), this._client.on("open", (i) => {
      console.log("client connected", i), this._clientData = this._client.connect(e, { metadata: { id: i } }), this._clientData.on("open", () => {
        console.log("Connected to host");
      }), this._clientData.on("data", (n) => {
        console.log("<<", n);
      });
    });
  }
}
class B1 {
  _peer;
  constructor(e) {
    this._peer = e;
  }
}
class F1 extends B1 {
  get isHost() {
    return !0;
  }
  _connections = [];
  constructor(e) {
    super(e), console.log("I AM THE HOST"), this._peer?.on("connection", this.onConnection.bind(this)), this._peer.on("close", () => {
      this.broadcast("BYE");
    }), setInterval(() => {
      this.broadcast("HELLO");
    }, 2e3);
  }
  onConnection(e) {
    console.log("host connection", e), e.on("open", () => {
      this._connections.push(e), this.broadcastConnection(e);
    });
  }
  broadcastConnection(e) {
    const t = this._connections.map((i) => i.metadata?.id).filter((i) => i !== void 0);
    this.broadcast({ type: "connection-list", connections: t });
  }
  broadcast(e) {
    if (e != null) {
      console.log(">>", e);
      for (const t in this._peer.connections) {
        const i = this._peer.connections[t];
        if (i)
          if (Array.isArray(i))
            for (const n of i)
              n && n.send(e);
          else
            console.warn(i);
      }
    }
  }
}
var wn = /* @__PURE__ */ ((s) => (s[s.OnConnection = 0] = "OnConnection", s[s.OnRoomJoin = 1] = "OnRoomJoin", s[s.Queued = 2] = "Queued", s[s.Immediate = 3] = "Immediate", s))(wn || {});
const Ny = "https://urls.needle.tools/default-networking-backend/index";
let Ai = "wss://networking.needle.tools/socket";
const ci = !!w("debugnet"), oh = !!(ci || w("debugowner")), rh = w("debugnetbin");
var z1 = /* @__PURE__ */ ((s) => (s.ConnectionInfo = "connection-start-info", s))(z1 || {}), te = /* @__PURE__ */ ((s) => (s.Join = "join-room", s.Leave = "leave-room", s.JoinedRoom = "joined-room", s.LeftRoom = "left-room", s.UserJoinedRoom = "user-joined-room", s.UserLeftRoom = "user-left-room", s.RoomStateSent = "room-state-sent", s))(te || {});
class sL {
  room;
  // room name
  viewId;
  allowEditing;
  inRoom;
  // connection ids
}
class oL {
  room;
  // room name
}
class rL {
  userId;
}
var U1 = /* @__PURE__ */ ((s) => (s.RequestHasOwner = "request-has-owner", s.ResponseHasOwner = "response-has-owner", s.RequestIsOwner = "request-is-owner", s.ResponseIsOwner = "response-is-owner", s.RequestOwnership = "request-ownership", s.GainedOwnership = "gained-ownership", s.RemoveOwnership = "remove-ownership", s.LostOwnership = "lost-ownership", s.GainedOwnershipBroadcast = "gained-ownership-broadcast", s.LostOwnershipBroadcast = "lost-ownership-broadcast", s))(U1 || {});
class b0 {
  guid;
  connection;
  get hasOwnership() {
    return this._hasOwnership;
  }
  // TODO: server should just send id to everyone
  /** @returns true of anyone has ownership */
  get isOwned() {
    return this._isOwned;
  }
  /** 
   * Checks if Needle Engine networking is connected to a websocket. Note that this is **not equal** to being connected to a *room*. If you want to check if Needle Engine is connected to a networking room use the `isInRoom` property.
   * @returns true if connected to the websocket. 
   */
  get isConnected() {
    return this.connection.isConnected;
  }
  _hasOwnership = !1;
  _isOwned = void 0;
  _gainSubscription;
  _lostSubscription;
  _hasOwnerResponse;
  constructor(e, t) {
    this.connection = e, this.guid = t, this._gainSubscription = this.onGainedOwnership.bind(this), this._lostSubscription = this.onLostOwnership.bind(this), e.beginListen("lost-ownership", this._lostSubscription), e.beginListen("gained-ownership-broadcast", this._gainSubscription), this._hasOwnerResponse = this.onHasOwnerResponse.bind(this), e.beginListen("response-has-owner", this._hasOwnerResponse);
  }
  _isWaitingForOwnershipResponseCallback = null;
  updateIsOwned() {
    this.connection.send("request-has-owner", { guid: this.guid });
  }
  onHasOwnerResponse(e) {
    e.guid === this.guid && (this._isOwned = e.value);
  }
  requestOwnershipIfNotOwned() {
    return this._isWaitingForOwnershipResponseCallback !== null ? this : (this._isWaitingForOwnershipResponseCallback = this.waitForHasOwnershipRequestResponse.bind(this), this.connection.beginListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this.connection.send("request-has-owner", { guid: this.guid }), this);
  }
  waitForHasOwnershipRequestResponse(e) {
    e.guid === this.guid && (this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null), this._isOwned = e.value, e.value || (oh && console.log("request ownership", this.guid), this.requestOwnership()));
  }
  requestOwnershipAsync() {
    return new Promise((e, t) => {
      this.requestOwnership();
      let i = 0;
      const n = () => {
        if (i++ > 10) return t("Timeout");
        setTimeout(() => {
          this.hasOwnership ? e(this) : n();
        }, 100);
      };
      n();
    });
  }
  requestOwnership() {
    return oh && console.log("Request ownership", this.guid), this.connection.send("request-ownership", { guid: this.guid }), this;
  }
  freeOwnership() {
    return this.connection.send("remove-ownership", { guid: this.guid }), this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null), this;
  }
  destroy() {
    this.connection.stopListen("gained-ownership", this._gainSubscription), this.connection.stopListen("lost-ownership", this._lostSubscription), this.connection.stopListen("response-has-owner", this._hasOwnerResponse), this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null);
  }
  onGainedOwnership(e) {
    e.guid === this.guid && (this._isOwned = !0, this.connection.connectionId === e.owner ? (oh && console.log("GAINED OWNERSHIP", this.guid), this._hasOwnership = !0) : this._hasOwnership = !1);
  }
  onLostOwnership(e) {
    e === this.guid && (oh && console.log("LOST OWNERSHIP", this.guid), this._hasOwnership = !1, this._isOwned = !1);
  }
}
class N1 {
  context;
  _peer = null;
  constructor(e) {
    this.context = e;
  }
  /** Experimental: networking via peerjs */
  get peer() {
    return this._peer || (this._peer = new j1()), this._peer;
  }
  /**
   * Returns the state of a given guid.
   */
  tryGetState(e) {
    return e === "invalid" ? null : this._state[e];
  }
  /** The connection id of the local user - it is given by the networking backend and can not be changed */
  get connectionId() {
    return this._connectionId;
  }
  /** Returns true if the networking backend is in debug mode.  
   * To see all networking messages in the console use `?debugnet` in the url
   */
  get isDebugEnabled() {
    return ci;
  }
  /** 
   * Checks if Needle Engine networking is connected to a websocket. Note that this is **not equal** to being connected to a *room*. If you want to check if Needle Engine is connected to a networking room use the `isInRoom` property.
   * @returns true if connected to the websocket. 
   */
  get isConnected() {
    return this.connected;
  }
  /** The name of the room the user is currently connected to */
  get currentRoomName() {
    return this._currentRoomName;
  }
  /** True when connected to a room via a regular url, otherwise (when using a view only url) false indicating that the user should not be able to modify the scene */
  get allowEditing() {
    return this._currentRoomAllowEditing;
  }
  /**
   * The view id of the room the user is currently connected to.
   */
  get currentRoomViewId() {
    return this._currentRoomViewId;
  }
  /**
   * Returns a url that can be shared with others to view the current room in view only mode.  
   * This is useful for sharing a room with others without allowing them to modify the scene.  
   * Use `connection.allowEditing` to check if the current room is in view only mode.  
   */
  getViewOnlyUrl() {
    if (this.currentRoomViewId === null) return null;
    const e = new URL(window.location.href);
    return e.searchParams.set("view", this.currentRoomViewId), e.href;
  }
  /** True if connected to a networked room. Use the joinRoom function or a `SyncedRoom` component */
  get isInRoom() {
    return this._isInRoom;
  }
  /** Latency to currently connected backend server */
  get currentLatency() {
    return this._currentDelay;
  }
  /**
   * The current server url that the networking backend is connected to (e.g. the url of the websocket server)
   */
  get currentServerUrl() {
    return this._ws?.url ?? null;
  }
  /** A ping is sent to the server at a regular interval while the browser tab is active. This method can be used to send additional ping messages when needed so that the user doesn't get disconnected from the networking backend */
  sendPing() {
    this.send("ping", { time: this.context.time.time });
  }
  /** Returns true if a user with the given connectionId is in the room */
  userIsInRoom(e) {
    return this._currentInRoom.indexOf(e) !== -1;
  }
  _usersInRoomCopy = [];
  /** Returns a list of all user ids in the current room */
  usersInRoom(e = null) {
    e || (e = this._usersInRoomCopy), e.length = 0;
    for (const t of this._currentInRoom)
      e.push(t);
    return e;
  }
  /** Joins a networked room. If you don't want to manage a connection yourself you can use a `SyncedRoom` component as well */
  joinRoom(e, t = !1) {
    return e ? e.length > 1024 ? (console.error('Room name too long, can not join: "' + e + '". Max length is 1024 characters.'), !1) : (this.isInRoom && this.currentRoomName !== e && console.warn("Needle Engine is already connected to a networking room. Connecting to multiple rooms is not supported"), this.connect(), ci && console.log("join: " + e), this.send("join-room", { room: e, viewOnly: t }, wn.OnConnection), !0) : (console.error('Missing room name, can not join: "' + e + '"'), !1);
  }
  /** Use to leave a room that you are currently connected to (use `leaveRoom()` to disconnect from the currently active room but you can also specify a room name) */
  leaveRoom(e = null) {
    return e || (e = this.currentRoomName), e ? (this.send("leave-room", { room: e }), !0) : (console.error('Missing room name, can not join: "' + e + '"'), !1);
  }
  /** Send a message to the networking backend - it will broadcasted to all connected users in the same room by default */
  send(e, t = null, i = wn.Queued) {
    if (t === null && (t = {}), i === wn.Queued) {
      this._defaultMessagesBuffer.push({ key: e, value: t });
      return;
    }
    return this.sendWithWebsocket(e, t, i);
  }
  /** Use to delete state for a given guid on the server */
  sendDeleteRemoteState(e) {
    this.send("delete-state", { guid: e, dontSave: !0 }), delete this._state[e];
  }
  /** Use to delete all state in the currently connected room on the server */
  sendDeleteRemoteStateAll() {
    this.send("delete-all-state"), this._state = {};
  }
  /** Send a binary message to the server (broadcasted to all connected users) */
  sendBinary(e) {
    rh && console.log("<< send binary", this.context.time.frame, e.length / 1024 + " KB"), this._ws?.send(e);
  }
  _defaultMessagesBuffer = [];
  _defaultMessagesBufferArray = [];
  sendBufferedMessagesNow() {
    if (!this._ws) return;
    this._defaultMessagesBufferArray.length = 0;
    const e = Object.keys(this._defaultMessagesBuffer).length;
    for (const i in this._defaultMessagesBuffer) {
      const n = this._defaultMessagesBuffer[i];
      if (e <= 1) {
        this.sendWithWebsocket(n.key, n.value, wn.Immediate);
        break;
      }
      const o = this.toMessage(n.key, n.value);
      this._defaultMessagesBufferArray.push(o);
    }
    if (this._defaultMessagesBuffer.length = 0, this._defaultMessagesBufferArray.length > 0 && ci && console.log("SEND BUFFERED", this._defaultMessagesBufferArray.length), this._defaultMessagesBufferArray.length <= 0) return;
    const t = JSON.stringify(this._defaultMessagesBufferArray);
    this._ws?.send(t);
  }
  /** Use to start listening to networking events.   
   * To unsubscribe from events use the `stopListen` method.   
   * See the example below for typical usage:
   * 
   * ### Component Example
   * ```ts
   * // Make sure to unsubscribe from events when the component is disabled
   * export class MyComponent extends Behaviour {
   *   onEnable() {
   *     this.connection.beginListen("joined-room", this.onJoinedRoom)
   *   }
   *   onDisable() {
   *     this.connection.stopListen("joined-room", this.onJoinedRoom)
   *   }
   *   onJoinedRoom = () => {
   *      console.log("I joined a networked room")
   *   }
   * }
   * ```
   * @link https://engine.needle.tools/docs/networking.html
   * 
  */
  beginListen(e, t) {
    return this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t), t;
  }
  /**@deprecated please use stopListen instead (2.65.2-pre) */
  stopListening(e, t) {
    return this.stopListen(e, t);
  }
  /** Use to stop listening to networking events  
   * To subscribe to events use the `beginListen` method.   
   * See the example below for typical usage:
   * 
   * ### Component Example
   * ```ts
   * // Make sure to unsubscribe from events when the component is disabled
   * export class MyComponent extends Behaviour {
   *   onEnable() {
   *     this.connection.beginListen("joined-room", this.onJoinedRoom)
   *   }
   *   onDisable() {
   *     this.connection.stopListen("joined-room", this.onJoinedRoom)
   *   }
   *   onJoinedRoom = () => {
   *      console.log("I joined a networked room")
   *   }
   * }
   * ```
   */
  stopListen(e, t) {
    if (!t || !this._listeners[e]) return;
    const i = this._listeners[e].indexOf(t);
    i >= 0 && this._listeners[e].splice(i, 1);
  }
  /** Use to start listening to networking binary events */
  beginListenBinary(e, t) {
    return this._listenersBinary[e] || (this._listenersBinary[e] = []), this._listenersBinary[e].push(t), t;
  }
  /** Use to stop listening to networking binary events */
  stopListenBinary(e, t) {
    if (!this._listenersBinary[e]) return;
    const i = this._listenersBinary[e].indexOf(t);
    i >= 0 && this._listenersBinary[e].splice(i, 1);
  }
  netWebSocketUrlProvider;
  /** Use to override the networking server backend url. This is what the `Networking` component uses to modify the backend url */
  registerProvider(e) {
    this.netWebSocketUrlProvider = e;
  }
  /** Used to connect to the networking server */
  async connect(e) {
    if (this.connected && e && e !== Ai)
      return Promise.reject("Can not connect to different server url. Please disconnect first.");
    if (this.connected)
      return Promise.resolve(!0);
    e && console.debug("Connecting to user provided url " + e);
    const t = e || this.netWebSocketUrlProvider?.getWebsocketUrl();
    return t ? Ai = t : rC() && (Ai = "wss://" + window.location.host + "/socket"), this.connectWebsocket();
  }
  /** Disconnect from the networking backend + reset internal state */
  disconnect() {
    this._ws?.close(), this._ws = void 0, Ai = void 0, this._currentRoomAllowEditing = !0, this._currentRoomName = null, this._currentRoomViewId = null, this._isInRoom = !1, this._currentInRoom.length = 0, this._state = {}, this._currentDelay = -1;
  }
  _listeners = {};
  _listenersBinary = {};
  connected = !1;
  channelId;
  _connectionId = null;
  // Websocket ------------------------------------------------------------
  _ws;
  _waitingForSocket = {};
  _isInRoom = !1;
  _currentRoomName = null;
  _currentRoomViewId = null;
  _currentRoomAllowEditing = !0;
  _currentInRoom = [];
  _state = {};
  _currentDelay = -1;
  _connectingToWebsocketPromise = null;
  connectWebsocket() {
    return this._connectingToWebsocketPromise ? this._connectingToWebsocketPromise : this._connectingToWebsocketPromise = new Promise(async (e, t) => {
      let i = !1;
      const n = (c) => {
        i || (i = !0, e(c));
      };
      if (Ai === void 0 && (console.log("Fetch default backend url: " + Ny), Ai = await (await fetch(Ny)).text()), Ai === void 0) {
        n(!1);
        return;
      }
      console.debug(`⊡ Connecting to networking backend on
` + Ai);
      const o = await import("./vendor-k9i6CeGi.js").then((c) => c.index), r = o.default?.WebsocketBuilder ?? o.WebsocketBuilder, a = o.default?.ExponentialBackoff ?? o.ExponentialBackoff, l = new r(Ai).withMaxRetries(10).withBackoff(new a(2e3, 4)).onOpen(() => {
        this._connectingToWebsocketPromise = null, this._ws = l, this.connected = !0, L() || ci ? console.log(`⊞ Connected to networking backend
` + Ai) : console.debug("⊞ Connected to networking backend", Ai), n(!0), this.onSendQueued(wn.OnConnection);
      }).onClose((c) => {
        this._connectingToWebsocketPromise = null, this.connected = !1, this._isInRoom = !1, n(!1);
        let h = "Websocket connection closed...";
        Ai?.includes("/socket") || (h += ' Do you perhaps mean to connect to "/socket"?'), console.error(h);
      }).onError((c) => {
        console.error("⊠ Websocket connection failed..."), n(!1);
      }).onRetry(() => {
        console.log("→ Retry connecting to networking websocket");
      }).build();
      l.addEventListener(o.WebsocketEvent.message, (c, h) => {
        this.onMessage(c, h);
      });
    });
  }
  onMessage(e, t) {
    const i = t.data;
    try {
      if (typeof i != "string") {
        i.size && this.handleIncomingBinaryMessage(i);
        return;
      }
      const n = JSON.parse(i);
      if (Array.isArray(n))
        for (const o of n)
          this.handleIncomingStringMessage(o);
      else this.handleIncomingStringMessage(n);
      return;
    } catch (n) {
      ci && i === "pong" ? console.log("<<", i) : L() && console.error("Failed to parse message", n);
    }
  }
  async handleIncomingBinaryMessage(e) {
    rh && console.log("<< bin", this.context.time.frame);
    const t = await e.arrayBuffer();
    var i = new Uint8Array(t);
    const n = new XS(i), o = n.getBufferIdentifier(), r = this._listenersBinary[o], a = I1(n), l = L1(a);
    if (l && typeof l == "string" && (this._state[l] = a), !r) return;
    const c = a ?? n;
    for (const h of r)
      h(c);
  }
  handleIncomingStringMessage(e) {
    if (ci && console.log("<<", e.key ?? e), e.key)
      switch (e.key) {
        case "connection-start-info":
          if (e.data) {
            const r = e.data;
            r && (console.assert(
              r.id !== void 0 && r.id !== null && r.id.length > 0,
              "server did not send connection id",
              r.id
            ), console.debug("Your id is: " + r.id, this.context.alias ?? ""), this._connectionId = r.id);
          } else console.warn("Expected connection id in " + e.key);
          break;
        case "joined-room":
          if (ci && console.log(e), e) {
            this._isInRoom = !0;
            const r = e;
            this._currentRoomName = r.room, this._currentRoomViewId = r.viewId, this._currentRoomAllowEditing = r.allowEditing ?? !0, this._currentInRoom.length = 0, this._currentInRoom.push(...r.inRoom), (rh || L()) && console.debug("Joined Needle Engine Room: " + r.room);
            const a = new URL(window.location.href);
            a.searchParams.has("room") && a.searchParams.delete("room"), a.searchParams.set("view", this._currentRoomViewId), console.debug(`Room view id: ${this._currentRoomViewId}
${a.href}`);
          }
          this.onSendQueued(wn.OnRoomJoin);
          break;
        case "left-room":
          const n = e;
          n.room === this.currentRoomName && (this._isInRoom = !1, this._currentRoomName = null, this._currentRoomAllowEditing = !0, this._currentInRoom.length = 0, (rh || L()) && console.debug("Left Needle Engine Room: " + n.room));
          break;
        case "user-joined-room":
          if (e.data) {
            const r = e.data;
            this._currentInRoom.push(r.userId), ci && console.log(r.userId + " joined", "now in room:", this._currentInRoom);
          }
          break;
        case "user-left-room":
          if (e.data) {
            const r = e.data, a = this._currentInRoom.indexOf(r.userId);
            a >= 0 && (ci && console.log(r.userId + " left", "now in room:", this._currentInRoom), this._currentInRoom.splice(a, 1)), r.userId === this.connectionId && console.log("you left the room");
          }
          break;
        case "all-room-state-deleted":
          ci && console.log("RECEIVED all-room-state-deleted"), this._state = {};
          break;
        case "ping":
        case "pong":
          const o = e.data?.time;
          o && (this._currentDelay = this.context.time.time - o), ci && console.log(`Current latency: ${(this._currentDelay * 1e3).toFixed()} ms`, "Clients in room: " + this._currentInRoom?.length);
          break;
      }
    const t = e.data;
    t && (this._state[t.guid] = t);
    let i = this._listeners[e.key];
    if (i) {
      i = [...i];
      for (const n of i)
        try {
          n(e.data);
        } catch (o) {
          console.error('Error invoking callback for "' + e.key + '"', o);
        }
    }
  }
  toMessage(e, t) {
    return {
      key: e,
      data: t
    };
  }
  sendWithWebsocket(e, t, i = wn.OnRoomJoin) {
    if (!this._ws) {
      const o = this._waitingForSocket[i] || [];
      o.push(() => this.sendWithWebsocket(e, t, i)), this._waitingForSocket[i] = o;
      return;
    }
    const n = JSON.stringify(this.toMessage(e, t));
    ci && console.log(">>", e), this._ws.send(n);
  }
  onSendQueued(e) {
    const t = this._waitingForSocket[e];
    if (t) {
      for (const i of t)
        i();
      t.length = 0;
    }
  }
}
const ql = w("debugwebxr");
class ff {
  controllerStates = [];
  userId;
  context;
  userStateEvtName;
  constructor(e, t) {
    this.userId = e, this.context = t, this.userStateEvtName = "xr-sync-user-state-" + e, this.context.connection.beginListen(this.userStateEvtName, this.onReceivedControllerState);
  }
  dispose() {
    this.context.connection.stopListen(this.userStateEvtName, this.onReceivedControllerState);
  }
  onReceivedControllerState = (e) => {
    ql && console.log(`XRSync: Received change for ${this.userId}: ${e.type} ${e.handedness}; tracked=${e.isTracking}`);
    let t = !1;
    for (let i = 0; i < this.controllerStates.length; i++)
      if (this.controllerStates[i].index === e.index) {
        this.controllerStates[i] = e, t = !0;
        break;
      }
    t || this.controllerStates.push(e);
  };
  update(e) {
    if (this.context.connection.isConnected != !1) {
      for (let t = this.controllerStates.length - 1; t >= 0; t--) {
        const i = this.controllerStates[t];
        let n = !1;
        for (let o = 0; o < e.controllers.length; o++)
          e.controllers[o].index === i.index && (n = !0);
        n || (ql && console.log(`XRSync: ${i.type} ${i.handedness} removed`, i.index), this.controllerStates.splice(t, 1), this.sendControllerRemoved(i));
      }
      for (const t of e.controllers)
        this.updateControllerStates(t);
    }
  }
  onExitXR(e) {
    for (const t of this.controllerStates)
      this.sendControllerRemoved(t);
    this.controllerStates.length = 0;
  }
  sendControllerRemoved(e) {
    e.isTracking = !1, e.guid = "", this.context.connection.send(this.userStateEvtName, e), this.context.connection.sendDeleteRemoteState(e.guid);
  }
  updateControllerStates(e) {
    const t = this.controllerStates.find((i) => i.index === e.index);
    if (t) {
      let i = !1;
      i ||= t.isTracking != e.isTracking, i && (t.isTracking = e.isTracking, this.context.connection.send(this.userStateEvtName, t));
    } else {
      const i = {
        guid: this.userId + "-" + e.index,
        isTracking: e.isTracking,
        handedness: e.side,
        index: e.index,
        type: e.hand ? "hand" : "controller"
      };
      this.controllerStates.push(i), this.context.connection.send(this.userStateEvtName, i), ql && console.log(`XRSync: ${i.type} ${i.handedness} added`, i.index);
    }
  }
}
class $1 {
  hasState(e) {
    return e ? this._states.has(e) : !1;
  }
  /** Is the left controller or hand tracked */
  isTracking(e, t) {
    if (!e) return;
    const i = this._states.get(e);
    return i ? i.controllerStates.find((o) => o.handedness === t)?.isTracking || !1 : void 0;
  }
  /** Is it hand tracking or a controller */
  getDeviceType(e, t) {
    if (!e) return;
    const i = this._states.get(e);
    return i ? i.controllerStates.find((o) => o.handedness === t)?.type || "unknown" : void 0;
  }
  context;
  constructor(e) {
    this.context = e, this.context.connection.beginListen(te.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(te.LeftRoom, this.onLeftRoom), this.context.connection.beginListen(te.UserJoinedRoom, this.onOtherUserJoinedRoom), this.context.connection.beginListen(te.UserLeftRoom, this.onOtherUserLeftRoom);
  }
  destroy() {
    this.context.connection.stopListen(te.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(te.LeftRoom, this.onLeftRoom), this.context.connection.stopListen(te.UserJoinedRoom, this.onOtherUserJoinedRoom), this.context.connection.stopListen(te.UserLeftRoom, this.onOtherUserLeftRoom);
  }
  onJoinedRoom = () => {
    if (this.context.connection.connectionId) {
      this._states.has(this.context.connection.connectionId) || (ql && console.log("XRSync: Local user joined room", this.context.connection.connectionId), this._states.set(this.context.connection.connectionId, new ff(this.context.connection.connectionId, this.context)));
      for (const e of this.context.connection.usersInRoom())
        this._states.has(e) || this._states.set(e, new ff(e, this.context));
    }
  };
  onLeftRoom = () => {
    this.context.connection.connectionId && (this._states.has(this.context.connection.connectionId) || (this._states.get(this.context.connection.connectionId)?.dispose(), this._states.delete(this.context.connection.connectionId)));
  };
  onOtherUserJoinedRoom = (e) => {
    const t = e.userId;
    this._states.has(t) || (ql && console.log("XRSync: Remote user joined room", t), this._states.set(t, new ff(t, this.context)));
  };
  onOtherUserLeftRoom = (e) => {
    const t = e.userId;
    this._states.has(t) || (this._states.get(t)?.dispose(), this._states.delete(t));
  };
  _states = /* @__PURE__ */ new Map();
  onUpdate(e) {
    this.context.connection.isConnected && this.context.connection.connectionId && this._states.get(this.context.connection.connectionId)?.update(e);
  }
  onExitXR(e) {
    this.context.connection.isConnected && this.context.connection.connectionId && this._states.get(this.context.connection.connectionId)?.onExitXR(e);
  }
}
class $y {
  _fadeToColorQuad;
  _fadeToColorMaterial;
  constructor() {
    this._fadeToColorMaterial = new we({
      color: 0,
      transparent: !0,
      depthTest: !1,
      fog: !1,
      side: xi
    }), this._fadeToColorQuad = new G(new Nn(10, 10), this._fadeToColorMaterial);
  }
  dispose() {
    this._fadeToColorQuad.geometry.dispose(), this._fadeToColorMaterial.dispose();
  }
  update(e, t) {
    const i = this._fadeToColorQuad, n = this._fadeToColorMaterial;
    i.parent !== e && n.opacity > 0 ? e.add(i) : n.opacity === 0 && i.removeFromParent(), i.layers.set(2), i.material = this._fadeToColorMaterial, i.position.z = -1, i.renderOrder = 1 / 0;
    const o = this._requestedFadeValue;
    n.opacity = j.lerp(n.opacity, o, t / 0.03), Math.abs(n.opacity - o) <= 0.01 && this._transitionResolve && (this._transitionResolve(), this._transitionResolve = null, this._transitionPromise = null, this._requestedFadeValue = 0);
  }
  remove() {
    this._fadeToColorQuad.removeFromParent();
  }
  /** Call to fade rendering to black for a short moment (the returned promise will be resolved when fully black)   
   * This can be used to mask scene transitions or teleportation
   * @returns a promise that is resolved when the screen is fully black
   * @example `fadeTransition().then(() => { <fully_black> })`
  */
  fadeTransition() {
    if (this._transitionPromise) return this._transitionPromise;
    this._requestedFadeValue = 1;
    const e = new Promise((t) => {
      this._transitionResolve = t;
    });
    return this._transitionPromise = e, e;
  }
  _requestedFadeValue = 0;
  _transitionPromise = null;
  _transitionResolve = null;
}
var xa = /* @__PURE__ */ ((s) => (s[s.Quad = 0] = "Quad", s[s.Cube = 1] = "Cube", s[s.Sphere = 2] = "Sphere", s[s.Cylinder = 3] = "Cylinder", s[s.RoundedCube = 10] = "RoundedCube", s))(xa || {});
class La {
  /**
   * Creates a 3D text object
   * @param text The text to display
   * @param opts Options to create the object
   */
  static createText(e, t) {
    let i = null;
    const n = t?.font || V1(t?.familyFamily || null);
    n instanceof kS ? i = this.#t(e, n, t) : i == null && (i = new an());
    const o = t?.color || 16777215, r = new G(i, t?.material ?? new ut({ color: o }));
    return this.applyDefaultObjectOptions(r, t), n instanceof Promise ? n.then((a) => {
      r.geometry = this.#t(e, a, t), t?.onGeometry && t.onGeometry(r);
    }) : t?.onGeometry && t.onGeometry(r), r;
  }
  static #t(e, t, i) {
    const n = i?.depth || 0.1;
    return new MS(e, {
      font: t,
      size: 1,
      depth: n,
      height: n,
      bevelEnabled: i?.bevel || !1,
      bevelThickness: 0.01,
      bevelOffset: 0.01,
      bevelSize: 0.01
    });
  }
  /**
   * Creates an occluder object that only render depth but not color
   * @param type The type of primitive to create
   * @returns The created object
   */
  static createOccluder(e) {
    const t = new we({ colorWrite: !1, depthWrite: !0, side: xi });
    return this.createPrimitive(e, { material: t });
  }
  static createPrimitive(e, t) {
    let i;
    const n = t?.color || 16777215;
    switch (e) {
      case "Quad":
      case 0:
        {
          const o = new Nn(1, 1, 1, 1), r = t?.material ?? new ut({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new G(o, r), i.name = "Quad";
        }
        break;
      case "Cube":
      case 1:
        {
          const o = new pa(1, 1, 1), r = t?.material ?? new ut({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new G(o, r), i.name = "Cube";
        }
        break;
      case 10:
      case "RoundedCube":
        {
          const o = W1(1, 1, 1, 0.1, 2), r = t?.material ?? new ut({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new G(o, r), i.name = "RoundedCube";
        }
        break;
      case "Sphere":
      case 2:
        {
          const o = new Ud(0.5, 16, 16), r = t?.material ?? new ut({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new G(o, r), i.name = "Sphere";
        }
        break;
      case "Cylinder":
      case 3:
        {
          const o = new Pb(0.5, 0.5, 1, 32), r = t?.material ?? new ut({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new G(o, r), i.name = "Cylinder";
        }
        break;
      case "ShaderBall":
        i = new so(), i.name = "ShaderBall", H1(i, t);
        break;
    }
    return this.applyDefaultObjectOptions(i, t), i;
  }
  /**
   * Creates a Sprite object  
   * @param opts Options to create the object
   * @returns The created object
   */
  static createSprite(e) {
    const i = new cx({ color: 16777215 });
    e?.texture && "map" in i && (i.map = e.texture);
    const n = new hx(i);
    return this.applyDefaultObjectOptions(n, e), n;
  }
  static applyDefaultObjectOptions(e, t) {
    e.receiveShadow = !0, e.castShadow = !0, t?.name && (e.name = t.name), t?.position && (Array.isArray(t.position) ? e.position.set(t.position[0], t.position[1], t.position[2]) : e.position.set(t.position.x || 0, t.position.y || 0, t.position.z || 0)), t?.rotation && (Array.isArray(t.rotation) ? e.rotation.set(t.rotation[0], t.rotation[1], t.rotation[2]) : e.rotation.set(t.rotation.x || 0, t.rotation.y || 0, t.rotation.z || 0)), t?.scale && (typeof t.scale == "number" ? e.scale.set(t.scale, t.scale, t.scale) : Array.isArray(t.scale) ? e.scale.set(t.scale[0], t.scale[1], t.scale[2]) : e.scale.set(t.scale.x || 1, t.scale.y || 1, t.scale.z || 1)), t?.receiveShadow != null && (e.receiveShadow = t.receiveShadow), t?.castShadow != null && (e.castShadow = t.castShadow), t?.parent && t.parent.add(e);
  }
}
function W1(s, e, t, i, n) {
  const o = new dx(), r = 1e-5, a = i - r;
  o.absarc(r, r, r, -Math.PI / 2, -Math.PI, !0), o.absarc(r, e - a * 2, r, Math.PI, Math.PI / 2, !0), o.absarc(s - a * 2, e - a * 2, r, Math.PI / 2, 0, !0), o.absarc(s - a * 2, r, r, 0, -Math.PI / 2, !0);
  const l = new ux(o, {
    bevelEnabled: !0,
    bevelSegments: n * 2,
    steps: 1,
    bevelSize: a,
    bevelThickness: i,
    curveSegments: n,
    UVGenerator: {
      generateTopUV: (c, h) => {
        const d = [];
        for (let f = 0; f < h.length; f += 3)
          d.push(new J(h[f] / s, h[f + 1] / e));
        return d;
      },
      generateSideWallUV: (c, h, d, f, p, g) => {
        const b = [];
        return b.push(new J(h[d] / s, h[d + 1] / e)), b.push(new J(h[f] / s, h[f + 1] / e)), b.push(new J(h[p] / s, h[p + 1] / e)), b.push(new J(h[g] / s, h[g + 1] / e)), b;
      }
    }
  });
  return l.scale(1, 1, 1 - i), l.center(), l.index || l.setIndex(Array.from({ length: l.attributes.position.count }, (c, h) => h)), l.computeVertexNormals(), l;
}
const ah = /* @__PURE__ */ new Map();
function V1(s) {
  let e = "";
  switch (s) {
    default:
    case "OpenSans":
      e = "https://cdn.needle.tools/static/fonts/facetype/Open Sans_Regular_ascii.json";
      break;
    case "Helvetiker":
      e = "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json";
      break;
  }
  if (ah.has(e)) {
    const n = ah.get(e);
    if (n) return n;
  }
  const t = new RS(), i = new Promise((n, o) => {
    t.load(e, (r) => {
      ah.set(e, r), n(r);
    }, void 0, o);
  });
  return ah.set(e, i), i;
}
let pf = !1, mf = null;
function H1(s, e) {
  if (mf === null) {
    const t = "https://cdn.needle.tools/static/models/shaderball.glb", i = new Ps(), n = Mm(null);
    i.setDRACOLoader(n.dracoLoader), i.setKTX2Loader(n.ktx2Loader), pf = !0, mf = i.loadAsync(t).then((o) => {
      const r = o.scene;
      return r.position.y -= 0.5, r;
    }).catch((o) => (console.warn("Failed to load shaderball mesh: " + o.message), Vy())).finally(() => {
      pf = !1;
    });
  }
  if (pf) {
    const t = Vy();
    t.name = "ShaderBall-Placeholder";
    const i = t.children[0];
    i?.type === "Mesh" && Wy(i, e), s.add(t);
  }
  mf.then((t) => {
    s.children.forEach((o) => {
      o.name === "ShaderBall-Placeholder" && s.remove(o);
    });
    const i = t.clone(), n = i.children[0];
    n?.type === "Mesh" && (n.geometry.attributes.tangent || n.geometry.computeTangents(), Wy(n, e)), s.add(i);
  });
}
function Wy(s, e) {
  if (e?.color || e?.material || e?.texture) {
    const i = e?.material ?? s.material?.clone() ?? new ut();
    e.color && "color" in i && i.color instanceof se && i.color.set(e.color), e?.texture && "map" in i && (i.map = e.texture), s.material = i;
  }
}
function Vy() {
  return new so().add(La.createPrimitive("Sphere", { material: new we({ transparent: !0, opacity: 0.1 }) }));
}
class Sa {
  static _active = null;
  static get active() {
    return this._active;
  }
  static _requestInFlight = !1;
  static async start(e, t) {
    if (this._active)
      return console.error("Cannot start a new XR session while one is already active"), null;
    if (this._requestInFlight)
      return console.error("Cannot start a new XR session while a request is already in flight"), null;
    if ("xr" in navigator && navigator.xr) {
      if (!t)
        return console.error("XRSessionInit must be provided"), null;
      this._requestInFlight = !0;
      const i = await navigator.xr.requestSession(e, t);
      return i.addEventListener("end", () => {
        this._active = null;
      }), this._requestInFlight ? (this._requestInFlight = !1, this._active = new Sa(e, t, i), this._active) : (i.end(), null);
    }
    return null;
  }
  static async handoff() {
    return this._active ? this._active.handoff() : null;
  }
  static async stop() {
    this._requestInFlight = !1, this._active && (await this._active.end(), await Os(100)), this._active = null;
  }
  _session;
  _mode;
  _init;
  get isAR() {
    return this._mode === "immersive-ar";
  }
  _renderer;
  _camera;
  _scene;
  constructor(e, t, i) {
    this._mode = e, this._init = t, this._session = i, this._session.addEventListener("end", this.onEnd), this._renderer = new mr({ alpha: !0 }), this._renderer.setAnimationLoop(this.onFrame), this._renderer.xr.setSession(i), this._renderer.xr.enabled = !0, this._camera = new de(), this._scene = new wi(), this._scene.fog = new Ob(4473924, 10, 250), this._scene.add(this._camera), this.setupScene();
  }
  end() {
    return this._session ? this._session.end() : Promise.resolve();
  }
  /** returns the session and session info and stops the temporary rendering */
  async handoff() {
    if (!this._session) throw new Error("Cannot handoff a session that has already ended");
    const e = {
      session: this._session,
      mode: this._mode,
      init: this._init
    };
    return await this.onBeforeHandoff(), this.onEnd(), this._session = null, e;
  }
  onEnd = () => {
    this._session?.removeEventListener("end", this.onEnd), this._renderer.setAnimationLoop(null), this._renderer.dispose(), this._scene.clear();
  };
  _lastTime = 0;
  onFrame = (e, t) => {
    const i = e - this._lastTime;
    this.update(e, i), this._camera.parent !== this._scene && this._scene.add(this._camera), this._renderer.render(this._scene, this._camera);
  };
  /** can be used to prepare the user or fade to black */
  async onBeforeHandoff() {
    await Os(1e3), this._scene.clear();
  }
  _objects = [];
  setupScene() {
    this._scene.background = new se(0), this._scene.add(new bm(5, 10, 1118481, 1118481));
    const e = new fp(16777215, 1);
    e.position.set(0, 20, 0), e.castShadow = !1, this._scene.add(e);
    const t = new fp(16777215, 1);
    t.position.set(0, -1, 0), t.castShadow = !1, this._scene.add(t);
    const i = new vm(16777215, 1, 100, 1);
    i.position.set(0, 2, 0), i.castShadow = !1, i.distance = 200, this._scene.add(i);
    const n = 50;
    for (let o = 0; o < 100; o++) {
      const r = new ut({
        color: 2236962,
        metalness: 1,
        roughness: 0.8
      });
      this.isAR && (r.emissive = new se(Math.random(), Math.random(), Math.random()), r.emissiveIntensity = Math.random());
      const a = j.random(0, 1) > 0.5 ? xa.Sphere : xa.Cube, l = La.createPrimitive(a, {
        material: r
      });
      l.position.x = j.random(-n, n), l.position.y = j.random(-2, n), l.position.z = j.random(-n, n), l.rotation.x = j.random(0, Math.PI * 2), l.rotation.y = j.random(0, Math.PI * 2), l.rotation.z = j.random(0, Math.PI * 2), l.scale.multiplyScalar(0.5 + Math.random() * 10);
      const c = l.position.distanceTo(this._camera.position) - l.scale.x;
      c < 1 && l.position.multiplyScalar(1 + 1 / c), this._objects.push(l), this._scene.add(l);
    }
  }
  update(e, t) {
    const i = e * 4e-4;
    for (let n = 0; n < this._objects.length; n++) {
      const o = this._objects[n];
      o.position.y += Math.sin(i + n * 0.5) * 5e-3, o.rotateY(2e-3);
    }
  }
}
var dc;
((s) => {
  const e = [];
  function t() {
    if (!e?.length) return !1;
    for (const o of e)
      o.exportAndOpen();
    return !0;
  }
  s.exportAndOpen = t;
  function i(o) {
    e.push(o);
  }
  s.registerExporter = i;
  function n(o) {
    if (!e) return;
    const r = e.indexOf(o);
    r >= 0 && e.splice(r, 1);
  }
  s.unregisterExporter = n;
})(dc || (dc = {}));
const $e = w("debugwebxr"), Hy = w("stats");
let gf = 0;
function G1(s) {
  let e = null;
  const t = s;
  return t.getAROverlayContainer ? e = t.getAROverlayContainer() : e = s, e;
}
q1();
async function q1() {
  if (w("debugasap")) {
    let s = globalThis["needle:XRSession"];
    if (s instanceof Promise) {
      delete globalThis["needle:XRSession"], ue.addContextCreatedCallback(async (e) => {
        if (!s) return;
        ia(!0);
        const t = await s;
        if (t) {
          const i = K.getDefaultSessionInit("immersive-vr");
          K.setSession("immersive-vr", t, i, e.context);
        } else
          console.error("NeedleXRSession: ASAP session was rejected");
        s = void 0;
      });
      return;
    }
  }
  if ("xr" in navigator) {
    if (/WebXRViewer\//i.test(navigator.userAgent)) {
      console.warn("WebXRViewer does not support addEventListener");
      return;
    }
    navigator.xr?.addEventListener("sessiongranted", async () => {
      ia(!0), console.log("Received Session Granted..."), await Os(100);
      const s = sessionStorage.getItem("needle_xr_session_mode"), e = sessionStorage.getItem("needle_xr_session_init") ?? null, t = e ? JSON.parse(e) : null;
      let i = null;
      if (v0() && (await Sa.start(s || "immersive-vr", t || K.getDefaultSessionInit("immersive-vr")), await Y1(), i = await Sa.handoff()), i)
        K.setSession(i.mode, i.session, i.init, N.Current);
      else if (s && e) {
        console.log("Session Granted: Restore last session");
        const n = JSON.parse(e);
        K.start(s, n).catch((o) => console.warn(o));
      } else
        K.start("immersive-vr").catch((n) => console.warn("Session Granted failed:", n));
    }, { once: !0 });
  }
}
function X1(s, e) {
  sessionStorage.setItem("needle_xr_session_mode", s), sessionStorage.setItem("needle_xr_session_init", JSON.stringify(e));
}
function Q1() {
  sessionStorage.removeItem("needle_xr_session_mode"), sessionStorage.removeItem("needle_xr_session_init");
}
const $m = /* @__PURE__ */ new Set();
ue.registerCallback(he.ContextCreationStart, async (s) => {
  $m.add(s.context);
});
ue.registerCallback(he.ContextCreated, async (s) => {
  $m.delete(s.context);
  const e = s.context?.domElement.getAttribute("autostart") || null;
  K1(e);
});
function v0() {
  return $m.size > 0;
}
function Y1() {
  return new Promise((s) => {
    const e = Date.now(), t = setInterval(() => {
      (!v0() || Date.now() - e > 6e4) && (clearInterval(t), s());
    }, 100);
  });
}
q.isDesktop() && L() && window.addEventListener("keydown", (s) => {
  (s.key === "x" || s.key === "Escape") && K.active && K.stop();
});
function K1(s) {
  if (s)
    switch (s?.toLowerCase()) {
      case "ar":
        Fn.registerWaitForInteraction(() => {
          K.start("ar");
        });
        break;
    }
}
const lh = Symbol("initial-fov");
class K {
  static _sync = null;
  static getXRSync(e) {
    return this._sync || (this._sync = new $1(e)), this._sync;
  }
  static get currentSessionRequest() {
    return this._currentSessionRequestMode;
  }
  static _currentSessionRequestMode = null;
  /**
   * @returns the active @type {NeedleXRSession} (if any active) or null
   */
  static get active() {
    return this._activeSession;
  }
  /** The active xr session mode (if any xr session is active) 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSessionMode
  */
  static get activeMode() {
    return this._activeSession?.mode ?? null;
  }
  /** XRSystem via navigator.xr access
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem
   */
  static get xrSystem() {
    return "xr" in navigator ? navigator.xr : void 0;
  }
  /**
   * @returns true if the browser supports WebXR (`immersive-vr` or `immersive-ar`)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
   */
  static isXRSupported() {
    return Promise.all([this.isVRSupported(), this.isARSupported()]).then((e) => e.some((t) => t)).catch(() => !1);
  }
  /** 
   * @returns true if the browser supports immersive-vr (WebXR)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
   */
  static isVRSupported() {
    return this.isSessionSupported("immersive-vr");
  }
  /** 
   * @returns true if the browser supports immersive-ar (WebXR) 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
  */
  static isARSupported() {
    return this.isSessionSupported("immersive-ar");
  }
  /**
   * @param mode The XRSessionMode to check if it is supported
   * @returns true if the browser supports the given XRSessionMode
   */
  static isSessionSupported(e) {
    return this.xrSystem?.isSessionSupported(e).catch((t) => ($e && console.error(t), !1)) ?? Promise.resolve(!1);
  }
  static _currentSessionRequest;
  static _activeSession;
  /** Register to listen to XRSession start events. Unsubscribe with `offXRSessionStart` */
  static onSessionRequestStart(e) {
    this._sessionRequestStartListeners.push(e);
  }
  /** Unsubscribe from request start evt. Register with `onSessionRequestStart` */
  static offSessionRequestStart(e) {
    const t = this._sessionRequestStartListeners.indexOf(e);
    t >= 0 && this._sessionRequestStartListeners.splice(t, 1);
  }
  static _sessionRequestStartListeners = [];
  /** Called after the session request has finished */
  static onSessionRequestEnd(e) {
    this._sessionRequestEndListeners.push(e);
  }
  /** Unsubscribe from request end evt */
  static offSessionRequestEnd(e) {
    const t = this._sessionRequestEndListeners.indexOf(e);
    t >= 0 && this._sessionRequestEndListeners.splice(t, 1);
  }
  static _sessionRequestEndListeners = [];
  /** Listen to XR session started. Unsubscribe with `offXRSessionStart` */
  static onXRSessionStart(e) {
    this._xrStartListeners.push(e);
  }
  /** Unsubscribe from XRSession started events */
  static offXRSessionStart(e) {
    const t = this._xrStartListeners.indexOf(e);
    t >= 0 && this._xrStartListeners.splice(t, 1);
  }
  static _xrStartListeners = [];
  /** Listen to XR session ended. Unsubscribe with `offXRSessionEnd` */
  static onXRSessionEnd(e) {
    this._xrEndListeners.push(e);
  }
  /** Unsubscribe from XRSession started events */
  static offXRSessionEnd(e) {
    const t = this._xrEndListeners.indexOf(e);
    t >= 0 && this._xrEndListeners.splice(t, 1);
  }
  static _xrEndListeners = [];
  /** Listen to controller added events. 
   * Events are cleared when starting a new session 
   **/
  static onControllerAdded(e) {
    this._controllerAddedListeners.push(e);
  }
  /** Unsubscribe from controller added evts */
  static offControllerAdded(e) {
    const t = this._controllerAddedListeners.indexOf(e);
    t >= 0 && this._controllerAddedListeners.splice(t, 1);
  }
  static _controllerAddedListeners = [];
  /** Listen to controller removed events 
   * Events are cleared when starting a new session 
   **/
  static onControllerRemoved(e) {
    this._controllerRemovedListeners.push(e);
  }
  /** Unsubscribe from controller removed events */
  static offControllerRemoved(e) {
    const t = this._controllerRemovedListeners.indexOf(e);
    t >= 0 && this._controllerRemovedListeners.splice(t, 1);
  }
  static _controllerRemovedListeners = [];
  /** If the browser supports offerSession - creating a VR or AR button in the browser navigation bar */
  static offerSession(e, t, i) {
    return "xr" in navigator && navigator.xr && "offerSession" in navigator.xr ? (typeof navigator.xr.offerSession == "function" && (console.log("WebXR offerSession is available - requesting mode: " + e), t == "default" && (t = this.getDefaultSessionInit(e)), navigator.xr.offerSession(e, {
      ...t
    }).then((n) => K.setSession(e, n, t, i)).catch((n) => {
      console.log("XRSession offer rejected (perhaps because another call to offerSession was made or a call to requestSession was made)");
    })), !0) : !1;
  }
  /** @returns a new XRSession init object with defaults */
  static getDefaultSessionInit(e) {
    switch (e) {
      case "immersive-ar":
        const t = ["anchors", "local-floor", "layers", "dom-overlay", "hit-test", "unbounded"];
        return q.isVisionOS() || t.push("hand-tracking"), {
          optionalFeatures: t
        };
      case "immersive-vr":
        const i = ["local-floor", "bounded-floor", "high-fixed-foveation-level", "layers"];
        return q.isVisionOS() || i.push("hand-tracking"), {
          optionalFeatures: i
        };
      default:
        return console.warn("No default session init for mode", e), {};
    }
  }
  /** start a new webXR session (make sure to stop already running sessions before calling this method)
   * @param mode The XRSessionMode to start (e.g. `immersive-vr` or `immersive-ar`) or `ar` to start `immersive-ar` on supported devices OR on iOS devices it will export an interactive USDZ and open in Quicklook.  
   * Get more information about WebXR modes: https://developer.mozilla.org/en-US/docs/Web/API/XRSessionMode
   * @param init The XRSessionInit to use (optional), docs: https://developer.mozilla.org/en-US/docs/Web/API/XRSessionInit
   * @param context The Needle Engine context to use
   */
  static async start(e, t, i) {
    if (q.isiOS()) {
      if (e === "ar")
        if (await this.isARSupported())
          e = "immersive-ar";
        else
          return dc.exportAndOpen(), null;
    } else e == "ar" && (e = "immersive-ar");
    if (L() && w("debugxrpreroom"))
      return console.warn("Debug: Starting temporary XR session"), await Sa.start(e, t || K.getDefaultSessionInit(e)), null;
    if (this._currentSessionRequest)
      return console.warn("A XRSession is already being requested"), ($e || L()) && ge("A XRSession is already being requested"), this._currentSessionRequest.then(() => this._activeSession);
    if (this._activeSession)
      return console.error("A XRSession is already running"), this._activeSession;
    if (i || (i = N.Current), i || (i = ue.All[0]), !i) throw new Error("No Needle Engine Context found");
    switch (t || (t = {}), e) {
      // Setup VR initialization parameters
      case "immersive-ar":
        {
          if (await this.xrSystem?.isSessionSupported("immersive-ar") !== !0)
            return console.error(e + " is not supported by this browser."), null;
          const l = this.getDefaultSessionInit(e), c = G1(i.domElement);
          c && !q.isQuest() && (l.domOverlay = { root: c }, l.optionalFeatures.push("dom-overlay")), t = {
            ...l,
            ...t
          };
        }
        break;
      // Setup AR initialization parameters
      case "immersive-vr":
        {
          if (await this.xrSystem?.isSessionSupported("immersive-vr") !== !0)
            return console.error(e + " is not supported by this browser."), null;
          t = {
            ...this.getDefaultSessionInit(e),
            ...t
          };
        }
        break;
      default:
        console.warn("No default session init for mode", e);
        break;
    }
    t.optionalFeatures ??= [], t.requiredFeatures ??= [], await Sa.stop();
    const n = e == "immersive-ar" ? i.scripts_immersive_ar : i.scripts_immersive_vr;
    $e ? console.log(`%cRequesting ${e} session`, "font-weight:bold;", t, n) : console.log(`%cRequesting ${e} session`, "font-weight:bold;");
    for (const a of n)
      a.onBeforeXR && a.onBeforeXR(e, t);
    for (const a of this._sessionRequestStartListeners)
      a({ mode: e, init: t });
    $e && Be("Requesting " + e + " session (" + Date.now() + ")"), this._currentSessionRequest = navigator?.xr?.requestSession(e, t), this._currentSessionRequestMode = e;
    const o = await this._currentSessionRequest?.catch((a) => {
      console.error(a, "Code: " + a.code), a.code === 9 && ge("Make sure your device has the required permissions (e.g. camera access)"), console.log("If the specified XR configuration is not supported (e.g. entering AR doesnt work) - make sure you access the website on a secure connection (HTTPS) and your device has the required permissions (e.g. camera access)"), location.protocol === "http:" && ge("XR requires a secure connection (HTTPS)");
    });
    this._currentSessionRequest = void 0, this._currentSessionRequestMode = null;
    for (const a of this._sessionRequestEndListeners)
      a({ mode: e, init: t, newSession: o || null });
    return o ? this.setSession(e, o, t, i) : (console.warn("XR Session request was rejected"), null);
  }
  static setSession(e, t, i, n) {
    if (this._activeSession)
      return console.error("A XRSession is already running"), this._activeSession;
    const o = e == "immersive-ar" ? n.scripts_immersive_ar : n.scripts_immersive_vr;
    return this._activeSession = new K(e, t, n, {
      scripts: o,
      controller_added: this._controllerAddedListeners,
      controller_removed: this._controllerRemovedListeners,
      init: i
    }), t.addEventListener("end", this.onEnd), $e ? console.log(`%cStarted ${e} session`, "font-weight:bold;", o) : console.log(`%cStarted ${e} session`, "font-weight:bold;"), this._activeSession;
  }
  static $_stop_request = Symbol();
  /** stops the active XR session */
  static stop() {
    const e = this._activeSession;
    e && (e[this.$_stop_request] === void 0 ? ($e && console.log("[NeedleXRSession] Stopping XR Session... (new)"), e[this.$_stop_request] = setTimeout(() => {
      e.end();
    })) : $e && console.warn("[NeedleXRSession] XR Session stop already requested"));
  }
  static onEnd = () => {
    $e && console.log("XR Session ended"), this._activeSession = null;
  };
  /** The needle engine context this session was started from */
  context;
  get sync() {
    return K._sync;
  }
  /** Returns true if the xr session is still active */
  get running() {
    return !this._ended && this.session != null;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession
   */
  session;
  /** XR Session Mode: AR or VR */
  mode;
  /** 
   * The XRSession interface's read-only interactionMode property describes the best space (according to the user agent) for the application to draw an interactive UI for the current session.
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/interactionMode 
   */
  get interactionMode() {
    return this.session.interactionMode;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/visibilityState
   * @returns {XRVisibilityState} The visibility state of the XRSession
   */
  get visibilityState() {
    return this.session.visibilityState;
  }
  /**
   * Check if the session is `visible-blurred` - this means e.g. the keyboard is shown
   */
  get isVisibleBlurred() {
    return this.session.visibilityState === "visible-blurred";
  }
  /**
   * Check if the session has system keyboard support
   */
  get isSystemKeyboardSupported() {
    return this.session.isSystemKeyboardSupported;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/environmentBlendMode
   */
  get environmentBlendMode() {
    return this.session.environmentBlendMode;
  }
  /** 
   * The current XR frame 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRFrame
   */
  get frame() {
    return this.context.xrFrame;
  }
  /** The currently active/connected controllers */
  controllers = [];
  /** shorthand to query the left controller. Use `controllers` to get access to all connected controllers */
  get leftController() {
    return this.controllers.find((e) => e.side === "left");
  }
  /** shorthand to query the right controller. Use `controllers` to get access to all connected controllers */
  get rightController() {
    return this.controllers.find((e) => e.side === "right");
  }
  /** @returns the given controller if it is connected */
  getController(e) {
    return typeof e == "number" ? this.controllers[e] || null : this.controllers.find((t) => t.side === e) || null;
  }
  /** Returns true if running in pass through mode in immersive AR (e.g. user is wearing a headset while in AR) */
  get isPassThrough() {
    return !!(this.environmentBlendMode !== "opaque" && this.interactionMode === "world-space" || this.mode === "immersive-ar" && this.environmentBlendMode !== "opaque" && this.controllers.some((e) => e.inputSource.targetRayMode === "tracked-pointer") || L() && q.isDesktop() && this.mode === "immersive-ar");
  }
  get isAR() {
    return this.mode === "immersive-ar";
  }
  get isVR() {
    return this.mode === "immersive-vr";
  }
  /** If the AR mode is not immersive (meaning the user is e.g. holding a phone instead of wearing a AR passthrough headset) */
  get isScreenBasedAR() {
    return this.isAR && !this.isPassThrough;
  }
  get posePosition() {
    return this._transformPosition;
  }
  get poseOrientation() {
    return this._transformOrientation;
  }
  /** @returns the context.renderer.xr.getReferenceSpace() result */
  get referenceSpace() {
    return this.context.renderer.xr.getReferenceSpace();
  }
  /** @returns the XRFrame `viewerpose` using the xr `referenceSpace` */
  get viewerPose() {
    return this._viewerPose;
  }
  /** @returns `true` if any image is currently being tracked */
  /** returns true if images are currently being tracked */
  get isTrackingImages() {
    if (this.frame && "getImageTrackingResults" in this.frame && typeof this.frame.getImageTrackingResults == "function")
      try {
        const e = this.frame.getImageTrackingResults();
        for (const t of e)
          if (t.trackingState === "tracked") return !0;
      } catch {
        return !1;
      }
    return !1;
  }
  /** The currently active XR rig */
  get rig() {
    const e = this._rigs[0] ?? null;
    return e?.gameObject && Pa(e.gameObject) || e?.isActive === !1 ? (this.updateActiveXRRig(), this._rigs[0] ?? null) : e;
  }
  _rigScale = 1;
  _lastRigScaleUpdate = -1;
  /** Get the XR Rig worldscale.   
   * 
   * **For AR**   
   * If you want to modify the scale in AR at runtime get the WebARSessionRoot component via `findObjectOfType(WebARSessionRoot)` and then set the `arScale` value. 
   * 
  */
  get rigScale() {
    return this._rigs[0] ? (this._lastRigScaleUpdate !== this.context.time.frame && (this._lastRigScaleUpdate = this.context.time.frame, this._rigScale = this._rigs[0].gameObject.worldScale.x), this._rigScale) : 1;
  }
  /** add a rig to the available XR rigs - if it's priority is higher than the currently active rig it will be enabled */
  addRig(e) {
    this._rigs.indexOf(e) >= 0 || (e.priority === void 0 && (e.priority = 0), this._rigs.push(e), this.updateActiveXRRig());
  }
  /** Remove a rig from the available XR Rigs */
  removeRig(e) {
    const t = this._rigs.indexOf(e);
    t !== -1 && (this._rigs.splice(t, 1), this.updateActiveXRRig());
  }
  /** Sets a XRRig to be active which will parent the camera to this rig */
  setRigActive(e) {
    const t = this._rigs.indexOf(e), i = this._rigs[0];
    this._rigs.splice(t, 1), this._rigs.unshift(e), e.priority = i?.priority ?? 0, this.updateActiveXRRig();
  }
  /**
   * @returns the user position in the rig space
   */
  getUserOffsetInRig() {
    const e = this.context.mainCamera?.position;
    if (!e || !this.rig) return H(0, 0, 0);
    const t = H(e);
    return t.x *= -1, t.z *= -1, t.applyQuaternion(ui(this.rig.gameObject.quaternion)), t;
  }
  updateActiveXRRig() {
    const e = this._rigs[0] ?? null;
    this._defaultRig.gameObject.parent !== this.context.scene && this.context.scene.add(this._defaultRig.gameObject), this._defaultRig.gameObject.visible = !0, this._rigs.includes(this._defaultRig) || this._rigs.push(this._defaultRig);
    let t = this._rigs[0];
    t && t.priority === void 0 && (t.priority = 0);
    for (let i = 1; i < this._rigs.length; i++) {
      const n = this._rigs[i];
      if (n.isActive) {
        if (Pa(n.gameObject)) {
          this._rigs.splice(i, 1), i--;
          continue;
        }
        (!t || t.isActive === !1 || n.priority !== void 0 && n.priority > t.priority) && (t = n);
      }
    }
    if (e !== t) {
      const i = this._rigs.indexOf(t);
      i >= 0 && this._rigs.splice(i, 1), this._rigs.unshift(t);
    }
    $e && (e === t ? console.log("Updated Active XR Rig:", t, "prev:", e) : console.log("Updated Active XRRig:", t, " (the same as before)"));
  }
  _rigs = [];
  _viewerHitTestSource = null;
  /** Returns a XR hit test result (if hit-testing is available) in rig space   
   * @param source If provided, the hit test will be performed for the given controller
  */
  getHitTest(e) {
    if (e)
      return this.getControllerHitTest(e);
    if (!this._viewerHitTestSource) return null;
    const t = this._viewerHitTestSource, i = this.frame.getHitTestResults(t);
    if (i.length > 0) {
      const n = i[0];
      return this.convertHitTestResult(n);
    }
    return null;
  }
  getControllerHitTest(e) {
    const t = e.getHitTestSource();
    if (!t) return null;
    const i = this.frame.getHitTestResultsForTransientInput(t);
    for (const n of i)
      if (n.inputSource === e.inputSource)
        for (const o of n.results)
          return this.convertHitTestResult(o);
    return null;
  }
  convertHitTestResult(e) {
    const t = this.context.renderer.xr.getReferenceSpace(), i = t && e.getPose(t);
    if (i) {
      const n = H(i.transform.position), o = ui(i.transform.orientation), r = this.context.mainCamera;
      if (r?.parent !== this._cameraRenderParent && n.applyMatrix4(na), r?.parent) {
        n.applyMatrix4(r.parent.matrixWorld), o.multiply(zi);
        const a = be(r.parent);
        a.premultiply(zi), o.premultiply(a);
      }
      return { hit: e, position: n, quaternion: o };
    }
    return null;
  }
  /** convert a XRRigidTransform from XR session space to threejs / Needle Engine XR space */
  convertSpace(e) {
    const t = H(e.position);
    t.applyMatrix4(na);
    const i = ui(e.orientation);
    return i.premultiply(zi), { position: t, quaternion: i };
  }
  /** this is the implictly created XR rig */
  _defaultRig;
  /** all scripts that receive some sort of XR update event */
  _xr_scripts;
  /** scripts that have onUpdateXR event methods */
  _xr_update_scripts = [];
  /** scripts that are in the scene but inactive (e.g. disabled parent gameObject) */
  _inactive_scripts = [];
  _controllerAdded;
  _controllerRemoved;
  _originalCameraWorldPosition;
  _originalCameraWorldRotation;
  _originalCameraWorldScale;
  _originalCameraParent;
  /** we store the main camera reference here each frame to make sure we have a rendering camera
   * this e.g. the case when the XR rig with the camera gets disabled (and thus this.context.mainCamera is unassigned)
   */
  _mainCamera = null;
  constructor(e, t, i, n) {
    X1(e, n.init), this.session = t, this.mode = e, this.context = i, ($e || w("console")) && ia(!0), this._xr_scripts = [...n.scripts], this._xr_update_scripts = this._xr_scripts.filter((o) => typeof o.onUpdateXR == "function"), this._controllerAdded = n.controller_added, this._controllerRemoved = n.controller_removed, Ms(this.onBefore, xe.LateUpdate), this.context.pre_render_callbacks.push(this.onBeforeRender), this.context.post_render_callbacks.push(this.onAfterRender), (n.init.optionalFeatures?.includes("hit-test") || n.init.requiredFeatures?.includes("hit-test")) && t.requestReferenceSpace("viewer").then((o) => t.requestHitTestSource?.call(t, { space: o })?.then((r) => this._viewerHitTestSource = r).catch((r) => console.error(r))).catch((o) => console.error(o)), this.context.mainCamera && (this._originalCameraWorldPosition = Z(this.context.mainCamera, new y()), this._originalCameraWorldRotation = be(this.context.mainCamera, new U()), this._originalCameraWorldScale = Qe(this.context.mainCamera, new y()), this._originalCameraParent = this.context.mainCamera.parent, this.context.mainCamera instanceof de && (this.context.mainCamera[lh] = this.context.mainCamera.fov)), this._defaultRig = new M1(), this.context.scene.add(this._defaultRig.gameObject), this.addRig(this._defaultRig);
    for (let o = 0; o < t.inputSources.length; o++) {
      const r = t.inputSources[o];
      if (!r.handedness) {
        console.warn("Input source in xr session has no handedness - ignoring", o);
        continue;
      }
      this.onInputSourceAdded(r);
    }
    this.session.addEventListener("end", this.onEnd), this.session.addEventListener(
      "inputsourceschange",
      /* @ts-ignore (ignore CI XRInputSourceChangeEvent mismatch) */
      (o) => {
        for (const r of o.removed)
          this.disconnectInputSource(r);
        for (const r of o.added)
          this.onInputSourceAdded(r);
      }
    ), this.context.xr = this, this.context.renderer.xr.setSession(this.session).then(this.onRendererSessionSet), "controllerAutoUpdate" in this.context.renderer.xr ? (console.debug("Disabling three.js controllerAutoUpdate"), this.context.renderer.xr.controllerAutoUpdate = !1) : $e && console.warn("controllerAutoUpdate is not available in three.js - cannot disable it");
  }
  /** called when renderer.setSession is fulfilled */
  onRendererSessionSet = () => {
    this.running && (this.context.renderer.xr.enabled = !0, this.context.renderer.xr.updateCamera(this.context.mainCamera), this.context.mainCameraComponent?.applyClearFlags());
  };
  onInputSourceAdded = (e) => {
    if (e.targetRayMode === "screen")
      return;
    let t = 0;
    for (let n = 0; n < this.session.inputSources.length; n++)
      if (this.session.inputSources[n] === e) {
        t = n;
        break;
      }
    if (this.controllers.find((n) => n.inputSource === e)) {
      console.debug("Controller already exists for input source", t);
      return;
    } else if (this._newControllers.find((n) => n.inputSource === e)) {
      console.debug("Controller already registered for input source", t);
      return;
    }
    const i = new m0(this, e, t);
    this._newControllers.push(i);
  };
  /** Disconnects the controller, invokes events and notifies previou controller (if any) */
  disconnectInputSource(e) {
    const t = (o, r) => {
      if (o.inputSource === e) {
        $e && console.log("Disconnecting controller", o.index);
        const a = r.indexOf(o);
        a >= 0 && r.splice(a, 1), this.invokeControllerEvent(o, this._controllerRemoved, "removed");
        const l = {
          xr: this,
          controller: o,
          change: "removed"
        };
        for (const c of this._xr_scripts)
          c.onXRControllerRemoved && c.onXRControllerRemoved(l);
        o.onDisconnected();
      }
    }, i = [...this.controllers];
    for (let o = i.length - 1; o >= 0; o--) {
      const r = i[o];
      t(r, this.controllers);
    }
    const n = [...this._newControllers];
    for (let o = n.length - 1; o >= 0; o--) {
      const r = n[o];
      t(r, this._newControllers);
    }
  }
  /** End the XR Session */
  end() {
    this._ended || this.session.end().catch((e) => console.warn(e));
  }
  _ended = !1;
  _newControllers = [];
  onEnd = (e) => {
    if (this._ended) return;
    this._ended = !0, console.debug("XR Session ended"), Q1(), this.onAfterRender(), this.revertCustomForward(), this._didStart = !1, this._previousCameraParent = null, this.requestedCameraNearPlane = null, yo(this.onBefore, xe.LateUpdate);
    const t = this.context.pre_render_callbacks.indexOf(this.onBeforeRender);
    t >= 0 && this.context.pre_render_callbacks.splice(t, 1);
    const i = this.context.post_render_callbacks.indexOf(this.onAfterRender);
    i >= 0 && this.context.post_render_callbacks.splice(i, 1), this.context.xr = null, this.context.renderer.xr.enabled = !1, this.context.pre_update_oneshot_callbacks.push(() => {
      this.context.mainCameraComponent?.applyClearFlags(), this.context.mainCameraComponent?.applyClippingPlane();
    }), P1({ session: this });
    for (const o of K._xrEndListeners)
      o({ xr: this });
    const n = [...this.controllers];
    for (let o = 0; o < n.length; o++)
      this.disconnectInputSource(n[o].inputSource);
    this.controllers.length = 0, this._newControllers.length = 0;
    for (const o of this._xr_scripts)
      o?.onLeaveXR?.({ xr: this });
    this.sync?.onExitXR(this), this.context.mainCamera && (this._originalCameraParent?.add(this.context.mainCamera), this._originalCameraWorldPosition && Ot(this.context.mainCamera, this._originalCameraWorldPosition), this._originalCameraWorldRotation && jn(this.context.mainCamera, this._originalCameraWorldRotation), this._originalCameraWorldScale && hc(this.context.mainCamera, this._originalCameraWorldScale), this.context.mainCamera instanceof de && this.context.mainCamera[lh] && (this.context.mainCamera.fov = this.context.mainCamera[lh], this.context.mainCamera[lh] = 0)), this.context.requestSizeUpdate(), this._defaultRig.gameObject.removeFromParent(), ia(!1);
  };
  _didStart = !1;
  /** Called every frame by the engine */
  onBefore = (e) => {
    const t = e.xrFrame;
    if (!t) return;
    this.context.xr = this, this.context.mainCameraComponent && this.context.mainCameraComponent !== this._mainCamera && (this._mainCamera = this.context.mainCameraComponent), this.rig?.isActive == !1 && ($e && console.warn("Latest rig is not active - trying to activate a different rig", this.rig), this.updateActiveXRRig()), this.rig && this._mainCamera?.gameObject && this._mainCamera?.gameObject?.parent !== this.rig.gameObject && this.rig.gameObject.add(this._mainCamera?.gameObject), this.internalUpdateState(), this.applyCustomForward();
    const i = { xr: this };
    if (this._didStart) {
      if (this.context.new_scripts_xr.length > 0) {
        const n = [...this.context.new_scripts_xr];
        for (let o = 0; o < n.length; o++) {
          const r = this.context.new_scripts_xr[o];
          if (!r || r.destroyed || r.supportsXR?.(this.mode) == !1) {
            this.context.new_scripts_xr.splice(o, 1);
            continue;
          }
          if (!r.activeAndEnabled) {
            this.context.new_scripts_xr.splice(o, 1), this.markInactive(r);
            continue;
          }
          if (this.addScript(r)) {
            this.invokeCallback_EnterXR(r);
            for (const a of this.controllers)
              this.invokeCallback_ControllerAdded(r, a);
          }
        }
      }
    } else {
      if (this._didStart = !0, this.mode === "immersive-vr") {
        const o = ii(this.context.scene.children);
        if (o) {
          const r = o.getSize(H());
          if (r.length() > 0) {
            const a = this._defaultRig.gameObject;
            a.position.set(o.min.x + r.x * 0.5, o.min.y, o.max.z + r.z * 0.5 + 1.5);
            const l = o.getCenter(H());
            l.y = a.position.y, a.lookAt(l);
          }
        }
      }
      C1({ session: this }), yr();
      for (const o of K._xrStartListeners)
        o(i);
      const n = [...this._xr_scripts];
      $e && console.log("NeedleXRSession start, handle scripts:", n);
      for (const o of n) {
        if (o.destroyed) {
          this._script_to_remove.push(o);
          continue;
        }
        if (!o.activeAndEnabled) {
          this.markInactive(o);
          continue;
        }
        this.invokeCallback_EnterXR(o);
        for (const r of this.controllers)
          this.invokeCallback_ControllerAdded(o, r);
      }
    }
    this.syncCameraCullingMask();
    for (const n of this.controllers)
      n.onUpdate(t);
    if (this._newControllers.length > 0) {
      const n = [...this._newControllers];
      this._newControllers.length = 0;
      for (const o of n) {
        if (!o.connected) {
          console.warn("New controller is not connected", o);
          continue;
        }
        this.controllers.push(o);
        for (const r of this._xr_scripts) {
          if (r.destroyed) {
            this._script_to_remove.push(r);
            continue;
          }
          r.activeAndEnabled !== !1 && this.invokeCallback_ControllerAdded(r, o);
        }
      }
      this.controllers.sort((o, r) => o.index - r.index);
    }
    $e && this.context.time.frame % 30 === 0 && this.controllers.length <= 0 && this.session.inputSources.length > 0 && (ia(!0), console.error("XRControllers are not added but inputSources are present"));
    for (const n of this._xr_update_scripts) {
      if (n.destroyed === !0) {
        this._script_to_remove.push(n);
        continue;
      }
      if (n.activeAndEnabled === !1) {
        this.markInactive(n);
        continue;
      }
      n.onUpdateXR && n.onUpdateXR(i);
    }
    if (this.handleInactiveScripts(), this._script_to_remove.length > 0) {
      const n = [...new Set(this._script_to_remove)];
      this._script_to_remove.length = 0;
      for (const o of n)
        !o.destroyed && this.running && o.onLeaveXR?.(i), this.removeScript(o);
    }
    this.sync?.onUpdate(this), this.onRenderDebug();
  };
  onRenderDebug() {
    if ($e)
      for (const e of this.controllers)
        e.onRenderDebug();
    if (($e || Hy) && this.rig && (gf++, gf >= 20)) {
      const e = this.rig.gameObject.worldPosition, t = this.rig.gameObject.worldForward;
      e.add(t.multiplyScalar(1.5));
      const i = this.rig.gameObject.worldUp;
      e.add(i.multiplyScalar(2.5));
      let n = "";
      if (n += `${this.context.time.smoothedFps.toFixed(0)} FPS`, n += `, calls: ${this.context.renderer.info.render.calls}, tris: ${this.context.renderer.info.render.triangles.toLocaleString()}`, $e || Hy)
        for (const o of this.controllers)
          n += `
${o.hand ? "hand" : "ctrl"} ${o.inputSource.handedness}[${o.index}] con:${o.connected} tr:${o.isTracking} hts:${o.hasHitTestSource ? "yes" : "no"}`;
      gf = 0, z.DrawLabel(e, n, void 0, 1 / 60 * 20);
    }
  }
  onBeforeRender = () => {
    this.context.mainCamera && (this.updateFade(this.context.mainCamera), this.requestedCameraNearPlane !== null && this.context.mainCamera instanceof de && (this.context.mainCamera.near = this.requestedCameraNearPlane, this.requestedCameraNearPlane = null));
  };
  onAfterRender = () => {
    if (this.onUpdateFade_PostRender(), q.isDesktop() || !this._renderOnceOnDevice) {
      const e = this.context.renderer;
      if (e.xr.isPresenting && this.context.mainCamera) {
        this._renderOnceOnDevice = !0;
        const t = e.xr.enabled, i = e.getRenderTarget(), n = this.context.scene.background;
        e.xr.enabled = !1, e.setRenderTarget(null), this.isPassThrough && (this.context.scene.background = null), this.context.composer ? this.context.composer.render(this.context.time.deltaTime) : e.render(this.context.scene, this.context.mainCamera), e.xr.enabled = t, e.setRenderTarget(i), this.context.scene.background = n;
      }
    }
  };
  /** register a new XR script if it hasnt added yet */
  addScript(e) {
    return this._xr_scripts.includes(e) ? !1 : ($e && console.log("Register new XRScript", e), this._xr_scripts.push(e), typeof e.onUpdateXR == "function" && this._xr_update_scripts.push(e), !0);
  }
  /** mark a script as inactive and invokes callbacks */
  markInactive(e) {
    if (!(this._inactive_scripts.indexOf(e) >= 0)) {
      this.removeScript(e, !1), this._inactive_scripts.push(e);
      for (const t of this.controllers) this.invokeCallback_ControllerRemoved(e, t);
      this.invokeCallback_LeaveXR(e);
    }
  }
  handleInactiveScripts() {
    if (this._inactive_scripts.length > 0)
      for (let e = this._inactive_scripts.length - 1; e >= 0; e--) {
        const t = this._inactive_scripts[e];
        if (t.activeAndEnabled) {
          this._inactive_scripts.splice(e, 1), this.addScript(t), this.invokeCallback_EnterXR(t);
          for (const i of this.controllers) this.invokeCallback_ControllerAdded(t, i);
        }
      }
  }
  _script_to_remove = [];
  removeScript(e, t = !0) {
    $e && console.log("Remove XRScript", e);
    const i = this._xr_scripts.indexOf(e);
    i >= 0 && this._xr_scripts.splice(i, 1);
    const n = this._xr_update_scripts.indexOf(e);
    if (n >= 0 && this._xr_update_scripts.splice(n, 1), t) {
      const o = this._inactive_scripts.indexOf(e);
      o >= 0 && this._inactive_scripts.splice(o, 1);
    }
  }
  invokeCallback_EnterXR(e) {
    e.onEnterXR && e.onEnterXR({ xr: this });
  }
  invokeCallback_ControllerAdded(e, t) {
    e.onXRControllerAdded && e.onXRControllerAdded({ xr: this, controller: t, change: "added" });
  }
  invokeCallback_ControllerRemoved(e, t) {
    e.onXRControllerRemoved && e.onXRControllerRemoved({ xr: this, controller: t, change: "removed" });
  }
  invokeCallback_LeaveXR(e) {
    e.onLeaveXR && !e.destroyed && e.onLeaveXR({ xr: this });
  }
  syncCameraCullingMask() {
    const e = this.context.xrCamera, t = this.context.mainCameraComponent?.cullingMask;
    if (e && t !== void 0) {
      for (const i of e.cameras)
        i.layers.mask = t;
      e.layers.mask = t;
    } else if (e) {
      for (const i of e.cameras)
        i.layers.enableAll();
      e.layers.enableAll();
    }
  }
  invokeControllerEvent(e, t, i) {
    for (let n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o)
        try {
          o({
            xr: this,
            controller: e,
            change: i
          });
        } catch (r) {
          console.error(r);
        }
    }
  }
  _camera;
  _cameraRenderParent = new M().rotateY(Math.PI);
  _previousCameraParent;
  _customforward = !0;
  originalCameraNearPlane;
  requestedCameraNearPlane = null;
  /** This is used to have the XR system camera look into threejs Z forward direction (instead of -z) */
  applyCustomForward() {
    if (this.context.mainCamera && this._customforward) {
      this._camera = this.context.mainCamera, this._camera.parent !== this._cameraRenderParent && (this._previousCameraParent = this._camera.parent, this._previousCameraParent?.add(this._cameraRenderParent)), this._cameraRenderParent.name = "XR Camera Render Parent", this._cameraRenderParent.add(this._camera);
      {
        let e = 0.02;
        const t = 1e-3;
        if (this.rig) {
          const i = Qe(this.rig.gameObject);
          e *= i.x;
        }
        this._camera instanceof de && Math.abs(this._camera.near - e) > t && (this.isAR ? this.originalCameraNearPlane = this._camera.near : this._camera.near = e, $e && console.debug(`Setting camera near plane to ${e} (was ${this.originalCameraNearPlane}) to account for XR rendering scale`));
      }
    }
  }
  revertCustomForward() {
    this._camera && this._previousCameraParent && this._previousCameraParent.add(this._camera), this._previousCameraParent = null, this._camera instanceof de && this.originalCameraNearPlane != null && (this._camera.near = this.originalCameraNearPlane, this.originalCameraNearPlane = void 0);
  }
  _viewerPose;
  _transformOrientation = new U();
  _transformPosition = new y();
  internalUpdateState() {
    const e = this.context.renderer.xr.getReferenceSpace();
    if (!e) {
      this._viewerPose = void 0;
      return;
    }
    if (this._viewerPose = this.frame.getViewerPose(e), this._viewerPose) {
      const t = this._viewerPose.transform;
      this._transformPosition.set(t.position.x, t.position.y, t.position.z), this._transformOrientation.set(t.orientation.x, t.orientation.y, t.orientation.z, t.orientation.w);
    }
  }
  // TODO: for scene transitions (e.g. SceneSwitcher) where creating the scene might take a few moments we might want more control over when/how this fading occurs and how long the scene stays black
  _transition;
  get transition() {
    return this._transition || (this._transition = new $y()), this._transition;
  }
  /** Call to fade rendering to black for a short moment (the returned promise will be resolved when fully black)   
   * This can be used to mask scene transitions or teleportation
   * @returns a promise that is resolved when the screen is fully black
   * @example `fadeTransition().then(() => { <fully_black> })`
  */
  fadeTransition() {
    return this._transition || (this._transition = new $y()), this._transition.fadeTransition();
  }
  /** e.g. FadeToBlack */
  updateFade(e) {
    this._transition && e instanceof de && this._transition.update(e, this.context.time.deltaTime);
  }
  onUpdateFade_PostRender() {
    this._transition?.remove();
  }
}
const yf = w("debugwebxr");
class Z1 {
  /** Searches the hierarchy for objects following a specific naming scheme */
  static tryFindAvatarObjects(e, t, i) {
    if (i.head && i.leftHand && i.rightHand) return;
    const n = e.name.toLocaleLowerCase();
    !i.head && n.includes("head") && (yf && console.log("FOUND AVATAR HEAD", e.name), i.head = new ie("", t, e)), n.includes("hand") && (!i.leftHand && n.includes("left") && (yf && console.log("FOUND AVATAR LEFT HAND", e.name), i.leftHand = new ie("", t, e)), !i.rightHand && n.includes("right") && (yf && console.log("FOUND AVATAR RIGHT HAND", e.name), i.rightHand = new ie("", t, e)));
    for (let o = 0; o < e.children.length; o++) {
      if (i.head && i.leftHand && i.rightHand) return;
      const r = e.children[o];
      this.tryFindAvatarObjects(r, t, i);
    }
  }
}
const Rt = new y(), Gy = new y(), qy = new U(), J1 = w("debuggizmos"), tn = 8947848, _f = 32;
class z {
  constructor() {
  }
  /**
   * Allow creating gizmos   
   * If disabled then no gizmos will be added to the scene anymore
   */
  static enabled = !0;
  /** 
   * Returns true if a given object is a gizmo
   */
  static isGizmo(e) {
    return e[Op] !== void 0;
  }
  /** Set visibility of all currently rendered gizmos */
  static setVisible(e) {
    for (const t of Ii.timedObjectsBuffer)
      t.visible = e;
  }
  /**
   * Draw a label in the scene or attached to an object (if a parent is provided)
   * @param position the position of the label in world space
   * @param text the text of the label
   * @param size the size of the label in world space
   * @param duration the duration in seconds the label will be rendered. If 0 it will be rendered for one frame
   * @param color the color of the label
   * @param backgroundColor the background color of the label
   * @param parent the parent object to attach the label to. If no parent is provided the label will be attached to the scene
   * @returns a handle to the label that can be used to update the text
   */
  static DrawLabel(e, t, i = 0.05, n = 0, o, r, a) {
    if (!z.enabled) return null;
    o || (o = tn);
    const l = K.active?.rigScale ?? 1, c = Ii.getTextLabel(n, t, i * l, o, r);
    return a instanceof M && a.add(c), c.position.x = e.x, c.position.y = e.y, c.position.z = e.z, c;
  }
  /**
   * Draw a ray gizmo in the scene
   * @param origin the origin of the ray in world space
   * @param dir the direction of the ray in world space
   * @param color the color of the ray
   * @param duration the duration in seconds the ray will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the ray will be rendered with depth test
   */
  static DrawRay(e, t, i = tn, n = 0, o = !0) {
    if (!z.enabled) return;
    const r = Ii.getLine(n), a = r.geometry.getAttribute("position");
    a.setXYZ(0, e.x, e.y, e.z), Rt.set(t.x, t.y, t.z).multiplyScalar(999999999), a.setXYZ(1, e.x + Rt.x, e.y + Rt.y, e.z + Rt.z), a.needsUpdate = !0, r.material.color.set(i), r.material.depthTest = o, r.material.depthWrite = !1;
  }
  /**
   * Draw a line gizmo in the scene
   * @param pt0 the start point of the line in world space
   * @param pt1 the end point of the line in world space
   * @param color the color of the line
   * @param duration the duration in seconds the line will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the line will be rendered with depth test
   * @param lengthFactor the length of the line. Default is 1
   */
  static DrawDirection(e, t, i = tn, n = 0, o = !0, r = 1) {
    if (!z.enabled) return;
    const a = Ii.getLine(n), l = a.geometry.getAttribute("position");
    l.setXYZ(0, e.x, e.y, e.z), t.w !== void 0 ? (Rt.set(0, 0, -r), qy.set(t.x, t.y, t.z, t.w), Rt.applyQuaternion(qy)) : (Rt.set(t.x, t.y, t.z), Rt.multiplyScalar(r)), l.setXYZ(1, e.x + Rt.x, e.y + Rt.y, e.z + Rt.z), l.needsUpdate = !0, a.material.color.set(i), a.material.depthTest = o, a.material.depthWrite = !1;
  }
  /**
   * Draw a line gizmo in the scene
   * @param pt0 the start point of the line in world space
   * @param pt1 the end point of the line in world space
   * @param color the color of the line
   * @param duration the duration in seconds the line will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the line will be rendered with depth test
   */
  static DrawLine(e, t, i = tn, n = 0, o = !0) {
    if (!z.enabled) return;
    const r = Ii.getLine(n), a = r.geometry.getAttribute("position");
    a.setXYZ(0, e.x, e.y, e.z), a.setXYZ(1, t.x, t.y, t.z), a.needsUpdate = !0, r.material.color.set(i), r.material.depthTest = o, r.material.depthWrite = !1, r.material.fog = !1;
  }
  /**
   * Draw a 2D circle gizmo in the scene
   * @param pt0 the center of the circle in world space
   * @param normal the normal of the circle in world space
   * @param radius the radius of the circle in world space
   * @param color the color of the circle
   * @param duration the duration in seconds the circle will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the circle will be rendered with depth test
   */
  static DrawCircle(e, t, i, n = tn, o = 0, r = !0) {
    if (!z.enabled) return;
    const a = Ii.getCircle(o);
    a.position.set(e.x, e.y, e.z), a.scale.set(i, i, i), a.quaternion.setFromUnitVectors(this._up, Rt.set(t.x, t.y, t.z).normalize()), a.material.color.set(n), a.material.depthTest = r, a.material.depthWrite = !1, a.material.fog = !1;
  }
  /**
   * Draw a 3D wiremesh sphere gizmo in the scene
   * @param center the center of the sphere in world space
   * @param radius the radius of the sphere in world space
   * @param color the color of the sphere
   * @param duration the duration in seconds the sphere will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the sphere will be rendered with depth test
   */
  static DrawWireSphere(e, t, i = tn, n = 0, o = !0) {
    if (!z.enabled) return;
    const r = Ii.getSphere(t, n, !0);
    ba(r, e.x, e.y, e.z), r.material.color.set(i), r.material.depthTest = o, r.material.depthWrite = !1, r.material.fog = !1;
  }
  /**
   * Draw a 3D sphere gizmo in the scene
   * @param center the center of the sphere in world space
   * @param radius the radius of the sphere in world space
   * @param color the color of the sphere
   * @param duration the duration in seconds the sphere will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the sphere will be rendered with depth test
   */
  static DrawSphere(e, t, i = tn, n = 0, o = !0) {
    if (!z.enabled) return;
    const r = Ii.getSphere(t, n, !1);
    ba(r, e.x, e.y, e.z), r.material.color.set(i), r.material.depthTest = o, r.material.depthWrite = !1;
  }
  /**
   * Draw a 3D wiremesh box gizmo in the scene
   * @param center the center of the box in world space
   * @param size the size of the box in world space
   * @param rotation the rotation of the box in world space
   * @param color the color of the box
   * @param duration the duration in seconds the box will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the box will be rendered with depth test
   */
  static DrawWireBox(e, t, i = tn, n = 0, o = !0, r = void 0) {
    if (!z.enabled) return;
    const a = Ii.getBox(n);
    a.position.set(e.x, e.y, e.z), a.scale.set(t.x, t.y, t.z), r ? a.quaternion.copy(r) : a.quaternion.identity(), a.material.color.set(i), a.material.depthTest = o, a.material.wireframe = !0, a.material.depthWrite = !1, a.material.fog = !1;
  }
  /**
   * Draw a 3D wiremesh box gizmo in the scene
   * @param box the box in world space
   * @param color the color of the box
   * @param duration the duration in seconds the box will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the box will be rendered with depth test
   */
  static DrawWireBox3(e, t = tn, i = 0, n = !0) {
    if (!z.enabled) return;
    const o = Ii.getBox(i);
    o.position.copy(e.getCenter(Rt)), o.scale.copy(e.getSize(Rt)), o.material.color.set(t), o.material.depthTest = n, o.material.wireframe = !0, o.material.depthWrite = !1, o.material.fog = !1;
  }
  static _up = new y(0, 1, 0);
  /**
   * Draw an arrow gizmo in the scene
   * @param pt0 the start point of the arrow in world space
   * @param pt1 the end point of the arrow in world space
   * @param color the color of the arrow
   * @param duration the duration in seconds the arrow will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the arrow will be rendered with depth test
   * @param wireframe if true the arrow will be rendered as wireframe
   */
  static DrawArrow(e, t, i = tn, n = 0, o = !0, r = !1) {
    if (!z.enabled) return;
    const a = Ii.getArrowHead(n);
    a.position.set(t.x, t.y, t.z), a.quaternion.setFromUnitVectors(this._up.set(0, 1, 0), Rt.set(t.x, t.y, t.z).sub(Gy.set(e.x, e.y, e.z)).normalize());
    const c = Rt.set(t.x, t.y, t.z).sub(Gy.set(e.x, e.y, e.z)).length() * 0.1;
    a.scale.set(c, c, c), a.material.color.set(i), a.material.depthTest = o, a.material.wireframe = r, this.DrawLine(e, t, i, n, o);
  }
  /**
   * Render a wireframe mesh in the scene. The mesh will be removed after the given duration (if duration is 0 it will be rendered for one frame).   
   * If a mesh object is provided then the mesh's matrixWorld and geometry will be used. Otherwise, the provided matrix and geometry will be used.
   * @param options the options for the wire mesh
   * @param options.duration the duration in seconds the mesh will be rendered. If 0 it will be rendered for one frame
   * @param options.color the color of the wire mesh
   * @param options.depthTest if true the wire mesh will be rendered with depth test
   * @param options.mesh the mesh object to render (if it is provided the matrix and geometry will be used)
   * @param options.matrix the matrix of the mesh to render
   * @param options.geometry the geometry of the mesh to render
   * @example
   * ```typescript
   * Gizmos.DrawWireMesh({ duration: 1, color: 0xff0000, mesh: myMesh });
   * ```
   */
  static DrawWireMesh(e) {
    const t = Ii.getMesh(e.duration ?? 0);
    "mesh" in e ? (t.geometry = e.mesh.geometry, t.matrix.copy(e.mesh.matrixWorld)) : (t.geometry = e.geometry, t.matrix.copy(e.matrix)), t.matrixAutoUpdate = !1, t.matrixWorldAutoUpdate = !1, t.material.color.set(e.color ?? tn), t.material.depthTest = e.depthTest ?? !0, t.material.wireframe = !0;
  }
}
const eP = new pa(1, 1, 1);
function Wm(s = null) {
  const e = new se(s ?? 14540253), t = new fx(eP);
  return new kb(t, new wm({ color: e }));
}
const Op = Symbol("GizmoCache");
class Ii {
  // private static createdLines: number = 0;
  static familyName = "needle-gizmos";
  static ensureFont() {
    let e = Ce.FontLibrary.getFontFamily(this.familyName);
    e || (e = Ce.FontLibrary.addFontFamily(this.familyName), e.addVariant("normal", "normal", "https://uploads.needle.tools/include/font-msdf.json", "https://uploads.needle.tools/include/font.png")?.addEventListener("ready", () => {
      Ce.update();
    }));
  }
  static getTextLabel(e, t, i, n, o) {
    this.ensureFont();
    let r = this.textLabelCache.pop(), a = 1;
    o && typeof o == "string" && o?.length >= 8 && o.startsWith("#") ? (a = parseInt(o.substring(7), 16) / 255, o = o.substring(0, 7), J1 && console.log(o, a)) : typeof o == "object" && o.a !== void 0 && (a = o.a);
    const l = {
      boxSizing: "border-box",
      fontFamily: this.familyName,
      width: "auto",
      fontSize: i,
      color: n,
      lineHeight: 1,
      backgroundColor: o ?? void 0,
      backgroundOpacity: a,
      textContent: t,
      borderRadius: 0.5 * i,
      padding: 0.8 * i,
      whiteSpace: "pre",
      offset: 0.05 * i
    };
    if (r)
      r.set(l);
    else {
      r = new $b(l);
      const c = this, h = r;
      h.setText = function(d) {
        this.set({ textContent: d }), c.tmuiNeedsUpdate = !0;
      };
    }
    return this.tmuiNeedsUpdate = !0, this.registerTimedObject(N.Current, r, e, this.textLabelCache), r;
  }
  static getBox(e) {
    let t = this.boxesCache.pop();
    if (!t) {
      const i = new pa(1, 1, 1);
      t = new G(i);
    }
    return this.registerTimedObject(N.Current, t, e, this.boxesCache), t;
  }
  static getLine(e) {
    let t = this.linesCache.pop();
    if (!t) {
      t = new ma();
      let i = t.geometry.getAttribute("position");
      i || (i = new ft(new Float32Array(6), 3), t.geometry.setAttribute("position", i));
    }
    return t.frustumCulled = !1, this.registerTimedObject(N.Current, t, e, this.linesCache), t;
  }
  static getCircle(e) {
    let t = this.circlesCache.pop();
    if (!t) {
      t = new ma();
      let i = t.geometry.getAttribute("position");
      if (!i) {
        i = new ft(new Float32Array(_f * 3), 3), t.geometry.setAttribute("position", i);
        const n = H(0, 1, 0), o = H(0, 0, 1), r = H(o);
        r.cross(n).normalize();
        const a = H(r), l = Math.PI * 2 / (_f - 1);
        for (let c = 0; c < _f + 1; c++) {
          const h = l * c;
          n.copy(a).multiplyScalar(Math.cos(h) * 1), r.copy(o).multiplyScalar(Math.sin(h) * 1);
          const d = n.add(r);
          i.setXYZ(c, d.x, d.y, d.z);
        }
      }
    }
    return t.frustumCulled = !1, this.registerTimedObject(N.Current, t, e, this.circlesCache), t;
  }
  static getSphere(e, t, i) {
    let n = this.spheresCache.pop();
    return n || (n = new G(new Ud(1, 8, 8))), n.scale.set(e, e, e), n.material.wireframe = i, this.registerTimedObject(N.Current, n, t, this.spheresCache), n;
  }
  static getArrowHead(e) {
    let t = this.arrowHeadsCache.pop();
    return t || (t = new G(new Pb(0, 0.5, 1, 8))), this.registerTimedObject(N.Current, t, e, this.arrowHeadsCache), t;
  }
  static getMesh(e) {
    let t = this.mesh.pop();
    return t || (t = new G(), t.material = new we()), this.registerTimedObject(N.Current, t, e, this.mesh), t;
  }
  static linesCache = [];
  static circlesCache = [];
  static spheresCache = [];
  static boxesCache = [];
  static arrowHeadsCache = [];
  static mesh = [];
  static textLabelCache = [];
  static registerTimedObject(e, t, i, n) {
    if (!e) {
      console.error("No Needle Engine context available. Did you call a Gizmos function in global scope?");
      return;
    }
    const o = this.contextBeforeRenderCallbacks.get(e), r = this.contextPostRenderCallbacks.get(e);
    if (o) {
      if (e.pre_render_callbacks[e.pre_render_callbacks.length - 1] !== o) {
        const a = e.pre_render_callbacks.indexOf(o);
        a >= 0 && e.pre_render_callbacks.splice(a, 1), e.pre_render_callbacks.push(o);
      }
    } else {
      const a = () => {
        this.onBeforeRender(e, this.timedObjectsBuffer);
      };
      this.contextBeforeRenderCallbacks.set(e, a), e.pre_render_callbacks.push(a);
    }
    if (r) {
      if (e.post_render_callbacks[e.post_render_callbacks.length - 1] !== r) {
        const a = e.post_render_callbacks.indexOf(r);
        a >= 0 && e.post_render_callbacks.splice(a, 1), e.post_render_callbacks.push(r);
      }
    } else {
      const a = () => {
        this.onPostRender(e, this.timedObjectsBuffer, this.timesBuffer);
      };
      this.contextPostRenderCallbacks.set(e, a), e.post_render_callbacks.push(a);
    }
    t.traverse((a) => {
      a.layers.disableAll(), a.layers.enable(2);
    }), t.renderOrder = 999999, t[Op] = n, t.castShadow = !1, t.receiveShadow = !1, t.isGizmo = !0, this.timedObjectsBuffer.push(t), this.timesBuffer.push(N.Current.time.realtimeSinceStartup + i), e.scene.add(t);
  }
  static timedObjectsBuffer = new Array();
  static timesBuffer = new Array();
  static contextPostRenderCallbacks = /* @__PURE__ */ new Map();
  static contextBeforeRenderCallbacks = /* @__PURE__ */ new Map();
  static tmuiNeedsUpdate = !1;
  static onBeforeRender(e, t) {
    this.tmuiNeedsUpdate && (this.tmuiNeedsUpdate = !1, Ce.update());
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      if (e.mainCamera && n instanceof Ce.MeshUIBaseElement) {
        if (Pa(n))
          continue;
        const o = e.isInVR, r = !1, a = !o;
        Yd(n, e.mainCamera, r, a);
      }
    }
  }
  static onPostRender(e, t, i) {
    const n = e.time.realtimeSinceStartup;
    for (let o = t.length - 1; o >= 0; o--) {
      const r = t[o];
      n >= i[o] - 1e-6 && (t.splice(o, 1), i.splice(o, 1), r.removeFromParent(), Pa(r) != !0 && r[Op].push(r));
    }
  }
}
const Vt = w("debugphysics"), Xy = new ho();
class _r {
  static AllLayers = 4294967295;
  ray;
  cam;
  screenPoint;
  raycaster;
  results;
  targets;
  recursive = !0;
  minDistance;
  maxDistance;
  lineThreshold;
  layerMask;
  ignore;
  testObject;
  useAcceleratedRaycast;
  allowSlowRaycastFallback = !0;
  screenPointFromOffset(e, t) {
    this.screenPoint === void 0 && (this.screenPoint = new J()), this.screenPoint.x = e / window.innerWidth * 2 - 1, this.screenPoint.y = -(t / window.innerHeight) * 2 + 1;
  }
  /** sets one layer for raycasting (e.g. layer 4, only objects on layer 4 will then be hit) */
  setLayer(e) {
    Xy.set(e), this.layerMask = Xy;
  }
  /** sets the layer.mask value directly, use setLayer if you want to set e.g. an individual layer only active. See https://threejs.org/docs/#api/en/core/Layers for more information about layers */
  setMask(e) {
    this.layerMask || (this.layerMask = new ho());
    const t = this.layerMask;
    t ? t.mask = e : this.layerMask = e;
  }
}
class w0 {
  distance;
  point;
  object;
  constructor(e, t, i) {
    this.object = e, this.distance = t, this.point = i;
  }
}
class uc {
  static _raycasting = 0;
  /**
   * Returns true if raycasting is currently happening
   */
  static get raycasting() {
    return this._raycasting > 0;
  }
  /**@deprecated use `this.context.physics.engine.raycast` {@link IPhysicsEngine.raycast} */
  raycastPhysicsFast(e, t = void 0, i = 1 / 0, n = !0) {
    return this.context.physics.engine?.raycast(e, t, { maxDistance: i, solid: n }) ?? null;
  }
  /**@deprecated use `this.context.physics.engine.raycastAndGetNormal` {@link IPhysicsEngine.raycastAndGetNormal} */
  raycastPhysicsFastAndGetNormal(e, t = void 0, i = 1 / 0, n = !0) {
    return this.context.physics.engine?.raycastAndGetNormal(e, t, { maxDistance: i, solid: n }) ?? null;
  }
  /**@deprecated use this.context.physics.engine.sphereOverlap */
  sphereOverlapPhysics(e, t) {
    return this.context.physics.engine?.sphereOverlap(e, t) ?? null;
  }
  context;
  engine;
  constructor(e) {
    this.context = e;
  }
  // raycasting
  raycaster = new Nd();
  defaultRaycastOptions = new _r();
  targetBuffer = new Array(1);
  defaultThresholds = {
    Mesh: {},
    Line: { threshold: -1 },
    LOD: {},
    Points: { threshold: 0 },
    Sprite: {}
  };
  sphereResults = new Array();
  sphereMask = new ho();
  sphere = new $d();
  /** Test overlapping of a sphere with the threejs geometry. This does not use colliders. This does not return an exact intersection point (intersections returned contain the object and the world position of the object that is being hit)
   * For a more accurate test use the physics engine's collider overlap test (see sphereOverlapPhysics)
   * @param spherePos the center of the sphere in world space
   * @param radius the radius of the sphere
   * @param traverseChildsAfterHit if false it will stop after the first hit. If true it will continue to traverse and add all hits to the result array
   * @param bvh use MeshBVH for raycasting. This is faster than the default threejs raycaster but uses more memory.
   * @param shouldRaycast optional callback to filter objects. Return `false` to ignore the object completely or `"continue in children"` to skip the object but continue to traverse its children (if you do raycast with `recursive` enabled)
   */
  sphereOverlap(e, t, i = !0, n = !1, o = null) {
    if (this.sphereResults.length = 0, !this.context.scene) return this.sphereResults;
    const r = this.sphereMask;
    r.enableAll(), r.disable(2);
    for (const a of this.context.scene.children)
      this.intersectSphere(a, e, t, r, this.sphereResults, i, n, o);
    return this.sphereResults.sort((a, l) => a.distance - l.distance);
  }
  raycastFromRay(e, t = null) {
    const i = t ?? this.defaultRaycastOptions;
    i.ray = e;
    const n = this.raycast(i);
    return i === this.defaultRaycastOptions && (i.ray = void 0), n;
  }
  /** raycast against rendered three objects. This might be very slow depending on your scene complexity.
   * We recommend setting objects to IgnoreRaycast layer (2) when you don't need them to be raycasted.
   * Raycasting SkinnedMeshes is specially expensive.
   * Use raycastPhysics for raycasting against physic colliders only. Depending on your scenario this might be faster.
   * @param options raycast options. If null, default options will be used.
   */
  raycast(e = null) {
    Vt && performance.mark("raycast.start"), e || (e = this.defaultRaycastOptions);
    const t = e.screenPoint ?? this.context.input.mousePositionRC, i = e.raycaster ?? this.raycaster;
    if (i.near = e.minDistance ?? 0, i.far = e.maxDistance ?? 1 / 0, i.params = this.defaultThresholds, e.lineThreshold === void 0 && (e.lineThreshold = -1), i.params.Line = { threshold: e.lineThreshold }, e.ray)
      i.ray.copy(e.ray);
    else {
      const a = e.cam ?? this.context.mainCamera;
      if (!a)
        return Vt && console.error("Can not perform raycast - no main camera found"), this.defaultRaycastOptions.results && (this.defaultRaycastOptions.results.length = 0), this.defaultRaycastOptions.results ?? [];
      const l = this.context.xrCamera;
      this.context.isInXR && l instanceof px && l.cameras.length > 0 ? i.setFromCamera(t, l.cameras[0]) : i.setFromCamera(t, a);
    }
    let n = e.targets;
    n || (n = this.targetBuffer, n.length = 1, n[0] = this.context.scene);
    let o = e.results;
    this.defaultRaycastOptions.results && (this.defaultRaycastOptions.results.length = 0), o || (this.defaultRaycastOptions.results || (this.defaultRaycastOptions.results = new Array()), o = this.defaultRaycastOptions.results), e.layerMask !== void 0 ? e.layerMask instanceof ho ? i.layers.mask = e.layerMask.mask : i.layers.mask = e.layerMask : (i.layers.enableAll(), i.layers.disable(2)), Vt && console.time("raycast"), o.length = 0, uc._raycasting++, this.intersect(this.raycaster, n, o, e), o.sort((a, l) => a.distance - l.distance);
    const r = e.ignore;
    return r !== void 0 && r.length > 0 && (o = o.filter((a) => !r.includes(a.object))), uc._raycasting--, Vt && (console.timeEnd("raycast"), console.warn("#" + this.context.time.frame + ", hits:", o?.length ? [...o] : "nothing"), performance.mark("raycast.end"), performance.measure("raycast", "raycast.start", "raycast.end")), o;
  }
  intersect(e, t, i, n) {
    for (const o of t) {
      if (!o || o.visible === !1 || z.isGizmo(o) || n.lineThreshold !== void 0 && n.lineThreshold < 0 && o instanceof ma)
        continue;
      let r = !0;
      const a = o, l = a.geometry;
      if (n.testObject) {
        const c = n.testObject?.(o);
        if (c === !1)
          continue;
        c === "continue in children" && (r = !1);
      }
      if (r && (l && Qy(l) || (r = !1)), r) {
        const c = Lb(o);
        c && (a.geometry = c);
        const h = i.length;
        let d = !0;
        if (n.precise === !1 && (d = !1), d ||= l.getAttribute("position")?.array?.length < 64, a instanceof _a && (d = !1), !d && iP(a, e, i) || (n.useAcceleratedRaycast !== !1 ? dd.runMeshBVHRaycast(e, a, i, this.context, n) : e.intersectObject(a, !1, i)), Vt && i.length != h) {
          const f = i[i.length - 1], p = c ? 8969557 : 7798784;
          z.DrawWireSphere(f.point, 0.1, p, 1, !1), z.DrawWireMesh({ mesh: o, depthTest: !1, duration: 0.2, color: p });
        }
        a.geometry = l;
      }
      n.recursive !== !1 && this.intersect(e, o.children, i, n);
    }
    return i;
  }
  tempBoundingBox = new bi();
  intersectSphere(e, t, i, n, o, r, a, l) {
    let c = e && e.isMesh && e.layers.test(n) && !z.isGizmo(e);
    c &&= e.visible, c &&= !(e instanceof ma), c &&= !(e instanceof _a);
    const h = e, d = h.geometry;
    if (c && l) {
      const f = l(e);
      if (f === !1)
        return;
      f === "continue in children" && (c = !1);
    }
    if (d && Qy(d) || (c = !1), c) {
      if (a) {
        const f = this.sphere;
        f.center.copy(t), f.radius = i;
        const p = o.length;
        if (dd.runMeshBVHRaycast(this.sphere, h, o, this.context, {}), p != o.length && !r)
          return;
      } else if (d.boundingBox || d.computeBoundingBox(), d.boundingBox) {
        h.matrixWorldNeedsUpdate && h.updateWorldMatrix(!1, !1);
        const f = this.tempBoundingBox.copy(d.boundingBox).applyMatrix4(h.matrixWorld), p = this.sphere;
        if (p.center.copy(t), p.radius = i, p.intersectsBox(f)) {
          const g = Z(e), b = g.distanceTo(p.center), m = new w0(e, b, g);
          if (o.push(m), !r) return;
        }
      }
    }
    if (e.children)
      for (const f of e.children) {
        const p = o.length;
        if (this.intersectSphere(f, t, i, n, o, r, a, l), p != o.length && !r) return;
      }
  }
}
function Qy(s) {
  return !(s.index && s.index.array.length < 3);
}
const Bo = new $d(), ch = new rr(), tP = new Cb();
function iP(s, e, t) {
  const i = s._computeIntersections;
  if (!i)
    return !1;
  let n = s["_computeIntersections:Needle"];
  return n || (n = s["_computeIntersections:Needle"] = function(o, r, a) {
    const l = this, c = l.geometry.boundingSphere;
    if (c) {
      if (l instanceof _a) {
        ch.setFromNormalAndCoplanarPoint(H(0, 1, 0), H(0, -l.position.y, 0)), ch.applyMatrix4(l.matrixWorld, tP);
        const d = o.ray.intersectPlane(ch, H());
        if (d) {
          Bo.copy(c), Bo.applyMatrix4(l.matrixWorld);
          const p = H(d).sub(o.ray.origin).length(), g = Bo.radius * 0.5;
          p < g && r.push({ distance: p, point: d, object: l, normal: ch.normal.clone() });
        }
        return;
      }
      Bo.copy(c), Bo.applyMatrix4(l.matrixWorld);
      const h = o.ray.intersectSphere(Bo, H());
      if (h) {
        const d = H(h).sub(o.ray.origin), f = d.length();
        if (f > Bo.radius) {
          const p = d.clone().normalize();
          r.push({ distance: f, point: h, object: l, normal: p });
        }
      }
    }
  }), s._computeIntersections = n, e.intersectObject(s, !1, t), s._computeIntersections = i, !0;
}
var dd;
((s) => {
  function e(v, _, x, I, O) {
    if (!_.geometry || !_.geometry.hasAttribute("position"))
      return !1;
    const k = _.geometry;
    if (_?.isSkinnedMesh) {
      const E = _, B = E.bvhNeedsUpdate;
      if (!E.staticGenerator)
        a(), o && (E.staticGenerator = new o(_), E.staticGenerator.applyWorldTransforms = !1, E.staticGeometry = E.staticGenerator.generate(), k.boundsTree = r?.call(E.staticGeometry), E.staticGeometryLastUpdate = performance.now() + Math.random() * 200, E.bvhNeedsUpdate = !0);
      else if (k.boundsTree && (E.autoUpdateMeshBvhInterval !== void 0 && E.autoUpdateMeshBvhInterval >= 0 || B === !0)) {
        const D = performance.now(), W = D - E.staticGeometryLastUpdate, X = E.autoUpdateMeshBvhInterval ?? 100;
        (B || W > X) && (Vt && console.warn(`Physics: updating skinned mesh bvh for ${_.name} after ${W.toFixed(2)}ms`), E.bvhNeedsUpdate = !1, E.staticGeometryLastUpdate = D, E.staticGenerator?.generate(E.staticGeometry), k.boundsTree.refit());
      }
    } else if (!k.boundsTree) {
      c || m();
      let E = !0;
      if ((I.xr || k[p] === !1 || k.getAttribute("position")?.isInterleavedBufferAttribute || k.index && k.index?.isInterleavedBufferAttribute) && (E = !1), E && d) {
        if (k[f] === void 0) {
          let B = null;
          if (b.length > 0) {
            const D = b.shift();
            D && !D.running && (B = D);
          }
          if (!B && g.length < 3 && (B = new d(), g.push(B)), B != null && !B.running) {
            const D = _.name;
            Vt && console.log("<<<< worker start", D, B), k[f] = "queued", performance.mark("bvh.create.start");
            const W = k.clone();
            try {
              B.generate(W).then((X) => {
                k[f] = "done", k.boundsTree = X;
              }).catch((X) => {
                k[f] = "failed - " + X?.message, k[p] = !1, Vt && console.error("Failed to generate mesh bvh on worker", X);
              }).finally(() => {
                Vt && console.log(">>>>> worker done", D, { hasBoundsTre: k.boundsTree != null }), b.push(B), W.dispose(), performance.mark("bvh.create.end"), performance.measure("bvh.create (worker)", "bvh.create.start", "bvh.create.end");
              });
            } catch (X) {
              console.error("Failed to generate mesh bvh on worker", X);
            }
          } else
            Vt && console.warn("No worker available");
        }
      } else (!h || !E) && (a(), n && (performance.mark("bvh.create.start"), k.boundsTree = new n(k), performance.mark("bvh.create.end"), performance.measure("bvh.create", "bvh.create.start", "bvh.create.end")));
    }
    if (v instanceof Nd) {
      const E = v, B = _.raycast;
      if (k.boundsTree)
        a(), i && (_.acceleratedRaycast || (_.acceleratedRaycast = i.bind(_), Vt && console.debug(`Physics: bind acceleratedRaycast fn to "${_.name}"`)), _.raycast = _.acceleratedRaycast);
      else if (Vt && console.warn("No bounds tree found for mesh", _.name, { workerTask: k[f], hasAcceleratedRaycast: i != null }), O.allowSlowRaycastFallback === !1)
        return Vt && console.warn("Skipping raycast because no bounds tree is available and allowSlowRaycastFallback is false"), !1;
      const D = E.firstHitOnly;
      return E.firstHitOnly = !1, E.intersectObject(_, !1, x), E.firstHitOnly = D, _.raycast = B, !0;
    } else if (v instanceof $d) {
      const E = k.boundsTree;
      if (E) {
        const B = v;
        if (l.copy(_.matrixWorld).invert(), B.applyMatrix4(l), E.intersectsSphere(B)) {
          const W = Z(_), X = W.distanceTo(B.center), A = new w0(_, X, W);
          x.push(A);
        }
      }
      return !0;
    }
    return !1;
  }
  s.runMeshBVHRaycast = e;
  let t = !1, i = null, n = null, o = null, r = null;
  function a() {
    t || (t = !0, import("./vendor-k9i6CeGi.js").then((v) => v.index$1).then((v) => {
      i = v.acceleratedRaycast, n = v.MeshBVH, o = v.StaticGeometryGenerator, r = v.computeBoundsTree;
    }).catch((v) => {
      (Vt || L()) && console.error("Failed to load BVH library...", v.message);
    }));
  }
  const l = new ee();
  let c = !1, h = !1, d = null;
  const f = Symbol("Needle:MeshBVH-Worker"), p = Symbol("Needle:MeshBVH-CanUseWorker"), g = [], b = [];
  function m() {
    c = !0, h = !0, Promise.resolve().then(() => bI).then((v) => {
      d = v.GenerateMeshBVHWorker;
    }).catch((v) => {
      (Vt || L()) && console.warn("Failed to setup mesh bvh worker");
    }).finally(() => {
      h = !1;
    });
  }
})(dd || (dd = {}));
const Yy = Symbol("gltf-loader-internal-usage-tracker"), nP = w("debugusers");
class oa {
  get name() {
    return "NEEDLE_internal_usage_tracker";
  }
  static isLoading(e) {
    return oa._loadingProcesses > 0;
  }
  static _loadingProcesses = 0;
  parser;
  _getDependency;
  _loadingId;
  _loadedObjects = /* @__PURE__ */ new Set();
  constructor(e) {
    this.parser = e, this._getDependency = this.parser.getDependency, this._loadingId = Date.now().toString();
  }
  beforeRoot() {
    oa._loadingProcesses++;
    const e = this, t = this._getDependency;
    return this.parser.getDependency = function(i, n) {
      const o = t.call(this, i, n);
      return o.then((r) => (r && (e._loadedObjects.add(r), r[Yy] = e._loadingId), r)), o;
    }, null;
  }
  afterRoot(e) {
    oa._loadingProcesses--, this.parser.getDependency = this._getDependency;
    for (const t of this._loadedObjects)
      delete t[Yy], t instanceof M && (t.parent || t instanceof G && setTimeout(() => {
        nP && console.warn("> GLTF LOADER: Mesh not used in scene!", t), t.material = null, t.geometry = null;
      }, 1e3));
    return null;
  }
  // private readonly _creatingNodeMesh: Map<number, CreateNodeMesh> = new Map();
  // createNodeMesh(_nodeIndex: number): CreateNodeMesh | null {
  //     // if (!this.parser) return null;
  //     // let process = this._creatingNodeMesh.get(nodeIndex);
  //     // if (process) return process;
  //     // process = this.parser.createNodeMesh(nodeIndex)?.then((mesh) => {
  //     //     console.log("createNodeMesh", nodeIndex, mesh);
  //     //     return mesh;
  //     // }) as CreateNodeMesh;
  //     // this._creatingNodeMesh.set(nodeIndex, process);
  //     // return process;
  // }
}
class sP {
  constructor() {
    window.addEventListener("unhandledrejection", (e) => {
      if (e.defaultPrevented) return;
      const t = e?.reason?.path;
      if (t) {
        const i = t[0];
        i && i.tagName === "IMG" && (console.warn(`Could not load image:
` + i.src), e.preventDefault());
      }
    });
  }
}
const Jd = w("trackresources");
function x0() {
  return Jd === "dispose";
}
let br = !0;
Jd === 0 && (br = !1);
function aL(s) {
  br = s;
}
function oP() {
  return br;
}
const S0 = Symbol("disposable");
function rP(s, e) {
  s && (s[S0] = e, Jo && console.warn("Set disposable", e, s));
}
const C0 = Symbol("disposed");
function lL(s) {
  return s[C0] === !0;
}
function Re(s) {
  if (s) {
    if (s[S0] === !1) {
      Jo && console.warn("Object is marked as not disposable", s);
      return;
    }
    if (typeof s == "object" && (s[C0] = !0), s instanceof wi)
      Re(s.environment), Re(s.background), Re(s.customDepthMaterial), Re(s.customDistanceMaterial);
    else if (s instanceof oo)
      Re(s.geometry), Re(s.material), Re(s.skeleton), Re(s.bindMatrix), Re(s.bindMatrixInverse), Re(s.customDepthMaterial), Re(s.customDistanceMaterial), s.visible = !1;
    else if (s instanceof G)
      Re(s.geometry), Re(s.material), Re(s.customDepthMaterial), Re(s.customDistanceMaterial), s.visible = !1;
    else if (s instanceof M)
      s.visible = !1;
    else if (s instanceof an) {
      Ir(s);
      for (const e of Object.keys(s.attributes)) {
        const t = s.attributes[e];
        Re(t);
      }
    } else if (s instanceof ft || s instanceof Mb)
      Jo && console.warn("BufferAttribute dispose not supported", s.count);
    else if (s instanceof Array)
      for (const e of s)
        e instanceof _e && Re(e);
    else if (s instanceof _e) {
      Ir(s);
      for (const t of Object.keys(s)) {
        const i = s[t];
        i instanceof Te && Re(i);
      }
      const e = s.uniforms;
      if (e)
        for (const t of Object.keys(e)) {
          const i = e[t];
          i instanceof Te ? Re(i) : i instanceof $i && Re(i.value);
        }
    } else s instanceof Te ? (Ir(s), Ir(s.source), s.source?.data instanceof ImageBitmap && Ir(s.source.data)) : s instanceof mx ? (Ir(s.boneTexture), s.boneTexture = null) : s instanceof gx || !(s instanceof M) && Jo && console.warn("Unknown object type", s);
  }
}
function Ir(s) {
  s && ((Jo || x0() || Jd) && console.warn("🧨 FREE", s), s instanceof ImageBitmap || "dispose" in s && typeof s.dispose == "function" && s.dispose());
}
function cL(s) {
}
const aP = /* @__PURE__ */ new Set();
function P0(s, e, t = null, i) {
  if (i || (i = aP, i.clear()), !s) return i;
  const n = s[fc];
  if (n)
    for (const o of n)
      i.has(o) || t?.call(null, o) !== !1 && (i.add(o), e && P0(o, !0, t, i));
  return i;
}
function hL(s) {
  return s[Tl];
}
const Jo = w("debugresourceusers") || w("debugmemory"), fc = Symbol("needle-resource-users"), Tl = Symbol("needle-resource-users-count");
function Bt(s, e) {
  Bm(s, e, function(t, i) {
    br && !uc.raycasting && (ud(fc, this, t, !1), ud(fc, this, i, !0));
  });
}
br && (Bt(G.prototype, "material"), Bt(G.prototype, "geometry"), Bt(_e.prototype, "map"), Bt(_e.prototype, "bumpMap"), Bt(_e.prototype, "alphaMap"), Bt(_e.prototype, "normalMap"), Bt(_e.prototype, "displacementMap"), Bt(_e.prototype, "roughnessMap"), Bt(_e.prototype, "metalnessMap"), Bt(_e.prototype, "emissiveMap"), Bt(_e.prototype, "specularMap"), Bt(_e.prototype, "envMap"), Bt(_e.prototype, "lightMap"), Bt(_e.prototype, "aoMap"), Bt(_e.prototype, "gradientMap"));
function lP(s) {
  if (br === !1) return;
  const e = s[fc];
  if (e)
    for (const t of e)
      ud(fc, t, s, !1);
}
br && Bm(_e.prototype, "dispose", function() {
  lP(this);
});
let kp = 0;
function ud(s, e, t, i) {
  if (kp > 0) return;
  if (Array.isArray(t)) {
    for (const o of t)
      ud(s, e, o, i);
    return;
  }
  if (!t) return;
  let n = t[s];
  if (n || (n = /* @__PURE__ */ new Set()), i) {
    if (e && !n.has(e)) {
      n.add(e);
      let o = t[Tl] || 0;
      o += 1, t[Tl] = o, Jo && console.warn(`🟢 Added user of "${t.type}"`, e, t, o, "users:", n);
    }
  } else if (e && n.has(e)) {
    n.delete(e);
    let o = t[Tl] || 0;
    o > 0 && (o -= 1, t[Tl] = o), Jo && console.warn(`🔴 Removed user of "${t.type}"`, e, t, o, "users:", n), o <= 0 && (oa.isLoading(t) || (Jd && console.warn(`🔴 Removed all user of "${t.type}"`, t), x0() && Re(t)));
  }
  t[s] = n;
}
try {
  Bm(
    mr.prototype,
    "render",
    function() {
      kp++;
    },
    function() {
      kp--;
    }
  );
} catch (s) {
  console.warn("Could not wrap WebGLRenderer.render", s);
}
const Ky = w("debugcomponentevents");
class Vm {
  static eventListeners = /* @__PURE__ */ new Map();
  static addComponentLifecylceEventListener(e, t) {
    this.eventListeners.has(e) && this.eventListeners.set(e, []);
    let i = this.eventListeners.get(e);
    i || (i = []), i.push(t), this.eventListeners.set(e, i), Ky && console.log("Added event listener for " + e, this.eventListeners);
  }
  static removeComponentLifecylceEventListener(e, t) {
    const i = this.eventListeners.get(e);
    if (!i) return;
    const n = i.indexOf(t);
    n < 0 || i.splice(n, 1);
  }
  static dispatchComponentLifecycleEvent(e, t) {
    const i = this.eventListeners.get(e);
    if (Ky && console.log("Dispatching event " + e, i), !!i)
      for (const n of i)
        n(t);
  }
}
const pc = Symbol("NEEDLE_NEED_UPDATE_INSTANCE"), O0 = Symbol("isUsingInstancing"), k0 = Symbol("instancingRenderer"), El = Symbol("instancingAutoUpdateBounds");
class ln {
  /** Is this object rendered using a InstancedMesh */
  static isUsingInstancing(e) {
    return e[O0] === !0;
  }
  /** Returns the instanced mesh IF the object is rendered by an instanced mesh
   * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
   */
  static getRenderer(e) {
    return e[k0] || null;
  }
  setAutoUpdateBounds(e, t) {
    const i = ln.getRenderer(e);
    i && (i[El] = t);
  }
  // TODO: change this so it does not set matrix world directly but some flag that is only used by instancing
  /** Mark an instanced object dirty so the instance matrix will be updated */
  static markDirty(e, t = !0) {
    if (e && (this.isUsingInstancing(e) && (e[pc] = !0, e.matrixWorldNeedsUpdate = !0), t))
      for (const i of e.children)
        ln.markDirty(i, !0);
  }
}
var fd;
((s) => {
  s.experimentalSmartHierarchyUpdate = !1;
})(fd || (fd = {}));
function ra(s, e) {
  try {
    e || s();
  } catch (t) {
    return console.error(t), !1;
  }
  return !0;
}
const Mp = w("debugnewscripts"), cP = w("debughierarchy"), ke = [];
function hP() {
  return ke.length > 0;
}
function pd(s) {
  if (Mp && console.log("Register new components", s.new_scripts.length, [...s.new_scripts], s.alias ? "element: " + s.alias : s.hash, s), s.new_scripts_pre_setup_callbacks.length > 0) {
    for (const e of s.new_scripts_pre_setup_callbacks)
      e && e();
    s.new_scripts_pre_setup_callbacks.length = 0;
  }
  if (!(s.new_scripts.length <= 0)) {
    ke.length = 0, s.new_scripts.length > 0 && ke.push(...s.new_scripts), s.new_scripts.length = 0;
    for (let e = 0; e < ke.length; e++)
      try {
        const t = ke[e];
        if (t.isComponent !== !0) {
          (L() || Mp) && console.error(`Registered script is not a Needle Engine component. 
The script will be ignored. Please make sure your component extends "Behaviour" imported from "@needle-tools/engine"
`, t), ke.splice(e, 1), e--;
          continue;
        }
        if (t.destroyed) continue;
        if (!t.gameObject) {
          console.warn(`Component can not be initialized: no GameObject assigned.
Did you add and remove a component in the same frame?`), ke.splice(e, 1), e--;
          continue;
        }
        t.context = s, Xl(t.gameObject), Hm(t, s);
      } catch (t) {
        console.error(t), hs(ke[e], s), ke.splice(e, 1), e--;
      }
    for (let e = 0; e < ke.length; e++)
      try {
        const t = ke[e];
        if (t.destroyed) {
          hs(ke[e], s), ke.splice(e, 1), e--;
          continue;
        }
        if (t.registering)
          try {
            t.registering();
          } catch (i) {
            console.error(i);
          }
        t.__internalAwake !== void 0 && (t.gameObject || console.error("Calling awake for a component without a GameObject", t, t.gameObject), Xl(t.gameObject), t.activeAndEnabled && ra(t.__internalAwake.bind(t)));
      } catch (t) {
        console.error(t), hs(ke[e], s), ke.splice(e, 1), e--;
      }
    for (let e = 0; e < ke.length; e++)
      try {
        const t = ke[e];
        if (t.destroyed || t.enabled === !1 || (Xl(t.gameObject), t.activeAndEnabled === !1)) continue;
        t.__internalEnable !== void 0 && (t.enabled = !0, ra(t.__internalEnable.bind(t)));
      } catch (t) {
        console.error(t), hs(ke[e], s), ke.splice(e, 1), e--;
      }
    for (let e = 0; e < ke.length; e++)
      try {
        const t = ke[e];
        if (t.destroyed || !t.gameObject) continue;
        s.new_script_start.push(t);
      } catch (t) {
        console.error(t), hs(ke[e], s), ke.splice(e, 1), e--;
      }
    ke.length = 0;
    for (const e of s.new_scripts_post_setup_callbacks)
      e && e();
    s.new_scripts_post_setup_callbacks.length = 0;
  }
}
function dP(s) {
  s && (s.__internalDisable(!0), hs(s, s.context));
}
function M0(s, e) {
  for (let t = 0; t < s.new_script_start.length; t++)
    try {
      const i = s.new_script_start[t];
      if (e !== void 0 && i.gameObject !== e || i.destroyed || i.activeAndEnabled === !1)
        continue;
      ra(i.__internalAwake.bind(i)), i.enabled && (ra(i.__internalEnable.bind(i)), ra(i.__internalStart.bind(i)), s.new_script_start.splice(t, 1), t--);
    } catch (i) {
      console.error(i), hs(s.new_script_start[t], s), s.new_script_start.splice(t, 1), t--;
    }
}
function Hm(s, e) {
  e.scripts.indexOf(s) === -1 && (e.scripts.push(s), s.earlyUpdate && e.scripts_earlyUpdate.push(s), s.update && e.scripts_update.push(s), s.lateUpdate && e.scripts_lateUpdate.push(s), s.onBeforeRender && e.scripts_onBeforeRender.push(s), s.onAfterRender && e.scripts_onAfterRender.push(s), s.onPausedChanged && e.scripts_pausedChanged.push(s), bf(s, null) && e.new_scripts_xr.push(s), bf(s, "immersive-vr") && e.scripts_immersive_vr.push(s), bf(s, "immersive-ar") && e.scripts_immersive_ar.push(s));
}
function hs(s, e) {
  Li(s, e.new_scripts), Li(s, e.new_script_start), Li(s, e.scripts), Li(s, e.scripts_earlyUpdate), Li(s, e.scripts_update), Li(s, e.scripts_lateUpdate), Li(s, e.scripts_onBeforeRender), Li(s, e.scripts_onAfterRender), Li(s, e.scripts_pausedChanged), Li(s, e.new_scripts_xr), Li(s, e.scripts_immersive_vr), Li(s, e.scripts_immersive_ar), e.stopAllCoroutinesFrom(s);
}
function Li(s, e) {
  const t = e.indexOf(s);
  t >= 0 && e.splice(t, 1);
}
function bf(s, e) {
  if (s) {
    const t = s;
    if (t.onBeforeXR || t.onEnterXR || t.onUpdateXR || t.onLeaveXR || t.onXRControllerAdded || t.onXRControllerRemoved)
      return !(e != null && t.supportsXR?.(e) === !1);
  }
  return !1;
}
let Rp = !0;
function vf() {
  Rp = !0;
}
function zh(s, e = !1) {
  if (fd.experimentalSmartHierarchyUpdate) {
    if (!e && !Rp)
      return;
    Rp = !1;
  }
  if (s || (s = ue.Current.scene), !s) {
    console.trace("Invalid call - no current context.");
    return;
  }
  const t = Pc(s);
  R0(s, t, !0) || (Mp || L() ? console.error(`Error updating hierarchy
Do you have circular references in your project? <a target="_blank" href="https://docs.needle.tools/circular-reference"> Click here for more information.`, s) : console.error('Failed to update active state in hierarchy of "' + s.name + '"', s), console.warn(" ↑ this error might be caused by circular references. Please make sure you don't have files with circular references (e.g. one GLB 1 is loading GLB 2 which is then loading GLB 1 again)."));
}
function R0(s, e, t, i = 0) {
  if (i > 1e3)
    return console.warn("Hierarchy is too deep (> 1000 level) - will abort updating active state"), !1;
  const n = Pc(s);
  if (e && (e = n, e && s.parent && i === 0)) {
    const l = s.parent;
    e = l[lo], e === void 0 && (l instanceof wi || (e = !0));
  }
  const r = s[lo] !== e;
  r && (s[lo] = e, cP && console.warn("ACTIVE CHANGE", s.name, n, s.visible, e, "changed?" + r, s), uP(s, (l) => {
    e ? l.enabled && (ra(l.__internalAwake.bind(l)), l.enabled && l.__internalEnable()) : l.__didAwake && l.enabled && (l.__didEnable = !1, l.onDisable());
  }));
  let a = !0;
  if (s.children)
    for (const l of s.children)
      R0(l, e, t, i + 1) === !1 && (a = !1);
  return a;
}
function Xl(s) {
  let e = !0, t = s, i = !1;
  for (; t && t; ) {
    if (t.type === "Scene" && (i = !0), !Pc(t)) {
      e = !1;
      break;
    }
    t = t.parent;
  }
  if (!s) {
    console.error("GO is null");
    return;
  }
  s[lo] = e && i;
}
function uP(s, e) {
  if (s.userData?.components)
    for (const t of s.userData.components)
      e(t);
}
const Uh = /* @__PURE__ */ new Map(), T0 = Symbol("prewarmFlag"), Tp = Symbol("waitingForPrewarm"), Ep = w("debugprewarm");
function fP(s, e) {
  if (!s || s[T0] === !0 || s[Tp] === !0) return;
  Uh.has(e) || Uh.set(e, []), s[Tp] = !0, Uh.get(e).push(s), Ep && console.debug("register prewarm", s.name);
}
let Zy = null, Jy = null;
function pP(s) {
  if (!s) return;
  const e = Uh.get(s);
  if (!e?.length) return;
  const t = s.mainCamera;
  if (t) {
    Ep && console.log("prewarm", e.length, "objects", [...e]);
    const i = s.renderer;
    if (i.compile) {
      const n = s.scene;
      i.compile(n, t), Zy ??= new yx(64), Jy ??= new _x(1e-3, 9999999, Zy), Jy.update(i, n);
      for (const o of e)
        o[T0] = !0, o[Tp] = !1;
      e.length = 0, Ep && console.log("prewarm done");
    }
  }
}
ue.registerCallback(he.ContextCreated, (s) => {
  const e = s.context;
  vP(e), yP(e);
});
const md = w("debugcomponents"), e_ = "eff8ba80-635d-11ec-90d6-0242ac120003";
class At {
  get seed() {
    return this._seed;
  }
  set seed(e) {
    this._seed = e;
  }
  _originalSeed;
  _seed;
  constructor(e) {
    typeof e == "string" && (e = At.hash(e)), this._originalSeed = e, this._seed = e;
  }
  reset() {
    this._seed = this._originalSeed;
  }
  generateUUID(e) {
    if (typeof e == "string")
      return uy(e, e_);
    const t = this._seed;
    return this._seed -= 1, uy(t.toString(), e_);
  }
  initialize(e) {
    typeof e == "string" ? this._seed = At.hash(e) : this._seed = e;
  }
  static createFromString(e) {
    return new At(this.hash(e));
  }
  static hash(e) {
    let t = 0;
    for (let i = 0; i < e.length; i++)
      t = e.charCodeAt(i) + ((t << 5) - t);
    return t;
  }
}
var mP = /* @__PURE__ */ ((s) => (s.NewInstanceCreated = "new-instance-created", s.InstanceDestroyed = "instance-destroyed", s))(mP || {});
class gP {
  guid;
  dontSave;
  constructor(e) {
    this.guid = e;
  }
}
function eu(s, e, t = !0, i) {
  if (!s) return;
  const n = s;
  if (Gi(s, t), !e) {
    console.warn("Can not send destroy: No networking connection provided", s.guid);
    return;
  }
  if (!e.isConnected) {
    L() && console.debug("Can not send destroy: not connected", s.guid);
    return;
  }
  let o = s.guid;
  if (!o && n.uuid && (o = n.uuid), !o) {
    console.warn("Can not send destroy: failed to find guid", s);
    return;
  }
  E0(o, e, i);
}
function E0(s, e, t) {
  const i = new gP(s);
  t?.saveInRoom === !1 && (i.dontSave = !0), e.send("instance-destroyed", i, wn.Queued);
}
function yP(s) {
  s.connection.beginListen("instance-destroyed", (e) => {
    md && console.log("[Remote] Destroyed", s.scene, e);
    const t = W0(e.guid, s.scene);
    t && Gi(t);
  });
}
class dL {
  /** File to download */
  filename;
  /** Checksum to verify its the correct file */
  hash;
  /** Expected size of the referenced file and its dependencies */
  size;
  constructor(e, t, i) {
    this.filename = e, this.hash = t, this.size = i;
  }
}
class _P {
  guid;
  originalGuid;
  seed;
  visible;
  hostData;
  dontSave;
  parent;
  position;
  rotation;
  scale;
  /** Set to true to prevent this model from being instantiated */
  preventCreation = void 0;
  /**
   * When set this will delete the server state when the user disconnects
   */
  deleteStateOnDisconnect;
  constructor(e, t) {
    this.originalGuid = e, this.guid = t;
  }
}
function A0(s, e, t, i) {
  const n = s;
  if (!n.guid)
    return console.warn("Can not instantiate: No guid", n), null;
  if (e.context || (e.context = N.Current), !e.context)
    return console.error("Missing network instantiate options / reference to network connection in sync instantiate"), null;
  const o = e ? { ...e } : null, { instance: r, seed: a } = wP(n, e);
  if (r) {
    const l = r;
    if (l.guid) {
      md && console.log("[Local] new instance", "gameobject:", r?.guid);
      const c = new _P(n.guid, l.guid);
      c.seed = a, e.deleteOnDisconnect === !0 && (c.deleteStateOnDisconnect = !0), o && (o.position && (Array.isArray(o.position) ? c.position = { x: o.position[0], y: o.position[1], z: o.position[2] } : c.position = { x: o.position.x, y: o.position.y, z: o.position.z }), o.rotation && (o.rotation instanceof ot ? o.rotation = new U().setFromEuler(o.rotation) : o.rotation instanceof Array && (o.rotation = new U().fromArray(o.rotation)), c.rotation = { x: o.rotation.x, y: o.rotation.y, z: o.rotation.z, w: o.rotation.w }), o.scale && (Array.isArray(o.scale) ? c.scale = { x: o.scale[0], y: o.scale[1], z: o.scale[2] } : c.scale = { x: o.scale.x, y: o.scale.y, z: o.scale.z })), c.position || (c.position = { x: l.position.x, y: l.position.y, z: l.position.z }), c.rotation || (c.rotation = { x: l.quaternion.x, y: l.quaternion.y, z: l.quaternion.z, w: l.quaternion.w }), c.scale || (c.scale = { x: l.scale.x, y: l.scale.y, z: l.scale.z }), c.visible = n.visible, o?.parent && (typeof o.parent == "string" ? c.parent = o.parent : c.parent = o.parent.guid), c.hostData = t, i === !1 && (c.dontSave = !0), !e?.context?.connection && L() && console.debug("Object will be instantiated but it will not be synced: not connected", n.guid), e.context.connection.isInRoom && Wr.push(new WeakRef(l)), e?.context?.connection.send("new-instance-created", c);
    } else console.warn("Missing guid, can not send new instance event", l);
  }
  return r;
}
function bP() {
  return Math.random() * 9999999;
}
const Wr = new Array();
function vP(s) {
  s.connection.beginListen("new-instance-created", async (e) => {
    const t = await SP(e.originalGuid, s.scene);
    if (e.preventCreation === !0)
      return;
    if (!t) {
      console.warn("could not find object that was instantiated: " + e.guid);
      return;
    }
    const i = new $n();
    e.position && (i.position = new y(e.position.x, e.position.y, e.position.z)), e.rotation && (i.rotation = new U(e.rotation.x, e.rotation.y, e.rotation.z, e.rotation.w)), e.scale && (i.scale = new y(e.scale.x, e.scale.y, e.scale.z)), i.parent = e.parent, e.seed && (i.idProvider = new At(e.seed)), i.visible = e.visible, i.context = s, md && s.alias && console.log("[Remote] instantiate in: " + s.alias);
    const n = ka(t, i);
    Wr.push(new WeakRef(n)), n && (e.parent === "scene" && s.scene.add(n), md && console.log("[Remote] new instance", "gameobject:", n?.guid, t));
  }), s.connection.beginListen("left-room", () => {
    Wr.length > 0 && console.debug(`Left networking room, cleaning up ${Wr.length} instantiated objects`);
    for (const e of Wr) {
      const t = e.deref();
      t && t.destroy();
    }
    Wr.length = 0;
  });
}
function wP(s, e) {
  const t = bP(), i = e ?? new $n();
  i.idProvider = new At(t);
  const n = ka(s, i);
  return { seed: t, instance: n };
}
const I0 = {};
function xP(s, e) {
  I0[s] = e;
}
async function SP(s, e) {
  const t = I0[s];
  if (t != null) {
    const i = await t(s);
    if (i) return i;
  }
  return L0(s, e);
}
function L0(s, e) {
  if (e === null || !s) return null;
  if (e.guid === s)
    return e;
  if (e.children)
    for (const t of e.children) {
      const i = L0(s, t);
      if (i)
        return i;
    }
  return null;
}
const Sc = w("gizmos"), pt = w("debugextension"), wf = w("debugtypes");
class CP {
  _types = /* @__PURE__ */ new Map();
  constructor() {
    wf && console.warn("TypeStore: Created", this);
  }
  /**
   * add a type to the store
   */
  add(e, t) {
    wf && console.warn("ADD TYPE", e);
    const i = this._types.get(e);
    i ? wf && i !== t && console.warn("Type name exists multiple times in your project and may lead to runtime errors:", e) : this._types.set(e, t);
  }
  /**
   * @returns the type for the given key if registered
   */
  get(e) {
    return this._types.get(e) || null;
  }
  /**
   * @returns the key/name for the given type if registered
   */
  getKey(e) {
    for (const [t, i] of this._types)
      if (i === e)
        return t;
    return null;
  }
}
const PP = Symbol("BuiltInType"), P = new CP(), uL = function(s) {
  P.get(s.name) || P.add(s.name, s);
}, Gm = w("debugresolvedependencies"), OP = ["/extensions/", "extensions/"], kP = [
  { prefix: "/nodes/", dependencyName: "node" },
  { prefix: "/meshes/", dependencyName: "mesh" },
  { prefix: "/materials/", dependencyName: "material" },
  { prefix: "/textures/", dependencyName: "texture" },
  { prefix: "/animations/", dependencyName: "animation" },
  // legacy support
  { prefix: "nodes/", dependencyName: "node" },
  { prefix: "meshes/", dependencyName: "mesh" },
  { prefix: "materials/", dependencyName: "material" },
  { prefix: "textures/", dependencyName: "texture" },
  { prefix: "animations/", dependencyName: "animation" }
];
async function qm(s, e) {
  Gm && console.log(s, e);
  const t = [];
  Ap(kP, s, e, t);
  const i = await Promise.all(t);
  return typeof e == "string" && i.length === 1 ? i[0] : i;
}
function MP(s, e) {
  return !s || !e ? !1 : s["needle:identifier"] != null && e["needle:identifier"] != null ? s["needle:identifier"] === e["needle:identifier"] : !1;
}
function RP(s, e) {
  s["needle:identifier"] = e;
}
function Ap(s, e, t, i) {
  if (typeof t == "object" && t !== void 0 && t !== null)
    for (const n of Object.keys(t)) {
      const o = t[n];
      if (typeof o == "string") {
        const r = t_(e, o);
        if (r != null)
          typeof r.then == "function" ? i.push(r.then((a) => t[n] = a)) : t[n] = r;
        else {
          const a = i_(s, e, o);
          if (a) {
            i.push(a.then((l) => (t[n] = l, l)));
            continue;
          }
        }
      } else if (Array.isArray(o))
        for (let r = 0; r < o.length; r++) {
          const a = o[r], l = t_(e, a);
          if (l !== null) {
            typeof l.then == "function" ? i.push(l.then((c) => o[r] = c)) : o[r] = l;
            continue;
          }
          for (const c of s) {
            const h = D0(c.prefix, a);
            if (h >= 0) {
              Gm && console.log(c, h, c.dependencyName), i.push(e.getDependency(c.dependencyName, h).then((d) => o[r] = d));
              break;
            }
          }
          typeof a == "object" && Ap(s, e, a, i);
        }
      else typeof o == "object" && Ap(s, e, o, i);
    }
  else if (typeof t == "string") {
    const n = i_(s, e, t);
    n && i.push(n);
  }
}
function t_(s, e) {
  if (s && s.plugins && typeof e == "string") {
    for (const t of OP)
      if (e.startsWith(t)) {
        let i = e.substring(t.length);
        const n = i.indexOf("/");
        n >= 0 && (i = i.substring(0, n));
        const o = s.plugins[i];
        if (pt && console.log(i, o), typeof o?.resolve == "function") {
          const r = e.substring(t.length + i.length + 1);
          return o.resolve(s, r);
        }
        break;
      }
  }
  return null;
}
function i_(s, e, t) {
  for (const i of s) {
    const n = D0(i.prefix, t);
    if (n >= 0)
      return Gm && console.warn("GET DEPENDENCY", i, n, i.dependencyName), e.getDependency(i.dependencyName, n);
  }
  return null;
}
function D0(s, e) {
  if (typeof e == "string" && e.startsWith(s)) {
    const t = e.substring(s.length), i = Number.parseInt(t);
    if (i >= 0)
      return i;
  }
  return -1;
}
const xf = "NEEDLE_persistent_assets";
function TP(s) {
  return s?.___persistentAsset === !0;
}
class EP {
  get name() {
    return xf;
  }
  parser;
  constructor(e) {
    this.parser = e;
  }
  async afterRoot(e) {
    if (!this.parser?.json?.extensions) return;
    const t = this.parser.json.extensions[xf];
    if (!t) return;
    pt && console.log(t);
    const i = new Array();
    for (const n of t?.assets) {
      const o = qm(this.parser, n);
      o && i.push(o);
    }
    await Promise.all(i);
  }
  resolve(e, t) {
    const i = Number.parseInt(t);
    if (i >= 0) {
      pt && console.log(t);
      const n = e.json.extensions[xf];
      if (n) {
        const o = n?.assets[i];
        if (o && typeof o == "object") {
          o.___persistentAsset = !0;
          const r = o.__type;
          r && P.get(r);
        }
        return o;
      }
    }
    return null;
  }
}
const xn = w("debugserializer");
class AP {
  register(e, t) {
    if (this.typeMap.has(e)) {
      const i = this.typeMap.get(e);
      if (i === t) return;
      xn && console.warn("Type: " + e + " is already registered", t, i);
    }
    xn && console.log("Register type serializer", t.name, t, e), this.typeMap.set(e, t);
  }
  /** type > serializer map */
  typeMap = /* @__PURE__ */ new Map();
  getSerializer(e) {
    if (e)
      return this.typeMap.get(e);
  }
  getSerializerForConstructor(e, t = 0) {
    if (t > 20) return;
    if (!e || !e.constructor) {
      xn && console.log("invalid type");
      return;
    }
    const i = e.name, n = this.getSerializer(e);
    if (n !== void 0)
      return xn && console.log("FOUND SERIALIZER", n?.name, e.name, e.constructor.name, "for type: " + i, n, e, this.typeMap), n;
    const o = Object.getPrototypeOf(e);
    if (o && o !== e) {
      const r = this.getSerializerForConstructor(o, ++t);
      if (r) {
        const a = o.constructor || o.prototype;
        xn && console.log("FOUND SERIALIZER(in constructor) " + a.constructor.name, a.name, a, r), this.register(a, r);
      }
      return r;
    }
    xn && console.warn("No serializer found for " + i, e, e.name, e.constructor.name);
  }
}
const gd = new AP();
class Zi {
  name;
  // register<T>(c: Constructor<T> | Constructor<T>[])
  // {
  //     if (Array.isArray(c)) {
  //         for (const t of c) {
  //             helper.register(t.name, this);
  //         }
  //     }
  //     else {
  //         helper.register(c.name, this);
  //     }
  // }
  constructor(e, t) {
    if (this.name = t, Array.isArray(e))
      for (const i of e)
        gd.register(i, this);
    else
      gd.register(e, this);
  }
}
class IP {
  isDevMode = hn();
  cache = {};
  /** only call when assigning values for the very first time */
  registerDefinedKeys(e, t) {
    if (this.isDevMode && this.cache[e] === void 0) {
      this.cache[e] = Object.keys(t);
      const i = t;
      i.$serializedTypes && Object.keys(i.$serializedTypes) && this.cache[e].push(...Object.keys(i.$serializedTypes)), xn && console.log("registerDefinedKeys for " + e, this.cache[e], t);
    }
  }
  getDefinedKey(e, t) {
    return this.cache[e] === void 0 ? !1 : this.cache[e].includes(t);
  }
}
class j0 {
  root;
  gltf;
  /** the url of the glb that is currently being loaded */
  gltfId;
  object;
  target;
  nodeId;
  nodeToObject;
  objectToNode;
  context;
  path;
  type;
  /** the serializable attribute for this field (target.path) */
  serializable;
  /** holds information if a field was undefined before serialization. This gives us info if we might want to warn the user about missing attributes */
  implementationInformation;
  constructor(e) {
    this.root = e;
  }
}
function LP(s, e) {
  const t = s.$serializedTypes;
  if (t === void 0) return null;
  const i = {};
  for (const o in t) {
    const r = s[o];
    if (r != null && typeof r == "object") {
      const a = gd.getSerializerForConstructor(r);
      if (a) {
        i[o] = a.onSerialize(r, e);
        continue;
      }
    }
    i[o] = r;
  }
  function n(o) {
    const r = P._types;
    for (const [a, l] of r)
      if (l === s.constructor)
        return a;
    return o.__name || o.constructor.name;
  }
  return i.name = n(s), typeof s.guid == "string" && (i.guid = s.guid), i;
}
const Nh = [];
function B0(s, e) {
  if (!s) return e;
  typeof s.$serializedTypes == "object" && (e || (e = {}), Object.assign(e, s.$serializedTypes));
  const t = Object.getPrototypeOf(s);
  return B0(t, e);
}
function Ip(s, e, t) {
  if (!s) return !1;
  if (t.target = s, s.onBeforeDeserialize !== void 0) {
    const n = s.onBeforeDeserialize(e, t);
    if (typeof n == "boolean") return n;
  }
  const i = B0(s);
  if (e) {
    if (typeof e.guid == "string" && (s.guid = e.guid), i)
      for (const n in i) {
        let o = function(l) {
          const h = l.type;
          return h ? Lp(a, h, t, void 0, s[n]) : Lp(a, l, t, void 0, s[n]);
        };
        const r = i[n], a = e[n];
        if (xn && console.log(n, a, s, r), !(s[n] !== void 0 && a === void 0) && (t.type = void 0, t.path = n, t.serializable = r, !(s.onBeforeDeserializeMember !== void 0 && s.onBeforeDeserializeMember(n, a, t) === !0))) {
          if (r === null)
            s[n] = a;
          else {
            if (Array.isArray(r))
              for (let l = 0; l < r.length; l++) {
                const c = r[l], h = o(c);
                if (h !== void 0 || l === r.length - 1) {
                  s[n] = h;
                  break;
                }
              }
            else
              s[n] = o(r);
            Nh.length = 0;
          }
          s.onAfterDeserializeMember !== void 0 && s.onAfterDeserializeMember(n, a, t);
        }
      }
    BP(s, e);
  }
  return jP(s, e, t.implementationInformation), s.onAfterDeserialize !== void 0 && s.onAfterDeserialize(e, t), !0;
}
const DP = w("noerrors");
function jP(s, e, t) {
  if (DP || !e || !hn() || !s || s.constructor && s.constructor[PP] === !0) return;
  const i = s.constructor?.name, n = Object.getOwnPropertyNames(e);
  for (const o of n) {
    if (o === "sourceId") continue;
    const r = s[o];
    if (r == null) continue;
    const a = e[o];
    if (t?.getDefinedKey(i, o) === !1) {
      const l = o.charAt(0).toUpperCase() + o.slice(1);
      t.getDefinedKey(i, l) && (Qo(Wi.Warn, '<strong>Please rename</strong> "' + l + '" to "' + o + '" in ' + i), console.warn('Please use lowercase for field: "' + l + '" in ' + i, a, s));
      continue;
    }
    if (a != null) {
      if (typeof a == "object" && (r === void 0 || !r.isObject3D)) {
        if (typeof a.node == "number" || typeof a.guid == "string") {
          if (a.could_not_resolve)
            continue;
          if (!(r !== void 0 && Object.keys(r).length > 1)) {
            Qo(Wi.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(Object3D)
${o}? : Object3D;

in ${i}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">See documentation</a>`), console.warn(i, o, s[o], s);
            continue;
          }
        } else if (!Array.isArray(r)) {
          const l = r.constructor?.name;
          if (l === "Object" && !r.constructor["did_warn:missing_serializable"]) {
            r.constructor["did_warn:missing_serializable"] = !0;
            const c = 'You might be missing a @serializable(Type) decorator for field "' + o + '" in ' + i + ".ts";
            console.warn(c + `
${o}:`, a, l), Qo(Wi.Warn, "Dev Warning: Are you missing a type in @serializable? Please check the browser console for details");
          }
        }
      }
      if (typeof r == "string" && typeof a == "string" && (a.endsWith(".gltf") || a.endsWith(".glb"))) {
        Qo(Wi.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(AssetReference)
${o}? : AssetReference;

in script ${i}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">documentation</a>`), console.warn(i, o, s[o], s);
        continue;
      }
    }
  }
}
function BP(s, e) {
  for (const t of Object.keys(e)) {
    const i = e[t];
    if (typeof i == "object" && i !== null && i !== void 0) {
      const n = s[t];
      if (!n) {
        xn && console.log(t, "is undefined on", s);
        continue;
      }
      for (const o of Object.keys(i))
        if (n[o] === void 0 && n_(i[o]) && !n_(n)) {
          const a = FP(n, o);
          if (a && (a?.writable === void 0 || a?.writable === !1) && a.set === void 0) {
            xn && console.warn('Property is not writable "' + o + '"', n, a, i[o], n[o]);
            continue;
          }
          n[o] = i[o];
        }
    }
  }
}
function FP(s, e) {
  for (; s; ) {
    const t = Object.getOwnPropertyDescriptor(s, e);
    if (t) return t;
    s = Object.getPrototypeOf(s);
  }
}
function n_(s) {
  switch (typeof s) {
    case "number":
    case "string":
    case "boolean":
      return !0;
  }
  return !1;
}
function Lp(s, e, t, i, n) {
  let o = typeof e == "function" && e.prototype === void 0, r = e;
  if (o)
    try {
      if (r = e?.call(e, n), o = !1, r == null) return;
    } catch (h) {
      console.error("Error in callback", h, s);
    }
  if (t.type = r, !o && n && (n instanceof _e || n instanceof G || n instanceof an || n instanceof ro))
    return n;
  if (i || (i = {
    serializer: gd.getSerializerForConstructor(r)
  }), n && typeof n == "object" && TP(n)) {
    if (n.__concreteInstance)
      return n.__concreteInstance;
    const h = n;
    if (!h.$serializedTypes && r.prototype.$serializedTypes && (h.$serializedTypes = r.prototype.$serializedTypes), h.$serializedTypes && Ip(h, s, t), n && r !== void 0)
      try {
        let d = null;
        i.serializer && (d = i.serializer.onDeserialize(s, t)), d || (d = new r(), pt && console.log("Create concrete instance for persistent asset", n, "instance:", d), Ca(d, n)), n.__concreteInstance = d, n = d;
      } catch (d) {
        console.error("Error creating instance or creating values on instance", d, n, r);
      }
    return n;
  }
  if (Array.isArray(s)) {
    const h = [];
    for (let d = 0; d < s.length; d++) {
      const f = s[d], p = Lp(f, e, t, i, f);
      h.push(p);
    }
    return h;
  }
  const a = i?.serializer;
  if (a)
    return a.onDeserialize(s, t);
  if (n instanceof Te) return n;
  let l;
  if (s && (s.isMaterial || s.isTexture || s.isObject3D || s instanceof ro))
    l = s;
  else {
    if (s === void 0) return;
    if (s === null && (r === _e || r === Te || r === G || r === ro))
      return null;
    try {
      l = new r(...zP(s));
    } catch (h) {
      console.error("Error creating " + t.path, t.target, h);
      return;
    }
  }
  const c = l;
  return c.$serializedTypes && Ip(c, s, t), l;
}
function zP(s) {
  if (Nh.length = 0, typeof s == "object" && s !== null && s !== void 0)
    for (const e of Object.keys(s))
      Nh.push(s[e]);
  return Nh;
}
const Dp = Symbol("assigned component properties");
function Ca(s, e, t, i) {
  if (e == null || s == null) return;
  s[Dp] = !0;
  const n = s.constructor?.name ?? "unknown";
  t?.registerDefinedKeys(n, s);
  for (const o of Object.keys(e)) {
    const r = UP(s, o);
    if (typeof r?.value != "function" && (!r || r.writable === !0 || r.set !== void 0)) {
      const a = e[o], l = s[o];
      s[o] = a, i?.onAssigned && i.onAssigned(s, o, l, a);
    }
  }
  delete s[Dp];
}
function UP(s, e) {
  let t;
  do
    t = Object.getOwnPropertyDescriptor(s, e);
  while (!t && (s = Object.getPrototypeOf(s)));
  return t;
}
const F0 = Symbol("customVisibilityFlag");
function ds(s, e) {
  s.layers[F0] = e;
}
const s_ = Symbol("DidPatchLayers");
function NP() {
  const s = ho.prototype;
  if (s[s_]) return;
  s[s_] = !0;
  const e = s.test;
  s.test = function(t) {
    return this[F0] === !1 ? !1 : e.call(this, t);
  };
}
NP();
Object.defineProperty(de.prototype, "fov", {
  get: function() {
    return this._fov;
  },
  set: function(s) {
    const e = s !== this._fov;
    this._fov = s, e && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
Object.defineProperty(de.prototype, "near", {
  get: function() {
    return this._near;
  },
  set: function(s) {
    const e = s !== this._near;
    this._near = s, e && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
Object.defineProperty(de.prototype, "far", {
  get: function() {
    return this._far;
  },
  set: function(s) {
    const e = s !== this._far;
    this._far = s, e && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
const z0 = /* @__PURE__ */ new Map();
function $P(s, e) {
  if (!s) return;
  if (!e) {
    console.warn("No prototype found", s, s.prototype, s.constructor);
    return;
  }
  const t = z0.get(e);
  t && t.apply(s);
}
function WP(s) {
  const e = VP(s.prototype);
  z0.set(s, e);
}
function VP(s) {
  return new HP(s);
}
class HP {
  $symbol;
  extensions;
  descriptors;
  constructor(e) {
    this.$symbol = Symbol("prototype-extension"), this.extensions = Object.keys(e), this.descriptors = new Array();
    for (let t = 0; t < this.extensions.length; t++) {
      const i = this.extensions[t], n = Object.getOwnPropertyDescriptor(e, i);
      n && this.descriptors.push(n);
    }
  }
  apply(e) {
    if (!e[this.$symbol]) {
      e[this.$symbol] = !0;
      for (let t = 0; t < this.extensions.length; t++) {
        const i = this.extensions[t], n = this.descriptors[t];
        n && Object.defineProperty(e, i, n);
      }
    }
  }
}
const GP = w("debuggetcomponent"), o_ = () => GP || globalThis.NEEDLE_DEBUG_GETCOMPONENT === !0;
function qP(s) {
  return s == null || s.isObject3D ? s : s.object && s.object.isObject3D ? s.object : s;
}
function U0(s, e) {
  if (!s || !s.userData.components) return e;
  const t = s.userData.components.indexOf(e);
  return t < 0 || (Vm.dispatchComponentLifecycleEvent("removing-component", e), e.gameObject = null, s.userData.components.splice(t, 1)), e;
}
function tu(s, e, t) {
  const i = Da(s, e);
  return i || An(s, e, t);
}
const N0 = new At("addComponentIdProvider");
function aa(s, e, t = !0) {
  s.userData || (s.userData = {}), s.userData.components || (s.userData.components = []), s.userData.components.push(e), e.gameObject = s, (e.guid === void 0 || e.guid === "invalid") && (e.guid = N0.generateUUID()), Qm(s), Jm(e, e.context);
  try {
    t && e.__internalAwake && (Xl(s), e.activeAndEnabled && e.__internalAwake()), Vm.dispatchComponentLifecycleEvent("component-added", e);
  } catch (i) {
    console.error(i);
  }
  return e;
}
function An(s, e, t, i) {
  if (typeof e == "function") {
    const n = new e();
    t && n.__internalNewInstanceCreated(t);
    let o = !0;
    return i?.callAwake != null && (o = i.callAwake), aa(s, n, o);
  }
  if (e.destroyed)
    return console.warn("Can not move/add a destroyed component", e), e;
  if (e.gameObject === s) return e;
  if (e.gameObject && e.gameObject.userData?.components) {
    const n = e.gameObject.userData.components.indexOf(e);
    e.gameObject.userData.components.splice(n, 1);
  }
  if (s.userData || (s.userData = {}), !s.userData.components) s.userData.components = [];
  else if (s.userData.components.includes(e)) return e;
  return s.userData.components.push(e), e.gameObject = s, (e.guid === void 0 || e.guid === "invalid") && (e.guid = N0.generateUUID()), t && e._internalInit(t), Jm(e, e.context), e;
}
function XP(s) {
  if (s.gameObject && s.gameObject.userData.components) {
    const e = s.gameObject.userData.components.indexOf(s);
    s.gameObject.userData.components.splice(e, 1);
  }
  s.__internalDisable && s.__internalDisable(), hs(s, s.context ?? N.Current), s.destroy(), s.gameObject = null;
}
let r_ = !1;
function $0(s, e, t) {
  if (s == null) return null;
  if (!s.isObject3D)
    return console.error("Object is not object3D"), null;
  if (!s?.userData?.components || (typeof e == "string" && (r_ || (r_ = !0, console.warn(`Accessing components by name is not supported.
Please use the component type instead. This may keep working in local development but it will fail when bundling your application.

You can import other modules your main module to get access to types
or if you use npmdefs you can make types available globally using globalThis:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis`, e))), o_() && console.log("[onGetComponent] FIND", e), e == null))
    return null;
  for (let i = 0; i < s.userData.components.length; i++) {
    const n = s.userData.components[i];
    let o = Object.getPrototypeOf(n);
    for (; o; ) {
      if (o === e.prototype)
        if (o_() && console.log("[onGetComponent] MATCH BY PROTOYPE", o), t) t.push(n);
        else return n;
      o = Object.getPrototypeOf(o);
    }
  }
  return t || null;
}
function Da(s, e) {
  const t = $0(s, e);
  return t ? Array.isArray(t) ? t[0] : t : null;
}
function iu(s, e, t, i = !0) {
  return t || (t = []), i && (t.length = 0), $0(s, e, t), t;
}
function nu(s, e, t) {
  if (t === !1 && s[lo] === !1) return null;
  const i = Da(s, e);
  if (t === !1 && i?.enabled === !1) return null;
  if (i) return i;
  for (let n = 0; n < s?.children?.length; n++) {
    const o = nu(s.children[n], e);
    if (o) return o;
  }
  return null;
}
function Cc(s, e, t, i = !0) {
  t || (t = []), i && (t.length = 0), iu(s, e, t, !1);
  for (let n = 0; n < s?.children?.length; n++)
    Cc(s.children[n], e, t, !1);
  return t;
}
function yd(s, e) {
  if (!s) return null;
  if (Array.isArray(s)) {
    for (let i = 0; i < s.length; i++) {
      const n = qP(s[i]), o = yd(n, e);
      if (o) return o;
    }
    return null;
  }
  const t = Da(s, e);
  return t || (s.parent ? yd(s.parent, e) : null);
}
function Xm(s, e, t, i = !0) {
  return t || (t = []), i && (t.length = 0), s ? (iu(s, e, t, !1), s.parent ? Xm(s.parent, e, t, !1) : t) : t;
}
function su(s, e = void 0, t = !0) {
  if (!s) return null;
  if (!e && (e = N.Current, !e))
    return console.error("Can not search object without any needle context or scene!!!"), null;
  let i = e;
  if (i.isScene || (i = e?.scene), !i) return null;
  const n = nu(i, s, t);
  return n || null;
}
function QP(s, e, t = void 0) {
  if (!s) return e ?? [];
  if (e || (e = []), e.length = 0, !t && (t = N.Current, !t))
    return console.error("Can not search object without any needle context or scene!!!"), e;
  "scene" in t && (t = t.scene);
  const i = t;
  return i && Cc(i, s, e, !1), e;
}
function Qm(s) {
  s && s.isObject3D === !0 && $P(s, M);
}
if (fd.experimentalSmartHierarchyUpdate) {
  const s = M.prototype.add;
  M.prototype.add = function(...i) {
    return vf(), s.apply(this, i);
  };
  const e = M.prototype.attach;
  M.prototype.attach = function(...i) {
    return vf(), e.apply(this, i);
  };
  const t = M.prototype.remove;
  M.prototype.remove = function(...i) {
    return vf(), t.apply(this, i);
  };
}
M.prototype.SetActive = function(s) {
  this.visible = s;
};
M.prototype.setActive = function(s) {
  this.visible = s;
};
M.prototype.destroy = function() {
  Gi(this);
};
M.prototype.addComponent = function(s, e) {
  return An(this, s, e);
};
M.prototype.addNewComponent = function(s, e) {
  return An(this, s, e);
};
M.prototype.removeComponent = function(s) {
  return U0(this, s);
};
M.prototype.getOrAddComponent = function(s, e) {
  return tu(this, s, e);
};
M.prototype.getComponent = function(s) {
  return Da(this, s);
};
M.prototype.getComponents = function(s, e) {
  return iu(this, s, e);
};
M.prototype.getComponentInChildren = function(s) {
  return nu(this, s);
};
M.prototype.getComponentsInChildren = function(s, e) {
  return Cc(this, s, e);
};
M.prototype.getComponentInParent = function(s) {
  return yd(this, s);
};
M.prototype.getComponentsInParent = function(s, e) {
  return Xm(this, s, e);
};
Object.getOwnPropertyDescriptor(M.prototype, "activeSelf") || Object.defineProperty(M.prototype, "activeSelf", {
  get: function() {
    return Pc(this);
  },
  set: function(s) {
    Wh(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldPosition") || Object.defineProperty(M.prototype, "worldPosition", {
  get: function() {
    return this instanceof Db ? Z(this.object) : Z(this);
  },
  set: function(s) {
    Ot(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldQuaternion") || Object.defineProperty(M.prototype, "worldQuaternion", {
  get: function() {
    return this instanceof Db ? be(this.object) : be(this);
  },
  set: function(s) {
    jn(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldRotation") || Object.defineProperty(M.prototype, "worldRotation", {
  get: function() {
    return Dm(this);
  },
  set: function(s) {
    JC(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldScale") || Object.defineProperty(M.prototype, "worldScale", {
  get: function() {
    return Qe(this);
  },
  set: function(s) {
    hc(this, s);
  }
});
const YP = new ee(), KP = new y(0, 0, 0), ZP = new y(0, 1, 0);
Object.getOwnPropertyDescriptor(M.prototype, "worldForward") || Object.defineProperty(M.prototype, "worldForward", {
  get: function() {
    return H().set(0, 0, 1).applyQuaternion(be(this));
  },
  set: function(s) {
    const e = ui().setFromRotationMatrix(YP.lookAt(KP.set(0, 0, 0), s, ZP.set(0, 1, 0)));
    this.worldQuaternion = e;
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldRight") || Object.defineProperty(M.prototype, "worldRight", {
  get: function() {
    return H().set(1, 0, 0).applyQuaternion(be(this));
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldUp") || Object.defineProperty(M.prototype, "worldUp", {
  get: function() {
    return H().set(0, 1, 0).applyQuaternion(be(this));
  }
});
WP(M);
class oe extends se {
  alpha = 1;
  get isRGBAColor() {
    return !0;
  }
  set a(e) {
    this.alpha = e;
  }
  get a() {
    return this.alpha;
  }
  constructor(e, t, i, n) {
    super(), typeof e == "number" && typeof t == "number" && typeof i == "number" ? (this.set(e, t, i), this.alpha = typeof n == "number" ? n : 1) : e !== void 0 && (this.set(e), this.alpha = 1);
  }
  clone() {
    const e = super.clone();
    return e.alpha = this.alpha, e;
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, "alpha" in e && typeof e.alpha == "number" ? this.alpha = e.alpha : typeof e.a == "number" && (this.alpha = e.a), this;
  }
  lerp(e, t) {
    const i = e;
    return i.alpha != null && (this.alpha = j.lerp(this.alpha, i.alpha, t)), super.lerp(e, t);
  }
  lerpColors(e, t, i) {
    const n = e, o = t;
    return n.alpha != null && o.alpha != null && (this.alpha = j.lerp(n.alpha, o.alpha, i)), super.lerpColors(e, t, i);
  }
  multiply(e) {
    const t = e;
    return t.alpha != null && (this.alpha = this.alpha * t.alpha), super.multiply(e);
  }
  fromArray(e, t = 0) {
    return this.alpha = e[t + 3], super.fromArray(e, t);
  }
  static fromColorRepresentation(e) {
    if (typeof e == "string") {
      if (e.trim() === "transparent")
        return new oe(0, 0, 0, 0);
      if (e.startsWith("#") && e.length === 9) {
        const t = parseInt(e.slice(1, 9), 16), i = t >> 24 & 255, n = t >> 16 & 255, o = t >> 8 & 255, r = t >> 0 & 255;
        return new oe(i / 255, n / 255, o / 255, r / 255);
      } else if (e.startsWith("#")) {
        const t = parseInt(e.slice(1), 16), i = t >> 16 & 255, n = t >> 8 & 255, o = t >> 0 & 255;
        return new oe(i / 255, n / 255, o / 255, 1);
      } else if (e.startsWith("rgba")) {
        const t = e.slice(5, -1).split(",").map(Number);
        return new oe(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
      } else if (e.startsWith("rgb")) {
        const t = e.slice(4, -1).split(",").map(Number);
        return new oe(t[0] / 255, t[1] / 255, t[2] / 255, 1);
      }
    } else if (Array.isArray(e)) {
      if (e.length === 4)
        return new oe(e[0], e[1], e[2], e[3]);
      if (e.length === 3)
        return new oe(e[0], e[1], e[2], 1);
      console.error("Invalid color array length. Expected 3 or 4, got " + e.length);
    }
    return new oe(e);
  }
}
const $h = w("debuggetcomponent"), er = w("debuginstantiate");
class $n {
  idProvider;
  parent;
  keepWorldPosition;
  position;
  rotation;
  scale;
  visible;
  context;
  components;
  clone() {
    const e = new $n();
    return e.idProvider = this.idProvider, e.parent = this.parent, e.keepWorldPosition = this.keepWorldPosition, e.position = Array.isArray(this.position) ? [...this.position] : this.position?.clone(), e.rotation = Array.isArray(this.rotation) ? [...this.rotation] : this.rotation?.clone(), e.scale = Array.isArray(this.scale) ? [...this.scale] : this.scale?.clone(), e.visible = this.visible, e.context = this.context, e.components = this.components, e;
  }
  /** Copy fields from another object, clone field references */
  cloneAssign(e) {
    this.idProvider = e.idProvider, this.parent = e.parent, this.keepWorldPosition = e.keepWorldPosition, this.position = Array.isArray(e.position) ? [...e.position] : e.position?.clone(), this.rotation = Array.isArray(e.rotation) ? [...e.rotation] : e.rotation?.clone(), this.scale = Array.isArray(e.scale) ? [...e.scale] : e.scale?.clone(), this.visible = e.visible, this.context = e.context, this.components = e.components;
  }
}
function Pc(s) {
  return s.visible;
}
function Wh(s, e) {
  return typeof e == "number" && (e = e > 0.5), s.visible = e, s.visible;
}
function JP(s) {
  return s[lo] || Ym(s);
}
function eO(s, e) {
  s[O0] = e;
}
function Ym(s) {
  return ln.isUsingInstancing(s);
}
function W0(s, e) {
  return cc(s, e, !0, !0);
}
const V0 = Symbol("isDestroyed");
function Pa(s) {
  return s[V0];
}
function tO(s, e) {
  s[V0] = e;
}
const jp = Symbol("isDontDestroy");
function hl(s, e = !0) {
  s[jp] = e;
}
const Vh = [], Hh = [];
function Gi(s, e = !0, t = !1) {
  Vh.length = 0, Hh.length = 0, Bp(s, e, !0);
  for (const i of Vh)
    i.gameObject = null, i.context = null;
  for (const i of Hh)
    tO(i, !0), t && Re(i);
  Hh.length = 0, Vh.length = 0;
}
function Bp(s, e = !0, t = !0) {
  if (s == null)
    return;
  const i = s;
  if (i.isComponent) {
    if (i[jp]) return;
    Vh.push(i);
    const r = i.gameObject;
    i.__internalDisable(), i.__internalDestroy(), i.gameObject = r;
    return;
  }
  if (s[jp]) return;
  const n = s;
  $h && console.log(n), Hh.push(n);
  const o = n.userData?.components;
  if (o != null && Array.isArray(o)) {
    let r = o.length;
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      Bp(l, e, !1), o.length < r && (r = o.length, a--);
    }
  }
  if (e && n.children)
    for (const r of n.children)
      Bp(r, e, !1);
  t && n.removeFromParent();
}
function Oa(s, e, t = !0) {
  return H0(s, e, t);
}
function* Km(s, e, t = !1, i = 999, n = 0) {
  if (s?.userData.components && !(n > i)) {
    for (const o of s.userData.components)
      e && o?.isComponent === !0 && o instanceof e ? yield o : yield o;
    if (t === !0)
      for (const o of s.children)
        yield* Km(o, e, !0, i, n + 1);
  }
}
function H0(s, e, t, i = 0) {
  if (s) {
    if (s.isObject3D, i > 1e3) {
      console.warn("Failed to iterate components: too many levels");
      return;
    }
    if (s.userData?.components)
      for (let n = 0; n < s.userData.components.length; n++) {
        const o = s.userData.components[n];
        if (o?.isComponent === !0) {
          const r = e(o);
          if (r !== void 0) return r;
        }
      }
    if (t && s.children) {
      const n = i + 1;
      for (let o = 0; o < s.children.length; o++) {
        const r = s.children[o];
        if (!r) continue;
        const a = H0(r, e, t, n);
        if (a !== void 0) return a;
      }
    }
  }
}
function ka(s, e) {
  if ("isAssetReference" in s)
    return s.instantiate(e ?? void 0);
  let t = null;
  e != null && (e.x !== void 0 ? (t = new $n(), t.position = e) : t = e);
  let i = N.Current;
  t?.context && (i = t.context), $h && i.alias && console.log("context", i.alias), t && !t.idProvider && (t.idProvider = new At(Date.now()));
  const n = [], o = {}, r = {}, a = G0(i, s, t, n, o, r);
  a && (sO(a, o), nO(r, o)), $h && (wp(s, !0), wp(a, !0));
  const l = {};
  if (t?.components !== !1) {
    for (const c in n) {
      const h = n[c], d = h.guid;
      t && t.idProvider && (h.guid = t.idProvider.generateUUID(), l[d] = h.guid, $h && console.log(h.name, h.guid)), Jm(h, i), h.__internalNewInstanceCreated && h.__internalNewInstanceCreated();
    }
    for (const c in n) {
      const h = n[c];
      h.resolveGuids && h.resolveGuids(l), h.enabled !== !1 && (h.enabled = !0);
    }
    pd(i);
  }
  return a;
}
function G0(s, e, t, i, n, o) {
  if (!e || e[pi])
    return null;
  const r = e.userData;
  e.userData = {};
  const a = e.children;
  e.children = [];
  const l = e.clone(!1);
  if (Qm(l), e.userData = r, e.children = a, n[e.uuid] = { original: e, clone: l }, er && console.log("ADD", e, l), e.type === "SkinnedMesh" && (o[e.uuid] = { original: e, clone: l }), t?.visible !== void 0 && (l.visible = t.visible), t?.idProvider) {
    l.uuid = t.idProvider.generateUUID();
    const h = l;
    h && (h.guid = l.uuid);
  }
  e.animations && e.animations.length > 0 && (l.animations = [...e.animations]);
  const c = e.parent;
  if (c && c.add(l), t?.position)
    if (Array.isArray(t.position)) {
      const h = new y();
      h.fromArray(t.position), l.worldPosition = h;
    } else
      l.worldPosition = t.position;
  else l.position.copy(e.position);
  if (t?.rotation) {
    if (t.rotation instanceof U)
      l.worldQuaternion = t.rotation;
    else if (t.rotation instanceof ot)
      l.worldQuaternion = ui().setFromEuler(t.rotation);
    else if (Array.isArray(t.rotation)) {
      const h = new ot();
      h.fromArray(t.rotation), l.worldQuaternion = ui().setFromEuler(h);
    }
  } else l.quaternion.copy(e.quaternion);
  if (t?.scale)
    if (Array.isArray(t.scale)) {
      const h = new y();
      h.fromArray(t.scale), t.scale = h;
    } else
      l.scale.copy(t.scale);
  else l.scale.copy(e.scale);
  if (t?.parent && t.parent !== "scene") {
    let h = null;
    if (typeof t.parent == "string" ? h = cc(t.parent, s.scene, !0) : h = t.parent, h) {
      const d = t.keepWorldPosition === !0 ? h.attach : h.add;
      d ? d.call(h, l) : console.error("Invalid parent object", h, "received when instantiating:", e);
    } else console.warn("could not find parent:", t.parent);
  }
  for (const [h, d] of Object.entries(e.userData))
    h !== "components" && (l.userData[h] = d);
  if (e.userData?.components) {
    const h = e.userData.components, d = [];
    l.userData.components = d;
    for (let f = 0; f < h.length; f++) {
      const p = h[f], g = new p.constructor();
      iO(p, g), p[Fh] !== void 0 && (g[Fh] = p[Fh]), d.push(g), g.gameObject = l, i.push(g), n[p.guid] = { original: p, clone: g }, Vm.dispatchComponentLifecycleEvent("component-added", g);
    }
  }
  t && (t.position = void 0, t.rotation = void 0, t.scale = void 0, t.parent = void 0, t.visible = void 0);
  for (const h in e.children) {
    const d = e.children[h], f = G0(s, d, t, i, n, o);
    f && (n[f.uuid] = { original: d, clone: f }, l.add(f));
  }
  return l;
}
function iO(s, e, t) {
  Ca(e, s, void 0, {
    // onAssigned: (target, key, _oldValue, value) => {
    // if (value !== null && typeof value === "object") {
    //     const serializable = target as ISerializable;
    //     if (serializable?.$serializedTypes?.[key]) {
    //         if (!(value instanceof Object3D)) {
    //             // let clone = null;
    //             // if ("clone" in value) {
    //             //     if (canClone(value)) clone = (value as any).clone();
    //             // }
    //             // else {
    //             //     clone = Object.assign(Object.create(Object.getPrototypeOf(value)), value);
    //             // }
    //             // if (clone) {
    //             //     console.debug(key, { target, value, clone })
    //             //     target[key] = clone;
    //             //     findNestedReferences(clone, objectsMap);
    //             // }
    //             // else console.debug("Could not clone value for key", key, value);
    //         }
    //         else {
    //             console.log("ASSIGNED", value)
    //         }
    //         recursiveAssign(target, target[key], newObjectsMap);
    //     }
    // }
    // }
  });
}
function nO(s, e) {
  for (const t in s) {
    const i = s[t], n = i.original, o = n.skeleton, r = i.clone;
    if (!o) {
      console.warn("Skinned mesh has no skeleton?", i);
      continue;
    }
    const a = o.bones, l = r.skeleton.clone();
    r.skeleton = l, r.bindMatrix.clone().copy(n.bindMatrix), r.bindMatrixInverse.copy(n.bindMatrixInverse);
    const c = [];
    l.bones = c;
    for (let h = 0; h < a.length; h++) {
      const d = a[h], p = e[d.uuid].clone;
      c.push(p);
    }
  }
  for (const t in s) {
    const i = s[t].clone;
    i.skeleton.update(), i.bind(i.skeleton, i.bindMatrix), i.updateMatrixWorld(!0);
  }
}
function sO(s, e) {
  for (const t in e) {
    const n = e[t].clone;
    if (n?.isObject3D && n?.userData?.components)
      for (let o = 0; o < n.userData.components.length; o++) {
        const r = n.userData.components[o], a = Object.entries(r);
        for (const [l, c] of a)
          if (Array.isArray(c)) {
            const h = [];
            r[l] = h;
            for (let d = 0; d < c.length; d++) {
              const f = c[d];
              if (typeof f != "object") {
                h.push(f);
                continue;
              }
              const p = a_(r, l, f, e);
              p !== void 0 ? (er && console.log("Found new instance for", l, f, "->", p), h.push(p)) : (er && console.warn("Could not find new instance for", l, f), h.push(f));
            }
          } else if (typeof c == "object") {
            const h = a_(r, l, c, e);
            h !== void 0 ? r[l] = h : er && console.warn("Could not find new instance for", l, c);
          }
      }
  }
}
function a_(s, e, t, i) {
  if (t != null)
    if (t.isComponent === !0) {
      const n = t.gameObject;
      if (n) {
        const o = n.uuid, r = i[o]?.clone;
        if (!r) {
          er && console.log("reference did not change", e, s, t);
          return;
        }
        const a = n.userData.components.indexOf(t);
        if (a >= 0 && r.isObject3D)
          return er && console.log(e, o), r.userData.components[a];
        console.warn("could not find component", e, t);
      }
    } else if (t.isObject3D === !0) {
      if (e === "gameObject") return;
      const n = t;
      if (n) {
        const o = n.uuid, r = i[o]?.clone;
        if (r)
          return er && console.log(e, "old", t, "new", r), r;
      }
    } else {
      if (t.isVector4 || t.isVector3 || t.isVector2 || t.isQuaternion || t.isEuler)
        return t.clone();
      if (t.isColor === !0)
        return t.clone();
      if (t.isEventList === !0)
        return t.__internalOnInstantiate(i);
    }
}
var Ma;
((s) => {
  s.baseUrl = "https://networking.needle.tools";
  function i(h) {
    return fy(new Uint8Array(h));
  }
  s.hashMD5 = i;
  function n(h) {
    const d = fy(new Uint8Array(h), { encoding: "binary", asBytes: !0 });
    return btoa(String.fromCharCode(...d));
  }
  s.hashMD5_Base64 = n;
  function o(h) {
    const d = new Uint8Array(h);
    return crypto.subtle.digest("SHA-256", d).then((p) => btoa(String.fromCharCode(...new Uint8Array(p))));
  }
  s.hashSha256 = o;
  function r(h) {
    const d = h.filesize / 1024 / 1024;
    return vs() ? d < 50 : d < 5;
  }
  s.canUpload = r;
  async function a(h, d) {
    const f = s.baseUrl;
    if (f) {
      if (!h.name)
        return console.error("Upload: file name is missing"), null;
    } else return console.error("Blob storage base url is not set"), null;
    let p = null;
    h instanceof File ? p = await h.arrayBuffer() : p = h.data;
    const g = p.byteLength, b = g / 1024 / 1024;
    if (b > 50)
      return d?.silent !== !0 && ge(`File (${b.toFixed(1)}MB) is too large for uploading (see console for details)`), console.warn(`Your file is too large for uploading (${b.toFixed(1)}MB). Max allowed size is 50MB`), null;
    if (!vs() && b > 5)
      return d?.silent !== !0 && ge('File is too large for uploading. Please get a <a href="https://needle.tools/pricing" target="_blank">commercial license</a> to upload files larger than 5MB'), console.warn(`Your file is too large for uploading (${b.toFixed(1)}MB). Max size is 5MB for non-commercial users. Please get a commercial license at https://needle.tools/pricing for larger files (up to 50MB)`), null;
    if (g < 1)
      return console.warn(`Your file is too small for uploading (${b.toFixed(1)}MB). Min size is 1 byte`), null;
    const m = n(p), v = {
      filename: h.name,
      "Content-Md5": m,
      // "x-amz-checksum-sha256": checksum,
      // "X-Amz-Content-Sha256": checksum,
      "Content-Type": h.type || "application/octet-stream",
      FileSize: g.toString(),
      // enforced by the server
      "Content-Disposition": `attachment; filename="${h.name}"`,
      // enforced by the server
      "x-amz-server-side-encryption": "AES256"
    }, _ = await fetch(f + "/api/needle/blob", {
      method: "POST",
      headers: v,
      signal: d?.abort
    }).then((x) => x.json()).catch((x) => (console.error(x), null));
    if (_ == null)
      return console.warn("Upload failed..."), null;
    if ("error" in _)
      return console.error(_.error), null;
    if ("upload" in _ && _.upload) {
      let x = function(k) {
        return d?.onProgress?.call(null, { progress01: 0, state: "inprogress" }), fetch(k, {
          method: "PUT",
          headers: v,
          body: p,
          signal: d?.abort
        }).then((B) => (d?.onProgress?.call(null, { progress01: 1, state: "finished" }), B)).catch((B) => B);
      };
      console.debug("Uploading file", _.upload);
      let I = !1, O = null;
      for (let k = 0; k < 3; k++)
        try {
          if (I) break;
          if (d?.abort?.aborted)
            return console.debug("Aborted upload"), null;
          const E = await x(_.upload);
          E instanceof Error ? (O = E, await Os(1e3 * k)) : E.ok && (console.debug("File uploaded successfully"), I = !0);
        } catch (E) {
          console.error(E);
        }
      if (!I)
        return console.error(O?.message || "Failed to upload file"), null;
    }
    if ("download" in _) {
      const x = f + _.download;
      return console.debug("File found in blob storage", x), {
        key: _.key,
        success: !0,
        download_url: x
      };
    }
    return null;
  }
  s.upload = a;
  function l(h) {
    return `${s.baseUrl}/api/needle/blob/${h}`;
  }
  s.getBlobUrlForKey = l;
  async function c(h, d) {
    const f = new xm();
    f.setResponseType("arraybuffer");
    const p = await f.loadAsync(h, (g) => {
      d && d.call(null, g);
    });
    return p instanceof ArrayBuffer ? new Uint8Array(p) : (console.error("Download failed, no arraybuffer returned"), null);
  }
  s.download = c;
})(Ma || (Ma = {}));
const Bs = w("debugaddressables");
class oO {
  _context;
  _assetReferences = {};
  /** @internal */
  constructor(e) {
    this._context = e, this._context.pre_update_callbacks.push(this.preUpdate);
  }
  /** @internal */
  dispose() {
    const e = this._context.pre_update_callbacks.indexOf(this.preUpdate);
    e >= 0 && this._context.pre_update_callbacks.splice(e, 1);
    for (const t in this._assetReferences)
      this._assetReferences[t]?.unload();
    this._assetReferences = {};
  }
  preUpdate = () => {
  };
  /**
   * Find a registered AssetReference by its URL
   */
  findAssetReference(e) {
    return this._assetReferences[e] || null;
  }
  /** 
   * Register an asset reference
   * @internal
   */
  registerAssetReference(e) {
    return e.url && (this._assetReferences[e.url] ? console.warn("Asset reference already registered", e) : this._assetReferences[e.url] = e), e;
  }
  /** @internal */
  unregisterAssetReference(e) {
    e.url && delete this._assetReferences[e.url];
  }
}
const Sf = Symbol("assetReference");
class ie {
  /**
   * Get an AssetReference for a URL to be easily loaded.  
   * AssetReferences are cached so calling this method multiple times with the same arguments will always return the same AssetReference.
   * @param url The URL of the asset to load. The url can be relative or absolute.
   * @param context The context to use for loading the asset  
   * @returns the AssetReference for the URL
   */
  static getOrCreateFromUrl(e, t) {
    if (!t && (t = N.Current, !t))
      throw new Error('Context is required when sourceId is a string. When you call this method from a component you can call it with "getOrCreate(this, url)" where "this" is the component.');
    const i = t.addressables, n = i.findAssetReference(e);
    if (n) return n;
    const o = new ie(e, t.hash);
    return i.registerAssetReference(o), o;
  }
  /** 
   * Get an AssetReference for a URL to be easily loaded.   
   * AssetReferences are cached so calling this method multiple times with the same arguments will always return the same AssetReference.
   */
  static getOrCreate(e, t, i) {
    if (typeof e == "string") {
      if (!i && (i = N.Current, !i))
        throw new Error('Context is required when sourceId is a string. When you call this method from a component you can call it with "getOrCreate(this, url)" where "this" is the component.');
    } else
      i = e.context, e = e.sourceId;
    const n = gr(e, t);
    Bs && console.log("GetOrCreate Addressable from", e, t, "FinalPath=", n);
    const o = i.addressables, r = o.findAssetReference(n);
    if (r) return r;
    const a = new ie(n, i.hash);
    return o.registerAssetReference(a), a;
  }
  isAssetReference = !0;
  /**  
   * This is the loaded asset root object. If the asset is a glb/gltf file this will be the {@link three#Scene} object.
   */
  get rawAsset() {
    return this._rawAsset;
  }
  /** The loaded asset root
   */
  get asset() {
    return this._glbRoot ?? (this._rawAsset?.scene || null);
  }
  set asset(e) {
    e ? this._rawAsset = {
      animations: e.animations,
      scene: e,
      scenes: [e]
    } : this._rawAsset = null;
  }
  /** The url of the loaded asset (or the asset to be loaded) 
   * @deprecated use url */
  get uri() {
    return this._url;
  }
  /** The url of the loaded asset (or the asset to be loaded) */
  get url() {
    return this._url;
  }
  /** The name of the assigned url. This name is deduced from the url and might not reflect the actual name of the asset */
  get urlName() {
    return this._urlName;
  }
  /**
   * @returns true if the uri is a valid URL (http, https, blob)
   */
  get hasUrl() {
    return this._url !== void 0 && (this._url.startsWith("http") || this._url.startsWith("blob:") || this._url.startsWith("www.") || this._url.includes("/"));
  }
  _rawAsset = null;
  _glbRoot;
  _url;
  _urlName;
  _progressListeners = [];
  _isLoadingRawBinary = !1;
  _rawBinary;
  constructor(...e) {
    typeof e[0] == "object" ? "url" in e[0] ? this._url = e[0].url : (this._url = "", e[0].asset && (this.asset = e[0].asset)) : (this._url = e[0], e[2] instanceof M && (this.asset = e[2]));
    const t = this._url.lastIndexOf("/");
    if (t >= 0) {
      this._urlName = this._url.substring(t + 1);
      const i = this._urlName.lastIndexOf(".");
      i >= 0 && (this._urlName = this._urlName.substring(0, i));
    } else
      this._urlName = this._url;
    xP(this._url, this.onResolvePrefab.bind(this));
  }
  async onResolvePrefab(e) {
    return e === this.url && (this.mustLoad && await this.loadAssetAsync(), this.asset) ? this.asset : null;
  }
  get mustLoad() {
    return !this.asset || this.asset.__destroyed === !0 || Pa(this.asset) === !0;
  }
  _loadingPromise = null;
  /**
   * @returns `true` if the asset has been loaded (via preload) or if it exists already (assigned to `asset`) */
  isLoaded() {
    return this._rawBinary || this.asset !== void 0;
  }
  /** frees previously allocated memory and destroys the current `asset` instance (if any) */
  unload() {
    this.asset && (Bs && console.log("Unload", this.asset), "scene" in this.asset && this.asset.scene && Gi(this.asset.scene, !0, !0), Gi(this.asset, !0, !0)), this.asset = null, this._rawBinary = void 0, this._glbRoot = null, this._loadingPromise = null, N.Current && N.Current.addressables.unregisterAssetReference(this);
  }
  /** loads the asset binary without creating an instance */
  async preload() {
    if (!this.mustLoad || this._isLoadingRawBinary) return null;
    if (this._rawBinary !== void 0) return this._rawBinary;
    this._isLoadingRawBinary = !0, Bs && console.log("Preload", this.url);
    const e = await Ma.download(this.url, (t) => {
      this.raiseProgressEvent(t);
    });
    return this._rawBinary = e?.buffer ?? null, this._isLoadingRawBinary = !1, this._rawBinary;
  }
  // TODO: we need a way to abort loading a resource
  /** Loads the asset and creates one instance (assigned to `asset`)
   * @returns the loaded asset
   */
  async loadAssetAsync(e) {
    if (Bs && console.log("[AssetReference] loadAssetAsync", this.url), !this.mustLoad) return this.asset;
    if (e && this._progressListeners.push(e), this._loadingPromise !== null)
      return this._loadingPromise.then((n) => this.asset);
    const t = N.Current;
    if (this._rawBinary) {
      if (!(this._rawBinary instanceof ArrayBuffer))
        return console.error("[AssetReference] Failed loading – Invalid data. Must be of type ArrayBuffer. " + typeof this._rawBinary), null;
      this._loadingPromise = Bn().parseSync(t, this._rawBinary, this.url, null), this.raiseProgressEvent(new ProgressEvent("progress", { loaded: this._rawBinary.byteLength, total: this._rawBinary.byteLength }));
    } else
      Bs && console.log("Load async", this.url), this._loadingPromise = Bn().loadSync(t, this.url, this.url, null, (n) => {
        this.raiseProgressEvent(n);
      });
    this._loadingPromise.finally(() => this._loadingPromise = null);
    const i = await this._loadingPromise;
    return this._progressListeners.length = 0, this._glbRoot = this.tryGetActualGameObjectRoot(i), i ? (i[Sf] = this, this._glbRoot && (this._glbRoot[Sf] = this), this.asset && (this.asset[Sf] = this), pd(t), i.scene !== void 0 && (this._rawAsset = i), this.asset) : null;
  }
  /** loads and returns a new instance of `asset` */
  instantiate(e) {
    return this.onInstantiate(e, !1);
  }
  /** loads and returns a new instance of `asset` - this call is networked so an instance will be created on all connected users */
  instantiateSynced(e, t = !0) {
    return this.onInstantiate(e, !0, t);
  }
  beginListenDownload(e) {
    this._progressListeners.indexOf(e) < 0 && this._progressListeners.push(e);
  }
  endListenDownload(e) {
    const t = this._progressListeners.indexOf(e);
    t >= 0 && this._progressListeners.splice(t, 1);
  }
  raiseProgressEvent(e) {
    for (const t of this._progressListeners)
      t(this, e);
  }
  static currentlyInstantiating = /* @__PURE__ */ new Map();
  async onInstantiate(e, t = !1, i) {
    const n = N.Current, o = new $n();
    if (e instanceof M ? o.parent = e : e && (Object.assign(o, e), o.cloneAssign(e)), o.parent === void 0 && (o.parent = n.scene), this.mustLoad && await this.loadAssetAsync(), Bs && console.log("Instantiate", this.url, "parent:", e), this.asset) {
      Bs && console.log("Add to scene", this.asset);
      let r = ie.currentlyInstantiating.get(this.url);
      if (r !== void 0 && r >= 1e4)
        return console.error("Recursive or too many instantiations of " + this.url + " in the same frame (" + r + ")"), null;
      try {
        if (r === void 0 && (r = 0), r += 1, ie.currentlyInstantiating.set(this.url, r), t) {
          o.context = n;
          const a = this.asset;
          a.guid = this.url;
          const l = A0(a, o, void 0, i);
          if (l)
            return l;
        } else {
          const a = ka(this.asset, o);
          if (a)
            return a;
        }
      } finally {
        n.post_render_callbacks.push(() => {
          r === void 0 || r < 0 ? r = 0 : r -= 1, ie.currentlyInstantiating.set(this.url, r);
        });
      }
    } else Bs && console.warn("Failed to load asset", this.url);
    return null;
  }
  /**
   * try to ignore the intermediate created object
   * because it causes trouble if we instantiate an assetreference per player
   * and call destroy on the player marker root
   * @returns the scene root object if the asset was a glb/gltf
   */
  tryGetActualGameObjectRoot(e) {
    if (e && e.scene) {
      const t = e.scene;
      if (t.isGroup && t.children.length === 1 && t.children[0].name + "glb" === t.name) {
        const i = t.children[0];
        return i.animations = t.animations, i;
      } else
        return t;
    }
    return null;
  }
}
class rO extends Zi {
  constructor() {
    super([ie], "AssetReferenceSerializer");
  }
  onSerialize(e, t) {
    if (e && e.uri !== void 0 && typeof e.uri == "string")
      return e.uri;
  }
  onDeserialize(e, t) {
    if (typeof e == "string")
      return t.context ? t.gltfId ? ie.getOrCreate(t.gltfId, e, t.context) : (console.error("Missing source id"), null) : (console.error("Missing context"), null);
    if (e instanceof M) {
      if (!t.context)
        return console.error("Missing context"), null;
      if (!t.gltfId)
        return console.error("Missing source id"), null;
      const i = e, n = t.context, o = i.guid ?? i.uuid, r = n.addressables.findAssetReference(o);
      if (r) return r;
      const a = new ie(o, void 0, i);
      return n.addressables.registerAssetReference(a), a;
    }
    return null;
  }
}
new rO();
const aO = Promise.resolve(null);
class la {
  static imageReferences = /* @__PURE__ */ new Map();
  static getOrCreate(e) {
    let t = la.imageReferences.get(e);
    return t || (t = new la(e), la.imageReferences.set(e, t)), t;
  }
  constructor(e) {
    this.url = e;
  }
  url;
  _bitmap;
  _bitmapObject;
  dispose() {
    this._bitmapObject && this._bitmapObject.close(), this._bitmap = void 0;
  }
  createHTMLImage() {
    const e = new Image();
    return e.src = this.url, e;
  }
  loader = null;
  createTexture() {
    return this.url ? (this.loader || (this.loader = new lc()), this.loader.setCrossOrigin("anonymous"), this.loader.loadAsync(this.url).then((e) => (e && !e.name?.length && (e.name = this.url.split("/").pop() ?? this.url), e))) : (console.error("Can not load texture without url"), aO);
  }
  /** Loads the bitmap data of the image */
  getBitmap() {
    return this._bitmap ? this._bitmap : (this._bitmap = new Promise((e, t) => {
      const i = document.createElement("img");
      i.addEventListener("load", () => {
        this._bitmap = createImageBitmap(i).then((n) => (this._bitmapObject = n, e(n), n));
      }), i.addEventListener("error", (n) => {
        console.error("Failed to load image:" + this.url, n), e(null);
      }), i.src = this.url;
    }), this._bitmap);
  }
}
class lO extends Zi {
  constructor() {
    super([la], "ImageReferenceSerializer");
  }
  onSerialize(e, t) {
    return null;
  }
  onDeserialize(e, t) {
    if (typeof e == "string") {
      const i = gr(t.gltfId, e);
      return la.getOrCreate(i);
    }
  }
}
new lO();
class ca {
  static cache = /* @__PURE__ */ new Map();
  static getOrCreate(e) {
    let t = ca.cache.get(e);
    return t || (t = new ca(e), ca.cache.set(e, t)), t;
  }
  /** Load the file binary data
   * @returns a promise that resolves to the binary data of the file. Make sure to await this request or use `.then(res => {...})` to get the result.
   */
  async loadRaw() {
    return this.res || (this.res = fetch(this.url)), this.res.then((e) => e.blob());
  }
  /** Load the file as text (if the referenced file is a text file like a .txt or .json file)
   * @returns a promise that resolves to the text data of the file. Make sure to await this request or use `.then(res => {...})` to get the result. If the format is json you can use `JSON.parse(result)` to convert it to a json object
   */
  async loadText() {
    return this.res || (this.res = fetch(this.url)), this.res.then((e) => e.text());
  }
  /** The resolved url to the file */
  url;
  res;
  constructor(e) {
    this.url = e;
  }
}
class cO extends Zi {
  constructor() {
    super([ca], "FileReferenceSerializer");
  }
  onSerialize(e, t) {
    return null;
  }
  onDeserialize(e, t) {
    if (typeof e == "string") {
      const i = gr(t.gltfId, e);
      return ca.getOrCreate(i);
    }
  }
}
new cO();
class hO {
  context;
  mixers = [];
  constructor(e) {
    this.context = e;
  }
  /** @hidden @internal */
  onDestroy() {
    this.mixers.forEach((e) => e.stopAllAction()), this.mixers.length = 0;
  }
  /**
   * Register an animation mixer instance.
   */
  registerAnimationMixer(e) {
    if (!e) {
      console.warn("AnimationsRegistry.registerAnimationMixer called with null or undefined mixer");
      return;
    }
    this.mixers.includes(e) || this.mixers.push(e);
  }
  /**
   * Unregister an animation mixer instance.
   */
  unregisterAnimationMixer(e) {
    if (!e) {
      console.warn("AnimationsRegistry.unregisterAnimationMixer called with null or undefined mixer");
      return;
    }
    const t = this.mixers.indexOf(e);
    t !== -1 && this.mixers.splice(t, 1);
  }
}
class mc {
  /**
   * Tries to get the animation actions from an animation mixer.
   * @param mixer The animation mixer to get the actions from
   * @returns The actions or null if the mixer is invalid
   */
  static tryGetActionsFromMixer(e) {
    const t = e._actions;
    return t || null;
  }
  static tryGetAnimationClipsFromObjectHierarchy(e, t) {
    if (t || (t = new Array()), e)
      e.animations && t.push(...e.animations);
    else return t;
    if (e.children)
      for (const i of e.children)
        this.tryGetAnimationClipsFromObjectHierarchy(i, t);
    return t;
  }
  /**
   * Assigns animations from a GLTF file to the objects in the scene.  
   * This method will look for objects in the scene that have animations and assign them to the correct objects.  
   * @param file The GLTF file to assign the animations from
   */
  static autoplayAnimations(e) {
    if (!e || !e.animations)
      return console.debug("No animations found in file"), null;
    const t = "scene" in e ? e.scene : e, i = new Array();
    for (let o = 0; o < e.animations.length; o++) {
      const r = e.animations[o];
      if (!r.tracks || r.tracks.length <= 0) {
        console.warn("Animation has no tracks");
        continue;
      }
      for (const a in r.tracks) {
        const l = r.tracks[a], c = ga.parseTrackName(l.name);
        let h = ga.findNode(t, c.nodeName);
        if (!h) {
          const f = l.__objectName ?? l.name.substring(0, l.name.indexOf("."));
          if (h = t.getObjectByProperty("uuid", f), !h)
            continue;
        }
        let d = n(h) || n(t);
        if (!d) {
          const f = P.get("Animation");
          if (d = t.addComponent(f), !d) {
            console.error("Failed creating Animation component: No 'Animation' component found in TypeStore");
            break;
          }
        }
        i.push(d), d.addClip && d.addClip(r);
      }
    }
    return i;
    function n(o) {
      if (!o) return null;
      const r = o.userData?.components;
      if (r && r.length > 0)
        for (let a = 0; a < r.length; a++) {
          const l = r[a];
          if (l.isAnimationComponent === !0)
            return l;
        }
      return n(o.parent);
    }
  }
}
function* q0(s, e = null) {
  const t = e ? e.time : N.Current.time, i = t.time;
  for (; t.time - i < s; )
    yield;
}
function* fL(s) {
  for (let e = 0; e < s; e++)
    yield;
}
function* dO(s) {
  let e = !0;
  for (s.then(() => e = !1), s.catch(() => e = !1); e; )
    yield;
}
const l_ = "NEEDLE_lightmaps", dl = w("debuglightmapsextension") || w("debuglightmaps");
var Sn = /* @__PURE__ */ ((s) => (s[s.Lightmap = 0] = "Lightmap", s[s.Skybox = 1] = "Skybox", s[s.Reflection = 2] = "Reflection", s))(Sn || {});
class uO {
  get name() {
    return l_;
  }
  parser;
  registry;
  source;
  constructor(e, t, i) {
    this.parser = e, this.registry = t, this.source = i;
  }
  afterRoot(e) {
    const t = this.parser.json.extensions;
    if (t) {
      const i = t[l_];
      if (i) {
        const n = i.textures;
        return n?.length ? (dl && console.log(i), new Promise(async (o, r) => {
          const a = [];
          for (const c of n)
            if (c.pointer) {
              dl && console.log(c);
              let h = null;
              if (c.pointer.startsWith("/textures/") || /** legacy support e.g. SOC */
              c.pointer.startsWith("textures/"))
                dl && console.log("Load texture from gltf", c.pointer), h = qm(this.parser, c.pointer).then((d) => this.resolveTexture(c, d));
              else if (typeof c.pointer == "string") {
                dl && console.log("Load texture from path", c.pointer);
                const d = gr(this.source, c.pointer);
                let f;
                d.endsWith(".exr") ? f = new Rm(this.parser.options.manager) : d.endsWith(".hdr") ? f = new jb(this.parser.options.manager) : f = new lc(this.parser.options.manager), h = f.loadAsync(d, void 0).then((p) => this.resolveTexture(c, p));
              } else c.pointer;
              h && a.push(h);
            }
          const l = await qb(a);
          l?.anyFailed && L() && console.error("Failed to load lightmap extension", l), o();
        })) : null;
      }
    }
    return null;
  }
  resolveTexture(e, t) {
    const i = t;
    dl && console.log("Lightmap loaded:", i), i?.isTexture && (this.registry ? (i.colorSpace = Ss, this.registry.registerTexture(this.source, e.type, i, e.index)) : console.log(Sn[e.type], e.pointer, i));
  }
}
const Lr = !!w("debuglightmaps");
class fO {
  _context;
  _lightmaps = /* @__PURE__ */ new Map();
  clear() {
    this._lightmaps.clear();
  }
  constructor(e) {
    this._context = e;
  }
  registerTexture(e, t, i, n) {
    Lr && console.log("Registering ", Sn[t] + ' "' + e + '"', i), this._lightmaps.has(e) || this._lightmaps.set(e, /* @__PURE__ */ new Map());
    const o = this._lightmaps.get(e), r = o?.get(t) ?? [];
    r.length < n && (r.length = n + 1), rP(i, !1), r[n] = i, o?.set(t, r);
  }
  tryGetLightmap(e, t = 0) {
    return this.tryGet(e, Sn.Lightmap, t);
  }
  tryGetSkybox(e) {
    return Lr && console.log("[Get Skybox]", e, this._lightmaps), this.tryGet(e, Sn.Skybox, 0);
  }
  tryGetReflection(e) {
    return Lr && console.log("[Get Reflection]", e, this._lightmaps), this.tryGet(e, Sn.Reflection, 0);
  }
  tryGet(e, t, i) {
    if (!e)
      return Lr && console.warn("Missing source id"), null;
    const n = this._lightmaps.get(e);
    if (!n)
      return Lr && console.warn(`[Lighting] No ${Sn[t]} texture entry for`, e), null;
    const o = n.get(t);
    return o === void 0 ? (Lr && console.warn(`[Lighting] No ${Sn[t]} texture for`, e, "index", i), null) : !o?.length || o.length <= i ? null : o[i];
  }
}
Ht.lights_fragment_maps = Ht.lights_fragment_maps.replace("vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );", `
    vec2 lUv = vLightMapUv.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
    vec4 lightMapTexel = texture2D( lightMap, lUv);
    // The range of RGBM lightmaps goes from 0 to 34.49 (5^2.2) in linear space, and from 0 to 5 in gamma space.
    lightMapTexel.rgb *= lightMapTexel.a * 8.; // no idea where that "8" comes from... heuristically derived
    lightMapTexel.a = 1.;
    lightMapTexel = conv_sRGBToLinear(lightMapTexel);
    `);
Ht.lightmap_pars_fragment = `
    #ifdef USE_LIGHTMAP
        uniform sampler2D lightMap;
        uniform float lightMapIntensity;
        uniform vec4 lightmapScaleOffset;
        
        // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
        vec4 conv_sRGBToLinear( in vec4 value ) {
            return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
        }
    #endif
    `;
Ht.lights_fragment_begin = Ht.lights_fragment_begin.replace(
  "irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );",
  `
#if defined(USE_LIGHTMAP)
irradiance += 0.;
#else
irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
#endif`
);
bx.lightmap.lightmapScaleOffset = { value: new fe(1, 1, 0, 0) };
const Cf = w("debugprogressive"), hh = new bi(), dh = new $d();
class pO {
  /** The type of the @needle-tools/gltf-progressive LODsManager - can be used to set static settings */
  static GLTF_PROGRESSIVE_LODSMANAGER_TYPE = Do;
  context;
  _lodsManager;
  _settings = {};
  /**
   * The internal LODs manager. See @needle-tools/gltf-progressive for more information.  
   * @link https://npmjs.com/package/@needle-tools/gltf-progressive
   */
  get manager() {
    return this._lodsManager;
  }
  get skinnedMeshAutoUpdateBoundsInterval() {
    return this._lodsManager?.skinnedMeshAutoUpdateBoundsInterval || this._settings.skinnedMeshAutoUpdateBoundsInterval || 0;
  }
  set skinnedMeshAutoUpdateBoundsInterval(e) {
    this._settings.skinnedMeshAutoUpdateBoundsInterval = e, this.applySettings();
  }
  /**
   * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.  
   * @default 200_000
   */
  get targetTriangleDensity() {
    return this._lodsManager?.targetTriangleDensity || this._settings.targetTriangleDensity || 2e5;
  }
  set targetTriangleDensity(e) {
    this._settings.targetTriangleDensity = e, this.applySettings();
  }
  constructor(e) {
    this.context = e;
  }
  applySettings() {
    if (this._lodsManager)
      for (const e in this._settings)
        this._lodsManager[e] = this._settings[e];
  }
  /** @internal */
  setRenderer(e) {
    this._lodsManager?.disable(), Do.removePlugin(this), Do.addPlugin(this), Do.debugDrawLine = z.DrawLine, this._lodsManager = Do.get(e, { engine: "needle-engine" }), this.applySettings(), this._lodsManager.enable();
  }
  disable() {
    this._lodsManager?.disable(), Do.removePlugin(this);
  }
  /** @internal */
  onAfterUpdatedLOD(e, t, i, n, o) {
    Cf && this.onRenderDebug(i, n, o);
  }
  onRenderDebug(e, t, i) {
    if (!t.geometry || !We.hasLODLevelAvailable(t.geometry) && !We.hasLODLevelAvailable(t.material)) return;
    const n = Do.getObjectLODState(t);
    if (!n) return;
    let o = i.mesh_lod;
    const r = i.mesh_lod != n.lastLodLevel_Mesh || i.texture_lod != n.lastLodLevel_Texture;
    if (Cf && t.geometry.boundingSphere) {
      const a = t.geometry.boundingSphere;
      dh.copy(a), dh.applyMatrix4(t.matrixWorld);
      const l = dh.center, c = dh.radius, h = ["#76c43e", "#bcc43e", "#c4ac3e", "#c4673e", "#ff3e3e"];
      if (r)
        z.DrawWireSphere(l, c, h[o], 0.1);
      else {
        const d = t.geometry.index?.count ?? 0, f = We.getMeshLODExtension(t.geometry)?.lods;
        o = f ? Math.min(f?.length - 1, o) : 0;
        let p = "";
        if (f && n.lastScreenCoverage > 0)
          for (let m = 0; m < f.length; m++) {
            const v = f[m].density, _ = m == f.length - 1;
            p += v.toFixed(0) + ">" + (v / n.lastScreenCoverage).toFixed(0) + (_ ? "" : ",");
          }
        const g = f ? f[o]?.density : -1;
        let b = "LOD " + i.mesh_lod + `
TEX ` + i.texture_lod;
        if (Cf == "density" && (b += `
` + d + ` tris
` + (g / n.lastScreenCoverage).toFixed(0) + ` dens
` + (n.lastScreenCoverage * 100).toFixed(1) + `% cov
` + (n.lastCentrality * 100).toFixed(1) + `% centr
` + (hh.min.x.toFixed(2) + "-" + hh.max.x.toFixed(2) + "x" + hh.min.y.toFixed(2) + "-" + hh.max.y.toFixed(2)) + " scr"), n.lastScreenCoverage > 0.1) {
          const m = e, v = m.worldForward, _ = m.worldPosition, I = H(v).multiplyScalar(c * 0.7).add(l), O = I.distanceTo(_), k = h[Math.min(h.length - 1, Math.max(0, o))] + "88", E = this.context.domHeight > 0 ? screen.height / this.context.domHeight : 1, B = e.isPerspectiveCamera ? Math.tan(e.fov * Math.PI / 180 / 2) : 1;
          z.DrawLabel(I, b, O * 0.012 * E * B, void 0, 16777215, k);
        }
      }
    }
  }
}
const mO = w("debugplayerview");
var tr = /* @__PURE__ */ ((s) => (s.Browser = "browser", s.Headset = "headset", s.Handheld = "handheld", s))(tr || {});
class gO {
  userId;
  context;
  viewDevice = "browser";
  get currentObject() {
    return this._object;
  }
  set currentObject(e) {
    this._object = e;
  }
  get isConnected() {
    return this.context.connection.userIsInRoom(this.userId);
  }
  removed = !1;
  _object;
  constructor(e, t) {
    this.userId = e, this.context = t;
  }
}
class yO {
  context;
  playerViews = /* @__PURE__ */ new Map();
  constructor(e) {
    this.context = e;
  }
  setPlayerView(e, t, i) {
    let n = this.playerViews.get(e);
    n || (n = new gO(e, this.context), this.playerViews.set(e, n)), n.viewDevice = i, n.currentObject = t, n.removed = !1;
  }
  getPlayerView(e) {
    if (!e) return;
    if (!this.context.connection.userIsInRoom(e)) {
      this.playerViews.delete(e);
      return;
    }
    return this.playerViews.get(e);
  }
  removePlayerView(e, t) {
    const i = this.playerViews.get(e);
    i?.viewDevice === t && (mO && console.log("REMOVE", e), i.removed = !0, this.playerViews.delete(e));
  }
}
new xm();
const Oc = new Uint8Array(4);
Oc[0] = 255;
Oc[1] = 255;
Oc[2] = 255;
Oc[3] = 255;
const _O = new Sm(Oc, 1, 1, Wd);
function Zm(s, e = 1) {
  const t = "alpha" in s, i = e * e, n = new Uint8Array(4 * i), o = Math.floor(s.r * 255), r = Math.floor(s.g * 255), a = Math.floor(s.b * 255);
  for (let c = 0; c < i; c++) {
    const h = c * 4;
    n[h + 0] = o, n[h + 1] = r, n[h + 2] = a, t ? n[h + 3] = Math.floor(s.alpha * 255) : n[h + 3] = 255;
  }
  const l = new Sm(n, e, e);
  return l.needsUpdate = !0, l;
}
function bO(s, e, t, i = 1, n = 3) {
  const r = i * n, a = [s, e, t], l = a.length, c = new Uint8Array(4 * l * r), h = new se();
  for (let f = 0; f < n; f++) {
    const p = Math.floor(f / n * l), g = j.clamp(p + 1, 0, l - 1), b = a[p], m = a[g], v = f / n * l % 1;
    h.lerpColors(b, m, v);
    const _ = Math.floor(h.r * 255), x = Math.floor(h.g * 255), I = Math.floor(h.b * 255);
    for (let O = 0; O < i; O++) {
      const k = (f * i + O) * 4;
      c[k + 0] = _, c[k + 1] = x, c[k + 2] = I, c[k + 3] = 255;
    }
  }
  const d = new Sm(c, i, n);
  return d.needsUpdate = !0, d;
}
function _d(s, e) {
  const t = s.elements;
  e || (e = []), e.length = 0;
  for (let i = 0; i < 16; i += 4) {
    const n = t[i], o = t[i + 1], r = t[i + 2], a = t[i + 3], l = new fe(n, o, r, a);
    e.push(l);
  }
  return e;
}
const Pf = [], c_ = [];
function vO(s, e) {
  if (Pf.length === 0)
    for (let t = 0; t < 27; t++) Pf.push(0);
  e || (e = Pf);
  for (let t = 0; t < 27; t++)
    c_[t] = e[t];
  e = c_, s.unity_SHAr = { value: new fe(e[9], e[3], e[6], e[0]) }, s.unity_SHBr = { value: new fe(e[12], e[15], e[18], e[21]) }, s.unity_SHAg = { value: new fe(e[10], e[4], e[7], e[1]) }, s.unity_SHBg = { value: new fe(e[13], e[16], e[19], e[22]) }, s.unity_SHAb = { value: new fe(e[11], e[5], e[8], e[2]) }, s.unity_SHBb = { value: new fe(e[14], e[17], e[20], e[23]) }, s.unity_SHC = { value: new fe(e[24], e[25], e[26], 1) };
}
class wO {
  vertexShader;
  fragmentShader;
  technique;
  constructor(e, t, i) {
    this.vertexShader = e, this.fragmentShader = t, this.technique = i;
  }
}
async function xO(s, e) {
  if (!s)
    return console.error("Can not find technique: no shader data"), null;
  const t = s.programs[e], i = t.vertexShader, n = t.fragmentShader;
  if (i !== void 0 && n !== void 0) {
    const o = s.shaders[i], r = s.shaders[n];
    if (o.uri && r.uri || o.code && r.code) {
      if (!o.code && o.uri && await h_(o), !r.code && r.uri && await h_(r), !o.code || !r.code) return null;
      const a = s.techniques[e];
      return new wO(o.code, r.code, a);
    }
  }
  return console.error("Shader technique not found", e), null;
}
async function h_(s) {
  const e = s.uri;
  if (e)
    if (e.endsWith(".glsl")) {
      const i = await new xm().loadAsync(e);
      s.code = i.toString();
    } else
      s.code = SO(s.uri);
}
function SO(s) {
  return decodeURIComponent(Array.prototype.map.call(atob(s), function(e) {
    return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}
const nn = w("debugenvlight");
var Ql = /* @__PURE__ */ ((s) => (s[s.Skybox = 0] = "Skybox", s[s.Trilight = 1] = "Trilight", s[s.Flat = 3] = "Flat", s[s.Custom = 4] = "Custom", s))(Ql || {}), Fp = /* @__PURE__ */ ((s) => (s[s.Skybox = 0] = "Skybox", s[s.Custom = 1] = "Custom", s))(Fp || {});
class CO {
  context;
  constructor(e) {
    this.context = e, this.context.pre_update_callbacks.push(this.preUpdate.bind(this));
  }
  _currentLightSettingsId;
  _sceneLightSettings;
  preUpdate() {
    const e = this.context.time;
    this._timevec4.x = e.time, this._timevec4.y = Math.sin(e.time), this._timevec4.z = Math.cos(e.time), this._timevec4.w = e.deltaTime;
  }
  _timevec4 = new fe();
  /** Time data used for custom shaders
   * x: time
   * y: sin(time)
   * z: cos(time)
   * w: deltaTime
   */
  get timeVec4() {
    return this._timevec4;
  }
  /** the current environment intensity */
  get environmentIntensity() {
    if (!this._sceneLightSettings || !this._currentLightSettingsId) return 1;
    const e = this._sceneLightSettings.get(this._currentLightSettingsId);
    return e ? e.ambientIntensity : 1;
  }
  /** Get all currently registered scene light settings */
  get sceneLightSettings() {
    return this._sceneLightSettings?.values();
  }
  /** set the scene lighting from a specific scene. Will disable any previously enabled lighting settings */
  enable(e) {
    e instanceof ie && (e = e.url);
    const t = this._sceneLightSettings?.get(e);
    return t ? (nn && console.log("Enable scene light settings", e, t), e !== this._currentLightSettingsId && this._currentLightSettingsId && this.disable(this._currentLightSettingsId), this._currentLightSettingsId = e, t.enabled = !0, !0) : (nn && console.warn("No light settings found for", e), !1);
  }
  /** disable the lighting of a specific scene, will only have any effect if it is currently active */
  disable(e) {
    if (e instanceof ie && (e = e.url), e == null) return !1;
    const t = this._sceneLightSettings?.get(e);
    return t ? (nn && console.log("Disable scene light settings", e, t), t.enabled = !1, !0) : !1;
  }
  /** Disables the currently active scene lighting (if any), returns the id of the previously active lighting */
  disableCurrent() {
    if (this._currentLightSettingsId) {
      const e = this._currentLightSettingsId;
      return this.disable(this._currentLightSettingsId), e;
    }
    return null;
  }
  /** @internal */
  internalRegisterSceneLightSettings(e) {
    const t = e.sourceId;
    if (!t) {
      console.error("Missing source id for scene light settings, can not register:", e);
      return;
    }
    nn && console.log("Register " + e?.sourceId + " lighting", e), this._sceneLightSettings || (this._sceneLightSettings = /* @__PURE__ */ new Map()), this._sceneLightSettings.set(t, e);
  }
  /** @internal */
  internalUnregisterSceneLightSettings(e) {
    const t = e.sourceId;
    if (!t) {
      console.error("Missing source id for scene light settings, can not unregister:", e);
      return;
    }
    nn && console.log("Unregister " + e?.sourceId + " lighting", e), this._sceneLightSettings && this._sceneLightSettings.delete(t);
  }
  /** @internal */
  internalRegisterReflection(e, t) {
    nn && console.log("Register reflection", e, t);
    const i = new PO(this.context, t, 1);
    this._lighting[e] = i;
  }
  /** @internal */
  internalGetReflection(e) {
    return this._lighting[e];
  }
  __currentReflectionId = null;
  /** @internal */
  internalEnableReflection(e) {
    this.__currentReflectionId = e;
    const t = this._sceneLightSettings?.get(e);
    switch (nn && console.log("Enable reflection", e, t ? Ql[t.ambientMode] : "Unknown ambient mode", t), t?.ambientMode) {
      case 0:
      case 4:
        const i = this.internalGetReflection(e);
        if (i && i.Source) {
          nn && console.log("Setting environment reflection", i);
          const n = this.context.scene, o = i.Source;
          o.mapping = _s, n.environment = o;
          return;
        } else nn && console.warn("Could not find reflection for source", e);
        break;
    }
    if (t?.environmentReflectionSource === 1)
      switch (t?.ambientMode) {
        case 1:
          if (t.ambientTrilight) {
            const i = t.ambientTrilight, n = bO(i[0], i[1], i[2], 64, 64);
            n.colorSpace = Cs, n.mapping = _s, this.context.scene.environment = n;
          } else console.error("Missing ambient trilight", t.sourceId);
          return;
        case 3:
          if (t.ambientLight) {
            const i = Zm(t.ambientLight, 64);
            i.colorSpace = Cs, i.mapping = _s, this.context.scene.environment = i;
          } else console.error("Missing ambientlight", t.sourceId);
          return;
        default:
          return;
      }
  }
  /** @internal */
  internalDisableReflection(e) {
    if (e && e !== this.__currentReflectionId) {
      nn && console.log("Not disabling reflection for", e, "because it is not the current light settings id", this.__currentReflectionId);
      return;
    }
    nn && console.log("Disable reflection", e);
    const t = this.context.scene;
    t.environment = null;
  }
  _lighting = {};
}
class PO {
  get Source() {
    return this._source;
  }
  // get Array(): number[] | undefined { return this._sphericalHarmonicsArray; }
  _source;
  // private _sphericalHarmonicsArray?: number[];
  // private _context: Context;
  // private _sphericalHarmonics: SphericalHarmonics3 | null = null;
  // private _ambientScale: number = 1;
  // private _lightProbe?: LightProbe;
  constructor(e, t, i = 1) {
    this._source = t, t.mapping = _s;
  }
  /* REMOVED, no LightProbe / custom shader lighting support for now
      getSphericalHarmonicsArray(intensityFactor: number = 1): SphericalHarmonicsData | null {
          if (this._sphericalHarmonicsArray?.length && this._source) {
              return { array: this._sphericalHarmonicsArray, texture: this._source, lightProbe: this._lightProbe };
          }
  
          try {
              const reflection = this._source;
              let rt: WebGLCubeRenderTarget | null = null;
              if (reflection) {
                  if (debug) console.log("GENERATING LIGHT PROBE", reflection, this.Source);
                  const size = Math.min(reflection.image.width, 512);
                  const target = new WebGLCubeRenderTarget(size);
                  rt = target.fromEquirectangularTexture(this._context.renderer, reflection);
                  // Not sure why we did assign the resulting texture here again but this causes rendering to break when toggling env lighting (e.g. on website) because this texture will then be set as the scene.environment
                  // this._source = rt.texture;
              }
  
              this._sphericalHarmonicsArray = [];
              if (rt) {
                  const sampledProbe = LightProbeGenerator.fromCubeRenderTarget(this._context.renderer, rt);
                  this._lightProbe = sampledProbe;
                  const lightFactor = (this._ambientScale * (intensityFactor * intensityFactor * Math.PI * .5)) - 1;
                  // console.log(intensityFactor, lightFactor);
                  this._sphericalHarmonics = sampledProbe.sh;
                  this._sphericalHarmonicsArray = this._sphericalHarmonics.toArray();
                  if (this._sphericalHarmonicsArray) {
                      const factor = ((intensityFactor) / (Math.PI * .5));
                      for (let i = 0; i < this._sphericalHarmonicsArray.length; i++) {
                          this._sphericalHarmonicsArray[i] *= factor;
                      }
                      sampledProbe.sh.scale(lightFactor);
                      if (this._source)
                          return { array: this._sphericalHarmonicsArray, texture: this._source, lightProbe: sampledProbe };
                  }
              }
          }
          catch (err) {
              console.error(err);
          }
  
          return null;
      }
      */
}
const d_ = w("timescale");
let zp = 1;
typeof d_ == "number" && (zp = d_);
class OO {
  /** The time in seconds since the start of Needle Engine. */
  get time() {
    return this._time;
  }
  set time(e) {
    this._time = e;
  }
  _time = 0;
  /** The time in seconds it took to complete the last frame (Read Only). */
  get deltaTime() {
    return this._deltaTime;
  }
  set deltaTime(e) {
    this._deltaTime = e;
  }
  _deltaTime = 0;
  /** The time in seconds it took to complete the last frame (Read Only). Timescale is not applied. */
  get deltaTimeUnscaled() {
    return this._deltaTimeUnscaled;
  }
  _deltaTimeUnscaled = 0;
  /** The scale at which time passes. This can be used for slow motion effects or to speed up time. */
  timeScale = 1;
  /** same as frameCount */
  get frame() {
    return this._frame;
  }
  set frame(e) {
    this._frame = e;
  }
  _frame = 0;
  /** The total number of frames that have passed (Read Only). Same as frame */
  get frameCount() {
    return this.frame;
  }
  /** The time in seconds it took to complete the last frame (Read Only). */
  get realtimeSinceStartup() {
    return this.clock.elapsedTime;
  }
  /** 
   * @returns {Number} FPS for this frame.   
   * Note that this returns the raw value (e.g. 59.88023952362959) and will fluctuate a lot between frames.  
   * If you want a more stable FPS, use `smoothedFps` instead.
  */
  get fps() {
    return 1 / this.deltaTime;
  }
  /** 
   * Approximated frames per second   
   * @returns the smoothed FPS value over the last 60 frames with decimals.  
  */
  get smoothedFps() {
    return this._smoothedFps;
  }
  /** The smoothed time in seconds it took to complete the last frame (Read Only). */
  get smoothedDeltaTime() {
    return 1 / this._smoothedFps;
  }
  clock = new vx();
  _smoothedFps = 0;
  _smoothedDeltaTime = 0;
  _fpsSamples = [];
  _fpsSampleIndex = 0;
  constructor() {
    typeof zp == "number" && (this.timeScale = zp);
  }
  /** Step the time. This is called automatically by the Needle Engine Context.
   * @internal
   */
  update() {
    this.deltaTime = this.clock.getDelta(), this.deltaTime = Math.min(0.1, this.deltaTime), this._deltaTimeUnscaled = this.deltaTime, this.deltaTime <= 0 && (this.deltaTime = 1e-12), this.deltaTime *= this.timeScale, this.frame += 1, this.time += this.deltaTime, this._fpsSamples.length < 60 ? this._fpsSamples.push(this.deltaTime) : this._fpsSamples[this._fpsSampleIndex++ % 60] = this.deltaTime;
    let e = 0;
    for (let t = 0; t < this._fpsSamples.length; t++)
      e += this._fpsSamples[t];
    this._smoothedDeltaTime = e / this._fpsSamples.length, this._smoothedFps = 1 / this._smoothedDeltaTime;
  }
}
let u_ = !1;
function X0(s) {
  u_ || (u_ = !0, kO(), MO());
}
X0();
function kO() {
  const s = `
float startCompression = 0.8;
float desaturation = 0.5;
// Patched tonemapping function
vec3 NeutralToneMapping( vec3 color ) {
    color *= toneMappingExposure;
    
    float d = 1. - startCompression;
    // float peak = dot(color, vec3(0.299, 0.587, 0.114));
    float peak = max(color.r, max(color.g, color.b));
    if (peak < startCompression) return color;
    float newPeak = 1. - d * d / (peak + d - startCompression);
    float invPeak = 1. / peak;
    
    float extraBrightness = dot(color * (1. - startCompression * invPeak), vec3(1, 1, 1));
    
    color *= newPeak * invPeak;
    float g = 1. - 3. / (desaturation * extraBrightness + 3.);
    return mix(color, vec3(1, 1, 1), g);
}
`, e = "vec3 NeutralToneMapping( vec3 color ) {", t = `return mix( color, vec3( newPeak ), g );
}`, i = Ht.tonemapping_pars_fragment.indexOf(e), n = Ht.tonemapping_pars_fragment.indexOf(t, i);
  if (i >= 0 && n >= 0) {
    const o = Ht.tonemapping_pars_fragment.substring(i, n + t.length);
    Ht.tonemapping_pars_fragment = Ht.tonemapping_pars_fragment.replace(o, s);
  } else L() && console.error("Couldn't find NeutralToneMapping in ShaderChunk.tonemapping_pars_fragment");
}
function MO() {
  const s = `
// 0: Default, 1: Golden, 2: Punchy
#define AGX_LOOK 0        

vec3 userSlope = vec3(1.0);
vec3 userOffset = vec3(0.0);
vec3 userPower = vec3(1.0);
float userSaturation = 1.0;

// Mean error^2: 3.6705141e-06
vec3 _agxDefaultContrastApprox(vec3 x) {
    vec3 x2 = x * x;
    vec3 x4 = x2 * x2;
    
    return  + 15.5     * x4 * x2
            - 40.14    * x4 * x
            + 31.96    * x4
            - 6.868    * x2 * x
            + 0.4298   * x2
            + 0.1191   * x
            - 0.00232;
}

vec3 _agx(vec3 val) {
    const mat3 agx_mat = mat3(
        0.842479062253094, 0.0423282422610123, 0.0423756549057051,
        0.0784335999999992,  0.878468636469772,  0.0784336,
        0.0792237451477643, 0.0791661274605434, 0.879142973793104);
    
    const float min_ev = -12.47393;
    const float max_ev = 4.026069;

    // val = pow(val, vec3(2.2)); 

    // Input transform (inset)
    val = agx_mat * val;
    
    // Log2 space encoding
    val = clamp(log2(val), min_ev, max_ev);
    val = (val - min_ev) / (max_ev - min_ev);
    
    // Apply sigmoid function approximation
    val = _agxDefaultContrastApprox(val);

    return val;
}

vec3 _agxEotf(vec3 val) {
    const mat3 agx_mat_inv = mat3(
        1.19687900512017, -0.0528968517574562, -0.0529716355144438,
        -0.0980208811401368, 1.15190312990417, -0.0980434501171241,
        -0.0990297440797205, -0.0989611768448433, 1.15107367264116);
        
    // Inverse input transform (outset)
    val = agx_mat_inv * val;
    
    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display
    // NOTE: We're linearizing the output here. Comment/adjust when
    // *not* using a sRGB render target
    val = pow(val, vec3(2.2)); 

    return val;
}

vec3 _agxLook(vec3 val) {
    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(val, lw);
    
    // Default
    vec3 offset = vec3(0.0);
    vec3 slope = vec3(1.0);
    vec3 power = vec3(1.0);
    float sat = 1.0;
    
    #if AGX_LOOK == 1
    // Golden
    slope = vec3(1.0, 0.9, 0.5);
    power = vec3(0.8);
    sat = 0.8;
    #elif AGX_LOOK == 2
    // Punchy
    slope = vec3(1.0);
    power = vec3(1.35, 1.35, 1.35);
    sat = 1.4;
    #endif        
    
    // Needle
    slope = vec3(1.05);
    power = vec3(1.10, 1.10, 1.10);
    sat = 1.15;

    // User
    // slope = userSlope;
    // offset = userOffset;
    // power = userPower;
    // sat = userSaturation;
    
    // ASC CDL
    val = pow(val * slope + offset, power);
    return luma + sat * (val - luma);
}


vec3 AgXToneMapping( vec3 color ) {
    // apply AGX
    color *= toneMappingExposure;
    color = max(color, vec3(0.001)); // Prevent NaN
    color = _agx(color);
    color = _agxLook(color); // Optional
    color = _agxEotf(color);
    return color;
`, e = "vec3 AgXToneMapping( vec3 color ) {", t = "return color;", i = Ht.tonemapping_pars_fragment.indexOf(e), n = Ht.tonemapping_pars_fragment.indexOf(t, i);
  if (i >= 0 && n >= 0) {
    const o = Ht.tonemapping_pars_fragment.substring(i, n + t.length);
    Ht.tonemapping_pars_fragment = Ht.tonemapping_pars_fragment.replace(o, s);
  } else L() && console.error("Couldn't find AgXToneMapping in ShaderChunk.tonemapping_pars_fragment");
}
function Q0(s) {
  if (typeof s == "string")
    switch (s = s.toLowerCase(), s) {
      case "none":
        return id;
      case "neutral":
        return ya;
      case "aces":
        return Hd;
      case "agx":
        return Vd;
      case "khronos_neutral":
        return ya;
      default:
        console.warn("[PostProcessing] Unknown tone mapping mode", s);
        return;
    }
}
function Et(s) {
  const e = document.createElement("span");
  return e.style.maxWidth = "48px", e.style.maxHeight = "48px", e.style.overflow = "hidden", e.classList.add("material-symbols-outlined", "notranslate"), e.setAttribute("translate", "no"), e.innerText = s, e;
}
function RO(s) {
  return s.classList?.contains("material-symbols-outlined") || !1;
}
const uh = /* @__PURE__ */ new Map();
async function f_(s) {
  const e = "Material Symbols Outlined";
  if (document.fonts.check(`1em '${e}'`) || (console.log("Font not loaded yet"), await document.fonts.ready), uh.has(s))
    return uh.get(s);
  const t = document.createElement("canvas"), i = 48;
  t.width = i, t.height = i;
  const n = t.getContext("2d");
  if (n) {
    n.font = `${i}px '${e}'`, n.fillStyle = "black", n.fillText(s, 0, i);
    const o = t.toDataURL(), r = new Te();
    return r.name = s + " icon", r.image = new Image(), r.image.src = o, r.needsUpdate = !0, uh.set(s, r), r;
  }
  return uh.set(s, null), null;
}
class kn {
  static _instance;
  /** 
   * Get access to the default HTML button factory.    
   * Use this to get or create default Needle Engine buttons that can be added to your HTML UI  
   * If you want to create a new factory and create new button instances instead of shared buttons, use `ButtonsFactory.create()` instead
   */
  static get instance() {
    return this.getOrCreate();
  }
  /** 
   * Get access to the default HTML button factory.    
   * Use this to get or create default Needle Engine buttons that can be added to your HTML UI  
   * If you want to create a new factory and create new button instances instead of shared buttons, use `ButtonsFactory.create()` instead
   */
  static getOrCreate() {
    return this._instance || (this._instance = new kn()), this._instance;
  }
  /** create a new buttons factory */
  static create() {
    return new kn();
  }
  _fullscreenButton;
  /**
   * Get the fullscreen button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createFullscreenButton} to get or create it
   */
  get fullscreenButton() {
    return this._fullscreenButton;
  }
  /** Create a fullscreen button (or return the existing one if it already exists) */
  createFullscreenButton(e) {
    if (this._fullscreenButton)
      return this._fullscreenButton;
    if (!document.fullscreenEnabled)
      return L() && console.warn("NeedleMenu: Fullscreen button could not be created, device doesn't support the Fullscreen API"), null;
    const t = document.createElement("button");
    this._fullscreenButton = t, t.classList.add("fullscreen-button"), t.title = "Click to enter fullscreen mode";
    const i = Et("fullscreen"), n = Et("fullscreen_exit");
    return t.appendChild(i), t.onclick = () => {
      document.fullscreenElement ? document.exitFullscreen() : "webkitRequestFullscreen" in e.domElement && typeof e.domElement.webkitRequestFullscreen == "function" ? e.domElement.webkitRequestFullscreen() : "requestFullscreen" in e.domElement && e.domElement.requestFullscreen();
    }, document.addEventListener("fullscreenchange", () => {
      document.fullscreenElement ? (i.remove(), t.appendChild(n), t.title = "Click to enter fullscreen mode") : (n.remove(), t.appendChild(i), t.title = "Click to exit fullscreen mode");
    }), globalThis.addEventListener("needle-xrsession-start", () => {
      t.style.display = "none";
    }), globalThis.addEventListener("needle-xrsession-end", () => {
      t.style.display = "";
    }), t;
  }
  _muteButton;
  /** Get the mute button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createMuteButton} to get or create it */
  get muteButton() {
    return this._muteButton;
  }
  /** Create a mute button (or return the existing one if it already exists) */
  createMuteButton(e) {
    if (this._muteButton)
      return this._muteButton;
    const t = document.createElement("button");
    this._muteButton = t, t.classList.add("mute-button"), t.title = "Click to mute/unmute";
    const i = Et("volume_off"), n = Et("volume_up");
    return e.application.muted ? t.appendChild(i) : t.appendChild(n), t.onclick = () => {
      e.application.muted ? (i.remove(), t.appendChild(n), e.application.muted = !1) : (n.remove(), t.appendChild(i), e.application.muted = !0);
    }, t;
  }
  _qrButton;
  /**
   * Get the QR code button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createQRCode} to get or create it
   */
  get qrButton() {
    return this._qrButton;
  }
  _customQRButtonUrl;
  /** Get or set the QR code button URL - this URL will open when scanning the QR code */
  set qrButtonUrl(e) {
    try {
      new URL(e), this._customQRButtonUrl = e;
    } catch {
      console.warn(`[Needle] QR code button URL is not a valid URL '${e}'`);
    }
  }
  get qrButtonUrl() {
    return this._customQRButtonUrl || window.location.href;
  }
  /** Create a QR code button (or return the existing one if it already exists)
   * The QR code button will show a QR code that can be scanned to open the current page on a phone  
   * The QR code will be generated with the current URL when the button is clicked
   * @returns the QR code button element
   */
  createQRCode() {
    if (this._qrButton) return this._qrButton;
    const e = this, t = document.createElement("button");
    this._qrButton = t, t.innerText = "QR Code", t.prepend(Et("qr_code")), t.title = "Scan this QR code with your phone to open this page", this.hideElementDuringXRSession(t);
    const i = document.createElement("div");
    i.style.cssText = `
            position: fixed;
            display: inline-block;
            padding: 0.5rem;
            background-color: white;
            border-radius: 0.4rem;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.2);
        `;
    const n = document.createElement("div");
    n.classList.add("qr-code-container"), i.appendChild(n), t.addEventListener("click", () => {
      if (i.parentNode) return r();
      L() && window.location.href.includes("://localhost") && ge("To access your website from another device in the same local network you have to use the IP address instead of localhost. The IP address is logged in your development server console when you start the server."), o();
    });
    async function o() {
      await a();
      const c = document.body.querySelector("needle-engine") || document.body;
      c.appendChild(i);
      const h = n.getBoundingClientRect(), d = t.getBoundingClientRect();
      i.style.left = d.left + d.width * 0.5 - h.width * 0.5 + "px";
      const f = d.top < h.height, p = "1.3rem";
      f ? i.style.top = `calc(${d.bottom}px + ${i.style.padding} + 0.0rem)` : i.style.top = `calc(${d.top - h.height}px - ${i.style.padding} - ${p})`, i.style.opacity = "0", i.style.pointerEvents = "all", i.style.transition = "opacity 0.2s ease-in-out", setTimeout(() => {
        i.style.opacity = "1", window.addEventListener("click", r, { once: !0 });
      }), window.addEventListener("resize", r), window.addEventListener("scroll", r), document.fullscreenElement ? document.fullscreenElement.appendChild(i) : c.appendChild(i);
    }
    function r() {
      i.style.pointerEvents = "none", i.style.transition = "opacity 0.2s", i.style.opacity = "0", setTimeout(() => i.parentNode?.removeChild(i), 500), window.removeEventListener("click", r), window.removeEventListener("resize", r), window.removeEventListener("scroll", r);
    }
    async function a() {
      const c = await CC({
        text: e.qrButtonUrl,
        width: 200,
        height: 200
      });
      n.innerHTML = "", n.appendChild(c);
    }
    return t.addEventListener("pointerenter", () => {
      a();
    }, { once: !0 }), t;
  }
  hideElementDuringXRSession(e) {
    zm((t) => {
      e["previous-display"] = e.style.display, e.style.display = "none";
    }), p0((t) => {
      e["previous-display"] != null && (e.style.display = e["previous-display"]);
    });
  }
}
function bd(s, e) {
  const t = e?.element || document.head, i = Array.from(t.querySelectorAll(`link[rel=stylesheet][href*='${s}']`));
  if (i.length <= 0) {
    const n = document.createElement("link");
    n.href = s, n.rel = "stylesheet", t.appendChild(n), i.push(n);
  }
  if (e?.loadedCallback)
    for (let n = 0; n < i.length; n++)
      e?.loadedCallback && i[n].addEventListener("load", e.loadedCallback);
}
function Y0() {
  bd("https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap");
}
const Up = "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&display=block", vd = "needle-logo-element";
class K0 extends HTMLElement {
  static get elementName() {
    return vd;
  }
  static create() {
    return document.createElement(vd);
  }
  constructor() {
    super(), this._root = this.attachShadow({ mode: "closed" });
    const e = document.createElement("template");
    e.innerHTML = `<style>
        :host {
            position: relative;
            min-width: fit-content;
            /* height: 100%; can not have height 100% because of align-items: stretch; in the parent */
            display: flex;
        }

        .wrapper {
            position: relative;
            display: grid;
            grid-template-columns: auto auto;
            padding: .1rem;
        }
        .wrapper:hover {
            cursor: pointer;
        }
        img {
            width: 95px;
            height: 100%;
            align-self: end;
            margin-left: 0.6rem;
        }
        span {
            font-size: 1rem;
            white-space: nowrap;
        }
        </style>
        <div class="wrapper">
            <img class="logo" src=${pC} />
        </div>
        `, this._root.appendChild(e.content.cloneNode(!0)), this.wrapper = this._root.querySelector(".wrapper"), this._root.appendChild(this.wrapper), this.addEventListener("click", () => {
      globalThis.open("https://needle.tools", "_blank");
    }), this.wrapper.setAttribute("title", "Made with Needle Engine");
  }
  _root;
  wrapper;
  logoElement = document.createElement("img");
  textElement = document.createElement("span");
  setLogoVisible(e) {
    this.logoElement.style.display = e ? "block" : "none";
  }
}
customElements.get(vd) || customElements.define(vd, K0);
const Of = w("debugspatialmenu");
class TO {
  _context;
  needleMenu;
  htmlButtonsMap = /* @__PURE__ */ new Map();
  enabled = !0;
  constructor(e, t) {
    this._context = e, this._context.pre_render_callbacks.push(this.preRender), this.needleMenu = t;
    const i = this.needleMenu.shadowRoot?.querySelector(".options");
    i ? new MutationObserver((o) => {
      if (this.enabled && !(this._context.isInXR == !1 && !Of))
        for (const r of o)
          r.type === "childList" && (r.addedNodes.forEach((a) => {
            this.createButtonFromHTMLNode(a);
          }), r.removedNodes.forEach((a) => {
            const l = a, c = this.htmlButtonsMap.get(l);
            c && (this.htmlButtonsMap.delete(l), c.remove(), Ce.update());
          }));
    }).observe(i, { childList: !0 }) : console.error("Could not find options container in needle menu");
  }
  setEnabled(e) {
    this.enabled = e, e || this.menu?.removeFromParent();
  }
  userRequestedMenu = !1;
  /** Bring up the spatial menu. This is typically invoked from a button click. 
   * The menu will show at a lower height to be easily accessible.
   * @returns true if the menu was shown, false if it can't be shown because the menu has been disabled.
   */
  setDisplay(e) {
    return this.enabled ? (this.userRequestedMenu = e, !0) : !1;
  }
  onDestroy() {
    const e = this._context.pre_render_callbacks.indexOf(this.preRender);
    e > -1 && this._context.pre_render_callbacks.splice(e, 1);
  }
  uiisDirty = !1;
  markDirty() {
    this.uiisDirty = !0;
  }
  _showNeedleLogo;
  showNeedleLogo(e) {
    this._showNeedleLogo = e;
  }
  _wasInXR = !1;
  preRender = () => {
    if (!this.enabled) {
      this.menu?.removeFromParent();
      return;
    }
    if (Of && q.isDesktop() && this.updateMenu(), !this._context.xr?.running) {
      this._wasInXR && (this._wasInXR = !1, this.onExitXR());
      return;
    }
    this._wasInXR || (this._wasInXR = !0, this.onEnterXR()), this.updateMenu();
  };
  onEnterXR() {
    const e = this.needleMenu.shadowRoot?.querySelector(".options");
    e && e.childNodes.forEach((t) => {
      this.createButtonFromHTMLNode(t);
    });
  }
  onExitXR() {
    this.menu?.removeFromParent();
  }
  createButtonFromHTMLNode(e) {
    const t = this.getMenu(), i = this.htmlButtonsMap.get(e);
    if (i) {
      i.add();
      return;
    }
    if (e instanceof HTMLButtonElement) {
      const n = this.createButton(t, e);
      this.htmlButtonsMap.set(e, n), n.add();
    } else e instanceof HTMLSlotElement && e.assignedNodes().forEach((n) => {
      this.createButtonFromHTMLNode(n);
    });
  }
  _menuTarget = new M();
  positionFilter = new Zb(90, 0.5);
  updateMenu() {
    const e = this.getMenu();
    this.handleNeedleWatermark(), this._context.scene.add(e);
    const t = this._context.mainCamera, n = this._context.xr?.rigScale || 1;
    if (t) {
      const o = t.worldPosition, r = t.worldForward.multiplyScalar(-1), a = r.y > 0.6, l = r.y > 0.4, c = (e.visible ? l : a) || this.userRequestedMenu, h = !e.visible && c;
      e.visible = c || q.isDesktop() && Of, r.multiplyScalar(3 * n), o.add(r), (h || !1) && (e.position.copy(this._menuTarget.position), e.position.y += 0.25, this._menuTarget.position.copy(e.position), this.positionFilter.reset(e.position), e.quaternion.copy(this._menuTarget.quaternion), this.markDirty());
      const f = this._menuTarget.position.distanceTo(o);
      (h || f > 1.5 * n) && (this.ensureRenderOnTop(this.menu), this._menuTarget.position.copy(o), this._context.scene.add(this._menuTarget), Yd(this._menuTarget, this._context.mainCamera, !0, !0), this._menuTarget.removeFromParent()), this.positionFilter.filter(this._menuTarget.position, e.position, this._context.time.time), this.menu?.quaternion.slerp(this._menuTarget.quaternion, this._context.time.deltaTime * 5), this.menu?.scale.setScalar(n);
    }
    this.uiisDirty && (this.uiisDirty = !1, Ce.update());
  }
  ensureRenderOnTop(e, t = 0) {
    e instanceof G && (e.material.depthTest = !1, e.material.depthWrite = !1), e.renderOrder = 1e3 + t * 2;
    for (const i of e.children)
      this.ensureRenderOnTop(i, t + 1);
  }
  familyName = "Needle Spatial Menu";
  menu;
  get isVisible() {
    return this.menu?.visible;
  }
  getMenu() {
    if (this.menu)
      return this.menu;
    this.ensureFont(), this.menu = new Ce.Block({
      boxSizing: "border-box",
      fontFamily: this.familyName,
      height: "auto",
      fontSize: 0.1,
      color: 0,
      lineHeight: 1,
      backgroundColor: 16777215,
      backgroundOpacity: 0.55,
      borderRadius: 1,
      whiteSpace: "pre-wrap",
      flexDirection: "row",
      alignItems: "center",
      padding: new fe(0, 0.05, 0, 0.05),
      borderColor: 0,
      borderOpacity: 0.05,
      borderWidth: 5e-3
    });
    const e = P.get("ObjectRaycaster");
    return e && aa(this.menu, new e()), this.menu;
  }
  _poweredByNeedleElement;
  handleNeedleWatermark() {
    if (!this._poweredByNeedleElement) {
      this._poweredByNeedleElement = new Ce.Block({
        width: "auto",
        height: "auto",
        fontSize: 0.05,
        whiteSpace: "pre-wrap",
        flexDirection: "row",
        flexWrap: "wrap",
        justifyContent: "center",
        margin: 0.02,
        borderRadius: 0.02,
        padding: 0.02,
        backgroundColor: 16777215,
        backgroundOpacity: 1
      }), this._poweredByNeedleElement["needle:use_eventsystem"] = !0;
      const e = new p_(this._context, () => globalThis.open("https://needle.tools", "_self"));
      aa(this._poweredByNeedleElement, e);
      const t = new Ce.Text({
        textContent: "Powered by",
        width: "auto",
        height: "auto"
      }), i = new Ce.Text({
        textContent: "needle",
        width: "auto",
        height: "auto",
        fontSize: 0.07,
        margin: new fe(0, 0, 0, 0.02)
      });
      this._poweredByNeedleElement.add(t), this._poweredByNeedleElement.add(i), this.menu?.add(this._poweredByNeedleElement), this.markDirty(), new lc().load("./include/needle/poweredbyneedle.webp", (o) => {
        e.allowModifyUI = !1, t.removeFromParent(), i.removeFromParent();
        const r = o.image.width / o.image.height;
        this._poweredByNeedleElement?.set({
          backgroundImage: o,
          backgroundOpacity: 1,
          width: 0.1 * r,
          height: 0.1
        }), this.markDirty();
      });
    }
    if (this.menu) {
      const e = this.menu.children.indexOf(this._poweredByNeedleElement);
      if (!this._showNeedleLogo && bs())
        e >= 0 && (this._poweredByNeedleElement.removeFromParent(), this.markDirty());
      else {
        this._poweredByNeedleElement.visible = !0, this.menu.add(this._poweredByNeedleElement);
        const t = this.menu.children.indexOf(this._poweredByNeedleElement);
        e !== t && this.markDirty();
      }
    }
  }
  ensureFont() {
    let e = Ce.FontLibrary.getFontFamily(this.familyName);
    e || (e = Ce.FontLibrary.addFontFamily(this.familyName), e.addVariant("normal", "normal", "./include/needle/arial-msdf.json", "./include/needle/arial.png")?.addEventListener("ready", () => {
      this.markDirty();
    }));
  }
  createButton(e, t) {
    const i = new Ce.Block({
      width: "auto",
      height: "auto",
      whiteSpace: "pre-wrap",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "center",
      backgroundColor: 16777215,
      backgroundOpacity: 0,
      padding: 0.02,
      margin: 0.01,
      borderRadius: 0.02,
      cursor: "pointer",
      fontSize: 0.05
    }), n = new Ce.Text({
      textContent: "",
      width: "auto",
      justifyContent: "center",
      alignItems: "center",
      backgroundOpacity: 0,
      backgroundColor: 16777215,
      fontFamily: this.familyName,
      color: 0,
      borderRadius: 0.02,
      padding: 0.01
    });
    i.add(n), i["needle:use_eventsystem"] = !0;
    const o = new p_(this._context, () => t.click());
    return aa(i, o), new EO(this, e, t, i, n);
  }
}
class EO {
  menu;
  root;
  htmlbutton;
  spatialContainer;
  spatialText;
  spatialIcon;
  constructor(e, t, i, n, o) {
    this.menu = e, this.root = t, this.htmlbutton = i, this.spatialContainer = n, this.spatialText = o, new MutationObserver((a) => {
      for (const l of a)
        l.type === "attributes" ? l.attributeName === "style" && this.updateVisible() : l.type === "childList" && this.updateText();
    }).observe(i, { attributes: !0, childList: !0 }), this.updateText();
  }
  add() {
    this.spatialContainer.parent != this.root && (this.root.add(this.spatialContainer), this.menu.markDirty(), this.updateVisible(), this.updateText());
  }
  remove() {
    this.spatialContainer.parent && (this.spatialContainer.removeFromParent(), this.menu.markDirty());
  }
  updateVisible() {
    const e = this.spatialContainer.visible;
    this.spatialContainer.visible = this.htmlbutton.style.display !== "none", e !== this.spatialContainer.visible && this.menu.markDirty();
  }
  _lastText = "";
  updateText() {
    let e = "", t = "";
    this.htmlbutton.childNodes.forEach((i) => {
      i.nodeType === Node.TEXT_NODE ? e += i.textContent : i instanceof HTMLElement && RO(i) && i.textContent && (t = i.textContent);
    }), this._lastText !== e && (this._lastText = e, this.spatialText.name = e, this.spatialText.set({ textContent: e }), this.menu.markDirty()), e.length <= 0 ? this.spatialText.parent && (this.spatialText.removeFromParent(), this.menu.markDirty()) : this.spatialText.parent || (this.spatialContainer.add(this.spatialText), this.menu.markDirty()), t && this.createIcon(t);
  }
  _lastTexture;
  async createIcon(e) {
    if (!this.spatialIcon) {
      const i = await f_(e);
      if (i && !this.spatialIcon) {
        const o = new Ce.Block({
          width: 0.08,
          height: 0.08,
          backgroundColor: 16777215,
          backgroundImage: i,
          backgroundOpacity: 1,
          margin: new fe(0, 5e-3, 0, 0)
        });
        this.spatialIcon = o, this.spatialContainer.add(o), this.menu.markDirty();
      }
    }
    if (e != this._lastTexture) {
      this._lastTexture = e;
      const i = await f_(e);
      i && (this.spatialIcon?.set({ backgroundImage: i }), this.menu.markDirty());
    }
    const t = this.spatialContainer.children.indexOf(this.spatialIcon);
    t > 0 && (this.spatialContainer.children.splice(t, 1), this.spatialContainer.children.unshift(this.spatialIcon), this.menu.markDirty());
  }
}
class p_ {
  isComponent = !0;
  enabled = !0;
  get activeAndEnabled() {
    return !0;
  }
  __internalAwake() {
  }
  __internalEnable() {
  }
  __internalDisable() {
  }
  __internalStart() {
  }
  onEnable() {
  }
  onDisable() {
  }
  gameObject;
  allowModifyUI = !0;
  get element() {
    return this.gameObject;
  }
  context;
  onclick;
  constructor(e, t) {
    this.context = e, this.onclick = t;
  }
  onPointerEnter() {
    this.context.input.setCursor("pointer"), this.allowModifyUI && (this.element.set({ backgroundOpacity: 1 }), Ce.update());
  }
  onPointerExit() {
    this.context.input.unsetCursor("pointer"), this.allowModifyUI && (this.element.set({ backgroundOpacity: 0 }), Ce.update());
  }
  onPointerDown(e) {
    e.use();
  }
  onPointerUp(e) {
    e.use();
  }
  onPointerClick(e) {
    e.use(), this.onclick();
  }
}
const Ho = "needle-menu", Yl = w("debugmenu"), m_ = w("debugnoncommercial");
let AO = class {
  _context;
  _menu;
  _spatialMenu;
  constructor(e) {
    this._menu = ou.getOrCreate(e.domElement, e), this._context = e, this._spatialMenu = new TO(e, this._menu), window.addEventListener("message", this.onPostMessage), zm(this.onStartXR);
  }
  /** @ignore internal method */
  onDestroy() {
    window.removeEventListener("message", this.onPostMessage), this._menu.remove(), this._spatialMenu.onDestroy();
  }
  onPostMessage = (e) => {
    if (e.origin === globalThis.location.origin && typeof e.data == "object") {
      const t = e.data, i = t.type;
      if (i === "needle:menu") {
        const n = t.button;
        if (n) {
          if (!n.label) return console.error("NeedleMenu: buttoninfo.label is required");
          if (!n.onclick) return console.error("NeedleMenu: buttoninfo.onclick is required");
          const o = document.createElement("button");
          if (o.textContent = n.label, n.icon) {
            const r = Et(n.icon);
            o.prepend(r);
          }
          n.priority && o.setAttribute("priority", n.priority.toString()), o.onclick = () => {
            if (n.onclick) {
              const r = n.onclick.startsWith("http") || n.onclick.startsWith("www."), a = n.target || "_blank";
              r ? globalThis.open(n.onclick, a) : console.error("NeedleMenu: onclick is not a valid link", n.onclick);
            }
          }, this._menu.appendChild(o);
        } else Yl && console.error("NeedleMenu: unknown postMessage event", t);
      } else Yl && console.warn("NeedleMenu: unknown postMessage type", i, t);
    }
  };
  onStartXR = (e) => {
    e.session.isScreenBasedAR && (this._menu.previousParent = this._menu.parentNode, this._context.arOverlayElement.appendChild(this._menu), e.session.session.addEventListener("end", this.onExitXR), this._menu.closeFoldout());
  };
  onExitXR = () => {
    this._menu.previousParent && (this._menu.previousParent.appendChild(this._menu), delete this._menu.previousParent);
  };
  /** Experimental: Change the menu position to be at the top or the bottom of the needle engine webcomponent
   * @param position "top" or "bottom"
   */
  setPosition(e) {
    this._menu.setPosition(e);
  }
  /**
   * Call to show or hide the menu.  
   * NOTE: Hiding the menu is a PRO feature and requires a needle engine license. Hiding the menu will not work in production without a license.
   */
  setVisible(e) {
    this._menu.setVisible(e);
  }
  /** When set to false, the Needle Engine logo will be hidden. Hiding the logo requires a needle engine license */
  showNeedleLogo(e) {
    this._menu.showNeedleLogo(e), this._spatialMenu?.showNeedleLogo(e);
  }
  /** @returns true if the logo is visible */
  get logoIsVisible() {
    return this._menu.logoIsVisible;
  }
  /** When enabled=true the menu will be visible in VR/AR sessions */
  showSpatialMenu(e) {
    this._spatialMenu.setEnabled(e);
  }
  setSpatialMenuVisible(e) {
    this._spatialMenu.setDisplay(e);
  }
  get spatialMenuIsVisible() {
    return this._spatialMenu.isVisible;
  }
  /**
   * Call to add or remove a button to the menu to show a QR code for the current page  
   * If enabled=true then a button will be added to the menu that will show a QR code for the current page when clicked.
   */
  showQRCodeButton(e) {
    if (e === "desktop-only" && (e = !q.isMobileDevice()), e) {
      const t = kn.getOrCreate().createQRCode();
      return t.style.display = "", this._menu.appendChild(t), t;
    } else {
      const t = kn.getOrCreate().qrButton;
      return t && (t.style.display = "none"), t ?? null;
    }
  }
  /** Call to add or remove a button to the menu to mute or unmute the application  
   * Clicking the button will mute or unmute the application
  */
  showAudioPlaybackOption(e) {
    if (!e) {
      this._muteButton?.remove();
      return;
    }
    this._muteButton = kn.getOrCreate().createMuteButton(this._context), this._muteButton.setAttribute("priority", "100"), this._menu.appendChild(this._muteButton);
  }
  _muteButton;
  showFullscreenOption(e) {
    if (!e) {
      this._fullscreenButton?.remove();
      return;
    }
    this._fullscreenButton = kn.getOrCreate().createFullscreenButton(this._context), this._fullscreenButton && (this._fullscreenButton.setAttribute("priority", "150"), this._menu.appendChild(this._fullscreenButton));
  }
  _fullscreenButton;
  appendChild(e) {
    return this._menu.appendChild(e);
  }
};
class ou extends HTMLElement {
  static create() {
    return document.createElement(Ho, { is: Ho });
  }
  static getOrCreate(e, t) {
    let i = e.querySelector(Ho);
    return !i && e.shadowRoot && (i = e.shadowRoot.querySelector(Ho)), i || (i = window.document.body.querySelector(Ho)), i || (i = ou.create(), e.shadowRoot ? e.shadowRoot.appendChild(i) : e.appendChild(i)), i._domElement = e, i._context = t, i;
  }
  _domElement = null;
  _context = null;
  constructor() {
    super();
    const e = document.createElement("template");
    e.innerHTML = `<style>

        /** Styling attributes that ensure the nested menu z-index does not cause it to overlay elements outside of <needle-engine> */
        :host {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 0;
            top: 0;
            pointer-events: none;
        }

        #root {
            position: absolute;
            width: auto;
            max-width: 95%;
            left: 50%;
            transform: translateX(-50%);
            top: min(20px, 10vh);
            padding: 0.3rem;
            display: flex;
            visibility: visible;
            flex-direction: row-reverse; /* if we overflow this should be right aligned so the logo is always visible */
            pointer-events: all;
            z-index: 1000;
        }

        /** hide the menu if it's empty **/
        #root.has-no-options.logo-hidden {
            display: none; 
        }

        /** using a div here because then we can change the class for placement **/
        #root.bottom {
            top: auto;
            bottom: min(30px, 10vh);
        }
        #root.top {
            top: calc(.7rem + env(safe-area-inset-top));
        }
        
        .wrapper {
            position: relative;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: stretch;
            gap: 0px;
            padding: 0 0rem;
        }

        .wrapper > *, .options > button, .options > select, ::slotted(*) {
            position: relative;
            border: none;
            border-radius: 0;
            outline: 1px solid rgba(0,0,0,0);
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 2.3rem;
            max-width: 100%;

            /** basic font settings for all entries **/
            font-size: 1rem;
            font-family: 'Roboto Flex', sans-serif;
            font-optical-sizing: auto;
            font-weight: 500;
            font-weight: 200;
            font-variation-settings: "wdth" 100;
            color: rgb(20,20,20);
        }

        .options > select[multiple]:hover {
            max-height: 300px;
        }

        .floating-panel-style {
            background: rgba(255, 255, 255, .4);
            outline: rgb(0 0 0 / 5%) 1px solid;
            border: 1px solid rgba(255, 255, 255, .1);
            box-shadow: 0px 7px 0.5rem 0px rgb(0 0 0 / 6%), inset 0px 0px 1.3rem rgba(0,0,0,.05);
            border-radius: 1.5rem;
            /** 
             * to make nested background filter work 
             * https://stackoverflow.com/questions/60997948/backdrop-filter-not-working-for-nested-elements-in-chrome 
             **/
            &::before {
                content: '';
                position: absolute;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                z-index: -1;
                border-radius: 1.5rem;
                -webkit-backdrop-filter: blur(8px);
                backdrop-filter: blur(8px);
            }
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        .options {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .options > *, ::slotted(*) {
            max-height: 2.25rem;
            padding: .4rem .5rem;
        }
        
        :host .options > *, ::slotted(*) {
            background: transparent;
            border: none;
            white-space: nowrap;
            transition: all 0.1s linear .02s;
            border-radius: 1.5rem;
            user-select: none;
        }
        :host .options > *:hover, ::slotted(*:hover) {
            cursor: pointer;
            color: black;
            background: rgba(245, 245, 245, .8);
            box-shadow: inset 0 0 1rem rgba(0,0,30,.2);
            outline: rgba(0,0,0,.1) 1px solid;
        }
        :host .options > *:active, ::slotted(*:active) {
            background: rgba(255, 255, 255, .8);
            box-shadow: inset 0px 1px 1px rgba(255,255,255,.5), inset 0 0 2rem rgba(0,0,30,.2), inset 0px 2px 4px rgba(0,0,20,.5);
            transition: all 0.05s linear;
        }
        :host .options > *:focus, ::slotted(*:focus) {
            outline: rgba(255,255,255,.5) 1px solid;
        }
        :host .options > *:focus-visible, ::slotted(*:focus-visible) {
            outline: rgba(0,0,0,.5) 1px solid;
        }

        :host .options > *:disabled, ::slotted(*:disabled) {
            background: rgba(0,0,0,.05);
            color: rgba(60,60,60,.7);
            pointer-events: none;
        }

        button, ::slotted(button) {
            gap: 0.3rem;
        }

        /** XR button animation **/
        :host button.this-mode-is-requested {
            background: repeating-linear-gradient(to right, #fff 0%, #fff 40%, #aaffff 55%, #fff 80%);
            background-size: 200% auto;
            background-position: 0 100%;
            animation: AnimationName .7s ease infinite forwards;
        }
        :host button.other-mode-is-requested {
            opacity: .5;
        }
        
        @keyframes AnimationName {
            0% { background-position: 0% 0 }
            100% { background-position: -200% 0 }
        }




        .logo {
            cursor: pointer;
            padding-left: 0.6rem;
            padding-bottom: .02rem;
            margin-right: 0.5rem;
        }
        .logo-hidden {
            .logo {
                display: none;
            }
        }
        :host .has-options .logo {
            border-left: 1px solid rgba(40,40,40,.4);
            margin-left: 0.3rem;
            margin-right: 0.5rem;
        }

        .logo > span {
            white-space: nowrap;
        }



        /** COMPACT */

        /** Hide the menu button normally **/
        .compact-menu-button { display: none; }
        /** And show it when we're in compact mode **/
        .compact .compact-menu-button {
            position: relative;
            display: block;
            background: none;
            border: none;
            border-radius: 2rem;

            margin: 0;
            padding: 0 .3rem;
            padding-top: .2rem;

            z-index: 100;

            color: #000;

            &:hover {
                background: rgba(255,255,255,.2);
                cursor: pointer;
            }
            &:focus {
                outline: 1px solid rgba(255,255,255,.5);
            }
            &:focus-visible {
                outline: 1px solid rgba(0,0,0,.5);
            }
            & .expanded-click-area {
                position: absolute;
                left: 0;
                right: 0;
                top: 10%;
                bottom: 10%;
                transform: scale(1.8);
            }
        }  
        .has-no-options .compact-menu-button {
            display: none;
        }
        .open .compact-menu-button {
            background: rgba(255,255,255,.2);
        }
        .logo-visible .compact-menu-button { 
            margin-left: .2rem;
        }
        
        /** Open and hide menu **/
        .compact .foldout { 
            display: none;
        }
        .open .options, .open .foldout {
            display: flex;
            justify-content: center;
        }
        .compact .wrapper {
            padding: 0;
        }
        .compact .wrapper, .compact .options {
            height: auto;
            max-height: initial;
            flex-direction: row;
            gap: .12rem;
        }
        .compact .options { 
            flex-wrap: wrap;
            gap: .3rem;
        }
        .compact .top .options {
            height: auto;
            flex-direction: row;
        }
        .compact .bottom .wrapper {
            height: auto;
            flex-direction: column;
        }

        .compact .foldout {
            max-height: min(100ch, calc(100vh - 100px));
            overflow: auto;
            overflow-x: hidden;
            align-items: center;

            position: fixed;
            bottom: calc(100% + 5px);
            z-index: 100;
            width: auto;
            left: .2rem;
            right: .2rem;
            padding: .2rem;

        }
        .compact.logo-hidden .foldout {
            /** for when there's no logo we want to center the foldout **/
            min-width: 24ch;
            margin-left: 50%;
            transform: translateX(calc(-50% - .2rem));
        }
        
        .compact.top .foldout {
            top: calc(100% + 5px);
            bottom: auto;
        }

        ::-webkit-scrollbar {
            max-width: 7px;
            background: rgba(100,100,100,.2);
            border-radius: .2rem;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, .3);
            border-radius: .2rem;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgb(150,150,150);
        }

        .compact .options > *, .compact .options > ::slotted(*) {
            font-size: 1.2rem;
            padding: .6rem .5rem;
            width: 100%;
        }
        .compact.has-options .logo {
            border: none;
            padding-left: 0;
            margin-left: 1rem;
            margin-bottom: .02rem;
        }
        .compact .options {
            /** e.g. if we have a very wide menu item like a select with long option names we don't want to overflow **/
            max-width: 100%;

            & > button, & > select {
                display: flex;
                flex-basis: 100%;
                min-height: 3rem;
            }
            & > button.row2 {
                //border: 1px solid red !important;
                display: flex;
                flex: 1;
                flex-basis: 30%;
            }
        }

        /** If there's really not enough space then just hide all options **/
        @media (max-width: 100px) or (max-height: 100px){
            .foldout {
                display: none !important;
            }
            .compact-menu-button {
                display: none !important;
            }
        }
        
        /* dark mode */
        /*
        @media (prefers-color-scheme: dark) {
            :host {
                background: rgba(0,0,0, .6);
            }
            :host button {
                color: rgba(200,200,200);
            }
            :host button:hover {
                background: rgba(100,100,100, .8);
            }
        }
        */

        </style>
        
        <div id="root" class="logo-hidden floating-panel-style bottom">
            <div class="wrapper">
                <div class="foldout">
                    <div class="options" part="options">
                        <slot></slot>
                    </div>
                    <div class="options" part="options">
                        <slot name="end"></slot>
                    </div>
                </div>
                <div style="user-select:none" class="logo">
                    <span class="madewith notranslate">powered by</span>
                </div>
            </div>
            <button class="compact-menu-button">
                <div class="expanded-click-area"></div>
            </button>
        </div>
        `;
    const t = this.attachShadow({ mode: "open" });
    Y0(), bd(Up, { loadedCallback: () => {
      this.handleSizeChange();
    } }), bd(Up, { element: t });
    const i = e.content.cloneNode(!0);
    t?.appendChild(i), this.root = t.querySelector("#root"), this.wrapper = this.root?.querySelector(".wrapper"), this.options = this.root?.querySelector(".options"), this.logoContainer = this.root?.querySelector(".logo"), this.compactMenuButton = this.root?.querySelector(".compact-menu-button"), this.compactMenuButton.append(Et("more_vert")), this.foldout = this.root?.querySelector(".foldout"), this.root?.appendChild(this.wrapper), this.wrapper.classList.add("wrapper");
    const n = K0.create();
    n.style.minHeight = "1rem", this.logoContainer.append(n), this.logoContainer.addEventListener("click", () => {
      globalThis.open("https://needle.tools", "_blank");
    });
    try {
      window.requestAnimationFrame(() => BO((h) => {
        if (h == !0 && vs() && !m_) {
          let d = this._userRequestedLogoVisible;
          d === void 0 && (d = !1), this.___onSetLogoVisible(d);
        } else
          this.___onSetLogoVisible(!0);
      }));
    } catch (h) {
      console.error("[Needle Menu] License check failed.", h);
    }
    this.compactMenuButton.addEventListener("click", (h) => {
      h.preventDefault(), this.root.classList.toggle("open");
    });
    let o = this._context;
    setTimeout(() => o = this._context);
    let r = 0;
    const a = (h, d) => {
      Yl && console.log("Set menu visible", d), o?.isInAR && o.arOverlayElement ? h != o.arOverlayElement && o.arOverlayElement.appendChild(this) : this.parentNode != this._domElement?.shadowRoot && this._domElement?.shadowRoot?.appendChild(this), this.style.display = d ? "flex" : "none", this.style.visibility = "visible", this.style.opacity = "1";
    };
    let l = !1;
    new MutationObserver((h) => {
      if (!l)
        try {
          l = !0, this.onChangeDetected(h);
          const d = this?.parentNode;
          if ((this.style.display != "flex" || this.style.visibility != "visible" || this.style.opacity != "1" || d != this._domElement?.shadowRoot) && !vs()) {
            const f = r++;
            hn() && this._userRequestedMenuVisible === !1 ? (f === 0 && a(d, this._userRequestedMenuVisible), f === 1 && console.warn("Needle Menu Warning: You need a PRO license to hide the Needle Engine menu → The menu will be visible in your deployed website if you don't have a PRO license. See https://needle.tools/pricing for details.")) : f === 0 ? a(d, !0) : setTimeout(() => a(d, !0), 5);
          }
        } finally {
          l = !1;
        }
    }).observe(this.root, { childList: !0, subtree: !0, attributes: !0 }), Yl && this.___insertDebugOptions();
  }
  _sizeChangeInterval;
  connectedCallback() {
    window.addEventListener("resize", this.handleSizeChange), this.handleMenuVisible(), this._sizeChangeInterval = setInterval(() => this.handleSizeChange(void 0, !0), 5e3), setTimeout(() => {
      this._domElement?.addEventListener("resize", this.handleSizeChange), this._domElement?.addEventListener("click", this.#t);
    }, 1);
  }
  disconnectedCallback() {
    window.removeEventListener("resize", this.handleSizeChange), clearInterval(this._sizeChangeInterval), this._domElement?.removeEventListener("resize", this.handleSizeChange), this._context?.domElement.removeEventListener("click", this.#t);
  }
  #t = (e) => {
    if (!e.defaultPrevented && e.target == this._domElement && e instanceof PointerEvent && e.button === 0 && this.root.classList.contains("open")) {
      const t = this.foldout.getBoundingClientRect(), i = e;
      i.clientX > t.left && i.clientX < t.right && i.clientY > t.top && i.clientY < t.bottom || this.root.classList.toggle("open", !1);
    }
  };
  _userRequestedLogoVisible = void 0;
  showNeedleLogo(e) {
    this._userRequestedLogoVisible = e, !(!e && (!vs() || m_) && (console.warn("[Needle Engine] You need a PRO license to hide the Needle Engine logo in production."), !hn())) && this.___onSetLogoVisible(e);
  }
  /** @returns true if the logo is visible */
  get logoIsVisible() {
    return !this.root.classList.contains("logo-hidden");
  }
  ___onSetLogoVisible(e) {
    this.logoContainer.style.display = "", this.logoContainer.style.opacity = "1", this.logoContainer.style.visibility = "visible", e ? (this.root.classList.remove("logo-hidden"), this.root.classList.add("logo-visible")) : (this.root.classList.remove("logo-visible"), this.root.classList.add("logo-hidden"));
  }
  setPosition(e) {
    if (e !== "top" && e !== "bottom")
      return console.error("NeedleMenu.setPosition: invalid position", e);
    this.root.classList.remove("top", "bottom"), this.root.classList.add(e);
  }
  _userRequestedMenuVisible = void 0;
  setVisible(e) {
    this._userRequestedMenuVisible = e, this.style.display = e ? "flex" : "none";
  }
  /**
   * If the menu is in compact mode and the foldout is currently open (to show all menu options) then this will close the foldout
   */
  closeFoldout() {
    this.root.classList.remove("open");
  }
  // private _root: ShadowRoot | null = null;
  root;
  /** wraps the whole content */
  wrapper;
  /** contains the buttons and dynamic elements */
  options;
  /** contains the needle-logo html element */
  logoContainer;
  compactMenuButton;
  foldout;
  append(...e) {
    for (const t of e)
      if (typeof t == "string") {
        const i = document.createTextNode(t);
        this.options.appendChild(i);
      } else
        this.options.appendChild(t);
  }
  appendChild(e) {
    if (!(e instanceof Node)) {
      const i = document.createElement("button");
      if (i.textContent = e.label, i.onclick = e.onClick, i.setAttribute("priority", e.priority?.toString() ?? "0"), e.title && (i.title = e.title), e.icon) {
        const n = Et(e.icon);
        e.iconSide === "right" ? i.appendChild(n) : i.prepend(n);
      }
      e.class && i.classList.add(e.class), e = i;
    }
    return this.options.appendChild(e);
  }
  prepend(...e) {
    for (const t of e)
      if (typeof t == "string") {
        const i = document.createTextNode(t);
        this.options.prepend(i);
      } else
        this.options.prepend(t);
  }
  _isHandlingChange = !1;
  /** Called when any change in the web component is detected (including in children and child attributes) */
  onChangeDetected(e) {
    if (!this._isHandlingChange) {
      this._isHandlingChange = !0;
      try {
        this.handleMenuVisible();
        for (const t of e)
          t.target == this.options && this.onOptionsChildrenChanged(t);
      } finally {
        this._isHandlingChange = !1;
      }
    }
  }
  onOptionsChildrenChanged(e) {
    if (this.root.classList.toggle("has-options", this.hasAnyVisibleOptions), this.root.classList.toggle("has-no-options", !this.hasAnyVisibleOptions), this.handleSizeChange(void 0, !0), e.type === "childList" && e.addedNodes.length > 0) {
      const t = Array.from(this.options.children);
      t.sort((n, o) => {
        const r = parseInt(n.getAttribute("priority") || "0"), a = parseInt(o.getAttribute("priority") || "0");
        return r - a;
      });
      let i = !1;
      for (let n = 0; n < t.length; n++) {
        const o = this.options.children[n], r = t[n];
        if (o !== r) {
          i = !0;
          break;
        }
      }
      if (i)
        for (const n of t)
          this.options.appendChild(n);
    }
  }
  _didSort = /* @__PURE__ */ new Map();
  /** checks if the menu has any content and should be rendered at all
   * if we dont have any content and logo then we hide the menu
   */
  handleMenuVisible() {
    Yl && console.log("Update VisibleState: Any Content?", this.hasAnyContent), this.hasAnyContent ? this.root.style.display = "" : this.root.style.display = "none", this.root.classList.toggle("has-options", this.hasAnyVisibleOptions), this.root.classList.toggle("has-no-options", !this.hasAnyVisibleOptions);
  }
  /** @returns true if we have any content OR a logo */
  get hasAnyContent() {
    return !!(this.logoContainer.style.display != "none" || this.hasAnyVisibleOptions);
  }
  get hasAnyVisibleOptions() {
    for (let e = 0; e < this.options.children.length; e++) {
      const t = this.options.children[e];
      if (t.tagName === "SLOT") {
        const n = t.assignedNodes();
        for (const o of n)
          if (o instanceof HTMLElement && o.style.display != "none")
            return !0;
      } else if (t.style.display != "none") return !0;
    }
    return !1;
  }
  _lastAvailableWidthChange = 0;
  _timeoutHandle = 0;
  handleSizeChange = (e, t) => {
    if (!this._domElement) return;
    const i = this._domElement.clientWidth;
    if (i < 100) {
      clearTimeout(this._timeoutHandle), this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style");
      return;
    }
    const o = i - 40;
    if (!t && Math.abs(o - this._lastAvailableWidthChange) < 1) return;
    this._lastAvailableWidthChange = o, clearTimeout(this._timeoutHandle), this._timeoutHandle = setTimeout(() => {
      const l = a();
      l < 0 ? (this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style")) : l > 0 && (this.root.classList.remove("compact"), this.foldout.classList.remove("floating-panel-style"), a() < 0 && (this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style")));
    }, 5);
    const r = () => this.options.clientWidth + this.logoContainer.clientWidth, a = () => o - r();
  };
  ___insertDebugOptions() {
    window.addEventListener("keydown", (i) => {
      i.key === "p" && this.setPosition(this.root.classList.contains("top") ? "bottom" : "top");
    });
    const e = document.createElement("button");
    e.textContent = "Hide Buttons", e.onclick = () => {
      const i = new Array(this.options.children.length);
      for (let n = 0; n < this.options.children.length; n++)
        i[n] = this.options.children[n];
      for (const n of i)
        this.options.removeChild(n);
      setTimeout(() => {
        for (const n of i)
          this.options.appendChild(n);
      }, 1e3);
    }, this.appendChild(e);
    const t = document.createElement("button");
    t.textContent = "Toggle Logo", t.addEventListener("click", () => {
      this.logoContainer.style.display = this.logoContainer.style.display === "none" ? "" : "none";
    }), this.appendChild(t);
  }
}
customElements.get(Ho) || customElements.define(Ho, ou);
const qe = w("debugcontext"), IO = w("stats"), LO = w("debugactive"), DO = w("debugframerate"), jO = w("debugcoroutine"), mL = {};
class gL {
  name;
  /** for debugging only */
  alias;
  /** the hash is used as a seed when initially loading the scene files */
  hash;
  /** when true the context will not check if it's visible in the viewport and always update and render */
  runInBackground;
  /** the DOM element the context belongs to or is inside of (this does not have to be the canvas. use renderer.domElement if you want to access the dom canvas) */
  domElement;
  /** externally owned renderer */
  renderer;
  /** externally owned camera */
  camera;
  /** externally owned scene */
  scene;
}
var xe = /* @__PURE__ */ ((s) => (s[s.Start = -1] = "Start", s[s.EarlyUpdate = 0] = "EarlyUpdate", s[s.Update = 1] = "Update", s[s.LateUpdate = 2] = "LateUpdate", s[s.OnBeforeRender = 3] = "OnBeforeRender", s[s.OnAfterRender = 4] = "OnAfterRender", s[s.PrePhysicsStep = 9] = "PrePhysicsStep", s[s.PostPhysicsStep = 10] = "PostPhysicsStep", s[s.Undefined = -1] = "Undefined", s))(xe || {});
function Jm(s, e) {
  if (!s) return;
  if (!s.isComponent) {
    (L() || qe) && console.error(`Registered script is not a Needle Engine component. 
The script will be ignored. Please make sure your component extends "Behaviour" imported from "@needle-tools/engine"
`, s);
    return;
  }
  e || (e = N.Current, qe && console.warn("> Registering component without context"));
  const t = e?.new_scripts;
  t.includes(s) || t.push(s);
}
class N {
  static _defaultTargetFramerate = { value: 90, toString() {
    return this.value;
  } };
  /** When a new context is created this is the framerate that will be used by default */
  static get DefaultTargetFrameRate() {
    return N._defaultTargetFramerate.value;
  }
  /** When a new context is created this is the framerate that will be used by default */
  static set DefaultTargetFrameRate(e) {
    N._defaultTargetFramerate.value = e;
  }
  static _defaultWebglRendererParameters = {
    antialias: !0,
    alpha: !1,
    // Note: this is due to a bug on OSX devices. See NE-5370
    powerPreference: q.isiOS() || q.isMacOS() ? "default" : "high-performance",
    stencil: !0
    // logarithmicDepthBuffer: true,
    // reverseDepthBuffer: true, // https://github.com/mrdoob/three.js/issues/29770
  };
  /** The default parameters that will be used when creating a new WebGLRenderer.  
   * Modify in global context to change the default parameters for all new contexts.
   * @example
   * ```typescript
   * import { Context } from "@needle-tools/engine";
   * Context.DefaultWebGLRendererParameters.antialias = false;
   * ```
   */
  static get DefaultWebGLRendererParameters() {
    return N._defaultWebglRendererParameters;
  }
  /** The needle engine version */
  get version() {
    return En;
  }
  /** The currently active context. Only set during the update loops */
  static get Current() {
    return ue.Current;
  }
  /** @internal this property should not be set by user code */
  static set Current(e) {
    ue.Current = e;
  }
  static get All() {
    return ue.All;
  }
  /** The name of the context */
  name;
  /** An alias for the context */
  alias;
  /** When the renderer or camera are managed by an external process (e.g. when running in r3f context). 
   * When this is false you are responsible to call update(timestamp, xframe.  
   * It is also currently assumed that rendering is handled performed by an external process
   * */
  isManagedExternally = !1;
  /** set to true to pause the update loop. You can receive an event for it in your components. 
   * Note that script updates will not be called when paused */
  isPaused = !1;
  /** When enabled the application will run while not visible on the page */
  runInBackground = !1;
  /** 
   * Set to the target framerate you want your application to run in (you can use ?stats to check the fps)
   * Set to undefined if you want to run at the maximum framerate
   */
  targetFrameRate;
  /** Use a higher number for more accurate physics simulation.   
   * When undefined physics steps will be 1 for mobile devices and 5 for desktop devices  
   * Set to 0 to disable physics updates
   * TODO: changing physics steps is currently not supported because then forces that we get from the character controller and rigidbody et al are not correct anymore - this needs to be properly tested before making this configureable
  */
  physicsSteps = 1;
  /** used to append to loaded assets */
  hash;
  /** The `<needle-engine>` web component */
  domElement;
  appendHTMLElement(e) {
    return this.domElement.shadowRoot ? this.domElement.shadowRoot.appendChild(e) : this.domElement.appendChild(e);
  }
  get resolutionScaleFactor() {
    return this._resolutionScaleFactor;
  }
  /** use to scale the resolution up or down of the renderer. default is 1 */
  set resolutionScaleFactor(e) {
    if (e !== this._resolutionScaleFactor && typeof e == "number") {
      if (e <= 0) {
        console.error("Invalid resolution scale factor", e);
        return;
      }
      this._resolutionScaleFactor = e, this.updateSize();
    }
  }
  _resolutionScaleFactor = 1;
  // domElement.clientLeft etc doesnt return absolute position
  _boundingClientRectFrame = -1;
  _boundingClientRect = null;
  _domX;
  _domY;
  /** update bounding rects + domX, domY */
  calculateBoundingClientRect() {
    if (this.xr) {
      this._domX = 0, this._domY = 0;
      return;
    }
    this._boundingClientRectFrame !== this.time.frame && (this._boundingClientRectFrame = this.time.frame, this._boundingClientRect = this.domElement.getBoundingClientRect(), this._domX = this._boundingClientRect.x, this._domY = this._boundingClientRect.y);
  }
  /** The width of the `<needle-engine>` element on the website */
  get domWidth() {
    return this.isInAR ? window.innerWidth : this.domElement.clientWidth;
  }
  /** The height of the `<needle-engine>` element on the website */
  get domHeight() {
    return this.isInAR ? window.innerHeight : this.domElement.clientHeight;
  }
  /** the X position of the `<needle-engine>` element on the website */
  get domX() {
    return this.calculateBoundingClientRect(), this._domX;
  }
  /** the Y position of the `<needle-engine>` element on the website */
  get domY() {
    return this.calculateBoundingClientRect(), this._domY;
  }
  /**
   * Is a XR session currently active and presenting?
   * @returns true if the xr renderer is currently presenting
   */
  get isInXR() {
    return this.renderer?.xr?.isPresenting || !1;
  }
  /** shorthand for `NeedleXRSession.active`  
   * Automatically set by NeedleXRSession when a XR session is active 
   * @returns the active XR session or null if no session is active
   * */
  xr = null;
  /**
   * Shorthand for `this.xr?.mode`. AR or VR
   * @returns the current XR session mode (immersive-vr or immersive-ar)
   */
  get xrSessionMode() {
    return this.xr?.mode;
  }
  /** Shorthand for `this.xrSessionMode === "immersive-vr"` 
   * @returns true if a webxr VR session is currently active. 
   */
  get isInVR() {
    return this.xrSessionMode === "immersive-vr";
  }
  /**
   * Shorthand for `this.xrSessionMode === "immersive-ar"`
   * @returns true if a webxr AR session is currently active.
   */
  get isInAR() {
    return this.xrSessionMode === "immersive-ar";
  }
  /** If a XR session is active and in pass through mode (immersive-ar on e.g. Quest) 
   * @returns true if the XR session is in pass through mode
   */
  get isInPassThrough() {
    return this.xr ? this.xr.isPassThrough : !1;
  }
  /** access the raw `XRSession` object (shorthand for `context.renderer.xr.getSession()`). For more control use `NeedleXRSession.active` */
  get xrSession() {
    return this.renderer?.xr?.getSession();
  }
  /** @returns the latest XRFrame (if a XRSession is currently active)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRFrame
   */
  get xrFrame() {
    return this._xrFrame;
  }
  /** @returns the current WebXR camera while the WebXRManager is active (shorthand for `context.renderer.xr.getCamera()`) */
  get xrCamera() {
    return this.renderer.xr.isPresenting ? this.renderer?.xr?.getCamera() : void 0;
  }
  _xrFrame = null;
  /**
   * The AR overlay element is used to display 2D HTML elements while a AR session is active.
   */
  get arOverlayElement() {
    const e = this.domElement;
    return typeof e.getAROverlayContainer == "function" ? e.getAROverlayContainer() : this.domElement;
  }
  /** 
   * Current event of the update cycle (e.g. `FrameEvent.EarlyUpdate` or `FrameEvent.OnBeforeRender`)
   */
  get currentFrameEvent() {
    return this._currentFrameEvent;
  }
  _currentFrameEvent = -1;
  /**
   * The scene contains all objects in the hierarchy and is automatically rendered by the context every frane.
   */
  scene;
  /**
   * The renderer is used to render the scene. It is automatically created when the context is created.
   */
  renderer;
  /**
   * The effect composer can be used to render postprocessing effects. If assigned then it will automatically render the scene every frame.
   */
  composer = null;
  /**
   * @internal All known components. Don't use directly
   */
  scripts = [];
  /**
   * @internal All paused components. Don't use directly
   */
  scripts_pausedChanged = [];
  /**
   * @internal All components that have a early update event. Don't use directly
   */
  scripts_earlyUpdate = [];
  /**
   * @internal All components that have a update event. Don't use directly
   */
  scripts_update = [];
  /**
   * @internal All components that have a late update event. Don't use directly
   */
  scripts_lateUpdate = [];
  /**
   * @internal All components that have a onBeforeRender event. Don't use directly
   */
  scripts_onBeforeRender = [];
  /**
   * @internal All components that have a onAfterRender event. Don't use directly
   */
  scripts_onAfterRender = [];
  /**
   * @internal All components that have coroutines. Don't use directly
   */
  scripts_WithCorroutines = [];
  /**
   * @internal Components with immersive-vr event methods. Don't use directly
   */
  scripts_immersive_vr = [];
  /**
   * @internal Components with immersive-ar event methods. Don't use directly
   */
  scripts_immersive_ar = [];
  /**
   * @internal Coroutine data
   */
  coroutines = {};
  /** callbacks called once after the context has been created */
  post_setup_callbacks = [];
  /** called every frame at the beginning of the frame (after component start events and before earlyUpdate) */
  pre_update_callbacks = [];
  /** called every frame before rendering (after all component events) */
  pre_render_callbacks = [];
  /** called every frame after rendering (after all component events) */
  post_render_callbacks = [];
  /** called every frame befroe update (this list is emptied every frame) */
  pre_update_oneshot_callbacks = [];
  /** @internal */
  new_scripts = [];
  /** @internal */
  new_script_start = [];
  /** @internal */
  new_scripts_pre_setup_callbacks = [];
  /** @internal */
  new_scripts_post_setup_callbacks = [];
  /** @internal */
  new_scripts_xr = [];
  /** 
   * The **main camera component** of the scene - this camera is used for rendering.  
   * Use `setCurrentCamera` for updating the main camera.
   */
  mainCameraComponent = void 0;
  /** 
   * The main camera of the scene - this camera is used for rendering   
   * Use `setCurrentCamera` for updating the main camera.
   */
  get mainCamera() {
    if (this._mainCamera)
      return this._mainCamera;
    if (this.mainCameraComponent) {
      const e = this.mainCameraComponent;
      return e.threeCamera || e.buildCamera(), e.threeCamera;
    }
    return this._fallbackCamera || (this._fallbackCamera = new de(75, this.domWidth / this.domHeight, 0.1, 1e3)), this._fallbackCamera;
  }
  /** Set the main camera of the scene. If set to null the camera of the {@link mainCameraComponent} will be used - this camera is used for rendering */
  set mainCamera(e) {
    this._mainCamera = e;
  }
  _mainCamera = null;
  _fallbackCamera = null;
  /** access application state (e.g. if all audio should be muted) */
  application;
  /** access animation mixer used by components in the scene */
  animations;
  /** access timings (current frame number, deltaTime, timeScale, ...) */
  time;
  /** access input data (e.g. click or touch events) */
  input;
  /** access physics related methods (e.g. raycasting). To access the phyiscs engine use `context.physics.engine` */
  physics;
  /** access networking methods (use it to send or listen to messages or join a networking backend) */
  connection;
  /** 
   * @deprecated AssetDataBase is deprecated
   */
  assets;
  /** The main light in the scene */
  mainLight = null;
  /** @deprecated Use sceneLighting */
  get rendererData() {
    return this.sceneLighting;
  }
  sceneLighting;
  addressables;
  lightmaps;
  players;
  lodsManager;
  /** Access the needle menu to add or remove buttons to the menu element */
  menu;
  /** @returns true if the context is fully created and ready */
  get isCreated() {
    return this._isCreated;
  }
  _needsUpdateSize = !1;
  _isCreated = !1;
  _isCreating = !1;
  _isVisible = !1;
  _stats = IO ? new TS() : null;
  constructor(e) {
    this.name = e?.name || "", this.alias = e?.alias, this.domElement = e?.domElement || document.body, this.hash = e?.hash, e?.renderer && (this.renderer = e.renderer, this.isManagedExternally = !0), e?.runInBackground !== void 0 && (this.runInBackground = e.runInBackground), e?.scene ? this.scene = e.scene : this.scene = new wi(), e?.camera && (this._mainCamera = e.camera), this.application = new Fn(this), this.time = new OO(), this.input = new O1(this), this.physics = new uc(this), this.connection = new N1(this), this.assets = new sP(), this.sceneLighting = new CO(this), this.addressables = new oO(this), this.lightmaps = new fO(this), this.players = new yO(this), this.menu = new AO(this), this.lodsManager = new pO(this), this.animations = new hO(this);
    const t = () => this._needsUpdateSize = !0;
    window.addEventListener("resize", t), this._disposeCallbacks.push(() => window.removeEventListener("resize", t));
    const i = new ResizeObserver((n) => this._needsUpdateSize = !0);
    i.observe(this.domElement), this._disposeCallbacks.push(() => i.disconnect()), this._intersectionObserver = new IntersectionObserver((n) => {
      this._isVisible = n[0].isIntersecting;
    }), this._disposeCallbacks.push(() => this._intersectionObserver?.disconnect()), ue.register(this);
  }
  /** 
   * Calling this function will dispose the current renderer and create a new one which will then be assigned to the context. It can be used to create a new renderer with custom WebGLRendererParameters.   
   * **Note**: Instead you can also modify the static `Context.DefaultWebGlRendererParameters` before the context is created.  
   * **Note**: This method is recommended because it re-uses an potentially already existing canvas element. This is necessary to keep input event handlers from working (e.g. components like OrbitControls subscribe to input events on the canvas)
   * @returns {WebGLRenderer} the newly created renderer
   */
  createNewRenderer(e) {
    if (this.renderer?.dispose(), e = { ...N.DefaultWebGLRendererParameters, ...e }, !e.canvas) {
      const t = this.domElement?.shadowRoot?.querySelector("canvas");
      t && (e.canvas = t, qe && console.log("Using canvas from shadow root", t));
    }
    return qe && console.log("Using Renderer Parameters:", e, this.domElement), this.renderer = new mr(e), this.renderer.debug.checkShaderErrors = L() || w("checkshadererrors") === !0, this.renderer.toneMappingExposure = 1, this.renderer.toneMapping = id, this.renderer.setClearColor(new se("lightgrey"), 0), this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = wx, this.renderer.setSize(this.domWidth, this.domHeight), this.renderer.outputColorSpace = Cs, this.renderer.nodes = {
      library: new xx(),
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    }, this.lodsManager.setRenderer(this.renderer), this.input.bindEvents(), this.renderer;
  }
  _intersectionObserver = null;
  internalOnUpdateVisible() {
    this._intersectionObserver?.disconnect(), this._intersectionObserver?.observe(this.domElement);
  }
  _disposeCallbacks = [];
  /** will request a renderer size update the next render call (will call updateSize the next update) */
  requestSizeUpdate() {
    this._needsUpdateSize = !0;
  }
  /** Clamps the renderer max resolution. If undefined the max resolution is not clamped. Default is undefined */
  maxRenderResolution;
  /** Control the renderer devicePixelRatio.  
   * **Options**   
   * - `auto` - Needle Engine automatically sets the pixel ratio to the current window.devicePixelRatio.
   * - `manual` - Needle Engine will not change the renderer pixel ratio. You can set it manually.
   * - `number` - Needle Engine will set the pixel ratio to the given number. The change will be applied to the renderer and the composer (if used) at the end of the current frame.
   */
  get devicePixelRatio() {
    return this._devicePixelRatio;
  }
  set devicePixelRatio(e) {
    e !== this._devicePixelRatio && (this._devicePixelRatio = e, this._needsUpdateSize = !0);
  }
  _devicePixelRatio = "auto";
  /** 
   * Update the renderer and canvas size. This is also automatically called when a DOM size change is detected.
   */
  updateSize(e = !1) {
    if (e || !this.isManagedExternally && this.renderer.xr?.isPresenting === !1) {
      this._needsUpdateSize = !1;
      const t = this.resolutionScaleFactor;
      let i = this.domWidth * t, n = this.domHeight * t;
      this.maxRenderResolution && (this.maxRenderResolution.x = Math.max(1, this.maxRenderResolution.x), i = Math.min(this.maxRenderResolution.x, i), this.maxRenderResolution.y = Math.max(1, this.maxRenderResolution.y), n = Math.min(this.maxRenderResolution.y, n));
      const o = this.mainCamera;
      this.updateAspect(o), this.renderer.setSize(i, n, !0), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%";
      const r = typeof this.devicePixelRatio == "number" ? this.devicePixelRatio : this.devicePixelRatio === "auto" ? Math.min(2, window.devicePixelRatio) : void 0;
      r !== void 0 && this.renderer.setPixelRatio(r), this.composer && (this.composer.setSize?.call(this.composer, i, n), r !== void 0 && "setPixelRatio" in this.composer && typeof this.composer.setPixelRatio == "function" && this.composer.setPixelRatio?.call(this.composer, window.devicePixelRatio));
    }
  }
  /**
   * Update the camera aspect ratio or orthorgraphic camera size. This is automatically called when a DOM size change is detected.
   */
  updateAspect(e, t, i) {
    if (!e) return;
    t === void 0 && (t = this.domWidth), i === void 0 && (i = this.domHeight);
    const n = t / i;
    if (e.isPerspectiveCamera) {
      const o = e, r = o.aspect;
      o.aspect = n, r !== o.aspect && e.updateProjectionMatrix();
    } else if (e.isOrthographicCamera) {
      const o = e, r = o.top - o.bottom, l = r * n / 2, c = r / 2;
      (o.left != -l || o.top != c) && (o.left = -l, o.right = l, o.top = c, o.bottom = -c, e.updateProjectionMatrix());
    }
  }
  /** This will recreate the whole needle engine context and dispose the whole scene content  
   * All content will be reloaded (loading times might be faster due to browser caches)   
   * All scripts will be recreated */
  recreate() {
    this.clear(), this.create(this._originalCreationArgs);
  }
  _originalCreationArgs;
  /** @deprecated use create. This method will be removed in a future version */
  async onCreate(e) {
    return this.create(e);
  }
  /** @internal */
  async create(e) {
    try {
      this._isCreating = !0, e !== this._originalCreationArgs && (this._originalCreationArgs = Xd(e)), window.addEventListener("unhandledrejection", this.onUnhandledRejection);
      const t = await this.internalOnCreate(e);
      return this._isCreated = t, t;
    } finally {
      window.removeEventListener("unhandledrejection", this.onUnhandledRejection), this._isCreating = !1;
    }
  }
  onUnhandledRejection = (e) => {
    this.onError(e.reason);
  };
  /** Dispatches an error */
  onError(e) {
    this.domElement.dispatchEvent(new CustomEvent("error", { detail: e }));
  }
  /** 
   * Clears the context and destroys all scenes and objects in the scene.   
   * The ContextCleared event is called at the end.   
   * This is automatically called when e.g. the `src` attribute changes on `<needle-engine>`   
   * or when the web component is removed from the DOM
   */
  clear() {
    ue.dispatchCallback(he.ContextClearing, this), yn(this, he.ContextClearing), Gi(this.scene, !0, !0), this.scene = new wi(), this.addressables?.dispose(), this.lightmaps?.clear(), this.physics?.engine?.clearCaches(), this.lodsManager.disable(), this._onBeforeRenderListeners.clear(), this._onAfterRenderListeners.clear(), this.isManagedExternally || this.renderer && (this.renderer.renderLists.dispose(), this.renderer.state.reset(), this.renderer.resetState()), ue.dispatchCallback(he.ContextCleared, this);
  }
  /**
   * Dispose all allocated resources and clears the scene. This is automatically called e.g. when the `<needle-engine>` component is removed from the DOM.
   */
  dispose() {
    this.internalOnDestroy();
  }
  /**@deprecated use dispose()  */
  onDestroy() {
    this.internalOnDestroy();
  }
  internalOnDestroy() {
    N.Current = this, ue.dispatchCallback(he.ContextDestroying, this), yn(this, he.ContextDestroying), this.clear(), this.renderer?.setAnimationLoop(null), this.renderer && (this.renderer.setClearAlpha(0), this.renderer.clear(), this.isManagedExternally || (qe && console.log("Disposing renderer"), this.renderer.dispose())), this.scene = null, this.renderer = null, this.input.dispose(), this.menu.onDestroy(), this.animations.onDestroy();
    for (const e of this._disposeCallbacks)
      try {
        e();
      } catch (t) {
        console.error("Error in on dispose callback:", t, e);
      }
    this.domElement?.parentElement && this.domElement.parentElement.removeChild(this.domElement), this._isCreated = !1, ue.dispatchCallback(he.ContextDestroyed, this), yn(this, he.ContextDestroyed), ue.unregister(this), N.Current === this && (N.Current = null);
  }
  /** @internal Automatically called by components when you call `startCoroutine`. Use `startCoroutine` instead  */
  registerCoroutineUpdate(e, t, i) {
    return typeof t?.next != "function" ? (console.error("Registered invalid coroutine function from " + e.name + `
Coroutine functions must be generators: "*myCoroutine() {...}"
Start a coroutine from a component by calling "this.startCoroutine(myCoroutine())"`), t) : (this.coroutines[i] || (this.coroutines[i] = []), this.coroutines[i].push({ comp: e, main: t }), t);
  }
  /** @internal Automatically called by components. */
  unregisterCoroutineUpdate(e, t) {
    if (!this.coroutines[t]) return;
    const i = this.coroutines[t].findIndex((n) => n.main === e);
    i >= 0 && this.coroutines[t].splice(i, 1);
  }
  /** @internal Automatically called */
  stopAllCoroutinesFrom(e) {
    for (const t in this.coroutines) {
      const i = this.coroutines[t];
      for (let n = i.length - 1; n >= 0; n--)
        i[n].comp === e && i.splice(n, 1);
    }
  }
  _cameraStack = [];
  /** Change the main camera */
  setCurrentCamera(e) {
    if (!e) return;
    if (e.threeCamera || e.buildCamera(), !e.threeCamera) {
      console.warn("Camera component is missing camera", e);
      return;
    }
    const t = this._cameraStack.indexOf(e);
    t >= 0 && this._cameraStack.splice(t, 1), this._cameraStack.push(e), this.mainCameraComponent = e;
    const i = e.threeCamera;
    i.isPerspectiveCamera && this.updateAspect(i), this.mainCameraComponent?.applyClearFlagsIfIsActiveCamera();
  }
  /**
   * Remove the camera from the mainCamera stack (if it has been set before with `setCurrentCamera`)
   */
  removeCamera(e) {
    if (!e) return;
    const t = this._cameraStack.indexOf(e);
    if (t >= 0 && this._cameraStack.splice(t, 1), this.mainCameraComponent === e && (this.mainCameraComponent = void 0, this._cameraStack.length > 0)) {
      const i = this._cameraStack[this._cameraStack.length - 1];
      this.setCurrentCamera(i);
    }
  }
  _onBeforeRenderListeners = /* @__PURE__ */ new Map();
  _onAfterRenderListeners = /* @__PURE__ */ new Map();
  /** Use to subscribe to onBeforeRender events on threejs objects.
   * @link https://threejs.org/docs/#api/en/core/Object3D.onBeforeRender
   */
  addBeforeRenderListener(e, t) {
    if (!this._onBeforeRenderListeners.has(e.uuid)) {
      const i = [];
      this._onBeforeRenderListeners.set(e.uuid, i), e.onBeforeRender = this._createRenderCallbackWrapper(i);
    }
    this._onBeforeRenderListeners.get(e.uuid).push(t);
  }
  /** Remove callback from three `onBeforeRender` event (if it has been added with `addBeforeRenderListener(...)`)
   * @link https://threejs.org/docs/#api/en/core/Object3D.onBeforeRender
  */
  removeBeforeRenderListener(e, t) {
    if (this._onBeforeRenderListeners.has(e.uuid)) {
      const i = this._onBeforeRenderListeners.get(e.uuid), n = i.indexOf(t);
      n >= 0 && i.splice(n, 1);
    }
  }
  /** 
   * Subscribe to onAfterRender events on threejs objects 
   * @link https://threejs.org/docs/#api/en/core/Object3D.onAfterRender
  */
  addAfterRenderListener(e, t) {
    if (!this._onAfterRenderListeners.has(e.uuid)) {
      const i = [];
      this._onAfterRenderListeners.set(e.uuid, i), e.onAfterRender = this._createRenderCallbackWrapper(i);
    }
    this._onAfterRenderListeners.get(e.uuid)?.push(t);
  }
  /** 
   * Remove from onAfterRender events on threejs objects 
   * @link https://threejs.org/docs/#api/en/core/Object3D.onAfterRender
  */
  removeAfterRenderListener(e, t) {
    if (this._onAfterRenderListeners.has(e.uuid)) {
      const i = this._onAfterRenderListeners.get(e.uuid), n = i.indexOf(t);
      n >= 0 && i.splice(n, 1);
    }
  }
  _createRenderCallbackWrapper(e) {
    return (t, i, n, o, r, a) => {
      for (let l = 0; l < e.length; l++) {
        const c = e[l];
        c(t, i, n, o, r, a);
      }
    };
  }
  _requireDepthTexture = !1;
  _requireColorTexture = !1;
  _renderTarget;
  _isRendering = !1;
  /** @returns true while the WebGL renderer is rendering (between onBeforeRender and onAfterRender events) */
  get isRendering() {
    return this._isRendering;
  }
  setRequireDepth(e) {
    this._requireDepthTexture = e;
  }
  setRequireColor(e) {
    this._requireColorTexture = e;
  }
  get depthTexture() {
    return this._renderTarget?.depthTexture || null;
  }
  get opaqueColorTexture() {
    return this._renderTarget?.texture || null;
  }
  /** @returns true if the `<needle-engine>` DOM element is visible on screen (`context.domElement`) */
  get isVisibleToUser() {
    if (this.isInXR) return !0;
    if (!this._isVisible) return !1;
    if (!this._needsVisibleUpdate && this._lastStyleComputedResult !== void 0) return this._lastStyleComputedResult;
    this._needsVisibleUpdate = !1;
    const e = getComputedStyle(this.domElement);
    return this._lastStyleComputedResult = e.visibility !== "hidden" && e.display !== "none" && e.opacity !== "0", this._lastStyleComputedResult;
  }
  _needsVisibleUpdate = !0;
  _lastStyleComputedResult = void 0;
  _createId = 0;
  async internalOnCreate(e) {
    const t = ++this._createId;
    qe && console.log("Creating context", this.name, e);
    const i = globalThis["needle:dependencies:ready"];
    i instanceof Promise && (qe && console.log("Waiting for dependencies to be ready"), await i.catch((c) => {
      if (qe || L()) {
        if (Zd("Needle Engine dependencies failed to load. Please check the console for more details"), c instanceof ReferenceError) {
          let h = "YourComponentName";
          const d = c.message.indexOf("'");
          if (d > 0) {
            const f = c.message.indexOf("'", d + 1);
            if (f > 0) {
              const p = c.message.substring(d + 1, f);
              p.length > 3 && (h = p);
            }
          }
          console.error(`Needle Engine dependencies failed to load:

# Make sure you don't have circular imports in your scripts!

Possible solutions: 
→ Replace @serializable(${h}) in your script with @serializable(Behaviour)
→ If you only need type information try importing the type only, e.g: import { type ${h} }

---`, c);
          return;
        }
        console.error("Needle Engine dependencies failed to load", c);
      }
    }).then(() => {
      qe && console.log("Needle Engine dependencies are ready");
    })), this.clear();
    const n = this.renderer, o = !n || n.isDisposed === !0;
    this.isManagedExternally === !1 && o ? this.createNewRenderer() : this.lodsManager.setRenderer(this.renderer), this.renderer?.setAnimationLoop(null), N.Current = this, await ue.dispatchCallback(he.ContextCreationStart, this);
    let r = !0, a;
    try {
      N.Current = this, e ? a = await this.internalLoadInitialContent(t, e) : a = [];
    } catch (c) {
      console.error(c), r = !1;
    }
    if (!r)
      return this.onError("Failed to load initial content"), !1;
    if (t !== this._createId || e?.abortSignal?.aborted)
      return !1;
    if (this.internalOnUpdateVisible(), !this.renderer)
      return qe && console.warn("Context has no renderer (perhaps it was disconnected?", this.domElement.isConnected), !1;
    !this.isManagedExternally && !this.domElement.shadowRoot && this.domElement.prepend(this.renderer.domElement), N.Current = this, N.Current = this;
    for (let c = 0; c < this.new_scripts.length; c++) {
      const h = this.new_scripts[c];
      if (h.gameObject !== void 0 && h.gameObject !== null) {
        h.gameObject.userData === void 0 && (h.gameObject.userData = {}), h.gameObject.userData.components === void 0 && (h.gameObject.userData.components = []);
        const d = h.gameObject.userData.components;
        d.includes(h) || d.push(h);
      }
    }
    if (this.post_setup_callbacks)
      for (let c = 0; c < this.post_setup_callbacks.length; c++)
        N.Current = this, await this.post_setup_callbacks[c](this);
    if (!this._mainCamera) {
      N.Current = this;
      let c = null;
      Oa(this.scene, (h) => {
        const d = h;
        if (d?.isCamera) {
          if (Xl(d.gameObject), !d.activeAndEnabled) return;
          if (d.tag === "MainCamera")
            return c = d, !0;
          c = d;
        }
      }), c ? this.setCurrentCamera(c) : !ue.dispatchCallback(he.MissingCamera, this, { files: a }) && !this.mainCamera && !this.isManagedExternally && console.warn("Missing camera in main scene", this);
    }
    this.input.bindEvents(), N.Current = this, pd(this), this.physics.engine && (this.physics.engine?.step(0), this.physics.engine?.postStep()), !this.isManagedExternally && this.composer && this.mainCamera, this._needsUpdateSize = !0, this._stats && (this._stats.showPanel(0), this._stats.dom.style.position = "absolute", this.domElement.shadowRoot?.appendChild(this._stats.dom)), qe && wp(this.scene, !0), this.targetFrameRate === void 0 ? (qe && console.warn("No target framerate set, using default", N.DefaultTargetFrameRate), this.targetFrameRate = N._defaultTargetFramerate) : qe && console.log("Target framerate set to", this.targetFrameRate), this._dispatchReadyAfterFrame = !0;
    const l = ue.dispatchCallback(he.ContextCreated, this, { files: a });
    if (l) {
      const c = this.domElement;
      "internalSetLoadingMessage" in c && typeof c.internalSetLoadingMessage == "function" && c?.internalSetLoadingMessage("finish loading"), await l;
    }
    return e?.abortSignal?.aborted ? !1 : (yn(this, he.ContextCreated), qe && console.log("Context Created...", this.renderer, this.renderer.domElement), this._isCreating = !1, !this.isManagedExternally && !e?.abortSignal?.aborted && this.restartRenderLoop(), !0);
  }
  async internalLoadInitialContent(e, t) {
    const i = new Array();
    if (t.files.length === 0) return i;
    const n = [...t.files], o = {
      name: "",
      progress: null,
      index: 0,
      count: n.length
    }, r = Bn(), a = 0;
    for (let l = 0; l < n.length; l++) {
      if (t.abortSignal?.aborted) {
        qe && console.log("Aborting loading because of abort signal");
        break;
      }
      if (e !== this._createId) {
        qe && console.log("Aborting loading because create id changed", e, this._createId);
        break;
      }
      const c = n[l];
      t?.onLoadingStart?.call(this, l, c), qe && console.log("Context Load " + c);
      const h = await r.loadSync(this, c, c, a, (d) => {
        t.abortSignal?.aborted || (o.name = c, o.progress = d, o.index = l, o.count = n.length, t.onLoadingProgress?.call(this, o));
      });
      t?.onLoadingFinished?.call(this, l, c, h ?? null), h ? i.push({
        src: c,
        file: h
      }) : console.warn("Could not load file: " + c);
    }
    if (e !== this._createId || t.abortSignal?.aborted) {
      qe && console.log("Aborting loading because create id changed or abort signal was set", e, this._createId);
      for (const l of i)
        if (l && l.file)
          for (const c of l.file.scenes)
            Gi(c, !0, !0);
    } else {
      let l = !1;
      for (const c of i)
        c && c.file && (c.file.scene ? (l = !0, this.scene.add(c.file.scene)) : console.warn("No scene found in loaded file"));
      if (!l) {
        for (const c of i)
          if (c && c.file && "parser" in c.file) {
            let h = 0;
            if (!Array.isArray(c.file.parser.json.materials)) continue;
            for (let d = 0; d < c.file.parser.json.materials.length; d++) {
              const f = await c.file.parser.getDependency("material", d), p = new M();
              p.position.x = d * 1.1, p.position.y = h, this.scene.add(p), La.createPrimitive("ShaderBall", {
                parent: p,
                material: f
              });
            }
            h += 1;
          }
      }
    }
    return i;
  }
  /** Sets the animation loop.   
   * Can not be done while creating the context or when disposed 
   **/
  restartRenderLoop() {
    return this.renderer ? this._isCreating ? (console.warn("Can not start render loop while creating context"), !1) : (this.renderer.setAnimationLoop((e, t) => {
      this.isManagedExternally || this.update(e, t);
    }), !0) : (console.error("Can not start render loop without renderer"), !1);
  }
  _renderlooperrors = 0;
  /** Performs a full update step including script callbacks, rendering (unless isManagedExternally is set to false) and post render callbacks */
  update(e, t) {
    if (t === void 0 && (t = null), L() || qe || hP())
      try {
        this.internalStep(e, t), this._renderlooperrors = 0;
      } catch (i) {
        this._renderlooperrors += 1, (L() || qe) && (i instanceof Error || i instanceof TypeError) && Be("Caught unhandled exception during render-loop - see console for details.", Wi.Error), console.error("Frame #" + this.time.frame + `
`, i), this._renderlooperrors >= 3 && (console.warn("Stopping render loop due to error"), this.renderer.setAnimationLoop(null)), this.domElement.dispatchEvent(new CustomEvent("error", { detail: i }));
      }
    else
      this.internalStep(e, t);
  }
  /** Call to **manually** perform physics steps.   
   * By default the context uses the `physicsSteps` property to perform steps during the update loop   
   * If you just want to increase the accuracy of physics you can instead set the `physicsSteps` property to a higher value
   * */
  updatePhysics(e) {
    this.internalUpdatePhysics(e);
  }
  /**
   * Set a rect or dom element. The camera center will be moved to the center of the rect.  
   * This is useful if you have Needle Engine embedded in a HTML layout and while you want the webgl background to fill e.g. the whole screen you want to move the camera center to free space.  
   * For that you can simply pass in the rect or HMTL div that you want the camera to center on.
   * @param rect The focus rect or null to disable
   * @param settings Optional settings for the focus rect. These will override the `focusRectSettings` property
   */
  setCameraFocusRect(e, t) {
    this._focusRect = e, t && Object.assign(this.focusRectSettings, t);
  }
  get focusRect() {
    return this._focusRect;
  }
  /** Settings when a focus rect is set. Use `setCameraFocusRect(...)` to do so.  
   * This can be used to offset the renderer center e.g. to a specific DOM element.
   */
  focusRectSettings = {
    /** Controls how fast the rect is centered. Smaller values mean the rect is centered faster.   
     * A minimum value of 0 means the rect is centered instantly.
     * @default .05
    */
    damping: 0.05
  };
  _focusRect = null;
  _lastTimestamp = 0;
  _accumulatedTime = 0;
  _dispatchReadyAfterFrame = !1;
  // TODO: we need to skip after render callbacks if the render loop is managed externally. When changing this we also need to to update the r3f sample
  internalStep(e, t) {
    this.internalOnBeforeRender(e, t) !== !1 && (this.internalOnRender(), this.internalOnAfterRender());
  }
  internalOnBeforeRender(e, t) {
    this.renderer.info.autoReset = !!t, this.renderer.info.autoReset === !1 && this.renderer.info.reset(), this._needsVisibleUpdate = !0;
    const i = t !== null && this._xrFrame === null;
    if (this._xrFrame = t, i && this.domElement.dispatchEvent(new CustomEvent("xr-session-started", { detail: { context: this, session: this.xrSession, frame: t } })), this._currentFrameEvent = -1, this.isManagedExternally === !1 && this.isInXR === !1 && this.targetFrameRate !== void 0) {
      this._lastTimestamp === 0 && (this._lastTimestamp = e), this._accumulatedTime += (e - this._lastTimestamp) / 1e3, this._lastTimestamp = e;
      let n = this.targetFrameRate;
      if (typeof n == "object" && (n = n.value), this._accumulatedTime < 1 / (n + 1))
        return !1;
      this._accumulatedTime = 0;
    }
    if (this._stats?.begin(), N.Current = this, this.onHandlePaused()) return !1;
    for (N.Current = this, this.time.update(), DO && console.log("FPS", this.time.smoothedFps.toFixed(0)), pd(this), zh(this.scene), M0(this), yn(
      this,
      -1
      /* Start */
    ); this._cameraStack.length > 0 && (!this.mainCameraComponent || this.mainCameraComponent.destroyed); ) {
      this._cameraStack.splice(this._cameraStack.length - 1, 1);
      const n = this._cameraStack[this._cameraStack.length - 1];
      this.setCurrentCamera(n);
    }
    if (this.pre_update_oneshot_callbacks) {
      for (const n in this.pre_update_oneshot_callbacks)
        this.pre_update_oneshot_callbacks[n]();
      this.pre_update_oneshot_callbacks.length = 0;
    }
    if (this.pre_update_callbacks)
      for (const n in this.pre_update_callbacks)
        this.pre_update_callbacks[n]();
    this._currentFrameEvent = 0;
    for (let n = 0; n < this.scripts_earlyUpdate.length; n++) {
      const o = this.scripts_earlyUpdate[n];
      o.activeAndEnabled && o.earlyUpdate !== void 0 && (N.Current = this, o.earlyUpdate());
    }
    this.executeCoroutines(
      0
      /* EarlyUpdate */
    ), yn(
      this,
      0
      /* EarlyUpdate */
    ), this._currentFrameEvent = 1;
    for (let n = 0; n < this.scripts_update.length; n++) {
      const o = this.scripts_update[n];
      o.activeAndEnabled && o.update !== void 0 && (N.Current = this, o.update());
    }
    this.executeCoroutines(
      1
      /* Update */
    ), yn(
      this,
      1
      /* Update */
    ), this._currentFrameEvent = 2;
    for (let n = 0; n < this.scripts_lateUpdate.length; n++) {
      const o = this.scripts_lateUpdate[n];
      o.activeAndEnabled && o.lateUpdate !== void 0 && (N.Current = this, o.lateUpdate());
    }
    if (this.executeCoroutines(
      2
      /* LateUpdate */
    ), yn(
      this,
      2
      /* LateUpdate */
    ), this.physicsSteps === void 0 && (this.physicsSteps = 1), this.physics.engine && this.physicsSteps > 0 && this.internalUpdatePhysics(this.physicsSteps), this.isVisibleToUser || this.runInBackground) {
      if (this._focusRect && this.mainCamera instanceof de) {
        const n = this.focusRectSettings, o = n.damping > 0 ? this.time.deltaTime / n.damping : 1;
        $C(this._focusRect, o, this.mainCamera, this.renderer);
      }
      this._currentFrameEvent = 3;
      for (let n = 0; n < this.scripts_onBeforeRender.length; n++) {
        const o = this.scripts_onBeforeRender[n];
        o.activeAndEnabled && o.onBeforeRender !== void 0 && (N.Current = this, o.onBeforeRender(t));
      }
      if (this.executeCoroutines(
        3
        /* OnBeforeRender */
      ), yn(
        this,
        3
        /* OnBeforeRender */
      ), this._needsUpdateSize && this.updateSize(), this.pre_render_callbacks)
        for (const n in this.pre_render_callbacks)
          this.pre_render_callbacks[n](t);
    }
    return !0;
  }
  internalUpdatePhysics(e) {
    if (!this.physics.engine) return !1;
    const t = e, i = this.time.deltaTime / t;
    for (let n = 0; n < t; n++)
      this._currentFrameEvent = 9, this.executeCoroutines(
        9
        /* PrePhysicsStep */
      ), this.physics.engine.step(i), this._currentFrameEvent = 10, this.executeCoroutines(
        10
        /* PostPhysicsStep */
      );
    return this.physics.engine.postStep(), !0;
  }
  internalOnRender() {
    this.isManagedExternally || (pP(this), this._currentFrameEvent = -1, ES.update(), this.renderNow(), this._currentFrameEvent = 4);
  }
  internalOnAfterRender() {
    if (this.isVisibleToUser || this.runInBackground) {
      for (let e = 0; e < this.scripts_onAfterRender.length; e++) {
        const t = this.scripts_onAfterRender[e];
        t.activeAndEnabled && t.onAfterRender !== void 0 && (N.Current = this, t.onAfterRender());
      }
      if (this.executeCoroutines(
        4
        /* OnAfterRender */
      ), yn(
        this,
        4
        /* OnAfterRender */
      ), this.post_render_callbacks)
        for (const e in this.post_render_callbacks)
          this.post_render_callbacks[e]();
    }
    this._currentFrameEvent = -1, this.connection.sendBufferedMessagesNow(), this._stats && (this._stats.end(), this.time.frameCount % 150 === 0 && console.log(this.renderer.info.render.calls + " DrawCalls", `
Render:`, { ...this.renderer.info.render }, `
Memory:`, { ...this.renderer.info.memory }, `
Target Framerate: ` + this.targetFrameRate)), this._dispatchReadyAfterFrame && (this._dispatchReadyAfterFrame = !1, this.domElement.dispatchEvent(new CustomEvent("ready")), ue.dispatchCallback(he.ContextFirstFrameRendered, this));
  }
  _tempClearColor = new se();
  _tempClearColor2 = new se();
  renderNow(e) {
    if (!e && (e = this.mainCamera, !e))
      return !1;
    if (this.handleRendererContextLost(), this._isRendering = !0, this.renderRequiredTextures(), this.renderer.toneMapping !== id && X0(), this.composer && !this.isInXR) {
      e && "setMainCamera" in this.composer && this.composer.passes[0]?.mainCamera != e && this.composer.setMainCamera(e);
      const t = this.renderer.getClearColor(this._tempClearColor), i = this.renderer.getClearAlpha();
      this._tempClearColor2.copy(t), this.renderer.setClearColor(t.convertSRGBToLinear(), this.renderer.getClearAlpha()), this.composer.render(this.time.deltaTime), this.renderer.setClearColor(this._tempClearColor2, i);
    } else e && (this.isInXR && q.isMacOS() && this.renderer.clearDepth(), this.renderer.render(this.scene, e));
    return this._isRendering = !1, !0;
  }
  _contextRestoreTries = 0;
  handleRendererContextLost() {
    this.time.frame % 10 && this.renderer.getContext().isContextLost() && this._contextRestoreTries++ < 100 && (console.warn("Attempting to recover WebGL context..."), this.renderer.forceContextRestore());
  }
  /** returns true if we should return out of the frame loop */
  _wasPaused = !1;
  onHandlePaused() {
    const e = this.evaluatePaused();
    if (this._wasPaused !== e) {
      LO && console.log("Paused?", e, "context:" + this.alias);
      for (let t = 0; t < this.scripts_pausedChanged.length; t++) {
        const i = this.scripts_pausedChanged[t];
        i.activeAndEnabled && i.onPausedChanged !== void 0 && (N.Current = this, i.onPausedChanged(e, this._wasPaused));
      }
    }
    return this._wasPaused = e, e;
  }
  evaluatePaused() {
    return this.isInXR ? !1 : this.isPaused ? !0 : this.runInBackground ? !1 : !this.isVisibleToUser;
  }
  renderRequiredTextures() {
    if (!this.mainCamera || !this._requireDepthTexture && !this._requireColorTexture) return;
    if (!this._renderTarget) {
      if (this._renderTarget = new Dn(this.domWidth, this.domHeight), this._requireDepthTexture) {
        const i = new Rb(this.domWidth, this.domHeight);
        this._renderTarget.depthTexture = i;
      }
      this._requireColorTexture && (this._renderTarget.texture = new Te(), this._renderTarget.texture.generateMipmaps = !1, this._renderTarget.texture.minFilter = nd, this._renderTarget.texture.magFilter = nd, this._renderTarget.texture.format = Wd);
    }
    const e = this._renderTarget;
    e.texture && (e.texture.colorSpace = this.renderer.outputColorSpace);
    const t = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(e), this.renderer.render(this.scene, this.mainCamera), this.renderer.setRenderTarget(t);
  }
  executeCoroutines(e) {
    if (this.coroutines[e]) {
      const i = this.coroutines[e];
      for (let n = 0; n < i.length; n++)
        try {
          const o = i[n];
          if (!o.comp || o.comp.destroyed || !o.main || o.comp.enabled === !1) {
            jO && console.log("Removing coroutine", o.comp, o.comp.enabled), i.splice(n, 1), --n;
            continue;
          }
          const a = o.chained;
          if (a && a.length > 0) {
            const d = a[a.length - 1].next();
            if (d.done && a.pop(), t(d) && (o.chained || (o.chained = []), o.chained.push(d.value)), !d.done) continue;
          }
          const l = o.main.next();
          if (l.done === !0) {
            i.splice(n, 1), --n;
            continue;
          }
          const c = l.value;
          if (t(c)) {
            if (c.next().done) continue;
            o.chained || (o.chained = []), o.chained.push(c);
          } else if (c instanceof Promise) {
            const h = c;
            o.chained || (o.chained = []);
            const d = dO(h);
            o.chained?.push(d);
            continue;
          }
        } catch (o) {
          console.error(o);
        }
    }
    function t(i) {
      return !!(i && i.next && i.return);
    }
  }
}
const mi = w("debuglicense"), Z0 = [];
let In = "basic";
mi && console.log("License Type: " + In);
function bs() {
  switch (In) {
    case "pro":
    case "enterprise":
      return !0;
  }
  return !1;
}
function ru() {
  switch (In) {
    case "indie":
      return !0;
  }
  return !1;
}
function eg() {
  switch (In) {
    case "edu":
      return !0;
  }
  return !1;
}
function vs() {
  return bs() || ru() || eg();
}
function BO(s) {
  if (bs() || ru() || eg())
    return s(!0);
  Z0.push(s);
}
function fh(s) {
  for (const e of Z0)
    try {
      e(s);
    } catch {
    }
}
ue.registerCallback(he.ContextRegistered, (s) => {
  UO(s.context), zO(s.context), setTimeout(() => $O(s.context), 2e3);
});
let Ra, Np = !1, $p = "";
async function FO() {
  if (Ra) return Ra;
  if (In === "basic")
    try {
      const s = "https://engine.needle.tools/licensing/check?location=" + encodeURIComponent(window.location.href) + "&version=" + En + "&generator=" + encodeURIComponent(jm), e = await fetch(s, {
        method: "GET"
      }).catch((t) => {
        mi && console.error("License check failed", t);
      });
      e?.status === 200 ? (Np = !1, mi && console.log("License check succeeded"), In = "pro", fh(!0)) : e?.status === 403 ? (fh(!1), Np = !0, $p = await e.text()) : (fh(!1), mi && console.log("License check failed with status " + e?.status));
    } catch (s) {
      fh(!1), mi && console.error("License check failed", s);
    }
  else mi && console.log('Runtime license check is skipped because license is already applied as "' + In + '"');
}
Ra = FO();
async function zO(s) {
  function e() {
    const n = document.createElement("div");
    n.className = "needle-forbidden", n.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: all;
        zIndex: 2147483647;
        line-height: 1.5;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        `;
    const o = n.style.cssText, r = document.createElement("div");
    n.appendChild(r), r.style.cssText = `
        position: absolute;
        left: 0;
        right: 0;
        top:0;
        bottom: 0;
        padding: 10%;
        color: white;
        font-size: 20px;
        font-family: sans-serif;
        text-align: center;
        pointer-events: all;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: rgba(0,0,0,.3);
        text-shadow: 0 0 2px black;
        `;
    const a = r.style.cssText, l = $p?.length > 1 ? $p : "This web application has been paused.<br/>You might be in violation of the Needle Engine terms of use.<br/>Please contact the Needle support if you think this is a mistake.";
    return r.innerHTML = l, setInterval(() => {
      r.innerHTML !== l && (r.innerHTML = l), r.parentNode !== n && n.appendChild(r), n.style.cssText !== o && (n.style.cssText = o), r.style.cssText !== a && (r.style.cssText = a);
    }, 500), n;
  }
  let t = e();
  const i = t.style.cssText;
  setInterval(() => {
    Np === !0 && (t.style.cssText !== i && (t = e()), s.domElement.shadowRoot ? t.parentNode !== s.domElement.shadowRoot && s.domElement.shadowRoot?.appendChild(t) : t.parentNode != document.body && document.body.appendChild(t));
  }, 500);
}
async function UO(s) {
  try {
    if (!bs() && !ru())
      return kf(s);
  } catch (e) {
    return mi && console.log("License check failed", e), kf(s);
  }
  mi && kf(s);
}
async function kf(s) {
  let e = !1;
  s.domElement.addEventListener("ready", () => e = !0), await Ra?.catch(() => {
  }), !(bs() || ru()) && (vs() === !1 && NO(), e ? Wp(s) : s.domElement.addEventListener("ready", () => {
    Wp(s);
  }));
}
function Wp(s) {
  const e = `
        position: relative;
        display: block;
        background-size: 20px;
        background-position: 10px 5px;
        background-repeat:no-repeat;
        background-image:url('${J0}');
        background-max-size: 40px;
        padding: 10px;
        padding-left: 30px;
    `;
  if (In === "edu")
    console.log("%c This project is supported by Needle for Education – https://needle.tools", e);
  else
    return;
  const t = document.createElement("div");
  t.className = "needle-non-commercial-use", t.innerHTML = "Made with Needle for Education", s.domElement.shadowRoot?.appendChild(t);
  let i = `
        position: absolute;
        font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
        font-size: 12px;
        color: rgb(100, 100, 100);
        /*mix-blend-mode: difference;*/
        background-color: transparent;
        z-index: 10000;

        cursor: pointer;
        user-select: none;
        opacity: 0;

        bottom: 6px;
        right: 12px;
        transform: translateY(0px);
        transition: all .5s ease-in-out 1s;
    `;
  t.style.cssText = i, t.addEventListener("click", () => {
    window.open("https://needle.tools", "_blank");
  });
  let n = t.style.cssText;
  setTimeout(() => {
    i = i.replace("opacity: 0", "opacity: 1"), i = i.replace("transform: translateY(10px)", "transform: translateY(0)"), t.style.cssText = i, n = t.style.cssText;
  }, 100);
  const o = setInterval(() => {
    const r = s.domElement.shadowRoot || s.domElement;
    t.parentNode !== r && r.appendChild(t), n != t.style.cssText && (t.style.cssText = i, n = t.style.cssText);
  }, 1e3);
  eg() && setTimeout(() => {
    clearInterval(o), t?.remove(), setTimeout(() => {
      s.domElement.parentNode && Wp(s);
    }, 1e3 * 60 * 5);
  }, 2e4);
}
const J0 = "data:image/webp;base64,UklGRrABAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSKEAAAARN6CmbSM4WR7vdARON11EBDq3fLiNbVtVzpMCPlKAEzsx0Y/x+Ovuv4dn0EFE/ydAvz6YggXzgh5sVgXM/zOC/4sii7qgGvB5N7hmuQYwkvazWAu1JPW41FXSHq6pnaQWvqYH18Fc0j1hO/BFTtIeSBlJi5w6qIIO7IOrwhFsB2Yxukif0FTRLpXswHR8MxbslKe9VZsn/Ub5C7YFOpqSTABWUDgg6AAAAFAGAJ0BKiAAIAA+7VyoTqmkpCI3+qgBMB2JbACdMt69DwMIQBLhkTO6XwY00UEDK6cNIDnuNibPf0EgAP7Y1myuiQHLDsF/0h5unrGh6WAbv7aegg2ZMd3uRKfT/3SJztcaujYfTvMXspfCTmYcoO6a+vhC3ss4M8uM58t4siiu59I4aOl59e9Sr6xoxYlHf2v+NnBNpJYeJf8jABQAId/PXuBkLEFkiCucgSGEcfhvajql/j3reCGl0M5/9gQWy7ayNPs+wlvIxFnNfSlfuND4CZOCyxOHhRqOmHN4ULHo3tCSrUNvgAA=";
let g_ = 0;
async function NO(s) {
  const e = Date.now();
  if (e - g_ < 2e3) return;
  g_ = e;
  const t = `
        position: relative;
        display: block;
        font-size: 18px;
        background-size: 20px;
        background-position: 10px 5px;
        background-repeat:no-repeat;
        background-image:url('${J0}');
        background-max-size: 40px;
        margin-bottom: 5px;
        margin-top: .3em;
        margin-bottom: .5em;
        padding: .2em;
        padding-left: 25px;
        border-radius: .5em;
        border: 2px solid rgba(160,160,160,.3);
    `, n = `Needle Engine — No license active, commercial use is not allowed. Visit https://needle.tools/pricing for more information and licensing options! v${En}`;
  N.Current?.xr ? console.log(n) : console.log("%c " + n, t);
}
async function $O(s) {
  if (window.crossOriginIsolated) return;
  if (In === "pro") {
    const t = s?.domElement?.getAttribute("no-telemetry");
    if (t === "" || t === "true" || t === "1") {
      mi && console.debug("Telemetry is disabled");
      return;
    }
    mi && console.debug("Telemetry attribute: " + t);
  }
  try {
    const t = "https://needle-engine-analytics-v2-r26roub2hq-lz.a.run.app";
    if (t) {
      const i = window.location.href.split("?")[0];
      let n = "api/v2/new/request";
      t.endsWith("/") || (n = "/" + n);
      const o = In, r = `${t}${n}`;
      mi && console.debug("Sending beacon");
      const a = {
        license: o,
        url: i,
        hostname: window.location.hostname,
        pathname: window.location.pathname,
        // search: window.location.search,
        // hash: window.location.hash,
        version: En,
        generator: jm,
        build_time: c0,
        public_key: Rl
      }, l = navigator.sendBeacon?.(r, JSON.stringify(a));
      mi && console.debug("Sent beacon: " + l);
    }
  } catch (t) {
    mi && console.log("Failed to send non-commercial usage message to analytics backend", t);
  }
}
function WO(s, e) {
  return Ms(s, he.ContextCreated, e), () => yo(s, he.ContextCreated);
}
function yL(s, e) {
  return Ms(s, he.ContextClearing, e), () => yo(s, he.ContextClearing);
}
function _L(s, e) {
  return Ms(s, he.ContextDestroying, e), () => yo(s, he.ContextDestroying);
}
function tg(s, e) {
  return Ms(s, xe.Start, e), () => yo(s, xe.Start);
}
function VO(s, e) {
  return Ms(s, xe.Update, e), () => yo(s, xe.Update);
}
function bL(s, e) {
  return Ms(s, xe.OnBeforeRender, e), () => yo(s, xe.OnBeforeRender);
}
function vL(s, e) {
  return Ms(s, xe.OnAfterRender, e), () => yo(s, xe.OnAfterRender);
}
const HO = w("debugdecoders");
let Mf = null;
function ev() {
  if (!Mf) {
    const s = Mm(null);
    Mf = { dracoLoader: s.dracoLoader, ktx2Loader: s.ktx2Loader, meshoptDecoder: s.meshoptDecoder };
  }
  return Mf;
}
function y_(s) {
  s !== void 0 && typeof s == "string" && OS(s);
}
function __(s) {
  if (s !== void 0 && typeof s == "string" && s !== "js") {
    const e = ev();
    HO && console.log("Setting draco decoder type to", s), e.dracoLoader.setDecoderConfig({ type: s });
  }
}
function b_(s) {
  s !== void 0 && typeof s == "string" && PS(s);
}
function ig(s, e) {
  const t = ev();
  return e.renderer ? t.ktx2Loader.detectSupport(e.renderer) : console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures will probably fail"), SS(s), s.dracoLoader || s.setDRACOLoader(t.dracoLoader), s.ktx2Loader || s.setKTX2Loader(t.ktx2Loader), s.meshoptDecoder || s.setMeshoptDecoder(t.meshoptDecoder), CS(s, {
    progressive: !0
  }), s;
}
const lt = function(s) {
  return u(s);
}, u = function(s) {
  if (s === void 0 && (s = null), !Array.isArray(s))
    s = v_(s);
  else
    for (let e = 0; e < s.length; e++) {
      const t = s[e];
      s[e] = v_(t);
    }
  return function(e, t) {
    if (!e) {
      const n = typeof t == "string" ? t : t.name;
      console.warn(`@serializable without a target at '${n}'.`);
      return;
    }
    typeof t != "string" && (t = t.name), Object.getOwnPropertyDescriptor(e, "$serializedTypes") || (e.$serializedTypes = {});
    const i = e.$serializedTypes = e.$serializedTypes || {};
    i[t] = s;
  };
};
function v_(s) {
  switch (s?.prototype?.constructor?.name) {
    case "Number":
    case "String":
    case "Boolean":
      return null;
  }
  return s;
}
const co = w("debughotreload");
let gc = !1;
const Kl = /* @__PURE__ */ new Map();
function wL() {
  return gc;
}
function w_() {
  return globalThis.NEEDLE_HOT_RELOAD_ENABLED === !0;
}
function GO(s) {
  if (gc) {
    co && console.warn("[Needle Engine] Hot reloading is in progress, not registering instance", s);
    return;
  }
  co && console.log("[Needle Engine] Registering hot reload instance", s);
  const t = s.constructor.name;
  Kl.has(t) ? Kl.get(t)?.push(s) : Kl.set(t, [s]);
}
function qO(s) {
  if (gc) {
    co && console.warn("[Needle Engine] Hot reloading is in progress, not unregistering instance", s);
    return;
  }
  co && console.log("[Needle Engine] Unregistering hot reload instance", s);
  const t = s.constructor.name, i = Kl.get(t);
  if (!i) return;
  const n = i.indexOf(s);
  n !== -1 && i.splice(n, 1);
}
let x_ = !1;
function XO() {
  if (co || x_) return;
  x_ = !0;
  const s = console.error;
  console.error = (...e) => {
    if (e.length) {
      const t = e[0];
      if (typeof t == "string" && t.includes("[hmr] Failed to reload ")) {
        console.log("[Needle Engine] Hot reloading failed"), window.location.reload();
        return;
      }
    }
    s.apply(console, e);
  };
}
function xL(s) {
  co && console.log("[HMR] Apply changes", s, Object.keys(s)), XO();
  for (const e of Object.keys(s))
    try {
      gc = !0;
      const t = P.get(e);
      if (!t) {
        co && console.log("[HMR] Type not found: " + e);
        continue;
      }
      const i = s[e], n = Kl.get(i.name);
      let o = "[Needle Engine] Updating type: " + e;
      const r = n?.length ?? -1;
      r > 0 ? o += " x" + r : o += " (No instances registered)", console.log(o);
      const a = Object.getOwnPropertyNames(t.prototype), l = Object.getOwnPropertyDescriptors(i.prototype);
      for (const c in l)
        l[c].writable && (t.prototype[c] = s[e].prototype[c]);
      for (const c of a)
        l[c] || delete t.prototype[c];
      if (n) {
        const c = new i(), h = Object.getOwnPropertyDescriptors(c);
        for (const d of n) {
          const f = d, p = f.isComponent === !0, g = p ? f.activeAndEnabled : !0, b = p ? f.context : void 0;
          try {
            if (p && b && hs(f, b), p && g && (f.enabled = !1), d.onBeforeHotReloadFields && d.onBeforeHotReloadFields() === !1)
              continue;
            for (const m in h)
              if (h[m].writable) {
                if (d[m] === void 0)
                  d[m] = c[m];
                else if (typeof d[m] == "function" && !d[m].prototype) {
                  const _ = d[m], x = _.name, I = "bound ";
                  if (x === I) continue;
                  const O = _.name.substring(I.length), k = i.prototype[O];
                  k && (d[m] = k.bind(d));
                }
              }
            d.onAfterHotReloadFields && d.onAfterHotReloadFields();
          } finally {
            p && b && Hm(f, b), p && g && (f.enabled = !0);
          }
        }
      }
    } catch (t) {
      if (co) console.error(t);
      else return !1;
    } finally {
      gc = !1, Qo(Wi.Log, "Script changes applied (HMR)");
    }
  return !0;
}
class S extends M {
  /**
   * Unique identifier for this GameObject
   */
  guid;
  /**
   * Checks if a GameObject has been destroyed
   * @param go The GameObject to check
   * @returns True if the GameObject has been destroyed
   */
  static isDestroyed(e) {
    return Pa(e);
  }
  /**
   * Sets the active state of a GameObject
   * @param go The GameObject to modify
   * @param active Whether the GameObject should be active
   * @param processStart Whether to process the start callbacks if being activated
   */
  static setActive(e, t, i = !0) {
    e && (Wh(e, t), zh(e), t && i && M0(N.Current, e));
  }
  /**
   * Checks if the GameObject itself is active (same as go.visible)
   * @param go The GameObject to check
   * @returns True if the GameObject is active
   */
  static isActiveSelf(e) {
    return Pc(e);
  }
  /**
   * Checks if the GameObject is active in the hierarchy (e.g. if any parent is invisible or not in the scene it will be false)
   * @param go The GameObject to check
   * @returns True if the GameObject is active in the hierarchy
   */
  static isActiveInHierarchy(e) {
    return JP(e);
  }
  /**
   * Marks a GameObject to be rendered using instancing
   * @param go The GameObject to mark
   * @param instanced Whether the GameObject should use instanced rendering
   */
  static markAsInstancedRendered(e, t) {
    eO(e, t);
  }
  /**
   * Checks if a GameObject is using instanced rendering
   * @param instance The GameObject to check
   * @returns True if the GameObject is using instanced rendering
   */
  static isUsingInstancing(e) {
    return Ym(e);
  }
  /**
   * Executes a callback for all components of the provided type on the provided object and its children
   * @param instance Object to run the method on
   * @param cb Callback to run on each component, "return undefined;" to continue and "return <anything>;" to break the loop
   * @param recursive If true, the method will be run on all children as well
   * @returns The last return value of the callback
   */
  static foreachComponent(e, t, i = !0) {
    return Oa(e, t, i);
  }
  /**
   * Creates a new instance of the provided object that will be replicated to all connected clients
   * @param instance Object to instantiate
   * @param opts Options for the instantiation
   * @returns The newly created instance or null if creation failed
   */
  static instantiateSynced(e, t) {
    return e ? A0(e, t) : null;
  }
  static instantiate(e, t = null) {
    return "isAssetReference" in e, ka(e, t);
  }
  /**
   * Destroys an object on all connected clients (if in a networked session)
   * @param instance Object to destroy
   * @param context Optional context to use
   * @param recursive If true, all children will be destroyed as well
   */
  static destroySynced(e, t, i = !0) {
    if (!e) return;
    const n = e;
    t = t ?? N.Current, eu(n, t.connection, i);
  }
  /**
   * Destroys an object
   * @param instance Object to destroy
   * @param recursive If true, all children will be destroyed as well. Default: true
   */
  static destroy(e, t = !0) {
    return Gi(e, t);
  }
  /**
   * Adds an object to parent and ensures all components are properly registered
   * @param instance Object to add
   * @param parent Parent to add the object to
   * @param context Optional context to use
   */
  static add(e, t, i) {
    if (!(!e || !t)) {
      if (e === t) {
        console.warn("Can not add object to self", e);
        return;
      }
      i || (i = N.Current), t.add(e), Wh(e, !0), zh(e), i ? S.foreachComponent(e, (n) => {
        Hm(n, i), !n.__internalDidAwakeAndStart && i.new_script_start.includes(n) === !1 && i.new_script_start.push(n);
      }, !0) : console.warn("Missing context");
    }
  }
  /**
   * Removes the object from its parent and deactivates all of its components
   * @param instance Object to remove
   */
  static remove(e) {
    e && (e.parent?.remove(e), Wh(e, !1), zh(e), S.foreachComponent(e, (t) => {
      dP(t);
    }, !0));
  }
  /**
   * Invokes a method on all components including children (if a method with that name exists)
   * @param go GameObject to invoke the method on
   * @param functionName Name of the method to invoke
   * @param args Arguments to pass to the method
   */
  static invokeOnChildren(e, t, ...i) {
    this.invoke(e, t, !0, i);
  }
  /**
   * Invokes a method on all components that have a method matching the provided name
   * @param go GameObject to invoke the method on
   * @param functionName Name of the method to invoke
   * @param children Whether to invoke on children as well
   * @param args Arguments to pass to the method
   */
  static invoke(e, t, i = !1, ...n) {
    e && this.foreachComponent(e, (o) => {
      const r = o[t];
      r && typeof r == "function" && r?.call(o, ...n);
    }, i);
  }
  /** @deprecated use `addComponent` */
  // eslint-disable-next-line deprecation/deprecation
  static addNewComponent(e, t, i, n = !0) {
    return An(e, t, i, { callAwake: n });
  }
  /**
   * Adds a new component (or moves an existing component) to the provided object
   * @param go Object to add the component to
   * @param instanceOrType If an instance is provided it will be moved to the new object, if a type is provided a new instance will be created
   * @param init Optional init object to initialize the component with
   * @param opts Optional options for adding the component
   * @returns The added or moved component
   */
  static addComponent(e, t, i, n) {
    return An(e, t, i, n);
  }
  /**
   * Moves a component to a new object
   * @param go GameObject to move the component to
   * @param instance Component to move
   * @returns The moved component
   */
  static moveComponent(e, t) {
    return An(e, t);
  }
  /**
   * Removes a component from its object
   * @param instance Component to remove
   * @returns The removed component
   */
  static removeComponent(e) {
    return U0(e.gameObject, e), e;
  }
  /**
   * Gets or adds a component of the specified type
   * @param go GameObject to get or add the component to
   * @param typeName Constructor of the component type
   * @returns The existing or newly added component
   */
  static getOrAddComponent(e, t) {
    return tu(e, t);
  }
  /**
   * Gets a component on the provided object
   * @param go GameObject to get the component from
   * @param typeName Constructor of the component type
   * @returns The component if found, otherwise null
   */
  static getComponent(e, t) {
    return e === null ? null : Da(e, t);
  }
  /**
   * Gets all components of the specified type on the provided object
   * @param go GameObject to get the components from
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponents(e, t, i = null) {
    return e === null ? i ?? [] : iu(e, t, i);
  }
  /**
   * Finds an object or component by its unique identifier
   * @param guid Unique identifier to search for
   * @param hierarchy Root object to search in
   * @returns The found GameObject or Component, or null/undefined if not found
   */
  static findByGuid(e, t) {
    return W0(e, t);
  }
  /**
   * Finds the first object of the specified component type in the scene
   * @param typeName Constructor of the component type
   * @param context Context or root object to search in
   * @param includeInactive Whether to include inactive objects in the search
   * @returns The first matching component if found, otherwise null
   */
  static findObjectOfType(e, t, i = !0) {
    return su(e, t ?? N.Current, i);
  }
  /**
   * Finds all objects of the specified component type in the scene
   * @param typeName Constructor of the component type
   * @param context Context or root object to search in
   * @returns Array of matching components
   */
  static findObjectsOfType(e, t) {
    const i = [];
    return QP(e, i, t), i;
  }
  /**
   * Gets a component of the specified type in the gameObject's children hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @returns The first matching component if found, otherwise null
   */
  static getComponentInChildren(e, t) {
    return nu(e, t);
  }
  /**
   * Gets all components of the specified type in the gameObject's children hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponentsInChildren(e, t, i = null) {
    return Cc(e, t, i ?? void 0);
  }
  /**
   * Gets a component of the specified type in the gameObject's parent hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @returns The first matching component if found, otherwise null
   */
  static getComponentInParent(e, t) {
    return yd(e, t);
  }
  /**
   * Gets all components of the specified type in the gameObject's parent hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponentsInParent(e, t, i = null) {
    return Xm(e, t, i);
  }
  /**
   * Gets all components on the gameObject
   * @param go GameObject to get components from
   * @returns Array of all components
   */
  static getAllComponents(e) {
    const t = e.userData?.components;
    return t ? [...t] : [];
  }
  /**
   * Iterates through all components on the gameObject
   * @param go GameObject to iterate components on
   * @returns Generator yielding each component
   */
  static *iterateComponents(e) {
    const t = e?.userData?.components;
    if (t && Array.isArray(t))
      for (let i = 0; i < t.length; i++)
        yield t[i];
  }
}
class R {
  /** 
   * Indicates whether this object is a component
   * @internal 
   */
  get isComponent() {
    return !0;
  }
  __context;
  /**
   * The context this component belongs to, providing access to the runtime environment
   * including physics, timing utilities, camera, and scene
   */
  get context() {
    return this.__context ?? N.Current;
  }
  set context(e) {
    this.__context = e;
  }
  /**
   * Shorthand accessor for the current scene from the context
   * @returns The scene this component belongs to
   */
  get scene() {
    return this.context.scene;
  }
  /**
   * The layer value of the GameObject this component is attached to
   * Used for visibility and physics filtering
   */
  get layer() {
    return this.gameObject?.userData?.layer;
  }
  /**
   * The name of the GameObject this component is attached to
   * Used for debugging and finding objects
   */
  get name() {
    return this.gameObject?.name ? this.gameObject.name : this.gameObject?.userData.name;
  }
  __name;
  set name(e) {
    this.gameObject ? (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.name = e, this.__name = e) : this.__name = e;
  }
  /**
   * The tag of the GameObject this component is attached to
   * Used for categorizing objects and efficient lookup
   */
  get tag() {
    return this.gameObject?.userData.tag;
  }
  set tag(e) {
    this.gameObject && (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.tag = e);
  }
  /**
   * Indicates whether the GameObject is marked as static
   * Static objects typically don't move and can be optimized by the engine
   */
  get static() {
    return this.gameObject?.userData.static;
  }
  set static(e) {
    this.gameObject && (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.static = e);
  }
  // get hideFlags(): HideFlags {
  //     return this.gameObject?.hideFlags;
  // }
  /**
   * Checks if this component is currently active (enabled and part of an active GameObject hierarchy)
   * Components that are inactive won't receive lifecycle method calls
   * @returns True if the component is enabled and all parent GameObjects are active
   */
  get activeAndEnabled() {
    return !(this.destroyed || this.__isEnabled === !1 || !this.__isActiveInHierarchy);
  }
  get __isActive() {
    return this.gameObject.visible;
  }
  get __isActiveInHierarchy() {
    if (!this.gameObject) return !1;
    const e = this.gameObject[lo];
    return e === void 0 ? !0 : e;
  }
  set __isActiveInHierarchy(e) {
    this.gameObject && (this.gameObject[lo] = e);
  }
  /**
   * Reference to the GameObject this component is attached to
   * This is a three.js Object3D with additional GameObject functionality
   */
  gameObject;
  /**
   * Unique identifier for this component instance,
   * used for finding and tracking components
   */
  guid = "invalid";
  /**
   * Identifier for the source asset that created this component.
   * For example, URL to the glTF file this component was loaded from
   */
  sourceId;
  /**
   * Called once when the component becomes active for the first time.
   * This is the first lifecycle callback to be invoked
   */
  awake() {
  }
  /**
   * Called every time the component becomes enabled or active in the hierarchy.
   * Invoked after {@link awake} and before {@link start}.
   */
  onEnable() {
  }
  /**
   * Called every time the component becomes disabled or inactive in the hierarchy.
   * Invoked when the component or any parent GameObject becomes invisible
   */
  onDisable() {
  }
  /**
   * Called when the component is destroyed.
   * Use for cleanup operations like removing event listeners
   */
  onDestroy() {
    this.__destroyed = !0;
  }
  /**
   * Starts a coroutine that can yield to wait for events.
   * Coroutines allow for time-based sequencing of operations without blocking.
   * Coroutines are based on generator functions, a JavaScript language feature. 
   * 
   * @param routine Generator function to start
   * @param evt Event to register the coroutine for (default: FrameEvent.Update)
   * @returns The generator function that can be used to stop the coroutine
   * @example
   * Time-based sequencing of operations
   * ```ts
   * *myCoroutine() {
   *   yield WaitForSeconds(1); // wait for 1 second
   *   yield WaitForFrames(10); // wait for 10 frames
   *   yield new Promise(resolve => setTimeout(resolve, 1000)); // wait for a promise to resolve
   * }
   * ```
   * @example
   * Coroutine that logs a message every 5 frames
   * ```ts
   * onEnable() {
   *   this.startCoroutine(this.myCoroutine());
   * }
   * private *myCoroutine() {
   *   while(this.activeAndEnabled) {
   *     console.log("Hello World", this.context.time.frame);
   *     // wait for 5 frames
   *     for(let i = 0; i < 5; i++) yield;
   *   }
   * }
   * ```
   */
  startCoroutine(e, t = xe.Update) {
    return this.context.registerCoroutineUpdate(this, e, t);
  }
  /**
   * Stops a coroutine that was previously started with startCoroutine
   * @param routine The routine to be stopped
   * @param evt The frame event the routine was registered with
   */
  stopCoroutine(e, t = xe.Update) {
    this.context.unregisterCoroutineUpdate(e, t);
  }
  /**
   * Checks if this component has been destroyed
   * @returns True if the component or its GameObject has been destroyed
   */
  get destroyed() {
    return this.__destroyed;
  }
  /**
   * Destroys this component and removes it from its GameObject
   * After destruction, the component will no longer receive lifecycle callbacks
   */
  destroy() {
    this.__destroyed || this.__internalDestroy();
  }
  /** @internal */
  __didAwake = !1;
  /** @internal */
  __didStart = !1;
  /** @internal */
  __didEnable = !1;
  /** @internal */
  __isEnabled = void 0;
  /** @internal */
  __destroyed = !1;
  /** @internal */
  get __internalDidAwakeAndStart() {
    return this.__didAwake && this.__didStart;
  }
  /** @internal */
  constructor(e) {
    this.__didAwake = !1, this.__didStart = !1, this.__didEnable = !1, this.__isEnabled = void 0, this.__destroyed = !1, this._internalInit(e), w_() && GO(this);
  }
  /** @internal */
  __internalNewInstanceCreated(e) {
    return this.__didAwake = !1, this.__didStart = !1, this.__didEnable = !1, this.__isEnabled = void 0, this.__destroyed = !1, this._internalInit(e), this;
  }
  /**
   * Initializes component properties from an initialization object
   * @param init Object with properties to copy to this component
   * @internal
   */
  _internalInit(e) {
    if (typeof e == "object")
      for (const t of Object.keys(e)) {
        const i = e[t];
        typeof i != "function" && (this[t] = i);
      }
  }
  /** @internal */
  __internalAwake() {
    this.__didAwake || (this.__didAwake = !0, this.awake());
  }
  /** @internal */
  __internalStart() {
    this.__didStart || (this.__didStart = !0, this.start && this.start());
  }
  /** @internal */
  __internalEnable(e) {
    return this.__destroyed ? (L() && console.warn("[Needle Engine Dev] Trying to enable destroyed component"), !1) : this.__didAwake ? this.__didEnable ? (e !== !0 && (this.__isEnabled = !0), !1) : (this.__didEnable = !0, this.__isEnabled = !0, this.onEnable(), !0) : !1;
  }
  /** @internal */
  __internalDisable(e) {
    if (this.__didAwake) {
      if (!this.__didEnable) {
        e !== !0 && (this.__isEnabled = !1);
        return;
      }
      this.__didEnable = !1, this.__isEnabled = !1, this.onDisable();
    }
  }
  /** @internal */
  __internalDestroy() {
    this.__destroyed || (this.__destroyed = !0, this.__didAwake && (this.onDestroy?.call(this), this.dispatchEvent(new CustomEvent("destroyed", { detail: this }))), XP(this), w_() && qO(this));
  }
  /**
   * Controls whether this component is enabled
   * Disabled components don't receive lifecycle callbacks
   */
  get enabled() {
    return typeof this.__isEnabled == "boolean" ? this.__isEnabled : !0;
  }
  set enabled(e) {
    if (this.__destroyed) {
      L() && console.warn(`[Needle Engine Dev] Trying to ${e ? "enable" : "disable"} destroyed component`);
      return;
    }
    if (typeof e == "number" && (e >= 0.5 ? e = !0 : e = !1), !this.__didAwake) {
      this.__isEnabled = e;
      return;
    }
    e ? this.__internalEnable() : this.__internalDisable();
  }
  /**
   * Gets the position of this component's GameObject in world space.    
   * Note: This is equivalent to calling `this.gameObject.worldPosition`
   */
  get worldPosition() {
    return Z(this.gameObject);
  }
  /**
   * Sets the position of this component's GameObject in world space
   * @param val The world position vector to set
   */
  set worldPosition(e) {
    Ot(this.gameObject, e);
  }
  /**
   * Sets the position of this component's GameObject in world space using individual coordinates
   * @param x X-coordinate in world space
   * @param y Y-coordinate in world space
   * @param z Z-coordinate in world space
   */
  setWorldPosition(e, t, i) {
    ba(this.gameObject, e, t, i);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as a quaternion
   * Note: This is equivalent to calling `this.gameObject.worldQuaternion`
   */
  get worldQuaternion() {
    return be(this.gameObject);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using a quaternion
   * @param val The world rotation quaternion to set
   */
  set worldQuaternion(e) {
    jn(this.gameObject, e);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using quaternion components
   * @param x X component of the quaternion
   * @param y Y component of the quaternion
   * @param z Z component of the quaternion
   * @param w W component of the quaternion
   */
  setWorldQuaternion(e, t, i, n) {
    e0(this.gameObject, e, t, i, n);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as Euler angles (in radians)
   */
  get worldEuler() {
    return t0(this.gameObject);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using Euler angles (in radians)
   * @param val The world rotation Euler angles to set
   */
  set worldEuler(e) {
    i0(this.gameObject, e);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as Euler angles (in degrees)  
   * Note: This is equivalent to calling `this.gameObject.worldRotation`
   */
  get worldRotation() {
    return this.gameObject.worldRotation;
  }
  /**
   * Sets the rotation of this component's GameObject in world space using Euler angles (in degrees)
   * @param val The world rotation vector to set (in degrees)
   */
  set worldRotation(e) {
    this.setWorldRotation(e.x, e.y, e.z, !0);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using individual Euler angles
   * @param x X-axis rotation
   * @param y Y-axis rotation
   * @param z Z-axis rotation
   * @param degrees Whether the values are in degrees (true) or radians (false)
   */
  setWorldRotation(e, t, i, n = !0) {
    Kd(this.gameObject, e, t, i, n);
  }
  static _forward = new y();
  /**
   * Gets the forward direction vector (0,0,-1) of this component's GameObject in world space
   */
  get forward() {
    return R._forward.set(0, 0, -1).applyQuaternion(this.worldQuaternion);
  }
  static _right = new y();
  /**
   * Gets the right direction vector (1,0,0) of this component's GameObject in world space
   */
  get right() {
    return R._right.set(1, 0, 0).applyQuaternion(this.worldQuaternion);
  }
  static _up = new y();
  /**
   * Gets the up direction vector (0,1,0) of this component's GameObject in world space
   */
  get up() {
    return R._up.set(0, 1, 0).applyQuaternion(this.worldQuaternion);
  }
  // EventTarget implementation:
  /** 
   * Storage for event listeners registered to this component
   * @private
   */
  _eventListeners = /* @__PURE__ */ new Map();
  /**
   * Registers an event listener for the specified event type
   * @param type The event type to listen for
   * @param listener The callback function to execute when the event occurs
   */
  addEventListener(e, t) {
    this._eventListeners[e] = this._eventListeners[e] || [], this._eventListeners[e].push(t);
  }
  /**
   * Removes a previously registered event listener
   * @param type The event type the listener was registered for
   * @param listener The callback function to remove
   */
  removeEventListener(e, t) {
    if (!this._eventListeners[e]) return;
    const i = this._eventListeners[e].indexOf(t);
    i >= 0 && this._eventListeners[e].splice(i, 1);
  }
  /**
   * Dispatches an event to all registered listeners
   * @param evt The event object to dispatch
   * @returns Always returns false (standard implementation of EventTarget)
   */
  dispatchEvent(e) {
    if (!e || !this._eventListeners[e.type]) return !1;
    const t = this._eventListeners[e.type];
    for (let i = 0; i < t.length; i++)
      t[i](e);
    return !1;
  }
}
const SL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Behaviour: R,
  Component: R,
  GameObject: S
}, Symbol.toStringTag, { value: "Module" }));
var QO = Object.defineProperty, tv = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && QO(e, t, n), n;
};
class au extends R {
  from;
  to;
  width = 0;
  centered = !0;
  _centerPos;
  awake() {
    this._centerPos = new y();
  }
  update() {
    if (!this.from || !this.to) return;
    const e = Z(this.from).clone(), t = Z(this.to).clone(), i = e.distanceTo(t);
    this._centerPos.copy(e), this._centerPos.add(t), this._centerPos.multiplyScalar(0.5), Ot(this.gameObject, this.centered ? this._centerPos : e), this.gameObject.lookAt(Z(this.to).clone()), this.gameObject.scale.set(this.width, this.width, i);
  }
}
tv([
  u(S)
], au.prototype, "from");
tv([
  u(S)
], au.prototype, "to");
var YO = Object.defineProperty, KO = Object.getOwnPropertyDescriptor, vr = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? KO(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && YO(e, t, n), n;
};
const Fs = w("debuganimation");
let iv = class {
  x;
  y;
};
class ni extends R {
  get isAnimationComponent() {
    return !0;
  }
  addClip(e) {
    this.animations || (this.animations = []), this.animations.includes(e) || this.animations.push(e);
  }
  playAutomatically = !0;
  randomStartTime = !0;
  minMaxSpeed;
  minMaxOffsetNormalized;
  loop = !0;
  clampWhenFinished = !1;
  /**
   * The time in seconds of the first running animation action
   * @default 0
   */
  get time() {
    if (this.actions) {
      for (const e of this.actions)
        if (e.isRunning()) return e.time;
    }
    return 0;
  }
  set time(e) {
    if (this.actions)
      for (const t of this.actions)
        t.time = e;
  }
  get duration() {
    if (this.actions) {
      for (const e of this.actions)
        if (e.isRunning()) return e.getClip().duration;
    }
    return 0;
  }
  _tempAnimationClipBeforeGameObjectExisted = null;
  /**
   * Get the first animation clip in the animations array
   */
  get clip() {
    return this.animations?.length ? this.animations[0] : null;
  }
  /**
   * Set the first animation clip in the animations array
   */
  set clip(e) {
    if (!this.__didAwake) {
      Fs && console.warn("Assign clip during serialization", e), this._tempAnimationClipBeforeGameObjectExisted = e;
      return;
    }
    e && (this.gameObject.animations || (this.gameObject.animations = []), !this.animations.includes(e) && (this.animations.length > 0 ? this.animations.splice(0, 0, e) : this.animations.push(e)));
  }
  set clips(e) {
    this.animations = e;
  }
  _tempAnimationsArray;
  set animations(e) {
    e == null || !Array.isArray(e) || (this.gameObject ? this.gameObject.animations = e : this._tempAnimationsArray = e);
  }
  get animations() {
    return this.gameObject?.animations || this._tempAnimationsArray || [];
  }
  mixer = void 0;
  /**
   * The animation actions
   */
  get actions() {
    return this._actions;
  }
  set actions(e) {
    this._actions = e;
  }
  _actions;
  _handles;
  /** @internal */
  awake() {
    this.mixer = void 0, Fs && console.log("Animation Awake", this.name, this), this._tempAnimationsArray && (this.animations = this._tempAnimationsArray, this._tempAnimationsArray = void 0), this._tempAnimationClipBeforeGameObjectExisted && (this.clip = this._tempAnimationClipBeforeGameObjectExisted, this._tempAnimationClipBeforeGameObjectExisted = null), this.actions = [], this._handles = [];
  }
  /** @internal */
  onEnable() {
    if (this.playAutomatically && this.animations?.length > 0) {
      const e = Math.floor(Math.random() * this.animations.length), t = this.animations[e];
      this.play(e, {
        exclusive: !0,
        fadeDuration: 0,
        startTime: this.randomStartTime ? Math.random() * t.duration : 0,
        loop: this.loop,
        clampWhenFinished: this.clampWhenFinished
      });
    }
  }
  /** @internal */
  update() {
    this.mixer && (this.mixer.update(this.context.time.deltaTime), this._handles.forEach((e) => e.update()));
  }
  /** @internal */
  onDisable() {
    this.mixer && this.mixer.stopAllAction();
  }
  /** @internal */
  onDestroy() {
    this.context.animations.unregisterAnimationMixer(this.mixer);
  }
  /** Get an animation action by the animation clip name */
  getAction(e) {
    return this.actions?.find((t) => t.getClip().name === e) || null;
  }
  /** Is any animation playing? */
  get isPlaying() {
    if (this.actions) {
      for (let e = 0; e < this.actions.length; e++)
        if (this.actions[e].isRunning())
          return !0;
    }
    return !1;
  }
  /** Stops all currently playing animations */
  stopAll(e) {
    if (this.actions)
      for (const t of this.actions)
        e?.fadeDuration ? t.fadeOut(e.fadeDuration) : t.stop();
  }
  /**
   * Stops a specific animation clip or index. If clip is undefined then all animations will be stopped
   */
  stop(e, t) {
    if (e === void 0) {
      this.stopAll();
      return;
    } else if (typeof e == "number") {
      if (e >= this.animations.length) {
        Fs && console.log("No animation at index", e);
        return;
      }
      e = this.animations[e];
    } else typeof e == "string" && (e = this.animations.find((n) => n.name === e));
    if (!e) {
      console.error("Could not find clip", e);
      return;
    }
    const i = this.actions.find((n) => n.getClip() === e);
    if (!i) {
      console.error("Could not find action", e);
      return;
    }
    t?.fadeDuration ? i.fadeOut(t.fadeDuration) : i.stop();
  }
  /**
   * Pause all animations or a specific animation clip or index
   * @param clip optional animation clip, index or name, if undefined all animations will be paused
   * @param unpause if true, the animation will be resumed
   */
  pause(e, t = !1) {
    if (e === void 0) {
      for (const n of this.actions)
        n.paused = !t;
      return;
    } else if (typeof e == "number") {
      if (e >= this.animations.length) {
        Fs && console.log("No animation at index", e);
        return;
      }
      e = this.animations[e];
    } else typeof e == "string" && (e = this.animations.find((n) => n.name === e));
    if (!e) {
      console.error("Could not find clip", e);
      return;
    }
    const i = this.actions.find((n) => n.getClip() === e);
    if (!i) {
      console.error("Could not find action", e);
      return;
    }
    i.paused = !t;
  }
  /**
   * Resume all paused animations.   
   * Note that this will not fade animations in or out and just unpause previous animations. If an animation was faded out which means it's not running anymore, it will not be resumed.
   */
  resume() {
    for (const e of this.actions)
      e.paused = !1;
  }
  /**
   * Play an animation clip or an clip at the specified index.
   * @param clipOrNumber the animation clip, index or name to play. If undefined, the first animation in the animations array will be played
   * @param options the play options. Use to set the fade duration, loop, speed, start time, end time, clampWhenFinished
   * @returns a promise that resolves when the animation is finished (note that it will not resolve if the animation is looping)
   */
  play(e = 0, t) {
    if (Fs && console.log("PLAY", e), this.ensureMixer(), !this.mixer) {
      Fs && console.warn("Missing mixer", this);
      return;
    }
    e === void 0 && (e = 0);
    let i = e;
    if (typeof e == "number") {
      if (e >= this.animations.length) {
        Fs && console.log("No animation at index", e);
        return;
      }
      i = this.animations[e];
    } else typeof e == "string" && (i = this.animations.find((o) => o.name === e));
    if (!i) {
      console.error("Could not find clip", e);
      return;
    }
    t || (t = {});
    for (const o of this.actions)
      if (o.getClip() === i)
        return this.internalOnPlay(o, t);
    if (!i.tracks) {
      console.warn("Clip is no AnimationClip", i);
      return;
    }
    const n = this.mixer.clipAction(i);
    return this.actions.push(n), this.internalOnPlay(n, t);
  }
  internalOnPlay(e, t) {
    var i = this.actions.find((r) => r === e);
    if (i === e && i.isRunning() && i.time < i.getClip().duration) {
      const r = this.tryFindHandle(e);
      if (i.paused && (i.paused = !1), r) return r.waitForFinish();
    }
    if (t.loop === void 0 && (t.loop = this.loop), t.clampWhenFinished === void 0 && (t.clampWhenFinished = this.clampWhenFinished), t.minMaxOffsetNormalized === void 0 && this.randomStartTime && (t.minMaxOffsetNormalized = this.minMaxOffsetNormalized), t.minMaxSpeed === void 0 && (t.minMaxSpeed = this.minMaxSpeed), t?.exclusive ?? !0)
      for (const r of this.actions)
        r != i && (t.fadeDuration ? r.fadeOut(t.fadeDuration) : r.stop());
    if (t?.fadeDuration && e.fadeIn(t.fadeDuration), e.enabled = !0, t?.startTime != null)
      e.time = t.startTime;
    else if (t?.minMaxOffsetNormalized && t.minMaxOffsetNormalized.x != 0 && t.minMaxOffsetNormalized.y != 0) {
      const r = e.getClip();
      e.time = j.lerp(t.minMaxOffsetNormalized.x, t.minMaxOffsetNormalized.y, Math.random()) * r.duration;
    } else e.time >= e.getClip().duration && (e.time = 0);
    t?.minMaxSpeed ? e.timeScale = j.lerp(t.minMaxSpeed.x, t.minMaxSpeed.y, Math.random()) : e.timeScale = t?.speed ?? 1, t?.loop != null ? e.loop = t.loop ? Sx : pp : e.loop = pp, t?.clampWhenFinished && (e.clampWhenFinished = !0), e.paused = !1, e.play(), Fs && console.log("PLAY", e.getClip().name, e);
    const o = new ZO(e, this.mixer, t, (r) => {
      this._handles.splice(this._handles.indexOf(o), 1);
    });
    return this._handles.push(o), o.waitForFinish();
  }
  tryFindHandle(e) {
    for (const t of this._handles)
      if (t.action === e)
        return t;
  }
  ensureMixer() {
    if (!this.mixer) {
      const e = "animationMixer";
      this.gameObject[e] && (this.mixer = this.gameObject[e]), (!this.mixer || !this.mixer.clipAction) && (this.mixer = new Cm(this.gameObject), this.gameObject[e] = this.mixer);
    }
    this.context.animations.registerAnimationMixer(this.mixer);
  }
}
vr([
  u()
], ni.prototype, "playAutomatically", 2);
vr([
  u()
], ni.prototype, "randomStartTime", 2);
vr([
  u(iv)
], ni.prototype, "minMaxSpeed", 2);
vr([
  u(iv)
], ni.prototype, "minMaxOffsetNormalized", 2);
vr([
  u()
], ni.prototype, "loop", 2);
vr([
  u()
], ni.prototype, "clampWhenFinished", 2);
vr([
  u(ro)
], ni.prototype, "clips", 1);
class ZO {
  mixer;
  action;
  promise = null;
  _options;
  _resolveCallback = null;
  _resolvedOrRejectedCallback;
  constructor(e, t, i, n) {
    this.action = e, this.mixer = t, this._resolvedOrRejectedCallback = n, this._options = i;
  }
  waitForFinish() {
    return this.promise ? this.promise : (this.promise = new Promise((e) => {
      this._resolveCallback = e;
    }), this.mixer.addEventListener("finished", this.onFinished), this.promise);
  }
  update() {
    this._options && this._options.endTime !== void 0 && this.action.time > this._options.endTime && (this._options.loop === !0 ? this.action.time = this._options.startTime ?? 0 : (this.action.time = this._options.endTime, this.action.timeScale = 0, this.onResolve()));
  }
  onResolve() {
    this.dispose(), this._resolvedOrRejectedCallback?.call(this, this), this._resolveCallback?.call(this, this.action);
  }
  // private onLoop = (_evt: MixerEvent) => {
  // }
  onFinished = (e) => {
    e.action === this.action && this.onResolve();
  };
  dispose() {
    this.mixer.removeEventListener("finished", this.onFinished);
  }
}
const Gh = Symbol("objectIsAnimatedData");
function S_(s, e, t) {
  if (!s) return;
  if (s[Gh] === void 0) {
    if (!t) return;
    s[Gh] = /* @__PURE__ */ new Set();
  }
  const i = s[Gh];
  t ? i.add(e) : i.has(e) && i.delete(e);
}
function JO(s) {
  if (!s) return !1;
  const e = s[Gh];
  return e !== void 0 && e.size > 0;
}
class PL {
  _context;
  get context() {
    return this._context ?? N.Current;
  }
  get isStateMachineBehaviour() {
    return !0;
  }
}
class ph {
  /** The name of the animation */
  name;
  /** The hash of the name */
  nameHash;
  /** The normalized time of the animation */
  normalizedTime;
  /** The length of the animation */
  length;
  /** The current speed of the animation */
  speed;
  /** The current action playing. It can be used to modify the action */
  action;
  /**
   * If the state has any transitions
   */
  hasTransitions;
  constructor(e, t, i, n) {
    this.name = e.name, this.nameHash = e.hash, this.normalizedTime = t, this.length = i, this.speed = n, this.action = e.motion.action || null, this.hasTransitions = e.transitions?.length > 0 || !1;
  }
}
function ek(s, e) {
  return {
    name: "Empty",
    isLooping: !1,
    guid: e?.generateUUID() ?? ys.generateUUID(),
    index: -1,
    clip: new ro(s, 0, [])
  };
}
var Wo = /* @__PURE__ */ ((s) => (s[s.If = 1] = "If", s[s.IfNot = 2] = "IfNot", s[s.Greater = 3] = "Greater", s[s.Less = 4] = "Less", s[s.Equals = 6] = "Equals", s[s.NotEqual = 7] = "NotEqual", s))(Wo || {}), nv = /* @__PURE__ */ ((s) => (s[s.Float = 1] = "Float", s[s.Int = 3] = "Int", s[s.Bool = 4] = "Bool", s[s.Trigger = 9] = "Trigger", s))(nv || {});
const et = w("debuganimatorcontroller"), mh = w("debugrootmotion");
class cn {
  /**
   * Creates an AnimatorController from a set of animation clips.
   * Each clip becomes a state in the controller's state machine.
   * 
   * @param clips - The animation clips to use for creating states
   * @param options - Configuration options for the controller including looping behavior and transitions
   * @returns A new AnimatorController instance
   */
  static createFromClips(e, t = { looping: !1, autoTransition: !0, transitionDuration: 0 }) {
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const a = e[r], l = [];
      if (t.autoTransition !== !1) {
        const h = t.transitionDuration ?? 0, d = h / a.duration;
        let f = r;
        (t.autoTransition === void 0 || t.autoTransition === !0) && (f = (r + 1) % e.length), l.push({
          exitTime: 1 - d,
          offset: 0,
          duration: h,
          hasExitTime: !0,
          destinationState: f,
          conditions: []
        });
      }
      const c = {
        name: a.name,
        hash: r,
        // by using the index it's easy for users to call play(2) to play the clip at index 2
        motion: {
          name: a.name,
          clip: a,
          isLooping: t?.looping ?? !1
        },
        transitions: l,
        behaviours: []
      };
      i.push(c);
    }
    const n = {
      name: "AnimatorController",
      guid: new At(Date.now()).generateUUID(),
      parameters: [],
      layers: [{
        name: "Base Layer",
        stateMachine: {
          defaultState: 0,
          states: i
        }
      }]
    };
    return new cn(n);
  }
  /**
   * Plays an animation state by name or hash.
   * 
   * @param name - The name or hash identifier of the state to play
   * @param layerIndex - The layer index (defaults to 0)
   * @param normalizedTime - The normalized time to start the animation from (0-1)
   * @param durationInSec - Transition duration in seconds
   */
  play(e, t = -1, i = Number.NEGATIVE_INFINITY, n = 0) {
    if (t < 0) t = 0;
    else if (t >= this.model.layers.length) {
      console.warn("invalid layer");
      return;
    }
    const r = this.model.layers[t].stateMachine;
    for (const a of r.states)
      if (a.name === e || a.hash === e) {
        et && console.log("transition to ", a), this.transitionTo(a, n, i);
        return;
      }
    console.warn("Could not find " + e + " to play");
  }
  /**
   * Resets the controller to its initial state.
   */
  reset() {
    this.setStartTransition();
  }
  /**
   * Sets a boolean parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param value - The boolean value to set
   */
  setBool(e, t) {
    const i = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.filter((n) => n[i] === e).forEach((n) => n.value = t);
  }
  /**
   * Gets a boolean parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The boolean value of the parameter, or false if not found
   */
  getBool(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.find((i) => i[t] === e)?.value ?? !1;
  }
  /**
   * Sets a float parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param val - The float value to set
   * @returns True if the parameter was found and set, false otherwise
   */
  setFloat(e, t) {
    const i = typeof e == "string" ? "name" : "hash", n = this.model?.parameters?.filter((o) => o[i] === e);
    return n.forEach((o) => o.value = t), n?.length > 0;
  }
  /**
   * Gets a float parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The float value of the parameter, or 0 if not found
   */
  getFloat(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.find((i) => i[t] === e)?.value ?? 0;
  }
  /**
   * Sets an integer parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param val - The integer value to set
   */
  setInteger(e, t) {
    const i = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.filter((n) => n[i] === e).forEach((n) => n.value = t);
  }
  /**
   * Gets an integer parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The integer value of the parameter, or 0 if not found
   */
  getInteger(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.find((i) => i[t] === e)?.value ?? 0;
  }
  /**
   * Sets a trigger parameter to active (true).
   * Trigger parameters are automatically reset after they are consumed by a transition.
   * 
   * @param name - The name or hash identifier of the trigger parameter
   */
  setTrigger(e) {
    et && console.log("SET TRIGGER", e);
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.filter((i) => i[t] === e).forEach((i) => i.value = !0);
  }
  /**
   * Resets a trigger parameter to inactive (false).
   * 
   * @param name - The name or hash identifier of the trigger parameter
   */
  resetTrigger(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.filter((i) => i[t] === e).forEach((i) => i.value = !1);
  }
  /**
   * Gets the current state of a trigger parameter.
   * 
   * @param name - The name or hash identifier of the trigger parameter
   * @returns The boolean state of the trigger, or false if not found
   */
  getTrigger(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.find((i) => i[t] === e)?.value ?? !1;
  }
  /**
   * Checks if the controller is currently in a transition between states.
   * 
   * @returns True if a transition is in progress, false otherwise
   */
  isInTransition() {
    return this._activeStates.length > 1;
  }
  /** Set the speed of the animator controller. Larger values will make the animation play faster. */
  setSpeed(e) {
    this._speed = e;
  }
  _speed = 1;
  /**
   * Finds an animation state by name or hash.
   * @deprecated Use findState instead
   * 
   * @param name - The name or hash identifier of the state to find
   * @returns The found state or null if not found
   */
  FindState(e) {
    return this.findState(e);
  }
  /**
   * Finds an animation state by name or hash.
   * 
   * @param name - The name or hash identifier of the state to find
   * @returns The found state or null if not found
   */
  findState(e) {
    if (!e) return null;
    if (Array.isArray(this.model.layers)) {
      for (const t of this.model.layers)
        for (const i of t.stateMachine.states)
          if (i.name === e || i.hash == e) return i;
    }
    return null;
  }
  /**
   * Gets information about the current playing animation state.
   * 
   * @returns An AnimatorStateInfo object with data about the current state, or null if no state is active
   */
  getCurrentStateInfo() {
    if (!this._activeState) return null;
    const e = this._activeState.motion.action;
    if (!e) return null;
    const t = this._activeState.motion.clip.duration, i = t <= 0 ? 0 : Math.abs(e.time / t);
    return new ph(this._activeState, i, t, this._speed);
  }
  /**
   * Gets the animation action currently playing.
   * 
   * @returns The current animation action, or null if no action is playing
   */
  get currentAction() {
    if (!this._activeState) return null;
    const e = this._activeState.motion.action;
    return e || null;
  }
  /**
   * The normalized time (0-1) to start playing the first state at.
   * This affects the initial state when the animator is first enabled.
   */
  normalizedStartOffset = 0;
  /**
   * The Animator component this controller is bound to.
   */
  animator;
  /**
   * The data model describing the animation states and transitions.
   */
  model;
  /**
   * Gets the engine context from the bound animator.
   */
  get context() {
    return this.animator?.context;
  }
  /**
   * Gets the animation mixer used by this controller.
   */
  get mixer() {
    return this._mixer;
  }
  /**
   * Cleans up resources used by this controller.
   * Stops all animations and unregisters the mixer from the animation system.
   */
  dispose() {
    if (this._mixer.stopAllAction(), this.animator) {
      this._mixer.uncacheRoot(this.animator.gameObject);
      for (const e of this._activeStates)
        e.motion.clip && this.mixer.uncacheAction(e.motion.clip, this.animator.gameObject);
    }
    this.context?.animations.unregisterAnimationMixer(this._mixer);
  }
  // applyRootMotion(obj: Object3D) {
  //     // this.internalApplyRootMotion(obj);
  // }
  /**
   * Binds this controller to an animator component.
   * Creates a new animation mixer and sets up animation actions.
   * 
   * @param animator - The animator to bind this controller to
   */
  bind(e) {
    e ? this.animator !== e && (this._mixer && (this._mixer.stopAllAction(), this.context?.animations.unregisterAnimationMixer(this._mixer)), this.animator = e, this._mixer = new Cm(this.animator.gameObject), this.context?.animations.registerAnimationMixer(this._mixer), this.createActions(this.animator)) : console.error("AnimatorController.bind: animator is null");
  }
  /**
   * Creates a deep copy of this controller.
   * Clones the model data but does not copy runtime state.
   * 
   * @returns A new AnimatorController instance with the same configuration
   */
  clone() {
    if (typeof this.model == "string")
      return console.warn("AnimatorController has not been resolved, can not create model from string", this.model), null;
    et && console.warn("AnimatorController clone()", this.model);
    const e = Xd(this.model, (i, n, o) => o == null ? !0 : !(o.type === "Object3D" || o.isObject3D === !0 || e1(o) || o.tracks !== void 0 || o instanceof cn));
    return console.assert(e !== this.model), new cn(e);
  }
  /**
   * Updates the controller's state machine and animations.
   * Called each frame by the animator component.
   * 
   * @param weight - The weight to apply to the animations (for blending)
   */
  update(e) {
    if (!this.animator) return;
    this.evaluateTransitions(), this.updateActiveStates(e);
    const t = this.animator.context.time.deltaTime;
    this.animator.applyRootMotion && this.rootMotionHandler?.onBeforeUpdate(e), this._mixer.update(t), this.animator.applyRootMotion && this.rootMotionHandler?.onAfterUpdate(e);
  }
  _mixer;
  _activeState;
  /**
   * Gets the currently active animation state.
   * 
   * @returns The active state or undefined if no state is active
   */
  get activeState() {
    return this._activeState;
  }
  constructor(e) {
    this.model = e, et && console.log(this);
  }
  _activeStates = [];
  updateActiveStates(e) {
    for (let t = 0; t < this._activeStates.length; t++) {
      const i = this._activeStates[t], n = i.motion;
      if (!n.action)
        this._activeStates.splice(t, 1), t--;
      else {
        const o = n.action;
        o.weight = e, o.getEffectiveWeight() <= 0 && !o.isRunning() && (et && console.debug("REMOVE", i.name, o.getEffectiveWeight(), o.isRunning(), o.isScheduled()), this._activeStates.splice(t, 1), t--);
      }
    }
  }
  setStartTransition() {
    this.model.layers.length > 1 && (et || L()) && console.warn("Multiple layers are not supported yet " + this.animator?.name);
    for (const e of this.model.layers) {
      const t = e.stateMachine;
      t.defaultState === void 0 && (et && console.warn("AnimatorController default state is undefined, will assign state 0 as default", e), t.defaultState = 0);
      const i = t.states[t.defaultState];
      this.transitionTo(i, 0, this.normalizedStartOffset);
      break;
    }
  }
  evaluateTransitions() {
    let e = !1;
    if (!this._activeState) {
      if (this.setStartTransition(), !this._activeState) return;
      e = !0;
    }
    const t = this._activeState, i = t.motion.action;
    for (const o of t.transitions) {
      if (!o.hasExitTime && o.conditions.length <= 0)
        continue;
      let r = !0;
      for (const a of o.conditions)
        if (!this.evaluateCondition(a)) {
          r = !1;
          break;
        }
      if (r)
        if (i) {
          const a = t.motion.clip.duration, l = a <= 0 ? 1 : Math.abs(i.time / a);
          let c = o.exitTime;
          i.timeScale < 0 && (c = 1 - c);
          let h = !1;
          if (o.hasExitTime ? i.timeScale > 0 ? h = l >= o.exitTime : i.timeScale < 0 && (h = 1 - l >= o.exitTime) : h = !0, h) {
            for (const d of o.conditions) {
              const f = this.model.parameters.find((p) => p.name === d.parameter);
              f?.type === nv.Trigger && f.value && (f.value = !1);
            }
            if (i.clampWhenFinished = !0, et) {
              const d = this.getState(o.destinationState, 0);
              console.log(`Transition to ${o.destinationState} / ${d?.name}`, o, `
Timescale: ` + i.timeScale, `
Normalized time: ` + l.toFixed(3), `
Exit Time: ` + c, o.hasExitTime);
            }
            this.transitionTo(o.destinationState, o.duration, o.offset);
            return;
          }
        } else {
          this.transitionTo(o.destinationState, o.duration, o.offset);
          return;
        }
    }
    i && this.setTimescale(i, t);
    let n = !1;
    if (t.motion.isLooping && i && (i.time >= i.getClip().duration ? (n = !0, i.reset(), i.time = 0, i.play()) : i.time <= 0 && i.timeScale < 0 && (n = !0, i.reset(), i.time = i.getClip().duration, i.play())), !n && t && !e && i && this.animator && t.behaviours) {
      const o = i?.getClip().duration, r = i.time / o, a = new ph(this._activeState, r, o, this._speed);
      for (const l of t.behaviours)
        l.instance && l.instance.onStateUpdate?.call(l.instance, this.animator, a, 0);
    }
  }
  setTimescale(e, t) {
    let i = t.speed ?? 1;
    t.speedParameter && (i *= this.getFloat(t.speedParameter)), i !== void 0 && (e.timeScale = i * this._speed);
  }
  getState(e, t) {
    return typeof e == "number" && (e == -1 && (e = this.model.layers[t].stateMachine.defaultState, e === void 0 && (et && console.warn("AnimatorController default state is undefined: ", this.model, "Layer: " + t), e = 0)), e = this.model.layers[t].stateMachine.states[e]), e;
  }
  /**
   * These actions have been active previously but not faded out because we entered a state that has no real animation - no duration. In which case we hold the previously active actions until they are faded out.
   */
  _heldActions = [];
  releaseHeldActions(e) {
    for (const t of this._heldActions)
      t.fadeOut(e);
    this._heldActions.length = 0;
  }
  transitionTo(e, t, i) {
    if (!this.animator) return;
    const n = 0;
    if (e = this.getState(e, n), !e?.motion || !e.motion.clip || !(e.motion.clip instanceof ro))
      return;
    const o = this._activeState === e;
    if (o) {
      const h = e.motion;
      if (!h.action_loopback && h.clip) {
        const d = this.rootMotionHandler ? this.animator.gameObject.matrix.clone() : null;
        this._mixer.uncacheAction(h.clip, this.animator.gameObject), d && d.decompose(this.animator.gameObject.position, this.animator.gameObject.quaternion, this.animator.gameObject.scale), h.action_loopback = this.createAction(h.clip);
      }
    }
    if (this._activeState?.behaviours && this._activeState.motion.action) {
      const h = this._activeState?.motion.clip.duration, d = this._activeState.motion.action.time / h, f = new ph(this._activeState, d, h, this._speed);
      for (const p of this._activeState.behaviours)
        p.instance?.onStateExit?.call(p.instance, this.animator, f, n);
    }
    const r = this._activeState?.motion.action;
    o && (e.motion.action = e.motion.action_loopback, e.motion.action_loopback = r);
    const a = this._activeState;
    this._activeState = e;
    const l = e.motion?.action, c = e.motion.clip;
    if (c?.duration <= 0 && c.tracks.length <= 0 ? r && this._heldActions.push(r) : r && (r.fadeOut(t), this.releaseHeldActions(t)), l) {
      if (i = Math.max(0, Math.min(1, i)), e.cycleOffsetParameter) {
        let d = this.getFloat(e.cycleOffsetParameter);
        typeof d == "number" ? (d < 0 && (d += 1), i += d, i %= 1) : et && console.warn("AnimatorController cycle offset parameter is not a number", e.cycleOffsetParameter);
      } else typeof e.cycleOffset == "number" && (i += e.cycleOffset, i %= 1);
      l.isRunning() && l.stop(), l.reset(), l.enabled = !0, this.setTimescale(l, e);
      const h = e.motion.clip.duration;
      if (l.time = o ? 0 : i * h, l.timeScale < 0 && (l.time = h - l.time), l.clampWhenFinished = !0, l.setLoop(pp, 0), t > 0 ? l.fadeIn(t) : l.weight = 1, l.play(), this.rootMotionHandler && this.rootMotionHandler.onStart(l), this._activeStates.includes(e) || this._activeStates.push(e), this._activeState.behaviours) {
        const d = new ph(e, i, h, this._speed);
        for (const f of this._activeState.behaviours)
          f.instance?.onStateEnter?.call(f.instance, this.animator, d, n);
      }
    } else et && (e.__warned_no_motion || (e.__warned_no_motion = !0, console.warn("No action", e.motion, this)));
    et && console.log("TRANSITION FROM " + a?.name + " TO " + e.name, t, r, l, l?.getEffectiveTimeScale(), l?.getEffectiveWeight(), l?.isRunning(), l?.isScheduled(), l?.paused);
  }
  createAction(e) {
    if (this._mixer.existingAction(e) && this._mixer.uncacheAction(e, this.animator?.gameObject), this.animator?.applyRootMotion) {
      this.rootMotionHandler || (this.rootMotionHandler = new tk(this));
      const i = this.animator.gameObject;
      return this.rootMotionHandler.createClip(this._mixer, i, e);
    } else
      return this._mixer.clipAction(e);
  }
  evaluateCondition(e) {
    const t = this.model.parameters.find((i) => i.name === e.parameter);
    if (!t) return !1;
    switch (e.mode) {
      case Wo.If:
        return t.value === !0;
      case Wo.IfNot:
        return t.value === !1;
      case Wo.Greater:
        return t.value > e.threshold;
      case Wo.Less:
        return t.value < e.threshold;
      case Wo.Equals:
        return t.value === e.threshold;
      case Wo.NotEqual:
        return t.value !== e.threshold;
    }
    return !1;
  }
  createActions(e) {
    et && console.log("AnimatorController createActions", this.model);
    for (const t of this.model.layers) {
      const i = t.stateMachine;
      for (let n = 0; n < i.states.length; n++) {
        const o = i.states[n];
        o.transitions || (o.transitions = []);
        for (const r of o.transitions)
          r.conditions || (r.conditions = []);
        if (o.motion || (et && console.warn("No motion", o), o.motion = ek(o.name)), this.animator && o.motion.clips) {
          const r = o.motion.clips?.find((a) => a.node.name === this.animator?.gameObject?.name);
          r ? o.motion.clip = r.clip : (et || L()) && console.warn('Could not find clip for animator "' + this.animator?.gameObject?.name + '"', o.motion.clips.map((a) => a.node.name));
        }
        if (!o.motion.clip) {
          et && console.warn("No clip assigned to state", o);
          const r = new ro(void 0, void 0, []);
          o.motion.clip = r;
        }
        if (o.motion?.clip) {
          const r = o.motion.clip;
          if (r instanceof ro) {
            const a = this.createAction(r);
            o.motion.action = a;
          } else
            (et || L()) && console.warn("No valid animationclip assigned", o);
        }
        if (o.behaviours && Array.isArray(o.behaviours))
          for (const r of o.behaviours) {
            if (!r?.typeName) continue;
            const a = P.get(r.typeName);
            if (a) {
              const l = new a();
              l.isStateMachineBehaviour && (l._context = this.context ?? void 0, Ca(l, r.properties), r.instance = l), et && console.log("Created animator controller behaviour", o.name, r.typeName, r.properties, l);
            } else
              (et || L()) && console.warn("Could not find AnimatorBehaviour type: " + r.typeName);
          }
      }
    }
  }
  /**
   * Yields all animation actions managed by this controller.
   * Iterates through all states in all layers and returns their actions.
   */
  *enumerateActions() {
    if (this.model.layers)
      for (const e of this.model.layers) {
        const t = e.stateMachine;
        for (let i = 0; i < t.states.length; i++) {
          const n = t.states[i];
          n?.motion && (n.motion.action && (yield n.motion.action), n.motion.action_loopback && (yield n.motion.action_loopback));
        }
      }
  }
  // https://docs.unity3d.com/Manual/RootMotion.html
  rootMotionHandler;
  // private findRootBone(obj: Object3D): Object3D | null {
  //     if (this.animationRoot) return this.animationRoot;
  //     if (obj.type === "Bone") {
  //         this.animationRoot = obj as Bone;
  //         return this.animationRoot;
  //     }
  //     if (obj.children) {
  //         for (const ch of obj.children) {
  //             const res = this.findRootBone(ch);
  //             if (res) return res;
  //         }
  //     }
  //     return null;
  // }
}
class C_ {
  track;
  createdInterpolant;
  originalEvaluate;
  customEvaluate;
  constructor(e, t) {
    this.track = e;
    const i = e, n = i.createInterpolant.bind(e);
    i.createInterpolant = () => (i.createInterpolant = n, this.createdInterpolant = n(), this.originalEvaluate = this.createdInterpolant.evaluate.bind(this.createdInterpolant), this.customEvaluate = (o) => {
      if (!this.originalEvaluate) return;
      const r = this.originalEvaluate(o);
      return t(o, r);
    }, this.createdInterpolant.evaluate = this.customEvaluate, this.createdInterpolant);
  }
  dispose() {
    this.createdInterpolant && this.originalEvaluate && (this.createdInterpolant.evaluate = this.originalEvaluate), this.track = void 0, this.createdInterpolant = null, this.originalEvaluate = void 0, this.customEvaluate = void 0;
  }
}
class nt {
  static lastObjPosition = {};
  static lastObjRotation = {};
  // we remove the first keyframe rotation from the space rotation when updating
  static firstKeyframeRotation = {};
  // this is used to rotate the space on clip end / start (so the transform direction is correct)
  static spaceRotation = {};
  static effectiveSpaceRotation = {};
  static clipOffsetRotation = {};
  set action(e) {
    this._action = e;
  }
  get action() {
    return this._action;
  }
  get cacheId() {
    return this.root.uuid;
  }
  _action;
  root;
  clip;
  positionWrapper = null;
  rotationWrapper = null;
  context;
  positionChange = new y();
  rotationChange = new U();
  constructor(e, t, i, n, o) {
    if (this.context = e, this.root = t, this.clip = i, nt.firstKeyframeRotation[this.cacheId] || (nt.firstKeyframeRotation[this.cacheId] = new U()), o) {
      const r = o.values;
      nt.firstKeyframeRotation[this.cacheId].set(r[0], r[1], r[2], r[3]);
    }
    nt.spaceRotation[this.cacheId] || (nt.spaceRotation[this.cacheId] = new U()), nt.effectiveSpaceRotation[this.cacheId] || (nt.effectiveSpaceRotation[this.cacheId] = new U()), nt.clipOffsetRotation[this.cacheId] = new U(), o && nt.clipOffsetRotation[this.cacheId].set(o.values[0], o.values[1], o.values[2], o.values[3]).invert(), this.handlePosition(i, n), this.handleRotation(i, o);
  }
  onStart(e) {
    if (e.getClip() !== this.clip) return;
    nt.lastObjRotation[this.cacheId] || (nt.lastObjRotation[this.cacheId] = this.root.quaternion.clone());
    const t = nt.lastObjRotation[this.cacheId];
    if (nt.spaceRotation[this.cacheId].copy(t), mh) {
      const i = new ot().setFromQuaternion(t);
      console.log("START", this.clip.name, j.toDegrees(i.y), this.root.position.z);
    }
  }
  getClipRotationOffset() {
    return nt.clipOffsetRotation[this.cacheId];
  }
  _prevTime = 0;
  handlePosition(e, t) {
    if (t) {
      const i = this.root;
      mh && i.add(new vi()), nt.lastObjPosition[this.cacheId] || (nt.lastObjPosition[this.cacheId] = this.root.position.clone());
      const n = new y(), o = new y();
      this.positionWrapper = new C_(t, (r, a) => {
        const l = this.action.getEffectiveWeight();
        return mh && i.position.length() > 8 && i.position.set(0, i.position.y, 0), r > this._prevTime && (n.set(a[0], a[1], a[2]), n.sub(o), n.multiplyScalar(l), n.applyQuaternion(this.getClipRotationOffset()), n.applyQuaternion(i.quaternion), this.positionChange.copy(n)), o.fromArray(a), this._prevTime = r, a[0] = 0, a[1] = 0, a[2] = 0, a;
      });
    }
  }
  static identityQuaternion = new U();
  handleRotation(e, t) {
    if (t) {
      if (mh) {
        const r = t.values, a = new ot().setFromQuaternion(new U(r[0], r[1], r[2], r[3]));
        console.log(e.name, t.name, "FIRST ROTATION IN TRACK", j.toDegrees(a.y));
        const l = t.values.length - 4, c = new U().set(r[l], r[l + 1], r[l + 2], r[l + 3]), h = new ot().setFromQuaternion(c);
        console.log(e.name, t.name, "LAST ROTATION IN TRACK", j.toDegrees(h.y));
      }
      let i = 0;
      const n = new U(), o = new U();
      this.rotationWrapper = new C_(t, (r, a) => (r > i && (o.set(a[0], a[1], a[2], a[3]), n.invert(), o.multiply(n), this.rotationChange.copy(o)), n.fromArray(a), i = r, a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a));
    }
  }
  // private lastPos: Vector3 = new Vector3();
  onBeforeUpdate(e) {
    this.positionChange.set(0, 0, 0), this.rotationChange.set(0, 0, 0, 1);
  }
  onAfterUpdate(e) {
    return !this.action || (e *= this.action.getEffectiveWeight(), e <= 0) ? !1 : (this.positionChange.multiplyScalar(e), this.rotationChange.slerp(nt.identityQuaternion, 1 - e), !0);
  }
}
class tk {
  controller;
  handler = [];
  root;
  basePosition = new y();
  baseQuaternion = new U();
  baseRotation = new ot();
  constructor(e) {
    this.controller = e;
  }
  createClip(e, t, i) {
    this.root = t, t && "name" in t && t.name;
    const n = this.findRootTrack(i, ".position"), o = this.findRootTrack(i, ".quaternion"), r = new nt(this.controller.context, t, i, n, o);
    this.handler.push(r);
    const a = e.clipAction(i);
    return r.action = a, a;
  }
  onStart(e) {
    for (const t of this.handler)
      t.onStart(e);
  }
  onBeforeUpdate(e) {
    this.basePosition.copy(this.root.position), this.baseQuaternion.copy(this.root.quaternion);
    for (const t of this.handler)
      t.onBeforeUpdate(e);
  }
  summedPosition = new y();
  summedRotation = new U();
  onAfterUpdate(e) {
    if (!(e <= 0)) {
      this.root.position.copy(this.basePosition), this.root.quaternion.copy(this.baseQuaternion), this.summedPosition.set(0, 0, 0), this.summedRotation.set(0, 0, 0, 1);
      for (const t of this.handler)
        t.onAfterUpdate(e) && (this.summedPosition.add(t.positionChange), this.summedRotation.multiply(t.rotationChange));
      this.root.position.add(this.summedPosition), this.root.quaternion.multiply(this.summedRotation);
    }
  }
  findRootTrack(e, t) {
    const i = e.tracks;
    if (!i) return null;
    for (const n of i)
      if (n.name.endsWith(t))
        return n;
    return null;
  }
}
class ik extends Zi {
  onSerialize(e, t) {
  }
  onDeserialize(e, t) {
    if (t.type === cn && e?.__type === "AnimatorController")
      return new cn(e);
  }
}
new ik(cn);
var nk = Object.defineProperty, sk = Object.getOwnPropertyDescriptor, lu = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? sk(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && nk(e, t, n), n;
};
const Di = w("debuganimator");
class kt extends R {
  /** 
   * Identifies this component as an animation component in the engine
   */
  get isAnimationComponent() {
    return !0;
  }
  applyRootMotion = !1;
  hasRootMotion = !1;
  keepAnimatorControllerStateOnDisable = !1;
  set runtimeAnimatorController(e) {
    this._animatorController && this._animatorController.model === e || (e ? e instanceof cn ? (e.animator && e.animator !== this && (console.warn("AnimatorController can not be bound to multiple animators", e.model?.name), e.model || console.error("AnimatorController has no model"), e = new cn(e.model)), this._animatorController = e, this._animatorController.bind(this)) : (Di && console.log("Assign animator controller", e, this), this._animatorController = new cn(e), this.__didAwake && this._animatorController.bind(this)) : this._animatorController = null);
  }
  /**
   * Gets the current animator controller instance
   * @returns The current animator controller or null if none is assigned
   */
  get runtimeAnimatorController() {
    return this._animatorController;
  }
  /** 
   * Retrieves information about the current animation state
   * @returns The current state information, or undefined if no state is playing
   */
  getCurrentStateInfo() {
    return this.runtimeAnimatorController?.getCurrentStateInfo();
  }
  /** 
   * The currently playing animation action that can be used to modify animation properties
   * @returns The current animation action, or null if no animation is playing
   */
  get currentAction() {
    return this.runtimeAnimatorController?.currentAction || null;
  }
  /** 
   * Indicates whether animation parameters have been modified since the last update
   * @returns True if parameters have been changed
   */
  get parametersAreDirty() {
    return this._parametersAreDirty;
  }
  _parametersAreDirty = !1;
  /** 
   * Indicates whether the animator state has changed since the last update
   * @returns True if the animator has been changed
   */
  get isDirty() {
    return this._isDirty;
  }
  _isDirty = !1;
  /**@deprecated use play() */
  Play(e, t = -1, i = Number.NEGATIVE_INFINITY, n = 0) {
    this.play(e, t, i, n);
  }
  /** 
   * Plays an animation on the animator
   * @param name The name or hash of the animation to play
   * @param layer The layer to play the animation on (-1 for default layer)
   * @param normalizedTime The time position to start playing (0-1 range, NEGATIVE_INFINITY for current position)
   * @param transitionDurationInSec The duration of the blend transition in seconds
   */
  play(e, t = -1, i = Number.NEGATIVE_INFINITY, n = 0) {
    this.runtimeAnimatorController?.play(e, t, i, n), this._isDirty = !0;
  }
  /**@deprecated use reset */
  Reset() {
    this.reset();
  }
  /** 
   * Resets the animator controller to its initial state
   */
  reset() {
    this._animatorController?.reset(), this._isDirty = !0;
  }
  /**@deprecated use setBool */
  SetBool(e, t) {
    this.setBool(e, t);
  }
  /**
   * Sets a boolean parameter in the animator
   * @param name The name or hash of the parameter
   * @param value The boolean value to set
   */
  setBool(e, t) {
    Di && console.log("setBool", e, t), this.runtimeAnimatorController?.getBool(e) !== t && (this._parametersAreDirty = !0), this.runtimeAnimatorController?.setBool(e, t);
  }
  /**@deprecated use getBool */
  GetBool(e) {
    return this.getBool(e);
  }
  /**
   * Gets a boolean parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the boolean parameter, or false if not found
   */
  getBool(e) {
    const t = this.runtimeAnimatorController?.getBool(e) ?? !1;
    return Di && console.log("getBool", e, t), t;
  }
  /**
   * Toggles a boolean parameter between true and false
   * @param name The name or hash of the parameter
   */
  toggleBool(e) {
    this.setBool(e, !this.getBool(e));
  }
  /**@deprecated use setFloat */
  SetFloat(e, t) {
    this.setFloat(e, t);
  }
  /**
   * Sets a float parameter in the animator
   * @param name The name or hash of the parameter
   * @param val The float value to set
   */
  setFloat(e, t) {
    this.runtimeAnimatorController?.getFloat(e) !== t && (this._parametersAreDirty = !0), Di && console.log("setFloat", e, t), this.runtimeAnimatorController?.setFloat(e, t);
  }
  /**@deprecated use getFloat */
  GetFloat(e) {
    return this.getFloat(e);
  }
  /**
   * Gets a float parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the float parameter, or -1 if not found
   */
  getFloat(e) {
    const t = this.runtimeAnimatorController?.getFloat(e) ?? -1;
    return Di && console.log("getFloat", e, t), t;
  }
  /**@deprecated use setInteger */
  SetInteger(e, t) {
    this.setInteger(e, t);
  }
  /**
   * Sets an integer parameter in the animator
   * @param name The name or hash of the parameter
   * @param val The integer value to set
   */
  setInteger(e, t) {
    this.runtimeAnimatorController?.getInteger(e) !== t && (this._parametersAreDirty = !0), Di && console.log("setInteger", e, t), this.runtimeAnimatorController?.setInteger(e, t);
  }
  /**@deprecated use getInteger */
  GetInteger(e) {
    return this.getInteger(e);
  }
  /**
   * Gets an integer parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the integer parameter, or -1 if not found
   */
  getInteger(e) {
    const t = this.runtimeAnimatorController?.getInteger(e) ?? -1;
    return Di && console.log("getInteger", e, t), t;
  }
  /**@deprecated use setTrigger */
  SetTrigger(e) {
    this.setTrigger(e);
  }
  /**
   * Activates a trigger parameter in the animator
   * @param name The name or hash of the trigger parameter
   */
  setTrigger(e) {
    this._parametersAreDirty = !0, Di && console.log("setTrigger", e), this.runtimeAnimatorController?.setTrigger(e);
  }
  /**@deprecated use resetTrigger */
  ResetTrigger(e) {
    this.resetTrigger(e);
  }
  /**
   * Resets a trigger parameter in the animator
   * @param name The name or hash of the trigger parameter
   */
  resetTrigger(e) {
    this._parametersAreDirty = !0, Di && console.log("resetTrigger", e), this.runtimeAnimatorController?.resetTrigger(e);
  }
  /**@deprecated use getTrigger */
  GetTrigger(e) {
    this.getTrigger(e);
  }
  /**
   * Gets the state of a trigger parameter from the animator
   * @param name The name or hash of the trigger parameter
   * @returns The state of the trigger parameter
   */
  getTrigger(e) {
    const t = this.runtimeAnimatorController?.getTrigger(e);
    return Di && console.log("getTrigger", e, t), t;
  }
  /**@deprecated use isInTransition */
  IsInTransition() {
    return this.isInTransition();
  }
  /** 
   * Checks if the animator is currently in a transition between states
   * @returns True if the animator is currently blending between animations
   */
  isInTransition() {
    return this.runtimeAnimatorController?.isInTransition() ?? !1;
  }
  /**@deprecated use setSpeed */
  SetSpeed(e) {
    return this.setSpeed(e);
  }
  /**
   * Sets the playback speed of the animator
   * @param speed The new playback speed multiplier
   */
  setSpeed(e) {
    e !== this._speed && (Di && console.log("setSpeed", e), this._speed = e, this._animatorController?.animator == this && this._animatorController.setSpeed(e));
  }
  /** 
   * Sets a random playback speed between the min and max values
   * @param minMax Object with x (minimum) and y (maximum) speed values
   */
  set minMaxSpeed(e) {
    this._speed = j.lerp(e.x, e.y, Math.random()), this._animatorController?.animator == this && this._animatorController.setSpeed(this._speed);
  }
  /**
   * Sets a random normalized time offset for animations between min (x) and max (y) values
   * @param minMax Object with x (min) and y (max) values for the offset range
   */
  set minMaxOffsetNormalized(e) {
    this._normalizedStartOffset = j.lerp(e.x, e.y, Math.random()), this.runtimeAnimatorController?.animator == this && (this.runtimeAnimatorController.normalizedStartOffset = this._normalizedStartOffset);
  }
  _speed = 1;
  _normalizedStartOffset = 0;
  _animatorController = null;
  awake() {
    Di && console.log("ANIMATOR", this.name, this), this.gameObject && this.initializeRuntimeAnimatorController();
  }
  // Why do we jump through hoops like this? It's because of the PlayableDirector and animation tracks
  // they NEED to use the same mixer when binding/creating the animation clips
  // so when the playable director runs it takes over updating the mixer for blending and then calls the runtimeAnimatorController.update
  // so they effectively share the same mixer. There might be cases still where not the same mixer is being used but then the animation track prints an error in dev
  _initializeWithRuntimeAnimatorController;
  initializeRuntimeAnimatorController(e = !1) {
    const t = e || this.runtimeAnimatorController !== this._initializeWithRuntimeAnimatorController;
    if (this.runtimeAnimatorController && t) {
      const i = this.runtimeAnimatorController.clone();
      this._initializeWithRuntimeAnimatorController = i, i ? (console.assert(this.runtimeAnimatorController !== i), this.runtimeAnimatorController = i, console.assert(this.runtimeAnimatorController === i), this.runtimeAnimatorController.bind(this), this.runtimeAnimatorController.setSpeed(this._speed), this.runtimeAnimatorController.normalizedStartOffset = this._normalizedStartOffset) : console.warn("Could not clone animator controller", this.runtimeAnimatorController);
    }
  }
  onDisable() {
    this.keepAnimatorControllerStateOnDisable || this._animatorController?.reset();
  }
  onBeforeRender() {
    this._isDirty = !1, this._parametersAreDirty = !1, !JO(this.gameObject) && this._animatorController && this._animatorController.update(1);
  }
}
lu([
  u()
], kt.prototype, "applyRootMotion", 2);
lu([
  u()
], kt.prototype, "hasRootMotion", 2);
lu([
  u()
], kt.prototype, "keepAnimatorControllerStateOnDisable", 2);
lu([
  u()
], kt.prototype, "runtimeAnimatorController", 1);
const P_ = Symbol("previous-visibility");
class ps extends Dn {
  /**
   * Render the scene to the texture
   * @param scene The scene to render
   * @param camera The camera to render from
   * @param renderer The renderer or effectcomposer to use
   */
  render(e, t, i) {
    if ("addPass" in i)
      this._unsupported_effectcomposer_warning || (console.warn("RenderTexture.render() does not yet support EffectComposer"), this._unsupported_effectcomposer_warning = !0);
    else if (i instanceof mr) {
      this.onBeforeRender();
      const o = i.getRenderTarget(), r = i.xr.enabled;
      i.xr.enabled = !1, i.setRenderTarget(this), i.clear(!0, !0, !0), i.render(e, t), i.setRenderTarget(o), i.xr.enabled = r, this.onAfterRender();
    }
  }
  static _userSet = /* @__PURE__ */ new Set();
  onBeforeRender() {
    ps._userSet.clear();
    const e = P0(this.texture, !0, null, ps._userSet);
    for (const t of e)
      t instanceof G && (t[P_] = t.visible, t.visible = !1);
  }
  onAfterRender() {
    for (const e of ps._userSet)
      e instanceof G && (e.visible = e[P_]);
    ps._userSet.clear();
  }
}
var ok = Object.defineProperty, rk = Object.getOwnPropertyDescriptor, kc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? rk(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && ok(e, t, n), n;
};
const gh = w("debuggroundprojection");
class Rs extends R {
  applyOnAwake = !1;
  autoFit = !0;
  set radius(e) {
    this._radius = e, this._projection && this.updateProjection();
  }
  get radius() {
    return this._radius;
  }
  _radius = 50;
  set height(e) {
    this._height = e, this._projection && this.updateProjection();
  }
  get height() {
    return this._height;
  }
  _height = 3;
  set arBlending(e) {
    this._arblending = e, this._needsTextureUpdate = !0;
  }
  get arBlending() {
    return this._arblending;
  }
  _arblending = 0;
  _lastBackground;
  _lastRadius;
  _lastHeight;
  _projection;
  _watcher;
  /** @internal */
  awake() {
    this.applyOnAwake && this.updateAndCreate();
  }
  /** @internal */
  onEnable() {
    this.context.time.frameCount > 0 && this.applyOnAwake && this.updateAndCreate(), this._watcher || (this._watcher = new ao(this.context.scene, "background"), this._watcher.subscribeWrite((e) => {
      gh && console.log("Background changed", this.context.scene.background), this._needsTextureUpdate = !0;
    }));
  }
  /** @internal */
  onDisable() {
    this._watcher?.revoke(), this._projection?.removeFromParent();
  }
  /** @internal */
  onEnterXR() {
    this.activeAndEnabled && (this._needsTextureUpdate = !0, this.updateProjection());
  }
  /** @internal */
  async onLeaveXR() {
    this.activeAndEnabled && (await Qd(1), this.updateProjection());
  }
  /** @internal */
  onBeforeRender() {
    this._projection && this.scene.backgroundRotation && this._projection.rotation.copy(this.scene.backgroundRotation), this.context.scene.backgroundBlurriness !== void 0 && this._lastBlurriness != this.context.scene.backgroundBlurriness && this.context.scene.backgroundBlurriness > 1e-3 ? this.updateProjection() : this._needsTextureUpdate && this.context.scene.background instanceof Te && this.updateBlurriness(this.context.scene.background, this.context.scene.backgroundBlurriness);
  }
  updateAndCreate() {
    this.updateProjection(), this._watcher?.apply();
  }
  _needsTextureUpdate = !1;
  /**
   * Updates the ground projection. This is called automatically when the environment or settings change.
   */
  updateProjection() {
    if (!this.context.scene.background) {
      this._projection?.removeFromParent();
      return;
    }
    const e = this.context.scene.background;
    if (!(e instanceof Te)) {
      this._projection?.removeFromParent();
      return;
    }
    if ((this.context.xr?.isPassThrough || this.context.xr?.isAR) && this.arBlending === 0) {
      this._projection?.removeFromParent();
      return;
    }
    if (!this.gameObject || this.destroyed)
      return;
    let t = !0;
    const i = 0, n = e !== this._lastBackground || this._height !== this._lastHeight || this._radius !== this._lastRadius;
    if (!this._projection || n) {
      gh && console.log("Create/Update Ground Projection", e.name), this._projection?.removeFromParent();
      try {
        this._projection = new _a(e, this._height, this._radius, 64);
      } catch (o) {
        console.error("Error creating three GroundProjection", o);
        return;
      }
      this._projection.position.y = this._height - i, this._projection.name = "GroundProjection", n0(this._projection, !1);
    } else
      t = !1;
    if (this._projection.parent || this.gameObject.add(this._projection), this.autoFit && t) {
      this._projection.updateWorldMatrix(!0, !0);
      const o = ii(this.context.scene.children, [this._projection]), r = o.min.y;
      if (r < 1 / 0) {
        const a = H();
        a.x = o.min.x + (o.max.x - o.min.x) * 0.5;
        const l = Qe(this.gameObject).x;
        a.y = r + this._height * l - i, a.z = o.min.z + (o.max.z - o.min.z) * 0.5, Ot(this._projection, a);
      }
      gh && z.DrawWireBox3(o, 65280, 5);
    }
    this.context.scene.backgroundBlurriness > 1e-3 && this._needsTextureUpdate && this.updateBlurriness(e, this.context.scene.backgroundBlurriness), this._lastBackground = e, this._lastHeight = this._height, this._lastRadius = this._radius, this._needsTextureUpdate = !1;
  }
  _blurrynessShader = null;
  _lastBlurriness = -1;
  updateBlurriness(e, t) {
    if (this._projection) {
      if (!e)
        return;
    } else return;
    this._needsTextureUpdate = !1, gh && console.log("Update Blurriness", t), this._blurrynessShader ??= new Ln({
      name: "GroundProjectionBlurriness",
      uniforms: {
        map: { value: e },
        blurriness: { value: t },
        blending: { value: 0 },
        alphaFactor: { value: 1 }
      },
      vertexShader: ak,
      fragmentShader: lk
    }), this._blurrynessShader.depthWrite = !1, this._blurrynessShader.uniforms.map.value = e, this._blurrynessShader.uniforms.blurriness.value = t, this._lastBlurriness = t, e.needsUpdate = !0;
    const i = this._projection.material.transparent;
    this._projection.material.transparent = (this.context.xr?.isAR === !0 && this.arBlending > 1e-6) ?? !1, this._projection.material.transparent ? this._blurrynessShader.uniforms.blending.value = this.arBlending : this._blurrynessShader.uniforms.blending.value = 0, this.context.isInPassThrough ? this._blurrynessShader.uniforms.alphaFactor.value = 0.95 : this._blurrynessShader.uniforms.alphaFactor.value = 1, i !== this._projection.material.transparent && (this._projection.material.needsUpdate = !0), this._projection.material.map = ar.copyTexture(e, this._blurrynessShader), this._projection.material.depthTest = !0, this._projection.material.depthWrite = !1;
  }
}
kc([
  u()
], Rs.prototype, "applyOnAwake", 2);
kc([
  u()
], Rs.prototype, "autoFit", 2);
kc([
  u()
], Rs.prototype, "radius", 1);
kc([
  u()
], Rs.prototype, "height", 1);
kc([
  u()
], Rs.prototype, "arBlending", 1);
const ak = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`, lk = `
  uniform sampler2D map;
  uniform float blurriness;
  uniform float alphaFactor;
  uniform float blending;
  varying vec2 vUv;

  const float PI = 3.14159265359;

  // Gaussian function
  float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * PI) * sigma);
  }

  // Custom smoothstep function for desired falloff
  float customSmoothstep(float edge0, float edge1, float x) {
    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
  }

  void main() {
    vec2 center = vec2(0.0, 0.0);
    vec2 pos = vUv;
    pos.x = 0.0; // Only consider vertical distance
    float distance = length(pos - center);
    
    // Calculate blur amount based on custom falloff
    float blurAmount = customSmoothstep(0.5, 1.0, distance * 2.0);
    blurAmount = clamp(blurAmount, 0.0, 1.0); // Ensure blur amount is within valid range

    // Gaussian blur
    vec2 pixelSize = 1.0 / vec2(textureSize(map, 0));
    vec4 color = vec4(0.0);
    float totalWeight = 0.0;
    int blurSize = int(60.0 * min(1.0, blurriness) * blurAmount); // Adjust blur size based on distance and blurriness
    float lodLevel = log2(float(blurSize)) * 0.5; // Compute LOD level

    for (int x = -blurSize; x <= blurSize; x++) {
        for (int y = -blurSize; y <= blurSize; y++) {
            vec2 offset = vec2(float(x), float(y)) * pixelSize * blurAmount;
            float weight = gaussian(length(vec2(float(x), float(y))), 1000.0 * blurAmount); // Use a fixed sigma value
            color += textureLod(map, vUv + offset, lodLevel) * weight;
            totalWeight += weight;
        }
    }

    color = totalWeight > 0.0 ? color / totalWeight : texture2D(map, vUv);

    gl_FragColor = color;

    float brightness = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));
    float stepFactor = blending - brightness * .1;
    gl_FragColor.a = pow(1.0 - blending * customSmoothstep(0.35 * stepFactor, 0.45 * stepFactor, distance), 5.);
    gl_FragColor.a *= alphaFactor;
    // gl_FragColor.rgb = vec3(1.0);

    // #include <tonemapping_fragment>
    // #include <colorspace_fragment>
    
    // Uncomment to visualize blur amount
    // gl_FragColor = vec4(blurAmount, 0.0, 0.0, 1.0);
  }
`;
var ck = Object.defineProperty, ng = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && ck(e, t, n), n;
};
class ja extends R {
  constraintActive = !0;
  locked = !1;
  sources = [];
  /**
   * Set the position of the constraint.
   */
  setConstraintPosition(e) {
    const t = this.sources[0];
    t && (t.worldPosition = e);
  }
}
ng([
  u()
], ja.prototype, "constraintActive");
ng([
  u()
], ja.prototype, "locked");
ng([
  u(M)
], ja.prototype, "sources");
let ir = class {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  x() {
    return this.bb.readFloat32(this.bb_pos);
  }
  y() {
    return this.bb.readFloat32(this.bb_pos + 4);
  }
  z() {
    return this.bb.readFloat32(this.bb_pos + 8);
  }
  static sizeOf() {
    return 12;
  }
  static createVec3(e, t, i, n) {
    return e.prep(4, 12), e.writeFloat32(n), e.writeFloat32(i), e.writeFloat32(t), e.offset();
  }
};
class sv {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  position(e) {
    return (e || new ir()).__init(this.bb_pos, this.bb);
  }
  rotation(e) {
    return (e || new ir()).__init(this.bb_pos + 12, this.bb);
  }
  scale(e) {
    return (e || new ir()).__init(this.bb_pos + 24, this.bb);
  }
  static sizeOf() {
    return 36;
  }
  static createTransform(e, t, i, n, o, r, a, l, c, h) {
    return e.prep(4, 36), e.prep(4, 12), e.writeFloat32(h), e.writeFloat32(c), e.writeFloat32(l), e.prep(4, 12), e.writeFloat32(a), e.writeFloat32(r), e.writeFloat32(o), e.prep(4, 12), e.writeFloat32(n), e.writeFloat32(i), e.writeFloat32(t), e.offset();
  }
}
class us {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsSyncedTransformModel(e, t) {
    return (t || new us()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsSyncedTransformModel(e, t) {
    return e.setPosition(e.position() + Nb), (t || new us()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  guid(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  /**
   * if the transform interpolation should be fast, this is true when the send interval is low and we want to have snappy transforms
   */
  fast() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  transform(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? (e || new sv()).__init(this.bb_pos + t, this.bb) : null;
  }
  /**
   * if the server should not save this info
   */
  dontSave() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  static startSyncedTransformModel(e) {
    e.startObject(4);
  }
  static addGuid(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addFast(e, t) {
    e.addFieldInt8(1, +t, 0);
  }
  static addTransform(e, t) {
    e.addFieldStruct(2, t, 0);
  }
  static addDontSave(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static endSyncedTransformModel(e) {
    return e.endObject();
  }
  static finishSyncedTransformModelBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedSyncedTransformModelBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
var T;
((s) => {
  ((e) => {
    e.MAYBEMODULE = null;
    const t = [];
    function i() {
      return e.MODULE ? Promise.resolve(e.MODULE) : new Promise((o) => {
        t.push(o);
      });
    }
    e.ready = i;
    async function n() {
      if (e.MODULE) return e.MODULE;
      const o = await import("./rapier-BJaux8TQ.js");
      return e.MODULE = o, e.MAYBEMODULE = o, t.forEach((r) => r(o)), t.length = 0, o;
    }
    e.load = n;
  })(s.RAPIER_PHYSICS || (s.RAPIER_PHYSICS = {})), ((e) => {
    e.MAYBEMODULE = null;
    const t = [];
    function i() {
      return e.MODULE ? Promise.resolve(e.MODULE) : new Promise((o) => {
        t.push(o);
      });
    }
    e.ready = i;
    async function n() {
      if (e.MODULE) return e.MODULE;
      const o = await import("./postprocessing-BzFF7i-7.js").then((r) => r.index);
      return e.MODULE = o, e.MAYBEMODULE = o, t.forEach((r) => r(o)), t.length = 0, o;
    }
    e.load = n;
  })(s.POSTPROCESSING || (s.POSTPROCESSING = {})), ((e) => {
    e.MAYBEMODULE = null;
    const t = [];
    function i() {
      return e.MODULE ? Promise.resolve(e.MODULE) : new Promise((o) => {
        t.push(o);
      });
    }
    e.ready = i;
    async function n() {
      if (e.MODULE) return e.MODULE;
      const o = await import("./postprocessing-BzFF7i-7.js").then((r) => r.N8AO);
      return e.MODULE = o, e.MAYBEMODULE = o, t.forEach((r) => r(o)), t.length = 0, o;
    }
    e.load = n;
  })(s.POSTPROCESSING_AO || (s.POSTPROCESSING_AO = {}));
})(T || (T = {}));
var xt = /* @__PURE__ */ ((s) => (s[s.Average = 0] = "Average", s[s.Multiply = 1] = "Multiply", s[s.Minimum = 2] = "Minimum", s[s.Maximum = 3] = "Maximum", s))(xt || {}), sg = /* @__PURE__ */ ((s) => (s[s.Discrete = 0] = "Discrete", s[s.Continuous = 1] = "Continuous", s))(sg || {}), Ge = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.FreezePositionX = 2] = "FreezePositionX", s[s.FreezePositionY = 4] = "FreezePositionY", s[s.FreezePositionZ = 8] = "FreezePositionZ", s[s.FreezePosition = 14] = "FreezePosition", s[s.FreezeRotationX = 16] = "FreezeRotationX", s[s.FreezeRotationY = 32] = "FreezeRotationY", s[s.FreezeRotationZ = 64] = "FreezeRotationZ", s[s.FreezeRotation = 112] = "FreezeRotation", s[s.FreezeAll = 126] = "FreezeAll", s))(Ge || {}), Al = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.X = 2] = "X", s[s.Y = 4] = "Y", s[s.Z = 8] = "Z", s[s.All = -1] = "All", s))(Al || {});
const Lt = function(s, e) {
  return function(t, i, n) {
    hk(t, i, n, s, e);
  };
};
function hk(s, e, t, i, n) {
  if (!n && !i && !s.onValidate) return;
  if (t !== void 0) {
    console.error("Invalid usage of validate decorator. Only fields can be validated.", s, e, t), Be("Invalid usage of validate decorator. Only fields can be validated. Property: " + e, Wi.Error);
    return;
  }
  let o = "";
  if (typeof e == "string" ? o = e : o = e.name, s.__internalAwake) {
    const r = Symbol(o), a = s.__internalAwake;
    s.__internalAwake = function() {
      if (!this.onValidate) {
        L() && console.warn('Usage of @validate decorate detected but there is no onValidate method in your class: "' + s.constructor?.name + '"');
        return;
      }
      if (this[r] === void 0) {
        this[r] = this[o];
        const l = this[o];
        if (l instanceof J || l instanceof y || l instanceof fe || l instanceof U) {
          const c = this[o];
          Am(c, () => {
            this.onValidate(o);
          });
        }
        Object.defineProperty(this, o, {
          set: function(c) {
            if (this[Dp] === !0)
              this[r] = c;
            else {
              i?.call(this, c);
              const h = this[r];
              this[r] = c, this.onValidate?.call(this, o, h);
            }
          },
          get: function() {
            return n?.call(this), this[r];
          }
        });
      }
      a.call(this);
    };
  }
}
const kL = function(s) {
  return function(e, t, i) {
    let n = "";
    typeof t == "string" ? n = t : n = t.name;
    const o = s.prototype, r = Object.getOwnPropertyDescriptor(o, n);
    if (!r?.value) {
      console.warn("Can not apply prefix: type does not have method named", t, s);
      return;
    }
    const a = r.value, l = e[n];
    Object.defineProperty(o, n, {
      value: function(...c) {
        const h = l?.call(this, ...c);
        if (h instanceof Promise) {
          h.then((d) => {
            if (d !== !1)
              return a.call(this, ...c);
          });
          return;
        }
        if (h !== !1)
          return a.call(this, ...c);
      }
    });
  };
};
var dk = Object.defineProperty, uk = Object.getOwnPropertyDescriptor, Si = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? uk(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && dk(e, t, n), n;
};
class fk {
  get isDirty() {
    return this.positionChanged || this.rotationChanged;
  }
  positionChanged = !1;
  rotationChanged = !1;
  position;
  quaternion;
  _positionKeys = ["x", "y", "z"];
  _quaternionKeys = ["_x", "_y", "_z", "_w"];
  reset(e = !1) {
    if (this.positionChanged = !1, this.rotationChanged = !1, this.mute = !1, e) {
      if (this.position)
        for (const t of this._positionKeys)
          delete this.position[t];
      if (this.quaternion)
        for (const t of this._quaternionKeys)
          delete this.quaternion[t];
    }
  }
  syncValues() {
    for (const e of this._positionKeys)
      this.position[e] = this.obj.position[e];
    for (const e of this._quaternionKeys)
      this.quaternion[e] = this.obj.quaternion[e];
  }
  mute = !1;
  applyValues() {
    if (this.positionChanged && this.position)
      for (const e of this._positionKeys) {
        const t = this.position[e];
        t !== void 0 && (this.obj.position[e] = t);
      }
    if (this.rotationChanged && this.quaternion)
      for (const e of this._quaternionKeys) {
        const t = this.quaternion[e];
        t !== void 0 && (this.obj.quaternion[e] = t);
      }
  }
  context;
  obj;
  _positionWatch;
  _rotationWatch;
  constructor(e, t) {
    this.context = t, this.obj = e;
  }
  start(e, t) {
    this.reset(), e && (this._positionWatch || (this._positionWatch = new ao(this.obj.position, ["x", "y", "z"])), this._positionWatch.apply(), this.position = {}, this._positionWatch.subscribeWrite((o, r) => {
      if (this.context.physics.engine?.isUpdating || this.mute) return;
      const a = this.position[r];
      Math.abs(a - o) < 1e-5 || (this.position[r] = o, this.positionChanged = !0);
    })), t && (this._rotationWatch || (this._rotationWatch = new ao(this.obj.quaternion, ["_x", "_y", "_z", "_w"])), this._rotationWatch.apply(), this.quaternion = {}, this._rotationWatch.subscribeWrite((o, r) => {
      if (this.context.physics.engine?.isUpdating || this.mute) return;
      const a = this.quaternion[r];
      Math.abs(a - o) < 1e-5 || (this.quaternion[r] = o, this.rotationChanged = !0);
    }));
    const i = this.obj.matrixWorld.multiplyMatrices.bind(this.obj.matrixWorld), n = new ee();
    this.obj.matrixWorld.multiplyMatrices = (o, r) => (this.context.physics.engine?.isUpdating || this.mute || n.equals(o) || (this.positionChanged = !0, this.rotationChanged = !0, n.copy(o)), i(o, r));
  }
  stop() {
    this._positionWatch?.revoke(), this._rotationWatch?.revoke();
  }
}
const si = class qh extends R {
  get isRigidbody() {
    return !0;
  }
  autoMass = !0;
  set mass(e) {
    e !== this._mass && (this._mass = e, this._propertiesChanged = !0, this.__didAwake && (this.autoMass = !1));
  }
  get mass() {
    return this.autoMass ? this.context.physics.engine?.getBody(this)?.mass() ?? -1 : this._mass;
  }
  _mass = 0;
  useGravity = !0;
  centerOfMass = new y(0, 0, 0);
  constraints = Ge.None;
  isKinematic = !1;
  drag = 0;
  angularDrag = 1;
  detectCollisions = !0;
  sleepThreshold = 0.01;
  collisionDetectionMode = sg.Discrete;
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionX() {
    return (this.constraints & Ge.FreezePositionX) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionY() {
    return (this.constraints & Ge.FreezePositionY) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionZ() {
    return (this.constraints & Ge.FreezePositionZ) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationX() {
    return (this.constraints & Ge.FreezeRotationX) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationY() {
    return (this.constraints & Ge.FreezeRotationY) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationZ() {
    return (this.constraints & Ge.FreezeRotationZ) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionX(e) {
    e ? this.constraints |= Ge.FreezePositionX : this.constraints &= ~Ge.FreezePositionX;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionY(e) {
    e ? this.constraints |= Ge.FreezePositionY : this.constraints &= ~Ge.FreezePositionY;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionZ(e) {
    e ? this.constraints |= Ge.FreezePositionZ : this.constraints &= ~Ge.FreezePositionZ;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationX(e) {
    e ? this.constraints |= Ge.FreezeRotationX : this.constraints &= ~Ge.FreezeRotationX;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationY(e) {
    e ? this.constraints |= Ge.FreezeRotationY : this.constraints &= ~Ge.FreezeRotationY;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationZ(e) {
    e ? this.constraints |= Ge.FreezeRotationZ : this.constraints &= ~Ge.FreezeRotationZ;
  }
  /** Gravity is such a common force that it is implemented as a special case (even if it could easily be implemented by the user using force application). Note however that a change of gravity won't automatically wake-up the sleeping bodies so keep in mind that you may want to wake them up manually before a gravity change.   
   * 
   * It is possible to change the way gravity affects a specific rigid-body by setting the rigid-body's gravity scale to a value other than 1.0. The magnitude of the gravity applied to this body will be multiplied by this scaling factor. Therefore, a gravity scale set to 0.0 will disable gravity for the rigid-body whereas a gravity scale set to 2.0 will make it twice as strong. A negative value will flip the direction of the gravity for this rigid-body.
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#gravity
   */
  set gravityScale(e) {
    this._gravityScale = e;
  }
  get gravityScale() {
    return this._gravityScale;
  }
  _gravityScale = 1;
  dominanceGroup = 0;
  static tempPosition = new y();
  _propertiesChanged = !1;
  _currentVelocity = new y();
  _smoothedVelocity = new y();
  _smoothedVelocityGetter = new y();
  _lastPosition = new y();
  _watch;
  awake() {
    this._watch = void 0, this._propertiesChanged = !1;
  }
  onEnable() {
    this._watch || (this._watch = new fk(this.gameObject, this.context)), this._watch.start(!0, !0), this.startCoroutine(this.beforePhysics(), xe.LateUpdate), L() && (globalThis.NEEDLE_USE_RAPIER ? T.RAPIER_PHYSICS.ready().then(async () => {
      await Qd(3), this.context.physics.engine?.getBody(this) || console.warn(`Rigidbody could not be created. Ensure "${this.name}" has a Collider component.`);
    }) : console.warn("Rigidbody could not be created: Rapier physics are explicitly disabled."));
  }
  onDisable() {
    this._watch?.stop(), this.context.physics.engine?.removeBody(this);
  }
  onDestroy() {
    this.context.physics.engine?.removeBody(this);
  }
  onValidate() {
    this._propertiesChanged = !0;
  }
  // need to do this right before updating physics to prevent rendered object glitching through physical bodies
  *beforePhysics() {
    for (; ; )
      this._propertiesChanged && (this._propertiesChanged = !1, this.context.physics.engine?.updateProperties(this)), this._watch?.isDirty ? (this._watch.mute = !0, this._watch.applyValues(), this.context.physics.engine?.updateBody(this, this._watch.positionChanged, this._watch.rotationChanged), this._watch.reset()) : this._watch?.syncValues(), this.captureVelocity(), yield;
  }
  /** Teleport the rigidbody to a new position in the world.   
   * Will reset forces before setting the object world position 
   * @param pt The new position to teleport the object to (world space)
   * @param localspace When true the object will be teleported in local space, otherwise in world space
   * */
  teleport(e, t = !0) {
    this._watch?.reset(!0), t ? this.gameObject.position.set(e.x, e.y, e.z) : this.setWorldPosition(e.x, e.y, e.z), this.resetForcesAndTorques(), this.resetVelocities();
  }
  resetForces(e = !0) {
    this.context.physics.engine?.resetForces(this, e);
  }
  resetTorques(e = !0) {
    this.context.physics.engine?.resetTorques(this, e);
  }
  resetVelocities() {
    this.setVelocity(0, 0, 0), this.setAngularVelocity(0, 0, 0);
  }
  resetForcesAndTorques() {
    this.resetForces(), this.resetTorques();
  }
  /** When a dynamic rigid-body doesn't move (or moves very slowly) during a few seconds, it will be marked as sleeping by the physics pipeline. Rigid-bodies marked as sleeping are no longer simulated by the physics engine until they are woken up. That way the physics engine doesn't waste any computational resources simulating objects that don't actually move. They are woken up automatically whenever another non-sleeping rigid-body starts interacting with them (either with a joint, or with one of its attached colliders generating contacts).  
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#sleeping */
  wakeUp() {
    this.context.physics.engine?.wakeup(this);
  }
  get isSleeping() {
    return this.context.physics.engine?.isSleeping(this);
  }
  /** Call to force an update of the rigidbody properties in the physics engine */
  updateProperties() {
    return this._propertiesChanged = !1, this.context.physics.engine?.updateProperties(this);
  }
  /** Forces affect the rigid-body's acceleration whereas impulses affect the rigid-body's velocity 
   * the acceleration change is equal to the force divided by the mass:
   * @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  applyForce(e, t, i = !0) {
    this._propertiesChanged && this.updateProperties(), this.context.physics.engine?.addForce(this, e, i);
  }
  /** Forces affect the rigid-body's acceleration whereas impulses affect the rigid-body's velocity 
   * the velocity change is equal to the impulse divided by the mass  
   * @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  applyImpulse(e, t = !0) {
    this._propertiesChanged && this.updateProperties(), this.context.physics.engine?.applyImpulse(this, e, t);
  }
  /** @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  setForce(e, t, i, n = !0) {
    this.context.physics.engine?.resetForces(this, n), typeof e == "number" ? (t ??= 0, i ??= 0, this.context.physics.engine?.addForce(this, { x: e, y: t, z: i }, n)) : this.context.physics.engine?.addForce(this, e, n);
  }
  /** The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the center-of-mass of the rigid-body. This method returns the current linear velocity of the rigid-body. 
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#velocity */
  getVelocity() {
    const e = this.context.physics.engine?.getLinearVelocity(this);
    return e ? (this._currentVelocity.x = e.x, this._currentVelocity.y = e.y, this._currentVelocity.z = e.z, this._currentVelocity) : this._currentVelocity.set(0, 0, 0);
  }
  setVelocity(e, t, i, n = !0) {
    if (e instanceof y) {
      const o = e;
      this.context.physics.engine?.setLinearVelocity(this, o, n);
      return;
    }
    t === void 0 || i === void 0 || this.context.physics.engine?.setLinearVelocity(this, { x: e, y: t, z: i }, n);
  }
  /** The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the center-of-mass of the rigid-body. This method returns the current angular velocity of the rigid-body. 
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#velocity */
  getAngularVelocity() {
    const e = this.context.physics.engine?.getAngularVelocity(this);
    return e ? (this._currentVelocity.x = e.x, this._currentVelocity.y = e.y, this._currentVelocity.z = e.z, this._currentVelocity) : this._currentVelocity.set(0, 0, 0);
  }
  setAngularVelocity(e, t, i, n = !0) {
    if (typeof e == "object") {
      const o = e;
      this.context.physics.engine?.setAngularVelocity(this, o, n);
      return;
    }
    if (t === void 0 || i === void 0 || typeof t == "boolean") {
      console.warn("setAngularVelocity expects either a Vec3 or 3 numbers");
      return;
    }
    this.context.physics.engine?.setAngularVelocity(this, { x: e, y: t, z: i }, n);
  }
  setTorque(e, t, i) {
    typeof e == "number" ? this.setAngularVelocity(e, t, i) : this.setAngularVelocity(e);
  }
  /** 
   * Returns the rigidbody velocity smoothed over ~ 10 frames
   */
  get smoothedVelocity() {
    return this._smoothedVelocityGetter.copy(this._smoothedVelocity), this._smoothedVelocityGetter.multiplyScalar(1 / this.context.time.deltaTime);
  }
  /**d
   * @deprecated not used anymore and will be removed in a future update
   */
  setBodyFromGameObject(e = null) {
  }
  captureVelocity() {
    const e = this.gameObject.matrixWorld;
    qh.tempPosition.setFromMatrixPosition(e);
    const t = qh.tempPosition.sub(this._lastPosition);
    this._lastPosition.copy(qh.tempPosition), this._smoothedVelocity.lerp(t, this.context.time.deltaTime / 0.1);
  }
};
Si([
  Lt()
], si.prototype, "autoMass", 2);
Si([
  u()
], si.prototype, "mass", 1);
Si([
  Lt(),
  u()
], si.prototype, "useGravity", 2);
Si([
  u(y)
], si.prototype, "centerOfMass", 2);
Si([
  Lt(),
  u()
], si.prototype, "constraints", 2);
Si([
  Lt(),
  u()
], si.prototype, "isKinematic", 2);
Si([
  Lt(),
  u()
], si.prototype, "drag", 2);
Si([
  Lt(),
  u()
], si.prototype, "angularDrag", 2);
Si([
  Lt(),
  u()
], si.prototype, "detectCollisions", 2);
Si([
  Lt(),
  u()
], si.prototype, "sleepThreshold", 2);
Si([
  Lt(),
  u()
], si.prototype, "collisionDetectionMode", 2);
Si([
  Lt()
], si.prototype, "_gravityScale", 2);
Si([
  Lt()
], si.prototype, "dominanceGroup", 2);
let rt = si;
new y();
new y();
const Gs = w("debugsync"), yc = "STRS";
_0(yc, us.getRootAsSyncedTransformModel);
const _n = new Em();
function ov(s, e, t = !0) {
  _n.clear();
  const i = _n.createString(s);
  us.startSyncedTransformModel(_n), us.addGuid(_n, i), us.addFast(_n, t);
  const n = e.worldPosition, o = e.worldEuler, r = e.gameObject.scale;
  us.addTransform(_n, sv.createTransform(_n, n.x, n.y, n.z, o.x, o.y, o.z, r.x, r.y, r.z));
  const a = us.endSyncedTransformModel(_n);
  return _n.finish(a, yc), _n.asUint8Array();
}
let Vp = 0, Zl = 0;
VO((s) => {
  const t = s.connection.currentServerUrl?.includes("glitch") ? 10 : 40;
  Zl = Math.floor(Vp / t), Vp = 0, Gs && Zl > 0 && console.log("Sync Transform Fast Interval", Zl);
});
class zn extends R {
  // public autoOwnership: boolean = true;
  /** When true, overrides physics behavior when this object is owned by the local user */
  overridePhysics = !0;
  /** Whether to smoothly interpolate position changes when receiving updates */
  interpolatePosition = !0;
  /** Whether to smoothly interpolate rotation changes when receiving updates */
  interpolateRotation = !0;
  /** When true, sends updates at a higher frequency, useful for fast-moving objects */
  fastMode = !1;
  /** When true, notifies other clients when this object is destroyed */
  syncDestroy = !1;
  // private _state!: SyncedTransformModel;
  _model = null;
  _needsUpdate = !0;
  rb = null;
  _wasKinematic = !1;
  _receivedDataBefore = !1;
  _targetPosition;
  _targetRotation;
  _receivedFastUpdate = !1;
  _shouldRequestOwnership = !1;
  /** 
   * Requests ownership of this object on the network.
   * You need to be connected to a room for this to work.
   */
  requestOwnership() {
    Gs && console.log("Request ownership"), this._model ? this._model.requestOwnership() : (this._shouldRequestOwnership = !0, this._needsUpdate = !0);
  }
  /**
   * Free ownership of this object on the network.  
   * You need to be connected to a room for this to work.  
   * This will also be called automatically when the component is disabled.
   */
  freeOwnership() {
    this._model?.freeOwnership();
  }
  /**
   * Checks if this client has ownership of the object
   * @returns true if this client has ownership, false if not, undefined if ownership state is unknown
   */
  hasOwnership() {
    return this._model?.hasOwnership ?? void 0;
  }
  /**
   * Checks if the object is owned by any client
   * @returns true if the object is owned, false if not, undefined if ownership state is unknown
   */
  isOwned() {
    return this._model?.isOwned;
  }
  joinedRoomCallback = null;
  receivedDataCallback = null;
  /** @internal */
  awake() {
    Gs && console.log("new instance", this.guid, this), this._receivedDataBefore = !1, this._targetPosition = new y(), this._targetRotation = new U(), this.lastPosition = new y(), this.lastRotation = new U(), this.lastScale = new y(), this.rb = S.getComponentInChildren(this.gameObject, rt), this.rb && (this._wasKinematic = this.rb.isKinematic), this.receivedUpdate = !0, this._model = new b0(this.context.connection, this.guid), this.context.connection.isConnected && this.tryGetLastState(), this.joinedRoomCallback = this.tryGetLastState.bind(this), this.context.connection.beginListen(te.JoinedRoom, this.joinedRoomCallback), this.receivedDataCallback = this.onReceivedData.bind(this), this.context.connection.beginListenBinary(yc, this.receivedDataCallback);
  }
  /** @internal */
  onDestroy() {
    this.syncDestroy && E0(this.guid, this.context.connection), this._model = null, this.context.connection.stopListen(te.JoinedRoom, this.joinedRoomCallback), this.context.connection.stopListenBinary(yc, this.receivedDataCallback);
  }
  /**
   * Attempts to retrieve and apply the last known network state for this transform
   */
  tryGetLastState() {
    const e = this.context.connection.tryGetState(this.guid);
    e && this.onReceivedData(e);
  }
  tempEuler = new ot();
  /**
   * Handles incoming network data for this transform
   * @param data The model containing transform information
   */
  onReceivedData(e) {
    if (!this.destroyed && typeof e.guid == "function" && e.guid() === this.guid) {
      Gs && console.log("new data", this.context.connection.connectionId, this.context.time.frameCount, this.guid, e), this.receivedUpdate = !0, this._receivedFastUpdate = e.fast();
      const t = e.transform();
      if (t) {
        ln.markDirty(this.gameObject, !0);
        const i = t.position();
        i && (this.interpolatePosition && this._targetPosition?.set(i.x(), i.y(), i.z()), (!this.interpolatePosition || !this._receivedDataBefore) && this.setWorldPosition(i.x(), i.y(), i.z()));
        const n = t.rotation();
        n && (this.tempEuler.set(n.x(), n.y(), n.z()), this.interpolateRotation && this._targetRotation.setFromEuler(this.tempEuler), (!this.interpolateRotation || !this._receivedDataBefore) && i0(this.gameObject, this.tempEuler));
        const o = t.scale();
        o && this.gameObject.scale.set(o.x(), o.y(), o.z());
      }
      this._receivedDataBefore = !0;
    }
  }
  /** 
   * @internal 
   * Initializes tracking of position and rotation when component is enabled
   */
  onEnable() {
    this.lastPosition.copy(this.worldPosition), this.lastRotation.copy(this.worldQuaternion), this.lastScale.copy(this.gameObject.scale), this._needsUpdate = !0, this._model && this._model.updateIsOwned();
  }
  /** 
   * @internal 
   * Releases ownership when component is disabled
   */
  onDisable() {
    this._model && this._model.freeOwnership();
  }
  receivedUpdate = !1;
  lastPosition;
  lastRotation;
  lastScale;
  /** 
   * @internal 
   * Handles transform synchronization before each render frame
   * Sends updates when owner, receives and applies updates when not owner
   */
  onBeforeRender() {
    if (!this.activeAndEnabled || !this.context.connection.isConnected) return;
    if (!this.context.connection.isInRoom || !this._model) {
      Gs && console.log("no model or room", this.name, this.guid, this.context.connection.isInRoom);
      return;
    }
    this._shouldRequestOwnership && (this._shouldRequestOwnership = !1, this._model.requestOwnership());
    const e = this.worldPosition, t = this.worldQuaternion, i = this.gameObject.scale;
    if (this._model.isOwned && !this.receivedUpdate) {
      const r = this._model.hasOwnership || this.fastMode ? 1e-4 : 1e-3;
      (e.distanceTo(this.lastPosition) > r || t.angleTo(this.lastRotation) > r || i.distanceTo(this.lastScale) > r) && (this._model.hasOwnership ? this._needsUpdate = !0 : (Gs && console.log(this.guid, "reset because not owned but", this.gameObject.name, this.lastPosition), this.worldPosition = this.lastPosition, e.copy(this.lastPosition), this.worldQuaternion = this.lastRotation, t.copy(this.lastRotation), this.gameObject.scale.copy(this.lastScale), ln.markDirty(this.gameObject, !0), this._needsUpdate = !1));
    }
    if (this._model && !this._model.hasOwnership && this._model.isOwned && this._receivedDataBefore) {
      const r = this._receivedFastUpdate || this.fastMode ? 0.5 : 0.3;
      let a = !1;
      if (this.interpolatePosition && this._targetPosition) {
        const l = this.worldPosition;
        l.lerp(this._targetPosition, r), this.worldPosition = l, a = !0;
      }
      if (this.interpolateRotation && this._targetRotation) {
        const l = this.worldQuaternion;
        l.slerp(this._targetRotation, r), this.worldQuaternion = l, a = !0;
      }
      a && ln.markDirty(this.gameObject, !0);
    }
    if (this.receivedUpdate = !1, this.lastPosition.copy(e), this.lastRotation.copy(t), this.lastScale.copy(i), !this._model || !this._model || this._model.hasOwnership === void 0 || !this._model.hasOwnership)
      return;
    this.rb && this.overridePhysics && this._wasKinematic !== void 0 && (Gs && console.log("reset kinematic", this.rb.name, this._wasKinematic), this.rb.isKinematic = this._wasKinematic);
    const n = 10, o = this.rb || this.fastMode;
    if (this._needsUpdate && (this.context.time.frameCount % n === 0 || o)) {
      if (Vp++, o && Zl > 0 && this.context.time.frameCount % Zl !== 0) return;
      Gs && console.debug("[SyncedTransform] Send update", this.context.connection.connectionId, this.guid, this.gameObject.name, this.gameObject.guid), this._needsUpdate = !1;
      const r = ov(this.guid, this, !!o);
      this.context.connection.sendBinary(r);
    }
  }
}
class cu {
  /** the original event */
  event;
  /** the index of the used device   
   * mouse and touch are always 0, controller is the gamepad index or XRController index
  */
  get deviceIndex() {
    return this.event.deviceIndex;
  }
  /** a combination of the pointerId + button to uniquely identify the exact input (e.g. LeftController:Button0 = 0, RightController:Button1 = 101) */
  get pointerId() {
    return this.event.pointerId;
  }
  /** 
   * mouse button 0 === LEFT, 1 === MIDDLE, 2 === RIGHT 
   * */
  button;
  buttonName;
  get pressure() {
    return this.event.pressure;
  }
  /** @returns `true` when `use()` has been called. Default: false */
  get used() {
    return this._used;
  }
  _used = !1;
  /** mark this event to be used */
  use() {
    this._used || (this._used = !0, this.event.use());
  }
  _propagationStopped = !1;
  get propagationStopped() {
    return this._propagationStopped;
  }
  /** Call this method to stop immediate propagation on the `event` object.   
   * WARNING: this is currently equivalent to stopImmediatePropagation   
   */
  stopPropagation() {
    this._propagationStopped = !0, this.event.stopImmediatePropagation();
  }
  /** Call this method to stop immediate propagation on the `event` object.   
   */
  stopImmediatePropagation() {
    this._propagationStopped = !0, this.event.stopImmediatePropagation();
  }
  /**@ignore internal flag, pointer captured (we dont want to see it in intellisense) */
  z__pointer_ctured = !1;
  /** Call this method in `onPointerDown` or `onPointerMove` to receive onPointerMove events for this pointerId even when the pointer has left the object until you call `releasePointerCapture` or when the pointerUp event happens 
  */
  setPointerCapture() {
    this.z__pointer_ctured = !0;
  }
  /**@ignore internal flag, pointer capture released */
  z__pointer_cture_rleased = !1;
  /** call this method in `onPointerDown` or `onPointerMove` to stop receiving onPointerMove events */
  releasePointerCapture() {
    this.z__pointer_cture_rleased = !0;
  }
  /** Who initiated this event */
  inputSource;
  /** Returns the input target ray mode e.g. "screen" for 2D mouse and touch events */
  get mode() {
    return this.event.mode;
  }
  /** The object this event hit or interacted with */
  object;
  /** The world position of this event */
  point;
  /** The object-space normal of this event */
  normal;
  /** */
  face;
  /** The distance of the hit point from the origin */
  distance;
  /** The instance ID of an object hit by a raycast (if a instanced object was hit) */
  instanceId;
  /** The three intersection */
  intersection;
  isDown;
  isUp;
  isPressed;
  isClick;
  isDoubleClick;
  input;
  constructor(e, t) {
    this.event = t, this.input = e, this.button = t.button;
  }
  clone() {
    const e = new cu(this.input, this.event);
    return Object.assign(e, this), e;
  }
  /**@deprecated use use() */
  Use() {
    this.use();
  }
  /**@deprecated use stopPropagation() */
  StopPropagation() {
    this.event.stopImmediatePropagation();
  }
}
function Hp(s, e) {
  return S.foreachComponent(s, (i) => {
    if (!i.enabled) return;
    const n = i;
    if (e)
      switch (e) {
        case "pointerdown":
          if (n.onPointerDown) return !0;
          break;
        case "pointerup":
          if (n.onPointerUp || n.onPointerClick) return !0;
          break;
        case "pointermove":
          if (n.onPointerEnter || n.onPointerExit || n.onPointerMove) return !0;
          break;
      }
    else if (n.onPointerDown || n.onPointerUp || n.onPointerEnter || n.onPointerExit || n.onPointerClick)
      return !0;
  }, !1) === !0;
}
const Jn = new Array();
class Ks {
  /**
   * When the CallInfo is enabled it will be invoked when the EventList is invoked
   */
  enabled = !0;
  /**
   * The target object to invoke the method on OR the function to invoke
   */
  target;
  methodName;
  /**
   * The arguments to invoke this method with
   */
  arguments;
  get canClone() {
    return this.target instanceof Object;
  }
  constructor(e, t, i, n) {
    this.target = e, this.methodName = t || null, this.arguments = i, n != null && (this.enabled = n);
  }
  invoke(...e) {
    if (this.enabled !== !1) {
      if (typeof this.target == "function")
        this.arguments ? (Jn.length = 0, e !== void 0 && e.length > 0 && Jn.push(...e), Jn.push(...this.arguments), this.target(...this.arguments), Jn.length = 0) : this.target(...e);
      else if (this.methodName != null) {
        const t = this.target[this.methodName];
        typeof t == "function" ? this.arguments ? (Jn.length = 0, e !== void 0 && e.length > 0 && Jn.push(...e), Jn.push(...this.arguments), t.call(this.target, ...Jn), Jn.length = 0) : t.call(this.target, ...e) : this.arguments ? this.target[this.methodName] = this.arguments[0] || e[0] : this.target[this.methodName] = e[0];
      }
    }
  }
}
const pk = (s) => /^[A-Z]*$/.test(s);
class og extends Event {
  //implements ArrayLike<T> {
  args;
}
class ce {
  /** checked during instantiate to create a new instance */
  isEventList = !0;
  /**
   * @internal Used by the Needle Engine instantiate call to remap the event listeners to the new instance
   */
  __internalOnInstantiate(e) {
    const t = new Array();
    for (let n = 0; n < this.methods.length; n++) {
      const o = this.methods[n];
      if (!(o.target instanceof Function)) {
        const r = o.target;
        let a = r?.uuid;
        if (r && (a = r.guid), a) {
          const l = e[a];
          if (l) {
            const c = o.arguments?.map((h) => h instanceof Object && h.uuid ? e[h.uuid] : h?.isComponent ? e[h.guid] : h);
            t.push(new Ks(l.clone, o.methodName, c, o.enabled));
          } else L() && console.warn("Could not find target for event listener");
        }
      }
    }
    return new ce(t);
  }
  target;
  key;
  // TODO: serialization should not take care of the args but instead give them to the eventlist directly
  // so we can handle passing them on here instead of in the serializer
  // this would also allow us to pass them on to the component EventTarget
  /** set an event target to try invoke the EventTarget dispatchEvent when this EventList is invoked */
  setEventTarget(e, t) {
    if (this.key = e, this.target = t, this.key !== void 0) {
      let i = "", n = !1;
      for (const o of this.key)
        n && pk(o) && (i += "-"), n = !0, i += o.toLowerCase();
      this.key = i;
    }
  }
  /** How many callback methods are subscribed to this event */
  get listenerCount() {
    return this.methods?.length ?? 0;
  }
  /** If the event is currently being invoked */
  get isInvoking() {
    return this._isInvoking;
  }
  _isInvoking = !1;
  // TODO: can we make functions serializable?
  methods = [];
  _methodsCopy = [];
  static from(...e) {
    return new ce(e);
  }
  constructor(e) {
    if (this.methods = [], Array.isArray(e))
      for (const t of e)
        t instanceof Ks ? this.methods.push(t) : typeof t == "function" && this.methods.push(new Ks(t));
    else
      typeof e == "function" && this.methods.push(new Ks(e));
  }
  /** Invoke all the methods that are subscribed to this event */
  invoke(...e) {
    if (this._isInvoking)
      return console.warn("Circular event invocation detected. Please check your event listeners for circular references.", this), !1;
    if (this.methods?.length <= 0) return !1;
    this._isInvoking = !0;
    try {
      this._methodsCopy.length = 0, this._methodsCopy.push(...this.methods);
      for (const t of this._methodsCopy)
        t.invoke(...e);
      if (typeof this.target == "object" && typeof this.key == "string") {
        const t = this.target.dispatchEvent;
        if (typeof t == "function") {
          const i = new og(this.key);
          i.args = e, t.call(this.target, i);
        }
      }
    } finally {
      this._isInvoking = !1, this._methodsCopy.length = 0;
    }
    return !0;
  }
  /** Add a new event listener to this event */
  addEventListener(e) {
    return this.methods.push(new Ks(e)), e;
  }
  removeEventListener(e) {
    if (e)
      for (let t = this.methods.length - 1; t >= 0; t--)
        this.methods[t].target === e && (this.methods[t].enabled = !1, this.methods.splice(t, 1));
  }
  removeAllEventListeners() {
    this.methods.length = 0;
  }
}
class mk extends Zi {
  constructor() {
    super([se, oe], "ColorSerializer");
  }
  onDeserialize(e) {
    if (e != null)
      return e.a !== void 0 ? new oe(e.r, e.g, e.b, e.a) : e.alpha !== void 0 ? new oe(e.r, e.g, e.b, e.alpha) : new se(e.r, e.g, e.b);
  }
  onSerialize(e) {
    if (e != null)
      return e.a !== void 0 ? { r: e.r, g: e.g, b: e.b, a: e.a } : { r: e.r, g: e.g, b: e.b };
  }
}
const ML = new mk();
class gk extends Zi {
  constructor() {
    super([ot], "EulerSerializer");
  }
  onDeserialize(e, t) {
    if (e != null) {
      if (e.order)
        return new ot(e.x, e.y, e.z, e.order);
      if (e.x != null)
        return new ot(e.x, e.y, e.z);
    }
  }
  onSerialize(e, t) {
    return { x: e.x, y: e.y, z: e.z, order: e.order };
  }
}
const RL = new gk();
class yk extends Zi {
  constructor() {
    super(M, "ObjectSerializer");
  }
  onSerialize(e, t) {
    if (t.objectToNode !== void 0 && e.uuid) {
      const i = t.objectToNode[e.uuid];
      return pt && console.log(i, e.name, e.uuid), { node: i };
    }
  }
  onDeserialize(e, t) {
    if (typeof e == "string") {
      if (e.endsWith(".glb") || e.endsWith(".gltf")) {
        if (t.serializable instanceof Array && t.serializable.includes(ie))
          return;
        L() && ge("Detected wrong usage of @serializable with Object3D or GameObject. Instead you should use AssetReference here! Please see the console for details.");
        const i = t.target?.constructor?.name;
        console.warn(`Wrong usage of @serializable detected in your script "${i}"

It looks like you used @serializable(Object3D) or @serializable(GameObject) for a prefab or scene reference which is exported to a separate glTF file.

To fix this please change your code to:

@serializable(AssetReference)
${t.path}! : AssetReference;
\0`);
      }
      return;
    }
    if (e) {
      if (e.node !== void 0 && t.nodeToObject) {
        const i = t.nodeToObject[e.node];
        return pt && console.log("Deserialized object reference?", e, i, t?.nodeToObject), i || console.warn("Did not find node: " + e.node, t.nodeToObject, t.object), i;
      } else if (e.guid) {
        if (!t.context) {
          console.error("Missing context");
          return;
        }
        let i;
        const n = t.gltf?.scene;
        return n && (i = S.findByGuid(e.guid, n)), i || (i = S.findByGuid(e.guid, t.context.scene)), i ? (i && i.isComponent === !0 && (pt && console.warn("Deserialized object reference is a component"), i = i.gameObject), pt && console.log("Deserialized object reference?", e, i, t?.nodeToObject)) : ((L() || pt) && console.warn("Could not resolve object reference", t.path, e, t.target, t.context.scene), e.could_not_resolve = !0), i;
      }
    }
  }
}
const _k = new yk();
class bk extends Zi {
  constructor() {
    super([R, R], "ComponentSerializer");
  }
  onSerialize(e, t) {
    if (e?.guid)
      return { guid: e.guid };
  }
  onDeserialize(e, t) {
    if (e?.guid) {
      if (e.___persistentAsset) {
        pt && console.log("Skipping component deserialization because it's a persistent asset", e);
        return;
      }
      const i = t.path;
      pt && console.log(e.guid, t.root, t.object, t.target);
      let n = this.findObjectForGuid(e.guid, t.root);
      if (n || t.context && (n = this.findObjectForGuid(e.guid, t.context?.scene), n))
        return n;
      (L() || pt) && console.warn('Could not resolve component reference: "' + i + '" using guid ' + e.guid, t.target), e.could_not_resolve = !0;
      return;
    }
  }
  findObjectForGuid(e, t) {
    if (t.guid === e) return t;
    const i = S.foreachComponent(t, (n) => {
      if (n.guid === e) return n;
    }, !1);
    if (i !== void 0)
      return i;
    for (let n = 0; n < t.children.length; n++) {
      const o = t.children[n], r = this.findObjectForGuid(e, o);
      if (r) return r;
    }
  }
}
const Rf = new bk();
class vk extends Zi {
  constructor() {
    super([ce]);
  }
  onSerialize(e, t) {
    console.log("TODO: SERIALIZE EVENT");
  }
  onDeserialize(e, t) {
    if (typeof e == "function")
      return new ce([new Ks(e, null, [], !0)]);
    if (e && e.type === "EventList") {
      pt && console.log("DESERIALIZE EVENT", e);
      const i = new Array();
      if (e.calls && Array.isArray(e.calls))
        for (const r of e.calls) {
          let a = function(h) {
            if (typeof h == "object") {
              let d = _k.onDeserialize(h, t);
              if (d || (d = Rf.onDeserialize(h, t)), d) return d;
            }
            return h;
          };
          pt && console.log(r);
          let l = Rf.findObjectForGuid(r.target, t.root);
          !l && t.context?.scene && (l = Rf.findObjectForGuid(r.target, t.context?.scene));
          const c = r.method?.length > 0;
          if (l && c) {
            const h = () => {
              const f = r.method[0].toUpperCase() + r.method.slice(1);
              if (typeof l[f] == "function") {
                console.warn(`EventList method:
Could not find method ${r.method} on object ${l.name}. Please rename ${r.method} to ${f}?
`, l[f], `
 in script: `, l), ge("EventList methods must start with lowercase letter, see console for details");
                return;
              } else
                console.warn(`EventList method:
Could not find method ${r.method} on object ${l.name}`, l, typeof l[r.method]);
            };
            if (typeof l[r.method] != "function") {
              let f = !1, p = l;
              for (; p; ) {
                const g = Object.getOwnPropertyDescriptor(p, r.method);
                if (g && (g.writable === !0 || g.set)) {
                  f = !0;
                  break;
                }
                p = Object.getPrototypeOf(p);
              }
              !f && (L() || pt) && h();
            }
          }
          if (l) {
            let h = r.argument;
            if (h !== void 0 ? h = a(h) : r.arguments !== void 0 && (h = r.arguments.map(a)), !l[r.method])
              console.warn(`EventList method not found: "${r.method}" on ${l?.name}`);
            else {
              h !== void 0 && !Array.isArray(h) && (h = [h]);
              const f = new Ks(l, r.method, h, r.enabled);
              i.push(f);
            }
          } else L() && console.warn(`[Dev] EventList: Could not find event listener in scene (${t.object?.name})`, r);
        }
      const n = new ce(i);
      pt && console.log(n);
      const o = t.target;
      return o !== void 0 && t.path !== void 0 && n.setEventTarget(t.path, o), n;
    }
  }
  // private createEventMethod(target: object, methodName: string, args?: any): Function | undefined {
  //     return function (...forwardedArgs: any[]) {
  //         const method = target[methodName];
  //         if (typeof method === "function") {
  //             if (args !== undefined) {
  //                 // we now have support for creating event methods with multiple arguments
  //                 // an argument can not be an array right now - so if we receive an array we assume it's the array of arguments that we want to call the method with
  //                 // this means ["test", true] will invoke the method like this: myFunction("test", true) 
  //                 if (Array.isArray(args))
  //                     method?.call(target, ...args);
  //                 // in any other case (when we just have one argument) we just call the method with the argument
  //                 // we can not use ...args by default becaue that would break string arguments (it would then just use the first character)
  //                 else
  //                     method?.call(target, args);
  //             }
  //             else // support invoking EventList with any number of arguments (if none were declared in unity)
  //                 method?.call(target, ...forwardedArgs);
  //         }
  //         else // the target "method" can be a property too
  //         {
  //             target[methodName] = args;
  //         }
  //     };
  // }
}
const TL = new vk(), wd = /* @__PURE__ */ new WeakMap(), wk = Te.prototype.clone;
Te.prototype.clone = function() {
  const s = wk.call(this);
  return wd.has(s) || wd.set(s, this), s;
};
class xk extends Zi {
  constructor() {
    super([ps, Dn]);
  }
  onSerialize(e, t) {
  }
  onDeserialize(e, t) {
    if (e instanceof Te && t.type === ps) {
      let i = e;
      wd.has(i) && (i = wd.get(i)), i.isRenderTargetTexture = !0, i.flipY = !0, i.offset.y = 1, i.repeat.y = -1, i.needsUpdate = !0, i.mipmaps = [], i instanceof Cx && (i.isCompressedTexture = !1, i.format = Wd);
      const n = new ps(i.image.width, i.image.height, {
        colorSpace: Ss
      });
      return n.texture = i, n;
    }
  }
}
new xk();
class Sk extends Zi {
  constructor() {
    super([URL]);
  }
  onSerialize(e, t) {
    return null;
  }
  onDeserialize(e, t) {
    if (typeof e == "string" && e.length > 0)
      return gr(t.gltfId, e);
  }
}
new Sk();
var Ck = Object.defineProperty, Pk = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Ck(e, t, n), n;
};
class Ta extends R {
  awake() {
    ti.createIfNoneExists(this.context);
  }
  onEnable() {
    ti.get(this.context)?.register(this);
  }
  onDisable() {
    ti.get(this.context)?.unregister(this);
  }
}
class qi extends Ta {
  targets = null;
  raycastHits = [];
  ignoreSkinnedMeshes = !1;
  start() {
    this.targets = [this.gameObject];
  }
  performRaycast(e = null) {
    if (!this.targets) return null;
    e ??= new _r(), e.targets = this.targets, e.results = this.raycastHits, e.useAcceleratedRaycast = !0;
    const t = e.testObject;
    this.ignoreSkinnedMeshes && (e.testObject = (n) => n instanceof oo ? "continue in children" : t ? t(n) : !0);
    const i = this.context.physics.raycast(e);
    return e.testObject = t, i;
  }
}
Pk([
  u()
], qi.prototype, "ignoreSkinnedMeshes");
class rg extends qi {
  // eventCamera: Camera | null = null;
  // ignoreReversedGraphics: boolean = false;
  // rootRaycaster: GraphicRaycaster | null = null;
  constructor() {
    super(), this.ignoreSkinnedMeshes = !0;
  }
}
class Ea extends Ta {
  /**
   * Use to disable SpatialGrabRaycaster globally
   */
  static allow = !0;
  performRaycast(e) {
    if (!K.active || !Ea.allow || !e?.ray) return null;
    const t = e.ray.origin;
    return this.context.physics.sphereOverlap(t, 0.015, !1, !0);
  }
}
class rv {
  /** returns the real object when dealing with shadow UI */
  static getObject(e) {
    const t = e[pi];
    return t && (t.isComponent === !0 ? e = t.gameObject : e = t), e;
  }
  static isInteractable(e, t) {
    if (t && (t.canvasGroup = void 0, t.graphic = void 0), e == null || !e.visible || (e = this.getObject(e), !e.visible)) return !1;
    const i = this.tryFindCanvasGroup(e);
    if (i?.isCanvasGroup === !0 && (t && (t.canvasGroup = i), i.blocksRaycasts === !1 || i.interactable === !1))
      return !1;
    const n = Oa(e, (o) => {
      if (o.isGraphic === !0) return o;
    }, !1);
    return t && n?.isGraphic === !0 && (t.graphic = n), !(n?.raycastTarget === !1 || n?.layer === 2);
  }
  static tryFindCanvasGroup(e) {
    if (!e) return null;
    const t = Oa(e, (i) => {
      const n = i;
      if (n.blocksRaycasts !== void 0 && n.interactable !== void 0) return n;
    }, !1);
    return t !== void 0 ? t : this.tryFindCanvasGroup(e.parent);
  }
}
function ag(s) {
  const e = s[pi];
  return e || (s.parent ? ag(s.parent) : null);
}
function Ok(s) {
  return s.isUI === !0 || typeof s[pi] == "object";
}
function xd(s, e) {
  if (!s) return;
  const t = s.material;
  if (t?.isMaterial === !0) {
    const i = s.parent;
    i && i.isText, t.side = e.doubleSided ?? !0 ? xi : fo, t.shadowSide = e.doubleSided ? xi : fo, s.castShadow = e.castShadows ? e.castShadows : !1, s.receiveShadow = e.receiveShadows ? e.receiveShadows : !1;
  }
  for (const i of s.children)
    xd(i, e);
}
function Vr(s, e, t) {
  s[e] === void 0 && console.warn("Field", e, "is undefined on", s);
  const i = Proxy.revocable(s[e], {
    // get(target, prop, receiver) {
    //     return Reflect.get(target, prop, receiver);
    // },
    set(r, a, l, c) {
      const h = r[a], d = Reflect.set(r, a, l, c);
      return t(l, h), d;
    }
  }), n = i.revoke, o = s[e];
  return i.revoke = () => {
    s[e] = o, n();
  }, s[e] = i.proxy, i;
}
const O_ = Symbol("Scheduled action");
function kk(s, e, t = xe.OnBeforeRender) {
  let i = s[O_];
  i || (i = s[O_] = {});
  const n = e.name;
  i[t] || (i[t] = {});
  const o = i[t];
  if (o[n]) return;
  function* a() {
    e?.call(s), o[n] = null;
  }
  const l = s.startCoroutine(a(), t);
  o[n] = l;
}
const qs = w("debugeventsystem");
var Gp = /* @__PURE__ */ ((s) => (s.BeforeHandleInput = "BeforeHandleInput", s.AfterHandleInput = "AfterHandleInput", s))(Gp || {});
WO((s) => {
  ti.createIfNoneExists(s);
});
class ti extends R {
  //@ts-ignore
  static ensureUpdateMeshUI(e, t, i = !1) {
    ul.update(e, t, i);
  }
  static markUIDirty(e) {
    ul.markDirty();
  }
  static createIfNoneExists(e) {
    e.scene.getComponent(ti) || e.scene.addComponent(ti);
  }
  static get(e) {
    return this.createIfNoneExists(e), e.scene.getComponent(ti);
  }
  /** Get the currently active event system */
  static get instance() {
    return this.get(N.Current);
  }
  raycaster = [];
  register(e) {
    e && this.raycaster && !this.raycaster.includes(e) && this.raycaster?.push(e);
  }
  unregister(e) {
    const t = this.raycaster?.indexOf(e);
    t !== void 0 && t !== -1 && this.raycaster?.splice(t, 1);
  }
  get hasActiveUI() {
    return this.currentActiveMeshUIComponents.length > 0;
  }
  get isHoveringObjects() {
    return this.hoveredByID.size > 0;
  }
  awake() {
    this.gameObject !== this.context.scene && (console.debug(`[Needle Engine] EventSystem is only allowed on the scene root. Disabling EventSystem on '${this.gameObject.name}'`), this.enabled = !1);
  }
  start() {
    this.context.scene.getComponent(Ta) || this.context.scene.addComponent(qi);
  }
  onEnable() {
    this.context.input.addEventListener(De.PointerDown, this.onPointerEvent), this.context.input.addEventListener(De.PointerUp, this.onPointerEvent), this.context.input.addEventListener(De.PointerMove, this.onPointerEvent);
  }
  onDisable() {
    this.context.input.removeEventListener(De.PointerDown, this.onPointerEvent), this.context.input.removeEventListener(De.PointerUp, this.onPointerEvent), this.context.input.removeEventListener(De.PointerMove, this.onPointerEvent);
  }
  /**
   * all pointers that have pressed something
   * 
   * key: pointerId
   * value: object that was pressed, data of the pointer event, handlers that are releavant to the event
  */
  pressedByID = /* @__PURE__ */ new Map();
  /**
   * all hovered objects
   * 
   * key: pointerId
   * value: object that is hovered, data of the pointer event
   */
  hoveredByID = /* @__PURE__ */ new Map();
  onBeforeRender() {
    this.resetMeshUIStates();
  }
  /**
   * Handle an pointer event from the input system
   */
  onPointerEvent = (e) => {
    if (e === void 0 || e.propagationStopped || e.defaultPrevented || e.used) return;
    const t = new cu(this.context.input, e);
    this._currentPointerEventName = e.type, t.inputSource = this.context.input, t.isClick = e.isClick, t.isDoubleClick = e.isDoubleClick, t.isDown = e.type == De.PointerDown, t.isUp = e.type == De.PointerUp, t.isPressed = this.context.input.getPointerPressed(e.pointerId);
    const i = new _r();
    e.hasRay ? i.ray = e.ray : i.screenPoint = this.context.input.getPointerPositionRC(e.pointerId), i.allowSlowRaycastFallback = e.isClick || e.isDoubleClick;
    const n = this.performRaycast(i);
    if (qs && (t.isDown ? console.log("DOWN", { id: t.pointerId, hits: n.length }) : t.isUp && console.log("UP", { id: t.pointerId, hits: n.length }), t.isClick && console.log("CLICK", { id: t.pointerId, hits: n.length })), n) {
      for (const r of n)
        r.event = e, e.intersections.push(r);
      e.origin.onPointerHits && e.origin.onPointerHits({
        sender: this,
        event: e,
        hits: n
      });
    }
    qs && t.isClick && Be("EventSystem: " + t.pointerId + " - " + this.context.time.frame + " - Up:" + t.isUp + ", Down:" + t.isDown);
    const o = {
      sender: this,
      args: t,
      hasActiveUI: this.currentActiveMeshUIComponents.length > 0
    };
    this.dispatchEvent(new CustomEvent("BeforeHandleInput", { detail: o })), this.handleIntersections(n, t), this.dispatchEvent(new CustomEvent("AfterHandleInput", { detail: o }));
  };
  _sortedHits = [];
  /** 
   * cache for objects that we want to raycast against. It's cleared before each call to performRaycast invoking raycasters
   */
  _testObjectsCache = /* @__PURE__ */ new Map();
  /** that's the raycaster that is CURRENTLY being used for raycasting (the shouldRaycastObject method uses this) */
  _currentlyActiveRaycaster = null;
  _currentPointerEventName = null;
  /** 
   * Checks if an object that we encounter has an event component and if it does, we add it to our objects cache
   * If it doesnt we tell our raycasting system to ignore it and continue in the child hierarchy
   * We do this to avoid raycasts against objects that are not going to be used by the event system
   * Because there's no component callback to be invoked anyways. 
   * This is especially important to avoid expensive raycasts against SkinnedMeshes
   * 
   * Further optimizations would be to check what type of event we're dealing with
   * For example if an event component has only an onPointerClick method we don't need to raycast during movement events
   * */
  shouldRaycastObject = (e) => {
    const t = e && "getComponent" in e ? e.getComponent(Ta) : null;
    if (t && t != this._currentlyActiveRaycaster)
      return !1;
    let i = null;
    if (Ok(e) && (i = e[pi]?.gameObject), this._testObjectsCache.has(e) || i && this._testObjectsCache.has(i))
      return this._testObjectsCache.get(e) === !1 ? "continue in children" : !0;
    {
      let o = Hp(e, this._currentPointerEventName);
      if (!o && i && (o = Hp(i, this._currentPointerEventName)), o) {
        this._testObjectsCache.set(e, !0);
        for (const r of e.children) this.shouldRaycastObject_AddToYesCache(r);
        return !0;
      }
      return this._testObjectsCache.set(e, !1), "continue in children";
    }
  };
  shouldRaycastObject_AddToYesCache(e) {
    this._testObjectsCache.set(e, !0);
    for (const t of e.children)
      this.shouldRaycastObject_AddToYesCache(t);
  }
  /** the raycast filter is always overriden */
  performRaycast(e) {
    if (!this.raycaster) return null;
    this._testObjectsCache.clear(), this._sortedHits.length = 0, e.testObject = this.shouldRaycastObject;
    for (const t of this.raycaster) {
      if (!t.activeAndEnabled) continue;
      this._currentlyActiveRaycaster = t;
      const i = t.performRaycast(e);
      this._currentlyActiveRaycaster = null, i && i.length > 0 && this._sortedHits.push(...i);
    }
    return this._sortedHits.sort((t, i) => t.distance - i.distance), this._sortedHits;
  }
  assignHitInformation(e, t) {
    t ? (e.intersection = t, e.point = t.point, e.normal = t.normal, e.face = t.face, e.distance = t.distance, e.instanceId = t.instanceId) : (e.intersection = void 0, e.point = void 0, e.normal = void 0, e.face = void 0, e.distance = void 0, e.instanceId = void 0);
  }
  handleIntersections(e, t) {
    if (e?.length) {
      e = this.sortCandidates(e);
      for (const n of e) {
        if (t.event.immediatePropagationStopped)
          return !1;
        if (this.assignHitInformation(t, n), this.handleEventOnObject(n.object, t))
          return !0;
      }
    }
    this.assignHitInformation(t, e?.[0]), this.invokePointerCapture(t);
    const i = this.hoveredByID.get(t.pointerId);
    return i && this.propagatePointerExit(i.obj, i.data, null), this.hoveredByID.delete(t.pointerId), t.isUp && (this.pressedByID.get(t.pointerId)?.handlers.forEach((n) => this.invokeOnPointerUp(t, n)), this.pressedByID.delete(t.pointerId)), !1;
  }
  _sortingBuffer = [];
  _noDepthTestingResults = [];
  sortCandidates(e) {
    this._sortingBuffer.length = 0, this._noDepthTestingResults.length = 0;
    for (let t = 0; t < e.length; t++) {
      const i = e[t], n = i.object;
      if (n.material && n.material.depthTest === !1) {
        this._noDepthTestingResults.push(i);
        continue;
      }
      this._sortingBuffer.push(i);
    }
    for (const t of this._sortingBuffer)
      this._noDepthTestingResults.push(t);
    return this._noDepthTestingResults;
  }
  out = {};
  /** 
   * Handle hit result by preparing all needed information before propagation.
   * Then calling propagate.
   */
  handleEventOnObject(e, t) {
    if (!this.testIsVisible(e))
      return t.isClick && qs && console.log("not allowed", e), !1;
    if (t.pointerId === void 0)
      return qs && console.error("Event without pointer can't be handled", t), !1;
    t.object = e;
    const i = e.parent, n = t.isClick ?? !1;
    let o = null;
    if (i && i.isUI) {
      const h = (t.isPressed || t.isClick) ?? !1;
      if (i[pi]) {
        const d = i[pi].gameObject;
        if (d) {
          if (!rv.isInteractable(d, this.out)) return !1;
          o = this.out.canvasGroup ?? null, this.handleMeshUIIntersection(e, h), e = d;
        }
      }
    }
    n && qs && console.log(this.context.time.frame, e);
    const r = this.hoveredByID.get(t.pointerId), a = r?.obj;
    a !== e && a && this.propagatePointerExit(a, r.data, e);
    const c = this.hoveredByID.get(t.pointerId);
    if (c ? (c.obj = e, c.data = t) : this.hoveredByID.set(t.pointerId, { obj: e, data: t }), t.isDown) {
      const h = this.pressedByID.get(t.pointerId);
      h ? (h.obj = e, h.data = t) : this.pressedByID.set(t.pointerId, { obj: e, data: t, handlers: /* @__PURE__ */ new Set() });
    }
    return (o === null || o.interactable) && this.handleMainInteraction(e, t, a ?? null), !0;
  }
  /**
   * Propagate up in hiearchy and call the callback for each component that is possibly a handler
   */
  propagate(e, t) {
    for (; e; )
      S.foreachComponent(e, (i) => {
        t(i);
      }, !1), e = e.parent;
  }
  /**
   * Propagate up in hierarchy and call handlers based on the pointer event data
   */
  handleMainInteraction(e, t, i) {
    const n = this.pressedByID.get(t.pointerId), o = i !== e;
    let r = !0;
    switch (t.event.pointerType) {
      case "mouse":
      case "touch":
        const a = this.context.input.getPointerPositionLastFrame(t.pointerId), l = this.context.input.getPointerPosition(t.pointerId);
        r = a && !j.approximately(a, l);
        break;
    }
    this.propagate(e, (a) => {
      const l = a;
      l.interactable !== !1 && (!l.activeAndEnabled || !l.enabled || (l.onPointerEnter && o && this.handlePointerEnter(l, t), t.isDown && l.onPointerDown && (l.onPointerDown(t), n?.handlers.add(l), this.handlePointerCapture(t, l)), l.onPointerMove && (r && l.onPointerMove(t), this.handlePointerCapture(t, l)), t.isUp && (l.onPointerUp && (this.invokeOnPointerUp(t, l), n?.handlers.delete(l)), l.onPointerExit && t.event?.pointerType === Um.Touch && (this.handlePointerExit(l, t), this.hoveredByID.delete(t.pointerId))), t.isClick && l.onPointerClick && l.onPointerClick(t)));
    }), t.isUp && (n?.handlers.forEach((a) => {
      this.invokeOnPointerUp(t, a);
    }), this.pressedByID.delete(t.pointerId));
  }
  /** Propagate up in hierarchy and call onPointerExit */
  propagatePointerExit(e, t, i) {
    this.propagate(e, (n) => {
      if (!n.gameObject || n.destroyed) return;
      const o = n;
      if (o.onPointerExit || o.onPointerEnter) {
        if (i && this.isChild(i, n.gameObject))
          return;
        this.handlePointerExit(o, t);
      }
    });
  }
  /** handles onPointerUp - this will also release the pointerCapture */
  invokeOnPointerUp(e, t) {
    t.onPointerUp?.call(t, e), this.releasePointerCapture(e, t);
  }
  /** Responsible for invoking onPointerEnter (and updating onPointerExit). We invoke onPointerEnter once per active pointerId */
  handlePointerEnter(e, t) {
    e.onPointerEnter && this.updatePointerState(e, t.pointerId, this.pointerEnterSymbol, !0) && e.onPointerEnter(t), this.updatePointerState(e, t.pointerId, this.pointerExitSymbol, !1);
  }
  /** Responsible for invoking onPointerExit (and updating onPointerEnter). We invoke onPointerExit once per active pointerId */
  handlePointerExit(e, t) {
    e.onPointerExit && this.updatePointerState(e, t.pointerId, this.pointerExitSymbol, !0) && e.onPointerExit(t), this.updatePointerState(e, t.pointerId, this.pointerEnterSymbol, !1);
  }
  /** updates the pointer state list for a component
   * @param comp the component to update
   * @param pointerId the pointerId to update
   * @param symbol the symbol to use for the state
   * @param add if true, the pointerId is added to the state list, if false the pointerId will be removed
   */
  updatePointerState(e, t, i, n) {
    let o = e[i];
    if (n)
      return o && o.includes(t) ? !1 : (o = o || [], o.push(t), e[i] = o, !0);
    {
      if (!o || !o.includes(t)) return !1;
      const r = o.indexOf(t);
      return r !== -1 && o.splice(r, 1), !0;
    }
  }
  /** the list of component handlers that requested pointerCapture for a specific pointerId */
  _capturedPointer = {};
  /** check if the event was marked to be captured: if yes add the current component to the captured list */
  handlePointerCapture(e, t) {
    if (e.z__pointer_ctured) {
      e.z__pointer_ctured = !1;
      const i = e.pointerId;
      if (t.onPointerMove) {
        const n = this._capturedPointer[i] || [];
        n.push(t), this._capturedPointer[i] = n;
      } else
        L() && !t.z__warned_no_pointermove && (t.z__warned_no_pointermove = !0, console.warn("PointerCapture was requested but the component doesn't implement onPointerMove. It will not receive any pointer events"));
    } else e.z__pointer_cture_rleased && (e.z__pointer_cture_rleased = !1, this.releasePointerCapture(e, t));
  }
  /** removes the component from the pointer capture list */
  releasePointerCapture(e, t) {
    const i = e.pointerId;
    if (this._capturedPointer[i]) {
      const n = this._capturedPointer[i].indexOf(t);
      n !== -1 && (this._capturedPointer[i].splice(n, 1), qs && console.log("released pointer capture", i, t, this._capturedPointer));
    }
  }
  /** invoke the pointerMove event on all captured handlers */
  invokePointerCapture(e) {
    if (e.event.type === De.PointerMove) {
      const t = e.pointerId, i = this._capturedPointer[t];
      if (i) {
        qs && console.log("Captured", t, i);
        for (let n = 0; n < i.length; n++) {
          const o = i[n];
          if (o.destroyed) {
            i.splice(n, 1), n--;
            continue;
          }
          o.onPointerMove?.call(o, e);
        }
      }
    }
  }
  pointerEnterSymbol = Symbol("pointerEnter");
  pointerExitSymbol = Symbol("pointerExit");
  isChild(e, t) {
    return !e || !t ? !1 : e === t ? !0 : e.parent ? this.isChild(e.parent, t) : !1;
  }
  handleMeshUiObjectWithoutShadowDom(e, t) {
    return !e || !e.isUI ? !0 : this.handleMeshUIIntersection(e, t);
  }
  currentActiveMeshUIComponents = [];
  handleMeshUIIntersection(e, t) {
    const i = ul.updateState(e, t);
    return i && this.currentActiveMeshUIComponents.push(i), i !== null;
  }
  resetMeshUIStates() {
    if (this.context.input.getPointerPressedCount() > 0 && ul.resetLastSelected(), !(!this.currentActiveMeshUIComponents || this.currentActiveMeshUIComponents.length <= 0)) {
      for (let e = 0; e < this.currentActiveMeshUIComponents.length; e++) {
        const t = this.currentActiveMeshUIComponents[e];
        ul.resetState(t);
      }
      this.currentActiveMeshUIComponents.length = 0;
    }
  }
  testIsVisible(e) {
    return e ? S.isActiveSelf(e) ? this.testIsVisible(e.parent) : !1 : !0;
  }
}
class ul {
  static lastSelected = null;
  static lastUpdateFrame = [];
  static needsUpdate = !1;
  static markDirty() {
    this.needsUpdate = !0;
  }
  static update(e, t, i = !1) {
    if (i) {
      e.update();
      return;
    }
    const n = t.time.frameCount;
    for (const o of this.lastUpdateFrame)
      if (o.context === t) {
        if (n === o.frame) return;
        o.frame = n;
        let r = this.needsUpdate || n < 1;
        o.nextUpdate <= n && (r = !0), r && (qs && console.log("Update threemeshui"), this.needsUpdate = !1, o.nextUpdate = n + 60, e.update());
        return;
      }
    this.lastUpdateFrame = [{ context: t, frame: n, nextUpdate: n + 60 }], e.update(), this.needsUpdate = !1;
  }
  static updateState(e, t) {
    let i = null;
    if (e && (i = this.findBlockOrTextInParent(e), i && i !== this.lastSelected)) {
      if (i.interactable === !1) return null;
      this.needsUpdate = !0;
    }
    return i;
  }
  static resetLastSelected() {
    const e = this.lastSelected;
    e && (this.lastSelected = null, this.resetState(e));
  }
  static resetState(e) {
    e && (this.needsUpdate = !0);
  }
  static findBlockOrTextInParent(e) {
    return e ? e.isBlock || e.isText ? e : this.findBlockOrTextInParent(e.parent) : null;
  }
}
var Mk = Object.defineProperty, Ee = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Mk(e, t, n), n;
};
const Ft = w("debugorbit"), Tf = w("freecam"), fl = w("debugcamerafit"), yh = w("smoothcam"), Rk = { LEFT: "", UP: "", RIGHT: "", BOTTOM: "" };
let Ef;
class Sd extends CustomEvent {
  constructor(e, t) {
    super("target-reached", {
      detail: {
        controls: e,
        type: t
      }
    });
  }
}
class ye extends R {
  /**
   * @inheritdoc
   */
  get isCameraController() {
    return !0;
  }
  /** The underlying three.js OrbitControls.   
   * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls}
   * @returns {@type ThreeOrbitControls | null}
  */
  get controls() {
    return this._controls;
  }
  /** The object being controlled by the OrbitControls (usually the camera)  
   * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls.object}
   * @returns {@type Object3D | null}
  */
  get controllerObject() {
    return this._cameraObject;
  }
  /** Register callback when user starts interacting with the orbit controls */
  onStartInteraction(e) {
    this.controls?.addEventListener("start", e);
  }
  autoTarget = !0;
  autoFit = !1;
  enableRotate = !0;
  autoRotate = !1;
  autoRotateSpeed = 1;
  minAzimuthAngle = 1 / 0;
  maxAzimuthAngle = 1 / 0;
  minPolarAngle = 0;
  maxPolarAngle = Math.PI;
  enableKeys = !1;
  enableDamping = !0;
  dampingFactor = 0.1;
  enableZoom = !0;
  minZoom = 0;
  maxZoom = 1 / 0;
  zoomSpeed = 1;
  /**
   * Set to true to enable zooming to the cursor position.  
   * @default false
   */
  zoomToCursor = !1;
  enablePan = !0;
  lookAtConstraint = null;
  lookAtConstraint01 = 1;
  allowInterrupt = !0;
  middleClickToFocus = !0;
  doubleClickToFocus = !0;
  clickBackgroundToFitScene = 2;
  /**
   * This is the DOM element that the OrbitControls will listen to for input events. By default this is the renderer's canvas element.  
   * Set this to a different element to make the OrbitControls listen to that element instead.  
   */
  get targetElement() {
    return this._controls?.domElement ?? this._targetElement;
  }
  set targetElement(e) {
    this._targetElement = e, this._controls && this._controls.domElement !== e && (this._controls.disconnect(), this._controls.domElement = e, this._controls.connect());
  }
  _targetElement = null;
  /** 
   * @internal If true debug information will be logged to the console
   * @default false
   */
  debugLog = !1;
  /** 
   * @deprecated use `targetLerpDuration` instead  
   * ~~The speed at which the camera target and the camera will be lerping to their destinations (if set via script or user input)~~ 
   * */
  get targetLerpSpeed() {
    return 5;
  }
  set targetLerpSpeed(e) {
    this.targetLerpDuration = 1 / e;
  }
  targetLerpDuration = 1;
  /**
   * Rotate the camera left (or right) by the specified angle in radians.   
   * For positive angles the camera will rotate to the left, for negative angles it will rotate to the right.  
   * Tip: Use Mathf to convert between degrees and radians.
   * @param angleInRadians The angle in radians to rotate the camera left
   * @example
   * ```typescript
   * // Rotate the camera left by 0.1 radians
   * orbitControls.rotateLeft(0.1);
   * ```
   */
  rotateLeft(e) {
    this._controls?._rotateLeft(e);
  }
  /**
   * Rotate the camera up (or down) by the specified angle in radians.  
   * For positive angles the camera will rotate up, for negative angles it will rotate down.
   * Tip: Use Mathf to convert between degrees and radians.
   * @param angleInRadians The angle in radians to rotate the camera up
   * @example
   * ```typescript
   * // Rotate the camera up by 0.1 radians
   * orbitControls.rotateUp(0.1);
   * ```
   */
  rotateUp(e) {
    this._controls?._rotateUp(e);
  }
  /**
   * Pan the camera by the specified amount in the x and y direction in pixels.
   * @param dx The amount to pan the camera in the x direction in pixels.
   * @param dy The amount to pan the camera in the y direction in pixels.
   */
  pan(e, t) {
    this._controls?._pan(e, t);
  }
  /**
   * Zoom the camera in or out by the specified scale factor. The factor is applied to the current zoom radius / distance.
   * If the scale is greater than 0 then the camera will zoom in, if it is less than 0 then the camera will zoom out. 
   * @param scale The scale factor to zoom the camera in or out. Expected range is between -1 and 1, where 0 means no zoom.
   * @example
   * ```typescript
   * // Zoom in by 0.1
   * orbitControls.zoomIn(0.1);
   * // Zoom out by 0.1
   * orbitControls.zoomIn(-0.1);
   * ```
   */
  zoomIn(e) {
    e > 0 ? this._controls?._dollyIn(1 - e) : e < 0 && this._controls?._dollyOut(1 + e);
  }
  _controls = null;
  _cameraObject = null;
  _lookTargetLerpActive = !1;
  _lookTargetStartPosition = new y();
  _lookTargetEndPosition = new y();
  _lookTargetLerp01 = 0;
  _lookTargetLerpDuration = 0;
  _cameraLerpActive = !1;
  _cameraStartPosition = new y();
  _cameraEndPosition = new y();
  _cameraLerp01 = 0;
  _cameraLerpDuration = 0;
  _fovLerpActive = !1;
  _fovLerpStartValue = 0;
  _fovLerpEndValue = 0;
  _fovLerp01 = 0;
  _fovLerpDuration = 0;
  _inputs = 0;
  _enableTime = 0;
  // use to disable double click when double clicking on UI
  _startedListeningToKeyEvents = !1;
  _eventSystem;
  _afterHandleInputFn;
  _camera = null;
  _syncedTransform;
  _didSetTarget = 0;
  /** @internal */
  awake() {
    Ft && console.debug("OrbitControls", this), this._didSetTarget = 0, this._startedListeningToKeyEvents = !1;
  }
  /** @internal */
  start() {
    this._eventSystem = ti.get(this.context) ?? void 0, this._eventSystem && (this._afterHandleInputFn = this.afterHandleInput.bind(this), this._eventSystem.addEventListener(Gp.AfterHandleInput, this._afterHandleInputFn));
  }
  /** @internal */
  onDestroy() {
    this._controls?.dispose(), this._eventSystem?.removeEventListener(Gp.AfterHandleInput, this._afterHandleInputFn);
  }
  /** @internal */
  onEnable() {
    this._didSetTarget = 0, this._enableTime = this.context.time.time;
    const e = S.getComponent(this.gameObject, yi);
    this._camera = e;
    let t = e?.threeCamera;
    if (!t && this.gameObject instanceof de && (t = this.gameObject), t && Cy(t, this, !0), !this._controls && t instanceof M) {
      this._cameraObject = t;
      const i = this.targetElement ?? this.context.renderer.domElement, n = t?.quaternion.clone();
      this._controls = new Bb(t, i), t?.quaternion.copy(n), Ef === void 0 && (Ef = { ...this._controls.keys });
      const o = Z(t), r = this.gameObject.worldForward, l = o.clone().sub(r.multiplyScalar(2.5));
      this._controls.target.copy(l);
    }
    if (this._controls)
      if (Tf && (this.enablePan = !0, this.enableZoom = !0, this.middleClickToFocus = !0, q.isMobileDevice() && (this.doubleClickToFocus = !0)), this._controls.addEventListener("start", this.onControlsChangeStarted), this._controls.addEventListener("endMovement", this.onControlsChangeEnded), !this._startedListeningToKeyEvents && this.enableKeys)
        this._startedListeningToKeyEvents = !0, this._controls.listenToKeyEvents(this.context.domElement);
      else
        try {
          this._controls.stopListenToKeyEvents();
        } catch {
        }
    this._syncedTransform = S.getComponent(this.gameObject, zn) ?? void 0, this.context.pre_render_callbacks.push(this.__onPreRender), this._activePointerEvents = [], this.context.input.addEventListener("pointerdown", this._onPointerDown, { queue: fi.Early }), this.context.input.addEventListener("pointerdown", this._onPointerDownLate, { queue: fi.Late }), this.context.input.addEventListener("pointerup", this._onPointerUp, { queue: fi.Early }), this.context.input.addEventListener("pointerup", this._onPointerUpLate, { queue: fi.Late });
  }
  /** @internal */
  onDisable() {
    if (this._camera?.threeCamera && Cy(this._camera.threeCamera, this, !1), this._controls) {
      this._controls.enabled = !1, this._controls.autoRotate = !1, this._controls.removeEventListener("start", this.onControlsChangeStarted), this._controls.removeEventListener("endMovement", this.onControlsChangeEnded);
      try {
        this._controls.stopListenToKeyEvents();
      } catch {
      }
      this._startedListeningToKeyEvents = !1;
    }
    this._activePointerEvents.length = 0, this.context.input.removeEventListener("pointerdown", this._onPointerDown), this.context.input.removeEventListener("pointerdown", this._onPointerDownLate), this.context.input.removeEventListener("pointerup", this._onPointerUp), this.context.input.removeEventListener("pointerup", this._onPointerUpLate);
  }
  _activePointerEvents;
  _lastTimeClickOnBackground = -1;
  _clickOnBackgroundCount = 0;
  _onPointerDown = (e) => {
    this._activePointerEvents.push(e);
  };
  _onPointerDownLate = (e) => {
    e.used && this._controls && (this._controls.enabled = !1);
  };
  _onPointerUp = (e) => {
    for (let t = this._activePointerEvents.length - 1; t >= 0; t--) {
      const i = this._activePointerEvents[t];
      if (i.pointerId === e.pointerId && i.button === e.button) {
        this._activePointerEvents.splice(t, 1);
        break;
      }
    }
    if (this.clickBackgroundToFitScene > 0 && e.isClick && e.button === 0) {
      if (e.hasRay || e.intersections.push(...this.context.physics.raycast()), e.intersections.length <= 0) {
        const t = this.context.time.time - this._lastTimeClickOnBackground;
        this._lastTimeClickOnBackground = this.context.time.time, this.clickBackgroundToFitScene <= 1 || t < this.clickBackgroundToFitScene * 0.15 ? (this._clickOnBackgroundCount += 1, this._clickOnBackgroundCount >= this.clickBackgroundToFitScene - 1 && this.fitCamera(this.context.scene.children, {
          immediate: !1
        })) : this._clickOnBackgroundCount = 0;
      }
      Ft && console.log(this.clickBackgroundToFitScene, e.intersections.length, this._clickOnBackgroundCount);
    }
  };
  _onPointerUpLate = (e) => {
    this.doubleClickToFocus && e.isDoubleClick && !e.used && this.setTargetFromRaycast();
  };
  updateTargetNow(e) {
    const t = new uo(this._cameraObject?.worldPosition, this._cameraObject?.worldForward.multiplyScalar(-1)), i = this.context.physics.raycastFromRay(t, e), n = i.length > 0 ? i[0] : void 0;
    n && n.distance > this.minZoom && n.distance < this.maxZoom ? (Ft && z.DrawWireSphere(n.point, 0.1, 16711680, 2), this._controls?.target.copy(i[0].point)) : Ft && console.log("OrbitControls: No hit found when updating target", { hits: [...i] });
  }
  _orbitStartAngle = 0;
  _zoomStartDistance = 0;
  onControlsChangeStarted = () => {
    Ft && console.debug("OrbitControls: Change started"), this._controls && (this._orbitStartAngle = this._controls.getAzimuthalAngle() + this._controls.getPolarAngle(), this._zoomStartDistance = this._controls.getDistance()), this._syncedTransform && this._syncedTransform.requestOwnership();
  };
  onControlsChangeEnded = () => {
    if (Ft && console.debug("OrbitControls: Change ended", { autoTarget: this.autoTarget }), this._controls && this.autoTarget) {
      const t = this._controls.getAzimuthalAngle() + this._controls.getPolarAngle() - this._orbitStartAngle;
      Math.abs(t) < 0.01 ? (Ft && console.debug("OrbitControls: Update target", { deltaAngle: t }), this.updateTargetNow({ allowSlowRaycastFallback: !1 })) : Ft && console.debug("OrbitControls: No target update", { deltaAngle: t });
    }
  };
  _shouldDisable = !1;
  afterHandleInput(e) {
    e.detail.args.pointerId === 0 && (e.detail.args.isDown ? this._controls && this._eventSystem && (this._shouldDisable = this._eventSystem.hasActiveUI) : (!e.detail.args.isPressed || e.detail.args.isUp) && (this._shouldDisable = !1));
  }
  onPausedChanged(e) {
    this._controls && e && (this._controls.enabled = !1);
  }
  /** @internal */
  onBeforeRender() {
    if (!this._controls) return;
    if (this._cameraObject !== this.context.mainCamera) {
      this._controls.enabled = !1;
      return;
    }
    if (this._controls.enabled = !0, (this.context.input.getPointerDown(1) || this.context.input.getPointerDown(2) || this.context.input.mouseWheelChanged || this.context.input.getPointerPressed(0) && this.context.input.getPointerPositionDelta(0)?.length()) && (this._inputs += 1), this._inputs > 0 && this.allowInterrupt && (this.enableRotate && (this.autoRotate = !1), this._cameraLerpActive = !1, this._lookTargetLerpActive = !1), this._inputs = 0, this.autoTarget && this._didSetTarget++ === 0) {
      const t = S.getComponent(this.gameObject, yi);
      if (t && !this.setLookTargetFromConstraint()) {
        this.debugLog && console.log("NO TARGET");
        const i = Z(t.threeCamera), n = Math.max(0.01, i.length()), o = new y(0, 0, -n).applyMatrix4(t.threeCamera.matrixWorld);
        Ft && z.DrawLine(i, o, 5592575, 10), this.setLookTargetPosition(o, !0);
      }
      if (!this.setLookTargetFromConstraint()) {
        const i = new _r();
        i.screenPoint = new J(0, 0), i.lineThreshold = 0.1;
        const n = this.context.physics.raycast(i);
        n.length > 0 && this.setLookTargetPosition(n[0].point, !0), fl && console.log("OrbitControls hits", ...n);
      }
    }
    if (this.middleClickToFocus && this.context.input.getPointerClicked(1) && this.setTargetFromRaycast(), this._lookTargetLerpActive || this._cameraLerpActive || this._fovLerpActive) {
      if (this._cameraLerpActive && this._cameraObject)
        if (this._cameraLerp01 += this.context.time.deltaTime / this._cameraLerpDuration, this._cameraLerp01 >= 1)
          this._cameraObject.position.copy(this._cameraEndPosition), this._cameraLerpActive = !1, this.dispatchEvent(new Sd(this, "camera"));
        else {
          const t = j.easeInOutCubic(this._cameraLerp01);
          this._cameraObject.position.lerpVectors(this._cameraStartPosition, this._cameraEndPosition, t);
        }
      if (this._lookTargetLerpActive)
        if (this._lookTargetLerp01 += this.context.time.deltaTime / this._lookTargetLerpDuration, this._lookTargetLerp01 >= 1)
          this.lerpLookTarget(this._lookTargetEndPosition, this._lookTargetEndPosition, 1), this._lookTargetLerpActive = !1, this.dispatchEvent(new Sd(this, "lookat"));
        else {
          const t = j.easeInOutCubic(this._lookTargetLerp01);
          this.lerpLookTarget(this._lookTargetStartPosition, this._lookTargetEndPosition, t);
        }
      if (this._fovLerpActive && this._cameraObject) {
        const t = this._cameraObject;
        if (this._fovLerp01 += this.context.time.deltaTime / this._fovLerpDuration, this._fovLerp01 >= 1)
          t.fov = this._fovLerpEndValue, this._fovLerpActive = !1;
        else {
          const i = j.easeInOutCubic(this._fovLerp01);
          t.fov = j.lerp(this._fovLerpStartValue, this._fovLerpEndValue, i);
        }
        t.updateProjectionMatrix();
      }
    }
    if (this._controls) {
      if (this.debugLog && (this._controls.domElement = this.context.renderer.domElement), this._controls.enabled = !this._shouldDisable && this._camera === this.context.mainCameraComponent && !this.context.isInXR && !this._activePointerEvents.some((t) => t.used), this._controls.keys = this.enableKeys ? Ef : Rk, this._controls.autoRotate = this.autoRotate, this._controls.autoRotateSpeed = this.autoRotateSpeed, this._controls.enableZoom = this.enableZoom, this._controls.zoomSpeed = this.zoomSpeed, this._controls.zoomToCursor = this.zoomToCursor, this._controls.enableDamping = this.enableDamping, this._controls.dampingFactor = this.dampingFactor, this._controls.enablePan = this.enablePan, this._controls.enableRotate = this.enableRotate, this._controls.minAzimuthAngle = this.minAzimuthAngle, this._controls.maxAzimuthAngle = this.maxAzimuthAngle, this._controls.minPolarAngle = this.minPolarAngle, this._controls.maxPolarAngle = this.maxPolarAngle, Tf || (this._camera?.threeCamera?.type === "PerspectiveCamera" ? (this._controls.minDistance = this.minZoom, this._controls.maxDistance = this.maxZoom, this._controls.minZoom = 0, this._controls.maxZoom = 1 / 0) : (this._controls.minDistance = 0, this._controls.maxDistance = 1 / 0, this._controls.minZoom = this.minZoom, this._controls.maxZoom = this.maxZoom)), typeof yh == "number" || yh === !0) {
        this._controls.enableDamping = !0;
        const t = typeof yh == "number" ? yh : 0.99;
        this._controls.dampingFactor = Math.max(1e-3, 1 - Math.min(1, t));
      }
      this.allowInterrupt || (this._lookTargetLerpActive && (this._controls.enablePan = !1), this._cameraLerpActive && (this._controls.enableRotate = !1, this._controls.autoRotate = !1), (this._lookTargetLerpActive || this._cameraLerpActive) && (this._controls.enableZoom = !1)), this.context.isInXR || (!Tf && this.lookAtConstraint?.locked && !this._lookTargetLerpActive && this.setLookTargetFromConstraint(0, this.lookAtConstraint01), this._controls.update(this.context.time.deltaTime), Ft && z.DrawWireSphere(this._controls.target, 0.1, 65280));
    }
  }
  __onPreRender = () => {
    const e = this.context.pre_render_callbacks.indexOf(this.__onPreRender);
    e >= 0 && this.context.pre_render_callbacks.splice(e, 1), this.autoFit && (this.autoFit = !1, this.fitCamera({
      centerCamera: "y",
      immediate: !0,
      objects: this.scene.children
    }));
  };
  /** 
   * Sets camera target position and look direction using a raycast in forward direction of the object.  
   * 
   * @param source The object to raycast from. If a camera is passed in the camera position will be used as the source.
   * @param immediateOrDuration If true the camera target will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
   * 
   * This is useful for example if you want to align your camera with an object in your scene (or another camera). Simply pass in this other camera object
   * @returns true if the target was set successfully
   */
  setCameraAndLookTarget(e, t = !1) {
    if (!e)
      return (L() || Ft) && console.warn("[OrbitControls] setCameraAndLookTarget target is null"), !1;
    if (!(e instanceof M) && !(e instanceof yi))
      return (L() || Ft) && console.warn("[OrbitControls] setCameraAndLookTarget target is not an Object3D or Camera"), !1;
    e instanceof yi && (e = e.gameObject);
    const i = e.worldPosition, n = e.worldForward;
    e instanceof Px && (Ft && console.debug("[OrbitControls] setCameraAndLookTarget flip forward direction for camera"), n.multiplyScalar(-1));
    const o = new uo(i, n);
    return Ft && z.DrawRay(o.origin, o.direction, 16711680, 10), this.setTargetFromRaycast(o, t) || this.setLookTargetPosition(o.at(2, H()), t), this.setCameraTargetPosition(i, t), !0;
  }
  /** Moves the camera to position smoothly. 
   * @param position The position in local space of the controllerObject to move the camera to. If null the camera will stop lerping to the target.
   * @param immediateOrDuration If true the camera will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
  */
  setCameraTargetPosition(e, t = !1) {
    e && (e instanceof M && (e = Z(e)), this._cameraEndPosition || (this._cameraEndPosition = new y()), this._cameraEndPosition.copy(e), t === !0 ? (this._cameraLerpActive = !1, this._cameraObject && this._cameraObject.position.copy(this._cameraEndPosition)) : this._cameraObject && (this._cameraLerpActive = !0, this._cameraLerp01 = 0, this._cameraStartPosition.copy(this._cameraObject?.position), typeof t == "number" ? this._cameraLerpDuration = t : this._cameraLerpDuration = this.targetLerpDuration));
  }
  // public setCameraTargetRotation(rotation: Vector3 | Euler | Quaternion, immediateOrDuration: boolean | number = false): void {
  //     if (!this._cameraObject) return;
  //     if (typeof immediateOrDuration === "boolean") immediateOrDuration = immediateOrDuration ? 0 : this.targetLerpDuration;
  //     const ray = new Ray(this._cameraObject.worldPosition, getTempVector(0, 0, 1));
  //     // if the camera is in the middle of lerping we use the end position for the raycast
  //     if (immediateOrDuration > 0 && this._cameraEndPosition && this._cameraLerpActive) {
  //         ray.origin = getTempVector(this._cameraEndPosition)
  //     }
  //     if (rotation instanceof Vector3) {
  //         rotation = new Euler().setFromVector3(rotation);
  //     }
  //     if (rotation instanceof Euler) {
  //         rotation = new Quaternion().setFromEuler(rotation);
  //     }
  //     ray.direction.applyQuaternion(rotation);
  //     ray.direction.multiplyScalar(-1);
  //     const hits = this.context.physics.raycastFromRay(ray);
  //     if (hits.length > 0) {
  //         this.setCameraTargetPosition(hits[0].point, immediateOrDuration);
  //     }
  //     else {
  //         this.setLookTargetPosition(ray.at(2, getTempVector()));
  //     }
  // }
  /** True while the camera position is being lerped */
  get cameraLerpActive() {
    return this._cameraLerpActive;
  }
  /** Call to stop camera position lerping */
  stopCameraLerp() {
    this._cameraLerpActive = !1;
  }
  setFieldOfView(e, t = !1) {
    if (!this._controls || typeof e != "number") return;
    const i = this._camera?.threeCamera;
    i && (t === !0 ? i.fov = e : (this._fovLerpActive = !0, this._fovLerp01 = 0, this._fovLerpStartValue = i.fov, this._fovLerpEndValue = e, typeof t == "number" ? this._fovLerpDuration = t : this._fovLerpDuration = this.targetLerpDuration));
  }
  /** Moves the camera look-at target to a position smoothly. 
   * @param position The position in world space to move the camera target to. If null the camera will stop lerping to the target.
   * @param immediateOrDuration If true the camera target will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
  */
  setLookTargetPosition(e = null, t = !1) {
    this._controls && e && (e instanceof M && (e = Z(e)), this._lookTargetEndPosition.copy(e), this._didSetTarget++, Ft && (console.warn("OrbitControls: setLookTargetPosition", e, t), z.DrawWireSphere(this._lookTargetEndPosition, 0.2, 16711680, 2)), t === !0 ? this.lerpLookTarget(this._lookTargetEndPosition, this._lookTargetEndPosition, 1) : (this._lookTargetLerpActive = !0, this._lookTargetLerp01 = 0, this._lookTargetStartPosition.copy(this._controls.target), typeof t == "number" ? this._lookTargetLerpDuration = t : this._lookTargetLerpDuration = this.targetLerpDuration));
  }
  /** True while the camera look target is being lerped */
  get lookTargetLerpActive() {
    return this._lookTargetLerpActive;
  }
  /** Call to stop camera look target lerping */
  stopLookTargetLerp() {
    this._lookTargetLerpActive = !1;
  }
  /** Sets the look at target from an assigned lookAtConstraint source by index 
   * @param index The index of the source to use
   * @param t The interpolation factor between the current look at target and the new target
  */
  setLookTargetFromConstraint(e = 0, t = 1) {
    if (!this._controls || this.lookAtConstraint?.enabled === !1) return !1;
    const i = this.lookAtConstraint?.sources;
    if (i && i.length > 0) {
      const n = i[e];
      if (n)
        return n.getWorldPosition(this._lookTargetEndPosition), this.lerpLookTarget(this._controls.target, this._lookTargetEndPosition, t), !0;
    }
    return !1;
  }
  lerpLookTarget(e, t, i) {
    this._controls && (i >= 1 ? this._controls.target.copy(t) : this._controls.target.lerpVectors(e, t, i), this.lookAtConstraint && this.lookAtConstraint.setConstraintPosition(this._controls.target));
  }
  setTargetFromRaycast(e, t = !1) {
    if (!this.controls) return !1;
    const i = e ? this.context.physics.raycastFromRay(e) : this.context.physics.raycast();
    for (const n of i)
      if (n.distance > 0 && S.isActiveInHierarchy(n.object)) {
        const o = ag(n.object);
        if (o && o.canvas?.screenspace)
          break;
        return this.setLookTargetPosition(n.point, t), !0;
      }
    return !1;
  }
  fitCamera(e, t) {
    if (this.context.isInXR) {
      console.warn("[OrbitControls] Can not fit camera while XR session is active");
      return;
    }
    let i;
    if (Array.isArray(e) || e && "type" in e ? i = e : e && typeof e == "object" && !(e instanceof M) && !Array.isArray(e) && (t = e, i = t.objects), i && !Array.isArray(i) && (i = [i]), (!Array.isArray(i) || i && i.length <= 0) && (i = this.context.scene.children), !Array.isArray(i) || i.length <= 0) {
      console.warn("No objects to fit camera to...");
      return;
    }
    const n = this._cameraObject, o = this._controls;
    if (!n || !o) {
      console.warn("No camera or controls found to fit camera to objects...");
      return;
    }
    t || (t = {});
    const { immediate: r = !1, centerCamera: a, cameraNearFar: l = "auto", fitOffset: c = 1.1, fov: h = n?.fov } = t, d = new y(), f = new y(), p = ii(i, void 0, this._camera?.threeCamera?.layers), g = p.clone();
    p.getCenter(f);
    const b = new y();
    if (p.getSize(b), n.updateMatrixWorld(), p.applyMatrix4(n.matrixWorldInverse), p.getSize(d), p.setFromCenterAndSize(f, d), Number.isNaN(d.x) || Number.isNaN(d.y) || Number.isNaN(d.z)) {
      console.warn("Camera fit size resultet in NaN", n, p, [...i]);
      return;
    }
    if (d.length() <= 1e-10) {
      fl && console.warn("Camera fit size is zero", p, [...i]);
      return;
    }
    const m = h, v = 2 * Math.atan(Math.tan(m * Math.PI / 360 / 2) * n.aspect) / Math.PI * 360, _ = d.y / (2 * Math.atan(Math.PI * m / 360)), x = d.x / (2 * Math.atan(Math.PI * v / 360)), I = c * Math.max(_, x) + d.z / 2;
    fl && console.log("Fit camera to objects", { fitHeightDistance: _, fitWidthDistance: x, distance: I, verticalFov: m, horizontalFov: v }), this.maxZoom = I * 10, this.minZoom = I * 0.01;
    const O = 0.05, k = f.clone();
    if (k.y -= d.y * O, t.targetOffset && (t.targetOffset.x !== void 0 && (k.x += t.targetOffset.x), t.targetOffset.y !== void 0 && (k.y += t.targetOffset.y), t.targetOffset.z !== void 0 && (k.z += t.targetOffset.z)), t.relativeTargetOffset && (t.relativeTargetOffset.x !== void 0 && (k.x += t.relativeTargetOffset.x * d.x), t.relativeTargetOffset.y !== void 0 && (k.y += t.relativeTargetOffset.y * d.y), t.relativeTargetOffset.z !== void 0 && (k.z += t.relativeTargetOffset.z * d.z)), this.setLookTargetPosition(k, r), this.setFieldOfView(t.fov, r), l == null || l == "auto") {
      const W = S.findObjectOfType(Rs), X = W ? W.radius : 0, A = Math.max(b.x, b.y, b.z, X);
      n.near = I / 100, n.far = A + I * 10, n.updateProjectionMatrix(), W && (this.maxZoom = Math.max(Math.min(this.maxZoom, X * 0.5), I));
    }
    const E = o.getDistance();
    E < this.minZoom && (this.minZoom = E * 0.9), E > this.maxZoom && (this.maxZoom = E * 1.1);
    const B = f.clone();
    t.fitDirection ? B.sub(new y().copy(t.fitDirection).multiplyScalar(1e6)) : B.sub(n.worldPosition), a === "y" && (B.y = 0), B.normalize(), B.multiplyScalar(I), a === "y" && (B.y += -O * 4 * I);
    let D = f.clone().sub(B);
    t.cameraOffset && (t.cameraOffset.x !== void 0 && (D.x += t.cameraOffset.x), t.cameraOffset.y !== void 0 && (D.y += t.cameraOffset.y), t.cameraOffset.z !== void 0 && (D.z += t.cameraOffset.z)), t.relativeCameraOffset && (t.relativeCameraOffset.x !== void 0 && (D.x += t.relativeCameraOffset.x * d.x), t.relativeCameraOffset.y !== void 0 && (D.y += t.relativeCameraOffset.y * d.y), t.relativeCameraOffset.z !== void 0 && (D.z += t.relativeCameraOffset.z * d.z)), n.parent && (D = n.parent.worldToLocal(D)), this.setCameraTargetPosition(D, r), (fl || t.debug) && (z.DrawWireBox3(p, 16777011, 10), z.DrawWireBox3(g, 65280, 10), !this._haveAttachedKeyboardEvents && fl && (this._haveAttachedKeyboardEvents = !0, document.body.addEventListener("keydown", (W) => {
      if (W.code === "KeyF") {
        let X;
        this._cameraObject instanceof de && (X = Math.random() * Math.random() * 170 + 10), this.fitCamera({ objects: i, fitOffset: c, immediate: !1, fov: X });
      }
      W.code === "KeyV" && this._cameraObject instanceof de && (this._cameraObject.fov = 60);
    }))), this.onBeforeRender();
  }
  _haveAttachedKeyboardEvents = !1;
}
Ee([
  u()
], ye.prototype, "autoTarget");
Ee([
  u()
], ye.prototype, "autoFit");
Ee([
  u()
], ye.prototype, "enableRotate");
Ee([
  u()
], ye.prototype, "autoRotate");
Ee([
  u()
], ye.prototype, "autoRotateSpeed");
Ee([
  u()
], ye.prototype, "minAzimuthAngle");
Ee([
  u()
], ye.prototype, "maxAzimuthAngle");
Ee([
  u()
], ye.prototype, "minPolarAngle");
Ee([
  u()
], ye.prototype, "maxPolarAngle");
Ee([
  u()
], ye.prototype, "enableKeys");
Ee([
  u()
], ye.prototype, "enableDamping");
Ee([
  u()
], ye.prototype, "dampingFactor");
Ee([
  u()
], ye.prototype, "enableZoom");
Ee([
  u()
], ye.prototype, "minZoom");
Ee([
  u()
], ye.prototype, "maxZoom");
Ee([
  u()
], ye.prototype, "zoomSpeed");
Ee([
  u()
], ye.prototype, "enablePan");
Ee([
  u(ja)
], ye.prototype, "lookAtConstraint");
Ee([
  u()
], ye.prototype, "lookAtConstraint01");
Ee([
  u()
], ye.prototype, "allowInterrupt");
Ee([
  u()
], ye.prototype, "middleClickToFocus");
Ee([
  u()
], ye.prototype, "doubleClickToFocus");
Ee([
  u()
], ye.prototype, "clickBackgroundToFitScene");
Ee([
  u()
], ye.prototype, "targetLerpDuration");
var Tk = Object.defineProperty, Ek = Object.getOwnPropertyDescriptor, qt = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? Ek(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && Tk(e, t, n), n;
}, ha = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Skybox = 1] = "Skybox", s[s.SolidColor = 2] = "SolidColor", s[s.Uninitialized = 4] = "Uninitialized", s))(ha || {});
const Xs = w("debugcam"), k_ = w("debugscreenpointtoray"), Dt = class Il extends R {
  /**
   * Returns whether this component is a camera
   * @returns {boolean} Always returns true
   */
  get isCamera() {
    return !0;
  }
  /** 
   * Gets or sets the camera's aspect ratio (width divided by height).
   * For perspective cameras, this directly affects the camera's projection matrix.
   * When set, automatically updates the projection matrix.
   */
  get aspect() {
    return this._cam instanceof de ? this._cam.aspect : this.context.domWidth / this.context.domHeight;
  }
  set aspect(e) {
    this._cam instanceof de && this._cam.aspect !== e && (this._cam.aspect = e, this._cam.updateProjectionMatrix());
  }
  /**
   * Gets or sets the camera's field of view in degrees for perspective cameras.
   * When set, automatically updates the projection matrix.
   */
  get fieldOfView() {
    return this._cam instanceof de ? this._cam.fov : this._fov;
  }
  set fieldOfView(e) {
    const t = this.fieldOfView != e;
    if (this._fov = e, t && this._cam && this._cam instanceof de) {
      if (this._fov === void 0) {
        console.warn("Can not set undefined fov on PerspectiveCamera");
        return;
      }
      this._cam.fov = this._fov, this._cam.updateProjectionMatrix();
    }
  }
  /**
   * Gets or sets the camera's near clipping plane distance.
   * Objects closer than this distance won't be rendered.
   * When set, automatically updates the projection matrix.
   */
  get nearClipPlane() {
    return this._nearClipPlane;
  }
  set nearClipPlane(e) {
    const t = this._nearClipPlane != e;
    this._nearClipPlane = e, this._cam && (t || this._cam.near != e) && (this._cam.near = e, this._cam.updateProjectionMatrix());
  }
  _nearClipPlane = 0.1;
  /**
   * Gets or sets the camera's far clipping plane distance.
   * Objects farther than this distance won't be rendered.
   * When set, automatically updates the projection matrix.
   */
  get farClipPlane() {
    return this._farClipPlane;
  }
  set farClipPlane(e) {
    const t = this._farClipPlane != e;
    this._farClipPlane = e, this._cam && (t || this._cam.far != e) && (this._cam.far = e, this._cam.updateProjectionMatrix());
  }
  _farClipPlane = 1e3;
  /**
   * Applies both the camera's near and far clipping planes and updates the projection matrix.
   * This ensures rendering occurs only within the specified distance range.
   */
  applyClippingPlane() {
    this._cam && (this._cam.near = this._nearClipPlane, this._cam.far = this._farClipPlane, this._cam.updateProjectionMatrix());
  }
  get clearFlags() {
    return this._clearFlags;
  }
  set clearFlags(e) {
    if (typeof e == "string")
      switch (e) {
        case "skybox":
          e = 1;
          break;
        case "solidcolor":
          e = 2;
          break;
        default:
          e = 0;
          break;
      }
    e !== this._clearFlags && (this._clearFlags = e, this.applyClearFlagsIfIsActiveCamera());
  }
  orthographic = !1;
  orthographicSize = 5;
  ARBackgroundAlpha = 0;
  set cullingMask(e) {
    this._cullingMask = e, this._cam && (this._cam.layers.mask = e);
  }
  get cullingMask() {
    return this._cam ? this._cam.layers.mask : this._cullingMask;
  }
  _cullingMask = 4294967295;
  /**
   * Sets only a specific layer to be active for rendering by this camera.
   * This is equivalent to calling `layers.set(val)` on the three.js camera object.
   * @param val The layer index to set active
   */
  set cullingLayer(e) {
    this.cullingMask = (1 << e | 0) >>> 0;
  }
  set backgroundBlurriness(e) {
    e !== this._backgroundBlurriness && (e === void 0 ? this._backgroundBlurriness = void 0 : this._backgroundBlurriness = Math.min(Math.max(e, 0), 1), this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundBlurriness() {
    return this._backgroundBlurriness;
  }
  _backgroundBlurriness = void 0;
  set backgroundIntensity(e) {
    e !== this._backgroundIntensity && (e === void 0 ? this._backgroundIntensity = void 0 : this._backgroundIntensity = Math.min(Math.max(e, 0), 10), this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundIntensity() {
    return this._backgroundIntensity;
  }
  _backgroundIntensity = void 0;
  set backgroundRotation(e) {
    e !== this._backgroundRotation && (e === void 0 ? this._backgroundRotation = void 0 : this._backgroundRotation = e, this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundRotation() {
    return this._backgroundRotation;
  }
  _backgroundRotation = void 0;
  set environmentIntensity(e) {
    this._environmentIntensity = e;
  }
  get environmentIntensity() {
    return this._environmentIntensity;
  }
  _environmentIntensity = void 0;
  get backgroundColor() {
    return this._backgroundColor ?? null;
  }
  set backgroundColor(e) {
    e && (this._backgroundColor || (this._backgroundColor = new oe(1, 1, 1, 1)), this._backgroundColor.copy(e), (!("alpha" in e) || e.alpha === void 0) && (this._backgroundColor.alpha = 1), this.applyClearFlagsIfIsActiveCamera());
  }
  set targetTexture(e) {
    this._targetTexture = e;
  }
  get targetTexture() {
    return this._targetTexture;
  }
  _targetTexture = null;
  _backgroundColor;
  _fov;
  _cam = null;
  _clearFlags = 2;
  _skybox;
  /**
   * Gets the three.js camera object. Creates one if it doesn't exist yet.
   * @returns {PerspectiveCamera | OrthographicCamera} The three.js camera object
   * @deprecated Use {@link threeCamera} instead
   */
  get cam() {
    return this.threeCamera;
  }
  /**
   * Gets the three.js camera object. Creates one if it doesn't exist yet.
   * @returns {PerspectiveCamera | OrthographicCamera} The three.js camera object
   */
  get threeCamera() {
    return this.activeAndEnabled && this.buildCamera(), this._cam;
  }
  static _origin = new y();
  static _direction = new y();
  /**
   * Converts screen coordinates to a ray in world space.
   * Useful for implementing picking or raycasting from screen to world.
   * 
   * @param x The x screen coordinate
   * @param y The y screen coordinate
   * @param ray Optional ray object to reuse instead of creating a new one
   * @returns {Ray} A ray originating from the camera position pointing through the screen point
   */
  screenPointToRay(e, t, i) {
    const n = this.threeCamera, o = Il._origin;
    o.set(e, t, -1), this.context.input.convertScreenspaceToRaycastSpace(o), k_ && console.log("screenPointToRay", e.toFixed(2), t.toFixed(2), "now:", o.x.toFixed(2), o.y.toFixed(2), "isInXR:" + this.context.isInXR), o.z = -1, o.unproject(n);
    const r = Il._direction.set(o.x, o.y, o.z), a = Z(n);
    return r.sub(a), r.normalize(), i ? (i.set(a, r), i) : new uo(a.clone(), r.clone());
  }
  _frustum;
  /**
   * Gets the camera's view frustum for culling and visibility checks.
   * Creates the frustum if it doesn't exist and returns it.
   * 
   * @returns {Frustum} The camera's view frustum
   */
  getFrustum() {
    return this._frustum || (this._frustum = new ay(), this.updateFrustum()), this._frustum;
  }
  /**
   * Forces an update of the camera's frustum.
   * This is automatically called every frame in onBeforeRender.
   */
  updateFrustum() {
    this._frustum || (this._frustum = new ay()), this._frustum.setFromProjectionMatrix(this.getProjectionScreenMatrix(this._projScreenMatrix, !0), this.context.renderer.coordinateSystem);
  }
  /**
   * Gets this camera's projection-screen matrix.
   * 
   * @param target Matrix4 object to store the result in
   * @param forceUpdate Whether to force recalculation of the matrix
   * @returns {Matrix4} The requested projection screen matrix
   */
  getProjectionScreenMatrix(e, t) {
    return t && this._projScreenMatrix.multiplyMatrices(this.threeCamera.projectionMatrix, this.threeCamera.matrixWorldInverse), e === this._projScreenMatrix ? e : e.copy(this._projScreenMatrix);
  }
  _projScreenMatrix = new ee();
  /** @internal */
  awake() {
    k_ && window.addEventListener("pointerdown", (e) => {
      const t = e.clientX, i = e.clientY;
      console.log("touch", t.toFixed(2), i.toFixed(2));
      const n = this.screenPointToRay(t, i), o = "#" + Math.floor(Math.random() * 16777215).toString(16);
      z.DrawRay(n.origin, n.direction, o, 10);
    });
  }
  /** @internal */
  onEnable() {
    Xs && console.log(`Camera enabled: "${this.name}". ClearFlags=${ha[this._clearFlags]}`, this), this.buildCamera(), (this.tag == "MainCamera" || !this.context.mainCameraComponent) && (this.context.setCurrentCamera(this), Ik(this)), this.applyClearFlagsIfIsActiveCamera({ applySkybox: !0 });
  }
  /** @internal */
  onDisable() {
    this.context.removeCamera(this);
  }
  onLeaveXR(e) {
    this.fieldOfView = this._fov;
  }
  /** @internal */
  onBeforeRender() {
    if (this._cam && (this._frustum && this.updateFrustum(), this._clearFlags === 2 && this.applyClearFlagsIfIsActiveCamera(), this._targetTexture)) {
      this.context.isManagedExternally && (this._warnedAboutExternalRenderer || (this._warnedAboutExternalRenderer = !0, console.warn("Rendering with external renderer is not supported yet. This may not work or throw errors. Please remove the the target texture from your camera: " + this.name, this.targetTexture))), this.context.composer;
      const e = this.context.renderer;
      if (e) {
        const t = this.context.mainCameraComponent;
        this.applyClearFlags(), this._targetTexture.render(this.context.scene, this._cam, e), t?.applyClearFlags();
      }
    }
  }
  /** 
   * Creates a three.js camera object if it doesn't exist yet and sets its properties.
   * This is called internally when accessing the {@link threeCamera} property.
   */
  buildCamera() {
    if (this._cam) return;
    const e = this.gameObject.isCamera;
    let t = null;
    if (e ? (t = this.gameObject, t?.layers.enableAll(), t instanceof de && (this._fov = t.fov)) : t = this.gameObject.children[0], t && t.isCamera)
      t instanceof de && (this._fov && (t.fov = this._fov), t.near = this._nearClipPlane, t.far = this._farClipPlane, t.updateProjectionMatrix());
    else if (!this.orthographic)
      t = new de(this.fieldOfView, window.innerWidth / window.innerHeight, this._nearClipPlane, this._farClipPlane), this.fieldOfView && (t.fov = this.fieldOfView), this.gameObject.add(t);
    else {
      const i = this.orthographicSize * 100;
      t = new zd(window.innerWidth / -i, window.innerWidth / i, window.innerHeight / i, window.innerHeight / -i, this._nearClipPlane, this._farClipPlane), this.gameObject.add(t);
    }
    this._cam = t, this._cam.layers.mask = this._cullingMask, this.tag == "MainCamera" && this.context.setCurrentCamera(this);
  }
  /**
   * Applies clear flags if this is the active main camera.
   * @param opts Options for applying clear flags
   */
  applyClearFlagsIfIsActiveCamera(e) {
    this.context.mainCameraComponent === this && this.applyClearFlags(e);
  }
  /**
   * Applies this camera's clear flags and related settings to the renderer.
   * This controls how the background is rendered (skybox, solid color, transparent).
   * @param opts Options for applying clear flags
   */
  applyClearFlags(e) {
    if (!this._cam) {
      Xs && console.log("Camera does not exist (apply clear flags)");
      return;
    }
    if (this.fieldOfView = this.fieldOfView, Xs) {
      const i = `[Camera] Apply ClearFlags: ${ha[this._clearFlags]} - "${this.name}"`;
      console.debug(i);
    }
    const t = this.context.domElement.getAttribute("background-image") || this.context.domElement.getAttribute("background-color");
    switch (this._clearFlags) {
      case 0:
        return;
      case 1:
        if (Il.backgroundShouldBeTransparent(this.context) && (!this.ARBackgroundAlpha || this.ARBackgroundAlpha < 1e-3)) {
          this.context.scene.background = null, this.context.renderer.setClearColor(0, 0);
          return;
        }
        (!this.scene.background || !this._skybox || e?.applySkybox === !0) && this.applySceneSkybox(), this._backgroundBlurriness !== void 0 && !this.context.domElement.getAttribute("background-blurriness") ? this.context.scene.backgroundBlurriness = this._backgroundBlurriness : Xs && console.warn(`Camera "${this.name}" has no background blurriness`), this._backgroundIntensity !== void 0 && !this.context.domElement.getAttribute("background-intensity") && (this.context.scene.backgroundIntensity = this._backgroundIntensity), this._backgroundRotation !== void 0 && !this.context.domElement.getAttribute("background-rotation") ? this.context.scene.backgroundRotation = this._backgroundRotation : Xs && console.warn(`Camera "${this.name}" has no background intensity`);
        break;
      case 2:
        if (this._backgroundColor && !t) {
          let i = this._backgroundColor.alpha;
          Il.backgroundShouldBeTransparent(this.context) && (i = this.ARBackgroundAlpha ?? 0), this.context.scene.background = null, this.context.xr?.isVR ? this.context.renderer.setClearColor(HC(this._backgroundColor).convertLinearToSRGB()) : this.context.renderer.setClearColor(this._backgroundColor, i);
        } else this._backgroundColor || Xs && console.warn(`[Camera] has no background color "${this.name}" `);
        break;
      case 4:
        t || (this.context.scene.background = null, this.context.renderer.setClearColor(0, 0));
        break;
    }
  }
  /**
   * Applies the skybox texture to the scene background.
   */
  applySceneSkybox() {
    this._skybox || (this._skybox = new Ak(this)), this._skybox.apply();
  }
  /**
   * Determines if the background should be transparent when in passthrough AR mode.
   * 
   * @param context The current rendering context
   * @returns {boolean} True when in XR on a pass through device where the background should be invisible
   */
  static backgroundShouldBeTransparent(e) {
    const t = e.renderer.xr?.getSession();
    if (!t) return !1;
    if (typeof t._transparent == "boolean")
      return t._transparent;
    const i = t.environmentBlendMode;
    Xs && Be("Environment blend mode: " + i + " on " + navigator.userAgent);
    let n = i === "additive" || i === "alpha-blend";
    return e.isInAR && i === "opaque" && (navigator.userAgent?.includes("OculusBrowser") || navigator.userAgent?.includes("Mozilla") && navigator.userAgent?.includes("Mobile WebXRViewer/v2")) && (n = !0), t._transparent = n, n;
  }
};
qt([
  u()
], Dt.prototype, "aspect", 1);
qt([
  u()
], Dt.prototype, "fieldOfView", 1);
qt([
  u()
], Dt.prototype, "nearClipPlane", 1);
qt([
  u()
], Dt.prototype, "farClipPlane", 1);
qt([
  u()
], Dt.prototype, "clearFlags", 1);
qt([
  u()
], Dt.prototype, "orthographic", 2);
qt([
  u()
], Dt.prototype, "orthographicSize", 2);
qt([
  u()
], Dt.prototype, "ARBackgroundAlpha", 2);
qt([
  u()
], Dt.prototype, "cullingMask", 1);
qt([
  u()
], Dt.prototype, "backgroundBlurriness", 1);
qt([
  u()
], Dt.prototype, "backgroundIntensity", 1);
qt([
  u(ot)
], Dt.prototype, "backgroundRotation", 1);
qt([
  u()
], Dt.prototype, "environmentIntensity", 1);
qt([
  u(oe)
], Dt.prototype, "backgroundColor", 1);
qt([
  u(ps)
], Dt.prototype, "targetTexture", 1);
let yi = Dt;
class Ak {
  _camera;
  _skybox;
  get context() {
    return this._camera?.context;
  }
  constructor(e) {
    this._camera = e;
  }
  /**
   * Applies the skybox texture to the scene background.
   * Retrieves the texture based on the camera's source ID.
   */
  apply() {
    if (this._skybox = this.context.lightmaps.tryGetSkybox(this._camera.sourceId), !this._skybox)
      this._did_log_failed_to_find_skybox || (this._did_log_failed_to_find_skybox = !0, console.warn(`Camera "${this._camera.name}" has no skybox texture. ${this._camera.sourceId}`));
    else if (this.context.scene.background !== this._skybox) {
      const e = this.context.domElement.getAttribute("background-image") || this.context.domElement.getAttribute("background-color");
      Xs && console.debug(`[Camera] Apply Skybox ${this._skybox?.name} ${e} - "${this._camera.name}"`), e?.length || (this._skybox.mapping = _s, this.context.scene.background = this._skybox);
    }
  }
}
function Ik(s) {
  w("freecam") && s.context.mainCameraComponent === s && S.getOrAddComponent(s.gameObject, ye);
}
class to extends R {
  /**
   * Gets the existing Three.js {@link three#AudioListener} instance or creates a new one if it doesn't exist.
   * This listener is responsible for capturing audio in the 3D scene.
   * @returns The {@link three#AudioListener} instance
   */
  get listener() {
    return this._listener == null && (this._listener = new Ox()), this._listener;
  }
  _listener = null;
  /**
   * Registers for interaction events and initializes the audio listener
   * when this component is enabled.
   * @internal
   */
  onEnable() {
    Fn.registerWaitForInteraction(this.onInteraction), this.addListenerIfItExists();
  }
  /**
   * Cleans up event registrations and removes the audio listener
   * when this component is disabled.
   * @internal
   */
  onDisable() {
    Fn.unregisterWaitForInteraction(this.onInteraction), this.removeListenerIfItExists();
  }
  onInteraction = () => {
    this.destroyed || this.listener == null || this.addListenerIfItExists();
  };
  addListenerIfItExists() {
    const e = this._listener;
    if (!e || e?.parent) return;
    const t = this.context.mainCameraComponent || S.getComponentInParent(this.gameObject, yi);
    t?.threeCamera ? t.threeCamera.add(e) : this.gameObject.add(e), e.filter ? (e.gain.connect(e.filter), e.filter.connect(e.context.destination)) : e.gain.connect(e.context.destination);
  }
  removeListenerIfItExists() {
    const e = this._listener;
    e && (e.removeFromParent(), e.filter && e.filter.disconnect(), e.gain && e.gain.disconnect());
  }
}
var Lk = Object.defineProperty, Dk = Object.getOwnPropertyDescriptor, fn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? Dk(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && Lk(e, t, n), n;
};
const vt = w("debugaudio"), Ji = class Qs extends R {
  /**
   * Checks if the user has interacted with the page to allow audio playback.
   * Audio playback often requires a user gesture first due to browser autoplay policies.
   * This is the same as calling {@link Application.userInteractionRegistered}.
   * 
   * @returns Whether user interaction has been registered to allow audio playback
   */
  static get userInteractionRegistered() {
    return Fn.userInteractionRegistered;
  }
  /**
   * Registers a callback that will be executed once the user has interacted with the page,
   * allowing audio playback to begin.
   * This is the same as calling {@link Application.registerWaitForInteraction}.
   * 
   * @param cb - The callback function to execute when user interaction is registered
   */
  static registerWaitForAllowAudio(e) {
    Fn.registerWaitForInteraction(e);
  }
  clip = "";
  playOnAwake = !1;
  preload = !0;
  playInBackground = !0;
  /**
   * Indicates whether the audio is currently playing.
   * 
   * @returns True if the audio is playing, false otherwise
   */
  get isPlaying() {
    return this.sound?.isPlaying ?? !1;
  }
  /**
   * The total duration of the current audio clip in seconds.
   * 
   * @returns Duration in seconds or undefined if no clip is loaded
   */
  get duration() {
    return this.sound?.buffer?.duration;
  }
  /**
   * The current playback position as a normalized value between 0 and 1.
   * Can be set to seek to a specific position in the audio.
   */
  get time01() {
    const e = this.duration;
    return e && this.sound ? this.sound?.context.currentTime / e : 0;
  }
  set time01(e) {
    const t = this.duration;
    t && this.sound && (this.time = e * t);
  }
  /**
   * The current playback position in seconds.
   * Can be set to seek to a specific time in the audio.
   */
  get time() {
    return this.sound?.source ? this.sound.source?.context.currentTime - this._lastContextTime + this.sound.offset : 0;
  }
  set time(e) {
    if (this.sound) {
      if (e === this.sound.offset) return;
      const t = this.isPlaying;
      this.stop(), this.sound.offset = e, t && this.play();
    }
  }
  get loop() {
    return this.sound && (this._loop = this.sound.getLoop()), this._loop;
  }
  set loop(e) {
    this._loop = e, this.sound && this.sound.setLoop(e);
  }
  get spatialBlend() {
    return this._spatialBlend;
  }
  set spatialBlend(e) {
    e !== this._spatialBlend && (this._spatialBlend = e, this._needUpdateSpatialDistanceSettings = !0);
  }
  get minDistance() {
    return this._minDistance;
  }
  set minDistance(e) {
    this._minDistance !== e && (this._minDistance = e, this._needUpdateSpatialDistanceSettings = !0);
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set maxDistance(e) {
    this._maxDistance !== e && (this._maxDistance = e, this._needUpdateSpatialDistanceSettings = !0);
  }
  _spatialBlend = 0;
  _minDistance = 1;
  _maxDistance = 100;
  get volume() {
    return this._volume;
  }
  set volume(e) {
    this._volume = e, this.sound && !this.context.application.muted && (vt && console.log(this.name, "audio set volume", e), this.sound.setVolume(e));
  }
  _volume = 1;
  set pitch(e) {
    this.sound && this.sound.setPlaybackRate(e);
  }
  get pitch() {
    return this.sound ? this.sound.getPlaybackRate() : 1;
  }
  rollOffMode = 0;
  _loop = !1;
  sound = null;
  helper = null;
  wasPlaying = !1;
  audioLoader = null;
  shouldPlay = !1;
  // set this from audio context time, used to set clip offset when setting "time" property
  // there is maybe a better way to set a audio clip current time?!
  _lastClipStartedLoading = null;
  _audioElement = null;
  /**
   * Returns the underlying {@link PositionalAudio} object, creating it if necessary.
   * The audio source needs a user interaction to be initialized due to browser autoplay policies.
   * 
   * @returns The three.js PositionalAudio object or null if unavailable
   */
  get Sound() {
    if (!this.sound && Qs.userInteractionRegistered) {
      let e = this.gameObject.getComponent(to) ?? this.context.mainCamera.getComponent(to) ?? su(to, this.context, !1);
      !e && this.context.mainCamera && (e = this.context.mainCamera.addComponent(to)), e?.listener ? (this.sound = new kx(e.listener), this.gameObject?.add(this.sound)) : vt && console.warn("No audio listener found in scene - can not play audio");
    }
    return this.sound;
  }
  // This is a hacky workaround to get the PositionalAudio behave like a 2D audio source
  // private _listener: AudioListener | null = null;
  // private _originalSoundMatrixWorldFunction: Function | null = null;
  // private _onSoundMatrixWorld = (force: boolean) => {
  //     if (this._spatialBlend > .05) {
  //         if (this._originalSoundMatrixWorldFunction) {
  //             this._originalSoundMatrixWorldFunction.call(this.sound, force);
  //         }
  //     }
  //     else {
  //         // we use another object's matrix world function (but bound to the positional audio)
  //         // this is just a little trick to prevent calling the PositionalAudio's updateMatrixWorld function
  //         this.gameObject.updateMatrixWorld?.call(this.sound, force);
  //         if (this.sound && this._listener) {
  //             this.sound.gain.connect(this._listener.listener.getInput());
  //             // const pos = getTempVector().setFromMatrixPosition(this._listener.gameObject.matrixWorld);
  //             // const ctx = this.sound.context;
  //             // const delay = this._listener.listener.timeDelta;
  //             // const time = ctx.currentTime ;
  //             // this.sound.panner.positionX.setValueAtTime(pos.x, time);
  //             // this.sound.panner.positionY.setValueAtTime(pos.y, time);
  //             // this.sound.panner.positionZ.setValueAtTime(pos.z, time);
  //             // this.sound.panner.orientationX.setValueAtTime(0, time);
  //             // this.sound.panner.orientationY.setValueAtTime(0, time);
  //             // this.sound.panner.orientationZ.setValueAtTime(-1, time);
  //         }
  //     }
  // }
  /**
   * Indicates whether the audio source is queued to play when possible.
   * This may be true before user interaction has been registered.
   * 
   * @returns Whether the audio source intends to play
   */
  get ShouldPlay() {
    return this.shouldPlay;
  }
  /**
   * Returns the Web Audio API context associated with this audio source.
   * 
   * @returns The {@link AudioContext} or null if not available
   */
  get audioContext() {
    return this.sound?.context;
  }
  /** @internal */
  awake() {
    vt && console.log("[AudioSource]", this), this.audioLoader = new mp(), this.playOnAwake && (this.shouldPlay = !0), this.preload && typeof this.clip == "string" && this.audioLoader.load(this.clip, this.createAudio, () => {
    }, console.error);
  }
  /** @internal */
  onEnable() {
    this.sound && this.gameObject.add(this.sound), Qs.userInteractionRegistered ? this.playOnAwake && this.context.application.isVisible && this.play() : Qs.registerWaitForAllowAudio(() => {
      this.enabled && !this.destroyed && this.shouldPlay && this.onNewClip(this.clip);
    }), globalThis.addEventListener("visibilitychange", this.onVisibilityChanged), this.context.application.addEventListener(Cp.MuteChanged, this.onApplicationMuteChanged);
  }
  /** @internal */
  onDisable() {
    globalThis.removeEventListener("visibilitychange", this.onVisibilityChanged), this.context.application.removeEventListener(Cp.MuteChanged, this.onApplicationMuteChanged), this.pause();
  }
  onVisibilityChanged = () => {
    switch (document.visibilityState) {
      case "hidden":
        (this.playInBackground === !1 || q.isMobileDevice()) && (this.wasPlaying = this.isPlaying, this.isPlaying && this.pause());
        break;
      case "visible":
        vt && console.log("visible", this.enabled, this.playOnAwake, !this.isPlaying, Qs.userInteractionRegistered, this.wasPlaying), this.enabled && this.playOnAwake && !this.isPlaying && Qs.userInteractionRegistered && this.wasPlaying && this.play();
        break;
    }
  };
  onApplicationMuteChanged = () => {
    this.context.application.muted ? this.sound?.setVolume(0) : this.sound?.setVolume(this.volume);
  };
  createAudio = (e) => {
    if (this.destroyed) {
      vt && console.warn("AudioSource destroyed, not creating audio", this.name);
      return;
    }
    vt && console.log("AudioBuffer finished loading", e);
    const t = this.Sound;
    if (!t) {
      vt && console.warn("Failed getting sound?", this.name);
      return;
    }
    t.isPlaying && t.stop(), e && t.setBuffer(e), t.loop = this._loop, this.context.application.muted ? t.setVolume(0) : t.setVolume(this.volume), t.autoplay = this.shouldPlay && Qs.userInteractionRegistered, this.applySpatialDistanceSettings(), t.isPlaying && t.stop(), Qs.registerWaitForAllowAudio(this.__onAllowAudioCallback);
  };
  __onAllowAudioCallback = () => {
    this.shouldPlay && this.play();
  };
  applySpatialDistanceSettings() {
    const e = this.sound;
    if (!e) return;
    this._needUpdateSpatialDistanceSettings = !1;
    const t = j.lerp(10 * this._maxDistance / Math.max(1e-4, this.spatialBlend), this._minDistance, this.spatialBlend);
    switch (vt && console.log(this.name, this._minDistance, this._maxDistance, this.spatialBlend, "Ref distance=" + t), e.setRefDistance(t), e.setMaxDistance(Math.max(0.01, this._maxDistance)), this.rollOffMode) {
      case 0:
        e.setDistanceModel("exponential");
        break;
      case 1:
        e.setDistanceModel("linear");
        break;
      case 2:
        console.warn("Custom rolloff for AudioSource is not supported: " + this.name);
        break;
    }
    this.spatialBlend > 0 ? vt && !this.helper && (this.helper = new AS(e, e.getRefDistance()), e.add(this.helper)) : this.helper && this.helper.parent && this.helper.removeFromParent();
  }
  async onNewClip(e) {
    if (e && (this.clip = e), typeof e == "string")
      if (vt && console.log(e), e.endsWith(".mp3") || e.endsWith(".wav")) {
        if (this.audioLoader || (this.audioLoader = new mp()), this.shouldPlay = !0, this._lastClipStartedLoading === e) {
          vt && console.log("Is currently loading:", this._lastClipStartedLoading, this);
          return;
        }
        this._lastClipStartedLoading = e, vt && console.log("load audio", e);
        const t = await this.audioLoader.loadAsync(e).catch(console.error);
        if (this.destroyed) return;
        this._lastClipStartedLoading === e && (this._lastClipStartedLoading = null), t && this.createAudio(t);
      } else console.warn("Unsupported audio clip type", e);
    else
      this.shouldPlay = !0, this.createAudio();
  }
  /**
   * Plays the audio clip or media stream.
   * If no argument is provided, plays the currently assigned clip.
   * 
   * @param clip - Optional audio clip or {@link MediaStream} to play
   */
  play(e = void 0) {
    !e && this.clip && (e = this.clip), e !== void 0 && typeof e != "string" && !(e instanceof MediaStream) && (L() && console.warn("Called play on AudioSource with unknown argument type:", e + `
Using the assigned clip instead:`, this.clip), e = this.clip);
    let t = !this.sound || e && e !== this.clip;
    if (typeof e == "string" && !this.audioLoader && (t = !0), (e instanceof MediaStream || typeof e == "string") && (this.clip = e), t) {
      this.shouldPlay = !0, this.onNewClip(e);
      return;
    }
    if (this.shouldPlay = !0, this._hasEnded = !1, vt && console.log("play", this.sound?.getVolume(), this.sound), this.sound && !this.sound.isPlaying) {
      const i = this.context.application.muted;
      i && this.sound.setVolume(0), this.gameObject?.add(this.sound), this.clip instanceof MediaStream ? (this.sound.setMediaStreamSource(this.clip), this._audioElement || (this._audioElement = document.createElement("audio"), this._audioElement.style.display = "none"), this._audioElement.parentNode || this.context.domElement.shadowRoot?.append(this._audioElement), this._audioElement.srcObject = this.clip, this._audioElement.autoplay = !1) : (this._audioElement && this._audioElement.remove(), this.sound.play(i ? 0.1 : 0));
    }
  }
  /**
   * Pauses audio playback while maintaining the current position.
   * Use play() to resume from the paused position.
   */
  pause() {
    vt && console.log("Pause", this), this._hasEnded = !0, this.shouldPlay = !1, this.sound && this.sound.isPlaying && this.sound.source && (this._lastContextTime = this.sound?.context.currentTime, this.sound.pause()), this._audioElement?.remove();
  }
  /**
   * Stops audio playback completely and resets the playback position to the beginning.
   * Unlike pause(), calling play() after stop() will start from the beginning.
   */
  stop() {
    vt && console.log("Pause", this), this._hasEnded = !0, this.shouldPlay = !1, this.sound && this.sound.source && (this._lastContextTime = this.sound?.context.currentTime, vt && console.log(this._lastContextTime), this.sound.stop()), this._audioElement?.remove();
  }
  _lastContextTime = 0;
  _hasEnded = !0;
  _needUpdateSpatialDistanceSettings = !1;
  /** @internal */
  update() {
    this.helper && (this.isPlaying && this.helper.update(), this.helper.visible = this.isPlaying), this._needUpdateSpatialDistanceSettings && this.applySpatialDistanceSettings(), this.sound && !this.sound.isPlaying && this.shouldPlay && !this._hasEnded && (this._hasEnded = !0, vt && console.log("Audio clip ended", this.clip), this.dispatchEvent(new CustomEvent("ended", { detail: this })));
  }
};
fn([
  u(URL)
], Ji.prototype, "clip", 2);
fn([
  u()
], Ji.prototype, "playOnAwake", 2);
fn([
  u()
], Ji.prototype, "preload", 2);
fn([
  u()
], Ji.prototype, "playInBackground", 2);
fn([
  u()
], Ji.prototype, "loop", 1);
fn([
  u()
], Ji.prototype, "spatialBlend", 1);
fn([
  u()
], Ji.prototype, "minDistance", 1);
fn([
  u()
], Ji.prototype, "maxDistance", 1);
fn([
  u()
], Ji.prototype, "volume", 1);
fn([
  u()
], Ji.prototype, "pitch", 1);
fn([
  u()
], Ji.prototype, "rollOffMode", 2);
let Xi = Ji;
const jk = w("debugavatar");
class je extends R {
  static getAvatar(e) {
    return e >= 0 && e < je.instances.length ? je.instances[e] : null;
  }
  static instances = [];
  static onAvatarMarkerCreated(e) {
    return je._onNewAvatarMarkerAdded.push(e), e;
  }
  static onAvatarMarkerDestroyed(e) {
    return je._onAvatarMarkerDestroyed.push(e), e;
  }
  static _onNewAvatarMarkerAdded = [];
  static _onAvatarMarkerDestroyed = [];
  connectionId;
  avatar;
  awake() {
    je.instances.push(this), jk && console.log(this);
    for (const e of je._onNewAvatarMarkerAdded)
      e({ avatarMarker: this, gameObject: this.gameObject });
  }
  onDestroy() {
    je.instances.splice(je.instances.indexOf(this), 1);
    for (const e of je._onAvatarMarkerDestroyed)
      e({ avatarMarker: this, gameObject: this.gameObject });
  }
  isLocalAvatar() {
    return this.connectionId === this.context.connection.connectionId;
  }
}
class da {
  static Pois = [];
  static LastChangeTime = 0;
  static Add(e, t, i = null) {
    if (t) {
      for (const n of this.Pois)
        if (n.obj === t) return;
      this.Pois.push({ obj: t, avatar: i }), this.LastChangeTime = e.time.time;
    }
  }
  static Remove(e, t) {
    if (t) {
      for (const i of this.Pois)
        if (i.obj === t) {
          this.Pois.splice(this.Pois.indexOf(i), 1), this.LastChangeTime = e?.time.time ?? N.Current?.time.time;
          return;
        }
    }
  }
}
class Bk {
  guid;
  position = new y();
}
class Cd extends R {
  set controlledTarget(e) {
    this.target = e;
    const t = P.get("MoveRandom");
    if (t && this.target) {
      const i = S.getComponent(this.target, t);
      i && i.destroy();
    }
  }
  // that target to copy positions into
  target = null;
  avatar = null;
  _model = null;
  _targetModel = new Bk();
  _currentTargetObject = null;
  _lastUpdateTime = 0;
  _lookDuration = 0;
  _lastPoiChangedTime = 0;
  awake() {
    if (this.avatar = S.getComponentInParent(this.gameObject, je), this.avatar) {
      const e = S.getComponentInParent(this.gameObject, je);
      this._model = new b0(this.context.connection, this.guid), e?.isLocalAvatar && this._model.requestOwnership();
    }
    this.context.connection.beginListen("avatar-look-target-changed", (e) => {
      this.target && e && e.guid === this.avatar?.guid && Ot(this.target, e.position);
    });
  }
  update() {
    if ((!this.context.connection.isConnected || this._model?.hasOwnership) && (da.LastChangeTime !== this._lastPoiChangedTime && (this._lastPoiChangedTime = da.LastChangeTime, this._lookDuration = 0), this.selectTarget(), this._currentTargetObject && this.context.time.frameCount % 10 === 0 && this.target)) {
      const t = Z(this._currentTargetObject);
      Ot(this.target, t), this.context.connection.isConnected && this.avatar && (this.context.connection.send("avatar-look-target-changed", this._targetModel), this._targetModel.guid = this.avatar.guid, this._targetModel.position.copy(t));
    }
  }
  selectTarget() {
    if (this.context.time.time - this._lastUpdateTime > this._lookDuration) {
      this._lastUpdateTime = this.context.time.time, this._lookDuration = Math.random() * 0.5 + 0.2;
      const t = da.Pois;
      if (t.length > 0) {
        const i = t[Math.floor(Math.random() * t.length)];
        if (i && i.obj) {
          if (i.avatar && i.avatar === this.avatar) return;
          this._currentTargetObject = i.obj;
        }
      }
    }
  }
}
function Fk(s) {
  const e = s;
  return !!(e.parser && e.parser.json);
}
var lg = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.DontExport = 1] = "DontExport", s))(lg || {});
function zk(s) {
  return s && s.isComponent;
}
const EL = Symbol("object"), Af = new Hi(() => new y(), 20);
class Uk {
  _point;
  _normal;
  _tangentVelocity;
  /** the distance of the collision point */
  distance;
  /** the impulse velocity */
  impulse;
  friction;
  /** worldspace point */
  get point() {
    return Af.get().set(this._point.x, this._point.y, this._point.z);
  }
  /** worldspace normal */
  get normal() {
    return Af.get().set(this._normal.x, this._normal.y, this._normal.z);
  }
  /** worldspace tangent */
  get tangentVelocity() {
    return Af.get().set(this._tangentVelocity.x, this._tangentVelocity.y, this._tangentVelocity.z);
  }
  /** @internal */
  constructor(e, t, i, n, o, r) {
    this._point = e, this.distance = t, this._normal = i, this.impulse = n, this.friction = o, this._tangentVelocity = r;
  }
}
class Nk {
  /** The contact points of this collision. Contains information about positions, normals, distance, friction, impulse... */
  contacts;
  /** @internal */
  constructor(e, t, i) {
    this.me = e, this._collider = t, this._gameObject = t.gameObject, this.contacts = i;
  }
  /** the gameobject this collision event belongs to (e.g. if onCollisionEnter is called then `me` is the same as `this.gameObject`) */
  me;
  _collider;
  /** the other collider the collision happened with */
  get collider() {
    return this._collider;
  }
  _gameObject;
  /** the other object the collision happened with */
  get gameObject() {
    return this._gameObject;
  }
  /** the other rigidbody we hit, null if none attached */
  get rigidBody() {
    return this.collider?.attachedRigidbody;
  }
}
class $k {
  object;
  collider;
  constructor(e, t) {
    this.object = e, this.collider = t;
  }
}
const Le = w("debugnetworkingstreams");
var ms = /* @__PURE__ */ ((s) => (s.Connected = "peer-user-connected", s.StreamReceived = "receive-stream", s.StreamEnded = "call-ended", s.Disconnected = "peer-user-disconnected", s.UserJoined = "user-joined", s))(ms || {});
class av {
  type = "call-ended";
  userId;
  direction;
  constructor(e, t) {
    this.userId = e, this.direction = t;
  }
}
class Wk {
  type = "receive-stream";
  userId;
  stream;
  target;
  constructor(e, t, i) {
    this.userId = e, this.stream = t, this.target = i;
  }
}
class Vk {
  /** the peer handle id */
  guid;
  peerId;
  // internal so server doesnt save it to persistent storage
  dontSave = !0;
  constructor(e, t) {
    this.guid = e.id, this.peerId = t;
  }
}
var Hk = /* @__PURE__ */ ((s) => (s.Incoming = "incoming", s.Outgoing = "outgoing", s))(Hk || {});
class Gk extends Pm {
  peerId;
  userId;
  direction;
  call;
  get stream() {
    return this._stream;
  }
  _stream = null;
  _isDisposed = !1;
  close() {
    this._isDisposed || (this._isDisposed = !0, this.call.close(), gs(this._stream));
  }
  get isOpen() {
    return this.call.peerConnection?.connectionState === "connected";
  }
  get isOpening() {
    return this.call.peerConnection?.connectionState === "connecting";
  }
  get isClosed() {
    return !this.isOpen || this._isDisposed;
  }
  constructor(e, t, i, n = null) {
    super(), this.peerId = t.peer, this.userId = e, this.call = t, this.direction = i, this._stream = n, t.on("stream", (o) => {
      if (Le && console.log("Receive stream", `
Audio:`, o.getAudioTracks(), `
Video:`, o.getVideoTracks()), this._stream = o, i === "incoming") {
        const r = new Wk(e, o, this);
        this.dispatchEvent(r);
      }
    }), t.on("close", () => {
      this.dispatchEvent(new av(e, i));
    });
  }
}
function M_(s) {
  return s = s.replace("a=fmtp:111 minptime=10;useinbandfec=1", "a=fmtp:111 ptime=5;useinbandfec=1;stereo=1;maxplaybackrate=48000;maxaveragebitrat=128000;sprop-stereo=1"), s;
}
class io extends Pm {
  static instances = /* @__PURE__ */ new Map();
  static getOrCreate(e, t) {
    if (io.instances.has(t))
      return io.instances.get(t);
    const i = new io(e, t);
    return io.instances.set(t, i), i;
  }
  getMyPeerId() {
    if (this.context.connection.connectionId)
      return this.getPeerIdFromUserId(this.context.connection.connectionId);
  }
  getPeerIdFromUserId(e) {
    return this.id + "-" + e;
  }
  getUserIdFromPeerId(e) {
    return e.substring(this.id.length + 1);
  }
  makeCall(e, t) {
    if (!t?.id) {
      Le ? console.warn("Can not make a call: mediastream has no id or is undefined") : console.debug("Can not make a call: mediastream has no id or is undefined");
      return;
    }
    const i = {
      metadata: {
        userId: this.context.connection.connectionId,
        streamId: t.id
      },
      sdpTransform: (o) => M_(o)
    }, n = this._peer?.call(e, t, i);
    if (n) {
      const o = this.registerCall(n, "outgoing", t);
      return Le && console.warn(`📞 CALL ${e}`, `
Outgoing:`, this._outgoingCalls, `
Incoming:`, this._incomingCalls), o;
    } else Le && console.error("Failed to make call", e, t, this._peer);
  }
  closeAll() {
    for (const e of this._incomingCalls)
      e.close();
    for (const e of this._outgoingCalls)
      e.close();
    this.updateCalls();
  }
  updateCalls = () => {
    for (let e = this._incomingCalls.length - 1; e >= 0; e--) {
      const t = this._incomingCalls[e];
      t.isClosed && !t.isOpening && this._incomingCalls.splice(e, 1);
    }
    for (let e = this._outgoingCalls.length - 1; e >= 0; e--) {
      const t = this._outgoingCalls[e];
      let i = !1;
      t.isClosed && !t.isOpening && (t.stream?.active ? Le && console.warn("!!! Stream is still active, don't remove call", t.userId, "Your id: " + this.context.connection.connectionId) : (Le && console.warn("!!! Remove closed call", t.userId), i = !0)), this.context.connection.userIsInRoom(t.userId) === !1 && (Le && console.warn("!!! User is not in room anymore, remove call", t.userId), i = !0), i && (t.close(), this._outgoingCalls.splice(e, 1));
    }
  };
  get peer() {
    return this._peer;
  }
  get incomingCalls() {
    return this._incomingCalls;
  }
  id;
  context;
  _incomingCalls = [];
  _outgoingCalls = [];
  _peer;
  constructor(e, t) {
    super(), this.context = e, this.id = t, this.setupPeer();
    const i = Object.getOwnPropertyDescriptor(navigator, "getUserMedia")?.writable;
    try {
      i ? navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia : Le && console.warn("[PeerJs] getUserMedia is not writable");
    } catch (n) {
      Le && console.error("[PeerJs] Error setting getUserMedia", n);
    }
  }
  _enabled = !1;
  _enabledPeer = !1;
  onConnectRoomFn = this.onConnectRoom.bind(this);
  // private onUserJoinedOrLeftRoomFn: Function = this.onUserJoinedOrLeftRoom.bind(this);
  // private onPeerConnectFn: (id) => void = this.onPeerConnect.bind(this);
  // private onPeerReceiveCallFn: (call) => void = this.onPeerReceivingCall.bind(this);
  // private _connectionPeerIdMap : Map<string, string> = new Map();
  enable() {
    this._enabled || (this._enabled = !0, this.context.connection.beginListen(te.JoinedRoom, this.onConnectRoomFn), this.subscribePeerEvents());
  }
  disable() {
    this._enabled && (this._enabled = !1, this.context.connection.stopListen(te.JoinedRoom, this.onConnectRoomFn), this.unsubscribePeerEvents());
  }
  onConnectRoom() {
    this.setupPeer();
  }
  // private onUserJoinedOrLeftRoom(_: UserJoinedOrLeftRoomModel): void {
  // };
  setupPeer() {
    if (this.context.connection.connectionId && !this._enabledPeer) {
      if (this._enabledPeer = !0, !this._peer) {
        const e = this.getMyPeerId();
        e ? this._peer = D1(e) : console.error("Failed to setup peerjs because we dont have a connection id", this.context.connection.connectionId);
      }
      this._enabled && this.subscribePeerEvents();
    }
  }
  subscribePeerEvents() {
    this._peer && (this._peer.on("open", this.onPeerConnect), this._peer.on("close", this.onPeerClose), this._peer.on("call", this.onPeerReceivingCall), this._peer.on("disconnected", this.onPeerDisconnected), this._peer.on("error", this.onPeerError));
  }
  unsubscribePeerEvents() {
    this._peer && (this._peer.off("open", this.onPeerConnect), this._peer.off("close", this.onPeerClose), this._peer.off("call", this.onPeerReceivingCall), this._peer.off("disconnected", this.onPeerDisconnected), this._peer.off("error", this.onPeerError));
  }
  /**
   * Emitted when a connection to the PeerServer is established. You may use the peer before this is emitted, but messages to the server will be queued. id is the brokering ID of the peer (which was either provided in the constructor or assigned by the server).
   * @param id ID of the peer 
  */
  onPeerConnect = (e) => {
    if (Le && console.log("PEER opened as", e), e === null) {
      console.error("Peer connection failed", e);
      return;
    }
    this.context.connection.send("peer-user-connected", new Vk(this, e));
  };
  /** Emitted when the peer is destroyed and can no longer accept or create any new connections. At this time, the peer's connections will all be closed. */
  onPeerClose = () => {
    Le && console.log("PEER closed"), this.updateCalls();
  };
  /** Emitted when the peer is disconnected from the signalling server, either manually or because the connection to the signalling server was lost. */
  onPeerDisconnected = () => {
    Le && console.log("PEER disconnected"), this.updateCalls();
  };
  /**
   * Errors on the peer are almost always fatal and will destroy the peer. Errors from the underlying socket and PeerConnections are forwarded here.
   */
  onPeerError = (e) => {
    Le && console.error("PEER error", e);
  };
  onPeerReceivingCall = (e) => {
    e.answer(void 0, {
      sdpTransform: (t) => M_(t)
    }), this.registerCall(e, "incoming", null);
  };
  registerCall(e, t, i) {
    const n = e.metadata;
    (!n || !n.userId) && console.error("Missing call metadata", e);
    const o = n.userId;
    t === "incoming" && Le ? console.warn("← Receive call from", e.metadata, e.connectionId) : Le && console.warn("→ Make call to", e.metadata);
    const r = t === "incoming" ? this._incomingCalls : this._outgoingCalls, a = new Gk(o, e, t, i);
    return r.push(a), e.on("error", (l) => {
      console.error("Call error", l);
    }), e.on("close", () => {
      Le && console.log("Call ended", e.metadata);
      const l = r.indexOf(a);
      l !== -1 && r.splice(l, 1), a.close(), this.dispatchEvent(new av(o, t));
    }), a.addEventListener("call-ended", (l) => {
      this.dispatchEvent(l);
    }), t === "incoming" && (a.addEventListener("receive-stream", (l) => {
      this.dispatchEvent(l);
    }), e.on("stream", () => {
      Le && console.log("Received stream for call", e.metadata);
      let l = 0;
      const c = setInterval(() => {
        const h = l === 0;
        !a.isOpen && h && (Le && console.warn("Close call because stream is not active", e.metadata), l += 1, clearInterval(c), a.close());
      }, 2e3);
    })), a;
  }
  // private onRemotePeerConnect(user: PeerUserConnectedModel) {
  //     console.log("other user connected", user);
  // }
}
class hu extends Pm {
  /**
   * Create a new NetworkedStreams instance
   */
  static create(e, t) {
    const i = io.getOrCreate(e.context, t || e.context.connection.connectionId || e.guid);
    return new hu(e.context, i);
  }
  context;
  peer;
  // private _receiveVideoStreamListeners: Array<(info: IncomingStreamArgs) => void> = [];
  _sendingStreams = /* @__PURE__ */ new Map();
  /**
   * If true, will log debug information
   */
  debug = !1;
  constructor(e, t) {
    if (super(), zk(e)) {
      const i = e;
      e = i.context, t = io.getOrCreate(i.context, i.guid);
    } else typeof t == "string" && (t = io.getOrCreate(e, t));
    if (e) {
      if (!(e instanceof N)) throw new Error("Failed to create NetworkedStreams because context is not an instance of Context");
    } else throw new Error("Failed to create NetworkedStreams because context is undefined");
    if (!t) throw new Error("Failed to create NetworkedStreams because peer is undefined");
    this.context = e, this.peer = t, Le && (this.debug = !0);
  }
  startSendingStream(e) {
    this._sendingStreams.has(e) ? console.warn("Received start sending stream with stream that is already being sent") : (this._sendingStreams.set(e, []), this.updateSendingCalls());
  }
  stopSendingStream(e) {
    if (e) {
      const t = this._sendingStreams.get(e);
      if (t) {
        for (const i of t)
          i.close();
        t.length = 0;
      }
      this._sendingStreams.delete(e), t && this.debug && this.debugLogCurrentState();
    }
    this.updateSendingCalls();
  }
  // private onConnectRoomFn: Function = this.onConnectRoom.bind(this);
  // private onUserConnectedFn: Function = this.onUserConnected.bind(this);
  // private onUserLeftFn: Function = this.onUserLeft.bind(this);
  _enabled = !1;
  get enabled() {
    return this._enabled;
  }
  enable() {
    this._enabled || (this._enabled = !0, this.peer.enable(), this.peer.addEventListener("receive-stream", this.onCallStreamReceived), this.peer.addEventListener("call-ended", this.onCallEnded), this.context.connection.beginListen("peer-user-connected", this.onUserConnected), this.context.connection.beginListen(te.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(te.UserJoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(te.UserLeftRoom, this.onUserLeft), this.context.connection.beginListen(te.LeftRoom, this.onLeftRoom), this._tickIntervalId = setInterval(this.tick, 5e3));
  }
  disable() {
    this._enabled && (this._enabled = !1, this.peer.disable(), this.peer.removeEventListener("receive-stream", this.onCallStreamReceived), this.peer.removeEventListener("call-ended", this.onCallEnded), this.context.connection.stopListen("peer-user-connected", this.onUserConnected), this.context.connection.stopListen(te.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(te.UserJoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(te.UserLeftRoom, this.onUserLeft), this.context.connection.stopListen(te.LeftRoom, this.onLeftRoom), this._tickIntervalId != null && (clearInterval(this._tickIntervalId), this._tickIntervalId = void 0));
  }
  _tickIntervalId;
  /* for webpack */
  tick = () => {
    this.updateSendingCalls();
  };
  // private onUserJoinedPeer = (evt) => {
  //     if (!this.context.connection.isConnected && evt.userId) {
  //         this.startCallWithUserIfNotAlready(evt.userId);
  //     }
  // }
  // When either we ourselves OR someone else is joining the room we want to make sure to re-establish all calls
  // and if the user that joined is not yet receiving our video stream we want to start a stream with them
  // https://github.com/needle-tools/needle-tiny/issues/697#issuecomment-1510425539
  onJoinedRoom = (e) => {
    this._sendingStreams.size > 0 && (this.debug && console.warn(`${e?.userId ? `User ${e.userId}` : "You"} joined room`, e, this._sendingStreams.size), this.updateSendingCalls());
  };
  /** This is when the local user leaves the room */
  onLeftRoom = (e) => {
    this.debug && console.warn(`${e?.userId || "You"} left room`, e), this.stopCallsToUsersThatAreNotInTheRoomAnymore(), this.peer.closeAll();
  };
  onCallStreamReceived = (e) => {
    this.debug && console.log("Call with " + e.userId + " started"), this.dispatchEvent({ type: "receive-stream", target: this, stream: e.stream, userId: e.userId }), this.debug && this.debugLogCurrentState();
  };
  onCallEnded = (e) => {
    this.debug && console.log("Call with " + e.userId + " ended"), this.dispatchEvent(e), this.debug && this.debugLogCurrentState();
  };
  onUserConnected = (e) => {
    if (this.peer.id === e.guid) {
      this.debug && console.log("PEER USER CONNECTED", e.guid, e, this._sendingStreams.size);
      const t = this._sendingStreams.keys().next().value;
      this.peer.makeCall(e.peerId, t);
    } else
      Le && console.log("Unknown user connected", e.guid, e.peerId);
  };
  onUserLeft = (e) => {
    this.debug && console.log("User left room: " + e.userId), this.stopCallsToUsersThatAreNotInTheRoomAnymore();
  };
  updateSendingCalls() {
    const e = this.context.connection.connectionId;
    for (const t of this._sendingStreams.keys()) {
      const i = this._sendingStreams.get(t) || [];
      for (const n of this.context.connection.usersInRoom()) {
        if (n === e) continue;
        const o = this.peer.getPeerIdFromUserId(n);
        if (i.find((a) => a.peerId === o && a.direction === "outgoing" && !a.isClosed && a.stream?.active))
          Le && console.debug("Already have a call with user " + n + " / peer " + o);
        else {
          const a = this.peer.makeCall(o, t);
          a && i.push(a);
        }
      }
      this._sendingStreams.set(t, i);
    }
    this.stopCallsToUsersThatAreNotInTheRoomAnymore();
  }
  // private startCallWithUserIfNotAlready(userId: string) {
  //     for (const stream of this._sendingVideoStreams.keys()) {
  //         const calls = this._sendingVideoStreams.get(stream) || [];
  //         const existing = calls.find(c => c.userId === userId);
  //         if (!existing || existing.stream?.active === false) {
  //             if (this.debug) console.log("Starting call to", userId)
  //             const handle = this.peer.makeCall(this.peer.getPeerIdFromUserId(userId), stream);
  //             if (handle) {
  //                 calls.push(handle);
  //                 return true;
  //             }
  //         }
  //     }
  //     return false;
  // }
  stopCallsToUsersThatAreNotInTheRoomAnymore() {
    for (const e of this._sendingStreams.keys()) {
      const t = this._sendingStreams.get(e);
      if (t)
        for (let i = t.length - 1; i >= 0; i--) {
          const n = t[i];
          this.context.connection.userIsInRoom(n.userId) ? Le && (this.context.connection.connectionId === n.userId ? console.warn(`You are still in the room [${i}] ${n.userId}`) : console.log(`User is still in room [${i}] ${n.userId}`)) : (Le && console.log(`Remove call ${[i]} to user that is not in room anymore ${n.userId}`), n.close(), t.splice(i, 1));
        }
    }
    this.peer.updateCalls(), this.debug && this.debugLogCurrentState();
  }
  debugLogCurrentState() {
    console.warn(`You (${this.context.connection.connectionId}) are currently sending ${this._sendingStreams.size} and receiving ${this.peer.incomingCalls.length} calls (${this.peer.incomingCalls.map((e) => e.userId).join(", ")})`, this.peer.incomingCalls);
  }
  // const call = peer.call(peerId, stream);
}
function gs(s) {
  if (s && s instanceof MediaStream)
    for (const e of s.getTracks())
      e.stop();
}
var qk = Object.defineProperty, cg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && qk(e, t, n), n;
};
const Xk = "noVoip", Qk = w("debugvoip");
class wr extends R {
  autoConnect = !0;
  runInBackground = !0;
  createMenuButton = !0;
  /**
   * When enabled debug messages will be printed to the console. This is useful for debugging audio issues. You can also append ?debugvoip to the URL to enable this.
   */
  debug = !1;
  _net;
  _menubutton;
  /** @internal */
  awake() {
    Qk && (this.debug = !0), this.debug && (console.log("VOIP debugging: press 'v' to toggle mute or 'c' to toggle connect/disconnect"), window.addEventListener("keydown", async (e) => {
      switch (e.key.toLowerCase()) {
        case "v":
          console.log("MUTE?", !this.isMuted), this.setMuted(!this.isMuted);
          break;
        case "c":
          this.isSending ? this.disconnect() : this.connect();
          break;
      }
    }), window.addEventListener("blur", () => {
      console.log("VOIP: MUTE ON BLUR"), this.setMuted(!0);
    }), window.addEventListener("focus", () => {
      console.log("VOIP: UNMUTE ON FOCUS"), this.setMuted(!1);
    }));
  }
  /** @internal */
  onEnable() {
    this._net || (this._net = hu.create(this)), this.debug && (this._net.debug = !0), this._net.addEventListener(ms.StreamReceived, this.onReceiveStream), this._net.addEventListener(ms.StreamEnded, this.onStreamEnded), this._net.enable(), this.autoConnect && this.context.connection.isConnected && this.connect(), this.context.connection.beginListen(te.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(te.LeftRoom, this.onLeftRoom), this.onEnabledChanged(), this.updateButton(), window.addEventListener("visibilitychange", this.onVisibilityChanged);
  }
  /** @internal */
  onDisable() {
    this._net && (this._net.stopSendingStream(this._outputStream), this._net.removeEventListener(ms.StreamReceived, this.onReceiveStream), this._net.removeEventListener(ms.StreamEnded, this.onStreamEnded), this._net?.disable()), this.context.connection.stopListen(te.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(te.LeftRoom, this.onLeftRoom), this.onEnabledChanged(), this.updateButton(), window.removeEventListener("visibilitychange", this.onVisibilityChanged);
  }
  /** @internal */
  onDestroy() {
    this._menubutton?.remove(), this._menubutton = void 0;
  }
  /** Set via the mic button (e.g. when the websocket connection closes and rejoins but the user was muted before we don't want to enable VOIP again automatically) */
  _allowSending = !0;
  _outputStream = null;
  /**
   * @returns true if the component is currently sending audio
   */
  get isSending() {
    return this._outputStream != null && this._outputStream.active;
  }
  /** Start sending audio. */
  async connect(e) {
    if (!this._net)
      return console.error("Cannot connect to voice chat - NetworkedStreams not initialized. Make sure the component is enabled before calling this method."), !1;
    if (this.context.connection.isConnected) {
      if (!await q.microphonePermissionsGranted())
        return console.error("Cannot connect to voice chat - microphone permissions not granted"), this.updateButton(), !1;
    } else return console.error("Cannot connect to voice chat - not connected to server"), this.updateButton(), !1;
    return this._allowSending = !0, this._net?.stopSendingStream(this._outputStream), gs(this._outputStream), this._outputStream = await this.getAudioStream(e), this._outputStream ? (this.debug && console.log("VOIP: Got audio stream"), this._net?.startSendingStream(this._outputStream), this.updateButton(), !0) : (this.updateButton(), await q.microphonePermissionsGranted() ? console.error("VOIP: Could not get audio stream - please make sure to connect an audio device and grant microphone permissions") : Zd("Microphone permissions not granted: Please grant microphone permissions to use voice chat"), (this.debug || L()) && console.log("VOIP: Failed to get audio stream"), !1);
  }
  /** Stop sending audio (muting your own microphone) */
  disconnect(e) {
    e?.remember && (this._allowSending = !1), this._net?.stopSendingStream(this._outputStream), gs(this._outputStream), this._outputStream = null, this.updateButton();
  }
  /**
   * Mute or unmute the audio stream (this will only mute incoming streams and not mute your own microphone. Use disconnect() to mute your own microphone)
   */
  setMuted(e) {
    const t = this._outputStream?.getAudioTracks();
    if (t)
      for (const i of t)
        i.enabled = !e;
  }
  /** Returns true if the audio stream is currently muted */
  get isMuted() {
    if (this._outputStream === null) return !1;
    const e = this._outputStream?.getAudioTracks();
    if (e) {
      for (const t of e)
        if (!t.enabled) return !0;
    }
    return !1;
  }
  async updateButton() {
    if (this.createMenuButton) {
      if (this._menubutton || (this._menubutton = document.createElement("button"), this._menubutton.addEventListener("click", () => {
        this.isSending ? this.disconnect({ remember: !0 }) : this.connect(), q.microphonePermissionsGranted().then((e) => {
          e || ge("<strong>Microphone permissions not granted</strong>. Please allow your browser to use the microphone to be able to talk. Click on the button on the left side of your browser's address bar to allow microphone permissions.");
        });
      })), this._menubutton) {
        this.context.menu.appendChild(this._menubutton), this.activeAndEnabled ? this._menubutton.style.display = "" : this._menubutton.style.display = "none", this._menubutton.title = this.isSending ? "Click to disable your microphone" : "Click to enable your microphone";
        let e = (this.isSending, ""), t = this.isSending ? "mic" : "mic_off";
        await q.microphonePermissionsGranted() || (e = "No Permission", t = "mic_off", this._menubutton.title = "Microphone permissions not granted. Please allow your browser to use the microphone to be able to talk. This can usually be done in the addressbar of the webpage."), this._menubutton.innerText = e, this._menubutton.prepend(Et(t)), this.context.connection.isConnected == !1 ? this._menubutton.setAttribute("disabled", "") : this._menubutton.removeAttribute("disabled");
      }
    } else this.activeAndEnabled || this._menubutton?.remove();
  }
  // private _analyzer?: AudioAnalyser;
  /** @deprecated */
  getFrequency(e) {
    return this.unsupported_getfrequency || (this.unsupported_getfrequency = !0, L() && ge("VOIP: getFrequency is currently not supported"), console.warn("VOIP: getFrequency is currently not supported")), null;
  }
  async getAudioStream(e) {
    if (!navigator.mediaDevices.getUserMedia)
      return console.error("No getDisplayMedia support"), null;
    const t = async (n) => await navigator.mediaDevices.getUserMedia({ audio: n ?? !0, video: !1 }).catch((o) => (console.warn("VOIP failed getting audio stream", o), null)), i = await t(e);
    if (!i) return null;
    if (q.isiOS() && e?.deviceId === void 0) {
      const o = (await navigator.mediaDevices.enumerateDevices()).find((r) => (r.kind === "audioinput" || r.kind === "audiooutput") && !r.label.includes("iPhone"));
      if (o) {
        const r = Object.assign({}, e);
        return r.deviceId = o.deviceId, await t(r);
      }
    }
    return i;
  }
  // we have to wait for the user to connect to a room when "auto connect" is enabled
  onJoinedRoom = async () => {
    this.debug && console.log("VOIP: Joined room"), await Os(300), this.autoConnect && !this.isSending && this._allowSending && this.connect();
  };
  onLeftRoom = () => {
    this.debug && console.log("VOIP: Left room"), this.disconnect();
    for (const e of this._incomingStreams.values())
      gs(e.srcObject);
    this._incomingStreams.clear();
  };
  _incomingStreams = /* @__PURE__ */ new Map();
  onReceiveStream = (e) => {
    const t = e.target.userId, i = e.stream;
    let n = this._incomingStreams.get(t);
    n || (n = new Audio(), this._incomingStreams.set(t, n)), n.srcObject = i, n.setAttribute("autoplay", "true"), Fn.registerWaitForInteraction(() => {
      n?.play().catch((o) => {
        console.error("VOIP: Failed to play audio", o);
      });
    });
  };
  onStreamEnded = (e) => {
    const t = this._incomingStreams.get(e.userId);
    gs(t?.srcObject), this._incomingStreams.delete(e.userId);
  };
  onEnabledChanged = () => {
    for (const e of this._incomingStreams) {
      const t = e[1];
      t.muted = !this.enabled;
    }
  };
  onVisibilityChanged = () => {
    if (this.runInBackground) return;
    const t = !(document.visibilityState === "visible");
    this.setMuted(t);
    for (const i of this._incomingStreams) {
      const n = i[1];
      n.muted = t;
    }
  };
}
cg([
  u()
], wr.prototype, "autoConnect");
cg([
  u()
], wr.prototype, "runInBackground");
cg([
  u()
], wr.prototype, "createMenuButton");
var Yk = Object.defineProperty, lv = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Yk(e, t, n), n;
};
const Kk = w("debugmouth");
class du extends R {
  idle = [];
  talking = [];
  marker = null;
  voip = null;
  lastMouthChangeTime = 0;
  mouthChangeLength = 0;
  awake() {
    setTimeout(() => {
      this.voip = S.findObjectOfType(wr, this.context), this.marker || (this.marker = S.getComponentInParent(this.gameObject, je));
    }, 3e3);
  }
  update() {
    if (!this.voip || this.context.time.frameCount % 10 !== 0) return;
    let e = this.marker?.connectionId ?? null;
    if (!e) {
      Kk && (e = null);
      return;
    }
    const t = this.voip.getFrequency(e) ?? 0;
    this.updateLips(t);
  }
  updateLips(e) {
    if (this.context.time.time - this.lastMouthChangeTime > this.mouthChangeLength) {
      if (this.mouthChangeLength = 0.05 + Math.random() * 0.1, this.talking && this.talking.length > 0 && e > 30) {
        this.lastMouthChangeTime = this.context.time.time;
        const t = Math.floor(Math.random() * this.talking.length);
        this.setMouthShapeActive(this.talking, t);
      } else if (this.idle.length > 0 && this.context.time.time - this.lastMouthChangeTime > 0.5) {
        this.lastMouthChangeTime = this.context.time.time;
        const t = Math.floor(Math.random() * this.idle.length);
        this.setMouthShapeActive(this.idle, t);
      }
    }
  }
  setMouthShapeActive(e, t) {
    if (e) {
      e != this.idle ? this.idle.map((i) => i.visible = !1) : this.talking.map((i) => i.visible = !1);
      for (let i = 0; i < e.length; i++) {
        const n = e[i];
        n && (n.visible = i === t);
      }
    }
  }
  // private tryFindMouthShapes() {
  //     if (this.mouthShapes) return;
  //     this.mouthShapes = [];
  //     this.head?.traverse(o => {
  //         if (o && o.type === "Mesh") {
  //             if (o.name.lastIndexOf("mouth") > 0) {
  //                 this.mouthShapes.push(o as Mesh);
  //             }
  //         }
  //     });
  // }
}
lv([
  u(M)
], du.prototype, "idle");
lv([
  u(M)
], du.prototype, "talking");
class cv extends R {
  voip = null;
  marker = null;
  _startPosition = null;
  awake() {
    this.voip = S.findObjectOfType(wr, this.context), this.marker = S.getComponentInParent(this.gameObject, je);
  }
  update() {
    if (!this.voip || !this.marker || this.context.time.frameCount % 10 !== 0) return;
    const e = this.marker.connectionId, t = this.voip.getFrequency(e);
    if (t == null) return;
    this._startPosition || (this._startPosition = this.gameObject.position.clone());
    const i = t / 100;
    this.gameObject.position.y = this._startPosition.y + i * 0.07;
  }
}
var Zk = Object.defineProperty, Jk = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Zk(e, t, n), n;
};
const Hr = w("debugxrflags"), hv = w("disablexrflags");
hv && console.warn("XRFlags are disabled");
var fs = /* @__PURE__ */ ((s) => (s[s.Never = 0] = "Never", s[s.Browser = 1] = "Browser", s[s.AR = 2] = "AR", s[s.VR = 4] = "VR", s[s.FirstPerson = 8] = "FirstPerson", s[s.ThirdPerson = 16] = "ThirdPerson", s[s.All = 4294967295] = "All", s))(fs || {});
class ei {
  static Global = new ei();
  Mask = 17;
  Has(e) {
    return (this.Mask & e) !== 0;
  }
  Set(e) {
    Hr && console.warn("Set XR flag state to", e), this.Mask = e, rn.Apply();
  }
  Enable(e) {
    this.Mask |= e, rn.Apply();
  }
  Disable(e) {
    this.Mask &= ~e, rn.Apply();
  }
  Toggle(e) {
    this.Mask ^= e, rn.Apply();
  }
  EnableAll() {
    this.Mask = -1, rn.Apply();
  }
  DisableAll() {
    this.Mask = 0, rn.Apply();
  }
}
const dv = class ns extends R {
  static registry = [];
  static Apply() {
    for (const e of this.registry) e.UpdateVisible(ei.Global);
  }
  static firstApply;
  static buffer = new ei();
  visibleIn;
  awake() {
    ns.registry.push(this);
  }
  onEnable() {
    ns.firstApply ? this.UpdateVisible(ei.Global) : (ns.firstApply = !0, ns.Apply());
  }
  onDestroy() {
    const e = ns.registry.indexOf(this);
    e >= 0 && ns.registry.splice(e, 1);
  }
  get isOn() {
    return this.gameObject.visible;
  }
  UpdateVisible(e = null) {
    if (hv)
      return;
    let t;
    const i = e;
    if (i && typeof i == "number" && (console.assert(typeof i == "number", "XRFlag.UpdateVisible: state must be a number", i), Hr && console.log(i), ns.buffer.Mask = i, e = ns.buffer), e instanceof ei ? (Hr && console.warn(this.name, "use passed in mask", e.Mask, this.visibleIn), t = e.Has(this.visibleIn)) : (Hr && console.log(this.name, "use global mask"), ei.Global.Has(this.visibleIn)), t !== void 0)
      if (t)
        Hr && console.log(this.name, "is visible", this.gameObject.uuid), S.setActive(this.gameObject, !0);
      else {
        if (Hr && console.log(this.name, "is not visible", this.gameObject.uuid), !this.gameObject.visible) return;
        this.gameObject.visible = !1;
      }
  }
};
Jk([
  u()
], dv.prototype, "visibleIn");
let rn = dv;
var eM = Object.defineProperty, uu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && eM(e, t, n), n;
};
class Ba extends R {
  eyes = [];
  lastBlinkTime = 0;
  blinkLength = 0;
  eyesOpen = !0;
  state = null;
  awake() {
    this.state = S.getComponentInParent(this.gameObject, rn);
  }
  update() {
    if (!this.gameObject || !this.gameObject.visible || !this.eyes || !Array.isArray(this.eyes) || this.eyes.length === 0) return;
    if (this.context.time.time - this.lastBlinkTime > this.blinkLength) {
      if (this.lastBlinkTime = this.context.time.time, this.state && !this.state.isOn || !this.activeAndEnabled) return;
      if (this.eyesOpen = !this.eyesOpen, this.blinkLength = Math.random(), this.eyesOpen ? (this.blinkLength *= 3, this.blinkLength += 0.5, Math.random() < 0.1 && (this.blinkLength = 0.1 + Math.random() * 0.2)) : (this.blinkLength *= Math.random() * 0.2, this.blinkLength += 0.1), Math.random() < 0.1 && (this.blinkLength *= 3), this.blinkLength = Math.max(0.2, this.blinkLength), this.blinkLength = Math.min(3, this.blinkLength), this.eyes)
        for (const t of this.eyes)
          t && (t.visible = this.eyesOpen);
    }
  }
}
uu([
  u(M)
], Ba.prototype, "eyes");
uu([
  u()
], Ba.prototype, "lastBlinkTime");
uu([
  u()
], Ba.prototype, "blinkLength");
uu([
  u()
], Ba.prototype, "eyesOpen");
var tM = Object.defineProperty, hg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && tM(e, t, n), n;
};
const fu = class uv extends R {
  head = null;
  eyes = null;
  target = null;
  brain = null;
  awake() {
    this.brain || (this.brain = S.getComponentInParent(this.gameObject, Cd)), this.brain || (this.brain = S.addComponent(this.gameObject, Cd)), this.brain && this.target && (this.brain.controlledTarget = this.target);
  }
  vec = new y();
  static forward = new y(0, 0, 1);
  currentTargetPoint = new y();
  update() {
    const e = this.target;
    if (e && this.head) {
      const t = this.eyes;
      if (t) {
        const i = Z(e);
        this.currentTargetPoint.lerp(i, this.context.time.deltaTime / 0.1);
        const n = Z(this.head), o = this.vec.copy(this.currentTargetPoint).sub(n).normalize();
        if (o.length() < 0.1) return;
        const r = uv.forward;
        if (r.set(0, 0, 1), r.applyQuaternion(be(this.head)), r.dot(o) > 0.45)
          for (let l = 0; l < t.length; l++)
            t[l].lookAt(this.currentTargetPoint);
      }
    }
  }
};
hg([
  u(M)
], fu.prototype, "head");
hg([
  u(M)
], fu.prototype, "eyes");
hg([
  u(M)
], fu.prototype, "target");
let fv = fu;
var iM = Object.defineProperty, dg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && iM(e, t, n), n;
};
class Mc extends R {
  length = 1;
  depthTest = !0;
  isGizmo = !1;
  _axes = null;
  /**
   * Creates and adds the axes visualization to the scene when the component is enabled.
   * If marked as a gizmo, it will only be shown when gizmos are enabled in the global parameters.
   */
  onEnable() {
    if (this.isGizmo && !Sc) return;
    this._axes || (this._axes = new vi(this.length)), this._axes.layers.disableAll(), this._axes.layers.set(this.layer), this.gameObject.add(this._axes);
    const e = this._axes.material;
    e && e.depthTest !== void 0 && (e.depthTest = this.depthTest);
  }
  /**
   * Removes the axes visualization from the scene when the component is disabled.
   */
  onDisable() {
    this._axes && this.gameObject.remove(this._axes);
  }
}
dg([
  u()
], Mc.prototype, "length");
dg([
  u()
], Mc.prototype, "depthTest");
dg([
  u()
], Mc.prototype, "isGizmo");
class pv extends R {
  from;
  to;
  hint;
  desiredDistance = 1;
  onEnable() {
  }
  update() {
    if (!this.from || !this.to || !this.hint) return;
    const e = Z(this.to).clone(), t = Z(this.from).clone(), i = e.distanceTo(t), n = e.clone();
    n.sub(t);
    const o = t.clone();
    o.add(e), o.multiplyScalar(0.5);
    const r = Z(this.hint).clone();
    r.sub(o);
    const a = new y();
    a.crossVectors(r, n), a.crossVectors(n, a), a.normalize();
    const l = i * 0.5, c = Math.max(this.desiredDistance, l), h = Math.sqrt(c * c - l * l), d = a.clone();
    d.multiplyScalar(h), d.add(o), Ot(this.gameObject, d);
    const f = o.clone();
    f.sub(a), this.gameObject.lookAt(f);
  }
}
const nM = w("gizmos"), sM = w("debugboxhelper");
class Pt extends R {
  /** The bounding box for this component */
  box = null;
  static testBox = new bi();
  _lastMatrixUpdateFrame = -1;
  static _position = new y();
  static _size = new y(0.01, 0.01, 0.01);
  static _emptyObjectSize = new y(0.01, 0.01, 0.01);
  /**
   * Tests if an object intersects with this helper's bounding box
   * @param obj The object to test for intersection
   * @returns True if objects intersect, false if not, undefined if the provided object is invalid
   */
  isInBox(e) {
    if (!e) return;
    if (this.box || (this.box = new bi()), ii([e], void 0, void 0, Pt.testBox), Pt.testBox.isEmpty()) {
      const i = Z(e, Pt._position);
      Pt.testBox.setFromCenterAndSize(i, Pt._emptyObjectSize);
    }
    this.updateBox();
    const t = this.box?.intersectsBox(Pt.testBox);
    return t && sM && z.DrawWireBox3(Pt.testBox, 16711680, 5), t;
  }
  /**
   * Tests if this helper's bounding box intersects with another box
   * @param box The {@link Box3} to test for intersection
   * @returns True if boxes intersect, false otherwise
   */
  intersects(e) {
    return e ? this.updateBox(!1).intersectsBox(e) : !1;
  }
  /**
   * Updates the helper's bounding box based on the gameObject's position and scale
   * @param force Whether to force an update regardless of frame count
   * @returns The updated {@link Box3}
   */
  updateBox(e = !1) {
    if (this.box || (this.box = new bi()), e || this.context.time.frameCount != this._lastMatrixUpdateFrame) {
      const t = this._lastMatrixUpdateFrame < 0;
      this._lastMatrixUpdateFrame = this.context.time.frameCount;
      const i = t, n = Z(this.gameObject, Pt._position, i), o = Qe(this.gameObject, Pt._size);
      this.box.setFromCenterAndSize(n, o);
    }
    return this.box;
  }
  _helper = null;
  _color = null;
  awake() {
    this._helper = null, this._color = null, this.box = null;
  }
  /**
   * Creates and displays a visual wireframe representation of this box helper
   * @param col Optional color for the wireframe. If not provided, uses default color
   * @param force If true, shows the helper even if gizmos are disabled
   */
  showHelper(e = null, t = !1) {
    if (!(!nM && !t)) {
      if (this._helper) {
        e && this._color?.set(e), this.gameObject.add(this._helper);
        return;
      }
      this._helper = Wm(e), this.gameObject.add(this._helper);
    }
  }
}
var oM = Object.defineProperty, oi = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && oM(e, t, n), n;
};
class Ci extends R {
  /**
   * Identifies this component as a collider.
   * @internal
   */
  get isCollider() {
    return !0;
  }
  attachedRigidbody = null;
  isTrigger = !1;
  sharedMaterial;
  membership = [0];
  filter;
  /** @internal */
  awake() {
    super.awake(), this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(rt));
  }
  /** @internal */
  start() {
    this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(rt));
  }
  /** @internal */
  onEnable() {
    this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(rt));
  }
  /** @internal */
  onDisable() {
    this.context.physics.engine?.removeBody(this);
  }
  /**
   * Returns the underlying physics body from the physics engine.
   * Only available if the component is enabled and active in the scene.
   */
  get body() {
    return this.context.physics.engine?.getBody(this);
  }
  /**
   * Updates the collider's properties in the physics engine.
   * Use this when you've changed collider properties and need to sync with the physics engine.
   */
  updateProperties = () => {
    this.context.physics.engine?.updateProperties(this);
  };
  /**
   * Updates the physics material in the physics engine.
   * Call this after changing the sharedMaterial property.
   */
  updatePhysicsMaterial() {
    this.context.physics.engine?.updatePhysicsMaterial(this);
  }
}
oi([
  u(rt)
], Ci.prototype, "attachedRigidbody");
oi([
  u()
], Ci.prototype, "isTrigger");
oi([
  u()
], Ci.prototype, "sharedMaterial");
oi([
  u()
], Ci.prototype, "membership");
oi([
  u()
], Ci.prototype, "filter");
class Rc extends Ci {
  radius = 0.5;
  center = new y(0, 0, 0);
  /**
   * Registers the sphere collider with the physics engine and sets up scale change monitoring.
   */
  onEnable() {
    super.onEnable(), this.context.physics.engine?.addSphereCollider(this), Am(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Removes scale change monitoring when the collider is disabled.
   */
  onDisable() {
    super.onDisable(), Gb(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Updates collider properties when validated in the editor or inspector.
   */
  onValidate() {
    this.updateProperties();
  }
}
oi([
  Lt(),
  u()
], Rc.prototype, "radius");
oi([
  u(y)
], Rc.prototype, "center");
const ug = class mv extends Ci {
  /**
   * Creates and adds a BoxCollider to the given object.
   * @param obj The object to add the collider to
   * @param opts Configuration options for the collider and optional rigidbody
   * @returns The newly created BoxCollider
   */
  static add(e, t) {
    const i = An(e, mv);
    return i.autoFit(), t?.rigidbody === !0 && An(e, rt, { isKinematic: !1 }), i;
  }
  size = new y(1, 1, 1);
  center = new y(0, 0, 0);
  /**
   * Registers the box collider with the physics engine and sets up scale change monitoring.
   * @internal
   */
  onEnable() {
    super.onEnable(), this.context.physics.engine?.addBoxCollider(this, this.size), Am(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Removes scale change monitoring when the collider is disabled.
   * @internal
   */
  onDisable() {
    super.onDisable(), Gb(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Updates collider properties when validated in the editor or inspector.
   * @internal
   */
  onValidate() {
    this.updateProperties();
  }
  /**
   * Automatically fits the collider to the geometry of the object.
   * Sets the size and center based on the object's bounding box.
   * @param opts Options object with a debug flag to visualize the bounding box
   */
  autoFit(e) {
    const t = this.gameObject, i = t.position.clone(), n = t.quaternion.clone(), o = t.scale.clone(), r = t.parent;
    t.position.set(0, 0, 0), t.quaternion.set(0, 0, 0, 1), t.scale.set(1, 1, 1), t.parent = null, t.updateMatrix();
    const a = ii([t]);
    t.position.copy(i), t.quaternion.copy(n), t.scale.copy(o), t.parent = r, e?.debug === !0 && z.DrawWireBox3(a, 16768256, 20), this.size = a.getSize(new y()) || new y(1, 1, 1), this.center = a.getCenter(new y()) || new y(0, 0, 0), this.size.length() <= 0 && this.size.set(0.01, 0.01, 0.01);
  }
};
oi([
  Lt(),
  u(y)
], ug.prototype, "size");
oi([
  u(y)
], ug.prototype, "center");
let fg = ug;
class xr extends Ci {
  sharedMesh;
  convex = !1;
  /**
   * Creates and registers the mesh collider with the physics engine.
   * Handles both individual meshes and mesh groups.
   */
  onEnable() {
    if (super.onEnable(), !this.context.physics.engine) return;
    this.sharedMesh?.isMesh || (this.gameObject instanceof G || this.gameObject instanceof so) && (this.sharedMesh = this.gameObject);
    const e = 0;
    if (this.sharedMesh?.isMesh)
      this.context.physics.engine.addMeshCollider(this, this.sharedMesh, this.convex), We.assignMeshLOD(this.sharedMesh, e).then((t) => {
        t && this.activeAndEnabled && this.context.physics.engine && this.sharedMesh && (this.context.physics.engine.removeBody(this), this.sharedMesh.geometry = t, this.context.physics.engine.addMeshCollider(this, this.sharedMesh, this.convex));
      });
    else {
      const t = this.sharedMesh;
      if (t?.isGroup) {
        console.warn(`MeshCollider mesh is a group "${this.sharedMesh?.name || this.gameObject.name}", adding all children as colliders. This is currently not fully supported (colliders can not be removed from world again)`, this);
        const i = new Array();
        for (const n in t.children) {
          const o = t.children[n];
          o.isMesh && (this.context.physics.engine.addMeshCollider(this, o, this.convex), i.push(We.assignMeshLOD(o, e)));
        }
        Promise.all(i).then((n) => {
          if (n.some((r) => r) == !1) return;
          this.context.physics.engine?.removeBody(this);
          const o = new G();
          for (const r of n)
            r && this.activeAndEnabled && (o.geometry = r, this.context.physics.engine?.addMeshCollider(this, o, this.convex));
        });
      } else
        (L() || w("showcolliders")) && console.warn(`[MeshCollider] A MeshCollider mesh is assigned to an unknown object on "${this.gameObject.name}", but it's neither a Mesh nor a Group. Please double check that you attached the collider component to the right object and report a bug otherwise!`, this);
    }
  }
}
oi([
  u(G)
], xr.prototype, "sharedMesh");
oi([
  u()
], xr.prototype, "convex");
class po extends Ci {
  center = new y(0, 0, 0);
  radius = 0.5;
  height = 2;
  /**
   * Registers the capsule collider with the physics engine.
   */
  onEnable() {
    super.onEnable(), this.context.physics.engine?.addCapsuleCollider(this, this.height, this.radius);
  }
}
oi([
  u(y)
], po.prototype, "center");
oi([
  u()
], po.prototype, "radius");
oi([
  u()
], po.prototype, "height");
var rM = Object.defineProperty, Ts = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && rM(e, t, n), n;
};
const R_ = w("debugcharactercontroller");
class Fa extends R {
  center = new y(0, 0, 0);
  radius = 0.5;
  height = 2;
  _rigidbody = null;
  get rigidbody() {
    return this._rigidbody ? this._rigidbody : (this._rigidbody = this.gameObject.getComponent(rt), this._rigidbody || (this._rigidbody = this.gameObject.addComponent(rt)), this.rigidbody);
  }
  _activeGroundCollisions;
  awake() {
    this._activeGroundCollisions = /* @__PURE__ */ new Set();
  }
  onEnable() {
    const e = this.rigidbody;
    let t = this.gameObject.getComponent(po);
    t || (t = this.gameObject.addComponent(po)), t.center.copy(this.center), t.radius = this.radius, t.height = this.height;
    const i = new y(0, 0, 1), n = new y(1, 0, 0), o = new y(0, 1, 0), r = this.gameObject.getWorldDirection(new y());
    r.y = 0;
    const a = n.dot(r) < 0 ? -1 : 1, l = i.angleTo(r) * a;
    this.gameObject.setRotationFromAxisAngle(o, l), e.lockRotationX = !0, e.lockRotationY = !0, e.lockRotationZ = !0;
  }
  move(e) {
    this.gameObject.position.add(e);
  }
  onCollisionEnter(e) {
    (e.contacts.length == 0 || e.contacts.some((t) => t.normal.y > 0.2)) && (this._activeGroundCollisions.add(e), R_ && console.log(`Collision(${this._activeGroundCollisions.size}): ${e.contacts.map((t) => t.normal.y.toFixed(2)).join(", ")} - ${this.isGrounded}`));
  }
  onCollisionExit(e) {
    this._activeGroundCollisions.delete(e), R_ && console.log(`Collision(${this._activeGroundCollisions.size}) - ${this.isGrounded}`);
  }
  get isGrounded() {
    return this._activeGroundCollisions.size > 0;
  }
  _contactVelocity = new y();
  get contactVelocity() {
    this._contactVelocity.set(0, 0, 0);
    for (const e of this._activeGroundCollisions) {
      const t = this.context.physics.engine?.getLinearVelocity(e.collider);
      t && (this._contactVelocity.x += t.x, this._contactVelocity.y += t.y, this._contactVelocity.z += t.z);
    }
    return this._contactVelocity;
  }
}
Ts([
  u(y)
], Fa.prototype, "center");
Ts([
  u()
], Fa.prototype, "radius");
Ts([
  u()
], Fa.prototype, "height");
class _o extends R {
  controller;
  movementSpeed = 2;
  rotationSpeed = 2;
  jumpForce = 1;
  doubleJumpForce = 2;
  animator;
  lookForward = !0;
  awake() {
    this._currentRotation = new U();
  }
  update() {
    const e = this.context.input;
    e.isKeyPressed("KeyW") ? this.moveInput.y += 1 : e.isKeyPressed("KeyS") && (this.moveInput.y -= 1), e.isKeyPressed("KeyD") ? this.lookInput.x += 1 : e.isKeyPressed("KeyA") && (this.lookInput.x -= 1), this.jumpInput ||= e.isKeyDown("Space");
  }
  move(e) {
    this.moveInput.add(e);
  }
  look(e) {
    this.lookInput.add(e);
  }
  jump() {
    this.jumpInput = !0;
  }
  lookInput = new J(0, 0);
  moveInput = new J(0, 0);
  jumpInput = !1;
  onBeforeRender() {
    this.handleInput(this.moveInput, this.lookInput, this.jumpInput), this.lookInput.set(0, 0), this.moveInput.set(0, 0), this.jumpInput = !1;
  }
  _currentSpeed = new y(0, 0, 0);
  _currentAngularSpeed = new y(0, 0, 0);
  _temp = new y(0, 0, 0);
  _jumpCount = 0;
  _currentRotation;
  handleInput(e, t, i) {
    if (this.controller?.isGrounded && (this._jumpCount = 0, this.doubleJumpForce > 0 && this.animator?.setBool("doubleJump", !1)), this._currentSpeed.z += e.y * this.movementSpeed * this.context.time.deltaTime, this.animator?.setBool("running", e.length() > 0.01), this.animator?.setBool("jumping", this.controller?.isGrounded === !0 && i), this._temp.copy(this._currentSpeed), this._temp.applyQuaternion(this.gameObject.quaternion), this.controller ? this.controller.move(this._temp) : this.gameObject.position.add(this._temp), this._currentAngularSpeed.y += j.toRadians(-t.x * this.rotationSpeed) * this.context.time.deltaTime, this.lookForward && Math.abs(this._currentAngularSpeed.y) < 0.01) {
      const n = this.context.mainCameraComponent.forward;
      n.y = 0, n.normalize(), this._currentRotation.setFromUnitVectors(new y(0, 0, 1), n), this.gameObject.quaternion.slerp(this._currentRotation, this.context.time.deltaTime * 10);
    }
    if (this.gameObject.rotateY(this._currentAngularSpeed.y), this._currentSpeed.multiplyScalar(1 - this.context.time.deltaTime * 10), this._currentAngularSpeed.y *= 1 - this.context.time.deltaTime * 10, this.controller && i && this.jumpForce > 0) {
      let n = this.controller?.isGrounded;
      if (this.doubleJumpForce > 0 && !this.controller?.isGrounded && this._jumpCount === 1 && (n = !0, this.animator?.setBool("doubleJump", !0)), n) {
        this._jumpCount += 1;
        const o = this.controller.rigidbody, r = this._jumpCount === 2 ? this.doubleJumpForce : this.jumpForce;
        o.applyImpulse(new y(0, 1, 0).multiplyScalar(r));
      }
    }
    if (this.controller) {
      const n = this.controller?.rigidbody.getVelocity().y;
      if (n < -1) {
        this._raycastOptions.ray || (this._raycastOptions.ray = new uo()), this._raycastOptions.ray.origin.copy(Z(this.gameObject)), this._raycastOptions.ray.direction.set(0, -1, 0);
        const o = this.layer;
        this.gameObject.layers.disableAll(), this.gameObject.layers.set(2);
        const r = this.context.physics.raycast(this._raycastOptions);
        this.gameObject.layers.set(o), (r.length && r[0].distance > 2 || n < -10) && this.animator?.setBool("falling", !0);
      } else this.animator?.setBool("falling", !1);
    }
  }
  _raycastOptions = new _r();
}
Ts([
  u(Fa)
], _o.prototype, "controller");
Ts([
  u()
], _o.prototype, "movementSpeed");
Ts([
  u()
], _o.prototype, "rotationSpeed");
Ts([
  u()
], _o.prototype, "jumpForce");
Ts([
  u()
], _o.prototype, "doubleJumpForce");
Ts([
  u(kt)
], _o.prototype, "animator");
var aM = Object.defineProperty, za = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && aM(e, t, n), n;
};
const pl = w("debugcontactshadows");
tg((s) => {
  const e = s.domElement.getAttribute("contactshadows") || s.domElement.getAttribute("contact-shadows");
  if (e != null && e != "0" && e != "false") {
    console.debug("Auto-creating ContactShadows because of `contactshadows` attribute");
    const t = pu.auto(s), i = parseFloat(e);
    isNaN(i) || (t.opacity = i, t.darkness = i);
  }
});
const Sr = class Ll extends R {
  static _instances = /* @__PURE__ */ new Map();
  /**
   * Create contact shadows for the scene. Automatically fits the shadows to the scene.  
   * The instance of contact shadows will be created only once.  
   * @param context The context to create the contact shadows in.
   * @returns The instance of the contact shadows.
   */
  static auto(e, t) {
    if (e || (e = N.Current), !e)
      throw new Error("No context provided and no current context set.");
    let i = this._instances.get(e);
    if (!i || i.destroyed) {
      const n = new M();
      i = An(n, Ll, {
        autoFit: !1,
        occludeBelowGround: !1
      }), this._instances.set(e, i);
    }
    return e.scene.add(i.gameObject), i.fitShadows(t), i;
  }
  autoFit = !1;
  darkness = 0.5;
  opacity = 0.5;
  blur = 4;
  occludeBelowGround = !1;
  backfaceShadows = !0;
  /**
   * The minimum size of the shadows box
   * @default undefined
   */
  minSize;
  /**
   * When enabled the shadows will not be updated automatically. Use `needsUpdate()` to update the shadows manually.
   * This is useful when you want to update the shadows only when the scene changes.
   * @default false
   */
  manualUpdate = !1;
  /**
   * Call this method to update the shadows manually. The update will be done in the next frame.
   */
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  _needsUpdate = !1;
  /** All shadow objects are parented to this object. 
   * The gameObject itself should not be transformed because we want the ContactShadows object e.g. also have a GroundProjectedEnv component
   * in which case ContactShadows scale would affect the projection
   **/
  shadowsRoot = new M();
  shadowCamera;
  shadowGroup = new so();
  renderTarget;
  renderTargetBlur;
  plane;
  occluderMesh;
  blurPlane;
  depthMaterial;
  horizontalBlurMaterial;
  verticalBlurMaterial;
  textureSize = 512;
  /**
   * Call to fit the shadows to the scene.
   */
  fitShadows(e = {}) {
    pl && console.warn("Fitting shadows to scene"), vp(this.shadowsRoot, !1);
    const t = e.object || this.context.scene, i = ii(t, [this.shadowsRoot]), n = Math.max(1, this.blur / 32), o = i.max.x - i.min.x, r = i.max.z - i.min.z;
    i.expandByVector(new y(n * o, 0, n * r)), pl && z.DrawWireBox3(i, 16776960, 60), this.gameObject.parent && i.applyMatrix4(this.gameObject.parent.matrixWorld.clone().invert());
    const a = i.min, l = Math.max(1e-5, (i.max.y - a.y) * 2e-3);
    i.max.y += l, this.shadowsRoot.position.set((a.x + i.max.x) / 2, a.y - l, (a.z + i.max.z) / 2), this.shadowsRoot.scale.set(i.max.x - a.x, i.max.y - a.y, i.max.z - a.z), e.positionOffset && (e.positionOffset.x !== void 0 && (this.shadowsRoot.position.x += e.positionOffset.x), e.positionOffset.y !== void 0 && (this.shadowsRoot.position.y += e.positionOffset.y), e.positionOffset.z !== void 0 && (this.shadowsRoot.position.z += e.positionOffset.z)), e.scaleFactor && (e.scaleFactor.x !== void 0 && (this.shadowsRoot.scale.x *= e.scaleFactor.x), e.scaleFactor.y !== void 0 && (this.shadowsRoot.scale.y *= e.scaleFactor.y), e.scaleFactor.z !== void 0 && (this.shadowsRoot.scale.z *= e.scaleFactor.z)), this.applyMinSize(), this.shadowsRoot.matrixWorldNeedsUpdate = !0, pl && console.log("Fitted shadows to scene", this.shadowsRoot.scale.clone());
  }
  /** @internal */
  awake() {
    Ll._instances.set(this.context, this), this.shadowsRoot.hideFlags = lg.DontExport, vp(this.shadowsRoot, !1);
  }
  /** @internal */
  start() {
    pl && console.log("Create ContactShadows on " + this.gameObject.name, this), this.gameObject.add(this.shadowsRoot), this.shadowsRoot.add(this.shadowGroup), this.renderTarget = new Dn(this.textureSize, this.textureSize), this.renderTarget.texture.generateMipmaps = !1, this.renderTargetBlur = new Dn(this.textureSize, this.textureSize), this.renderTargetBlur.texture.generateMipmaps = !1;
    const e = new Nn(1, 1).rotateX(Math.PI / 2);
    this.gameObject instanceof G && (console.warn("ContactShadows can not be added to a Mesh. Please add it to a Group or an empty Object"), ds(this.gameObject, !1));
    const t = new we({
      map: this.renderTarget.texture,
      opacity: this.opacity,
      color: 0,
      transparent: !0,
      depthWrite: !1,
      side: fo
    });
    this.plane = new G(e, t), this.plane.scale.y = -1, this.plane.layers.set(2), this.shadowsRoot.add(this.plane), this.plane && (this.plane.renderOrder = 1), this.occluderMesh = new G(this.plane.geometry, new we({
      depthWrite: !0,
      stencilWrite: !0,
      colorWrite: !1,
      side: Gd
    })).translateY(-1e-4), this.occluderMesh.renderOrder = -100, this.occluderMesh.layers.set(2), this.shadowsRoot.add(this.occluderMesh), this.blurPlane = new G(e), this.blurPlane.visible = !1, this.shadowGroup.add(this.blurPlane);
    const i = 0, n = 1;
    this.shadowCamera = new zd(-1 / 2, 1 / 2, 1 / 2, -1 / 2, i, n), this.shadowCamera.layers.enableAll(), this.shadowCamera.rotation.x = Math.PI / 2, this.shadowGroup.add(this.shadowCamera), this.depthMaterial = new Mx(), this.depthMaterial.userData.darkness = { value: this.darkness }, this.depthMaterial.blending = Rx, this.depthMaterial.blendEquation = Tx, this.depthMaterial.onBeforeCompile = (o) => {
      this.depthMaterial && (o.uniforms.darkness = this.depthMaterial.userData.darkness, o.fragmentShader = /* glsl */
      `
                uniform float darkness;
                ${o.fragmentShader.replace(
        "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        // we're scaling the shadow value down a bit when it's a backface (looks better)
        "gl_FragColor = vec4( vec3( 1.0 ), ( 1.0 - fragCoordZ ) * darkness * opacity * (gl_FrontFacing ? 1.0 : 0.66) );"
      )}
            `);
    }, this.depthMaterial.depthTest = !1, this.depthMaterial.depthWrite = !1, this.horizontalBlurMaterial = new Ln(IS), this.horizontalBlurMaterial.depthTest = !1, this.verticalBlurMaterial = new Ln(LS), this.verticalBlurMaterial.depthTest = !1, this.shadowGroup.visible = !1, this.autoFit ? this.fitShadows() : this.applyMinSize();
  }
  onEnable() {
    this._needsUpdate = !0;
  }
  /** @internal */
  onDestroy() {
    Ll._instances.get(this.context) === this && Ll._instances.delete(this.context), this.renderTarget?.dispose(), this.renderTargetBlur?.dispose(), this.depthMaterial?.dispose(), this.horizontalBlurMaterial?.dispose(), this.verticalBlurMaterial?.dispose(), this.blurPlane?.geometry.dispose(), this.plane?.geometry.dispose(), this.occluderMesh?.geometry.dispose();
  }
  /** @internal */
  onBeforeRender(e) {
    if (this.manualUpdate && !this._needsUpdate)
      return;
    if (this._needsUpdate = !1, !this.renderTarget || !this.renderTargetBlur || !this.depthMaterial || !this.shadowCamera || !this.blurPlane || !this.shadowGroup || !this.plane || !this.horizontalBlurMaterial || !this.verticalBlurMaterial) {
      pl && console.error("ContactShadows: not initialized yet");
      return;
    }
    const t = this.context.scene, i = this.context.renderer, n = i.getRenderTarget();
    this.shadowGroup.visible = !0, this.occluderMesh && (this.occluderMesh.visible = !1);
    const o = this.plane.visible;
    this.plane.visible = !1, this.gameObject instanceof G && ds(this.gameObject, !1);
    const r = t.background;
    t.background = null, t.overrideMaterial = this.depthMaterial, this.backfaceShadows ? this.depthMaterial.side = xi : this.depthMaterial.side = fo;
    const a = i.getClearAlpha();
    i.setClearAlpha(0);
    const l = i.xr.enabled;
    i.xr.enabled = !1;
    const c = this.context.scene.matrixWorldAutoUpdate;
    this.context.scene.matrixWorldAutoUpdate = !1;
    const h = i.renderLists.get(t, 0), d = h.transparent;
    T_.length = 0, h.transparent = T_, If.length = 0;
    for (const p of h.opaque) {
      if (!p.object.visible) continue;
      const g = p.material;
      let b = p.material.colorWrite == !1 || g.wireframe === !0 || s1(p.object) === !1;
      !b && p.material.isLineMaterial && (b = !0), !b && p.material.isPointsMaterial && (b = !0), b && (If.push(p.object), p.object["needle:visible"] = p.object.visible, p.object.visible = !1);
    }
    i.setRenderTarget(this.renderTarget), i.clear(), i.render(t, this.shadowCamera), h.transparent = d;
    for (const p of If)
      p["needle:visible"] != null && (p.visible = p["needle:visible"]);
    t.overrideMaterial = null;
    const f = Math.max(this.blur, 0.05);
    this.blurShadow(f * 2), this.blurShadow(f * 0.5), this.shadowGroup.visible = !1, this.occluderMesh && (this.occluderMesh.visible = this.occludeBelowGround), this.plane.visible = o, i.setRenderTarget(n), i.setClearAlpha(a), t.background = r, i.xr.enabled = l, this.context.scene.matrixWorldAutoUpdate = c;
  }
  // renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget
  blurShadow(e) {
    if (!this.blurPlane || !this.shadowCamera || !this.renderTarget || !this.renderTargetBlur || !this.horizontalBlurMaterial || !this.verticalBlurMaterial)
      return;
    this.blurPlane.visible = !0;
    const t = this.shadowsRoot.worldScale, i = (t.x + t.z) / 2, n = t.z / i, o = t.x / i;
    this.blurPlane.material = this.horizontalBlurMaterial, this.blurPlane.material.uniforms.tDiffuse.value = this.renderTarget.texture, this.horizontalBlurMaterial.uniforms.h.value = e * 1 / this.textureSize * n;
    const r = this.context.renderer, a = r.getRenderTarget();
    r.setRenderTarget(this.renderTargetBlur), r.render(this.blurPlane, this.shadowCamera), this.blurPlane.material = this.verticalBlurMaterial, this.blurPlane.material.uniforms.tDiffuse.value = this.renderTargetBlur.texture, this.verticalBlurMaterial.uniforms.v.value = e * 1 / this.textureSize * o, r.setRenderTarget(this.renderTarget), r.render(this.blurPlane, this.shadowCamera), this.blurPlane.visible = !1, r.setRenderTarget(a);
  }
  applyMinSize() {
    this.minSize && this.shadowsRoot.scale.set(
      Math.max(this.minSize.x || 0, this.shadowsRoot.scale.x),
      Math.max(this.minSize.y || 0, this.shadowsRoot.scale.y),
      Math.max(this.minSize.z || 0, this.shadowsRoot.scale.z)
    );
  }
};
za([
  u()
], Sr.prototype, "autoFit");
za([
  u()
], Sr.prototype, "darkness");
za([
  u()
], Sr.prototype, "opacity");
za([
  u()
], Sr.prototype, "blur");
za([
  u()
], Sr.prototype, "occludeBelowGround");
za([
  u()
], Sr.prototype, "backfaceShadows");
let pu = Sr;
const T_ = [], If = new Array(), lM = w("logstats");
class gv extends R {
  onEnable() {
    console.log(this), lM && this.startCoroutine(this.run(), xe.OnAfterRender);
  }
  *run() {
    for (; this.enabled; ) {
      const e = this.context.renderer.info;
      console.log(e.memory, e.render, e.programs), yield;
    }
  }
}
class mu extends R {
  isUsed = !0;
  usedBy = null;
}
class yv extends R {
}
const E_ = w("debugdeletable");
class nr extends Pt {
  static _instances = [];
  onEnable() {
    nr._instances.push(this);
  }
  onDisable() {
    const e = nr._instances.indexOf(this);
    e >= 0 && nr._instances.splice(e, 1);
  }
}
class _v extends R {
  update() {
    for (const e of nr._instances) {
      const t = this.gameObject;
      if (e.isInBox(t) === !0) {
        const n = S.getComponentInParent(this.gameObject, mu);
        if (n)
          E_ && console.warn("DeleteBox: Not deleting object with usage marker", this.guid, n);
        else {
          if (E_)
            try {
              if (e.box) {
                const o = e.box, r = Pt.testBox;
                z.DrawWireBox3(o, 16711680, 5), z.DrawWireBox3(r, 255, 5), console.log("DeleteBox: Destroying", this.gameObject, { deleteBoxArea: o, deletedObjectArea: r });
              } else
                console.log("DeleteBox: Destroying", this.gameObject);
            } catch {
            }
          eu(this.gameObject, this.context.connection);
        }
      }
    }
  }
}
var cM = Object.defineProperty, hM = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && cM(e, t, n), n;
};
class pg extends R {
  visibleOn;
  onEnable() {
    this.apply();
  }
  apply() {
    this.test() || S.setActive(this.gameObject, !1);
  }
  test() {
    return this.visibleOn < 0 ? !0 : q.isMobileDevice() ? (this.visibleOn & 2) !== 0 : (this.visibleOn & 1) !== 0;
  }
}
hM([
  u()
], pg.prototype, "visibleOn");
var dM = Object.defineProperty, Cr = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && dM(e, t, n), n;
};
const Mn = w("debugdrag"), Lf = [];
var bv = /* @__PURE__ */ ((s) => (s[s.XZPlane = 0] = "XZPlane", s[s.Attached = 1] = "Attached", s[s.HitNormal = 2] = "HitNormal", s[s.DynamicViewAngle = 3] = "DynamicViewAngle", s[s.SnapToSurfaces = 4] = "SnapToSurfaces", s[s.None = 5] = "None", s))(bv || {});
const bo = class ji extends R {
  /**
   * Checks if any DragControls component is currently active with selected objects
   * @returns True if any DragControls component is currently active
   */
  static get HasAnySelected() {
    return this._active > 0;
  }
  static _active = 0;
  /** 
   * Retrieves a list of all DragControl components that are currently dragging objects.
   * @returns Array of currently active DragControls components
   */
  static get CurrentlySelected() {
    Lf.length = 0;
    for (const e of this._instances)
      e._isDragging && Lf.push(e);
    return Lf;
  }
  /** Registry of currently active and enabled DragControls components */
  static _instances = [];
  dragMode = 3;
  snapGridResolution = 0;
  keepRotation = !0;
  xrDragMode = 1;
  xrKeepRotation = !1;
  xrDistanceDragFactor = 1;
  showGizmo = !1;
  /** 
   * Returns the object currently being dragged by this DragControls component, if any.
   * @returns The object being dragged or null if no object is currently dragged
   */
  get draggedObject() {
    return this._targetObject;
  }
  /**
   * Updates the object that is being dragged by the DragControls.
   * This can be used to change the target during a drag operation.
   * @param obj The new object to drag, or null to stop dragging
   */
  setTargetObject(e) {
    this._targetObject = e;
    for (const i of this._dragHandlers.values())
      i.setTargetObject(e);
    const t = "_rigidbody-was-kinematic";
    this._rigidbody?.[t] === !1 && (this._rigidbody.isKinematic = !1, this._rigidbody[t] = void 0), this._rigidbody = null, e && (this._rigidbody = S.getComponentInChildren(e, rt), this._rigidbody?.isKinematic === !1 && (this._rigidbody.isKinematic = !0, this._rigidbody[t] = !1));
  }
  _rigidbody = null;
  // future:
  // constraints?
  /** The object to be dragged – we pass this to handlers when they are created */
  _targetObject = null;
  _dragHelper = null;
  static lastHovered;
  _draggingRigidbodies = [];
  _potentialDragStartEvt = null;
  _dragHandlers = /* @__PURE__ */ new Map();
  _totalMovement = new y();
  /** A marker is attached to components that are currently interacted with, to e.g. prevent them from being deleted. */
  _marker = null;
  _isDragging = !1;
  _didDrag = !1;
  /** @internal */
  awake() {
    this._potentialDragStartEvt = null, this._dragHandlers = /* @__PURE__ */ new Map(), this._totalMovement = new y(), this._marker = null, this._isDragging = !1, this._didDrag = !1, this._dragHelper = null, this._draggingRigidbodies = [];
  }
  /** @internal */
  start() {
    this.gameObject.getComponentInParent(qi) || this.gameObject.addComponent(qi);
  }
  /** @internal */
  onEnable() {
    ji._instances.push(this);
  }
  /** @internal */
  onDisable() {
    ji._instances = ji._instances.filter((e) => e !== this);
  }
  /**
   * Checks if editing is allowed for the current networking connection.
   * @param _obj Optional object to check edit permissions for
   * @returns True if editing is allowed
   */
  allowEdit(e = null) {
    return this.context.connection.allowEditing;
  }
  /** 
   * Handles pointer enter events. Sets the cursor style and tracks the hovered object.
   * @param evt Pointer event data containing information about the interaction
   * @internal
   */
  onPointerEnter(e) {
    if (!this.allowEdit(this.gameObject) || e.mode !== "screen" || (e.event.mode === "tracked-pointer" || e.event.mode === "transient-pointer" ? this.xrDragMode : this.dragMode) === 5) return;
    const n = S.getComponentInParent(e.object, ji);
    !n || n !== this || (ji.lastHovered = e.object, this.context.domElement.style.cursor = "pointer");
  }
  /** 
   * Handles pointer movement events. Marks the event as used if dragging is active.
   * @param args Pointer event data containing information about the movement
   * @internal
   */
  onPointerMove(e) {
    (this._isDragging || this._potentialDragStartEvt !== null) && e.use();
  }
  /** 
   * Handles pointer exit events. Resets the cursor style when the pointer leaves a draggable object.
   * @param evt Pointer event data containing information about the interaction
   * @internal
   */
  onPointerExit(e) {
    this.allowEdit(this.gameObject) && e.mode === "screen" && ji.lastHovered === e.object && (this.context.domElement.style.cursor = "auto");
  }
  /** 
   * Handles pointer down events. Initiates the potential drag operation if conditions are met.
   * @param args Pointer event data containing information about the interaction
   * @internal
   */
  onPointerDown(e) {
    if (!(!this.allowEdit(this.gameObject) || e.used || (e.mode === "tracked-pointer" || e.mode === "transient-pointer" ? this.xrDragMode : this.dragMode) === 5) && (ji.lastHovered = e.object, e.button === 0)) {
      this._dragHandlers.size === 0 && (this._didDrag = !1, this._totalMovement.set(0, 0, 0), this._potentialDragStartEvt = e), this._targetObject || this.setTargetObject(this.gameObject), ji._active += 1;
      const n = new Df(this, this._targetObject);
      if (this._dragHandlers.set(e.event.space, n), n.onDragStart(e), this._dragHandlers.size === 2) {
        const o = this._dragHandlers.values(), r = o.next().value, a = o.next().value;
        if (r instanceof Df && a instanceof Df) {
          const l = new uM(this, this._targetObject, r, a);
          this._dragHandlers.set(this.gameObject, l), l.onDragStart(e);
        } else
          console.error("Attempting to construct a MultiTouchDragHandler with invalid DragPointerHandlers. This is likely a bug.", { a: r, b: a });
      }
      e.use();
    }
  }
  /** 
   * Handles pointer up events. Finalizes or cancels the drag operation.
   * @param args Pointer event data containing information about the interaction
   * @internal
   */
  onPointerUp(e) {
    if (Mn && z.DrawLabel(e.point ?? this.gameObject.worldPosition, "POINTERUP:" + e.pointerId + ", " + e.button, 0.03, 3), !this.allowEdit(this.gameObject) || e.button !== 0) return;
    this._potentialDragStartEvt = null;
    const t = this._dragHandlers.get(e.event.space), i = this._dragHandlers.get(this.gameObject);
    i && (i.handlerA === t || i.handlerB === t) && (this._dragHandlers.delete(this.gameObject), i.onDragEnd(e)), t && (ji._active > 0 && (ji._active -= 1), this.setTargetObject(null), t.onDragEnd && t.onDragEnd(e), this._dragHandlers.delete(e.event.space), this._dragHandlers.size === 0 && this.onLastDragEnd(e), e.use());
  }
  /**
   * Updates the drag operation every frame. Processes pointer movement, accumulates drag distance
   * and triggers drag start once there's enough movement.
   * @internal
   */
  update() {
    for (const e of this._dragHandlers.values())
      e.collectMovementInfo && e.collectMovementInfo(), e.getTotalMovement && this._totalMovement.add(e.getTotalMovement());
    if (this._potentialDragStartEvt) {
      if (!this._didDrag)
        if (this._totalMovement.length() > 3e-4)
          this._didDrag = !0;
        else return;
      const e = this._potentialDragStartEvt;
      this._potentialDragStartEvt = null, this.onFirstDragStart(e);
    }
    for (const e of this._dragHandlers.values())
      e.onDragUpdate && e.onDragUpdate(this._dragHandlers.size);
    this._dragHelper && this._dragHelper.hasSelected && this.onAnyDragUpdate();
  }
  /** 
   * Called when the first pointer starts dragging on this object. 
   * Sets up network synchronization and marks rigidbodies for dragging.
   * Not called for subsequent pointers on the same object.
   * @param evt Pointer event data that initiated the drag
   */
  onFirstDragStart(e) {
    if (!e || !e.object) return;
    const t = S.getComponentInParent(e.object, ji);
    if (!t || t !== this && t._isDragging) return;
    const i = this._targetObject || this.gameObject;
    if (!i) return;
    this._isDragging = !0;
    const n = S.getComponentInChildren(i, zn);
    Mn && console.log("DRAG START", n, i), n && (n.fastMode = !0, n?.requestOwnership()), this._marker = S.addComponent(i, mu), this._draggingRigidbodies.length = 0;
    const o = S.getComponentsInChildren(i, rt);
    o && this._draggingRigidbodies.push(...o);
  }
  /** 
   * Called each frame as long as any pointer is dragging this object.
   * Updates visuals and keeps rigidbodies awake during the drag.
   */
  onAnyDragUpdate() {
    if (!this._dragHelper) return;
    this._dragHelper.showGizmo = this.showGizmo, this._dragHelper.onUpdate(this.context);
    for (const t of this._draggingRigidbodies)
      t.wakeUp(), t.resetVelocities(), t.resetForcesAndTorques();
    const e = this._targetObject || this.gameObject;
    ln.markDirty(e);
  }
  /** 
   * Called when the last pointer has been removed from this object.
   * Cleans up drag state and applies final velocities to rigidbodies.
   * @param evt Pointer event data for the last pointer that was lifted
   */
  onLastDragEnd(e) {
    if (!this || !this._isDragging) return;
    this._isDragging = !1;
    for (const i of this._draggingRigidbodies)
      i.setVelocity(i.smoothedVelocity);
    if (this._draggingRigidbodies.length = 0, this._targetObject = null, e?.object) {
      const i = S.getComponentInChildren(e.object, zn);
      i && (i.fastMode = !1);
    }
    if (this._marker && this._marker.destroy(), !this._dragHelper) return;
    const t = this._dragHelper.selected;
    Mn && console.log("DRAG END", t, t?.visible), this._dragHelper.setSelected(null, this.context);
  }
};
Cr([
  u()
], bo.prototype, "dragMode");
Cr([
  u()
], bo.prototype, "snapGridResolution");
Cr([
  u()
], bo.prototype, "keepRotation");
Cr([
  u()
], bo.prototype, "xrDragMode");
Cr([
  u()
], bo.prototype, "xrKeepRotation");
Cr([
  u()
], bo.prototype, "xrDistanceDragFactor");
Cr([
  u()
], bo.prototype, "showGizmo");
let Zr = bo;
class uM {
  handlerA;
  handlerB;
  context;
  settings;
  gameObject;
  _handlerAAttachmentPoint = new y();
  _handlerBAttachmentPoint = new y();
  _followObject;
  _manipulatorObject;
  _deviceMode;
  _followObjectStartWorldQuaternion = new U();
  constructor(e, t, i, n) {
    this.context = e.context, this.settings = e, this.gameObject = t, this.handlerA = i, this.handlerB = n, this._followObject = new M(), this._manipulatorObject = new M(), this.context.scene.add(this._manipulatorObject);
    const o = K.active?.rig?.gameObject;
    if (!this.handlerA || !this.handlerB || !this.handlerA.hitPointInLocalSpace || !this.handlerB.hitPointInLocalSpace) {
      console.error("Invalid: MultiTouchDragHandler needs two valid DragPointerHandlers with hitPointInLocalSpace set.");
      return;
    }
    if (this._tempVec1.copy(this.handlerA.hitPointInLocalSpace), this._tempVec2.copy(this.handlerB.hitPointInLocalSpace), this.gameObject.localToWorld(this._tempVec1), this.gameObject.localToWorld(this._tempVec2), o && (o.worldToLocal(this._tempVec1), o.worldToLocal(this._tempVec2)), this._initialDistance = this._tempVec1.distanceTo(this._tempVec2), this._initialDistance < 0.02 ? (Mn && console.log("Finding alternative drag attachment points since initial distance is too low: " + this._initialDistance.toFixed(2)), this.handlerA.followObject.parent.getWorldPosition(this._tempVec1), this.handlerB.followObject.parent.getWorldPosition(this._tempVec2), this._handlerAAttachmentPoint.copy(this._tempVec1), this._handlerBAttachmentPoint.copy(this._tempVec2), this.gameObject.worldToLocal(this._handlerAAttachmentPoint), this.gameObject.worldToLocal(this._handlerBAttachmentPoint), this._initialDistance = this._tempVec1.distanceTo(this._tempVec2), this._initialDistance < 1e-3 && (console.warn("Not supported right now – controller drag points for multitouch are too close!"), this._initialDistance = 1)) : (this._handlerAAttachmentPoint.copy(this.handlerA.hitPointInLocalSpace), this._handlerBAttachmentPoint.copy(this.handlerB.hitPointInLocalSpace)), this._tempVec3.lerpVectors(this._tempVec1, this._tempVec2, 0.5), this._initialScale.copy(t.scale), Mn) {
      this._followObject.add(new vi(2)), this._manipulatorObject.add(new vi(5));
      const r = (a) => `${a.x.toFixed(2)}, ${a.y.toFixed(2)}, ${a.z.toFixed(2)}`;
      z.DrawLine(this._tempVec1, this._tempVec2, 65535, 0, !1), z.DrawLabel(this._tempVec3, "A:B " + this._initialDistance.toFixed(2) + `
` + r(this._tempVec1) + `
` + r(this._tempVec2), 0.03, 5);
    }
  }
  onDragStart(e) {
    this.gameObject.add(this._followObject), this._followObject.matrixAutoUpdate = !1, this._followObject.matrix.identity(), this._deviceMode = e.mode, this._followObjectStartWorldQuaternion.copy(this._followObject.worldQuaternion), this.alignManipulator(), this._manipulatorObject.attach(this._followObject), this._manipulatorPosOffset.copy(this._followObject.position), this._manipulatorRotOffset.copy(this._followObject.quaternion), this._manipulatorScaleOffset.copy(this._followObject.scale);
  }
  onDragEnd(e) {
    if (!this.handlerA || !this.handlerB) {
      console.error("onDragEnd called on MultiTouchDragHandler without valid handlers. This is likely a bug.");
      return;
    }
    this.handlerA.recenter(), this.handlerB.recenter(), this._manipulatorObject.removeFromParent(), this._followObject.removeFromParent(), this._manipulatorObject.destroy(), this._followObject.destroy();
  }
  _manipulatorPosOffset = new y();
  _manipulatorRotOffset = new U();
  _manipulatorScaleOffset = new y();
  _tempVec1 = new y();
  _tempVec2 = new y();
  _tempVec3 = new y();
  tempLookMatrix = new ee();
  _initialScale = new y();
  _initialDistance = 0;
  alignManipulator() {
    if (!this.handlerA || !this.handlerB) {
      console.error("alignManipulator called on MultiTouchDragHandler without valid handlers. This is likely a bug.", this);
      return;
    }
    if (!this.handlerA.followObject || !this.handlerB.followObject) {
      console.error("alignManipulator called on MultiTouchDragHandler without valid follow objects. This is likely a bug.", this.handlerA, this.handlerB);
      return;
    }
    this._tempVec1.copy(this._handlerAAttachmentPoint), this._tempVec2.copy(this._handlerBAttachmentPoint), this.handlerA.followObject.localToWorld(this._tempVec1), this.handlerB.followObject.localToWorld(this._tempVec2), this._tempVec3.lerpVectors(this._tempVec1, this._tempVec2, 0.5), this._manipulatorObject.position.copy(this._tempVec3);
    const e = this.context.mainCamera;
    this.tempLookMatrix.lookAt(this._tempVec3, this._tempVec2, e.worldUp), this._manipulatorObject.quaternion.setFromRotationMatrix(this.tempLookMatrix);
    const t = this._tempVec1.distanceTo(this._tempVec2);
    this._manipulatorObject.scale.copy(this._initialScale).multiplyScalar(t / this._initialDistance), this._manipulatorObject.updateMatrix(), this._manipulatorObject.updateMatrixWorld(!0), Mn && (z.DrawLabel(this._tempVec3.clone().add(new y(0, 0.2, 0)), "A:B " + t.toFixed(2), 0.03), z.DrawLine(this._tempVec1, this._tempVec2, 65280, 0, !1));
  }
  onDragUpdate() {
    this.alignManipulator();
    const e = 30, t = 1;
    this._followObject.position.copy(this._manipulatorPosOffset), this._followObject.quaternion.copy(this._manipulatorRotOffset), this._followObject.scale.copy(this._manipulatorScaleOffset);
    const i = this.gameObject, n = this._followObject;
    if (!i) {
      console.error("MultiTouchDragHandler has no dragged object. This is likely a bug.");
      return;
    }
    n.updateMatrix(), n.updateMatrixWorld(!0);
    const r = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer" ? this.settings.xrKeepRotation : this.settings.keepRotation;
    if (this.settings.snapGridResolution > 0) {
      const d = this._followObject.worldPosition, f = this.settings.snapGridResolution;
      d.x = Math.round(d.x / f) * f, d.y = Math.round(d.y / f) * f, d.z = Math.round(d.z / f) * f, this._followObject.worldPosition = d, this._followObject.updateMatrix();
    }
    r && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion, this._followObject.updateMatrix());
    const a = j.clamp01(this.context.time.deltaTime * e * t), l = i.worldPosition;
    l.lerp(n.worldPosition, a), i.worldPosition = l;
    const c = i.worldQuaternion;
    c.slerp(n.worldQuaternion, a), i.worldQuaternion = c;
    const h = i.worldScale;
    h.lerp(n.worldScale, a), i.worldScale = h;
  }
  setTargetObject(e) {
    this.gameObject = e;
  }
}
class Df {
  /** 
   * Returns the accumulated movement of the pointer in world units.
   * Used for determining if enough motion has occurred to start a drag.
   */
  getTotalMovement() {
    return this._totalMovement;
  }
  /** 
   * Returns the object that follows the pointer during dragging operations.
   */
  get followObject() {
    return this._followObject;
  }
  /**
   * Returns the point where the pointer initially hit the object in local space.
   */
  get hitPointInLocalSpace() {
    return this._hitPointInLocalSpace;
  }
  context;
  gameObject;
  settings;
  _lastRig = void 0;
  /** This object is placed at the pivot of the dragged object, and parented to the control space. */
  _followObject;
  _totalMovement = new y();
  /** Motion along the pointer ray. On screens this doesn't change. In XR it can be used to determine how much
   * effort someone is putting into moving an object closer or further away. */
  _totalMovementAlongRayDirection = 0;
  /** Distance between _followObject and its parent at grab start, in local space */
  _grabStartDistance = 0;
  _deviceMode;
  _followObjectStartPosition = new y();
  _followObjectStartQuaternion = new U();
  _followObjectStartWorldQuaternion = new U();
  _lastDragPosRigSpace;
  _tempVec = new y();
  _tempMat = new ee();
  _hitPointInLocalSpace = new y();
  _hitNormalInLocalSpace = new y();
  _bottomCenter = new y();
  _backCenter = new y();
  _backBottomCenter = new y();
  _bounds = new bi();
  _dragPlane = new rr(new y(0, 1, 0));
  _draggedOverObject = null;
  _draggedOverObjectLastSetUp = null;
  _draggedOverObjectLastNormal = new y();
  _draggedOverObjectDuration = 0;
  /** Allows overriding which object is dragged while a drag is already ongoing. Used for example by Duplicatable */
  setTargetObject(e) {
    this.gameObject = e;
  }
  constructor(e, t) {
    this.settings = e, this.context = e.context, this.gameObject = t, this._followObject = new M();
  }
  recenter() {
    if (!this._followObject.parent) {
      console.warn("Error: space follow object doesn't have parent but recenter() is called. This is likely a bug");
      return;
    }
    if (!this.gameObject) {
      console.warn("Error: space follow object doesn't have a gameObject");
      return;
    }
    const e = this._followObject.parent;
    this.gameObject.add(this._followObject), this._followObject.matrixAutoUpdate = !1, this._followObject.position.set(0, 0, 0), this._followObject.quaternion.set(0, 0, 0, 1), this._followObject.scale.set(1, 1, 1), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0), e.attach(this._followObject), this._followObjectStartPosition.copy(this._followObject.position), this._followObjectStartQuaternion.copy(this._followObject.quaternion), this._followObjectStartWorldQuaternion.copy(this._followObject.worldQuaternion), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
    const t = this._hitPointInLocalSpace.clone();
    this.gameObject.localToWorld(t), this._grabStartDistance = t.distanceTo(e.worldPosition);
    const n = K.active?.rig?.gameObject?.worldScale.x || 1;
    this._grabStartDistance /= n, this._totalMovementAlongRayDirection = 0, this._lastDragPosRigSpace = void 0, Mn && (z.DrawLine(t, e.worldPosition, 65280, 0.5, !1), z.DrawLabel(e.worldPosition.add(new y(0, 0.1, 0)), this._grabStartDistance.toFixed(2), 0.03, 0.5));
  }
  onDragStart(e) {
    if (!this.gameObject) {
      console.warn("Error: space follow object doesn't have a gameObject");
      return;
    }
    if (e.event.space.add(this._followObject), this._lastDragPosRigSpace = void 0, e.point && e.normal)
      this._hitPointInLocalSpace.copy(e.point), this.gameObject.worldToLocal(this._hitPointInLocalSpace), this._hitNormalInLocalSpace.copy(e.normal);
    else if (e) {
      const b = e.event.space, m = b.worldPosition;
      this.gameObject.worldToLocal(m), this._hitPointInLocalSpace.copy(m);
      const v = b.worldUp;
      this._tempMat.copy(this.gameObject.matrixWorld).invert(), v.transformDirection(this._tempMat), this._hitNormalInLocalSpace.copy(v);
    }
    this.recenter(), this._totalMovement.set(0, 0, 0), this._deviceMode = e.mode;
    const i = this._followObject.parent.worldForward, o = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer" ? this.settings.xrDragMode : this.settings.dragMode, r = this._hitPointInLocalSpace.clone();
    switch (this.gameObject.localToWorld(r), o) {
      case 0:
        const b = new y(0, 1, 0);
        this.gameObject.parent && b.transformDirection(this.gameObject.parent.matrixWorld.clone().invert()), this._dragPlane.setFromNormalAndCoplanarPoint(b, r);
        break;
      case 2:
        const m = this._hitNormalInLocalSpace.clone();
        m.transformDirection(this.gameObject.matrixWorld), this._dragPlane.setFromNormalAndCoplanarPoint(m, r);
        break;
      case 1:
        this._dragPlane.setFromNormalAndCoplanarPoint(i, r);
        break;
      case 3:
        this.setPlaneViewAligned(r, !0);
        break;
      case 4:
        this.setPlaneViewAligned(r, !1);
        break;
    }
    const a = this.gameObject.parent, l = this.gameObject.position.clone(), c = this.gameObject.quaternion.clone(), h = this.gameObject.scale.clone(), d = this.gameObject.matrixWorld.clone();
    a && a.remove(this.gameObject), this.gameObject.position.set(0, 0, 0), this.gameObject.quaternion.set(0, 0, 0, 1), this.gameObject.scale.set(1, 1, 1);
    const f = ii([this.gameObject]);
    f.expandByPoint(this.gameObject.worldPosition);
    const p = new y();
    f.getCenter(p);
    const g = new y();
    f.getSize(g), this._bottomCenter.copy(p.clone().add(new y(0, -g.y / 2, 0))), this._backCenter.copy(p.clone().add(new y(0, 0, g.z / 2))), this._backBottomCenter.copy(p.clone().add(new y(0, -g.y / 2, g.z / 2))), this._bounds.copy(f), a && a.add(this.gameObject), this.gameObject.position.copy(l), this.gameObject.quaternion.copy(c), this.gameObject.scale.copy(h), this.gameObject.matrixWorld.copy(d), this._draggedOverObject = null, this._draggedOverObjectLastSetUp = null, this._draggedOverObjectLastNormal.set(0, 1, 0), this._draggedOverObjectDuration = 0;
  }
  collectMovementInfo() {
    if (!this._followObject.parent) return;
    const e = this._followObject.parent;
    this._followObject.updateMatrix();
    const t = e.worldPosition, i = K.active?.rig?.gameObject;
    i && i.worldToLocal(t), (this._lastDragPosRigSpace === void 0 || i != this._lastRig) && (this._lastDragPosRigSpace = t.clone(), this._lastRig = i), this._tempVec.copy(t).sub(this._lastDragPosRigSpace);
    const n = e.worldForward;
    if (i && (this._tempMat.copy(i.matrixWorld).invert(), n.transformDirection(this._tempMat)), this._totalMovementAlongRayDirection += n.dot(this._tempVec), this._tempVec.x = Math.abs(this._tempVec.x), this._tempVec.y = Math.abs(this._tempVec.y), this._tempVec.z = Math.abs(this._tempVec.z), this._totalMovement.add(this._tempVec), this._lastDragPosRigSpace.copy(t), Mn) {
      let o = t;
      i && (o = o.clone(), o.transformDirection(i.matrixWorld)), z.DrawRay(o, n, 255);
    }
  }
  onDragUpdate(e) {
    if (e > 1) return;
    const t = this.gameObject;
    if (!t || !this._followObject) {
      console.warn("Warning: DragPointerHandler doesn't have a dragged object. This is likely a bug.");
      return;
    }
    const i = this._followObject.parent;
    if (!i) {
      console.warn("Warning: DragPointerHandler doesn't have a drag source. This is likely a bug.");
      return;
    }
    this._followObject.updateMatrix();
    const n = i.worldPosition, o = i.worldForward, r = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer", a = r ? this.settings.xrKeepRotation : this.settings.keepRotation, l = r ? this.settings.xrDragMode : this.settings.dragMode;
    if (l === 5) return;
    const c = 10;
    a && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
    let h = 1, d = 2;
    if (r && this._grabStartDistance > 0.5) {
      const _ = 1 + this._totalMovementAlongRayDirection * (2 * this.settings.xrDistanceDragFactor);
      h = Math.max(0, _), h = h * h * h;
    } else this._grabStartDistance <= 0.5 && (d = 3);
    this._followObject.position.copy(this._followObjectStartPosition), a || this._followObject.quaternion.copy(this._followObjectStartQuaternion), this._followObject.position.multiplyScalar(h), this._followObject.updateMatrix();
    const f = this._hasLastSurfaceHitPoint;
    this._hasLastSurfaceHitPoint = !1;
    const p = new uo(n, o);
    if (l == 4) {
      const _ = this.context.physics.raycastFromRay(p, {
        testObject: (x) => x !== this.followObject && x !== i && x !== t
        // && !(o instanceof GroundedSkybox)
      });
      if (_.length > 0) {
        const x = _[0];
        if (this._draggedOverObject === x.object ? this._draggedOverObjectDuration += this.context.time.deltaTime : (this._draggedOverObject = x.object, this._draggedOverObjectDuration = 0), x.face) {
          this._hasLastSurfaceHitPoint = !0, this._lastSurfaceHitPoint.copy(x.point);
          const O = this._draggedOverObjectDuration >= 0.15, E = this._totalMovement.length() >= 1e-3, B = H(x.normal || x.face.normal).applyQuaternion(x.object.worldQuaternion);
          if ((O || E) && (this._draggedOverObjectLastSetUp !== this._draggedOverObject || this._draggedOverObjectLastNormal.dot(B) < 0.999999 || this.context.time.frame % 60 === 0)) {
            this._draggedOverObjectLastSetUp = this._draggedOverObject, this._draggedOverObjectLastNormal.copy(x.face.normal);
            const D = H(), W = H();
            this._bounds.getCenter(D), this._bounds.getSize(W), D.sub(W.multiplyScalar(0.5).multiply(B)), this._hitPointInLocalSpace.copy(D), this._hitNormalInLocalSpace.copy(x.face.normal), this._bounds.getCenter(D), this._bounds.getSize(W), D.add(W.multiplyScalar(0.5).multiply(x.face.normal));
            const X = H(this._hitPointInLocalSpace).add(D);
            this._followObject.localToWorld(X);
            const A = x.point;
            this._dragPlane.setFromNormalAndCoplanarPoint(B, A);
          } else if (!(O || E))
            return;
        }
      } else f && this.gameObject && this.setPlaneViewAligned(this.gameObject.worldPosition, !1);
    }
    if (l !== 1 && p.intersectPlane(this._dragPlane, this._tempVec)) {
      this._followObject.worldPosition = this._tempVec, this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
      const _ = H(this._hitPointInLocalSpace);
      this._followObject.localToWorld(_), Mn && z.DrawLine(_, this._tempVec, 65535, 0, !1), this._followObject.worldPosition = this._tempVec.multiplyScalar(2).sub(_), this._followObject.updateMatrix(), this._followObject.updateMatrix();
    }
    if (this.settings.snapGridResolution > 0) {
      const _ = this._followObject.worldPosition, x = this.settings.snapGridResolution;
      _.x = Math.round(_.x / x) * x, _.y = Math.round(_.y / x) * x, _.z = Math.round(_.z / x) * x, this._followObject.worldPosition = _, this._followObject.updateMatrix();
    }
    a && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion, this._followObject.updateMatrix());
    const g = j.clamp01(this.context.time.deltaTime * c * d), b = j.clamp01(this.context.time.deltaTime * c * 0.5 * d), m = t.worldPosition;
    m.lerp(this._followObject.worldPosition, g), t.worldPosition = m;
    const v = t.worldQuaternion;
    if (v.slerp(this._followObject.worldQuaternion, b), t.worldQuaternion = v, Mn) {
      const _ = this._hitPointInLocalSpace.clone();
      t.localToWorld(_), z.DrawSphere(_, 0.02, 16711680);
      const x = this._hitNormalInLocalSpace.clone();
      x.applyQuaternion(v), z.DrawRay(_, x, 16711680), z.DrawLabel(
        m.add(new y(0, 0.25, 0)),
        `Distance: ${this._totalMovement.length().toFixed(2)}

                Along Ray: ${this._totalMovementAlongRayDirection.toFixed(2)}

                Session: ${!!K.active}

                Device: ${this._deviceMode}

                `,
        0.03
      );
      const I = this._bottomCenter.clone(), O = this._backCenter.clone(), k = this._backBottomCenter.clone();
      t.localToWorld(I), t.localToWorld(O), t.localToWorld(k), z.DrawSphere(I, 0.01, 65280, 0, !1), z.DrawSphere(O, 0.01, 255, 0, !1), z.DrawSphere(k, 0.01, 16711935, 0, !1), z.DrawLine(I, k, 65535, 0, !1), z.DrawLine(k, O, 65535, 0, !1);
    }
  }
  onDragEnd(e) {
    console.assert(this._followObject.parent === e.event.space, "Drag end: _followObject is not parented to the space object"), this._followObject.removeFromParent(), this._followObject.destroy(), this._lastDragPosRigSpace = void 0;
  }
  _hasLastSurfaceHitPoint = !1;
  _lastSurfaceHitPoint = new y();
  setPlaneViewAligned(e, t) {
    if (!this._followObject.parent)
      return !1;
    const i = this._followObject.parent.worldForward, n = H(0, 1, 0), o = i, r = n.angleTo(o), a = 0.5;
    return t && (r > Math.PI / 2 + a || r < Math.PI / 2 - a) ? this._dragPlane.setFromNormalAndCoplanarPoint(n, e) : this._dragPlane.setFromNormalAndCoplanarPoint(i, e), !0;
  }
}
class vv {
  /** Controls whether visual helpers like lines and markers are displayed */
  showGizmo = !0;
  /** When true, drag plane alignment changes based on view angle */
  useViewAngle = !0;
  /**
   * Checks if there is a currently selected object being visualized
   */
  get hasSelected() {
    return this._selected !== null && this._selected !== void 0;
  }
  /**
   * Returns the currently selected object being visualized, if any
   */
  get selected() {
    return this._selected;
  }
  _selected = null;
  _context = null;
  _camera;
  _cameraPlane = new rr();
  _hasGroundPlane = !1;
  _groundPlane = new rr();
  _groundOffset = new y();
  _groundOffsetFactor = 0;
  _groundDistance = 0;
  _groundPlanePoint = new y();
  _raycaster = new Nd();
  _cameraPlaneOffset = new y();
  _intersection = new y();
  _worldPosition = new y();
  _inverseMatrix = new ee();
  _rbs = [];
  _groundLine;
  _groundMarker;
  static geometry = new an().setFromPoints([new y(0, 0, 0), new y(0, -1, 0)]);
  constructor(e) {
    this._camera = e;
    const t = new ma(vv.geometry), i = t.material;
    i.color = new se(0.4, 0.4, 0.4), t.layers.set(2), t.name = "line", t.scale.y = 1, this._groundLine = t;
    const n = new Ud(0.5, 22, 22), o = new we({ color: i.color }), r = new G(n, o);
    r.visible = !1, r.layers.set(2), this._groundMarker = r;
  }
  setSelected(e, t) {
    if (this._selected && t)
      for (const i of this._rbs)
        i.wakeUp(), i.setVelocity(0, 0, 0);
    if (this._selected && da.Remove(t, this._selected), this._selected = e, this._context = t, this._rbs.length = 0, e ? (t.scene.add(this._groundLine), t.scene.add(this._groundMarker)) : (this._groundLine.removeFromParent(), this._groundMarker.removeFromParent()), this._selected) {
      if (!t) {
        console.error("DragHelper: no context");
        return;
      }
      da.Add(t, this._selected, null), this._groundOffsetFactor = 0, this._hasGroundPlane = !0, this._groundOffset.set(0, 0, 0), this._requireUpdateGroundPlane = !0, this.onUpdateScreenSpacePlane();
    }
  }
  _groundOffsetVector = new y(0, 1, 0);
  _requireUpdateGroundPlane = !0;
  _didDragOnGroundPlaneLastFrame = !1;
  onUpdate(e) {
    this._selected;
  }
  onUpdateWorldPosition(e, t, i) {
    if (this._selected) {
      if (i) {
        const n = Z(this._selected);
        n.y = e.y, e = n;
      }
      if (Ot(this._selected, e), Ot(this._groundLine, e), this._hasGroundPlane ? this._groundLine.scale.y = this._groundDistance : this._groundLine.scale.y = 1e3, this._groundLine.visible = this.showGizmo, this._groundMarker.visible = t !== null && this.showGizmo, t) {
        const n = Z(this._camera).distanceTo(t) * 0.01;
        this._groundMarker.scale.set(n, n, n), Ot(this._groundMarker, t);
      }
    }
  }
  onUpdateScreenSpacePlane() {
    if (!this._selected || !this._context) return;
    const e = this._context.input.getPointerPositionRC(0);
    e && (this._raycaster.setFromCamera(e, this._camera), this._cameraPlane.setFromNormalAndCoplanarPoint(this._camera.getWorldDirection(this._cameraPlane.normal), this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld)), this._raycaster.ray.intersectPlane(this._cameraPlane, this._intersection) && this._selected.parent && (this._inverseMatrix.copy(this._selected.parent.matrixWorld).invert(), this._cameraPlaneOffset.copy(this._intersection).sub(this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld))));
  }
  onUpdateGroundPlane() {
    if (!this._selected || !this._context) return;
    const e = Z(this._selected), t = new uo(H(0, 0.1, 0).add(e), H(0, -1, 0)), i = new _r();
    i.testObject = (o) => o !== this._selected;
    const n = this._context.physics.raycastFromRay(t, i);
    for (let o = 0; o < n.length; o++) {
      const r = n[o];
      if (!r.face || this.contains(this._selected, r.object))
        continue;
      const a = H(0, 1, 0);
      this._groundPlane.setFromNormalAndCoplanarPoint(a, r.point);
      break;
    }
    this._hasGroundPlane = !0, this._groundPlane.setFromNormalAndCoplanarPoint(t.direction.multiplyScalar(-1), t.origin), this._raycaster.ray.intersectPlane(this._groundPlane, this._intersection), this._groundDistance = this._intersection.distanceTo(e), this._groundOffset.copy(this._intersection).sub(e);
  }
  contains(e, t) {
    if (e === t) return !0;
    if (e.children) {
      for (const i of e.children)
        if (this.contains(i, t)) return !0;
    }
    return !1;
  }
}
var fM = /* @__PURE__ */ ((s) => (s.File_Spawned = "file-spawned", s))(fM || {});
class AL {
  guid;
  file_name;
  file_hash;
  file_size;
  position;
  scale;
  seed;
  sender;
  /** the url to download the file */
  downloadUrl;
  parentGuid;
  boundsSize;
  constructor(e, t, i, n, o, r, a, l, c) {
    this.seed = t, this.guid = i, this.file_name = n, this.file_hash = o, this.file_size = r, this.position = a, this.scale = l, this.sender = e, this.downloadUrl = c;
  }
}
var Go;
((s) => {
  const e = /* @__PURE__ */ new Map();
  function t(n) {
    e.has(n.guid) && i(n.guid);
    const o = new M();
    e.set(n.guid, o);
    const r = new M();
    r.position.y = -0.5, o.add(r);
    const a = new G(new pa(1, 1, 1, 1, 1, 1), new we(
      { color: 14540253, wireframe: !0, transparent: !0, opacity: 0.3 }
    ));
    a.position.y = 0.5, r.add(a);
    const l = new M();
    r.add(l);
    const c = new G(new pa(1, 1, 1, 1, 1, 1), new we({
      color: 12307660,
      transparent: !0,
      opacity: 0.4
    }));
    c.position.y = 0.5, l.scale.y = 0.01, l.add(c);
    const h = new G(new Nn(1, 1, 1, 1), new we({
      color: 34,
      transparent: !0,
      opacity: 0.05,
      depthTest: !1
    }));
    return h.rotateX(-Math.PI / 2), h.position.y = 0.51, c.add(h), n.parent.add(o), o.rotateY(Math.PI / 2), n.position && o.position?.copy(n.position), n.size && (o.worldScale = new y().copy(n.size)), o.position.y = o.scale.y / 2, {
      object: o,
      onProgress: (d) => {
        l instanceof M && l.scale.set(1, d, 1);
      }
    };
  }
  s.addPreview = t;
  function i(n) {
    const o = e.get(n);
    o && (e.delete(n), o.removeFromParent());
  }
  s.removePreview = i;
})(Go || (Go = {}));
const Jr = [], Xh = [];
var A_;
((s) => {
  function e(i, n) {
    const o = { name: n?.name, priority: n?.priority ?? 0, callback: i };
    return Jr.push(o), Jr.sort((r, a) => r.priority === a.priority ? 0 : r.priority > a.priority ? -1 : 1), () => {
      const r = Jr.indexOf(o);
      r >= 0 && Jr.splice(r, 1);
    };
  }
  s.onCreateCustomModelLoader = e;
  function t(i) {
    return Xh.push(i), () => {
      const n = Xh.indexOf(i);
      n >= 0 && Xh.splice(n, 1);
    };
  }
  s.onDetermineModelMimetype = t;
})(A_ || (A_ = {}));
const Jl = w("debugfileformat");
function pM(s) {
  switch ((s.split(".").pop() || s).toUpperCase()) {
    case "GLTF":
      return "model/gltf+json";
    case "VRM":
      return "model/vrm";
    case "GLB":
      return "model/gltf-binary";
    case "FBX":
      return "model/fbx";
    case "USD":
      return "model/vnd.usd+zip";
    case "USDA":
      return "model/vnd.usda+zip";
    case "USDZ":
      return "model/vnd.usdz+zip";
    case "OBJ":
      return "model/obj";
    default:
      return null;
  }
}
async function mM(s, e) {
  const { useExtension: t = !0 } = e;
  if (t) {
    const o = s, r = new URL(o, globalThis.location.href);
    let a = null;
    const l = r.searchParams.get("filetype");
    switch (l && (a = l.toUpperCase()), a?.length || (a = r.pathname.split(".").pop()?.toUpperCase()), Jl && console.warn(`[Needle Engine] Try to use file extension to determine type: '${a}'`), a) {
      case "GLTF":
        return "model/gltf+json";
      case "VRM":
        return "model/vrm";
      case "GLB":
        return "model/gltf-binary";
      case "FBX":
        return "model/fbx";
      case "USD":
        return "model/vnd.usd+zip";
      case "USDA":
        return "model/vnd.usda+zip";
      case "USDZ":
        return "model/vnd.usdz+zip";
      case "OBJ":
        return "model/obj";
    }
  }
  const i = s;
  if (!s.startsWith("blob:")) {
    const o = new URL(s, globalThis.location.href);
    o.searchParams.append("range", "true"), s = o.toString();
  }
  const n = await fetch(s, {
    method: "GET",
    headers: {
      range: "bytes=0-32"
    }
  }).catch((o) => null);
  if (n?.ok) {
    const o = await n.arrayBuffer(), r = gM(i, o, n);
    return Jl && console.log("[Needle Engine] Determined file type from header: " + r), r;
  }
  return "unknown";
}
function gM(s, e, t) {
  if (e.byteLength < 4)
    return "unknown";
  const i = new Uint8Array(e);
  Jl && console.warn(`[Needle Engine] Trying to determine file type from binary data
`, '"' + new TextDecoder().decode(e) + `"
`, i);
  const n = new TextDecoder().decode(e).replace(/\s/g, "");
  if (n[0] === "{" && n[1] === '"')
    return console.debug("GLTF detected"), "model/gltf+json";
  if (i[0] == 103 && i[1] == 108 && i[2] == 84 && i[3] == 70 && (i[4] == 10 || i[4] === 2))
    return console.debug("GLTF .bin detected"), "model/gltf+json";
  if (i[0] == 103 && i[1] == 108 && i[2] == 84 && i[3] == 70 && i[4] == 98)
    return console.debug("GLB detected"), "model/gltf-binary";
  if (i[0] == 80 && i[1] == 75 && i[2] == 3 && i[3] == 4)
    return console.debug("USDZ detected"), "model/vnd.usdz+zip";
  if (i[0] == 80 && i[1] == 88 && i[2] == 82 && i[3] == 45 && i[4] == 85 && i[5] == 83 && i[6] == 68 && i[7] == 67)
    return console.debug("Binary USD detected"), "model/vnd.usd";
  if (i[0] == 35 && i[1] == 117 && i[2] == 115 && i[3] == 100 && i[4] == 97)
    return console.debug("ASCII USD detected"), "model/vnd.usda";
  if (i[0] == 75 && i[1] == 97 && i[2] == 121 && i[3] == 100 && i[4] == 97 && i[5] == 114 && i[6] == 97 && i[7] == 32)
    return console.debug("Binary FBX detected"), "model/fbx";
  if (i[0] == 59 && i[1] == 32 && i[2] == 70 && i[3] == 66 && i[4] == 88 && i[5] == 32)
    return console.debug("ASCII FBX detected"), "model/fbx";
  if (i[0] == 35 && i[1] == 32 && i[2] == 66 && i[3] == 108 && i[4] == 101 && i[5] == 110 && i[6] == 100 && i[7] == 101 && i[8] == 114 && i[9] == 32)
    return console.debug("OBJ detected"), "model/obj";
  if (i[0] == 35 && i[1] == 32 && i[2] == 65 && i[3] == 108 && i[4] == 105 && i[5] == 97 && i[6] == 115 && i[7] == 32 && i[8] == 79 && i[9] == 66 && i[10] == 74)
    return console.debug("OBJ detected"), "model/obj";
  if (t.headers.has("content-type")) {
    const o = t.headers.get("content-type");
    if (o?.startsWith("image/"))
      return console.debug("Image detected, not a model file"), "unsupported";
    switch (console.debug("Content-Type: " + o), o) {
      case "model/gltf+json":
      case "model/gltf-binary":
      case "model/vrm":
      case "model/vnd.usdz+zip":
      case "model/vnd.usd+zip":
      case "model/vnd.usd":
      case "model/vnd.usda+zip":
      case "model/vnd.usda":
      case "model/vnd.usdc":
      case "model/fbx":
      case "model/vnd.autodesk.fbx":
      case "model/obj":
        return o;
    }
  }
  if (i[0] == 118 && i[1] == 32 || i[0] == 102 && i[1] == 32)
    return console.debug("OBJ detected (the file has no header and starts with vertex or face)"), "obj";
  if (i[0] == 35 && i[1] == 32 && i[2] == 70 && i[3] == 105 && i[4] == 108 && i[5] == 101 && i[6] == 32 && i[7] == 101 && i[8] == 120 && i[9] == 112 && i[10] == 111 && i[11] == 114 && i[12] == 116 && i[13] == 101 && i[14] == 100 && i[15] == 32 && i[16] == 98 && i[17] == 121 && i[18] == 32 && i[19] == 90 && i[20] == 66 && i[21] == 114 && i[22] == 117 && i[23] == 115 && i[24] == 104)
    return console.debug("OBJ detected (exported by ZBrush)"), "obj";
  if (i[0] == 109 && i[1] == 116 && i[2] == 108 && i[3] == 108 && i[4] == 105 && i[5] == 98)
    return console.debug("OBJ detected (mtllib)"), "obj";
  for (const o of Xh) {
    const r = o({
      url: s,
      response: t,
      contentType: t.headers.get("content-type"),
      bytes: i
    });
    if (r)
      return Jl && console.debug(`Mimetype callback returned: ${r}`), r;
  }
  if (L() || Jl) {
    const o = new TextDecoder().decode(e.slice(0, Math.min(e.byteLength, 32)));
    console.warn(`Could not determine file type.

Consider registering a custom loader via the 'onCreateCustomModelLoader' callback: 'NeedleEngineModelLoader.onCreateCustomModelLoader(args => { })'

Content-Type: "${t.headers.get("content-type")}
"Text: "${o}"
Binary:`, i);
  } else
    console.debug("Could not determine file type from binary data");
  return "unknown";
}
var yM = Object.defineProperty, Ua = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && yM(e, t, n), n;
};
const hi = w("debugdroplistener");
class _M extends CustomEvent {
  /**
   * Creates a new added event with the provided details
   * @param detail Information about the added object
   */
  constructor(e) {
    super("object-added", { detail: e });
  }
}
const bM = "blob";
class vo extends R {
  dropArea;
  fitIntoVolume = !1;
  fitVolumeSize = new y(1, 1, 1);
  placeAtHitPosition = !0;
  useNetworking = !1;
  onDropped = new ce();
  /**
   * Loads a file from the given URL and adds it to the scene.
   * @returns A promise that resolves to the loaded object or null if loading failed.
   */
  loadFromURL(e, t) {
    return this.addFromUrl(e, { screenposition: new J(), point: t?.point, size: t?.size }, !1);
  }
  /**
   * Forgets all previously added objects.     
   * The droplistener will then not be able to remove previously added objects.
   */
  forgetObjects() {
    this.removePreviouslyAddedObjects(!1);
  }
  // #region internals
  /** @internal */
  onEnable() {
    this.context.renderer.domElement.addEventListener("dragover", this.onDrag), this.context.renderer.domElement.addEventListener("drop", this.onDrop), window.addEventListener("paste", this.handlePaste), this.context.connection.beginListen("droplistener", this.onNetworkEvent);
  }
  /** @internal */
  onDisable() {
    this.context.renderer.domElement.removeEventListener("dragover", this.onDrag), this.context.renderer.domElement.removeEventListener("drop", this.onDrop), window.removeEventListener("paste", this.handlePaste), this.context.connection.stopListen("droplistener", this.onNetworkEvent);
  }
  /**
   * Handles network events received from other clients containing information about dropped objects
   * @param evt Network event data containing object information, position, and content URL
   */
  onNetworkEvent = (e) => {
    if (!this.useNetworking) {
      hi && console.debug("[DropListener] Ignoring networked event because networking is disabled", e);
      return;
    }
    if (e.guid?.startsWith(this.guid)) {
      const t = e.url;
      if (console.debug("[DropListener] Received networked event", e), t)
        if (Array.isArray(t))
          for (const i of t)
            this.addFromUrl(i, { screenposition: new J(), point: e.point, size: e.size }, !0);
        else
          this.addFromUrl(t, { screenposition: new J(), point: e.point, size: e.size }, !0);
    }
  };
  /**
   * Handles clipboard paste events and processes them as potential URL drops
   * Only URLs are processed by this handler, and only when editing is allowed
   * @param evt The paste event
   */
  handlePaste = (e) => {
    if (this.context.connection.allowEditing === !1 || e.defaultPrevented) return;
    navigator.clipboard.readText().then((i) => {
      if (i && (i.startsWith("http") || i.startsWith("https") || i.startsWith("blob"))) {
        const o = { screenposition: new J(this.context.input.mousePosition.x, this.context.input.mousePosition.y) };
        this.testIfIsInDropArea(o) && this.addFromUrl(i, o, !1);
      }
    }).catch(console.warn);
  };
  /**
   * Handles drag events over the renderer's canvas
   * Prevents default behavior to enable drop events
   * @param evt The drag event
   */
  onDrag = (e) => {
    this.context.connection.allowEditing !== !1 && e.preventDefault();
  };
  /**
   * Processes drop events to add files to the scene
   * Handles both file drops and text/URL drops
   * @param evt The drop event
   */
  onDrop = async (e) => {
    if (this.context.connection.allowEditing === !1 || (hi && console.log(e), !e?.dataTransfer) || e["droplistener:handled"]) return;
    e.preventDefault();
    const t = { screenposition: new J(e.offsetX, e.offsetY) };
    if (this.dropArea && this.testIfIsInDropArea(t) === !1)
      return;
    e["droplistener:handled"] = !0;
    const i = e.dataTransfer.items;
    if (!i) return;
    const n = [];
    for (const o in i) {
      const r = i[o];
      if (r.kind === "file") {
        const a = r.getAsFile();
        if (!a) continue;
        n.push(a);
      } else r.kind === "string" && r.type == "text/plain" && r.getAsString((a) => {
        this.addFromUrl(a, t, !1);
      });
    }
    n.length > 0 && await this.addFromFiles(n, t);
  };
  /**
   * Processes a dropped or pasted URL and tries to load it as a 3D model
   * Handles special cases like GitHub URLs and Polyhaven asset URLs
   * @param url The URL to process
   * @param ctx Context information about where the drop occurred
   * @param isRemote Whether this URL was shared from a remote client
   * @returns The added object or null if loading failed
   */
  async addFromUrl(e, t, i) {
    hi && console.log("dropped url", e);
    try {
      if (e.startsWith("https://github.com/")) {
        const r = e.split("/"), a = r[3], l = r[4], c = r[6], h = r.slice(7).join("/");
        e = `https://raw.githubusercontent.com/${a}/${l}/${c}/${h}`;
      } else e.startsWith("https://polyhaven.com/a") && (e = vM(e));
      if (!e) return null;
      const n = e.toLowerCase();
      if (n.endsWith(".hdr") || n.endsWith(".hdri") || n.endsWith(".exr") || n.endsWith(".png") || n.endsWith(".jpg") || n.endsWith(".jpeg"))
        return console.warn(`Fileformat is not supported: ${n}`), null;
      this.removePreviouslyAddedObjects();
      const o = await Pd.loadFileFromURL(new URL(e), {
        guid: this.guid,
        context: this.context,
        parent: this.gameObject,
        point: t.point,
        size: t.size
      });
      if (o && this._addedObjects.length <= 0)
        return t.url = e, this.onObjectLoaded(o, t, i);
    } catch {
      console.warn("String is not a valid URL", e);
    }
    return null;
  }
  _abort = null;
  /**
   * Processes dropped files and loads them as 3D models.
   * When enabled, it also handles network drops (sending files between clients).
   * Automatically handles cancelling previous uploads if new files are dropped.
   * @param fileList Array of dropped files
   * @param ctx Context information about where on the screen or in 3D space the drop occurred
   */
  async addFromFiles(e, t) {
    if (hi && console.log("Add files", e), !!Array.isArray(e) && e.length) {
      this.deleteDropEvent(), this.removePreviouslyAddedObjects(), rd(bM, null), this._abort?.abort("New files dropped"), this._abort = new AbortController();
      for (const i of e) {
        if (!i) continue;
        if (i.type.startsWith("image/")) {
          hi && console.warn("Ignoring dropped image file", i.name, i.type);
          continue;
        } else if (i.name.endsWith(".bin")) {
          hi && console.warn("Ignoring dropped binary file", i.name, i.type);
          continue;
        }
        console.debug("Load file " + i.name + " + " + i.type);
        const n = await Pd.loadFile(i, this.context, { guid: this.guid });
        if (n) {
          this.dispatchEvent(new CustomEvent("file-dropped", { detail: i })), t.file = i;
          const o = this.onObjectLoaded(n, t, !1);
          o && this.context.connection.isConnected && this.useNetworking && (console.debug("Uploading dropped file to blob storage"), Ma.upload(i, { abort: this._abort?.signal }).then((r) => {
            r?.download_url && this._addedObjects.includes(o) && this.sendDropEvent(r.download_url, o, n.contentMD5);
          }).catch(console.warn));
          break;
        }
      }
    }
  }
  /** Previously added objects */
  _addedObjects = new Array();
  _addedModels = new Array();
  /**
   * Removes all previously added objects from the scene
   * @param doDestroy When true, destroys the objects; when false, just clears the references
   */
  removePreviouslyAddedObjects(e = !0) {
    if (e)
      for (const t of this._addedObjects)
        t.parent === this.gameObject && Gi(t, !0, !0);
    this._addedObjects.length = 0, this._addedModels.length = 0;
  }
  /**
   * Adds a loaded model to the scene with proper positioning and scaling.
   * Handles placement based on component settings and raycasting.
   * If {@link fitIntoVolume} is enabled, the object will be scaled to fit within the volume defined by {@link fitVolumeSize}.
   * @param data The loaded model data and content hash
   * @param ctx Context information about where the drop occurred
   * @param isRemote Whether this object was shared from a remote client
   * @returns The added object or null if adding failed
   */
  onObjectLoaded(e, t, i) {
    const { model: n, contentMD5: o } = e;
    if (hi && console.log(`Dropped ${this.gameObject.name}`, n), !n?.scene)
      return console.warn("No object specified to add to scene", n), null;
    this.removePreviouslyAddedObjects();
    const r = n.scene;
    this.gameObject.attach(r), r.position.set(0, 0, 0), r.quaternion.identity(), this._addedObjects.push(r), this._addedModels.push(n);
    const a = new bi().setFromCenterAndSize(new y(0, this.fitVolumeSize.y * 0.5, 0).add(this.gameObject.worldPosition), this.fitVolumeSize);
    if (hi && z.DrawWireBox3(a, 255, 5), this.fitIntoVolume && o1(r, a, {
      position: !this.placeAtHitPosition
    }), this.placeAtHitPosition && t && t.screenposition) {
      r.visible = !1;
      const c = this.context.physics.raycast({ screenPoint: this.context.input.convertScreenspaceToRaycastSpace(t.screenposition.clone()) });
      if (r.visible = !0, c && c.length > 0)
        for (const h of c) {
          const d = h.point.clone();
          hi && console.log("Place object at hit", h), r1(r, d);
          break;
        }
    }
    mc.autoplayAnimations(n);
    const l = new _M({
      sender: this,
      gltf: n,
      model: n,
      object: r,
      contentMD5: o,
      dropped: t.file || (t.url ? new URL(t.url) : void 0)
    });
    return this.dispatchEvent(l), this.onDropped?.invoke(l.detail), !i && t.url?.startsWith("http") && this.context.connection.isConnected && r && this.sendDropEvent(t.url, r, o), r;
  }
  /**
   * Sends a network event to other clients about a dropped object
   * Only triggered when networking is enabled and the connection is established
   * @param url The URL to the content that was dropped
   * @param obj The object that was added to the scene
   * @param contentmd5 The content hash for verification
   */
  async sendDropEvent(e, t, i) {
    if (!this.useNetworking) {
      hi && console.debug("[DropListener] Ignoring networked event because networking is disabled", e);
      return;
    }
    if (this.context.connection.isConnected) {
      console.debug('Sending drop event "' + t.name + '"', e);
      const n = ii([t]), o = {
        name: t.name,
        guid: this.guid,
        url: e,
        point: t.worldPosition.clone(),
        size: n.getSize(new y()),
        contentMD5: i
      };
      this.context.connection.send("droplistener", o);
    }
  }
  /**
   * Deletes remote state for this DropListener's objects
   * Called when new files are dropped to clean up previous state
   */
  deleteDropEvent() {
    this.context.connection.sendDeleteRemoteState(this.guid);
  }
  /**
   * Tests if a drop event occurred within the designated drop area if one is specified
   * @param ctx The drop context containing screen position information
   * @returns True if the drop is valid (either no drop area is set or the drop occurred inside it)
   */
  testIfIsInDropArea(e) {
    if (this.dropArea) {
      const t = this.context.input.convertScreenspaceToRaycastSpace(e.screenposition.clone());
      if (!this.context.physics.raycast({
        targets: [this.dropArea],
        screenPoint: t,
        recursive: !0,
        testObject: (n) => !this._addedObjects.includes(n)
      }).length)
        return L() && console.log(`Dropped outside of drop area for DropListener "${this.name}".`), !1;
    }
    return !0;
  }
}
Ua([
  u(M)
], vo.prototype, "dropArea");
Ua([
  u()
], vo.prototype, "fitIntoVolume");
Ua([
  u(y)
], vo.prototype, "fitVolumeSize");
Ua([
  u()
], vo.prototype, "placeAtHitPosition");
Ua([
  u()
], vo.prototype, "useNetworking");
Ua([
  u(ce)
], vo.prototype, "onDropped");
function vM(s) {
  if (!s.startsWith("https://polyhaven.com/")) return s;
  const e = "https://dl.polyhaven.org/file/ph-assets/Models/gltf/4k/", n = new URL(s).pathname.split("/").pop(), o = `${e}${n}/${n}_4k.gltf`;
  return console.log("Resolved polyhaven asset url", s, "→", o), o;
}
var Pd;
((s) => {
  async function e(i, n, o) {
    const r = o.guid, a = new At(r), l = new Blob([i], { type: i.type || pM(i.name) || void 0 }), c = URL.createObjectURL(l), h = await Bn().loadSync(n, c, i.name, a).catch((d) => (console.error(`Failed to load file "${i.name}" (${i.type}):`, d), null));
    return URL.revokeObjectURL(c), h ? new Promise((d, f) => {
      const p = new FileReader();
      p.readAsArrayBuffer(i), p.onloadend = async (g) => {
        const b = p.result, m = Ma.hashMD5(b);
        return d({ model: h, contentMD5: m });
      };
    }) : (console.warn(`Failed to load "${i.name}" (${i.type})`), null);
  }
  s.loadFile = e;
  async function t(i, n) {
    return new Promise(async (o, r) => {
      const a = new At(n.guid), l = i.toString();
      hi && z.DrawWireSphere(n.point, 0.1, 16711680, 3);
      const c = Go.addPreview({
        guid: n.guid,
        parent: n.parent,
        position: n?.point,
        size: n?.size
      }), h = await Bn().loadSync(n.context, l, l, a, (d) => {
        c.onProgress(d.loaded / d.total);
      }).catch(console.warn);
      if (h) {
        const d = await fetch(l).then((p) => p.arrayBuffer()), f = Ma.hashMD5(d);
        hi ? setTimeout(() => Go.removePreview(n.guid), 3e3) : Go.removePreview(n.guid), o({ model: h, contentMD5: f });
      } else
        hi ? setTimeout(() => Go.removePreview(n.guid), 3e3) : Go.removePreview(n.guid), console.warn("Unsupported file type: " + i.toString());
    });
  }
  s.loadFileFromURL = t;
})(Pd || (Pd = {}));
var wM = Object.defineProperty, mg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && wM(e, t, n), n;
};
const gu = class wv extends R {
  parent = null;
  object = null;
  limitCount = 60;
  _currentCount = 0;
  _startPosition = null;
  _startQuaternion = null;
  start() {
    if (this._currentCount = 0, this._startPosition = null, this._startQuaternion = null, this.object || (this.object = this.gameObject), this.object) {
      if (this.object === this.gameObject) {
        const t = new At(this.guid);
        this.object = S.instantiate(this.object, { idProvider: t, keepWorldPosition: !1 }), S.getComponent(this.object, wv)?.destroy();
        let n = this.object.getComponentInChildren(Zr);
        n || (n = this.object.addComponent(Zr, {
          dragMode: bv.SnapToSurfaces
        }), n.guid = t.generateUUID());
        let o = S.getComponent(n.gameObject, zn);
        o || (o = n.gameObject.addComponent(zn), o.guid = t.generateUUID());
      }
      this.object.visible = !1;
      const e = this.gameObject.getComponent(Zr);
      e && (e.enabled = !1), this._startPosition = this.object.position?.clone() ?? new y(0, 0, 0), this._startQuaternion = this.object.quaternion?.clone() ?? new U(0, 0, 0, 1);
    }
    this.gameObject.getComponentInParent(qi) || this.gameObject.addComponent(qi);
  }
  onEnable() {
    this.startCoroutine(this.cloneLimitIntervalFn());
  }
  _forwardPointerEvents = /* @__PURE__ */ new Map();
  onPointerEnter(e) {
    e.used || this.object && this.context.connection.allowEditing && e.button === 0 && this.context.input.setCursor("pointer");
  }
  onPointerExit(e) {
    e.used || this.object && this.context.connection.allowEditing && e.button === 0 && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerDown(e) {
    if (e.used || !this.object || !this.context.connection.allowEditing || e.button !== 0) return;
    const t = this.handleDuplication();
    if (t) {
      const i = S.getComponent(t, Zr);
      i ? (i.onPointerDown(e), this._forwardPointerEvents.set(e.event.space, i)) : L() && console.warn(`Duplicated object (${t.name}) does not have DragControls`);
    } else
      this._currentCount >= this.limitCount ? console.warn(`[Duplicatable] Limit of ${this.limitCount} objects created within a few seconds reached. Please wait a moment before creating more objects.`) : console.warn("[Duplicatable] Could not duplicate object.");
  }
  /** @internal */
  onPointerUp(e) {
    if (e.used) return;
    const t = this._forwardPointerEvents.get(e.event.space);
    t && (t.onPointerUp(e), this._forwardPointerEvents.delete(e.event.space));
  }
  *cloneLimitIntervalFn() {
    for (; this.activeAndEnabled && !this.destroyed; )
      this._currentCount > 0 ? this._currentCount -= 1 : this._currentCount < 0 && (this._currentCount = 0), yield q0(1);
  }
  handleDuplication() {
    if (!this.object || this.limitCount > 0 && this._currentCount >= this.limitCount || this.object === this.gameObject) return null;
    if (S.isDestroyed(this.object))
      return this.object = null, null;
    this.object.visible = !0, this._startPosition && this.object.position.copy(this._startPosition), this._startQuaternion && this.object.quaternion.copy(this._startQuaternion);
    const e = new $n();
    this.parent || (this.parent = this.gameObject.parent), this.parent && (e.parent = this.parent.guid ?? this.parent.userData?.guid, e.keepWorldPosition = !0), e.position = this.worldPosition, e.rotation = this.worldQuaternion, e.context = this.context, this._currentCount += 1;
    const t = S.instantiateSynced(this.object, e);
    return console.assert(t !== this.object, "Duplicated object is original"), this.object.visible = !1, this._startPosition && this.object.position.clone().copy(this._startPosition), this._startQuaternion && this.object.quaternion.clone().copy(this._startQuaternion), t;
  }
};
mg([
  u(M)
], gu.prototype, "parent");
mg([
  u(M)
], gu.prototype, "object");
mg([
  u()
], gu.prototype, "limitCount");
let xv = gu;
var ss = /* @__PURE__ */ ((s) => (s[s.PointerEnter = 0] = "PointerEnter", s[s.PointerExit = 1] = "PointerExit", s[s.PointerDown = 2] = "PointerDown", s[s.PointerUp = 3] = "PointerUp", s[s.PointerClick = 4] = "PointerClick", s[s.Drag = 5] = "Drag", s[s.Drop = 6] = "Drop", s[s.Scroll = 7] = "Scroll", s[s.UpdateSelected = 8] = "UpdateSelected", s[s.Select = 9] = "Select", s[s.Deselect = 10] = "Deselect", s[s.Move = 11] = "Move", s[s.InitializePotentialDrag = 12] = "InitializePotentialDrag", s[s.BeginDrag = 13] = "BeginDrag", s[s.EndDrag = 14] = "EndDrag", s[s.Submit = 15] = "Submit", s[s.Cancel = 16] = "Cancel", s))(ss || {}), xM = Object.defineProperty, gg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && xM(e, t, n), n;
};
class yg {
  eventID;
  callback = new ce();
}
gg([
  u()
], yg.prototype, "eventID");
gg([
  u(ce)
], yg.prototype, "callback");
class _g extends R {
  triggers = [];
  /** @internal */
  invoke(e) {
    if (this.triggers)
      for (const t of this.triggers)
        t.eventID === e && t.callback?.invoke();
  }
  hasTrigger(e) {
    return this.triggers?.some((t) => t.eventID === e) ?? !1;
  }
  shouldChangeCursor() {
    return this.hasTrigger(ss.PointerClick) || this.hasTrigger(ss.PointerDown) || this.hasTrigger(ss.PointerUp);
  }
  /** @internal */
  onPointerClick(e) {
    this.invoke(ss.PointerClick);
  }
  /** @internal */
  onPointerEnter(e) {
    this.shouldChangeCursor() && this.context.input.setCursor("pointer"), this.invoke(ss.PointerEnter);
  }
  /** @internal */
  onPointerExit(e) {
    this.shouldChangeCursor() && this.context.input.unsetCursor("pointer"), this.invoke(ss.PointerExit);
  }
  /** @internal */
  onPointerDown(e) {
    this.invoke(ss.PointerDown);
  }
  /** @internal */
  onPointerUp(e) {
    this.invoke(ss.PointerUp);
  }
}
gg([
  u(yg)
], _g.prototype, "triggers");
class Sv {
  writer;
  constructor(e) {
    this.writer = e;
  }
  writeNode(e) {
  }
}
class SM extends Sv {
  beforeWriteNode(e, t) {
    z.isGizmo(e) && (t.keep = !1);
  }
}
class Cv extends Sv {
  beforeWriteTexture(e, t) {
    e.isRenderTargetTexture && (t.newTexture = Zm(new oe(1, 1, 1, 0)));
  }
}
function qp(s) {
  const e = lg.DontExport;
  return !(s.hideFlags & e);
}
const jf = w("debugexr");
class CM {
  get name() {
    return "EXT_texture_exr";
  }
  parser;
  constructor(e) {
    this.parser = e, jf && console.log(e);
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, o = i.json.textures[e];
    if (jf && console.log("EXT_texture_exr.loadTexture", e, o), !o.extensions || !o.extensions[t])
      return null;
    const r = o.extensions[t], a = new Rm(i.options.manager);
    return jf && console.log("EXT_texture_exr.loadTexture", r), i.loadTextureImage(e, r.source, a);
  }
}
typeof window < "u" && window.addEventListener("unhandledrejection", (s) => {
});
const es = pt, _h = "$___Export_Components", PM = "NEEDLE_components";
class OM {
  [$r];
}
class kM {
  node;
  nodeIndex;
  nodeDef;
  constructor(e, t, i) {
    this.node = e, this.nodeIndex = t, this.nodeDef = i;
  }
}
class Pv {
  get name() {
    return PM;
  }
  // import
  parser;
  nodeToObjectMap = {};
  /** The loaded gltf */
  gltf = null;
  // export
  exportContext;
  objectToNodeMap = {};
  context;
  writer;
  registerExport(e) {
    e.register((t) => {
      if ("serializeUserData" in t) {
        const i = t.serializeUserData.bind(t);
        this.writer = t, t.serializeUserData = (n, o) => {
          try {
            this.serializeUserData(n, o) && (t.extensionsUsed[this.name] = !0), i(n, o);
          } finally {
            this.afterSerializeUserData(n, o);
          }
        };
      }
      return this;
    });
  }
  beforeParse() {
    this.exportContext = {}, this.objectToNodeMap = {};
  }
  // https://github.com/mrdoob/three.js/blob/efbfc67edc7f65cfcc61a389ffc5fd43ea702bc6/examples/jsm/exporters/GLTFExporter.js#L532
  serializeUserData(e, t) {
    const i = e.userData?.components;
    return !i || i.length <= 0 ? !1 : (delete e.userData.components, e[_h] = i, !0);
  }
  afterSerializeUserData(e, t) {
    if (e.type === "Scene" && es && console.log("DONE", JSON.stringify(t)), e[_h] === void 0) return;
    const i = e[_h];
    delete e[_h], i !== null && (e.userData.components = i);
  }
  writeNode(e, t) {
    const i = this.writer.json.nodes.length;
    es && console.log(e.name, i, e.uuid);
    const n = new kM(e, i, t);
    this.exportContext[i] = n, this.objectToNodeMap[e.uuid] = i;
  }
  afterParse(e) {
    es && console.log("AFTER", e);
    for (const t in this.exportContext) {
      const i = this.exportContext[t], n = i.node, o = i.nodeDef, r = i.nodeIndex, a = n.userData?.components;
      if (!a || a.length <= 0) continue;
      const l = new OM();
      o.extensions = o.extensions || {}, o.extensions[this.name] = l, this.context.object = n, this.context.nodeId = r, this.context.objectToNode = this.objectToNodeMap;
      const c = [];
      for (const h of a) {
        this.context.target = h;
        const d = Bn().writeBuiltinComponentData(h, this.context);
        d !== null && c.push(d);
      }
      c.length > 0 && (l[$r] = c, es && console.log("DID WRITE", n, "nodeIndex", r, c));
    }
  }
  // -------------------------------------
  // LOADING 
  // called by GLTFLoader
  beforeRoot() {
    return es && console.log("BEGIN LOAD"), this.nodeToObjectMap = {}, null;
  }
  // called by GLTFLoader
  async afterRoot(e) {
    this.gltf = e;
    const t = e.parser, i = t?.extensions;
    if (!i) return;
    const n = i[this.name];
    es && console.log("After root", e, this.parser, i);
    const o = [];
    if (n === !0) {
      const r = t.json.nodes;
      if (r) {
        for (let a = 0; a < r.length; a++) {
          const l = await t.getDependency("node", a);
          this.nodeToObjectMap[a] = l;
        }
        for (let a = 0; a < r.length; a++) {
          const l = r[a], c = a, h = l.extensions;
          if (!h) continue;
          const d = h[this.name];
          if (!d) continue;
          es && console.log("NODE", l);
          const f = this.nodeToObjectMap[c];
          if (!f) {
            console.error("Could not find object for node index: " + c, l, t);
            continue;
          }
          Qm(f), o.push(this.createComponents(f, d));
        }
      }
    }
    await Promise.all(o);
    for (const r of t.associations.keys()) {
      const a = t.associations.get(r);
      if (a?.materials != null) {
        const l = "/materials/" + a.materials;
        RP(r, l);
      }
    }
  }
  async createComponents(e, t) {
    if (!t) return;
    const i = t[$r];
    if (i) {
      const n = new Array();
      es && console.log(e.name, i);
      for (const o in i) {
        const r = i[o];
        es && console.log("Serialized data", JSON.parse(JSON.stringify(r))), r && this.parser && n.push(
          qm(this.parser, r).catch((a) => console.error(`Error while resolving references (see console for details)
`, a, e, r))
        ), e.userData = e.userData || {}, e.userData[$r] = e.userData[$r] || [], e.userData[$r].push(r);
      }
      await Promise.all(n).catch((o) => {
        console.error("Error while loading components", o);
      });
    }
  }
  // parse function https://github.com/mrdoob/three.js/blob/efbfc67edc7f65cfcc61a389ffc5fd43ea702bc6/examples/jsm/loaders/GLTFLoader.js#L2290
  // createNodeAttachment(nodeIndex: number): null {
  //     // if(!this.parser){
  //     //     console.error("Parser not set, call registerLoad with on this");
  //     //     return null;
  //     // }
  //     // const node = this.parser.json.nodes[nodeIndex];
  //     // const extenstions = node.extensions;
  //     // const data = extenstions && extenstions[this.name];
  //     // if (!data) return null;
  //     // const components = data[builtinComponentKeyName];
  //     // if (!components) return null;
  //     // console.log(components);
  //     return null;
  // }
}
const I_ = "NEEDLE_gameobject_data";
class MM {
  get name() {
    return I_;
  }
  parser;
  constructor(e) {
    this.parser = e;
  }
  // private _lastIndex: number = -1;
  // createNodeAttachment(index): null {
  //     if (index === this._lastIndex) return null;
  //     this._lastIndex = index;
  //     const node = this.parser.json.nodes[index];
  //     if (node && node.extensions) {
  //         const ext = node.extensions[EXTENSION_NAME];
  //         if (ext)
  //             this.findAndApplyExtensionData(index, ext);
  //     }
  //     return null;
  // }
  // private lastIndex: number = -1;
  afterRoot(e) {
    const t = [];
    for (let i = 0; i < this.parser.json.nodes?.length; i++) {
      const n = this.parser.json.nodes[i];
      if (n && n.extensions) {
        const o = n.extensions[I_];
        if (o) {
          const r = this.findAndApplyExtensionData(i, o);
          t.push(r);
        }
      }
    }
    return Promise.all(t).then(() => null);
  }
  async findAndApplyExtensionData(e, t) {
    const i = await this.parser.getDependency("node", e);
    i && this.applyExtensionData(i, t);
  }
  applyExtensionData(e, t) {
    t.layers === void 0 && (t.layers = 0), e.userData.layer = t.layers, e.layers.disableAll(), e.layers.set(t.layers), e.userData.tag = t.tag ?? "none", e.hideFlags = 0, e.userData.static = t.static ?? !1, e.visible = t.activeSelf ?? !0, e.guid = t.guid;
  }
}
const L_ = "NEEDLE_lighting_settings", Gr = w("debugenvlight");
class RM {
  get name() {
    return L_;
  }
  parser;
  sourceId;
  context;
  constructor(e, t, i) {
    this.parser = e, this.sourceId = t, this.context = i;
  }
  afterRoot(e) {
    const t = this.parser.json.extensions;
    if (t) {
      const i = t[L_];
      if (i) {
        Gr && console.log('Loaded "' + this.name + '", src: "' + this.sourceId + '"', i);
        let n;
        if (e.scene.children.length === 1) {
          const o = e.scene.children[0];
          n = S.addComponent(o, Xp, {}, { callAwake: !1 });
        } else {
          const o = new M();
          o.name = "LightSettings " + this.sourceId, e.scene.add(o), n = S.addComponent(o, Xp, {}, { callAwake: !1 });
        }
        n.sourceId = this.sourceId, n.ambientIntensity = i.ambientIntensity, n.ambientLight = new se().fromArray(i.ambientLight), Array.isArray(i.ambientTrilight) && (n.ambientTrilight = i.ambientTrilight.map((o) => new se().fromArray(o))), n.ambientMode = i.ambientMode, n.environmentReflectionSource = i.environmentReflectionSource;
      }
    }
    return null;
  }
}
ue.registerCallback(he.ContextCreated, (s) => {
  const e = s.context, t = S.findObjectOfType(Xp, e);
  t?.sourceId && (t.enabled = !0);
});
class Xp extends R {
  ambientMode = Ql.Skybox;
  ambientLight;
  ambientTrilight;
  ambientIntensity = 1;
  environmentReflectionSource = Fp.Skybox;
  _hasReflection = !1;
  _ambientLightObj;
  _hemisphereLightObj;
  awake() {
    if (this.sourceId) {
      const t = this.environmentReflectionSource === Fp.Skybox ? Sn.Skybox : Sn.Reflection, i = this.context.lightmaps.tryGet(this.sourceId, t, 0);
      this._hasReflection = i != null, i && this.context.sceneLighting.internalRegisterReflection(this.sourceId, i);
    }
    this.enabled = !1, this.context.sceneLighting.internalRegisterSceneLightSettings(this), Gr && window.addEventListener("keydown", (t) => {
      if (!this.destroyed)
        switch (t.key) {
          case "l":
            this.enabled = !this.enabled;
            break;
        }
    });
    const e = this.gameObject.userData?.components;
    if (e) {
      const t = e.indexOf(this);
      e.splice(t, 1), e.push(this);
    }
  }
  onDestroy() {
    this.context.sceneLighting.internalUnregisterSceneLightSettings(this);
  }
  calculateIntensityFactor(e) {
    const t = Math.max(e.r, e.g, e.b);
    return 2.2 * j.lerp(0, 1.33, t);
  }
  onEnable() {
    if (Gr && console.warn("💡🟡 >>> Enable lighting", this.sourceId, this.enabled, this), this.ambientMode == Ql.Flat) {
      if (this.ambientLight && !this._ambientLightObj) {
        const e = this.calculateIntensityFactor(this.ambientLight);
        this._ambientLightObj = new Ex(this.ambientLight, this.ambientIntensity * e), Gr && console.log("Created ambient light", this.sourceId, this._ambientLightObj, this.ambientIntensity, e);
      }
      this._ambientLightObj && this.gameObject.add(this._ambientLightObj);
    } else if (this.ambientMode === Ql.Trilight) {
      if (this.ambientTrilight) {
        const e = this.ambientTrilight[0], t = this.ambientTrilight[this.ambientTrilight.length - 1], i = this.calculateIntensityFactor(t);
        this._hemisphereLightObj = new Ax(t, e, this.ambientIntensity * i), this.gameObject.add(this._hemisphereLightObj), Gr && console.log("Created hemisphere ambient light", this.sourceId, this._hemisphereLightObj, this.ambientIntensity, i);
      }
    } else
      this._ambientLightObj && this._ambientLightObj.removeFromParent(), this._hemisphereLightObj && this._hemisphereLightObj.removeFromParent();
    this.sourceId && (this.context.domElement.getAttribute("environment-image") || this.context.sceneLighting.internalEnableReflection(this.sourceId));
  }
  onDisable() {
    Gr && console.warn("💡⚫ <<< Disable lighting:", this.sourceId, this), this._ambientLightObj && this._ambientLightObj.removeFromParent(), this._hemisphereLightObj && this._hemisphereLightObj.removeFromParent(), this.sourceId && this.context.sceneLighting.internalDisableReflection(this.sourceId);
  }
}
const Bf = w("debugstencil");
function TM(s, e) {
  return (s & 1 << e.layer) != 0;
}
const EM = Symbol("stencils");
class Zs {
  get name() {
    return "NEEDLE_render_objects";
  }
  static stencils = {};
  static applyStencil(e) {
    if (!e) return;
    const t = e.sourceId;
    if (Bf && console.log(t, Zs.stencils), !t) return;
    const i = Zs.stencils[t];
    if (i)
      for (let n = i.length - 1; n >= 0; n--) {
        const o = i[n];
        if (TM(o.layer, e)) {
          Bf && console.log(o), setTimeout(() => {
            hn() && Ym(e.gameObject) && (ge("Stencil not supported on instanced objects"), console.warn("Stencil not supported on instanced objects", e));
          }, 500);
          for (let r = 0; r < e.sharedMaterials.length; r++) {
            let a = e.sharedMaterials[r];
            a && (a = a.clone(), a[EM] = !0, a.stencilWrite = !0, a.stencilWriteMask = 255, a.stencilFuncMask = 255, a.stencilRef = o.value, a.stencilFunc = o.compareFunc, a.stencilZPass = o.passOp, a.stencilFail = o.failOp, a.stencilZFail = o.zFailOp, e.sharedMaterials[r] = a);
          }
          e.gameObject.renderOrder = o.event * 1e3 + o.index * 50;
          break;
        }
      }
  }
  parser;
  source;
  constructor(e, t) {
    this.parser = e, this.source = t;
  }
  afterRoot(e) {
    const t = this.parser.json.extensions;
    if (t) {
      const i = t[IM];
      if (i) {
        Bf && console.log(i);
        const n = i.stencil;
        if (n && Array.isArray(n))
          for (const o of n) {
            const r = { ...o };
            r.compareFunc = AM(r.compareFunc), r.passOp = Ff(r.passOp), r.failOp = Ff(r.failOp), r.zFailOp = Ff(r.zFailOp), Zs.stencils[this.source] || (Zs.stencils[this.source] = []), Zs.stencils[this.source].push(r);
          }
      }
    }
    return null;
  }
}
function Ff(s) {
  switch (s) {
    case 0:
      return qx;
    case 1:
      return Gx;
    case 2:
      return Hx;
    case 3:
      return Vx;
    case 4:
      return Wx;
    case 6:
      return $x;
    case 7:
      return Nx;
    case 5:
      return Ux;
  }
  return 0;
}
function AM(s) {
  switch (s) {
    case 1:
      return ly;
    case 2:
      return zx;
    case 3:
      return Fx;
    case 4:
      return Bx;
    case 5:
      return jx;
    case 6:
      return Dx;
    case 7:
      return Lx;
    case 8:
      return Ix;
  }
  return ly;
}
const IM = "NEEDLE_render_objects";
var Ov = /* @__PURE__ */ ((s) => (s[s.INT = 5124] = "INT", s[s.FLOAT = 5126] = "FLOAT", s[s.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", s[s.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", s[s.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", s[s.INT_VEC2 = 35667] = "INT_VEC2", s[s.INT_VEC3 = 35668] = "INT_VEC3", s[s.INT_VEC4 = 35669] = "INT_VEC4", s[s.BOOL = 35670] = "BOOL", s[s.BOOL_VEC2 = 35671] = "BOOL_VEC2", s[s.BOOL_VEC3 = 35672] = "BOOL_VEC3", s[s.BOOL_VEC4 = 35673] = "BOOL_VEC4", s[s.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", s[s.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", s[s.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", s[s.SAMPLER_2D = 35678] = "SAMPLER_2D", s[s.SAMPLER_3D = 35680] = "SAMPLER_3D", s[s.SAMPLER_CUBE = 35681] = "SAMPLER_CUBE", s[s.UNKNOWN = 0] = "UNKNOWN", s))(Ov || {});
const vn = w("debugcustomshader"), Dr = "NEEDLE_techniques_webgl";
class LM {
  objectToWorldMatrix = new ee();
  worldToObjectMatrix = new ee();
  objectToWorld = new Array();
  worldToObject = new Array();
  updateFrom(e) {
    this.objectToWorldMatrix.copy(e.matrixWorld), _d(this.objectToWorldMatrix, this.objectToWorld), this.worldToObjectMatrix.copy(e.matrixWorld).invert(), _d(this.worldToObjectMatrix, this.worldToObject);
  }
}
class Me extends Tb {
  identifier;
  onBeforeRenderSceneCallback = this.onBeforeRenderScene.bind(this);
  clone() {
    const e = super.clone();
    return kv(e), e;
  }
  constructor(e, ...t) {
    super(...t), this.identifier = e, vn && console.log(this), this.type = "NEEDLE_CUSTOM_SHADER", this.uniforms[this._objToWorldName] || (this.uniforms[this._objToWorldName] = { value: [] }), this.uniforms[this._worldToObjectName] || (this.uniforms[this._worldToObjectName] = { value: [] }), this.uniforms[this._viewProjectionName] || (this.uniforms[this._viewProjectionName] = { value: [] }), this.uniforms[this._sphericalHarmonicsName], (this.depthTextureUniform || this.opaqueTextureUniform) && N.Current.pre_render_callbacks.push(this.onBeforeRenderSceneCallback);
  }
  dispose() {
    super.dispose();
    const e = N.Current.pre_render_callbacks.indexOf(this.onBeforeRenderSceneCallback);
    e >= 0 && N.Current.pre_render_callbacks.splice(e, 1);
  }
  /* REMOVED, we don't have Lit shader support for now
  async waitForLighting() {
      const context: Context = Context.Current;
      if (!context) {
          console.error("Missing context");
          return;
      }
      const data = await context.sceneLighting.internalGetSceneLightingData(this.identifier);
      if (!data || !data.array) {
          console.warn("Missing lighting data for custom shader, getSceneLightingData did not return anything");
          return;
      }
      if (debug)
          console.log(data);
      const array = data.array;
      const envTexture = data.texture;
      // console.log(envTexture);
      this.uniforms["unity_SpecCube0"] = { value: envTexture };
      SetUnitySphericalHarmonics(this.uniforms, array);
      const hdr = Math.sqrt(Math.PI * .5);
      this.uniforms["unity_SpecCube0_HDR"] = { value: new Vector4(hdr, hdr, hdr, hdr) };
      // this.needsUpdate = true;
      // this.uniformsNeedUpdate = true;
      if (debug) console.log("Set environment lighting", this.uniforms);
  }
  */
  _sphericalHarmonicsName = "unity_SpecCube0";
  _objToWorldName = "hlslcc_mtx4x4unity_ObjectToWorld";
  _worldToObjectName = "hlslcc_mtx4x4unity_WorldToObject";
  static viewProjection = new ee();
  static _viewProjectionValues = [];
  _viewProjectionName = "hlslcc_mtx4x4unity_MatrixVP";
  static viewMatrix = new ee();
  static _viewMatrixValues = [];
  _viewMatrixName = "hlslcc_mtx4x4unity_MatrixV";
  static _worldSpaceCameraPosName = "_WorldSpaceCameraPos";
  static _worldSpaceCameraPos = new y();
  static _mainLightColor = new fe();
  static _mainLightPosition = new y();
  static _lightData = new fe();
  _rendererData = new LM();
  get depthTextureUniform() {
    if (this.uniforms)
      return this.uniforms._CameraDepthTexture;
  }
  get opaqueTextureUniform() {
    if (this.uniforms)
      return this.uniforms._CameraOpaqueTexture;
  }
  onBeforeRenderScene() {
    this.opaqueTextureUniform && N.Current.setRequireColor(!0), this.depthTextureUniform && N.Current.setRequireDepth(!0);
  }
  onBeforeRender(e, t, i, n, o, r) {
    n.attributes.tangent || n.computeTangents(), this.onUpdateUniforms(i, o);
  }
  onUpdateUniforms(e, t) {
    const i = N.Current;
    if (e && (Me.viewProjection && this.uniforms[this._viewProjectionName] && (Me.viewProjection.copy(e.projectionMatrix).multiply(e.matrixWorldInverse), _d(Me.viewProjection, Me._viewProjectionValues)), Me.viewMatrix && this.uniforms[this._viewMatrixName] && (Me.viewMatrix.copy(e.matrixWorldInverse), _d(Me.viewMatrix, Me._viewMatrixValues)), this.uniforms[Me._worldSpaceCameraPosName] && Me._worldSpaceCameraPos.setFromMatrixPosition(e.matrixWorld)), this.uniforms._TimeParameters && (this.uniforms._TimeParameters.value = i.sceneLighting.timeVec4), this.uniforms._Time) {
      const a = this.uniforms._Time.value;
      a.x = i.sceneLighting.timeVec4.x / 20, a.y = i.sceneLighting.timeVec4.x, a.z = i.sceneLighting.timeVec4.x * 2, a.w = i.sceneLighting.timeVec4.x * 3;
    }
    if (this.uniforms._SinTime) {
      const a = this.uniforms._SinTime.value;
      a.x = Math.sin(i.sceneLighting.timeVec4.x / 8), a.y = Math.sin(i.sceneLighting.timeVec4.x / 4), a.z = Math.sin(i.sceneLighting.timeVec4.x / 2), a.w = Math.sin(i.sceneLighting.timeVec4.x);
    }
    if (this.uniforms._CosTime) {
      const a = this.uniforms._CosTime.value;
      a.x = Math.cos(i.sceneLighting.timeVec4.x / 8), a.y = Math.cos(i.sceneLighting.timeVec4.x / 4), a.z = Math.cos(i.sceneLighting.timeVec4.x / 2), a.w = Math.cos(i.sceneLighting.timeVec4.x);
    }
    if (this.uniforms.unity_DeltaTime) {
      const a = this.uniforms.unity_DeltaTime.value;
      a.x = i.time.deltaTime, a.y = 1 / i.time.deltaTime, a.z = i.time.smoothedDeltaTime, a.w = 1 / i.time.smoothedDeltaTime;
    }
    const n = i.mainLight;
    if (n) {
      const a = Z(n.gameObject, Me._mainLightPosition);
      this.uniforms._MainLightPosition = { value: a.normalize() }, Me._mainLightColor.set(n.color.r, n.color.g, n.color.b, 0), this.uniforms._MainLightColor = { value: Me._mainLightColor };
      const l = n.intensity;
      Me._lightData.z = l, this.uniforms.unity_LightData = { value: Me._lightData };
    }
    if (e && (Me.viewProjection && this.uniforms[this._viewProjectionName] && (this.uniforms[this._viewProjectionName].value = Me._viewProjectionValues), Me.viewMatrix && this.uniforms[this._viewMatrixName] && (this.uniforms[this._viewMatrixName].value = Me._viewMatrixValues), this.uniforms[Me._worldSpaceCameraPosName] && (this.uniforms[Me._worldSpaceCameraPosName] = { value: Me._worldSpaceCameraPos }), i.mainCameraComponent)) {
      if (this.uniforms._ProjectionParams) {
        const a = this.uniforms._ProjectionParams.value;
        a.x = 1, a.y = i.mainCameraComponent.nearClipPlane, a.z = i.mainCameraComponent.farClipPlane, a.w = 1 / a.z, this.uniforms._ProjectionParams.value = a;
      }
      if (this.uniforms._ZBufferParams) {
        const a = this.uniforms._ZBufferParams.value, l = i.mainCameraComponent;
        a.x = 1 - l.farClipPlane / l.nearClipPlane, a.y = l.farClipPlane / l.nearClipPlane, a.z = a.x / l.farClipPlane, a.w = a.y / l.farClipPlane, this.uniforms._ZBufferParams.value = a;
      }
      if (this.uniforms._ScreenParams) {
        const a = this.uniforms._ScreenParams.value;
        a.x = i.domWidth, a.y = i.domHeight, a.z = 1 + 1 / a.x, a.w = 1 + 1 / a.y, this.uniforms._ScreenParams.value = a;
      }
      if (this.uniforms._ScaledScreenParams) {
        const a = this.uniforms._ScaledScreenParams.value;
        a.x = i.domWidth, a.y = i.domHeight, a.z = 1 + 1 / a.x, a.w = 1 + 1 / a.y, this.uniforms._ScaledScreenParams.value = a;
      }
    }
    const o = this.depthTextureUniform;
    o && (o.value = i.depthTexture);
    const r = this.opaqueTextureUniform;
    if (r && (r.value = i.opaqueColorTexture), t) {
      const a = this._rendererData;
      a.updateFrom(t), this.uniforms[this._worldToObjectName].value = a.worldToObject, this.uniforms[this._objToWorldName].value = a.objectToWorld;
    }
    this.uniformsNeedUpdate = !0;
  }
}
class DM {
  get name() {
    return Dr;
  }
  parser;
  identifier;
  constructor(e, t) {
    this.parser = e, this.identifier = t;
  }
  loadMaterial(e) {
    const t = this.parser.json.materials[e];
    if (!t)
      return vn && console.log(e, this.parser.json.materials), null;
    if (!t.extensions || !t.extensions[Dr])
      return vn && console.log(`Material ${e} does not use NEEDLE_techniques_webgl`), null;
    vn && console.log(`Material ${e} uses NEEDLE_techniques_webgl`, t);
    const i = t.extensions[Dr].technique;
    if (i < 0)
      return console.debug(`Material ${e} does not have a valid technique index`), null;
    const n = this.parser.json.extensions[Dr];
    if (!n)
      return vn ? console.error("Missing shader data", this.parser.json.extensions) : console.debug("Missing custom shader data in parser.json.extensions"), null;
    vn && console.log(n);
    const o = n.techniques[i];
    return o ? new Promise(async (r, a) => {
      const l = await xO(n, o.program), c = l?.fragmentShader, h = l?.vertexShader;
      if (!c || !h) return a();
      vn && console.log("loadMaterial", t, l);
      const d = {}, f = o.uniforms;
      (h.includes("_Time") || c.includes("_Time")) && (d._Time = { value: new fe(0, 0, 0, 0) }), (h.includes("_SinTime") || c.includes("_SinTime")) && (d._SinTime = { value: new fe(0, 0, 0, 0) }), (h.includes("_CosTime") || c.includes("_CosTime")) && (d._CosTime = { value: new fe(0, 0, 0, 0) }), (h.includes("unity_DeltaTime") || c.includes("unity_DeltaTime")) && (d.unity_DeltaTime = { value: new fe(0, 0, 0, 0) });
      for (const v in f) {
        const _ = v;
        switch (_) {
          case "_TimeParameters":
            const x = new fe();
            d[_] = { value: x };
            break;
          case "hlslcc_mtx4x4unity_MatrixV":
          case "hlslcc_mtx4x4unity_MatrixVP":
            d[_] = { value: [] };
            break;
          case "_MainLightPosition":
          case "_MainLightColor":
          case "_WorldSpaceCameraPos":
            d[_] = { value: [0, 0, 0, 1] };
            break;
          case "unity_OrthoParams":
            break;
          case "unity_SpecCube0":
            d[_] = { value: null };
            break;
          default:
          case "_ScreenParams":
          case "_ZBufferParams":
          case "_ProjectionParams":
            d[_] = { value: [0, 0, 0, 0] };
            break;
          case "_CameraOpaqueTexture":
          case "_CameraDepthTexture":
            d[_] = { value: null };
            break;
        }
      }
      let p = !1;
      if (t.extensions && t.extensions[Dr]) {
        const v = t.extensions[Dr];
        if (v.technique === i) {
          vn && console.log(t.name, "Material Properties", v);
          for (const _ in v.values) {
            const x = v.values[_];
            if (typeof x == "string") {
              if (x.startsWith("/textures/")) {
                const I = x.substring(10), O = Number.parseInt(I);
                if (O >= 0) {
                  const k = await this.parser.getDependency("texture", O);
                  k instanceof Te && (k.colorSpace = Ss, k.needsUpdate = !0), d[_] = { value: k };
                  continue;
                }
              }
              switch (_) {
                case "alphaMode":
                  x === "BLEND" && (p = !0);
                  continue;
              }
            }
            if (Array.isArray(x) && x.length === 4) {
              d[_] = { value: new fe(x[0], x[1], x[2], x[3]) };
              continue;
            }
            d[_] = { value: x };
          }
        }
      }
      const g = new Me(
        this.identifier,
        {
          name: t.name ?? "",
          uniforms: d,
          vertexShader: h,
          fragmentShader: c,
          lights: !1
          // defines: {
          //     "USE_SHADOWMAP" : true
          // },
        }
      );
      switch (g.glslVersion = Xx, g.vertexShader = g.vertexShader.replace("#version 300 es", ""), g.fragmentShader = g.fragmentShader.replace("#version 300 es", ""), d._Cull?.value) {
        case 0:
          g.side = xi;
          break;
        case 1:
          g.side = Gd;
          break;
        case 2:
          g.side = fo;
          break;
        default:
          g.side = fo;
          break;
      }
      switch (d._ZTest?.value) {
        case 3:
          g.depthTest = !0, g.depthFunc = tS;
          break;
        case 6:
          g.depthTest = !0, g.depthFunc = eS;
          break;
        case 2:
          g.depthTest = !0, g.depthFunc = Jx;
          break;
        case 4:
          g.depthTest = !0, g.depthFunc = Zx;
          break;
        case 5:
          g.depthTest = !0, g.depthFunc = Kx;
          break;
        case 7:
          g.depthTest = !0, g.depthFunc = Yx;
          break;
        case 8:
          g.depthTest = !1, g.depthFunc = Qx;
          break;
      }
      g.transparent = p, p && (g.depthWrite = !1), vO(d), g.onUpdateUniforms();
      for (const v in f) {
        const _ = v, x = f[v].type;
        if (d[_]?.value === void 0)
          switch (x) {
            case Ov.SAMPLER_2D:
              d[_] = { value: _O }, console.warn("Missing/unassigned texture, fallback to white: " + _);
              break;
            default:
              _ === "unity_OrthoParams" || console.warn("TODO: EXPECTED UNIFORM / fallback NOT SET: " + _, f[v]);
              break;
          }
      }
      vn && console.log(g.uuid, d), kv(g), r(g);
    }) : null;
  }
}
function kv(s) {
  if (s.uniforms) {
    vn && console.log("Uniforms:", s.uniforms);
    for (const t in s.uniforms)
      switch (e(t, t), t) {
        case "_Color":
          e("color", t);
          break;
      }
  }
  function e(t, i) {
    Object.getOwnPropertyDescriptor(s, t) || Object.defineProperty(s, t, {
      get: () => s.uniforms[i].value,
      set: (n) => {
        s.uniforms[i].value = n, s.needsUpdate = !0;
      }
    });
  }
}
const jM = w("debugextensions");
let Od;
const BM = import("./vendor-k9i6CeGi.js").then((s) => s.index$2).then(async (s) => (Od = s.GLTFAnimationPointerExtension, Od)).catch((s) => {
  console.warn("Failed to import GLTFLoaderAnimationPointer. Please use @needle-tools/three-animationpointer for full KHR_animation support", s);
}), lr = new Array();
function IL(s) {
  lr.includes(s) || lr.push(s);
}
function LL(s) {
  const e = lr.indexOf(s);
  e >= 0 && lr.splice(e, 1);
}
function Mv(s) {
  if (s instanceof Ps) {
    const e = new Pv();
    return s.register((t) => (e.parser = t, e)), e;
  }
  return null;
}
class FM {
  resolvePath(e) {
    return e.includes("/extensions/builtin_components/") ? e.replace("/extensions/builtin_components/", "/userData/components/") : e.includes("extensions/builtin_components/") ? e.replace("extensions/builtin_components/", "/userData/components/") : e;
  }
}
async function Qp(s, e, t) {
  const i = t.indexOf("?");
  i >= 0 && (t = t.substring(0, i)), s.register((n) => new MM(n)), s.register((n) => new EP(n)), s.register((n) => new uO(n, e.lightmaps, t)), s.register((n) => new RM(n, t, e)), s.register((n) => new DM(n, t)), s.register((n) => new Zs(n, t)), s.register((n) => new We(n)), s.register((n) => new CM(n)), oP() && s.register((n) => new oa(n)), await BM.catch((n) => {
  }), s.register((n) => {
    if (Od) {
      const o = new Od(n);
      return o.setAnimationPointerResolver.bind(o)(new FM()), o;
    } else
      return (jM || L()) && console.error("Missing KHR_animation_pointer extension..."), {
        name: "KHR_animation_pointer_NOT_AVAILABLE"
      };
  });
  for (const n of lr)
    n.onImport && n.onImport(s, t, e);
}
function Rv(s, e) {
  for (const t of lr)
    t.onExport && t.onExport(s, e);
}
function zM(s, e, t) {
  for (const i of lr)
    i.onLoaded && i.onLoaded(s, e, t);
}
class Tv {
  constructor(e) {
    this.writer = e, this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(e, t) {
    if (e.constructor.name !== "InstancedMesh") return;
    const i = this.writer, n = i.extensionsUsed, o = {};
    t.extensions = t.extensions || {}, t.extensions[this.name] = o;
    let r = new ee();
    const a = new Array(), l = new Array(), c = new Array();
    for (let p = 0; p < e.count; p++) {
      e.getMatrixAt(p, r);
      let g = new y(), b = new U(), m = new y();
      r.decompose(g, b, m), a.push(g.x, g.y, g.z), l.push(b.x, b.y, b.z, b.w), c.push(m.x, m.y, m.z);
    }
    const h = new Float32Array(a), d = new Float32Array(l), f = new Float32Array(c);
    o.attributes = {
      TRANSLATION: i.processAccessor(new ft(h, 3)),
      ROTATION: i.processAccessor(new ft(d, 4)),
      SCALE: i.processAccessor(new ft(f, 3))
    }, n[this.name] = !0;
  }
}
var UM = Object.defineProperty, Ev = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && UM(e, t, n), n;
};
const ml = w("debugreflectionprobe"), D_ = w("noreflectionprobe"), zf = Symbol("reflectionProbeKey"), j_ = Symbol("original material"), bg = class os extends R {
  static _probes = /* @__PURE__ */ new Map();
  static isUsingReflectionProbe(e) {
    return !!(e[zf] || e[j_]?.[zf]);
  }
  static get(e, t, i, n) {
    if (!e || e.isObject3D !== !0 || D_) return null;
    const o = os._probes.get(t);
    if (o) {
      for (const r of o)
        if (r.__didAwake || r.__internalAwake(), r.activeAndEnabled) {
          if (n) {
            if (r.gameObject === n)
              return r;
          } else if (r.isInBox(e))
            return ml && console.log("Found reflection probe", e.name, r.name), r;
        }
    }
    return ml && console.debug("Did not find reflection probe", e.name, i, e), null;
  }
  _texture;
  // @serializable(Texture)
  set texture(e) {
    if (e && !(e instanceof Te)) {
      console.error("ReflectionProbe.texture must be a Texture", e);
      return;
    }
    this._texture = e, e && (e.mapping = _s, e.colorSpace = Ss, e.needsUpdate = !0);
  }
  get texture() {
    return this._texture;
  }
  center;
  size;
  _boxHelper;
  isInBox(e) {
    return this._boxHelper?.isInBox(e);
  }
  constructor() {
    super(), os._probes.has(this.context) || os._probes.set(this.context, []), os._probes.get(this.context)?.push(this);
  }
  awake() {
    this._boxHelper = this.gameObject.addComponent(Pt), this._boxHelper.updateBox(!0), ml && this._boxHelper.showHelper(5592320, !0), this._texture && (this._texture.mapping = _s, this._texture.colorSpace = Ss, this._texture.needsUpdate = !0);
  }
  start() {
    !this._texture && L() && (console.warn(`[ReflectionProbe] Missing texture. Please assign a custom cubemap texture. To use reflection probes assign them to your renderer's "anchor" property.`), ge("ReflectionProbe configuration hint: See browser console for details"));
  }
  onDestroy() {
    const e = os._probes.get(this.context);
    if (e) {
      const t = e.indexOf(this);
      t >= 0 && e.splice(t, 1);
    }
  }
  // when objects are rendered and they share material
  // and some need reflection probe and some don't
  // we need to make sure we don't override the material but use a copy
  static _rendererMaterialsCache = /* @__PURE__ */ new Map();
  onSet(e) {
    if (D_ || !this.enabled || e.sharedMaterials?.length <= 0 || !this.texture) return;
    let t = os._rendererMaterialsCache.get(e);
    t || (t = [], os._rendererMaterialsCache.set(e, t));
    for (let i = 0; i < e.sharedMaterials.length; i++) {
      const n = e.sharedMaterials[i];
      if (!n || n.envMap === void 0 || n instanceof we)
        continue;
      let o = t[i];
      const r = n === o?.copy, a = !o || o.material.uuid !== n.uuid || o.copy.version !== n.version;
      if (!r && a) {
        if (ml) {
          let h = "";
          o ? o.material !== n ? h = "reference changed; cached instance?: " + r : o.copy.version !== n.version && (h = "version changed") : h = "not cached", console.warn("Cloning material", n.name, n.version, "Reason:", h, `
`, n.uuid, `
`, o?.copy.uuid, `
`, e.name);
        }
        const c = n.clone();
        c.version = n.version, o ? (o.copy = c, o.material = n) : (o = {
          material: n,
          copy: c
        }, t.push(o)), c[zf] = this, c[j_] = n, ml && console.log("Set reflection", e.name, e.guid);
      }
      o && o.copy && (o.copy.onBeforeCompile = n.onBeforeCompile);
      const l = o?.copy;
      l.envMap = this.texture, e.sharedMaterials[i] = l;
    }
  }
  onUnset(e) {
    const t = os._rendererMaterialsCache.get(e);
    if (t)
      for (let i = 0; i < t.length; i++) {
        const n = t[i];
        e.sharedMaterials[i] = n.material;
      }
  }
};
Ev([
  u(y)
], bg.prototype, "center");
Ev([
  u(y)
], bg.prototype, "size");
let kd = bg;
const Kt = w("debuginstancing");
class Aa {
  static instance = new Aa();
  /** This is the initial instance count when creating a new instancing structure.    
   * Override this and the number of max instances that you expect for a given object.
   * The larger the value the more objects can be added without having to resize but it will also consume more memory.    
   * (The instancing mesh renderer will grow x2 if the max instance count is reached)
   * @default 4
   * @returns The initial instance count
   * */
  static getStartInstanceCount = (e) => 4;
  objs = [];
  setup(e, t, i, n, o, r = 0) {
    e.applySettings(t);
    const a = this.tryCreateOrAddInstance(t, i, o);
    if (a) {
      n === null && (n = []), n.push(a), We.assignTextureLOD(a.renderer.material, 0);
      for (let l = 0; l < e.sharedMeshes.length; l++) {
        const c = e.sharedMeshes[l], h = c.geometry;
        We.assignMeshLOD(c, 0).then((d) => {
          d && e.activeAndEnabled && h != d && a.setGeometry(d);
        });
      }
    } else if (r <= 0 && t.type !== "Mesh") {
      const l = r + 1;
      for (const c of t.children)
        n = this.setup(e, c, i, n, o, l);
    }
    return r === 0 && o.useMatrixWorldAutoUpdate && n && n.length >= 0 && this.autoUpdateInstanceMatrix(t), n;
  }
  tryCreateOrAddInstance(e, t, i) {
    if (e.type === "Mesh") {
      const n = i.foundMeshes;
      if (i.foundMeshes += 1, !i.rend.enableInstancing) return null;
      if (i.rend.enableInstancing !== !0) {
        if (n >= i.rend.enableInstancing.length)
          return Kt && console.error("Something is wrong with instance setup", e, i.rend.enableInstancing, n), null;
        if (!i.rend.enableInstancing[n])
          return null;
      }
      const o = e, r = o.material;
      for (const d of this.objs) {
        if (!d.canAdd(o.geometry, r)) continue;
        return d.addInstance(o);
      }
      let a = Aa.getStartInstanceCount(e);
      (!a || a < 0) && (a = 4);
      let l = e.name;
      l?.length || (l = yC());
      const c = new NM(l, o.geometry, r, a, t);
      return this.objs.push(c), c.addInstance(o);
    }
    return null;
  }
  autoUpdateInstanceMatrix(e) {
    const t = e.matrixWorld.multiplyMatrices.bind(e.matrixWorld), i = e.matrixWorld.clone(), n = (o, r) => {
      const a = t(o, r);
      return (e[pc] || i.equals(a) === !1) && (i.copy(a), e[pc] = !0), a;
    };
    e.matrixWorld.multiplyMatrices = n;
  }
}
class ua {
  static all = [];
  /** The name of the object */
  get name() {
    return this.object.name;
  }
  get isActive() {
    return this.__instanceIndex >= 0;
  }
  get vertexCount() {
    return this.object.geometry.attributes.position.count;
  }
  get maxVertexCount() {
    return Math.max(this.meshInformation.vertexCount, this.vertexCount);
  }
  get reservedVertexCount() {
    return this.__reservedVertexRange;
  }
  get indexCount() {
    return this.object.geometry.index ? this.object.geometry.index.count : 0;
  }
  get maxIndexCount() {
    return Math.max(this.meshInformation.indexCount, this.indexCount);
  }
  get reservedIndexCount() {
    return this.__reservedIndexRange;
  }
  /** The object that is being instanced */
  object;
  /** The instancer/BatchedMesh that is rendering this object*/
  renderer;
  /** @internal */
  __instanceIndex = -1;
  /** @internal */
  __reservedVertexRange = 0;
  /** @internal */
  __reservedIndexRange = 0;
  __geometryIndex = -1;
  /** The mesh information of the object - this tries to also calculate the LOD info */
  meshInformation;
  constructor(e, t) {
    this.__instanceIndex = -1, this.object = e, this.renderer = t, e[k0] = t, this.meshInformation = qo(e.geometry), ua.all.push(this);
  }
  /** Calculates the mesh information again
   * @returns true if the vertex count or index count has changed
   */
  updateMeshInformation() {
    const e = qo(this.object.geometry), t = this.meshInformation.vertexCount, i = this.meshInformation.indexCount;
    return Object.assign(this.meshInformation, e), t !== this.meshInformation.vertexCount || i !== this.meshInformation.indexCount;
  }
  /** Updates the matrix from the rendered object. Will also call updateWorldMatrix internally */
  updateInstanceMatrix(e = !1, t = !0) {
    this.__instanceIndex < 0 || (t && this.object.updateWorldMatrix(!0, e), this.renderer.updateInstance(this.object.matrixWorld, this.__instanceIndex));
  }
  /** Updates the matrix of the instance */
  setMatrix(e) {
    this.__instanceIndex < 0 || this.renderer.updateInstance(e, this.__instanceIndex);
  }
  /** Can be used to change the geometry of this instance */
  setGeometry(e) {
    if (this.__geometryIndex < 0) return !1;
    const t = this;
    if (this.vertexCount > this.__reservedVertexRange)
      return i(`Instancing: Can not update geometry (${this.name}), reserved vertex range is too small: ${this.__reservedVertexRange.toLocaleString()} < ${this.vertexCount.toLocaleString()} vertices for ${this.name}`);
    if (this.indexCount > this.__reservedIndexRange)
      return i(`Instancing: Can not update geometry (${this.name}), reserved index range is too small: ${this.__reservedIndexRange.toLocaleString()} < ${this.indexCount.toLocaleString()} indices for ${this.name}`);
    return this.renderer.updateGeometry(e, this.__geometryIndex);
    function i(n) {
      return t.updateMeshInformation() && (t.renderer.remove(t, !0), t.renderer.add(t)) ? !0 : ((L() || Kt) && console.error(n), !1);
    }
  }
  /** Adds this object to the instancing renderer (effectively activating instancing) */
  add() {
    this.__instanceIndex >= 0 || (this.renderer.add(this), S.markAsInstancedRendered(this.object, !0));
  }
  /** Removes this object from the instancing renderer 
   * @param delete_ If true, the instance handle will be removed from the global list
  */
  remove(e) {
    if (!(this.__instanceIndex < 0) && (this.renderer.remove(this, e), S.markAsInstancedRendered(this.object, !1), e)) {
      const t = ua.all.indexOf(this);
      t >= 0 && ua.all.splice(t, 1);
    }
  }
}
class NM {
  /** The three instanced mesh
   * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
   */
  get batchedMesh() {
    return this._batchedMesh;
  }
  get visible() {
    return this._batchedMesh.visible;
  }
  set visible(e) {
    this._batchedMesh.visible = e;
  }
  get castShadow() {
    return this._batchedMesh.castShadow;
  }
  set castShadow(e) {
    this._batchedMesh.castShadow = e;
  }
  set receiveShadow(e) {
    this._batchedMesh.receiveShadow = e;
  }
  /** If true, the instancer is allowed to grow when the max instance count is reached */
  allowResize = !0;
  /** The name of the instancer */
  name = "";
  /** The added geometry */
  geometry;
  /** The material used for the instanced mesh */
  material;
  /** The current number of instances */
  get count() {
    return this._currentInstanceCount;
  }
  /** Update the bounding box and sphere of the instanced mesh 
   * @param box If true, update the bounding box
   * @param sphere If true, update the bounding sphere
  */
  updateBounds(e = !0, t = !0) {
    if (this._needUpdateBounds = !1, e && this._batchedMesh.computeBoundingBox(), t && this._batchedMesh.computeBoundingSphere(), Kt && this._batchedMesh.boundingSphere) {
      const i = this._batchedMesh.boundingSphere;
      z.DrawWireSphere(i.center, i.radius, 65280);
    }
  }
  _context;
  _batchedMesh;
  _handles = [];
  _geometryIds = /* @__PURE__ */ new Map();
  _maxInstanceCount;
  _currentInstanceCount = 0;
  _currentVertexCount = 0;
  _currentIndexCount = 0;
  _maxVertexCount;
  _maxIndexCount;
  static nullMatrix = new ee();
  /** Check if the geometry can be added to this instancer
   * @param geometry The geometry to check
   * @param material The material of the geometry
   * @returns true if the geometry can be added
   */
  canAdd(e, t) {
    return this._maxVertexCount > 1e7 || t !== this.material || !this.validateGeometry(e) ? !1 : !!(!this.mustGrow(e) || this.allowResize);
  }
  _needUpdateBounds = !1;
  _debugMaterial = null;
  constructor(e, t, i, n, o) {
    this.name = e, this.geometry = t, this.material = i, this._context = o, this._maxInstanceCount = Math.max(2, n), Kt && (this._debugMaterial = B_());
    const r = this.tryEstimateVertexCountSize(this._maxInstanceCount, [t], n);
    this._maxVertexCount = r.vertexCount, this._maxIndexCount = r.indexCount, this._batchedMesh = new cy(this._maxInstanceCount, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material), this._batchedMesh[El] = !0, this._batchedMesh.visible = !0, this._context.scene.add(this._batchedMesh), i instanceof Tb && (i.defines.USE_INSTANCING = !0, i.needsUpdate = !0), o.pre_render_callbacks.push(this.onBeforeRender), o.post_render_callbacks.push(this.onAfterRender), Kt && console.log(`Instanced renderer created with ${this._maxInstanceCount} instances, ${this._maxVertexCount} max vertices and ${this._maxIndexCount} max indices for "${e}"`);
  }
  dispose() {
    Kt && console.warn("Dispose instanced renderer", this.name), this._context.scene.remove(this._batchedMesh), this._batchedMesh.dispose(), this._batchedMesh = null, this._handles = [];
  }
  addInstance(e) {
    const t = new ua(e, this);
    e.castShadow === !0 && this._batchedMesh.castShadow === !1 && (this._batchedMesh.castShadow = !0), e.receiveShadow === !0 && this._batchedMesh.receiveShadow === !1 && (this._batchedMesh.receiveShadow = !0);
    try {
      this.add(t);
    } catch (i) {
      if (console.error(`Failed adding mesh to instancing (object name: "${e.name}", instances: ${this._currentInstanceCount.toLocaleString()}/${this._maxInstanceCount.toLocaleString()}, vertices: ${this._currentVertexCount.toLocaleString()}/${this._maxVertexCount.toLocaleString()}, indices: ${this._currentIndexCount.toLocaleString()}/${this._maxIndexCount.toLocaleString()})
`, i), L()) {
        Zd("Failed instancing mesh. See the browser console for details.");
        debugger;
      }
      return null;
    }
    return t;
  }
  add(e) {
    const t = e.object.geometry;
    if (!t || !t.attributes)
      return console.error("Cannot add object to instancing without geometry", e.name), !1;
    if (this.mustGrow(t))
      if (this.allowResize)
        this.grow(t);
      else
        return console.error("Cannot add instance, max count reached", this.name, this.count, this._maxInstanceCount), !1;
    return e.object.updateWorldMatrix(!0, !0), this.addGeometry(e), this._handles[e.__instanceIndex] = e, this._currentInstanceCount += 1, this.markNeedsUpdate(), this._currentInstanceCount > 0 && (this._batchedMesh.visible = !0), !0;
  }
  remove(e, t) {
    e && (e.__instanceIndex < 0 || this._handles[e.__instanceIndex] != e || this._currentInstanceCount <= 0 || (this.removeGeometry(e, t), this._handles[e.__instanceIndex] = null, e.__instanceIndex = -1, this._currentInstanceCount > 0 && (this._currentInstanceCount -= 1), this._currentInstanceCount <= 0 && (this._batchedMesh.visible = !1), this.markNeedsUpdate()));
  }
  updateInstance(e, t) {
    this._batchedMesh.setMatrixAt(t, e), this.markNeedsUpdate();
  }
  updateGeometry(e, t) {
    return this.validateGeometry(e) ? (this.mustGrow() && this.grow(e), Kt && console.debug("[Instancing] UPDATE GEOMETRY at " + t, this._batchedMesh._geometryCount, e.name, qo(e), e.attributes.position.count, e.index ? e.index.count : 0), this._batchedMesh.setGeometryAt(t, e), this._geometryIds.set(e, t), this.markNeedsUpdate(), !0) : !1;
  }
  onBeforeRender = () => {
    this._batchedMesh.layers.enableAll(), this._needUpdateBounds && this._batchedMesh[El] === !0 && (Kt === "verbose" && console.log("Update instancing bounds", this.name, this._batchedMesh.matrixWorldNeedsUpdate), this.updateBounds());
  };
  onAfterRender = () => {
    this._batchedMesh.layers.disableAll();
  };
  validateGeometry(e) {
    const t = this.geometry;
    for (const i in t.attributes)
      if (i !== "batchId" && !e.hasAttribute(i))
        return L() && console.warn(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`), !1;
    return !0;
  }
  markNeedsUpdate() {
    Kt === "verbose" && console.warn("Marking instanced mesh dirty", this.name), this._needUpdateBounds = !0;
  }
  /**
   * @param geo The geometry to add (if none is provided it means the geometry is already added and just updated)
   */
  mustGrow(e) {
    if (this.count >= this._maxInstanceCount) return !0;
    if (!e || !e.attributes) return !1;
    const t = qo(e), i = t.vertexCount, n = t.indexCount;
    return this._currentVertexCount + i > this._maxVertexCount || this._currentIndexCount + n > this._maxIndexCount;
  }
  grow(e) {
    const i = Math.ceil(this._maxInstanceCount * 2), n = this.tryEstimateVertexCountSize(i, [e]), o = Math.max(this._maxVertexCount, n.vertexCount), r = Math.max(this._maxIndexCount, n.indexCount, Math.ceil(this._maxVertexCount * 2));
    if (Kt) {
      const c = qo(e);
      console.warn(`[Instancing] Growing Buffer
Mesh: "${this.name}${e.name?.length ? "/" + e.name : ""}"
${c.vertexCount} vertices, ${c.indexCount} indices
Max count ${this._maxInstanceCount} → ${i}
Max vertex count ${this._maxVertexCount} -> ${o}
Max index count ${this._maxIndexCount} -> ${r}`), this._debugMaterial = B_();
    } else L() && console.debug(`[Instancing] Growing Buffer
Mesh: "${this.name}${e.name?.length ? "/" + e.name : ""}"
Max count ${this._maxInstanceCount} → ${i}
Max vertex count ${this._maxVertexCount} -> ${o}
Max index count ${this._maxIndexCount} -> ${r}`);
    this._maxVertexCount = o, this._maxIndexCount = r;
    const a = new cy(i, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material);
    a.layers = this._batchedMesh.layers, a.castShadow = this._batchedMesh.castShadow, a.receiveShadow = this._batchedMesh.receiveShadow, a.visible = this._batchedMesh.visible, a[El] = this._batchedMesh[El], a.matrixAutoUpdate = this._batchedMesh.matrixAutoUpdate, a.matrixWorldNeedsUpdate = this._batchedMesh.matrixWorldNeedsUpdate, a.matrixAutoUpdate = this._batchedMesh.matrixAutoUpdate, a.matrixWorld.copy(this._batchedMesh.matrixWorld), a.matrix.copy(this._batchedMesh.matrix), this._batchedMesh.dispose(), this._batchedMesh.removeFromParent(), this._geometryIds.clear(), this._batchedMesh = a, this._maxInstanceCount = i;
    const l = [...this._handles];
    this._handles = [];
    for (const c of l)
      c && c.__instanceIndex >= 0 && (this.addGeometry(c), this._handles[c.__instanceIndex] = c);
    this._context.scene.add(a);
  }
  tryEstimateVertexCountSize(e, t, i = 1) {
    const n = /* @__PURE__ */ new Map();
    for (const d of this._handles)
      if (d && d.__instanceIndex >= 0 && d.object.geometry)
        if (n.has(d.object.geometry)) {
          const f = n.get(d.object.geometry);
          f.count += 1;
        } else {
          const p = { count: 1, ...qo(d.object.geometry) };
          n.set(d.object.geometry, p);
        }
    let o = 0, r = 0;
    for (const [d, f] of n)
      o += f.vertexCount * f.count, r += f.indexCount * f.count;
    let l = Math.ceil(o / Math.max(1, this._currentInstanceCount)) * e, h = Math.ceil(r / Math.max(1, this._currentInstanceCount)) * e * 2;
    if (t)
      for (const d of t) {
        const f = qo(d);
        f != null && (l += f.vertexCount * i, h += f.indexCount * i);
      }
    return { vertexCount: l, indexCount: h };
  }
  addGeometry(e) {
    const i = e.object.geometry;
    if (!i)
      return;
    let n = this._geometryIds.get(i);
    n == null ? (Kt && console.debug(`[Instancing] > ADD NEW GEOMETRY "${e.name} (${i.name}; ${i.uuid})"
${this._currentInstanceCount} instances, ${e.maxVertexCount} max vertices, ${e.maxIndexCount} max indices`), n = this._batchedMesh.addGeometry(i, e.maxVertexCount, e.maxIndexCount), this._geometryIds.set(i, n)) : Kt === "verbose" && console.log(`[Instancing] > ADD INSTANCE "${e.name}"
GEOMETRY_ID=${n}
${this._currentInstanceCount} instances`), this._currentVertexCount += e.maxVertexCount, this._currentIndexCount += e.maxIndexCount;
    const o = this._batchedMesh.addInstance(n);
    e.__geometryIndex = n, e.__instanceIndex = o, e.__reservedVertexRange = e.maxVertexCount, e.__reservedIndexRange = e.maxIndexCount, this._batchedMesh.setMatrixAt(o, e.object.matrixWorld), Kt && console.debug(`[Instancing] > ADDED INSTANCE "${e.name}"
GEOMETRY_ID=${n}
${this._currentInstanceCount} instances
Index: ${e.__instanceIndex}`);
  }
  removeGeometry(e, t) {
    if (e.__instanceIndex < 0) {
      console.warn("Cannot remove geometry, instance index is invalid", e.name);
      return;
    }
    Kt && console.debug(`[Instancing] < REMOVE INSTANCE "${e.name}" at [${e.__instanceIndex}]
GEOMETRY_ID=${e.__geometryIndex}
${this._currentInstanceCount} instances
Index: ${e.__instanceIndex}`), this._batchedMesh.deleteInstance(e.__instanceIndex);
  }
}
function qo(s) {
  if (!s)
    return L() && console.error("Cannot get mesh information from null geometry"), { vertexCount: 0, indexCount: 0 };
  let e = s.attributes?.position?.count || 0, t = s.index ? s.index.count : 0;
  const i = We.getMeshLODExtension(s);
  if (i) {
    const n = i.lods[0];
    let o = n.vertexCount, r = n.indexCount;
    const a = Math.min(200, Math.ceil(o * 0.05));
    o += a, r += 20, e = Math.max(e, o), t = Math.max(t, r);
  }
  return e = Math.ceil(e), t = Math.ceil(t), { vertexCount: e, indexCount: t };
}
function B_() {
  const s = new ut({ color: new se(Math.random(), Math.random(), Math.random()) });
  return s.emissive = s.color, s.emissiveIntensity = 0.3, w("wireframe") && (s.wireframe = !0), s;
}
const jr = w("debuglightmaps");
class Yp {
  get lightmap() {
    return this.lightmapTexture;
  }
  set lightmap(e) {
    e !== this.lightmapTexture && (this.lightmapTexture = e, this.applyLightmap(), this.lightmapTexture && We.assignTextureLOD(this.lightmapTexture, 0).then((t) => {
      t?.isTexture && (this.lightmapTexture = t);
    }));
  }
  lightmapIndex = -1;
  lightmapScaleOffset = new fe(1, 1, 0, 0);
  context;
  gameObject;
  lightmapTexture = null;
  lightmapScaleOffsetUniform = { value: new fe(1, 1, 0, 0) };
  lightmapUniform = { value: null };
  constructor(e, t) {
    this.gameObject = e, this.context = t;
  }
  init(e, t, i) {
    console.assert(this.gameObject !== void 0 && this.gameObject !== null, "Missing gameobject", this), this.lightmapIndex = e, !(this.lightmapIndex < 0) && (this.lightmapScaleOffset = t, this.lightmapTexture = i, We.assignTextureLOD(i, 0).then((n) => {
      n?.isTexture && (this.lightmapTexture = n);
    }), jr == "show" ? (console.log("Lightmap:", this.gameObject.name, e, `
ScaleOffset:`, t, `
Texture:`, i), this.setLightmapDebugMaterial()) : jr && console.log("Use debuglightmaps=show to render lightmaps only in the scene."), this.applyLightmap());
  }
  updateLightmapUniforms(e) {
    const t = e.uniforms;
    t && t.lightmap && (this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset, t.lightmapScaleOffset = this.lightmapScaleOffsetUniform);
  }
  /**
   * Apply the lightmap to the object. This will clone the material and set the lightmap texture and scale/offset
   */
  applyLightmap() {
    if (this.gameObject.type === "Object3D") {
      jr && console.warn("Can not add lightmap. Is this object missing a renderer?", this.gameObject.name);
      return;
    }
    if (this.gameObject.type === "Group") {
      this.gameObject["Needle:Multimaterial-LightmapWarning"] === void 0 && (this.gameObject["Needle:Multimaterial-LightmapWarning"] = !0, console.warn("Lightmap on multimaterial object is not supported yet... please open a feature request on https://github.com/needle-tools/needle-engine-support if your project requires it"));
      return;
    }
    console.assert(this.gameObject.type === "Mesh", "Lightmap only works on meshes", this);
    const e = this.gameObject;
    if (e.geometry.getAttribute("uv1") || e.geometry.setAttribute("uv1", e.geometry.getAttribute("uv")), Array.isArray(this.gameObject.material)) {
      const t = this.gameObject.material;
      for (let i = 0; i < t.length; i++)
        t[i] = this.ensureLightmapMaterial(t[i]);
    } else
      this.gameObject.material = this.ensureLightmapMaterial(this.gameObject.material);
    if (this.lightmapIndex >= 0 && this.lightmapTexture) {
      this.lightmapTexture.channel = 1;
      const t = this.gameObject.material;
      if (Array.isArray(t))
        for (const i of t)
          this.assignLightmapTexture(i);
      else t && this.assignLightmapTexture(t);
    }
  }
  ensureLightmapMaterial(e) {
    if (e.userData || (e.userData = {}), e["NEEDLE:lightmap-material-version"] != e.version && e["NEEDLE:lightmap-material-version"] == null) {
      jr && console.warn("Cloning material for lightmap " + e.name);
      const t = e.clone();
      t.name?.includes("(lightmap)") || (t.name = e.name + " (lightmap)"), e = t, e.onBeforeCompile = this.onBeforeCompile;
    }
    return e;
  }
  assignLightmapTexture(e) {
    !e || e instanceof gp && e.transmission > 0 || !(e.lightMap !== this.lightmapTexture || e["NEEDLE:lightmap-material-version"] !== e.version) || (jr && console.log("Assigning lightmap", e.name, e.version, e), e.lightMap = this.lightmapTexture, e["NEEDLE:lightmap-material-version"] = e.version);
  }
  onBeforeCompile = (e, t) => {
    jr && console.log(`Lightmaps, before compile
`, e), this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset, this.lightmapUniform.value = this.lightmapTexture, e.uniforms.lightmapScaleOffset = this.lightmapScaleOffsetUniform;
  };
  setLightmapDebugMaterial() {
    this.gameObject.material = new Ln({
      vertexShader: `
                varying vec2 vUv1;
                void main()
                {
                    vUv1 = uv1;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
                `,
      fragmentShader: `
                uniform sampler2D lightMap;
                uniform float lightMapIntensity;
                uniform vec4 lightmapScaleOffset;
                varying vec2 vUv1;

                // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
                vec4 conv_sRGBToLinear( in vec4 value ) {
                    return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
                }

                void main() {
                    vec2 lUv = vUv1.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
                    
                    vec4 lightMapTexel = texture2D( lightMap, lUv);
                    gl_FragColor = lightMapTexel;
                    gl_FragColor.a = 1.;
                }
                `,
      defines: { USE_LIGHTMAP: "" }
    });
  }
}
var $M = Object.defineProperty, Es = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && $M(e, t, n), n;
};
const qr = w("debugrenderer"), F_ = w("debugskinnedmesh"), z_ = w("noinstancing"), WM = w("wireframe");
class VM {
  path = null;
  asset = null;
  default;
}
class HM {
  _renderer;
  _targets = [];
  _indexMapMaxIndex;
  _indexMap;
  _changed = !1;
  get changed() {
    return this._changed;
  }
  set changed(e) {
    e === !0 && qr && console.warn("SharedMaterials have changed: " + this._renderer.name, this), this._changed = e;
  }
  is(e) {
    return this._renderer === e;
  }
  constructor(e, t) {
    this._renderer = e;
    const i = this.setMaterial.bind(this), n = this.getMaterial.bind(this), o = e.gameObject;
    if (this._targets = [], o)
      switch (o.type) {
        case "Group":
          this._targets = [...o.children];
          break;
        case "SkinnedMesh":
        case "Mesh":
          this._targets.push(o);
          break;
      }
    let r = !1, a, l = 0;
    for (let c = 0; c < this._targets.length; c++) {
      const h = this._targets[c];
      if (!h) continue;
      const d = h.material;
      if (d) {
        d.shadowSide = d.side;
        for (let f = 0; f < t.length; f++) {
          const p = t[f];
          if (!p) {
            r = !0;
            continue;
          }
          if (d.name === p.name) {
            a === void 0 && (a = /* @__PURE__ */ new Map()), a.set(f, c), l = Math.max(l, f);
            break;
          }
        }
      }
    }
    if (r) {
      this._indexMapMaxIndex = l, this._indexMap = a;
      const c = `Renderer ${e.name} was initialized with missing materials - this may lead to unexpected behaviour when trying to access sharedMaterials by index.`;
      console.warn(c), hn() && ge("Found renderer with missing materials: please check the console for details.");
    }
    return new Proxy(this, {
      get(c, h) {
        if (typeof h == "string") {
          const d = parseInt(h);
          if (!isNaN(d))
            return n(d);
        }
        return c[h];
      },
      set(c, h, d) {
        return typeof h == "string" && i(d, Number.parseInt(h)), Reflect.set(c, h, d) ? (d instanceof _e && (c.changed = !0), !0) : !1;
      }
    });
  }
  get length() {
    return this._indexMapMaxIndex !== void 0 ? this._indexMapMaxIndex + 1 : this._targets.length;
  }
  // iterator to support: for(const mat of sharedMaterials)
  *[Symbol.iterator]() {
    for (let e = 0; e < this.length; e++)
      yield this.getMaterial(e);
  }
  resolveIndex(e) {
    const t = this._indexMap;
    return t && t.has(e) ? t.get(e) : e;
  }
  setMaterial(e, t) {
    if (t = this.resolveIndex(t), t < 0 || t >= this._targets.length) return;
    const i = this._targets[t];
    !i || i.material === void 0 || (i.material = e, this.changed = !0);
  }
  getMaterial(e) {
    if (e = this.resolveIndex(e), e < 0) return null;
    const t = this._targets;
    if (e >= t.length) return null;
    const i = t[e];
    return i ? i.material : null;
  }
}
const Wn = class Qh extends R {
  /** Enable or disable instancing for an object. This will create a Renderer component if it does not exist yet.
   * @returns the Renderer component that was created or already existed on the object
   */
  static setInstanced(e, t) {
    const i = tu(e, Qh);
    return i.setInstancingEnabled(t), i;
  }
  /** Check if an object is currently rendered using instancing
   * @returns true if the object is rendered using instancing
   */
  static isInstanced(e) {
    const t = Da(e, Qh);
    return t ? t.isInstancingActive : ln.isUsingInstancing(e);
  }
  /** Set the rendering state only of an object (makes it visible or invisible) without affecting component state or child hierarchy visibility! You can also just enable/disable the Renderer component on that object for the same effect!
   * 
   * If you want to activate or deactivate a complete object you can use obj.visible as usual (it acts the same as setActive in Unity) */
  static setVisible(e, t) {
    ds(e, t);
  }
  receiveShadows = !1;
  shadowCastingMode = 0;
  lightmapIndex = -1;
  lightmapScaleOffset = new fe(1, 1, 0, 0);
  enableInstancing = void 0;
  renderOrder = void 0;
  allowOcclusionWhenDynamic = !0;
  probeAnchor;
  reflectionProbeUsage = 0;
  // custom shader
  // get materialProperties(): Array<MaterialProperties> | undefined {
  //     return this._materialProperties;
  // }
  // set materialProperties(value: Array<MaterialProperties> | undefined) {
  //     this._materialProperties = value;
  // }
  // private customShaderHandler: RendererCustomShader | undefined = undefined;
  // private _materialProperties: Array<MaterialProperties> | undefined = undefined;
  _lightmaps;
  /** Get the mesh Object3D for this renderer  
   * Warn: if this is a multimaterial object it will return the first mesh only 
   * @returns a mesh object3D.
   * */
  get sharedMesh() {
    if (this.gameObject.type === "Mesh")
      return this.gameObject;
    if (this.gameObject.type === "SkinnesMesh")
      return this.gameObject;
    if (this.gameObject.type === "Group")
      return this.gameObject.children[0];
  }
  _sharedMeshes = [];
  /** Get all the mesh Object3D for this renderer 
   * @returns an array of mesh object3D.
   */
  get sharedMeshes() {
    if (this.destroyed || !this.gameObject) return this._sharedMeshes;
    if (this._sharedMeshes.length = 0, this.gameObject.type === "Group")
      for (const e of this.gameObject.children)
        (e.type === "Mesh" || e.type === "SkinnedMesh") && this._sharedMeshes.push(e);
    else (this.gameObject.type === "Mesh" || this.gameObject.type === "SkinnedMesh") && this._sharedMeshes.push(this.gameObject);
    return this._sharedMeshes;
  }
  get sharedMaterial() {
    return this.sharedMaterials[0];
  }
  set sharedMaterial(e) {
    this.sharedMaterials[0] !== e && (this.sharedMaterials[0] = e, this.applyLightmapping());
  }
  /**@deprecated please use sharedMaterial */
  get material() {
    return this.sharedMaterials[0];
  }
  /**@deprecated please use sharedMaterial */
  set material(e) {
    this.sharedMaterial = e;
  }
  _sharedMaterials;
  _originalMaterials;
  _probeAnchorLastFrame;
  // this is just available during deserialization
  set sharedMaterials(e) {
    if (!this._originalMaterials)
      this._originalMaterials = e;
    else if (e) {
      let t = !1;
      for (let i = 0; i < this._sharedMaterials.length; i++) {
        const n = i < e.length ? e[i] : null;
        n && n instanceof _e ? this.sharedMaterials[i] = n : t || (t = !0, console.warn("Can not assign null as material: " + this.name, n));
      }
    }
  }
  //@ts-ignore
  get sharedMaterials() {
    return this.__didAwake ? ((!this._sharedMaterials || !this._sharedMaterials.is(this)) && (this._originalMaterials || (this._originalMaterials = []), this._sharedMaterials = new HM(this, this._originalMaterials)), this._sharedMaterials) : null;
  }
  static get shouldSuppressInstancing() {
    return z_;
  }
  _lightmapTextureOverride = void 0;
  get lightmap() {
    return this._lightmaps?.length ? this._lightmaps[0].lightmap : null;
  }
  /** set undefined to return to default lightmap */
  set lightmap(e) {
    if (this._lightmapTextureOverride = e, e === void 0 && (e = this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex)), this._lightmaps?.length)
      for (const t of this._lightmaps)
        t.lightmap = e;
  }
  get hasLightmap() {
    const e = this.lightmap;
    return e != null;
  }
  allowProgressiveLoading = !0;
  _firstFrame = -1;
  registering() {
    this.enabled || this.setVisibility(!1);
  }
  awake() {
    if (this._firstFrame = this.context.time.frame, qr && console.log("Renderer ", this.name, this), this.clearInstancingState(), this.probeAnchor && qr && this.probeAnchor.add(new vi(0.2)), this._reflectionProbe = null, this.isMultiMaterialObject(this.gameObject)) {
      for (const e of this.gameObject.children)
        this.context.addBeforeRenderListener(e, this.onBeforeRenderThree), e.layers.mask = this.gameObject.layers.mask;
      if (this.renderOrder !== void 0) {
        let e = 0;
        for (let t = 0; t < this.gameObject.children.length; t++) {
          const i = this.gameObject.children[t];
          if (!(!this.isMeshOrSkinnedMesh(i) || S.getComponent(i, Qh))) {
            if (this.renderOrder.length <= e) {
              console.warn("Incorrect renderOrder element count", this, this.renderOrder.length + " but expected " + this.gameObject.children.length, "Index: " + e, "ChildElement:", i);
              continue;
            }
            i.renderOrder = this.renderOrder[e], e += 1;
          }
        }
      }
    } else this.isMeshOrSkinnedMesh(this.gameObject) ? (this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree), this.renderOrder !== void 0 && this.renderOrder.length > 0 && (this.gameObject.renderOrder = this.renderOrder[0])) : this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
    if (this.applyLightmapping(), WM)
      for (let e = 0; e < this.sharedMaterials.length; e++) {
        const t = this.sharedMaterials[e];
        t && (t.wireframe = !0);
      }
  }
  applyLightmapping() {
    if (this.lightmapIndex >= 0) {
      const e = this.gameObject.type, t = this._lightmapTextureOverride !== void 0 ? this._lightmapTextureOverride : this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex);
      if (t) {
        if (this._lightmaps || (this._lightmaps = []), e === "Mesh") {
          const i = this.gameObject.material;
          if (i?.isMeshBasicMaterial)
            i && console.warn("Lightmapping is not supported on MeshBasicMaterial", i.name);
          else {
            if (this._lightmaps.length <= 0) {
              const o = new Yp(this.gameObject, this.context);
              this._lightmaps.push(o);
            }
            this._lightmaps[0].init(this.lightmapIndex, this.lightmapScaleOffset, t);
          }
        } else if (this.isMultiMaterialObject(this.gameObject) && this.sharedMaterials.length > 0)
          for (let i = 0; i < this.gameObject.children.length; i++) {
            const n = this.gameObject.children[i];
            if (!n.material?.isMeshBasicMaterial) {
              let o;
              i >= this._lightmaps.length ? (o = new Yp(n, this.context), this._lightmaps.push(o)) : o = this._lightmaps[i], o.init(this.lightmapIndex, this.lightmapScaleOffset, t);
            }
          }
      } else
        qr && console.warn("Lightmap not found", this.sourceId, this.lightmapIndex);
    }
  }
  _isInstancingEnabled = !1;
  _handles = void 0;
  /** 
   * @returns true if this renderer has instanced objects
   */
  get isInstancingActive() {
    return this._handles != null && this._handles.length > 0 && this._isInstancingEnabled;
  }
  /** @returns the instancing handles */
  get instances() {
    if (!this._handles || this._handles.length <= 0)
      return null;
    if (this._handlesTempArray.length = 0, this._handles)
      for (const e of this._handles)
        this._handlesTempArray.push(e);
    return this._handlesTempArray;
  }
  _handlesTempArray = [];
  /** Enable or disable instancing for this renderer.
   * @param enabled true to enable instancing, false to disable it
   */
  setInstancingEnabled(e) {
    if (this._isInstancingEnabled === e) return e && (this._handles === void 0 || this._handles != null && this._handles.length > 0);
    if (this._isInstancingEnabled = e, e) {
      if (this.enableInstancing === void 0 && (this.enableInstancing = !0), this._handles === void 0) {
        if (this._handles = Aa.instance.setup(this, this.gameObject, this.context, null, { rend: this, foundMeshes: 0, useMatrixWorldAutoUpdate: this.useInstanceMatrixWorldAutoUpdate() }), this._handles)
          return S.markAsInstancedRendered(this.gameObject, !0), !0;
      } else if (this._handles !== null) {
        for (const t of this._handles)
          t.updateInstanceMatrix(!0), t.add();
        return S.markAsInstancedRendered(this.gameObject, !0), !0;
      }
    } else {
      if (this._handles)
        for (const t of this._handles)
          t.remove(this.destroyed);
      return !0;
    }
    return !1;
  }
  clearInstancingState() {
    this._isInstancingEnabled = !1, this._handles = void 0;
  }
  /** Return true to wrap matrix update events for instanced rendering to update instance matrices automatically when matrixWorld changes
   * This is a separate method to be overrideable from user code
   */
  useInstanceMatrixWorldAutoUpdate() {
    return !0;
  }
  start() {
    if (this.enableInstancing && !z_ && (this.setInstancingEnabled(!0), ln.markDirty(this.gameObject)), this.gameObject.frustumCulled = this.allowOcclusionWhenDynamic, this.isMultiMaterialObject(this.gameObject))
      for (let e = 0; e < this.gameObject.children.length; e++) {
        const t = this.gameObject.children[e];
        t.frustumCulled = this.allowOcclusionWhenDynamic;
      }
  }
  onEnable() {
    this.sharedMeshes, this.setVisibility(!0), this._isInstancingEnabled || this.enableInstancing == !0 || Array.isArray(this.enableInstancing) && this.enableInstancing.some((t) => t) ? this.__internalDidAwakeAndStart && this.setInstancingEnabled(!0) : this.enabled && this.applyStencil(), this.updateReflectionProbe();
  }
  onDisable() {
    this.setVisibility(!1), this._handles && this._handles.length > 0 && this.setInstancingEnabled(!1);
  }
  onDestroy() {
    if (this._handles = null, this.isMultiMaterialObject(this.gameObject))
      for (const e of this.gameObject.children)
        this.context.removeBeforeRenderListener(e, this.onBeforeRenderThree);
    else
      this.context.removeBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
  }
  onBeforeRender() {
    if (this.gameObject) {
      if (this._probeAnchorLastFrame !== this.probeAnchor && (this._reflectionProbe?.onUnset(this), this.updateReflectionProbe()), qr == this.name && this.gameObject instanceof G) {
        this.gameObject.geometry.computeBoundingSphere();
        const e = H(this.gameObject.geometry.boundingSphere.center).applyMatrix4(this.gameObject.matrixWorld);
        z.DrawWireSphere(e, this.gameObject.geometry.boundingSphere.radius, 56831);
      }
      if (this.isMultiMaterialObject(this.gameObject) && this.gameObject.children?.length > 0)
        for (const e of this.gameObject.children)
          this.applySettings(e);
      else
        this.applySettings(this.gameObject);
      if (this.sharedMaterials?.changed && (this.sharedMaterials.changed = !1, this.applyLightmapping()), this._handles?.length && this.gameObject[pc] === !0) {
        this.gameObject[pc] = !1;
        for (let t = this._handles.length - 1; t >= 0; t--)
          this._handles[t].updateInstanceMatrix();
        this.gameObject.matrixWorldNeedsUpdate = !1;
      }
      if (this._handles && this._handles.length <= 0 && S.markAsInstancedRendered(this.gameObject, !1), this._isInstancingEnabled && this._handles)
        for (let e = 0; e < this._handles.length; e++) {
          const t = this._handles[e];
          ds(t.object, !1);
        }
      if (this.reflectionProbeUsage !== 0 && this._reflectionProbe && (this._lightmaps?.length || this._reflectionProbe.onSet(this)), this._sharedMaterials)
        for (const e of this._sharedMaterials)
          e && "envMap" in e && "envMapIntensity" in e && !kd.isUsingReflectionProbe(e) && (e.envMap = this.context.scene.environment);
      else qr && console.warn("[Renderer] sharedMaterials not initialized yet: " + this.name);
    }
  }
  onBeforeRenderThree = (e, t, i, n, o, r) => {
    if (o.envMapIntensity !== void 0) {
      const a = this.hasLightmap ? Math.PI : 1, l = this.context.mainCameraComponent?.environmentIntensity ?? 1;
      o.envMapIntensity = Math.max(0, l * this.context.sceneLighting.environmentIntensity / a);
    }
    if (this._lightmaps)
      for (const a of this._lightmaps)
        a.updateLightmapUniforms(o), a.applyLightmap();
  };
  onAfterRender() {
    if (this._isInstancingEnabled && this._handles)
      for (let e = 0; e < this._handles.length; e++) {
        const t = this._handles[e];
        ds(t.object, !0);
      }
    this.reflectionProbeUsage !== 0 && this._reflectionProbe && this._reflectionProbe.onUnset(this), this.static && this.gameObject.matrixAutoUpdate && (this.gameObject.matrixAutoUpdate = !1);
  }
  /** Applies stencil settings for this renderer's objects (if stencil settings are available) */
  applyStencil() {
    Zs.applyStencil(this);
  }
  /** Apply the settings of this renderer to the given object
   * Settings include shadow casting and receiving (e.g. this.receiveShadows, this.shadowCastingMode)
   */
  applySettings(e) {
    e.receiveShadow = this.receiveShadows, this.shadowCastingMode == 1 ? e.castShadow = !0 : e.castShadow = !1;
  }
  _reflectionProbe = null;
  updateReflectionProbe() {
    this._reflectionProbe = null, this.reflectionProbeUsage !== 0 && (this.startCoroutine(this._updateReflectionProbe(), xe.LateUpdate), this._probeAnchorLastFrame = this.probeAnchor);
  }
  *_updateReflectionProbe() {
    const e = this.probeAnchor || this.gameObject, t = !!this.probeAnchor;
    this._reflectionProbe = kd.get(e, this.context, t, this.probeAnchor);
  }
  setVisibility(e) {
    if (!this.isMultiMaterialObject(this.gameObject))
      ds(this.gameObject, e);
    else
      for (const t of this.gameObject.children)
        this.isMeshOrSkinnedMesh(t) && ds(t, e);
  }
  isMultiMaterialObject(e) {
    return e.type === "Group";
  }
  isMeshOrSkinnedMesh(e) {
    return e.type === "Mesh" || e.type === "SkinnedMesh";
  }
};
Es([
  u()
], Wn.prototype, "receiveShadows");
Es([
  u()
], Wn.prototype, "shadowCastingMode");
Es([
  u()
], Wn.prototype, "lightmapIndex");
Es([
  u(fe)
], Wn.prototype, "lightmapScaleOffset");
Es([
  u()
], Wn.prototype, "enableInstancing");
Es([
  u()
], Wn.prototype, "renderOrder");
Es([
  u()
], Wn.prototype, "allowOcclusionWhenDynamic");
Es([
  u(M)
], Wn.prototype, "probeAnchor");
Es([
  u()
], Wn.prototype, "reflectionProbeUsage");
let Qi = Wn;
class yu extends Qi {
}
class Av extends yu {
  _needUpdateBoundingSphere = !1;
  // private _lastWorldPosition = new Vector3();
  awake() {
    super.awake(), F_ && console.log('SkinnedMeshRenderer for "' + this.name + '"', this), this.allowOcclusionWhenDynamic = !1;
    for (const e of this.sharedMeshes)
      e.parent?.updateWorldMatrix(!1, !0), this.markBoundsDirty();
  }
  onAfterRender() {
    if (super.onAfterRender(), this._needUpdateBoundingSphere) {
      for (const e of this.sharedMeshes)
        if (e instanceof oo) {
          this._needUpdateBoundingSphere = !1;
          try {
            const t = e.geometry, i = Lb(e);
            i && (e.geometry = i), e.computeBoundingSphere(), e.geometry = t;
          } catch (t) {
            console.error(`Error updating bounding sphere for ${e.name}`, t);
          }
        }
    }
    if (F_) {
      for (const e of this.sharedMeshes)
        if (e instanceof oo && e.boundingSphere) {
          const t = H(e.boundingSphere.center).applyMatrix4(e.matrixWorld);
          z.DrawWireSphere(t, e.boundingSphere.radius, "red");
        }
    }
  }
  markBoundsDirty() {
    this._needUpdateBoundingSphere = !0;
  }
}
var GM = Object.defineProperty, Iv = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && GM(e, t, n), n;
};
const bh = w("debuggltfexport");
class Lv extends Pt {
  sceneRoot;
}
const vg = class Xr extends R {
  binary = !0;
  objects = [];
  ext;
  async exportNow(e, t) {
    bh && console.log("Exporting objects as glTF", this.objects), e || (e = "scene"), (!this.objects || this.objects.length <= 0) && (this.objects = [this.context.scene]);
    const i = {
      binary: this.binary,
      pivot: Xr.calculateCenter(this.objects),
      ...t
    }, n = await this.export(this.objects, i).catch((o) => (console.error(o), !1));
    return n === !1 ? !1 : (this.binary ? e.endsWith(".glb") || (e += ".glb") : e.endsWith(".gltf") || (e += ".gltf"), this.binary ? Xr.saveArrayBuffer(n, e) : Xr.saveJson(n, e), !0);
  }
  async export(e, t) {
    if (!e || e.length <= 0) {
      console.warn("No objects set to export");
      return;
    }
    const i = new Fb();
    i.register((c) => new Tv(c)), i.register((c) => new Cv(c)), Rv(i, this.context), Xr.filterTopmostParent(e);
    const n = {
      trs: !1,
      onlyVisible: !0,
      truncateDrawRange: !1,
      binary: !0,
      maxTextureSize: 1 / 0,
      // To prevent NaN value,
      embedImages: !0,
      includeCustomExtensions: !0,
      animations: t?.animations || Xr.collectAnimations(e),
      ...t
    }, o = new Array(), r = new M();
    t?.pivot && r.position.sub(t.pivot), bh && console.log("EXPORT", e), e.forEach((c) => {
      c && qp(c) && (r.children.push(c), c.matrixAutoUpdate = !1, c.matrix.copy(c.matrixWorld), S.getComponentsInChildren(c, Qi).forEach((h) => {
        S.isActiveInHierarchy(h.gameObject) && h.setInstancingEnabled(!1);
      }), c.traverse((h) => {
        if (!qp(h)) {
          const d = h.parent;
          h.removeFromParent(), o.push(() => {
            d && d.add(h);
          });
        }
      }));
    });
    const a = new j0(r);
    return t?.needleComponents && (this.ext = new Pv()), this.ext && (this.ext.registerExport(i), this.ext.context = a), new Promise((c, h) => {
      bh && console.log("Starting glTF export.");
      try {
        i?.parse(
          r,
          // called when the gltf has been generated
          (d) => {
            l(), c(d);
          },
          // called when there is an error in the generation
          (d) => {
            l(), h(d);
          },
          n
        );
      } catch (d) {
        console.error(d), h(d);
      } finally {
        o.forEach((d) => d()), bh && console.log("Finished glTF export.");
      }
    });
    function l() {
      e.forEach((c) => {
        c && (c.matrixAutoUpdate = !0, S.getComponentsInChildren(c, Qi).forEach((h) => {
          S.isActiveInHierarchy(h.gameObject) && h.setInstancingEnabled(!1);
        }));
      });
    }
  }
  static saveArrayBuffer(e, t) {
    this.save(new Blob([e], { type: "application/octet-stream" }), t);
  }
  static saveJson(e, t) {
    this.save("data: text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(e)), t);
  }
  static save(e, t) {
    const i = document.createElement("a");
    i.style.display = "none", document.body.appendChild(i), typeof e == "string" ? i.href = e : i.href = URL.createObjectURL(e), i.download = t, i.click(), i.remove();
  }
  static collectAnimations(e, t) {
    t = t || [];
    for (const i of e)
      i && i.traverseVisible((n) => {
        n.animations && n.animations.length > 0 && t.push(...n.animations);
      });
    return t;
  }
  static calculateCenter(e, t) {
    const i = t || new y();
    return i.set(0, 0, 0), e.forEach((n) => {
      i.add(Z(n));
    }), i.divideScalar(e.length), i;
  }
  static filterTopmostParent(e) {
    if (!(e.length <= 0))
      for (let t = 0; t < e.length; t++) {
        let i = e[t];
        if (!i) {
          e.splice(t, 1), t--;
          continue;
        }
        for (; i.parent; ) {
          if (e.includes(i.parent)) {
            e.splice(t, 1), t--;
            break;
          }
          i = i.parent;
        }
      }
  }
};
Iv([
  u()
], vg.prototype, "binary");
Iv([
  u(M)
], vg.prototype, "objects");
let Dv = vg;
typeof globalThis !== void 0 && !("OffscreenCanvas" in globalThis) && (globalThis.OffscreenCanvas = class {
  canvas;
  constructor(e, t) {
    return this.canvas = document.createElement("canvas"), this.canvas.width = e, this.canvas.height = t, this.canvas.convertToBlob = (i, n) => new Promise((o) => {
      this.canvas.toBlob(o, i, n);
    }), this.canvas;
  }
});
const qM = w("debugprogress");
function XM(s) {
  s = s || /* @__PURE__ */ new Date();
  const e = s.getMonth() + 1, t = s.getDate(), i = s.getHours(), n = s.getMinutes(), o = s.getSeconds(), r = (e < 10 ? "0" : "") + e, a = (t < 10 ? "0" : "") + t, l = (i < 10 ? "0" : "") + i, c = (n < 10 ? "0" : "") + n, h = (o < 10 ? "0" : "") + o;
  return s.getFullYear() + r + a + "-" + l + c + h;
}
class le {
  /** Start a new progress reporting scope. Make sure to close it with Progress.end.
   * @param scope The scope to start progress reporting for.
   * @param options Parent scope, onProgress callback and logging. If only a string is provided, it's used as parentScope.
   * @example
   * // Manual usage:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting object 1", currentStep: 1, totalSteps: 3 });
   * Progress.report("export-usdz", { message: "Exporting object 2", currentStep: 2, totalSteps: 3 });
   * Progress.report("export-usdz", { message: "Exporting object 3", currentStep: 3, totalSteps: 3 });
   * 
   * // Auto step usage:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting objects", autoStep: true, totalSteps: 3 });
   * Progress.report("export-usdz", "Exporting object 1");
   * Progress.report("export-usdz", "Exporting object 2");
   * Progress.report("export-usdz", "Exporting object 3");
   * Progress.end("export-usdz");
   * 
   * // Auto step with weights:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting objects", autoStep: true, totalSteps: 10 });
   * Progress.report("export-usdz", { message: "Exporting object 1", autoStep: 8 }); // will advance to 80% progress
   * Progress.report("export-usdz", "Exporting object 2"); // 90%
   * Progress.report("export-usdz", "Exporting object 3"); // 100%
   * 
   * // Child scopes:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Overall export", autoStep: true, totalSteps: 2 });
   * Progress.start("export-usdz-objects", "export-usdz");
   * Progress.report("export-usdz-objects", { message: "Exporting objects", autoStep: true, totalSteps: 3 });
   * Progress.report("export-usdz-objects", "Exporting object 1");
   * Progress.report("export-usdz-objects", "Exporting object 2");
   * Progress.report("export-usdz-objects", "Exporting object 3");
   * Progress.end("export-usdz-objects");
   * Progress.report("export-usdz", "Exporting materials");
   * Progress.end("export-usdz");
   * 
   * // Enable console logging:
   * Progress.start("export-usdz", { logTimings: true });
   */
  static start(e, t) {
    typeof t == "string" && (t = { parentScope: t });
    const i = new QM(e, t);
    Dl.set(e, i);
  }
  /** Report progress for a formerly started scope.
   * @param scope The scope to report progress for.
   * @param options Options for the progress report. If a string is passed, it will be used as the message.
   * @example
   * // auto step and show a message
   * Progress.report("export-usdz", "Exporting object 1");
   * // same as above
   * Progress.report("export-usdz", { message: "Exporting object 1", autoStep: true });
   * // show the current step and total steps and implicitly calculate progress as 10%
   * Progress.report("export-usdz", { currentStep: 1, totalSteps: 10 });
   * // enable auto step mode, following calls that have autoStep true will increase currentStep automatically.
   * Progress.report("export-usdz", { totalSteps: 20, autoStep: true });
   * // show the progress as 50%
   * Progress.report("export-usdz", { progress: 0.5 });
   * // give this step a weight of 20, which changes how progress is calculated. Useful for steps that take longer and/or have child scopes.
   * Progress.report("export-usdz", { message. "Long process", autoStep: 20 });
   * // show the current step and total steps and implicitly calculate progress as 10%
   * Progress.report("export-usdz", { currentStep: 1, totalSteps: 10 });
   */
  static report(e, t) {
    const i = Dl.get(e);
    if (!i) {
      console.warn("Reporting progress for non-existing scope", e);
      return;
    }
    typeof t == "string" && (t = { message: t, autoStep: !0 }), i.report(t);
  }
  /** End a formerly started scope. This will also report the progress as 100%.
   * @remarks Will warn if any child scope is still running (progress < 1).
  */
  static end(e) {
    const t = Dl.get(e);
    t && (t.end(), Dl.delete(e));
  }
}
const Dl = /* @__PURE__ */ new Map();
class QM {
  scopeLabel;
  parentScope;
  childScopes = [];
  parentDepth = 0;
  lastStep = 0;
  lastAutoStepWeight = 1;
  lastTotalSteps = 0;
  onProgress;
  showLogs = !1;
  selfProgress = 0;
  totalProgress = 0;
  selfReports = 0;
  totalReports = 0;
  constructor(e, t) {
    this.parentScope = t?.parentScope ? Dl.get(t.parentScope) : void 0, this.parentScope && (this.parentScope.childScopes.push(this), this.parentDepth = this.parentScope.parentDepth + 1), this.scopeLabel = " ".repeat(this.parentDepth * 2) + e, this.showLogs = t?.logTimings ?? !!qM, this.showLogs && console.time(this.scopeLabel), this.onProgress = t?.onProgress;
  }
  report(e, t = !1) {
    if (e) {
      if (e.totalSteps !== void 0 && (this.lastTotalSteps = e.totalSteps), e.currentStep !== void 0 && (this.lastStep = e.currentStep), e.autoStep !== void 0) {
        if (e.currentStep === void 0) {
          this.lastStep === void 0 && (this.lastStep = 0);
          const n = typeof e.autoStep == "number" ? e.autoStep : 1;
          this.lastStep += this.lastAutoStepWeight, this.lastAutoStepWeight = n, e.currentStep = this.lastStep;
        }
        e.totalSteps = this.lastTotalSteps;
      }
      e.progress !== void 0 ? this.selfProgress = e.progress : e.currentStep !== void 0 && e.totalSteps !== void 0 && (this.selfProgress = e.currentStep / e.totalSteps);
    }
    if (this.childScopes.length > 0) {
      let n = 0, o = 0;
      for (const a of this.childScopes)
        n += a.selfProgress, o += 1;
      o > 0 && (n /= o);
      const r = this.lastAutoStepWeight / (this.lastTotalSteps ?? 1);
      this.totalProgress = this.selfProgress + n * r;
    } else
      this.totalProgress = this.selfProgress;
    this.selfProgress = Math.min(1, this.selfProgress), this.totalProgress = Math.min(1, this.totalProgress);
    let i = (this.totalProgress * 100).toFixed(3) + "%";
    this.childScopes.length > 0 && (i += " (" + (this.selfProgress * 100).toFixed(3) + "% self)"), e?.message && (i = e.message + " – " + i), this.lastStep !== void 0 && this.lastTotalSteps !== void 0 && (i = "Step " + (this.lastStep + (this.lastAutoStepWeight != 1 ? "–" + (this.lastStep + this.lastAutoStepWeight) : "") + "/" + this.lastTotalSteps) + " " + i), t ? this.totalReports++ : (this.selfReports++, this.totalReports++), this.showLogs && console.timeLog(this.scopeLabel, i), this.onProgress && this.onProgress(this.totalProgress), this.parentScope && this.parentScope.report(void 0, !0);
  }
  end() {
    this.report({ progress: 1, autoStep: !0 }, !0), this.showLogs && (console.timeLog(this.scopeLabel, "Total reports: " + this.totalReports, "Self reports: " + this.selfReports), console.timeEnd(this.scopeLabel));
    let e = !1;
    for (const t of this.childScopes)
      if (!(t.selfProgress >= 1)) {
        e = !0;
        break;
      }
    e && console.warn("Progress end with child scopes that are still running", this), this.onProgress = void 0;
  }
}
const Ie = "</StageRoot/Materials";
function YM(s, e, t) {
  const i = /* @__PURE__ */ new Map(), n = (b) => {
    const m = b.type___needle, v = i.get(m) || /* @__PURE__ */ new Map();
    if (i.set(m, v), !v.has(b)) {
      const _ = `${m}${v.size ? `_${v.size}` : ""}`;
      v.set(b, _);
    }
    return v.get(b);
  }, o = s.colorNode ? vh(s.colorNode) : [], r = s.colorNode ? `color3f inputs:diffuseColor.connect = ${Ie}/${e}/${n(o.values().next().value)}.outputs:out>` : "", a = s.roughnessNode ? vh(s.roughnessNode) : [], l = s.roughnessNode ? `float inputs:roughness.connect = ${Ie}/${e}/${n(a.values().next().value)}.outputs:out>` : "", c = s.normalNode ? vh(s.normalNode) : [], h = s.normalNode ? `float3 inputs:normal.connect = ${Ie}/${e}/${n(c.values().next().value)}.outputs:out>` : "", d = s.metalnessNode ? vh(s.metalnessNode) : [], f = s.metalnessNode ? `float inputs:metallic.connect = ${Ie}/${e}/${n(d.values().next().value)}.outputs:out>` : "", p = /* @__PURE__ */ new Set([...o, ...a, ...c, ...d]), g = JM(p, e, t, n);
  return console.debug(g), `

	def Material "${e}" ${s.name ? `(
		displayName = "${s.name}"
	)` : ""}
	{
		token outputs:mtlx:surface.connect = ${Ie}/${e}/N_mtlxsurface.outputs:surface>

		def Shader "N_mtlxsurface"
		{
			uniform token info:id = "ND_UsdPreviewSurface_surfaceshader"
			${r}
			${l}
			${h}
			${f}
			token outputs:surface
		}
		
		${g}
		
	}`;
}
function vh(s) {
  const e = (m) => {
    if (m.nodeType) return m.nodeType;
    switch (m.type) {
      case "TimerNode":
        return "float";
      case "TextureNode":
        return;
      case "ConvertNode":
        return m.convertTo;
      default:
        return;
    }
  }, t = (m) => {
    const v = /* @__PURE__ */ new Set(), _ = (x) => {
      if (!(!x.isNode || v.has(x))) {
        x.nodeType___needle || (x.nodeType___needle = e(x)), x.shaderNode ? (x.type___needle = "ShaderCallNodeInternal", x.shaderNodeLayoutName___needle = x.shaderNode.layout.name.slice(3)) : x.type___needle = x.type, v.add(x);
        for (const I in x)
          x[I]?.isNode && (_(x[I]), x.nodeType___needle ||= x[I].nodeType___needle), Array.isArray(x[I]) && x[I].forEach((O) => {
            O.isNode && (_(O), x.nodeType___needle ||= O.nodeType___needle);
          });
      }
    };
    return _(m), v;
  }, i = (m) => {
    if (m.type === "ConvertNode") {
      if (m.convertTo === m.node.nodeType___needle)
        return !0;
      if (m.node.type === "ConstNode") {
        if (m.convertTo === "vec4" && m.node.value.isVector4)
          return !0;
        if (m.convertTo === "vec3" && m.node.value.isVector3)
          return !0;
        if (m.convertTo === "vec2" && m.node.value.isVector2)
          return !0;
        if (m.convertTo === "color" && m.node.value.isColor)
          return !0;
        if (m.convertTo === "float" && typeof m.node.value == "number")
          return !0;
      } else if (m.node.type == "SplitNode" && m.convertTo == "float" && m.node.components.length === 1)
        return !0;
    }
    return !1;
  }, n = (m) => {
    for (; o(m); )
      !m.node && m.shaderNode ? m = m.inputNodes[0] : m = m.node ?? m.aNode ?? m.bNode ?? m.cNode;
    return m;
  }, o = (m) => {
    const v = ["UniformNode", "UniformGroupNode", "ShaderNodeInternal"];
    return !m || i(m) || v.includes(m.type___needle) || m.type___needle === void 0;
  }, r = (m, v) => {
    for (const _ of v)
      for (const x in _) {
        if (_[x]?.isNode && _[x] === m)
          return { parent: _, label: x };
        if (Array.isArray(_[x]) && _[x].find((O) => O.isNode && O === m))
          return { parent: _, label: x };
      }
    return null;
  }, a = (m, v) => {
    if (m.shaderNode)
      m.inputNodes[0] = n(m.inputNodes[0]);
    else if (Array.isArray(m.nodes))
      for (let _ = 0; _ < m.nodes.length; _++)
        m.nodes[_] && o(m.nodes[_]) && (m.nodes[_] = n(m.nodes[_]));
    else
      v.forEach((_) => {
        m[_] && o(m[_]) && (m[_] = n(m[_]));
      });
  }, l = (m) => {
    m.type === "MathNode" && m.method === "mix" && (m.cNode.nodeType___needle = "float", m.cNode.type === "ConvertNode" && (m.cNode.convertTo = "float"));
  }, c = (m, v) => {
    v.label === "cNode" && v.parent.type === "MathNode" && v.parent.method === "mix" || (v.parent.type === "JoinNode" ? m.nodeType___needle = "float" : m.nodeType___needle = v.parent.nodeType___needle);
  }, h = (m) => m?.type === "ConvertNode" && m.nodeType___needle === "color" && m.node.nodeType___needle === "vec4", d = (m, v) => {
    m.convertTo = "vec3", m.nodeType___needle = "vec3";
    const _ = {
      type: "ConvertNode",
      convertTo: "color",
      node: m,
      isNode: !0,
      nodeType___needle: "color",
      type___needle: "ConvertNode"
    }, x = r(m, v);
    return x?.parent && (x.parent[x.label] = _), _;
  }, f = (m) => m?.type === "ConvertNode" && m.node.type === "TextureNode" && m.nodeType___needle !== m.node.nodeType___needle, p = (m) => {
    const v = /* @__PURE__ */ new Set();
    for (let _ of m)
      if (!o(_)) {
        if (l(_), _.type == "SplitNode") {
          const x = r(_, m);
          if (_.components.length === 1)
            _.nodeType___needle = "float";
          else if (x)
            _.nodeType___needle = x.parent.nodeType___needle;
          else throw new Error("SplitNode without parent found, this should not happen");
        }
        if (a(_, ["node", "aNode", "bNode", "cNode"]), _.type == "ConstNode" && _.nodeType == null && c(_, r(_, m)), h(_) && v.add(d(_, m)), f(_)) {
          _.node.nodeType___needle = _.convertTo;
          const x = r(_, m);
          x?.parent && (x.parent[x.label] = _.node), _ = _.node;
        }
        v.add(_);
      }
    return v;
  }, g = t(s);
  return p(g);
}
function KM(s, e) {
  switch (e) {
    case "float4":
      return s.isVector4 ? `(${s.x}, ${s.y}, ${s.z}, ${s.w})` : `(${s}, ${s}, ${s}, ${s})`;
    case "float3":
      return s.isVector3 ? `(${s.x}, ${s.y}, ${s.z})` : `(${s}, ${s}, ${s})`;
    case "float2":
      return s.isVector2 ? `(${s.x}, ${s.y})` : `(${s}, ${s})`;
    case "color3f":
      return s.isColor ? `(${s.r}, ${s.g}, ${s.b})` : `(${s}, ${s}, ${s})`;
    default:
      return s.isVector4 || s.isVector3 || s.isVector2 ? `${s.x}` : s.isColor ? `${s.r}` : `${s}`;
  }
}
function ZM(s, e, t, i) {
  const n = "        ", o = (p) => ({
    float: "float",
    vec2: "vector2",
    vec3: "vector3",
    vec4: "vector4",
    color: "color3"
  })[p] || "float", r = (p) => ({
    float: "float",
    vec2: "float2",
    vec3: "float3",
    vec4: "float4",
    color: "color3f"
  })[p] || "float", a = s.type___needle, l = s.nodeType___needle, c = o(l);
  let h = r(l), d = "";
  const f = new Array();
  switch (a) {
    case "UniformGroupNode":
    case "UniformNode":
      return "";
    case "TimerNode":
      d = "time_float";
      break;
    case "ConstNode":
      d = "constant_" + c, f.push(`${h} inputs:value = ${KM(s.value, h)}`);
      break;
    case "JoinNode":
      d = "combine" + s.nodes.length + "_" + c;
      let p = 1;
      for (const x of s.nodes)
        f.push(`float inputs:in${p++}.connect = ${Ie}/${e}/${t(x)}.outputs:out>`);
      break;
    case "ConvertNode":
      d = "convert_" + o(s.node.nodeType___needle) + "_" + c, s.node && f.push(`${r(s.node.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.node)}.outputs:out>`);
      break;
    case "MathNode":
      d = s.method + "_" + c, s.aNode && !s.bNode && f.push(`${r(s.aNode.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), s.aNode && s.bNode && !s.cNode && (f.push(`${r(s.aNode.nodeType___needle)} inputs:in1.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), f.push(`${r(s.bNode.nodeType___needle)} inputs:in2.connect = ${Ie}/${e}/${t(s.bNode)}.outputs:out>`)), s.aNode && s.bNode && s.cNode && s.method == "clamp" && (f.push(`${r(s.aNode.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), f.push(`${r(s.bNode.nodeType___needle)} inputs:low.connect = ${Ie}/${e}/${t(s.bNode)}.outputs:out>`), f.push(`${r(s.cNode.nodeType___needle)} inputs:high.connect = ${Ie}/${e}/${t(s.cNode)}.outputs:out>`)), s.aNode && s.bNode && s.cNode && s.method == "mix" && (f.push(`${r(s.aNode.nodeType___needle)} inputs:fg.connect = ${Ie}/${e}/${t(s.bNode)}.outputs:out>`), f.push(`${r(s.bNode.nodeType___needle)} inputs:bg.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), f.push(`float inputs:mix.connect = ${Ie}/${e}/${t(s.cNode)}.outputs:out>`));
      break;
    case "OperatorNode":
      let b = "";
      switch (s.op) {
        case "*":
          b = "multiply";
          break;
        case "/":
          b = "divide";
          break;
        case "+":
          b = "add";
          break;
        case "-":
          b = "subtract";
          break;
      }
      if (d = b + "_" + c, s.aNode && !s.bNode && f.push(`${r(s.aNode.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), s.aNode && s.bNode) {
        const x = r(s.aNode.nodeType___needle), I = r(s.bNode.nodeType___needle);
        (x === "color3f" && I === "float" || I === "float" && I === "color3f") && (d = b + "_color3FA"), f.push(`${x} inputs:in1.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), f.push(`${I} inputs:in2.connect = ${Ie}/${e}/${t(s.bNode)}.outputs:out>`);
      }
      break;
    case "TextureNode":
      s.uvNode ? (d = "tiledimage_" + c, f.push(`float2 inputs:texcoord.connect = ${Ie}/${e}/${t(s.uvNode)}.outputs:out>`)) : d = "image_" + c;
      const m = s._value, v = wg.includes(m.format), _ = eR(m);
      f.push(`asset inputs:file = @textures/${_}.${v ? "png" : "jpg"}@`), i[_] = { texture: m, scale: void 0 };
      break;
    case "NormalMapNode":
      h = "float3", d = "normalmap", f.push(`${h} inputs:in.connect = ${Ie}/${e}/${t(s.node)}.outputs:out>`);
      break;
    case "AttributeNode":
      d = "geompropvalue_" + c, f.push('string inputs:geomprop = "st"');
      break;
    case "ShaderCallNodeInternal":
      d = s.shaderNodeLayoutName___needle + "_" + c, f.push(`${h} inputs:in.connect = ${Ie}/${e}/${t(s.inputNodes[0])}.outputs:out>`);
      break;
    case "SplitNode":
      d = "swizzle_" + o(s.node.nodeType___needle) + "_" + c, f.push(`${r(s.node.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.node)}.outputs:out>`), f.push(`string inputs:channels = "${s.components}"`);
      break;
  }
  return `
	${n}def Shader "${t(s)}"
	${n}{
		${n}uniform token info:id = "ND_${d}"
		${n}${h} outputs:out
		${n}${f.length > 0 ? f.join(`
				`) : ""}
	${n}}
	`;
}
function JM(s, e, t, i) {
  let n = "";
  for (const o of s)
    n += ZM(o, e, i, t);
  return n;
}
function eR(s) {
  return dn(s.name) + "_" + (s.source?.id ?? s.id);
}
function dn(s) {
  return s = s.replace(/[^a-zA-Z0-9_]/g, ""), s.match(/^[a-zA-Z_]/) || (s = "_" + s), s;
}
function jv(s) {
  return s = s.replace('"', '\\"'), s;
}
function Bv(s) {
  if (s.length === 0) return null;
  const e = s.map((i) => {
    const n = new Array();
    for (; i.parent; )
      n.unshift(i.parent), i = i.parent;
    return n;
  });
  return e[0].findLast((i) => e.every((n) => n.includes(i))) || null;
}
function Fv(s) {
  const e = Bv(s), t = /* @__PURE__ */ new Set();
  for (const i of s) {
    let n = i.parent;
    for (; n && n !== e; )
      s.includes(n) || t.add(n), n = n.parent;
  }
  return t;
}
const tR = new y(), iR = new U(), nR = new y(1, 1, 1);
class st {
  static USDObject_export_id = 0;
  uuid;
  name;
  /** If no type is provided, type is chosen automatically (Xform or Mesh) */
  type;
  /** MaterialBindingAPI and SkelBindingAPI are handled automatically, extra schemas can be added here */
  extraSchemas = [];
  displayName;
  visibility;
  // defaults to "inherited" in USD
  getMatrix() {
    if (!this.transform) return new ee();
    const { position: e, quaternion: t, scale: i } = this.transform, n = new ee();
    return n.compose(e || tR, t || iR, i || nR), n;
  }
  setMatrix(e) {
    if (!e || !(e instanceof ee)) {
      this.transform = null;
      return;
    }
    const t = new y(), i = new U(), n = new y();
    e.decompose(t, i, n), this.transform = { position: t, quaternion: i, scale: n };
  }
  /** @deprecated Use `transform`, or `getMatrix()` if you really need the matrix */
  get matrix() {
    return this.getMatrix();
  }
  /** @deprecated Use `transform`, or `setMatrix()` if you really need the matrix */
  set matrix(e) {
    this.setMatrix(e);
  }
  transform = null;
  _isDynamic;
  get isDynamic() {
    return this._isDynamic;
  }
  set isDynamic(e) {
    this._isDynamic = e;
  }
  geometry;
  material;
  camera;
  parent;
  skinnedMesh;
  children = [];
  animations;
  _eventListeners;
  // these are for tracking which xformops are needed
  needsTranslate = !1;
  needsOrient = !1;
  needsScale = !1;
  static createEmptyParent(e) {
    const t = new st(ys.generateUUID(), e.name + "_empty_" + st.USDObject_export_id++, e.transform), i = e.parent;
    return i && i.add(t), t.add(e), t.isDynamic = !0, e.transform = null, t;
  }
  static createEmpty() {
    const e = new st(ys.generateUUID(), "Empty_" + st.USDObject_export_id++);
    return e.isDynamic = !0, e;
  }
  constructor(e, t, i = null, n = null, o = null, r = null, a = null, l = null) {
    this.uuid = e, this.name = dn(t), this.displayName = t, i ? this.transform = {
      position: i.position?.clone() || null,
      quaternion: i.quaternion?.clone() || null,
      scale: i.scale?.clone() || null
    } : this.transform = null, this.geometry = n, this.material = o, this.camera = r, this.parent = null, this.children = [], this._eventListeners = {}, this._isDynamic = !1, this.skinnedMesh = a, this.animations = l;
  }
  is(e) {
    return e ? this.uuid === e.uuid : !1;
  }
  isEmpty() {
    return !this.geometry;
  }
  clone() {
    const e = new st(ys.generateUUID(), this.name, this.transform, this.geometry, this.material);
    return e.isDynamic = this.isDynamic, e;
  }
  deepClone() {
    const e = this.clone();
    for (const t of this.children)
      t && e.add(t.deepClone());
    return e;
  }
  getPath() {
    let e = this.parent, t = this.name;
    for (; e; )
      t = (e.parent ? e.name : e.name + "/Scenes/Scene") + "/" + t, e = e.parent;
    return "</" + t + ">";
  }
  add(e) {
    e.parent && e.parent.remove(e), e.parent = this, this.children.push(e);
  }
  remove(e) {
    const t = this.children.indexOf(e);
    t >= 0 && (e.parent === this && (e.parent = null), this.children.splice(t, 1));
  }
  addEventListener(e, t) {
    this._eventListeners[e] || (this._eventListeners[e] = []), this._eventListeners[e].push(t);
  }
  removeEventListener(e, t) {
    if (!this._eventListeners[e]) return;
    const i = this._eventListeners[e].indexOf(t);
    i >= 0 && this._eventListeners[e].splice(i, 1);
  }
  onSerialize(e, t) {
    const i = this._eventListeners.serialize;
    i && i.forEach((n) => n(e, t));
  }
}
class zv extends st {
  stageLength;
  get isDocumentRoot() {
    return !0;
  }
  get isDynamic() {
    return !1;
  }
  constructor() {
    super(void 0, "StageRoot", null, null, null, null), this.children = [], this.stageLength = 200;
  }
  add(e) {
    e.parent = this, this.children.push(e);
  }
  remove(e) {
    const t = this.children.indexOf(e);
    t >= 0 && (e.parent === this && (e.parent = null), this.children.splice(t, 1));
  }
  traverse(e, t = null) {
    if (t !== null ? e(t) : t = this, t.children)
      for (const i of t.children)
        this.traverse(e, i);
  }
  findById(e) {
    let t = !1;
    function i(n) {
      if (!t) {
        if (n.uuid === e)
          return t = !0, n;
        if (n.children)
          for (const o of n.children) {
            if (!o) continue;
            const r = i(o);
            if (r) return r;
          }
      }
    }
    return i(this);
  }
  buildHeader(e) {
    const t = e.extensions?.find((h) => h?.extensionName === "animation"), i = e.extensions?.find((h) => h?.extensionName === "Behaviour"), n = e.extensions?.find((h) => h?.extensionName === "Physics"), o = t?.getStartTimeCode() ?? 0, r = t?.getEndTimeCode() ?? 0;
    let a = "";
    const l = t?.registeredClips;
    if (l)
      for (const h of l)
        a += `	# Animation: ${h.name}, start=${t.getStartTimeByClip(h) * 60}, length=${h.duration * 60}
`;
    const c = a;
    return `#usda 1.0
(
	customLayerData = {
		string creator = "Needle Engine ${En}"
		dictionary Needle = {
			bool animations = ${t ? 1 : 0}
			bool interactive = ${i ? 1 : 0}
			bool physics = ${n ? 1 : 0}
			bool quickLookCompatible = ${e.quickLookCompatible ? 1 : 0}
		}
	}
	defaultPrim = "${dn(this.name)}"
	metersPerUnit = 1
	upAxis = "Y"
	startTimeCode = ${o}
	endTimeCode = ${r}
	timeCodesPerSecond = 60
	framesPerSecond = 60
	doc = """Generated by Needle Engine USDZ Exporter ${En}"""
${c}
)
`;
  }
}
const Br = `
`, $t = "</StageRoot/Materials";
class sR {
  str;
  indent;
  constructor() {
    this.str = "", this.indent = 0;
  }
  clear() {
    this.str = "", this.indent = 0;
  }
  beginBlock(e = void 0, t = "{", i = !0) {
    e !== void 0 ? (e = this.applyIndent(e), this.str += e, i ? (this.str += Br, this.str += this.applyIndent(t)) : this.str += " " + t) : this.str += this.applyIndent(t), this.str += Br, this.indent += 1;
  }
  closeBlock(e = "}") {
    this.indent -= 1, this.str += this.applyIndent(e) + Br;
  }
  beginArray(e) {
    e = this.applyIndent(e + " = ["), this.str += e, this.str += Br, this.indent += 1;
  }
  closeArray() {
    this.indent -= 1, this.str += this.applyIndent("]") + Br;
  }
  appendLine(e = "") {
    e = this.applyIndent(e), this.str += e, this.str += Br;
  }
  toString() {
    return this.str;
  }
  applyIndent(e) {
    let t = "";
    for (let i = 0; i < this.indent; i++) t += "	";
    return t + e;
  }
}
class oR {
  root;
  exporter;
  extensions = [];
  quickLookCompatible;
  exportInvisible;
  materials;
  textures;
  files;
  document;
  output;
  animations;
  constructor(e, t, i) {
    this.root = e, this.exporter = t, this.quickLookCompatible = i.quickLookCompatible, this.exportInvisible = i.exportInvisible, i.extensions && (this.extensions = i.extensions), this.materials = /* @__PURE__ */ new Map(), this.textures = {}, this.files = {}, this.document = new zv(), this.output = "", this.animations = [];
  }
}
class Uf {
  ar = {
    anchoring: { type: "plane" },
    planeAnchoring: { alignment: "horizontal" }
  };
  quickLookCompatible = !1;
  extensions = [];
  maxTextureSize = 4096;
  exportInvisible = !1;
}
let rR = class {
  debug;
  pruneUnusedNodes;
  sceneAnchoringOptions = new Uf();
  extensions = [];
  keepObject;
  beforeWritingDocument;
  constructor() {
    this.debug = !1, this.pruneUnusedNodes = !0;
  }
  async parse(e, t = new Uf()) {
    t = Object.assign(new Uf(), t), this.sceneAnchoringOptions = t;
    const i = new oR(e, this, t);
    this.extensions = i.extensions;
    const n = i.files, o = "model.usda";
    n[o] = null;
    const r = i.materials, a = i.textures;
    le.report("export-usdz", "Invoking onBeforeBuildDocument"), await Yh(i, "onBeforeBuildDocument"), le.report("export-usdz", "Done onBeforeBuildDocument"), le.report("export-usdz", "Reparent bones to common ancestor");
    const l = [], c = /* @__PURE__ */ new Set();
    e?.traverse((_) => {
      if (!(!t.exportInvisible && !_.visible) && _ instanceof oo) {
        const x = _.skeleton.bones, I = Bv(x);
        if (I) {
          const O = { object: _, originalParent: _.parent, newParent: I };
          l.push(O), c.add(O.object.uuid), O.newParent && c.add(O.newParent.uuid), O.originalParent && c.add(O.originalParent.uuid);
        }
      }
    });
    for (const _ of l) {
      const { object: x, originalParent: I, newParent: O } = _;
      O.add(x);
    }
    le.report("export-usdz", "Traversing hierarchy"), e && Uv(e, i.document, i, this.keepObject), le.report("export-usdz", "Invoking onAfterBuildDocument"), await Yh(i, "onAfterBuildDocument");
    const d = i.extensions.find((_) => _.extensionName === "Behaviour")?.getAllTargetUuids() ?? /* @__PURE__ */ new Set();
    if (this.pruneUnusedNodes) {
      const _ = {
        allBehaviorTargets: d,
        debug: !1,
        boneReparentings: c,
        quickLookCompatible: i.quickLookCompatible
      };
      this.debug && U_(i.document, "Hierarchy BEFORE pruning", _), Nv(i.document, _), this.debug && U_(i.document, "Hierarchy AFTER pruning");
    } else this.debug && console.log("Pruning of empty nodes is disabled. This may result in a larger USDZ file.");
    le.report("export-usdz", { message: "Parsing document", autoStep: 10 }), await aR(i, () => (le.report("export-usdz", "Building materials"), yR(r, a, t.quickLookCompatible))), le.report("export-usdz", "Invoking onAfterSerialize"), await Yh(i, "onAfterSerialize");
    for (const _ of l) {
      const { object: x, originalParent: I, newParent: O } = _;
      I && I.add(x);
    }
    i.exporter?.beforeWritingDocument?.();
    const p = i.document.buildHeader(i) + `
` + i.output;
    this.debug && console.log(p), n[o] = zb(p), i.output = "", le.report("export-usdz", { message: "Exporting textures", autoStep: 10 }), le.start("export-usdz-textures", { parentScope: "export-usdz", logTimings: !1 });
    const g = new mr({
      antialias: !1,
      alpha: !0,
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0
    }), b = Object.keys(a).length;
    le.report("export-usdz-textures", { totalSteps: b * 3, currentStep: 0 });
    const m = async (_) => {
      const x = a[_], I = x.texture, O = wg.includes(I.format);
      let k = {
        imageData: I.image
      };
      le.report("export-usdz-textures", { message: "read back texture", autoStep: !0 });
      const E = x.scale !== void 0 && x.scale.x !== 1 && x.scale.y !== 1 && x.scale.z !== 1 && x.scale.w !== 1;
      (I.isCompressedTexture || I.isRenderTargetTexture || E) && (k = await lR(I, t.maxTextureSize, g, x.scale)), le.report("export-usdz-textures", { message: "convert texture to canvas", autoStep: !0 });
      const B = await hR(k.imageBitmap || k.imageData, t.maxTextureSize).catch((D) => {
        console.error("Error converting texture to canvas", I, D);
      });
      if (B) {
        le.report("export-usdz-textures", { message: "convert canvas to blob", autoStep: !0 });
        const D = await B.convertToBlob({ type: O ? "image/png" : "image/jpeg", quality: 0.95 });
        n[`textures/${_}.${O ? "png" : "jpg"}`] = new Uint8Array(await D.arrayBuffer());
      } else
        console.warn("Can`t export texture: ", I);
    };
    for (const _ in a)
      await m(_);
    g.dispose(), le.end("export-usdz-textures");
    let v = 0;
    for (const _ in n) {
      const x = n[_], I = 34 + _.length;
      v += I;
      const O = v & 63;
      if (O !== 4) {
        const k = 64 - O, E = new Uint8Array(k);
        n[_] = [x, { extra: { 12345: E } }];
      }
      v = x.length;
    }
    return le.report("export-usdz", "zip archive"), DS(n, { level: 0 });
  }
};
function Uv(s, e, t, i) {
  if (!t.exportInvisible && !s.visible) return;
  let n, o, r;
  const a = { position: s.position, quaternion: s.quaternion, scale: s.scale };
  if (s.position.x === 0 && s.position.y === 0 && s.position.z === 0 && (a.position = null), s.quaternion.x === 0 && s.quaternion.y === 0 && s.quaternion.z === 0 && s.quaternion.w === 1 && (a.quaternion = null), s.scale.x === 1 && s.scale.y === 1 && s.scale.z === 1 && (a.scale = null), (s instanceof G || s instanceof oo) && (o = s.geometry, r = s.material), i && !i(s) && (o = void 0, r = void 0), (s instanceof G || s instanceof oo) && r && typeof r == "object" && (r instanceof ut || r instanceof we || // material instanceof MeshPhysicalNodeMaterial ||
  r.isMeshPhysicalNodeMaterial || r instanceof _e && r.type === "MeshLineMaterial")) {
    const l = Sh(s), c = s instanceof oo ? s : null;
    n = new st(s.uuid, l, a, o, r, void 0, c, s.animations);
  } else if (s instanceof de || s instanceof zd) {
    const l = Sh(s);
    n = new st(s.uuid, l, a, void 0, void 0, s);
  } else {
    const l = Sh(s);
    n = new st(s.uuid, l, a, void 0, void 0, void 0, void 0, s.animations);
  }
  if (n) {
    if (n.displayName = s.userData?.name || s.name, n.visibility = s.visible ? void 0 : "invisible", e && e.add(n), e = n, t.extensions)
      for (const l of t.extensions)
        l.onExportObject && l.onExportObject.call(l, s, n, t);
  } else {
    const l = Sh(s), c = new st(s.uuid, l, { position: s.position, quaternion: s.quaternion, scale: s.scale });
    e && e.add(c), e = c;
  }
  for (const l of s.children)
    Uv(l, e, t, i);
}
function U_(s, e, ...t) {
  const i = {};
  let n = 0;
  function o(r, a) {
    n++;
    let l = r.displayName || r.name;
    l += " (" + r.uuid + ")", (r.geometry || r.material || r.camera || r.skinnedMesh) && (l += " (" + (r.geometry ? "geo, " : "") + (r.material ? "mat, " : "") + (r.camera ? "cam, " : "") + (r.skinnedMesh ? "skin, " : "") + ")"), a[l] = {};
    const h = { object: r };
    r.material && (h.mat = !0), r.geometry && (h.geo = !0), r.camera && (h.cam = !0), r.skinnedMesh && (h.skin = !0), a[l]._self = h;
    for (const d of r.children)
      d && o(d, a[l]);
  }
  o(s, i), console.log(e + " (" + n + " nodes)", i, ...t);
}
function Nv(s, e) {
  let t = !0;
  const i = new Array(), n = new Array();
  if (s.children.length === 0)
    t = !0;
  else {
    const c = [...s.children];
    for (const h of c)
      if (h) {
        const d = Nv(h, e);
        e.debug && (d ? i.push(h) : n.push(h)), t = t && d;
      }
  }
  const o = e.allBehaviorTargets.has(s.uuid), r = s.geometry || s.material || s.camera && !e.quickLookCompatible || s.skinnedMesh || !1, a = e.boneReparentings.has(s.uuid), l = t && !o && !r && !a;
  return l ? (e.debug && console.log("Pruned object:", (s.displayName || s.name) + " (" + s.uuid + ")", {
    isVisible: r,
    isBehaviorSourceOrTarget: o,
    allChildsWerePruned: t,
    isBoneReparenting: a,
    object: s,
    prunedChilds: i,
    keptChilds: n
  }), s.parent?.remove(s)) : e.debug && console.log("Kept object:", (s.displayName || s.name) + " (" + s.uuid + ")", {
    isVisible: r,
    isBehaviorSourceOrTarget: o,
    allChildsWerePruned: t,
    isBoneReparenting: a,
    object: s,
    prunedChilds: i,
    keptChilds: n
  }), l;
}
async function aR(s, e) {
  le.start("export-usdz-resources", "export-usdz");
  const t = [];
  for (const l of s.document.children)
    $v(l, s, t);
  const i = t.length;
  for (let l = 0; l < i; l++)
    le.report("export-usdz-resources", { totalSteps: i, currentStep: l }), await new Promise((c, h) => {
      t[l](), c();
    });
  le.end("export-usdz-resources");
  const n = new sR(), o = s.exporter.sceneAnchoringOptions.ar;
  n.beginBlock(`def Xform "${s.document.name}"`), n.beginBlock(`def Scope "Scenes" (
		kind = "sceneLibrary"
	)`), n.beginBlock('def Xform "Scene"', "(", !1), n.appendLine('apiSchemas = ["Preliminary_AnchoringAPI"]'), n.appendLine("customData = {"), n.appendLine("	bool preliminary_collidesWithEnvironment = 0"), n.appendLine('	string sceneName = "Scene"'), n.appendLine("}"), n.appendLine('sceneName = "Scene"'), n.closeBlock(")"), n.beginBlock(), n.appendLine(`token preliminary:anchoring:type = "${o.anchoring.type}"`), o.anchoring.type === "plane" && n.appendLine(`token preliminary:planeAnchoring:alignment = "${o.planeAnchoring.alignment}"`), o.anchoring.type === "image" && n.appendLine(`rel preliminary:imageAnchoring:referenceImage = </${s.document.name}/Scenes/Scene/AnchoringReferenceImage>`), n.appendLine();
  const r = (l) => {
    if (!l) return 0;
    let c = 1;
    for (const h of l.children) c += r(h);
    return c;
  }, a = r(s.document);
  le.start("export-usdz-xforms", "export-usdz"), le.report("export-usdz-xforms", { totalSteps: a, currentStep: 1 });
  for (const l of s.document.children)
    Wv(l, n, s);
  le.end("export-usdz-xforms"), le.report("export-usdz", "invoke onAfterHierarchy"), await Yh(s, "onAfterHierarchy", n), n.closeBlock(), n.closeBlock(), n.appendLine(e()), n.closeBlock(), le.report("export-usdz", "write to string"), s.output += n.toString();
}
function $v(s, e, t) {
  if (!s) return;
  const i = s.geometry, n = s.material;
  if (i)
    if (n && ("isMeshStandardMaterial" in n && n.isMeshStandardMaterial || "isMeshBasicMaterial" in n && n.isMeshBasicMaterial || n.type === "MeshLineMaterial")) {
      const o = "geometries/" + Kp(i, s.name) + ".usda";
      if (!(o in e.files)) {
        const r = () => {
          const a = pR(i, s.skinnedMesh?.skeleton?.bones, e.quickLookCompatible);
          e.files[o] = fR(a);
        };
        t.push(r);
      }
    } else
      console.warn("NeedleUSDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", n?.name);
  n && (n.uuid in e.materials || (e.materials[n.uuid] = n));
  for (const o of s.children)
    $v(o, e, t);
}
async function Yh(s, e, t = null) {
  if (s.extensions) {
    for (const i of s.extensions)
      if (i && typeof i[e] == "function") {
        const o = i[e].call(i, s, t);
        o instanceof Promise && await o;
      }
  }
}
let wh = null, zt = null, Nf, Fr, xh;
async function lR(s, e = 1 / 0, t = null, i = void 0) {
  Nf || (Nf = new Nn(2, 2, 1, 1)), Fr || (Fr = new Ln({
    uniforms: {
      blitTexture: new $i(s),
      flipY: new $i(!1),
      scale: new $i(new fe(1, 1, 1, 1))
    },
    vertexShader: `
            varying vec2 vUv;
			uniform bool flipY;
            void main(){
                vUv = uv;
				if (flipY)
					vUv.y = 1. - vUv.y;
                gl_Position = vec4(position.xy * 1.0,0.,.999999);
            }`,
    fragmentShader: `
            uniform sampler2D blitTexture;
			uniform vec4 scale; 
            varying vec2 vUv;

            void main(){ 
                gl_FragColor = vec4(vUv.xy, 0, 1);
                
                #ifdef IS_SRGB
                gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );
                #else
                gl_FragColor = texture2D( blitTexture, vUv);
                #endif
				
				gl_FragColor.rgba *= scale.rgba;
            }`
  }));
  const n = Fr.uniforms;
  n.blitTexture.value = s, n.flipY.value = !1, n.scale.value = new fe(1, 1, 1, 1), i !== void 0 && n.scale.value.copy(i), Fr.defines.IS_SRGB = s.colorSpace == Cs, Fr.needsUpdate = !0, xh || (xh = new G(Nf, Fr), xh.frustumCulled = !1);
  const o = new de(), r = new wi();
  r.add(xh), t || (t = wh = new mr({ antialias: !1, alpha: !0, premultipliedAlpha: !1, preserveDrawingBuffer: !0 }));
  const a = Math.min(s.image.width, e), l = Math.min(s.image.height, e);
  zt && (zt.width !== a || zt.height !== l) && (zt.dispose(), zt = null), zt || (zt = new Dn(a, l, { format: Wd, type: iS, minFilter: sd, magFilter: sd })), t.setRenderTarget(zt), t.setSize(a, l), t.clear(), t.render(r, o), wh && (wh.dispose(), wh = null);
  const c = new Uint8ClampedArray(zt.width * zt.height * 4);
  t.readRenderTargetPixels(zt, 0, 0, zt.width, zt.height, c);
  const h = new ImageData(c, zt.width, zt.height, void 0), d = await createImageBitmap(h, { premultiplyAlpha: "none" });
  return {
    imageData: h,
    imageBitmap: d
  };
}
function cR(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas || typeof ImageBitmap < "u" && s instanceof ImageBitmap;
}
async function hR(s, e = 4096) {
  const t = e / Math.max(s.width, s.height), i = s.width * Math.min(1, t), n = s.height * Math.min(1, t), o = new OffscreenCanvas(i, n), r = { premultiplyAlpha: "none" };
  s.width !== i && (r.resizeWidth = i), s.height !== n && (r.resizeHeight = n);
  const a = await createImageBitmap(s, r), l = o.getContext("bitmaprenderer");
  return l && l.transferFromImageBitmap(a), o;
}
async function dR(s, e = void 0, t = !1, i = 4096) {
  if (cR(s)) {
    const n = i / Math.max(s.width, s.height), o = new OffscreenCanvas(s.width * Math.min(1, n), s.height * Math.min(1, n)), r = o.getContext("2d", { alpha: !0, premultipliedAlpha: !1 });
    if (!r) throw new Error("Could not get canvas 2D context");
    if (t === !0 && (r.translate(0, o.height), r.scale(1, -1)), r.drawImage(s, 0, 0, o.width, o.height), e !== void 0) {
      const a = e.x, l = e.y, c = e.z, h = e.w, d = r.getImageData(0, 0, o.width, o.height), f = d.data;
      for (let p = 0; p < f.length; p += 4)
        f[p + 0] = f[p + 0] * a, f[p + 1] = f[p + 1] * l, f[p + 2] = f[p + 2] * c, f[p + 3] = f[p + 3] * h;
      r.putImageData(d, 0, 0);
    }
    return o;
  } else
    throw new Error("NeedleUSDZExporter: No valid image data found. Unable to process texture.");
}
const Oe = 7;
function uR() {
  return `#usda 1.0
(
    customLayerData = {
        string creator = "Needle Engine USDZExporter"
    }
    metersPerUnit = 1
    upAxis = "Y"
)
`;
}
function fR(s, e) {
  let t = uR();
  return t += s, zb(t);
}
function Sh(s) {
  return s.name.replace(/[-<>\(\)\[\]§$%&\/\\\=\?\,\;]/g, "") + "_" + s.id;
}
function N_(s) {
  return dn(s.name || "bone_" + s.uuid);
}
function Kp(s, e) {
  return dn(s.name || "Geometry") + "_" + s.id;
}
function _u(s) {
  return dn(s.name || "Material") + "_" + s.id;
}
function fa(s, e) {
  let t = N_(s), i = s.parent;
  for (; i && i !== e; )
    t = N_(i) + "/" + t, i = i.parent;
  return t;
}
function Wv(s, e, t) {
  if (s == null)
    return;
  le.report("export-usdz-xforms", { message: "buildXform " + s.displayName || s.name, autoStep: !0 });
  const i = s.transform, n = s.geometry, o = s.material, r = s.camera, a = s.name;
  if (s.animations)
    for (const p of s.animations)
      t.animations.push(p);
  const l = n && n.isBufferGeometry && n.attributes.skinIndex !== void 0 && n.attributes.skinIndex.count > 0, c = l ? "SkelRoot" : "Xform", h = new Array(), d = o && o instanceof we && o.color && o.color.r === 1 && o.color.g === 1 && o.color.b === 1 && !o.map && o.opacity === 1 && n?.attributes.color;
  if (n?.attributes.color && !d && console.warn("NeedleUSDZExporter: Geometry has vertex colors. Vertex colors will only be shown in QuickLook for unlit materials with white color and no texture. Otherwise, they will be ignored.", s.displayName), e.appendLine(), n ? (e.beginBlock(`def ${c} "${a}"`, "(", !1), t.quickLookCompatible && o && o.side === xi && !l ? e.appendLine(`prepend references = @./geometries/${Kp(n)}.usda@</Geometry_doubleSided>`) : e.appendLine(`prepend references = @./geometries/${Kp(n)}.usda@</Geometry>`), d || h.push("MaterialBindingAPI"), l && h.push("SkelBindingAPI")) : r && !t.quickLookCompatible ? e.beginBlock(`def Camera "${a}"`, "(", !1) : s.type !== void 0 ? e.beginBlock(`def ${s.type} "${a}"`) : e.beginBlock(`def Xform "${a}"`, "(", !1), s.type === void 0 && (s.extraSchemas?.length && h.push(...s.extraSchemas), h.length && e.appendLine(`prepend apiSchemas = [${h.map((p) => `"${p}"`).join(", ")}]`)), s.displayName && e.appendLine(`displayName = "${jv(s.displayName)}"`), (r || s.type === void 0) && (e.closeBlock(")"), e.beginBlock()), n && o) {
    if (!d) {
      const p = _u(o);
      e.appendLine(`rel material:binding = </StageRoot/Materials/${p}>`);
    }
    !t.quickLookCompatible && o.side === xi && (e.beginBlock('over "Geometry" '), e.appendLine("uniform bool doubleSided = 1"), e.closeBlock());
  }
  let f = !1;
  if (l ? (e.appendLine("rel skel:skeleton = <Rig>"), e.appendLine("rel skel:animationSource = <Rig/_anim>"), f = !1) : s.type === void 0 && i && (f = f || i.position !== null || i.quaternion !== null || i.scale !== null, i.position && (s.needsTranslate = !0, e.appendLine(`double3 xformOp:translate = (${ae(i.position.x)}, ${ae(i.position.y)}, ${ae(i.position.z)})`)), i.quaternion && (s.needsOrient = !0, e.appendLine(`quatf xformOp:orient = (${ae(i.quaternion.w)}, ${ae(i.quaternion.x)}, ${ae(i.quaternion.y)}, ${ae(i.quaternion.z)})`)), i.scale && (s.needsScale = !0, e.appendLine(`double3 xformOp:scale = (${ae(i.scale.x)}, ${ae(i.scale.y)}, ${ae(i.scale.z)})`))), s.visibility !== void 0 && e.appendLine(`token visibility = "${s.visibility}"`), r && !t.quickLookCompatible && ("isOrthographicCamera" in r && r.isOrthographicCamera ? (e.appendLine(`float2 clippingRange = (${r.near}, ${r.far})`), e.appendLine(`float horizontalAperture = ${((Math.abs(r.left) + Math.abs(r.right)) * 10).toPrecision(Oe)}`), e.appendLine(`float verticalAperture = ${((Math.abs(r.top) + Math.abs(r.bottom)) * 10).toPrecision(Oe)}`), e.appendLine('token projection = "orthographic"')) : "isPerspectiveCamera" in r && r.isPerspectiveCamera && (e.appendLine(`float2 clippingRange = (${r.near.toPrecision(Oe)}, ${r.far.toPrecision(Oe)})`), e.appendLine(`float focalLength = ${r.getFocalLength().toPrecision(Oe)}`), e.appendLine(`float focusDistance = ${r.focus.toPrecision(Oe)}`), e.appendLine(`float horizontalAperture = ${r.getFilmWidth().toPrecision(Oe)}`), e.appendLine('token projection = "perspective"'), e.appendLine(`float verticalAperture = ${r.getFilmHeight().toPrecision(Oe)}`))), s.onSerialize && s.onSerialize(e, t), s.type === void 0) {
    const p = new Array();
    s.needsTranslate && p.push('"xformOp:translate"'), s.needsOrient && p.push('"xformOp:orient"'), s.needsScale && p.push('"xformOp:scale"'), p.length && e.appendLine(`uniform token[] xformOpOrder = [${p.join(", ")}]`);
  }
  if (s.children) {
    e.appendLine();
    for (const p of s.children)
      Wv(p, e, t);
  }
  e.closeBlock();
}
function ae(s) {
  return Number.isInteger(s) ? s.toString() : s.toFixed(10);
}
function $_(s) {
  const e = s.elements;
  return `( ${Ch(e, 0)}, ${Ch(e, 4)}, ${Ch(e, 8)}, ${Ch(e, 12)} )`;
}
function Ch(s, e) {
  return `(${ae(s[e + 0])}, ${ae(s[e + 1])}, ${ae(s[e + 2])}, ${ae(s[e + 3])})`;
}
function pR(s, e = [], t = !0) {
  return `
def "Geometry"
${mR(s, e, t)}
`;
}
function mR(s, e = [], t = !0) {
  const i = "Geometry", n = s.attributes, o = n.position.count, r = e && e.length > 0, a = [], l = [];
  let c = new Array(), h = n.skinIndex;
  if (r) {
    const f = [];
    for (const m of e)
      a.push({ bone: m, index: e.indexOf(m) }), f.push(m.uuid);
    let p = 1e4;
    for (; f.length < e.length && p-- > 0; )
      for (const m of a) {
        const v = m.bone.children;
        for (const _ of v)
          f.indexOf(_.uuid) === -1 && e.indexOf(_) !== -1 && (a.push({ bone: _, index: e.indexOf(_) }), f.push(_.uuid));
      }
    p <= 0 && console.error("Failed to sort bones in skinned mesh", a, e, f);
    for (const m of Fv(e))
      a.push({ bone: m, index: a.length });
    const g = a[0].bone.parent;
    a.sort((m, v) => fa(m.bone, g) > fa(v.bone, g) ? 1 : -1), a.map((m) => '"' + fa(m.bone, g) + '"').join(", ");
    for (const m in a)
      l[a[m].index] = parseInt(m);
    const b = n.skinIndex;
    c = new Array();
    for (let m = 0; m < b.count; m++) {
      const v = b.getX(m), _ = b.getY(m), x = b.getZ(m), I = b.getW(m);
      c.push(l[v], l[_], l[x], l[I]);
    }
    h = new ft(new Uint16Array(c), 4);
  }
  const d = n.skinWeight && n.skinIndex;
  return `
{	
    def Mesh "${i}" ${d ? `(
        prepend apiSchemas = ["SkelBindingAPI"]
    )` : ""}
    {
        int[] faceVertexCounts = [${$f(s)}]
        int[] faceVertexIndices = [${Wf(s)}]
		${n.normal || t ? (
    // in QuickLook, normals are required, otherwise double-sided rendering doesn't work.
    `normal3f[] normals = [${Kh(n.normal, o)}] (
            interpolation = "vertex"
        )`
  ) : ""}
        point3f[] points = [${Kh(n.position, o)}]
        ${n.uv ? `texCoord2f[] primvars:st = [${Vv(n.uv, o, !0)}] (
            interpolation = "vertex"
        )` : ""}
		${n.uv1 ? Vf("st1", n.uv1) : ""}
		${n.uv2 ? Vf("st2", n.uv2) : ""}
		${n.uv3 ? Vf("st3", n.uv3) : ""}
		${d ? `matrix4d primvars:skel:geomBindTransform = ( (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1) ) (
				elementSize = 1
				interpolation = "constant"
			)` : ""}
		${n.skinIndex ? `int[] primvars:skel:jointIndices = [${W_(h, !0)}] (
			elementSize = 4
			interpolation = "vertex"
		)` : ""}
		${n.skinWeight ? `float[] primvars:skel:jointWeights = [${W_(n.skinWeight)}] (
			elementSize = 4
			interpolation = "vertex"
		)` : ""}
		${n.color ? `color3f[] primvars:displayColor = [${Kh(n.color, o)}] (
			interpolation = "vertex"
		)` : ""}
        uniform token subdivisionScheme = "none"
    }
}
${t ? `
# This is a workaround for QuickLook/RealityKit not supporting the doubleSided attribute. We're adding a second
# geometry definition here, that uses the same mesh data but appends extra faces with reversed winding order.
def "${i}_doubleSided" (
	prepend references = </Geometry>
)
{
	over "Geometry"
	{
		int[] faceVertexCounts = [${$f(s) + ", " + $f(s)}]
		int[] faceVertexIndices = [${Wf(s) + ", " + Wf(s, !0)}]
	}
}
` : ""}
`;
}
function $f(s) {
  const e = s.index !== null ? s.index.count : s.attributes.position.count;
  return Array(Math.floor(e / 3)).fill(3).join(", ");
}
function Wf(s, e = !1) {
  const t = s.index, i = [];
  if (t !== null)
    for (let n = 0; n < t.count; n++) {
      let o = n;
      e && (o = n % 3 === 0 ? n + 2 : n % 3 === 2 ? n - 2 : n), i.push(t.getX(o));
    }
  else {
    const n = s.attributes.position.count;
    for (let o = 0; o < n; o++) {
      let r = o;
      e && (r = o % 3 === 0 ? o + 2 : o % 3 === 2 ? o - 2 : o), i.push(r);
    }
  }
  return i.join(", ");
}
function Vf(s, e) {
  const t = e.itemSize;
  switch (t) {
    case 2:
      return `texCoord2f[] primvars:${s} = [${Vv(e, t, !0)}] (
				interpolation = "vertex"
			)`;
    case 3:
      return `texCoord3f[] primvars:${s} = [${Kh(e, t)}] (
				interpolation = "vertex"
			)`;
    case 4:
      return `double4[] primvars:${s} = [${gR(e, t)}] (
				interpolation = "vertex"
			)`;
    default:
      return console.warn("USDZExporter: Attribute with " + t + " components are currently not supported. Results may be undefined for " + s + "."), "";
  }
}
function Kh(s, e) {
  if (s === void 0)
    return console.warn("USDZExporter: A mesh attribute is missing and will be set with placeholder data. The result may look incorrect."), Array(e).fill("(0, 0, 1)").join(", ");
  const t = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), r = s.getZ(i);
    t.push(`(${n.toPrecision(Oe)}, ${o.toPrecision(Oe)}, ${r.toPrecision(Oe)})`);
  }
  return t.join(", ");
}
function gR(s, e) {
  if (s === void 0)
    return console.warn("USDZExporter: Attribute is missing. Results may be undefined."), Array(e).fill("(0, 0, 0, 0)").join(", ");
  const t = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), r = s.getZ(i) || 0, a = s.getW(i) || 0;
    t.push(`(${n.toPrecision(Oe)}, ${o.toPrecision(Oe)}, ${r.toPrecision(Oe)}, ${a.toPrecision(Oe)})`);
  }
  return t.join(", ");
}
function W_(s, e = !1) {
  const t = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), r = s.getZ(i), a = s.getW(i);
    t.push(`${e ? n : n.toPrecision(Oe)}`), t.push(`${e ? o : o.toPrecision(Oe)}`), t.push(`${e ? r : r.toPrecision(Oe)}`), t.push(`${e ? a : a.toPrecision(Oe)}`);
  }
  return t.join(", ");
}
function Vv(s, e, t = !1) {
  if (s === void 0)
    return console.warn("USDZExporter: UVs missing."), Array(e).fill("(0, 0)").join(", ");
  const i = [];
  for (let n = 0; n < s.count; n++) {
    const o = s.getX(n);
    let r = s.getY(n);
    t && (r = 1 - r), i.push(`(${o.toPrecision(Oe)}, ${r.toPrecision(Oe)})`);
  }
  return i.join(", ");
}
function yR(s, e, t = !1) {
  const i = [];
  for (const n in s) {
    const o = s[n];
    i.push(_R(o, e, t));
  }
  return `
	def "Materials"
    {
${i.join("")}
    }`;
}
function Bi(s) {
  return dn(s.name) + "_" + (s.source?.id ?? s.id);
}
function zs(s, e, t, i, n, o, r = void 0, a = void 0) {
  const l = Bi(s), c = l + (a !== void 0 && a !== 1 ? "_" + a : ""), h = t && a !== void 0 && a !== 1, d = h ? new fe(1, 1, 1, a) : void 0;
  a === void 0 && (a = 1), h && (a = 1), d && d.w <= 0.05 && (d.w = 0.05), i[c] = { texture: s, scale: d };
  const f = s.channel > 0 ? "st" + s.channel : "st";
  o.add(s.channel);
  const p = wg.includes(s.format), g = {
    1e3: "repeat",
    // RepeatWrapping
    1001: "clamp",
    // ClampToEdgeWrapping
    1002: "mirror"
    // MirroredRepeatWrapping
  }, b = s.repeat.clone(), m = s.offset.clone(), v = s.rotation, _ = Math.sin(v), x = Math.cos(v);
  m.y = 1 - m.y - b.y, t ? (b.x === 0 && (b.x = 1e-4), b.y === 0 && (b.y = 1e-4), m.x = m.x / b.x, m.y = m.y / b.y, m.x += _ / b.x, m.y += x - 1) : (m.x += _ * b.x, m.y += (1 - x) * b.y);
  const I = _u(n), O = b.x != 1 || b.y != 1 || m.x != 0 || m.y != 0 || v != 0, k = `${$t}/${I}/${"uvReader_" + f}.outputs:result>`, E = `${$t}/${I}/Transform2d_${e}.outputs:result>`, B = e !== "normal" && r && (r.r !== 1 || r.g !== 1 || r.b !== 1 || a !== 1) || !1, D = e === "normal", W = n instanceof ut && n.normalScale ? n.normalScale.x * 2 : 2, X = W.toFixed(Oe), A = (-1 * (W / 2)).toFixed(Oe), $ = (1 - W).toFixed(Oe);
  return `
		${O ? `def Shader "Transform2d_${e}" (
			sdrMetadata = {
				string role = "math"
			}
		)
		{
			uniform token info:id = "UsdTransform2d"
			float2 inputs:in.connect = ${k}
			float2 inputs:scale = ${H_(b)}
			float2 inputs:translation = ${H_(m)}
			float inputs:rotation = ${(v / Math.PI * 180).toFixed(Oe)}
			float2 outputs:result
		}
		` : ""}
		def Shader "${l}_${e}"
		{
			uniform token info:id = "UsdUVTexture"
			asset inputs:file = @textures/${c}.${p ? "png" : "jpg"}@
			token inputs:sourceColorSpace = "${s.colorSpace === "srgb" ? "sRGB" : "raw"}"
			float2 inputs:st.connect = ${O ? E : k}
			${B ? `
			float4 inputs:scale = (${r ? r.r + ", " + r.g + ", " + r.b : "1, 1, 1"}, ${a})
			` : ""}
			${D ? `
			float4 inputs:scale = (${X}, ${X}, ${X}, 1)
			float4 inputs:bias = (${A}, ${A}, ${$}, 0)
			` : ""}
			token inputs:wrapS = "${g[s.wrapS]}"
			token inputs:wrapT = "${g[s.wrapT]}"
			float outputs:r
			float outputs:g
			float outputs:b
			float3 outputs:rgb
			${n.transparent || n.alphaTest > 0 ? "float outputs:a" : ""}
		}`;
}
function _R(s, e, t = !1) {
  const i = _u(s);
  if (s.colorWrite === !1 || s.userData?.isShadowCatcherMaterial || s.userData?.isLightBlendMaterial) {
    const f = s.userData.isLightBlendMaterial || s.userData.isShadowCatcherMaterial ? "ND_realitykit_shadowreceiver_surfaceshader" : "ND_realitykit_occlusion_surfaceshader";
    return `

		def Material "${i}" ${s.name ? `(
			displayName = "${s.name}"
		)` : ""}
		{
			token outputs:mtlx:surface.connect = ${$t}/${i}/Occlusion.outputs:out>

			def Shader "Occlusion"
			{
				uniform token info:id = "${f}"
				token outputs:out
			}
		}`;
  }
  const o = "                ", r = [], a = [], l = /* @__PURE__ */ new Set();
  if (s.isMeshPhysicalNodeMaterial === !0)
    return YM(s, i, e);
  let c = s.transparent || s.alphaTest ? s.opacity : 1, h = !1, d = !1;
  if (s instanceof gp && s.transmission !== void 0 && (c *= 1 - s.transmission * (1 - s.roughness * 0.5)), s.map ? (r.push(`${o}color3f inputs:diffuseColor.connect = ${$t}/${i}/${Bi(s.map)}_diffuse.outputs:rgb>`), s instanceof we && s.transparent && s.alphaTest == 0 && t ? (r.push(`${o}float inputs:opacity.connect = ${$t}/${i}/${Bi(s.map)}_diffuse.outputs:a>`), h = !0, r.push(`${o}float inputs:opacityThreshold = ${1e-10}`), d = !0) : s.transparent ? (r.push(`${o}float inputs:opacity.connect = ${$t}/${i}/${Bi(s.map)}_diffuse.outputs:a>`), h = !0) : s.alphaTest > 0 && (r.push(`${o}float inputs:opacity.connect = ${$t}/${i}/${Bi(s.map)}_diffuse.outputs:a>`), h = !0, r.push(`${o}float inputs:opacityThreshold = ${s.alphaTest}`), d = !0), a.push(zs(s.map, "diffuse", t, e, s, l, s.color, c))) : r.push(`${o}color3f inputs:diffuseColor = ${V_(s.color)}`), s.alphaHash && t && (d ? console.warn("Opacity threshold for " + s.name + " was already connected. Skipping alphaHash opacity threshold.") : (r.push(`${o}float inputs:opacityThreshold = 0.0000000001`), d = !0)), s.aoMap && (r.push(`${o}float inputs:occlusion.connect = ${$t}/${i}/${Bi(s.aoMap)}_occlusion.outputs:r>`), a.push(zs(s.aoMap, "occlusion", t, e, s, l))), s.alphaMap ? (r.push(`${o}float inputs:opacity.connect = ${$t}/${i}/${Bi(s.alphaMap)}_opacity.outputs:r>`), r.push(`${o}float inputs:opacityThreshold = 0.0000000001`), h = !0, d = !0, a.push(zs(s.alphaMap, "opacity", t, e, s, l, new se(1, 1, 1), c))) : (h ? console.warn("Opacity for " + s.name + " was already connected. Skipping default opacity.") : (r.push(`${o}float inputs:opacity = ${c}`), h = !0), s.alphaTest > 0 && (d ? console.warn("Opacity threshold for " + s.name + " was already connected. Skipping default opacity threshold.") : (r.push(`${o}float inputs:opacityThreshold = ${s.alphaTest}`), d = !0))), s instanceof ut) {
    if (s.emissiveMap) {
      r.push(`${o}color3f inputs:emissiveColor.connect = ${$t}/${i}/${Bi(s.emissiveMap)}_emissive.outputs:rgb>`);
      const f = s.emissive.clone();
      f.multiplyScalar(s.emissiveIntensity), a.push(zs(s.emissiveMap, "emissive", t, e, s, l, f));
    } else if (s.emissive?.getHex() > 0) {
      const f = s.emissive.clone();
      f.multiplyScalar(s.emissiveIntensity), r.push(`${o}color3f inputs:emissiveColor = ${V_(f)}`);
    }
    s.normalMap && (r.push(`${o}normal3f inputs:normal.connect = ${$t}/${i}/${Bi(s.normalMap)}_normal.outputs:rgb>`), a.push(zs(s.normalMap, "normal", t, e, s, l))), s.roughnessMap && s.roughness === 1 ? (r.push(`${o}float inputs:roughness.connect = ${$t}/${i}/${Bi(s.roughnessMap)}_roughness.outputs:g>`), a.push(zs(s.roughnessMap, "roughness", t, e, s, l))) : r.push(`${o}float inputs:roughness = ${s.roughness !== void 0 ? s.roughness : 1}`), s.metalnessMap && s.metalness === 1 ? (r.push(`${o}float inputs:metallic.connect = ${$t}/${i}/${Bi(s.metalnessMap)}_metallic.outputs:b>`), a.push(zs(s.metalnessMap, "metallic", t, e, s, l))) : r.push(`${o}float inputs:metallic = ${s.metalness !== void 0 ? s.metalness : 0}`);
  }
  return s instanceof gp && (r.push(`${o}float inputs:clearcoat = ${s.clearcoat}`), r.push(`${o}float inputs:clearcoatRoughness = ${s.clearcoatRoughness}`), r.push(`${o}float inputs:ior = ${s.ior}`), !s.transparent && !(s.alphaTest > 0) && s.transmissionMap && (r.push(`${o}float inputs:opacity.connect = ${$t}/${i}/${Bi(s.transmissionMap)}_transmission.outputs:r>`), a.push(zs(s.transmissionMap, "transmission", t, e, s, l)))), l.size > 2 ? console.warn("USDZExporter: Material " + s.name + " uses more than 2 UV channels. Currently, only UV0 and UV1 are supported.") : l.size === 2 && (!l.has(0) || !l.has(1)) && console.warn("USDZExporter: Material " + s.name + " uses UV channels other than 0 and 1. Currently, only UV0 and UV1 are supported."), `

		def Material "${i}" ${s.name ? `(
			displayName = "${jv(s.name)}"
		)` : ""}
		{
			token outputs:surface.connect = ${$t}/${i}/PreviewSurface.outputs:surface>

			def Shader "PreviewSurface"
			{
				uniform token info:id = "UsdPreviewSurface"
${r.join(`
`)}
				int inputs:useSpecularWorkflow = ${s instanceof we ? "1" : "0"}
				token outputs:surface
			}
${a.length > 0 ? `
${l.has(0) ? `
			def Shader "uvReader_st"
			{
				uniform token info:id = "UsdPrimvarReader_float2"
				token inputs:varname = "st"
				float2 inputs:fallback = (0.0, 0.0)
				float2 outputs:result
			}
` : ""}
${l.has(1) ? `
			def Shader "uvReader_st1"
			{
				uniform token info:id = "UsdPrimvarReader_float2"
				token inputs:varname = "st1"
				float2 inputs:fallback = (0.0, 0.0)
				float2 outputs:result
			}
` : ""}
${a.join(`
`)}` : ""}
		}`;
}
function V_(s) {
  return `(${s.r}, ${s.g}, ${s.b})`;
}
function H_(s) {
  return `(${s.x}, ${s.y})`;
}
const wg = [
  // uncompressed formats with alpha channel
  1023,
  // RGBAFormat
  // compressed formats with alpha channel
  33777,
  // RGBA_S3TC_DXT1_Format
  33778,
  // RGBA_S3TC_DXT3_Format
  33779,
  // RGBA_S3TC_DXT5_Format
  35842,
  // RGBA_PVRTC_4BPPV1_Format
  35843,
  // RGBA_PVRTC_2BPPV1_Format
  37496,
  // RGBA_ETC2_EAC_Format
  37808,
  // RGBA_ASTC_4x4_Format
  37809,
  // RGBA_ASTC_5x4_Format
  37810,
  // RGBA_ASTC_5x5_Format
  37811,
  // RGBA_ASTC_6x5_Format
  37812,
  // RGBA_ASTC_6x6_Format
  37813,
  // RGBA_ASTC_8x5_Format
  37814,
  // RGBA_ASTC_8x6_Format
  37815,
  // RGBA_ASTC_8x8_Format
  37816,
  // RGBA_ASTC_10x5_Format
  37817,
  // RGBA_ASTC_10x6_Format
  37818,
  // RGBA_ASTC_10x8_Format
  37819,
  // RGBA_ASTC_10x10_Format
  37820,
  // RGBA_ASTC_12x10_Format
  37821,
  // RGBA_ASTC_12x12_Format
  36492
  // RGBA_BPTC_Format
];
w("debugusdz");
class It {
  static global_id = 0;
  id;
  trigger;
  action;
  exclusive = !1;
  makeExclusive(e) {
    return this.exclusive = e, this;
  }
  constructor(e, t, i) {
    this.id = "Behavior_" + dn(e) + "_" + It.global_id++, this.trigger = t, this.action = i;
  }
  writeTo(e, t, i) {
    if (!this.trigger || !this.action) return;
    i.beginBlock(`def Preliminary_Behavior "${this.id}"`);
    let n = "";
    if (Array.isArray(this.trigger)) {
      n = "[";
      for (let o = 0; o < this.trigger.length; o++) {
        const r = this.trigger[o];
        n += "<" + r.id + ">", o + 1 < this.trigger.length && (n += ", ");
      }
      n += "]";
    } else
      n = `<${this.trigger.id}>`;
    if (i.appendLine(`rel triggers = ${n}`), i.appendLine(`rel actions = <${this.action.id}>`), i.appendLine(`uniform bool exclusive = ${this.exclusive ? 1 : 0}`), i.appendLine(), Array.isArray(this.trigger))
      for (const o of this.trigger)
        o.writeTo(t, i), i.appendLine();
    else
      this.trigger.writeTo(t, i);
    i.appendLine(), this.action.writeTo(t, i), i.closeBlock();
  }
}
const zr = /* @__PURE__ */ new Set();
function Zp(s, e) {
  let t = "";
  if (Array.isArray(s)) {
    zr.clear();
    let i = "[ ";
    for (let n = 0; n < s.length; n++) {
      let o = s[n];
      if (!o) {
        console.warn("Invalid target object in behavior", s + ". Is the object exported?");
        continue;
      }
      if (typeof o == "string") {
        if (zr.has(o)) continue;
        i += o, zr.add(o);
      } else if (typeof o == "object") {
        if (o.isObject3D && (o = e.findById(o.uuid), !o)) {
          console.warn("Invalid target object in behavior", s + ". Is the object exported?");
          continue;
        }
        const r = o.getPath?.call(o);
        if (zr.has(r)) continue;
        i += r, zr.add(r);
      }
      n + 1 < s.length && (i += ", ");
    }
    i += " ]", t = i, zr.clear();
  } else if (typeof s == "object") {
    const i = s;
    if (i.isObject3D && (s = e.findById(i.uuid)), !s)
      throw console.error("Invalid target object in behavior, the target object is likely missing from USDZ export. Is the object exported?", i), new Error(`Invalid target object in behavior, the target object is likely missing from USDZ export. Please report a bug. uuid: ${i.uuid}.`);
    t = s.getPath?.call(s);
  }
  return t;
}
class sr {
  static global_id = 0;
  id;
  targetId;
  tokenId;
  type;
  distance;
  constructor(e, t) {
    e && (this.targetId = e), t ? this.id = t : this.id = "Trigger_" + sr.global_id++;
  }
  writeTo(e, t) {
    t.beginBlock(`def Preliminary_Trigger "${this.id}"`), this.targetId && (typeof this.targetId != "string" && (this.targetId = Zp(this.targetId, e)), t.appendLine("rel affectedObjects = " + this.targetId)), this.tokenId && t.appendLine(`token info:id = "${this.tokenId}"`), this.type && t.appendLine(`token type = "${this.type}"`), typeof this.distance == "number" && t.appendLine(`double distance = ${this.distance}`), t.closeBlock();
  }
}
function G_(s, e = { direct: !0, indirect: !0 }) {
  const t = st.createEmpty();
  t.name = "InputTarget_" + t.name, t.displayName = void 0, t.type = "RealityKitComponent", t.onSerialize = (i) => {
    i.appendLine("bool allowsDirectInput = " + (e.direct ? 1 : 0)), i.appendLine("bool allowsIndirectInput = " + (e.indirect ? 1 : 0)), i.appendLine('uniform token info:id = "RealityKit.InputTarget"');
  }, s.add(t);
}
class Gt {
  static __sceneStartTrigger;
  static sceneStartTrigger() {
    if (this.__sceneStartTrigger !== void 0) return this.__sceneStartTrigger;
    const e = new sr(void 0, "SceneStart");
    return e.tokenId = "SceneTransition", e.type = "enter", this.__sceneStartTrigger = e, e;
  }
  /** Trigger that fires when an object has been tapped/clicked.
   * @param targetObject The object or list of objects that can be interacted with.
   * @param inputMode Input Mode (direct and/or indirect). Only available for USDObject targets. Only supported on Vision OS at the moment. */
  static tapTrigger(e, t = { direct: !0, indirect: !0 }) {
    const i = new sr(e);
    if (Array.isArray(e) && e.length > 1)
      for (const n of e)
        n instanceof st && G_(n, t);
    else
      e instanceof st && G_(e, t);
    return i.tokenId = "TapGesture", i;
  }
  static isTapTrigger(e) {
    return e?.tokenId === "TapGesture";
  }
  static proximityToCameraTrigger(e, t) {
    const i = new sr(e);
    return i.tokenId = "ProximityToCamera", i.distance = t, i;
  }
}
class ea {
  static global_id = 0;
  static getId() {
    return this.global_id++;
  }
  id;
  actions;
  loops = 0;
  performCount = 1;
  type = "serial";
  multiplePerformOperation = void 0;
  constructor(e, t) {
    this.id = e, this.actions = t;
  }
  addAction(e) {
    return this.actions.push(e), this;
  }
  makeParallel() {
    return this.type = "parallel", this;
  }
  makeSequence() {
    return this.type = "serial", this;
  }
  makeLooping() {
    return this.loops = 1, this.performCount = 0, this;
  }
  makeRepeat(e) {
    return this.performCount = e, this;
  }
  writeTo(e, t) {
    t.beginBlock(`def Preliminary_Action "${this.id}"`), t.beginArray("rel actions");
    for (const i of this.actions) {
      if (!i) continue;
      const n = i === this.actions[this.actions.length - 1];
      t.appendLine("<" + i.id + ">" + (n ? "" : ", "));
    }
    t.closeArray(), t.appendLine(), t.appendLine('token info:id = "Group"'), t.appendLine(`bool loops = ${this.loops}`), t.appendLine(`int performCount = ${this.loops > 0 ? 0 : Math.max(0, this.performCount)}`), t.appendLine(`token type = "${this.type}"`), typeof this.multiplePerformOperation == "string" && t.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`), t.appendLine();
    for (const i of this.actions)
      i && (i.writeTo(e, t), t.appendLine());
    t.closeBlock();
  }
}
class di {
  static global_id = 0;
  id;
  tokenId;
  affectedObjects;
  easeType;
  motionType = void 0;
  duration;
  moveDistance;
  style;
  type;
  // combined types of different actions
  front;
  up;
  start;
  animationSpeed;
  reversed;
  pingPong;
  xFormTarget;
  audio;
  gain;
  auralMode;
  multiplePerformOperation;
  velocity;
  // extra info written as comment at the beginning of the action
  comment;
  animationName;
  clone() {
    const e = new di(), t = e.id;
    return Object.assign(e, this), e.id = t, e;
  }
  constructor(e, t) {
    e && (this.affectedObjects = e), t ? this.id = t : this.id = "Action", this.id += "_" + di.global_id++;
  }
  writeTo(e, t) {
    t.beginBlock(`def Preliminary_Action "${this.id}"`), this.comment && t.appendLine(`# ${this.comment}`), this.affectedObjects && (typeof this.affectedObjects != "string" && (this.affectedObjects = Zp(this.affectedObjects, e)), t.appendLine("rel affectedObjects = " + this.affectedObjects)), typeof this.duration == "number" && (typeof this.animationSpeed == "number" && this.animationSpeed !== 1 ? t.appendLine(`double duration = ${this.duration / this.animationSpeed} `) : t.appendLine(`double duration = ${this.duration} `)), this.easeType && t.appendLine(`token easeType = "${this.easeType}"`), this.tokenId && t.appendLine(`token info:id = "${this.tokenId}"`), this.tokenId === "ChangeScene" && t.appendLine("rel scene = </StageRoot/Scenes/Scene>"), this.motionType !== void 0 && t.appendLine(`token motionType = "${this.motionType}"`), typeof this.moveDistance == "number" && t.appendLine(`double moveDistance = ${this.moveDistance} `), this.style && t.appendLine(`token style = "${this.style}"`), this.type && t.appendLine(`token type = "${this.type}"`), this.front && t.appendLine(`vector3d front = (${this.front.x}, ${this.front.y}, ${this.front.z})`), this.up && t.appendLine(`vector3d upVector = (${this.up.x}, ${this.up.y}, ${this.up.z})`), typeof this.start == "number" && t.appendLine(`double start = ${this.start} `), typeof this.animationSpeed == "number" && t.appendLine(`double animationSpeed = ${this.animationSpeed.toFixed(2)} `), typeof this.reversed == "boolean" && t.appendLine(`bool reversed = ${this.reversed}`), typeof this.pingPong == "boolean" && t.appendLine(`bool reverses = ${this.pingPong}`), this.xFormTarget && (typeof this.xFormTarget != "string" && (this.xFormTarget = Zp(this.xFormTarget, e)), t.appendLine(`rel xformTarget = ${this.xFormTarget}`)), typeof this.audio == "string" && t.appendLine(`asset audio = @${this.audio}@`), typeof this.gain == "number" && t.appendLine(`double gain = ${this.gain}`), typeof this.auralMode == "string" && t.appendLine(`token auralMode = "${this.auralMode}"`), typeof this.multiplePerformOperation == "string" && t.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`), typeof this.velocity == "object" && t.appendLine(`vector3d velocity = (${this.velocity.x}, ${this.velocity.y}, ${this.velocity.z})`), t.closeBlock();
  }
}
class Ni {
  x = 0;
  y = 0;
  z = 0;
  constructor(e, t, i) {
    this.x = e, this.y = t, this.z = i;
  }
  static get up() {
    return new Ni(0, 1, 0);
  }
  static get right() {
    return new Ni(1, 0, 0);
  }
  static get forward() {
    return new Ni(0, 0, 1);
  }
  static get back() {
    return new Ni(0, 0, -1);
  }
  static get zero() {
    return new Ni(0, 0, 0);
  }
}
class me {
  static sequence(...e) {
    return new ea("Group_" + ea.getId(), e).makeSequence();
  }
  static parallel(...e) {
    return new ea("Group_" + ea.getId(), e).makeParallel();
  }
  static fadeAction(e, t, i) {
    const n = new di(e);
    return n.tokenId = "Visibility", n.type = i ? "show" : "hide", n.duration = t, n.style = "basic", n.motionType = "none", n.moveDistance = 0, n.easeType = "none", n;
  }
  /**
   * creates an action that plays an animation
   * @param start offset in seconds!
   * @param duration in seconds! 0 means play to end
   */
  static startAnimationAction(e, t, i = !1, n = !1) {
    const o = new di(e);
    o.tokenId = "StartAnimation";
    const r = t.start, a = t.duration, l = t.speed, c = t.clipName;
    if (o.comment = `Animation: ${c}, start=${r * 60}, length=${a * 60}, end=${(r + a) * 60}`, o.animationName = c, o.start = r, o.duration = a, o.animationSpeed = l, o.reversed = i, o.pingPong = n, o.multiplePerformOperation = "allow", i && (o.start -= a), n) {
      o.pingPong = !1;
      const h = o.clone();
      return h.reversed = !i, h.start = o.start, h.reversed && (h.start -= a), me.sequence(o, h);
    }
    return o;
  }
  static waitAction(e) {
    const t = new di();
    return t.tokenId = "Wait", t.duration = e, t.motionType = void 0, t;
  }
  static lookAtCameraAction(e, t, i, n) {
    const o = new di(e);
    return o.tokenId = "LookAtCamera", o.duration = t === void 0 ? 9999999999999 : t, o.front = i ?? Ni.forward, o.up = n ?? Ni.up, o;
  }
  static emphasize(e, t, i = "bounce", n = 1, o = "basic") {
    const r = new di(e);
    return r.tokenId = "Emphasize", r.duration = t, r.style = o ?? "basic", r.motionType = i, r.moveDistance = n, r;
  }
  static transformAction(e, t, i, n, o = "inout") {
    const r = new di(e);
    return r.tokenId = "Transform", r.duration = i, r.duration = Math.max(1e-6, i), r.type = n, r.easeType = i > 0 ? o : "none", Array.isArray(t) && console.error("Transform target must not be an array", t), r.xFormTarget = t, r;
  }
  static playAudioAction(e, t, i = "play", n = 1, o = "spatial") {
    const r = new di(e);
    return r.tokenId = "Audio", r.type = i, r.audio = t, r.gain = n, r.auralMode = o, r.multiplePerformOperation = "allow", r;
  }
  // Supported only on VisionOS, Preliminary Behaviours can affect RealityKit physics as well
  static impulseAction(e, t) {
    const i = new di(e);
    return i.tokenId = "Impulse", i.velocity = t, i;
  }
  // Currently doesn't work on VisionOS, see FB13761990
  /*
  static reloadSceneAction() {
      const act = new ActionModel();
      act.tokenId = "ChangeScene";
      // rel scene = ... is implicit since we only allow one scene right now
      return act;
  }
  */
}
class bR {
  get id() {
    return this.object.uuid;
  }
  object;
  model;
  constructor(e) {
    this.object = e;
  }
  apply(e) {
    if (!this.model && (this.model = e.findById(this.object.uuid), !this.model)) {
      console.error("could not find model with id " + this.object.uuid);
      return;
    }
    this.onApply(e);
  }
}
class Hv extends bR {
  constructor(e, t, i, n) {
    super(e), this.matrix = t, this.material = i, this.geometry = n;
  }
  matrix;
  material;
  geometry;
  onApply(e) {
    const t = this.model;
    if (!t) return;
    t.parent?.isDynamic || st.createEmptyParent(t);
    const i = t.clone();
    this.matrix && i.setMatrix(this.matrix), this.material && (i.material = this.material), this.geometry && (i.geometry = this.geometry), t.parent?.add(i);
  }
  _enableAction;
  _disableAction;
  enable() {
    return this._enableAction ? this._enableAction : (this._enableAction = me.fadeAction(this.object, 0, !0), this._enableAction);
  }
  disable() {
    return this._disableAction ? this._disableAction : (this._disableAction = me.fadeAction(this.object, 0, !1), this._disableAction);
  }
}
class vR {
  actions;
  sortedActions;
  constructor(e) {
    this.actions = [...e];
  }
  // organize is called once when getting an action for the first time
  // the sorted actions are baked then and adding new actions will not be added anymore
  organize() {
    this.sortedActions = {};
    for (const e of this.actions) {
      const t = e.id;
      this.sortedActions[t] || (this.sortedActions[t] = []), this.sortedActions[t].push(e);
    }
  }
  /** returns all document actions affecting the object passed in */
  getActions(e) {
    return this.sortedActions || this.organize(), this.sortedActions[e.uuid];
  }
}
const Cn = w("debugusdzanimation"), Jp = w("debugusdzanimationserialization");
class Yo {
  _start;
  get start() {
    return this._start === void 0 && (this._start = this.ext.getStartTimeByClip(this.clip)), this._start;
  }
  get duration() {
    return this.clip?.duration ?? Ue.restPoseClipDuration;
  }
  get nearestAnimatedRoot() {
    return this._nearestAnimatedRoot;
  }
  get clipName() {
    return this.clip?.name ?? "rest";
  }
  ext;
  root;
  _nearestAnimatedRoot = void 0;
  clip;
  // Playback speed. Does not affect how the animation is written, just how fast actions play it back.
  speed;
  constructor(e, t, i) {
    this.ext = e, this.root = t, this.clip = i, this._nearestAnimatedRoot = this.getNearestAnimatedRoot();
  }
  static isDescendantOf(e, t) {
    let i = t;
    if (!i || !e) return !1;
    for (; i; ) {
      if (!i) return !1;
      if (i === e) return !0;
      i = i.parent;
    }
    return !1;
  }
  /** Finds the nearest actually animated object under root based on the tracks in the AnimationClip. */
  getNearestAnimatedRoot() {
    let e;
    try {
      for (const t of this.clip?.tracks ?? []) {
        const i = ga.parseTrackName(t.name);
        let n = ga.findNode(this.root, i.nodeName);
        if (n)
          if (!e) e = n;
          else {
            if (n === e || Yo.isDescendantOf(e, n)) continue;
            if (!Yo.isDescendantOf(n, e)) {
              for (; !Yo.isDescendantOf(n, e) && n.parent; )
                n = n.parent;
              Yo.isDescendantOf(n, e) || console.error("USDZExporter: Animation clip targets multiple roots that are not parent/child. Please report a bug", this.root, this.clip, e, n);
            }
            e = n;
          }
      }
    } catch (t) {
      console.error("USDZExporter: Exception when trying to find nearest animated root. Please report a bug", t), e = void 0;
    }
    return e;
  }
}
class Ue {
  clip;
  pos;
  rot;
  scale;
  root;
  target;
  duration = 0;
  useRootMotion = !1;
  /** This value can theoretically be anything – a value of 1 is good to clearly see animation gaps.
   * For production, a value of 1/60 is enough, since the files can then still properly play back at 60fps.
   */
  static frameRate = 60;
  static animationDurationPadding = 6 / 60;
  static restPoseClipDuration = 6 / 60;
  constructor(e, t, i) {
    if (this.root = e, this.target = t, this.clip = i, i ? this.duration = i.duration : this.duration = Ue.restPoseClipDuration, i && i.tracks) {
      const o = Math.max(...i.tracks.map((r) => r.times[r.times.length - 1]));
      o !== this.duration && (console.warn("USDZExporter: Animation clip duration does not match the maximum time value in the tracks.", i, o, this.duration), this.duration = o);
    }
    const n = S.getComponent(e, kt);
    n && (this.useRootMotion = n.applyRootMotion);
  }
  addTrack(e) {
    if (!this.clip) {
      console.error("This is a rest clip but you're trying to add tracks to it – this is likely a bug");
      return;
    }
    e.name.endsWith("position") ? this.pos = e : e.name.endsWith("quaternion") ? this.rot = e : e.name.endsWith("scale") ? this.scale = e : (e.name.endsWith("activeSelf") ? console.warn("[USDZ] Animation of enabled/disabled state is not supported for USDZ export and will NOT be exported: " + e.name + " on " + (this.root?.name ?? this.target.name) + ". Animate scale 0/1 instead.") : console.warn("[USDZ] Animation track type not supported for USDZ export and will NOT be exported: " + e.name + " on " + (this.root?.name ?? this.target.name) + ". Only .position, .rotation, .scale are supported."), L() && ge("[USDZ] Some animations can't be exported. See console for details."));
  }
  getFrames() {
    return this.clip ? Math.max(this.pos?.times?.length ?? 0, this.rot?.times?.length ?? 0, this.scale?.times?.length ?? 0) : 2;
  }
  getDuration() {
    return this.duration;
  }
  getSortedTimesArray(e = !0, t = !0, i = !0) {
    if (!this.clip) return [0, this.duration];
    const n = this.pos?.times, o = this.rot?.times, r = this.scale?.times, a = [];
    if (e && n) for (const l of n) a.push(l);
    if (t && o) for (const l of o) a.push(l);
    if (i && r) for (const l of r) a.push(l);
    return a.includes(0) || a.push(0), a.sort((l, c) => l - c), [...new Set(a)];
  }
  /**
   * Returns an iterator that yields the values for each time sample. 
   * Values are reused objects - if you want to append them to some array 
   * instead of processing them right away, clone() them.
   * @param timesArray 
   * @param generatePos 
   * @param generateRot 
   * @param generateScale 
   */
  *getValues(e, t = !0, i = !0, n = !0) {
    const o = new y(), r = new U(), a = new y(1, 1, 1), l = this.target, c = t ? this.pos?.createInterpolant() : void 0, h = i ? this.rot?.createInterpolant() : void 0, d = n ? this.scale?.createInterpolant() : void 0;
    c || o.set(l.position.x, l.position.y, l.position.z), h || r.set(l.quaternion.x, l.quaternion.y, l.quaternion.z, l.quaternion.w), d || a.set(l.scale.x, l.scale.y, l.scale.z), c && c.valueSize !== 3 && (c.valueSize = 3), h && h.valueSize !== 4 && (h.valueSize = 4), d && d.valueSize !== 3 && (d.valueSize = 3);
    const f = 0;
    for (let p = 0 - f; p < e.length + f; p++) {
      let g = 0, b = 0;
      if (p < 0 ? (g = e[0], b = g - Ue.animationDurationPadding / 2 + 1 / 60) : p >= e.length ? (g = e[e.length - 1], b = g + Ue.animationDurationPadding / 2 - 1 / 60) : (g = e[p], b = g), c) {
        const m = c.evaluate(g);
        o.set(m[0], m[1], m[2]);
      }
      if (h) {
        const m = h.evaluate(g);
        r.set(m[0], m[1], m[2], m[3]);
      }
      if (d) {
        const m = d.evaluate(g);
        a.set(m[0], m[1], m[2]);
      }
      if (this.useRootMotion && l === this.root) {
        const m = new ee();
        m.compose(o, r, a), m.multiply(l.matrix), m.decompose(o, r, a);
      }
      yield { time: b, translation: o, rotation: r, scale: a, index: p };
    }
  }
}
class xg {
  get extensionName() {
    return "animation";
  }
  get animationData() {
    return this.dict;
  }
  get registeredClips() {
    return this.clipToStartTime.keys();
  }
  get animatedRoots() {
    return this.rootTargetMap.keys();
  }
  get holdClipMap() {
    return this.clipToHoldClip;
  }
  /** For each animated object, contains time/pos/rot/scale samples in the format that USD needs,
   *  ready to be written to the .usda file.
   */
  dict = /* @__PURE__ */ new Map();
  /** Map of all roots (Animation/Animator or scene) and all targets that they animate.
   *  We need that info so that we can ensure that each target has the same number of TransformData entries
   *  so that switching between animations doesn't result in data "leaking" to another clip.
   */
  rootTargetMap = /* @__PURE__ */ new Map();
  rootAndClipToRegisteredAnimationMap = /* @__PURE__ */ new Map();
  /** Clips registered for each root */
  rootToRegisteredClip = /* @__PURE__ */ new Map();
  lastClipEndTime = 0;
  clipToStartTime = /* @__PURE__ */ new Map();
  clipToHoldClip = /* @__PURE__ */ new Map();
  serializers = [];
  /** Determines if we inject a rest pose clip for each root - only makes sense for QuickLook */
  injectRestPoses = !1;
  /** Determines if we inject a PlayAnimationOnClick component with "scenestart" trigger - only makes sense for QuickLook */
  injectImplicitBehaviours = !1;
  constructor(e) {
    this.injectRestPoses = e, this.injectImplicitBehaviours = e;
  }
  getStartTimeCode() {
    return !this.injectRestPoses || this.rootAndClipToRegisteredAnimationMap.size === 0 ? 0 : (Ue.restPoseClipDuration + Ue.animationDurationPadding) * 60;
  }
  /** Returns the end time code, based on 60 frames per second, for all registered animations.
   * This matches the highest time value in the USDZ file. */
  getEndTimeCode() {
    let e = 0;
    for (const [t, i] of this.rootAndClipToRegisteredAnimationMap) {
      const n = i.start + i.duration;
      n > e && (e = n);
    }
    return e * 60;
  }
  getClipCount(e) {
    return this.rootToRegisteredClip.get(e)?.length ?? 0 ?? 0;
  }
  /*
      // TODO why do we have this here and on TransformData? Can RegisteredAnimationInfo not cache this value?
      // TODO we probably want to assert here that this is the same value on all nodes
      getStartTime01(root: Object3D, clip: AnimationClip | null) {
          // This is a rest pose clip, it always starts at 0
          if (!clip) return 0;
  
          const targets = this.rootTargetMap.get(root);
          if (!targets) return 0;
          const transformDatas = this.dict.get(targets[0]);
          if (!transformDatas) {
              console.error("Trying to get start time for root that has no animation data", root, clip, ...this.dict);
              return 0;
          }
  
          let currentStartTime = 0;
          for (let i = 0; i < transformDatas.length; i++) {
              if (transformDatas[i].clip === clip) break;
              currentStartTime += transformDatas[i].getDuration() + TransformData.animationDurationPadding;
          }
  
          return currentStartTime;
      }
      */
  getStartTimeByClip(e) {
    return e ? this.clipToStartTime.has(e) ? this.clipToStartTime.get(e) : (console.error("USDZExporter: Missing start time for clip – please report a bug.", e), 0) : 0;
  }
  // The same clip could be registered for different roots. All of them need written animation data then.
  // The same root could have multiple clips registered to it. If it does, the clips need to write
  // independent time data, so that playing back an animation on that root doesn't result in data "leaking"/"overlapping".
  // The structure we need is:
  // - MyRoot
  //   Animator
  //     - Clip1: CubeScale (only animates MyCube), duration: 3s
  //     - Clip2: SphereRotation (only animates MySphere), duration: 2s
  //   - MyCube
  //   - MySphere
  // Results in:
  // - MyRoot
  //   - MyCube
  //     - # rest clip (0..0.1)
  //     - # CubeScale (0.2..3.2)
  //     - # rest clip for SphereRotation (3.3..5.3)
  //   - MySphere
  //     - # rest clip (0..0.1)
  //     - # rest clip for CubeScale (0.2..3.2)
  //     - # SphereRotation (3.3..5.3)
  /** Register an AnimationClip for a specific root object.
   * @param root The root object that the animation clip is targeting.
   * @param clip The animation clip to register. If null, a rest pose is registered.
   * @returns The registered animation info, which contains the start time and duration of the clip.
   */
  registerAnimation(e, t) {
    if (!e) return null;
    this.rootTargetMap.has(e) || this.rootTargetMap.set(e, []);
    const i = e.uuid + (t?.uuid ?? "-rest");
    if (this.rootAndClipToRegisteredAnimationMap.has(i))
      return this.rootAndClipToRegisteredAnimationMap.get(i);
    Cn && console.log("registerAnimation", e, t);
    const n = this.injectRestPoses ? 1 : 0, o = (this.rootToRegisteredClip.get(e)?.length ?? 0) + n, r = this.rootTargetMap.get(e), a = new Set(r);
    if (t && t.tracks)
      for (const c of t.tracks) {
        const h = ga.parseTrackName(c.name), d = ga.findNode(e, h.nodeName);
        if (!d) {
          console.warn("no object found for track", c.name, "using " + e.name + " instead");
          continue;
        }
        this.dict.has(d) || this.dict.set(d, []);
        const f = this.dict.get(d);
        if (!f) {
          console.warn("no transform data found for target ", d, "at slot " + o + ", this is likely a bug");
          continue;
        }
        a.delete(d), this.injectRestPoses && !f[0] && (console.log("Injecting rest pose", d, t, "at slot", o), f[0] = new Ue(null, d, null));
        let p = f[o];
        p || (p = new Ue(e, d, t), f[o] = p), p.addTrack(c), r?.includes(d) || r?.push(d);
      }
    Cn && console.log("Unregistered nodes for this clip", a, "clip", t, "at slot", o, "for root", e, "targets", r);
    for (const c of a) {
      const h = this.dict.get(c);
      if (!h) continue;
      if (this.injectRestPoses && !h[0]) {
        console.warn("Adding rest pose for ", c, t, "at slot", o, "This is likely a bug, should have been added earlier.");
        const f = new Ue(null, c, null);
        h[0] = f;
      }
      let d = h[o];
      d || (Cn && console.log("Adding padding clip for ", c, t, "at slot", o), d = new Ue(e, c, t), h[o] = d);
    }
    const l = new Yo(this, e, t);
    if (this.rootAndClipToRegisteredAnimationMap.set(i, l), Cn && console.log({ root: e, clip: t, info: l }), t) {
      const c = this.rootToRegisteredClip.get(e);
      if (c ? c.push(t) : this.rootToRegisteredClip.set(e, [t]), !this.clipToStartTime.get(t)) {
        this.lastClipEndTime == null && (this.lastClipEndTime = Ue.restPoseClipDuration);
        let d = this.lastClipEndTime + Ue.animationDurationPadding, f = d + t.duration;
        const p = Math.round(d * 60) / 60, g = Math.round(f * 60) / 60;
        Math.abs(p - d) < 0.01 && (d = p), Math.abs(g - f) < 0.01 && (f = g), d = Math.ceil(d), f = d + t.duration, this.clipToStartTime.set(t, d), this.lastClipEndTime = f;
      }
    }
    return l;
  }
  onAfterHierarchy(e) {
    Cn && console.log("Animation clips per animation target node", this.dict);
  }
  onAfterBuildDocument(e) {
    Cn && console.log("Animation data", { dict: this.dict, rootTargetMap: this.rootTargetMap, rootToRegisteredClip: this.rootToRegisteredClip });
    for (const t of this.rootTargetMap.keys()) {
      const i = this.rootTargetMap.get(t);
      if (!i) continue;
      let n;
      const o = [];
      for (const r of i) {
        const a = this.dict.get(r);
        if (!a) {
          console.error("No data found for target on USDZ export – please report a bug!", r);
          continue;
        }
        n === void 0 && (n = a?.length), n !== a?.length && console.error("Different array lengths for targets – please report a bug!", a);
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (!c) {
            const d = l - (this.injectRestPoses ? 1 : 0);
            a[l] = new Ue(null, r, this.rootToRegisteredClip.get(t)[d]), c = a[l];
          }
          const h = c.getDuration();
          if (o[l] === void 0) o[l] = h;
          else if (o[l] !== h) {
            console.error("Error during UDSZ export: Encountered different animation durations for animated targets. Please report a bug!", { datas: a, target: r }), o[l] = h;
            continue;
          }
        }
      }
    }
    for (const t of this.serializers) {
      const i = t.model?.parent, n = i?.isDynamic === !0;
      Jp && console.log(n, t.model?.parent), n && t.registerCallback(i);
    }
  }
  onExportObject(e, t, i) {
    S.foreachComponent(e, (o) => {
      const r = o;
      typeof r.createAnimation == "function" && r.createAnimation(this, t, i);
    }, !1);
    const n = new wR(e, this);
    this.serializers.push(n), n.registerCallback(t);
  }
}
class wR {
  model = void 0;
  object;
  animationData;
  ext;
  callback;
  constructor(e, t) {
    this.object = e, this.animationData = t.animationData, this.ext = t;
  }
  registerCallback(e) {
    this.model && this.callback && this.model.removeEventListener("serialize", this.callback), this.callback || (this.callback = this.onSerialize.bind(this)), Jp && console.log("REPARENT", e), this.model = e, this.callback && this.model.addEventListener("serialize", this.callback);
  }
  skinnedMeshExport(e, t, i) {
    const n = this.model, o = this.animationData;
    if (n && n.skinnedMesh) {
      let r = function(A) {
        const $ = [];
        for (const [V, ne] of A) {
          let re = `${V} : [`;
          const pe = [];
          for (const Se of ne)
            pe.push(`(${ae(Se.x)}, ${ae(Se.y)}, ${ae(Se.z)})`);
          re = re.concat(pe.join(", ")), re = re.concat("],"), $.push(re);
        }
        return $;
      }, a = function(A) {
        const $ = [];
        for (const [V, ne] of A) {
          let re = `${V} : [`;
          const pe = [];
          for (const Se of ne)
            pe.push(`(${ae(Se.w)}, ${ae(Se.x)}, ${ae(Se.y)}, ${ae(Se.z)})`);
          re = re.concat(pe.join(", ")), re = re.concat("],"), $.push(re);
        }
        return $;
      }, l = function(A) {
        let $, V = !0;
        const ne = /* @__PURE__ */ new Map();
        for (const [pe, Se] of A) {
          $ === void 0 && ($ = Se.length), $ !== Se.length && (V = !1);
          let Je = 0;
          for (const Ei of Se)
            Je++, Ei || (ne.has(pe) || ne.set(pe, []), ne.get(pe).push(Je));
        }
        Cn && console.log("Bone count: ", A.size, "TransformData entries per bone: ", $, "Undefined bone entries: ", ne), console.assert(V, "All bones should have the same number of TransformData entries", A), console.assert(ne.size === 0, "All TransformData entries should be set", ne);
        const re = [];
        for (const [pe, Se] of A)
          for (let Je = 0; Je < Se.length; Je++) {
            const Ei = Se[Je], Jc = i.getStartTimeByClip(Ei.clip);
            re.length <= Je && re.push({ pos: [], rot: [], scale: [], timeOffset: Jc });
            const js = re[Je];
            js.pos.push(...Ei.getSortedTimesArray(!0, !1, !1)), js.rot.push(...Ei.getSortedTimesArray(!1, !0, !1)), js.scale.push(...Ei.getSortedTimesArray(!1, !1, !0));
          }
        for (const pe of re)
          pe.pos.sort((Se, Je) => Se - Je), pe.rot.sort((Se, Je) => Se - Je), pe.scale.sort((Se, Je) => Se - Je), pe.pos = [...new Set(pe.pos)], pe.rot = [...new Set(pe.rot)], pe.scale = [...new Set(pe.scale)];
        return re;
      }, c = function(A, $, V) {
        const ne = /* @__PURE__ */ new Map(), re = /* @__PURE__ */ new Map(), pe = /* @__PURE__ */ new Map(), Se = $.length;
        for (const Je of V) {
          const Ei = A.get(Je);
          let Jc;
          Ei ? console.assert(Ei.length === Se, "We should have the same number of TransformData entries for each bone", Ei, $) : Jc = new Ue(null, Je, null);
          for (let js = 0; js < Se; js++) {
            const ef = Ei ? Ei[js] : Jc, Ar = $[js];
            for (const { time: rl, translation: al } of ef.getValues(Ar.pos, !0, !1, !1)) {
              const en = (rl + Ar.timeOffset) * 60;
              ne.has(en) || ne.set(en, new Array()), ne.get(en).push(al.clone());
            }
            for (const { time: rl, rotation: al } of ef.getValues(Ar.rot, !1, !0, !1)) {
              const en = (rl + Ar.timeOffset) * 60;
              re.has(en) || re.set(en, new Array()), re.get(en).push(al.clone());
            }
            for (const { time: rl, scale: al } of ef.getValues(Ar.scale, !1, !1, !0)) {
              const en = (rl + Ar.timeOffset) * 60;
              pe.has(en) || pe.set(en, new Array()), pe.get(en).push(al.clone());
            }
          }
        }
        return {
          position: ne.size == 0 ? void 0 : ne,
          quaternion: re.size == 0 ? void 0 : re,
          scale: pe.size == 0 ? void 0 : pe
        };
      }, h = function(A) {
        const $ = [];
        for (const V of A)
          $.push(`(${ae(V.x)}, ${ae(V.y)}, ${ae(V.z)})`);
        return $.join(", ");
      }, d = function(A) {
        const $ = [];
        for (const V of A)
          $.push(`(${ae(V.w)}, ${ae(V.x)}, ${ae(V.y)}, ${ae(V.z)})`);
        return $.join(", ");
      }, f = function(A) {
        const $ = /* @__PURE__ */ new Map();
        if (Cn) {
          const V = new Array();
          for (const [ne, re] of o)
            V.push(ne.uuid + ": " + re.length + " " + re.map((pe) => pe.clip?.uuid.substring(0, 6)).join(" "));
          console.log(`getPerBoneTransformData
` + V.join(`
`));
        }
        for (const V of A) {
          const ne = o.get(V);
          ne && $.set(V, ne);
        }
        return $;
      }, p = function(A) {
        const $ = f(A), V = l($);
        return c($, V, A);
      };
      const g = n.skinnedMesh.skeleton, b = new Array(), m = [], v = [];
      for (const A of g.bones) {
        m.push(A), v.push(A.uuid);
        const $ = g.boneInverses[g.bones.indexOf(A)];
        b.push({ bone: A, inverse: $ });
      }
      let _ = 1e4;
      for (; v.length < g.bones.length && _-- > 0; )
        for (const A of m) {
          const $ = A.children;
          for (const V of $)
            if (v.indexOf(V.uuid) === -1 && g.bones.indexOf(V) !== -1) {
              m.push(V), v.push(V.uuid);
              const ne = g.boneInverses[g.bones.indexOf(V)];
              b.push({ bone: V, inverse: ne });
            }
        }
      _ <= 0 && console.error("Failed to sort bones in skinned mesh", n.skinnedMesh, g.bones, v);
      for (const A of Fv(g.bones))
        b.push({ bone: A, inverse: A.matrixWorld.clone().invert() });
      const x = b[0].bone.parent;
      x || console.error("No bone parent found for skinned mesh during USDZ export", n.skinnedMesh), b.sort((A, $) => fa(A.bone, x) > fa($.bone, x) ? 1 : -1);
      const I = t.quickLookCompatible, O = [], k = [], E = [], B = [];
      for (const { bone: A } of b) {
        if (I) {
          const $ = A.scale;
          $.x == 0 && ($.x = 1e-5), $.y == 0 && ($.y = 1e-5), $.z == 0 && ($.z = 1e-5), O.push(new ee().compose(A.position, A.quaternion, A.scale));
        } else
          O.push(A.matrix.clone());
        k.push(A.position), E.push(A.quaternion), B.push(A.scale);
      }
      const D = b.map((A) => '"' + fa(A.bone, x) + '"').join(", "), W = b.map((A) => $_(A.inverse.clone().invert())).join(", ");
      e.beginBlock('def Skeleton "Rig"'), e.appendLine(`uniform matrix4d[] bindTransforms = [${W}]`), e.appendLine(`uniform token[] joints = [${D}]`), e.appendLine('uniform token purpose = "guide"'), e.appendLine(`uniform matrix4d[] restTransforms = [${O.map((A) => $_(A)).join(", ")}]`);
      const X = p(b.map((A) => A.bone));
      if (Cn) {
        let A = 1e7, $ = 0;
        for (const V of X.position?.keys() ?? [])
          A = Math.min(A, V), $ = Math.max($, V);
        console.log("Time samples", A, $, X);
      }
      if (e.beginBlock('def SkelAnimation "_anim"'), e.appendLine(`uniform token[] joints = [${D}]`), e.appendLine(`quatf[] rotations = [${d(E)}]`), X && X.quaternion) {
        e.beginBlock("quatf[] rotations.timeSamples = {", "");
        const A = a(X.quaternion);
        for (const $ of A)
          e.appendLine($);
        e.closeBlock();
      }
      if (e.appendLine(`half3[] scales = [${h(B)}]`), X && X.scale) {
        e.beginBlock("half3[] scales.timeSamples = {", "");
        const A = r(X.scale);
        for (const $ of A)
          e.appendLine($);
        e.closeBlock();
      }
      if (e.appendLine(`float3[] translations = [${h(k)}]`), X && X.position) {
        e.beginBlock("float3[] translations.timeSamples = {", "");
        const A = r(X.position);
        for (const $ of A)
          e.appendLine($);
        e.closeBlock();
      }
      e.closeBlock(), e.closeBlock();
    }
  }
  onSerialize(e, t) {
    if (!this.model) return;
    const i = this.animationData.get(this.object);
    if (i)
      for (let h = 0; h < i.length; h++)
        i[h] === void 0 && (i[h] = new Ue(null, this.object, null));
    const n = this.ext;
    this.skinnedMeshExport(e, t, n);
    const o = this.object, r = this.model, a = this.animationData.get(o);
    if (!a || o.isSkinnedMesh) return;
    Jp && console.log("SERIALIZE", this.model.name, this.object.type, a);
    const l = Intl.NumberFormat("en-US", {
      maximumFractionDigits: 3,
      minimumFractionDigits: 0,
      useGrouping: !1
    });
    function c(h, d) {
      if (h.some((p) => p && {
        position: p.pos,
        rotation: p.rot,
        scale: p.scale
      }[d])) {
        switch (d) {
          case "position":
            r.needsTranslate = !0, e.beginBlock("double3 xformOp:translate.timeSamples = {", "");
            break;
          case "rotation":
            r.needsOrient = !0, e.beginBlock("quatf xformOp:orient.timeSamples = {", "");
            break;
          case "scale":
            r.needsScale = !0, e.beginBlock("double3 xformOp:scale.timeSamples = {", "");
            break;
        }
        for (let p = 0; p < h.length; p++) {
          const g = h[p];
          if (!g) continue;
          const b = n.getStartTimeByClip(g.clip), m = g.getSortedTimesArray(d === "position", d === "rotation", d === "scale");
          if (!m || m.length === 0) {
            console.error("got an animated object but no time values?", o, g);
            continue;
          }
          const v = !g.clip, _ = d === "position" && (g.pos || v), x = d === "rotation" && (g.rot || v), I = d === "scale" && (g.scale || v);
          if (_ || x || I) {
            const O = g.clip?.name ?? "rest", k = g.getDuration();
            Cn && console.log("Write .timeSamples:", O, b, k, h), e.appendLine("# " + O + ": start=" + l.format(b * Ue.frameRate) + ", length=" + l.format(k * Ue.frameRate) + ", frames=" + g.getFrames());
          }
          if (_)
            for (const { time: O, translation: k } of g.getValues(m, !0, !1, !1)) {
              const B = `${l.format((b + O) * Ue.frameRate)}: (${ae(k.x)}, ${ae(k.y)}, ${ae(k.z)}),`;
              e.appendLine(B);
            }
          if (x)
            for (const { time: O, rotation: k } of g.getValues(m, !1, !0, !1)) {
              const B = `${l.format((b + O) * Ue.frameRate)}: (${ae(k.w)}, ${ae(k.x)}, ${ae(k.y)}, ${ae(k.z)}),`;
              e.appendLine(B);
            }
          if (I)
            for (const { time: O, scale: k } of g.getValues(m, !1, !1, !0)) {
              const B = `${l.format((b + O) * Ue.frameRate)}: (${ae(k.x)}, ${ae(k.y)}, ${ae(k.z)}),`;
              e.appendLine(B);
            }
        }
        e.closeBlock();
      }
    }
    c(a, "position"), c(a, "rotation"), c(a, "scale");
  }
}
const xR = w("debugusdz");
class Na {
  static getName(e) {
    const t = e.split(".").pop();
    let n = e.split(".").slice(0, -1).join(".").split("/").pop()?.replace(".", "_");
    return n || (n = "Audio_" + Math.random().toString(36).substring(2, 15)), dn(n) + "." + t;
  }
  get extensionName() {
    return "Audio";
  }
  files = new Array();
  onExportObject(e, t, i) {
    const n = S.getComponents(e, Xi);
    if (n.length)
      for (const o of n) {
        if (!o.clip || typeof o.clip != "string" || !o.playOnAwake)
          continue;
        const r = o.clip.split("/").pop() || "Audio", a = Na.getName(o.clip), l = dn(a);
        if (!this.files.some((c) => c.path === o.clip)) {
          this.files.push({ path: o.clip, name: a });
          const c = a.toLowerCase();
          i.quickLookCompatible && !c.endsWith(".mp3") && !c.endsWith(".wav") && !c.endsWith(".m4a") && console.error("Audio file " + o.clip + " from " + o.name + " is not an MP3 or WAV file. QuickLook may not support playing it.");
        }
        i.quickLookCompatible || t.addEventListener("serialize", (c, h) => {
          c.appendLine(), c.beginBlock(`def SpatialAudio "${l}"`, "(", !1), c.appendLine(`displayName = "${r}"`), c.closeBlock(")"), c.beginBlock(), c.appendLine(`uniform asset filePath = @audio/${a}@`), c.appendLine(`uniform token auralMode = "${o.spatialBlend > 0 ? "spatial" : "nonSpatial"}"`), c.appendLine(`uniform token playbackMode = "${o.loop ? "loopFromStage" : "onceFromStart"}"`), c.appendLine(`uniform float gain = ${o.volume}`), c.closeBlock();
        });
      }
  }
  async onAfterSerialize(e) {
    for (const t of this.files) {
      const i = "audio/" + t.name;
      if (e.files[i]) {
        xR && console.warn("Audio file with name " + i + " already exists in the context. Skipping.");
        continue;
      }
      const r = await (await (await fetch(t.path)).blob()).arrayBuffer(), a = new Uint8Array(r);
      e.files[i] = a;
    }
  }
}
var SR = Object.defineProperty, Fe = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && SR(e, t, n), n;
};
const q_ = w("debugusdzbehaviours");
function Tc(s) {
  s && (s.getComponentInParent(Ta) || (L() && console.debug('Raycaster on "' + s.name + '" was automatically added, because no raycaster was found in the parent hierarchy.'), s.addComponent(qi)));
}
class $a extends R {
  object;
  target;
  duration = 1;
  relativeMotion = !1;
  coroutine = null;
  targetPos = new y();
  targetRot = new U();
  targetScale = new y();
  start() {
    Tc(this.gameObject);
  }
  onPointerClick(e) {
    e.use(), this.coroutine && this.stopCoroutine(this.coroutine), this.relativeMotion ? this.coroutine = this.startCoroutine(this.moveRelative()) : this.coroutine = this.startCoroutine(this.moveToTarget());
  }
  *moveToTarget() {
    if (!this.target || !this.object) return;
    const e = Z(this.object).clone(), t = Z(this.target).clone(), i = be(this.object).clone(), n = be(this.target).clone(), o = Qe(this.object).clone(), r = Qe(this.target).clone(), a = e.distanceTo(t), l = i.angleTo(n), c = o.distanceTo(r);
    if (a < 0.01 && l < 0.01 && c < 0.01) {
      Ot(this.object, t), jn(this.object, n), hc(this.object, r), this.coroutine = null;
      return;
    }
    let h = 0, d = 0;
    for (; h < 1; )
      h += this.context.time.deltaTime / this.duration, h > 1 && (h = 1), d = h < 0.5 ? 4 * h * h * h : 1 - Math.pow(-2 * h + 2, 3) / 2, this.targetPos.lerpVectors(e, t, d), this.targetRot.slerpQuaternions(i, n, d), this.targetScale.lerpVectors(o, r, d), Ot(this.object, this.targetPos), jn(this.object, this.targetRot), hc(this.object, this.targetScale), yield;
    this.coroutine = null;
  }
  *moveRelative() {
    if (!this.target || !this.object) return;
    const e = this.object.position.clone(), t = this.object.quaternion.clone(), i = this.object.scale.clone(), n = this.target.position.clone(), o = this.target.quaternion.clone(), r = this.target.scale.clone();
    n.applyQuaternion(this.object.quaternion), this.targetPos.copy(this.object.position).add(n), this.targetRot.copy(this.object.quaternion).multiply(o), this.targetScale.copy(this.object.scale).multiply(r);
    let a = 0, l = 0;
    for (; a < 1; )
      a += this.context.time.deltaTime / this.duration, a > 1 && (a = 1), l = a < 0.5 ? 4 * a * a * a : 1 - Math.pow(-2 * a + 2, 3) / 2, this.object.position.lerpVectors(e, this.targetPos, l), this.object.quaternion.slerpQuaternions(t, this.targetRot, l), this.object.scale.lerpVectors(i, this.targetScale, l), yield;
    this.coroutine = null;
  }
  beforeCreateDocument(e) {
    if (this.target && this.object && this.gameObject) {
      const t = new It(
        "Move to " + this.target?.name,
        Gt.tapTrigger(this.gameObject),
        me.transformAction(this.object, this.target, this.duration, this.relativeMotion ? "relative" : "absolute")
      );
      e.addBehavior(t);
    }
  }
}
Fe([
  u(M)
], $a.prototype, "object");
Fe([
  u(M)
], $a.prototype, "target");
Fe([
  u()
], $a.prototype, "duration");
Fe([
  u()
], $a.prototype, "relativeMotion");
const bu = class Nt extends R {
  materialToSwitch;
  variantMaterial;
  fadeDuration = 0;
  start() {
    this._objectsWithThisMaterial = this.objectsWithThisMaterial, Tc(this.gameObject), L() && this._objectsWithThisMaterial.length <= 0 && console.warn('ChangeMaterialOnClick: No objects found with material "' + this.materialToSwitch?.name + '"');
  }
  onPointerEnter(e) {
    this.context.input.setCursor("pointer");
  }
  onPointerExit(e) {
    this.context.input.unsetCursor("pointer");
  }
  onPointerClick(e) {
    if (e.use(), !!this.variantMaterial)
      for (let t = 0; t < this.objectsWithThisMaterial.length; t++) {
        const i = this.objectsWithThisMaterial[t];
        i.material = this.variantMaterial;
      }
  }
  _objectsWithThisMaterial = null;
  /** Get all objects in the scene that have the assigned materialToSwitch */
  get objectsWithThisMaterial() {
    return this._objectsWithThisMaterial != null ? this._objectsWithThisMaterial : (this._objectsWithThisMaterial = [], this.variantMaterial && this.materialToSwitch && this.context.scene.traverse((e) => {
      if (e instanceof G)
        if (Array.isArray(e.material)) {
          for (const t of e.material)
            if (t === this.materialToSwitch) {
              this.objectsWithThisMaterial.push(e);
              break;
            }
        } else
          e.material === this.materialToSwitch ? this.objectsWithThisMaterial.push(e) : MP(e.material, this.materialToSwitch) && this.objectsWithThisMaterial.push(e);
    }), this._objectsWithThisMaterial);
  }
  selfModel;
  targetModels;
  static _materialTriggersPerId = {};
  static _startHiddenBehaviour = null;
  static _parallelStartHiddenActions = [];
  async beforeCreateDocument(e, t) {
    this.targetModels = [], Nt._materialTriggersPerId = {}, Nt.variantSwitchIndex = 0, this.materialToSwitch && await We.assignTextureLOD(this.materialToSwitch, 0), this.variantMaterial && await We.assignTextureLOD(this.variantMaterial, 0);
  }
  createBehaviours(e, t, i) {
    this.objectsWithThisMaterial.find((o) => o.uuid === t.uuid) && this.targetModels.push(t), this.gameObject.uuid === t.uuid && (this.selfModel = t, this.materialToSwitch && (Nt._materialTriggersPerId[this.materialToSwitch.uuid] || (Nt._materialTriggersPerId[this.materialToSwitch.uuid] = []), Nt._materialTriggersPerId[this.materialToSwitch.uuid].push(this)));
  }
  afterCreateDocument(e, t) {
    if (!this.materialToSwitch) return;
    const i = Nt._materialTriggersPerId[this.materialToSwitch.uuid];
    if (i) {
      const n = {};
      for (const o of i) {
        const r = o.createVariants();
        r && r.length > 0 && (n[o.selfModel.uuid] = r);
      }
      for (const o of i) {
        const r = [];
        for (const a in n)
          a !== o.selfModel.uuid && r.push(...n[a]);
        o.createAndAttachBehaviors(e, n[o.selfModel.uuid], r);
      }
    }
    delete Nt._materialTriggersPerId[this.materialToSwitch.uuid];
  }
  createAndAttachBehaviors(e, t, i) {
    const n = [], o = Math.max(0, this.fadeDuration);
    n.push(me.fadeAction([...this.targetModels, ...i], o, !1)), n.push(me.fadeAction(t, o, !0)), e.addBehavior(
      new It(
        "Select_" + this.selfModel.name,
        Gt.tapTrigger(this.selfModel),
        me.parallel(...n)
      )
    ), Nt._parallelStartHiddenActions.push(...t), Nt._startHiddenBehaviour || (Nt._startHiddenBehaviour = new It(
      "StartHidden_" + this.selfModel.name,
      Gt.sceneStartTrigger(),
      me.fadeAction(Nt._parallelStartHiddenActions, o, !1)
    ), e.addBehavior(Nt._startHiddenBehaviour));
  }
  static getMaterialName(e) {
    return dn(e.name || "Material") + "_" + e.id;
  }
  static variantSwitchIndex = 0;
  createVariants() {
    if (!this.variantMaterial) return null;
    const e = [];
    for (const t of this.targetModels) {
      const i = t.clone();
      i.name += "_Variant_" + Nt.variantSwitchIndex++ + "_" + Nt.getMaterialName(this.variantMaterial), i.displayName = i.displayName + ": Variant with material " + this.variantMaterial.name, i.material = this.variantMaterial, i.geometry = t.geometry, i.transform = t.transform, (!t.parent || !t.parent.isEmpty()) && st.createEmptyParent(t), t.parent && t.parent.add(i), e.push(i);
    }
    return e;
  }
};
Fe([
  u(_e)
], bu.prototype, "materialToSwitch");
Fe([
  u(_e)
], bu.prototype, "variantMaterial");
Fe([
  u()
], bu.prototype, "fadeDuration");
let Gv = bu;
const Ec = class Ae extends R {
  target;
  toggleOnClick = !1;
  targetState = !0;
  hideSelf = !0;
  start() {
    Tc(this.gameObject);
  }
  onPointerClick(e) {
    e.use(), !this.toggleOnClick && this.hideSelf && (this.gameObject.visible = !1), this.target && (this.target.visible = this.toggleOnClick ? !this.target.visible : this.targetState);
  }
  selfModel;
  selfModelClone;
  targetModel;
  toggleModel;
  createBehaviours(e, t, i) {
    t.uuid === this.gameObject.uuid && (this.selfModel = t, this.selfModelClone = t.clone());
  }
  stateBeforeCreatingDocument = !1;
  targetStateBeforeCreatingDocument = !1;
  static clonedToggleIndex = 0;
  static wasVisible = Symbol("usdz_SetActiveOnClick_wasVisible");
  static toggleClone = Symbol("clone for toggling");
  static reverseToggleClone = Symbol("clone for reverse toggling");
  beforeCreateDocument() {
    this.target && (this.gameObject[Ae.wasVisible] === void 0 && (this.gameObject[Ae.wasVisible] = this.gameObject.activeSelf), this.target[Ae.wasVisible] === void 0 && (this.target[Ae.wasVisible] = this.target.activeSelf), this.stateBeforeCreatingDocument = this.gameObject[Ae.wasVisible], this.targetStateBeforeCreatingDocument = this.target[Ae.wasVisible], this.gameObject.visible = !0, this.target.visible = !0);
  }
  afterCreateDocument(e, t) {
    if (!this.target) return;
    this.targetModel = t.document.findById(this.target.uuid);
    const i = this.selfModel;
    if (this.selfModel && this.targetModel) {
      let n = this.selfModel, o = this.targetState;
      if (this.toggleOnClick)
        if (o = !this.targetStateBeforeCreatingDocument, !this.selfModelClone.geometry)
          (!this.selfModel.parent || this.selfModel.parent.isEmpty()) && zv.createEmptyParent(this.selfModel), this.toggleModel = this.selfModel.deepClone(), this.toggleModel.name += "_toggle", this.selfModel.parent.add(this.toggleModel);
        else {
          if (!this.gameObject[Ae.toggleClone]) {
            const l = this.selfModelClone.clone();
            l.setMatrix(new ee()), l.name += "_toggle" + Ae.clonedToggleIndex++, i.add(l), this.gameObject[Ae.toggleClone] = l, console.warn("USDZExport: Toggle " + this.gameObject.name + " doesn't have geometry. It will be deep cloned and nested behaviours will likely not work.");
          }
          const a = this.gameObject[Ae.toggleClone];
          if (!this.gameObject[Ae.reverseToggleClone]) {
            const l = this.selfModelClone.clone();
            l.setMatrix(new ee()), l.name += "_toggleReverse" + Ae.clonedToggleIndex++, i.add(l), this.gameObject[Ae.reverseToggleClone] = l;
          }
          this.toggleModel = this.gameObject[Ae.reverseToggleClone], (!this.toggleModel.geometry || !a.geometry) && console.error("triggers without childs and without geometry won't work!", this, i.geometry), n = a, i.geometry = null, i.material = null;
        }
      if (this.toggleModel) {
        if (this.toggleOnClick) {
          const a = [];
          a.push(me.fadeAction(n, 0, !1)), a.push(me.fadeAction(this.toggleModel, 0, !0)), a.push(me.fadeAction(this.targetModel, 0, o)), e.addBehavior(new It(
            "Toggle_" + n.name + "_ToggleTo" + (o ? "On" : "Off"),
            Gt.tapTrigger(n),
            me.parallel(...a)
          ));
          const l = [];
          l.push(me.fadeAction(this.toggleModel, 0, !1)), l.push(me.fadeAction(n, 0, !0)), l.push(me.fadeAction(this.targetModel, 0, !o)), e.addBehavior(new It(
            "Toggle_" + n.name + "_ToggleTo" + (o ? "Off" : "On"),
            Gt.tapTrigger(this.toggleModel),
            me.parallel(...l)
          ));
        }
      } else {
        const a = [];
        this.hideSelf && a.push(me.fadeAction(n, 0, !1)), a.push(me.fadeAction(this.targetModel, 0, o)), e.addBehavior(new It(
          "Toggle_" + n.name + "_ToggleTo" + (o ? "On" : "Off"),
          Gt.tapTrigger(n),
          a.length > 1 ? me.parallel(...a) : a[0]
        ));
      }
      const r = new Array();
      this.targetStateBeforeCreatingDocument || r.push(this.targetModel), this.stateBeforeCreatingDocument || r.push(i), this.toggleModel && r.push(this.toggleModel), on.add(r, e);
    }
  }
  afterSerialize(e, t) {
    this.gameObject[Ae.wasVisible] !== void 0 && (this.gameObject.visible = this.gameObject[Ae.wasVisible], delete this.gameObject[Ae.wasVisible]), this.target && this.target[Ae.wasVisible] !== void 0 && (this.target.visible = this.target[Ae.wasVisible], delete this.target[Ae.wasVisible]), delete this.gameObject[Ae.toggleClone], delete this.gameObject[Ae.reverseToggleClone];
  }
};
Fe([
  u(M)
], Ec.prototype, "target");
Fe([
  u()
], Ec.prototype, "toggleOnClick");
Fe([
  u()
], Ec.prototype, "targetState");
Fe([
  u()
], Ec.prototype, "hideSelf");
let qv = Ec;
class on extends R {
  static _fadeBehaviour;
  static _fadeObjects = [];
  static add(e, t) {
    const i = Array.isArray(e) ? e : [e];
    for (const n of i)
      on._fadeObjects.includes(n) || (console.log("adding hide on start", n), on._fadeObjects.push(n));
    on._fadeBehaviour === void 0 && (on._fadeBehaviour = new It(
      "HideOnStart",
      Gt.sceneStartTrigger(),
      //@ts-ignore
      me.fadeAction(on._fadeObjects, 0, !1)
    ), t.addBehavior(on._fadeBehaviour));
  }
  start() {
    S.setActive(this.gameObject, !1);
  }
  createBehaviours(e, t, i) {
    t.uuid === this.gameObject.uuid && (this.wasVisible || on.add(t, e));
  }
  wasVisible = !1;
  beforeCreateDocument() {
    this.wasVisible = S.isActiveSelf(this.gameObject);
  }
}
class Ac extends R {
  target;
  duration = 0.5;
  motionType = "bounce";
  beforeCreateDocument() {
  }
  createBehaviours(e, t, i) {
    if (this.target && t.uuid === this.gameObject.uuid) {
      const n = new It(
        "emphasize " + this.name,
        Gt.tapTrigger(this.gameObject),
        me.emphasize(this.target, this.duration, this.motionType, void 0, "basic")
      );
      e.addBehavior(n);
    }
  }
  afterCreateDocument(e, t) {
  }
}
Fe([
  u()
], Ac.prototype, "target");
Fe([
  u()
], Ac.prototype, "duration");
Fe([
  u()
], Ac.prototype, "motionType");
class cr extends R {
  target;
  clip = "";
  toggleOnClick = !1;
  // Not exposed, but used for implicit playback of PlayOnAwake audio sources
  trigger = "tap";
  start() {
    Tc(this.gameObject);
  }
  ensureAudioSource() {
    if (!this.target) {
      const e = this.gameObject.addComponent(Xi);
      e && (this.target = e, e.spatialBlend = 1, e.volume = 1, e.loop = !1, e.preload = !0);
    }
  }
  onPointerClick(e) {
    e.use(), !(!this.target?.clip && !this.clip) && (this.ensureAudioSource(), this.target && (this.target.isPlaying && this.toggleOnClick ? this.target.stop() : (!this.toggleOnClick && this.target.isPlaying && this.target.stop(), this.clip ? this.target.play(this.clip) : this.target.play())));
  }
  createBehaviours(e, t, i) {
    if (!(!this.target && !this.clip) && t.uuid === this.gameObject.uuid) {
      const n = this.clip ? this.clip : this.target ? this.target.clip : void 0;
      if (!n || typeof n != "string") return;
      const o = this.target ? this.target.gameObject : this.gameObject;
      Na.getName(n);
      const r = this.target ? this.target.volume : 1, a = this.target && this.target.spatialBlend == 0 ? "nonSpatial" : "spatial";
      let l = !1;
      this.gameObject.traverse((f) => {
        f instanceof G && f.visible && (l = !0);
      }), l = !0;
      const c = e.addAudioClip(n);
      let h = me.playAudioAction(o, c, "play", r, a);
      this.target && this.target.loop && (h = me.sequence(h).makeLooping());
      const d = this.name ? "_" + this.name : "";
      if (l && this.trigger === "tap") {
        this.toggleOnClick && (h.multiplePerformOperation = "stop");
        const f = new It(
          "playAudio" + d,
          Gt.tapTrigger(t),
          h
        );
        e.addBehavior(f);
      }
      if (this.target && this.target.playOnAwake && this.target.enabled)
        if (l && this.trigger === "tap")
          console.warn("USDZExport: Audio sources that are played on tap can't also auto-play at scene start due to a QuickLook bug.");
        else {
          const f = new It(
            "playAudioOnStart" + d,
            Gt.sceneStartTrigger(),
            h
          );
          e.addBehavior(f);
        }
    }
  }
}
Fe([
  u(Xi)
], cr.prototype, "target");
Fe([
  u(URL)
], cr.prototype, "clip");
Fe([
  u()
], cr.prototype, "toggleOnClick");
const Sg = class bn extends R {
  animator;
  stateName;
  // Not editable from the outside yet, but from code
  // we want to expose this once we have a nice drawer for "Triggers" (e.g. shows proximity distance)
  // and once we rename the component to "PlayAnimation" or "PlayAnimationOnTrigger"
  trigger = "tap";
  // "proximity"
  animation;
  get target() {
    return this.animator?.gameObject || this.animation?.gameObject;
  }
  start() {
    Tc(this.gameObject);
  }
  onPointerClick(e) {
    e.use(), this.target && this.stateName && this.animator?.play(this.stateName, 0, 0, 0.1);
  }
  selfModel;
  stateAnimationModel;
  animationSequence = new Array();
  animationLoopAfterSequence = new Array();
  randomOffsetNormalized = 0;
  createBehaviours(e, t, i) {
    t.uuid === this.gameObject.uuid && (this.selfModel = t);
  }
  static animationActions = [];
  static rootsWithExclusivePlayback = /* @__PURE__ */ new Set();
  // Cleanup. TODO This is not the best way as it's called multiple times (once for each component).
  afterSerialize() {
    if (bn.rootsWithExclusivePlayback.size > 1) {
      const e = 'Multiple root objects targeted by more than one animation. To work around QuickLook bug FB13410767, animations will be set as "exclusive" and activating them will stop other animations being marked as exclusive.';
      L() && ge(e), console.warn(e, ...bn.rootsWithExclusivePlayback);
    }
    bn.animationActions = [], bn.rootsWithExclusivePlayback = /* @__PURE__ */ new Set();
  }
  afterCreateDocument(e, t) {
    if (this.animationSequence === void 0 && this.animationLoopAfterSequence === void 0 || !this.stateAnimationModel || !this.target) return;
    const i = t.document, n = t.extensions.find((a) => a instanceof xg);
    if (!n) return;
    const o = n.getClipCount(this.target) > 1;
    o && (L() && console.warn("Setting exclusive playback for " + this.target.name + "@" + this.stateName + " because it has " + n.getClipCount(this.target) + " animations. This works around QuickLook bug FB13410767."), bn.rootsWithExclusivePlayback.add(this.target));
    const r = this.name ? this.name : "";
    i.traverse((a) => {
      if (a.uuid === this.target?.uuid) {
        const l = bn.getActionForSequences(
          i,
          a,
          this.animationSequence,
          this.animationLoopAfterSequence,
          this.randomOffsetNormalized
        ), c = new It(
          this.trigger + "_" + r + "_toPlayAnimation_" + this.stateName + "_on_" + this.target?.name,
          this.trigger == "tap" ? Gt.tapTrigger(this.selfModel) : Gt.sceneStartTrigger(),
          l
        );
        o && c.makeExclusive(!0), e.addBehavior(c);
      }
    });
  }
  static getActionForSequences(e, t, i, n, o) {
    const r = (l, c) => {
      let h = bn.animationActions.find((d) => d.affectedObjects == l && d.start == c.start && d.duration == c.duration && d.animationSpeed == c.speed);
      return h || (h = me.startAnimationAction(l, c), bn.animationActions.push(h)), h;
    }, a = me.sequence();
    if (i && i.length > 0)
      for (const l of i)
        a.addAction(r(t, l));
    if (n && n.length > 0) {
      const l = a.actions.length == 0 ? a : me.sequence();
      for (const c of n)
        l.addAction(r(t, c));
      l.makeLooping(), a !== l && a.addAction(l);
    }
    return o && o > 0 && a.actions.unshift(me.waitAction(o)), a;
  }
  static getAndRegisterAnimationSequences(e, t, i) {
    if (!t) return;
    const n = t.getComponent(kt), o = t.getComponent(ni);
    if (!n && !o) return;
    if (n && !i)
      throw new Error("PlayAnimationOnClick: No stateName specified for animator " + n.name + " on " + t.name);
    let r = [], a = [];
    if (o) {
      const g = e.registerAnimation(t, o.clip);
      g && (o.loop ? a.push(g) : r.push(g));
      let b = 0;
      if (o.minMaxOffsetNormalized) {
        const m = o.minMaxOffsetNormalized.x, v = o.minMaxOffsetNormalized.y;
        b = (o.clip?.duration || 1) * (m + Math.random() * (v - m));
      }
      return {
        animationSequence: r,
        animationLoopAfterSequence: a,
        randomTimeOffset: b
      };
    }
    const l = n?.runtimeAnimatorController;
    let c = l?.findState(i), h = [], d = [];
    if (l && c) {
      const g = new Array();
      g.push(c);
      let b = !1;
      for (; g.length < 100; ) {
        if (!c || c === null || !c.transitions || c.transitions.length === 0) {
          c.motion?.isLooping && (b = !0);
          break;
        }
        const m = c.transitions.find((_) => _.conditions.length === 0), v = m ? l.getState(m.destinationState, 0) : null;
        if (v && g.includes(v)) {
          c = v, b = !0;
          break;
        } else if (m) {
          if (c = v, !c)
            break;
          g.push(c);
        } else {
          b = c.motion?.isLooping ?? !1;
          break;
        }
      }
      if (b && c) {
        const m = g.indexOf(c);
        h = g.slice(0, m), d = g.slice(m), q_ && console.log("found loop from " + i, "states until loop", h, "states looping", d);
      } else
        h = g, d = [], q_ && console.log("found no loop from " + i, "states", h);
      if (!d.length) {
        const m = h[h.length - 1], v = m.motion?.clip;
        if (v) {
          let _;
          if (e.holdClipMap.has(v))
            _ = e.holdClipMap.get(v);
          else {
            const x = m.name + "_hold";
            _ = v.clone(), _.duration = 1, _.name = x;
            const I = v.duration;
            _.tracks = v.tracks.map((O) => {
              const k = O.clone();
              k.times = new Float32Array([0, I]);
              const E = O.values.length, B = O.getValueSize(), D = O.values.slice(E - B, E);
              return k.values = new Float32Array(2 * B), k.values.set(D, 0), k.values.set(D, B), k;
            }), _.name = x, e.holdClipMap.set(v, _);
          }
          if (_) {
            const x = {
              name: _.name,
              motion: { clip: _, isLooping: !1, name: _.name },
              speed: 1,
              transitions: [],
              behaviours: [],
              hash: m.hash + 1
            };
            d.push(x);
          }
        }
      }
    }
    if (h.length === 1 && (!h[0].motion?.clip || h[0].motion?.clip.tracks?.length === 0)) {
      r = new Array();
      const g = e.registerAnimation(t, null);
      g && r.push(g);
      return;
    }
    if (h = h.filter((g) => g.motion?.clip && g.motion?.clip.tracks?.length > 0), d = d.filter((g) => g.motion?.clip && g.motion?.clip.tracks?.length > 0), h.length === 0 && d.length === 0) {
      console.warn("No clips found for state " + i + " on " + n?.name + ", can't export animation data");
      return;
    }
    const f = (g, b) => {
      if (!t) return;
      const m = e.registerAnimation(t, g.motion.clip ?? null);
      m ? (m.speed = g.speed, b.push(m)) : console.warn("Couldn't register animation for state " + g.name + " on " + n?.name);
    };
    if (h.length > 0) {
      r = new Array();
      for (const g of h)
        f(g, r);
    }
    if (d.length > 0) {
      a = new Array();
      for (const g of d)
        f(g, a);
    }
    let p = 0;
    if (n && l && n.minMaxOffsetNormalized) {
      const g = n.minMaxOffsetNormalized.x, b = n.minMaxOffsetNormalized.y;
      p = ((h.length ? h[0] : d.length ? d[0] : null)?.motion.clip?.duration || 1) * (g + Math.random() * (b - g));
    }
    return {
      animationSequence: r,
      animationLoopAfterSequence: a,
      randomTimeOffset: p
    };
  }
  createAnimation(e, t, i) {
    if (!this.target || !this.animator && !this.animation) return;
    const n = bn.getAndRegisterAnimationSequences(e, this.target, this.stateName);
    n && (this.animationSequence = n.animationSequence, this.animationLoopAfterSequence = n.animationLoopAfterSequence, this.randomOffsetNormalized = n.randomTimeOffset, this.stateAnimationModel = t);
  }
};
Fe([
  u(kt)
], Sg.prototype, "animator");
Fe([
  u()
], Sg.prototype, "stateName");
let Md = Sg;
class Ic extends R {
  getType() {
  }
  target;
  getDuration() {
  }
}
Fe([
  u(M)
], Ic.prototype, "target");
class vu extends R {
  target;
}
Fe([
  u(Ic)
], vu.prototype, "target");
class wu extends Ic {
  type = 1;
  duration = 1;
  getType() {
    switch (this.type) {
      case 1:
        return "hide";
      case 0:
        return "show";
    }
  }
  getDuration() {
    return this.duration;
  }
}
Fe([
  u()
], wu.prototype, "type");
Fe([
  u()
], wu.prototype, "duration");
class Xv extends vu {
}
class or {
  static _instance;
  static create() {
    return new or();
  }
  static getOrCreate() {
    return this._instance || (this._instance = this.create()), this._instance;
  }
  get isSecureConnection() {
    return window.location.protocol === "https:";
  }
  get quicklookButton() {
    return this._quicklookButton;
  }
  _quicklookButton;
  get arButton() {
    return this._arButton;
  }
  _arButton;
  get vrButton() {
    return this._vrButton;
  }
  _vrButton;
  get sendToQuestButton() {
    return this._sendToQuestButton;
  }
  _sendToQuestButton;
  get qrButton() {
    return kn.getOrCreate().createQRCode();
  }
  /** get or create the quicklook button 
   * Behaviour of the button:
   * - if the button is clicked a USDZExporter component will be searched for in the scene and if found, it will be used to export the scene to USDZ / Quicklook
  */
  createQuicklookButton() {
    if (this._quicklookButton) return this._quicklookButton;
    const e = document.createElement("button");
    this._quicklookButton = e, e.dataset.needle = "quicklook-button";
    const t = q.supportsQuickLookAR();
    e.innerText = "View in AR", e.prepend(Et("view_in_ar"));
    let i = !1, n = null;
    return e.addEventListener("click", () => {
      n = su(ws), n || (i = !0, n = new ws()), i && (n.objectToExport = N.Current.scene), n ? (e.classList.add("this-mode-is-requested"), n.exportAndOpen().then(() => {
        e.classList.remove("this-mode-is-requested");
      }).catch((o) => {
        e.classList.remove("this-mode-is-requested"), console.error(o);
      })) : console.warn("No USDZExporter component found in the scene");
    }), this.hideElementDuringXRSession(e), e;
  }
  /** get or create the WebXR AR button  
   * @param init optional session init options
   * Behaviour of the button:
   * - if the device supports AR, the button will be visible and clickable
   * - if the device does not support AR, the button will be hidden
   * - if the device changes and now supports AR, the button will be visible
   */
  createARButton(e) {
    if (this._arButton) return this._arButton;
    const t = "immersive-ar", i = document.createElement("button");
    return this._arButton = i, i.classList.add("webxr-button"), i.dataset.needle = "webxr-ar-button", i.innerText = "Enter AR", i.prepend(Et("view_in_ar")), i.title = "Click to start an AR session", i.addEventListener("click", () => K.start(t, e)), this.updateSessionSupported(i, t), this.listenToXRSessionState(i, t), this.hideElementDuringXRSession(i), this.isSecureConnection || (i.disabled = !0, i.title = "WebXR requires a secure connection (HTTPS)"), q.isMozillaXR() || navigator.xr?.addEventListener("devicechange", () => this.updateSessionSupported(i, t)), i;
  }
  /** get or create the WebXR VR button 
   * @param init optional session init options
   * Behaviour of the button:
   * - if the device supports VR, the button will be visible and clickable
   * - if the device does not support VR, the button will be hidden
   * - if the device changes and now supports VR, the button will be visible
  */
  createVRButton(e) {
    if (this._vrButton) return this._vrButton;
    const t = "immersive-vr", i = document.createElement("button");
    return this._vrButton = i, i.classList.add("webxr-button"), i.dataset.needle = "webxr-vr-button", i.innerText = "Enter VR", i.prepend(Et("panorama_photosphere")), i.title = "Click to start a VR session", i.addEventListener("click", () => K.start(t, e)), this.updateSessionSupported(i, t), this.listenToXRSessionState(i, t), this.hideElementDuringXRSession(i), this.isSecureConnection || (i.disabled = !0, i.title = "WebXR requires a secure connection (HTTPS)"), q.isMozillaXR() || navigator.xr?.addEventListener("devicechange", () => this.updateSessionSupported(i, t)), i;
  }
  /** get or create the Send To Quest button 
   * Behaviour of the button:
   * - if the button is clicked, the current URL will be sent to the Oculus Browser on the Quest
  */
  createSendToQuestButton() {
    if (this._sendToQuestButton) return this._sendToQuestButton;
    const e = "https://oculus.com/open_url/?url=", t = document.createElement("button");
    return this._sendToQuestButton = t, t.dataset.needle = "webxr-sendtoquest-button", t.innerText = "Open on Quest", t.prepend(Et("share_windows")), t.title = "Click to send this page to the Oculus Browser on your Quest", t.addEventListener("click", () => {
      const i = encodeURIComponent(window.location.href), n = e + i;
      window.open(n) == null && Be("This page doesn't allow popups. Please paste " + n + " into your browser.");
    }), this.listenToXRSessionState(t), this.hideElementDuringXRSession(t), q.isMozillaXR() || navigator.xr?.addEventListener("devicechange", () => {
      navigator.xr?.isSessionSupported("immersive-vr") ? t.style.display = "none" : t.style.display = "";
    }), t;
  }
  /**
   * @deprecated please use ButtonsFactory.getOrCreate().createQRCode(). This method will be removed in a future update
   */
  createQRCode() {
    return kn.getOrCreate().createQRCode();
  }
  updateSessionSupported(e, t) {
    if (!("xr" in navigator)) {
      e.style.display = "none";
      return;
    }
    K.isSessionSupported(t).then((i) => {
      e.style.display = i ? "" : "none", L() && !i && console.log('[WebXR] "' + t + '" is not supported on this device – make sure your server runs using HTTPS and you have a device connected that supports ' + t);
    });
  }
  hideElementDuringXRSession(e) {
    zm((t) => {
      e["previous-display"] = e.style.display, e.style.display = "none";
    }), p0((t) => {
      e["previous-display"] != null && (e.style.display = e["previous-display"]);
    });
  }
  listenToXRSessionState(e, t) {
    t && (K.onSessionRequestStart((i) => {
      i.mode === t ? e.classList.add("this-mode-is-requested") : (e["was-disabled"] = e.disabled, e.disabled = !0, e.classList.add("other-mode-is-requested"));
    }), K.onSessionRequestEnd((i) => {
      e.classList.remove("this-mode-is-requested"), e.classList.remove("other-mode-is-requested"), e.disabled = e["was-disabled"];
    }));
  }
}
var CR = Object.defineProperty, PR = Object.getOwnPropertyDescriptor, gt = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? PR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && CR(e, t, n), n;
};
const ec = w("debugspriterenderer"), OR = w("wireframe");
class hr {
  static cache = {};
  static getOrCreateGeometry(e) {
    if (e.__cached_geometry) return e.__cached_geometry;
    if (e.guid && hr.cache[e.guid])
      return ec && console.log("Take cached geometry for sprite", e.guid), hr.cache[e.guid];
    const t = new an();
    e.__cached_geometry = t;
    const i = new Float32Array(e.triangles.length * 3), n = new Float32Array(e.triangles.length * 2);
    for (let o = 0; o < e.triangles.length; o += 1) {
      const r = e.triangles[o];
      i[o * 3] = -e.vertices[r].x, i[o * 3 + 1] = e.vertices[r].y, i[o * 3 + 2] = 0;
      const a = e.uv[r];
      n[o * 2] = a.x, n[o * 2 + 1] = 1 - a.y;
    }
    return t.setAttribute("position", new ft(i, 3)), t.setAttribute("uv", new ft(n, 2)), e.guid && (this.cache[e.guid] = t), ec && console.log("Built sprite geometry", e, t), t;
  }
}
class kR {
  x;
  y;
}
function Qv(s) {
  s && (s.colorSpace != Cs && (s.colorSpace = Cs, s.needsUpdate = !0), s.minFilter == nd && s.magFilter == nd && (s.anisotropy = 1, s.needsUpdate = !0));
}
let wo = class {
  constructor(e) {
    e && (this.texture = e, this.triangles = [0, 1, 2, 0, 2, 3], this.uv = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }], this.vertices = [{ x: -0.5, y: -0.5 }, { x: 0.5, y: -0.5 }, { x: 0.5, y: 0.5 }, { x: -0.5, y: 0.5 }]);
  }
  guid;
  texture;
  triangles;
  uv;
  vertices;
  /** @internal */
  __cached_geometry;
  /**
   * The mesh that represents the sprite
   */
  get mesh() {
    return this._mesh || (this._mesh = new G(hr.getOrCreateGeometry(this), this.material)), this._mesh;
  }
  _mesh;
  /**
   * The material used to render the sprite
   */
  get material() {
    return this._material || (this.texture && Qv(this.texture), this._material = new we({
      map: this.texture,
      color: 16777215,
      side: xi,
      transparent: !0
    })), this._material;
  }
  _material;
  /**
   * The geometry of the sprite that can be used to create a mesh
   */
  getGeometry() {
    return hr.getOrCreateGeometry(this);
  }
};
gt([
  u()
], wo.prototype, "guid", 2);
gt([
  u(Te)
], wo.prototype, "texture", 2);
gt([
  lt()
], wo.prototype, "triangles", 2);
gt([
  lt()
], wo.prototype, "uv", 2);
gt([
  lt()
], wo.prototype, "vertices", 2);
const Hf = Symbol("spriteOwner");
class _c {
  sprites;
  constructor() {
    this.sprites = [];
  }
}
gt([
  u(wo)
], _c.prototype, "sprites", 2);
const Cg = class em {
  static create() {
    const e = new em();
    return e.spriteSheet = new _c(), e;
  }
  // we don't assign anything here because it's used by the serialization system.
  // there's currently a limitation in the serializer when e.g. spriteSheet is already assigned it will not be overriden by the serializer
  // hence the spriteSheet field is undefined by default
  constructor() {
  }
  clone() {
    const e = new em();
    return e.index = this.index, e.spriteSheet = this.spriteSheet, e;
  }
  /**
   * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link index}
   */
  set sprite(e) {
    e && (this.spriteSheet ? ((this.index === null || this.index === void 0) && (this.index = 0), this.spriteSheet.sprites[this.index] = e) : (this.spriteSheet = new _c(), this.spriteSheet.sprites = [e], this.index = 0));
  }
  /** The currently active sprite */
  get sprite() {
    if (this.spriteSheet)
      return this.spriteSheet.sprites[this.index];
  }
  spriteSheet;
  index = 0;
  update(e) {
    if (!this.spriteSheet) return;
    const t = this.index;
    if (t < 0 || t >= this.spriteSheet.sprites.length)
      return;
    const i = this.spriteSheet.sprites[t], n = i?.texture;
    if (n && (Qv(n), !i.__hasLoadedProgressive)) {
      i.__hasLoadedProgressive = !0;
      const o = n;
      We.assignTextureLOD(n, 0).then((r) => {
        r instanceof Te && (i.texture = r, e?.map === o && (e.map = r, e.needsUpdate = !0));
      });
    }
  }
};
gt([
  u(_c)
], Cg.prototype, "spriteSheet", 2);
gt([
  u()
], Cg.prototype, "index", 2);
let tc = Cg;
class Pi extends R {
  drawMode = 0;
  size = { x: 1, y: 1 };
  color;
  sharedMaterial;
  transparent = !0;
  cutoutThreshold = 0;
  castShadows = !1;
  renderOrder = 0;
  toneMapped = !0;
  /**
   * Assign a new texture to the currently active sprite
   */
  set texture(e) {
    if (!this._spriteSheet) return;
    const t = this._spriteSheet.spriteSheet?.sprites[this.spriteIndex];
    t && (t.texture = e, this.updateSprite());
  }
  /**
   * Add a new sprite to the currently assigned sprite sheet. The sprite will be added to the end of the sprite sheet.
   * Note that the sprite will not be rendered by default - set the `spriteIndex` to the index of the sprite to be rendered.
   * @param sprite The sprite to be added
   * @returns The index of the sprite in the sprite sheet
   * @example
   * ```typescript
   * const spriteRenderer = gameObject.addComponent(SpriteRenderer);
   * const index = spriteRenderer.addSprite(mySprite);
   * if(index >= 0)
   *   spriteRenderer.spriteIndex = index;
   * ```
   */
  addSprite(e, t = !1) {
    if (this._spriteSheet || (this._spriteSheet = tc.create()), !this._spriteSheet.spriteSheet) return -1;
    this._spriteSheet.spriteSheet?.sprites.push(e);
    const i = this._spriteSheet.spriteSheet?.sprites.length - 1;
    return t && (this.spriteIndex = i), i;
  }
  get sprite() {
    return this._spriteSheet;
  }
  /**
   * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link spriteIndex}
   */
  set sprite(e) {
    if (e !== this._spriteSheet)
      if (typeof e == "number") {
        const t = Math.round(e);
        ec && console.log("[SpriteSheet] Set index to " + t + " (was " + this.spriteIndex + ")", e), this.spriteIndex = t;
      } else e instanceof wo ? (this._spriteSheet || (this._spriteSheet = tc.create()), this._spriteSheet.sprite != e && (this._spriteSheet.sprite = e), this.updateSprite()) : e != this._spriteSheet && (this._spriteSheet = e, this.updateSprite());
  }
  /**
   * Set the index of the sprite to be rendered in the currently assigned sprite sheet
   */
  set spriteIndex(e) {
    this._spriteSheet && (this._spriteSheet.index = e, this.updateSprite());
  }
  get spriteIndex() {
    return this._spriteSheet?.index ?? 0;
  }
  /**
   * Get the number of sprites in the currently assigned sprite sheet
   */
  get spriteFrames() {
    return this._spriteSheet?.spriteSheet?.sprites.length ?? 0;
  }
  _spriteSheet;
  _currentSprite;
  /** @internal */
  awake() {
    this._currentSprite = void 0, this._spriteSheet ? this._spriteSheet = this._spriteSheet.clone() : this._spriteSheet = tc.create(), ec && console.log("Awake", this.name, this, this.sprite);
  }
  /** @internal */
  start() {
    this._currentSprite ? this.gameObject && this.gameObject.add(this._currentSprite) : this.updateSprite();
  }
  /**
   * Update the sprite. Modified properties will be applied to the sprite mesh. This method is called automatically when the sprite is changed.
   * @param force If true, the sprite will be forced to update.
   * @returns True if the sprite was updated successfully
   */
  updateSprite(e = !1) {
    if (!this.__didAwake && !e) return !1;
    const t = this._spriteSheet;
    if (!t?.spriteSheet?.sprites)
      return console.warn("SpriteRenderer has no data or spritesheet assigned..."), !1;
    const i = t.spriteSheet.sprites[this.spriteIndex];
    if (!i)
      return ec && console.warn("Sprite not found", this.spriteIndex, t.spriteSheet.sprites), !1;
    if (this._currentSprite)
      this._currentSprite.geometry = hr.getOrCreateGeometry(i), this._currentSprite.material.map = i.texture;
    else {
      const n = new we({ color: 16777215, side: xi });
      if (OR && (n.wireframe = !0), this.color && (n.color || (n.color = new se()), n.color.copy(this.color), n.opacity = this.color.alpha), n.transparent = !0, n.toneMapped = this.toneMapped, n.depthWrite = !1, i.texture && !n.wireframe) {
        let o = i.texture;
        o[Hf] !== void 0 && o[Hf] !== this && this.spriteFrames > 1 && (o = i.texture = o.clone()), o[Hf] = this, n.map = o;
      }
      this.sharedMaterial = n, this._currentSprite = new G(hr.getOrCreateGeometry(i), n), this._currentSprite.renderOrder = Math.round(this.renderOrder), We.assignTextureLOD(n, 0);
    }
    return this._currentSprite.parent !== this.gameObject && (this.drawMode === 2 && this._currentSprite.scale.set(this.size.x, this.size.y, 1), this.gameObject && this.gameObject.add(this._currentSprite)), this._currentSprite && this._currentSprite.layers.set(this.layer), this.sharedMaterial && (this.sharedMaterial.alphaTest = this.cutoutThreshold, this.sharedMaterial.transparent = this.transparent), this._currentSprite.castShadow = this.castShadows, t?.update(this.sharedMaterial), !0;
  }
}
gt([
  u()
], Pi.prototype, "drawMode", 2);
gt([
  u(kR)
], Pi.prototype, "size", 2);
gt([
  u(oe)
], Pi.prototype, "color", 2);
gt([
  u(_e)
], Pi.prototype, "sharedMaterial", 2);
gt([
  u()
], Pi.prototype, "transparent", 2);
gt([
  u()
], Pi.prototype, "cutoutThreshold", 2);
gt([
  u()
], Pi.prototype, "castShadows", 2);
gt([
  u()
], Pi.prototype, "renderOrder", 2);
gt([
  u()
], Pi.prototype, "toneMapped", 2);
gt([
  u(tc)
], Pi.prototype, "sprite", 1);
const X_ = w("debugwebxr"), MR = new ee().makeRotationY(Math.PI);
class Vi extends R {
  static _eventListeners = {};
  /**
   * Event that is called when the scene has been placed in AR.
   * @param cb the callback that is called when the scene has been placed
   * @returns a function to remove the event listener
   */
  static onPlaced(e) {
    const t = "placed";
    return this._eventListeners[t] || (this._eventListeners[t] = []), this._eventListeners[t].push(e), () => {
      const i = this._eventListeners[t].indexOf(e);
      i >= 0 && this._eventListeners[t].splice(i, 1);
    };
  }
  static _hasPlaced = !1;
  /**
   * @returns true if the scene has been placed in AR by the user or automatic placement
   */
  static get hasPlaced() {
    return this._hasPlaced;
  }
  /** The scale of the user in AR.  
   * **NOTE**: a large value makes the scene appear smaller  
   * @default 1
   */
  get arScale() {
    return this._arScale;
  }
  set arScale(e) {
    this._arScale = Math.max(1e-6, e), this.onSetScale();
  }
  _arScale = 1;
  /** When enabled the placed scene forward direction will towards the XRRig 
   * @deprecated
   * @default false
  */
  invertForward = !1;
  /** When assigned this asset will be loaded and visualize the placement while in AR
   * @default null
   */
  customReticle;
  /** Enable touch transform to translate, rotate and scale the scene in AR with multitouch
   * @default true
   */
  arTouchTransform = !0;
  /** When enabled the scene will be placed automatically when a point in the real world is found
   * @default false
   */
  autoPlace = !1;
  /** When enabled the scene center will be automatically calculated from the content in the scene */
  autoCenter = !1;
  /** Experimental: When enabled we will create a XR anchor for the scene placement    
   * and make sure the scene is at that anchored point during a XR session 
   * @default false
   **/
  useXRAnchor = !1;
  /** true if we're currently placing the scene */
  _isPlacing = !0;
  /** This is the world matrix of the ar session root when entering webxr
   * it is applied when the scene has been placed (e.g. if the session root is x:10, z:10 we want this position to be the center of the scene)
   */
  _startOffset = new ee();
  _createdPlacementObject = null;
  _reparentedComponents = [];
  // move objects into a temporary scene while placing (which is not rendered) so that the components won't be disabled during this process
  // e.g. we want the avatar to still be updated while placing
  // another possibly solution would be to ensure from this component that the Rig is *also* not disabled while placing
  _placementScene = new wi();
  /** the reticles used for placement */
  _reticle = [];
  /** needs to be in sync with the reticles */
  _hits = [];
  _placementStartTime = -1;
  _rigPlacementMatrix;
  /** if useAnchor is enabled this is the anchor we have created on placing the scene using the placement hit */
  _anchor = null;
  /** user input is used for ar touch transform */
  userInput;
  onEnable() {
    this.customReticle?.preload();
  }
  supportsXR(e) {
    return e === "immersive-ar";
  }
  onEnterXR(e) {
    X_ && console.log("ENTER WEBXR: SessionRoot start..."), this._anchor = null, Vi._hasPlaced = !1, this.gameObject.updateMatrixWorld(), this._startOffset.copy(this.gameObject.matrixWorld);
    const t = new M();
    this._createdPlacementObject = t, t.name = "AR Session Root", this._placementScene.name = "AR Placement Scene", this._placementScene.children.length = 0;
    for (let i = this.context.scene.children.length - 1; i >= 0; i--) {
      const n = this.context.scene.children[i];
      this._placementScene.add(n);
    }
    if (this.context.scene.add(t), this.autoCenter) {
      const i = ii(this._placementScene.children), n = i.getCenter(new y()), o = i.getSize(new y()), r = new ee();
      r.makeTranslation(n.x, n.y - o.y * 0.5, n.z), this._startOffset.multiply(r);
    }
    this._reparentedComponents.length = 0, this._reparentedComponents.push({ comp: this, originalObject: this.gameObject }), S.addComponent(t, this);
    for (const i of this._reticle)
      Gi(i);
    this._reticle.length = 0, this._isPlacing = !0, this.context.input.addEventListener("pointerup", this.onPlaceScene, { queue: fi.Early });
  }
  onLeaveXR() {
    this.context.input.removeEventListener("pointerup", this.onPlaceScene, { queue: fi.Early }), this.onRevertSceneChanges(), this._anchor = null, Vi._hasPlaced = !1, this._rigPlacementMatrix = void 0;
  }
  onUpdateXR(e) {
    if (e.xr.isTrackingImages) {
      for (const t of this._reticle)
        t.visible = !1;
      return;
    }
    if (this._isPlacing) {
      const t = e.xr.rig?.gameObject;
      t && t.parent !== this.context.scene && this.context.scene.add(t);
      let i = !1;
      if (e.xr.isPassThrough && e.xr.controllers.length > 0 && !this.autoPlace)
        for (const n of e.xr.controllers) {
          const o = n.getHitTest();
          o && (i = !0, this.updateReticleAndHits(e.xr, n.index, o, e.xr.rigScale));
        }
      if (!i) {
        const n = e.xr.getHitTest();
        n && this.updateReticleAndHits(e.xr, 0, n, e.xr.rigScale);
      }
    } else {
      if (this._anchor && e.xr.referenceSpace) {
        const t = e.xr.frame.getPose(this._anchor.anchorSpace, e.xr.referenceSpace);
        if (t && this.context.time.frame % 20 === 0) {
          const i = e.xr.convertSpace(t.transform), n = this._reticle[0];
          n && (n.position.copy(i.position), n.quaternion.copy(i.quaternion), this.onApplyPose(n));
        }
      }
      if (this.arTouchTransform ? (this.userInput || (this.userInput = new Rd(this.context)), this.userInput?.enable()) : this.userInput?.disable(), this.arTouchTransform && this.userInput?.hasChanged) {
        if (e.xr.rig) {
          const t = e.xr.rig.gameObject;
          this.userInput.applyMatrixTo(t.matrix, !0), t.matrix.decompose(t.position, t.quaternion, t.scale), this.userInput.factor = t.scale.x;
        }
        this.userInput.reset();
      }
    }
  }
  updateReticleAndHits(e, t, i, n) {
    this._hits[t] = i.hit;
    let o = this._reticle[t];
    if (!o) {
      if (this.customReticle)
        if (this.customReticle.asset)
          o = ka(this.customReticle.asset);
        else {
          this.customReticle.loadAssetAsync();
          return;
        }
      else
        o = new G(
          new nS(0.07, 0.09, 32).rotateX(-Math.PI / 2),
          new we({ side: xi, depthTest: !1, depthWrite: !1, transparent: !0, opacity: 1, color: 15658734 })
        ), o.name = "AR Placement Reticle";
      if (X_) {
        const r = new vi(1);
        r.position.y += 0.01, o.add(r);
      }
      this._reticle[t] = o, o.matrixAutoUpdate = !1, o.visible = !1;
    }
    if (o.lastPos = o.lastPos || i.position.clone(), o.lastQuat = o.lastQuat || i.quaternion.clone(), o.position.copy(o.lastPos.lerp(i.position, this.context.time.deltaTime / 0.1)), o.lastPos.copy(o.position), o.quaternion.copy(o.lastQuat.slerp(i.quaternion, this.context.time.deltaTime / 0.05)), o.lastQuat.copy(o.quaternion), o.scale.set(n, n, n), this.customReticle && this.applyViewBasedTransform(o), o.updateMatrix(), o.visible = !0, o.parent !== this.context.scene && this.context.scene.add(o), this._placementStartTime < 0 && (this._placementStartTime = this.context.time.realtimeSinceStartup), this.autoPlace)
      if (this.upVec.set(0, 1, 0).applyQuaternion(o.quaternion), this.upVec.dot(H(0, 1, 0)) > 0.9) {
        let a = o["autoplace:timer"] || 0;
        a >= 1 ? (o.visible = !1, this.onPlaceScene(null)) : (a += this.context.time.deltaTime, o["autoplace:timer"] = a);
      } else
        o["autoplace:timer"] = 0;
  }
  onPlaceScene = (e) => {
    if (this._isPlacing == !1 || e?.used) return;
    let t = this._reticle[0];
    if (!t) {
      console.warn("No reticle to place...");
      return;
    }
    if (!t.visible && !this.autoPlace) {
      console.warn("Reticle is not visible (can not place)");
      return;
    }
    if (K.active?.isTrackingImages) {
      console.warn("Scene Placement is disabled while images are being tracked");
      return;
    }
    let i = this._hits[0];
    if (e && e.origin instanceof m0) {
      const n = this._reticle[e.origin.index];
      n && (t = n, i = this._hits[e.origin.index]);
    }
    if (e && (e.stopImmediatePropagation(), e.stopPropagation(), e.use()), this._isPlacing = !1, this.context.input.removeEventListener("pointerup", this.onPlaceScene), this.onRevertSceneChanges(), t.position.copy(t.lastPos), t.quaternion.copy(t.lastQuat), this.onApplyPose(t), Vi._hasPlaced = !0, this.useXRAnchor && this.onCreateAnchor(K.active, i), this.context.xr)
      for (const n of this.context.xr.controllers)
        n.cancelHitTestSource();
  };
  onSetScale() {
    if (!Vi._hasPlaced) return;
    const e = K.active?.rig?.gameObject;
    if (e) {
      const t = K.active?.rigScale || 1, i = 1 / this._arScale * t, n = new ee().makeScale(i, i, i).invert();
      e.matrix.premultiply(n), e.matrix.decompose(e.position, e.quaternion, e.scale);
    }
  }
  onRevertSceneChanges() {
    for (const e of this._reticle)
      e && (e.visible = !1, e?.removeFromParent());
    this._reticle.length = 0;
    for (let e = this._placementScene.children.length - 1; e >= 0; e--) {
      const t = this._placementScene.children[e];
      this.context.scene.add(t);
    }
    this._createdPlacementObject?.removeFromParent();
    for (const e of this._reparentedComponents)
      S.addComponent(e.originalObject, e.comp);
  }
  async onCreateAnchor(e, t) {
    if (t.createAnchor === void 0) {
      console.warn("Hit does not support creating an anchor", t), L() && ge("Hit does not support creating an anchor");
      return;
    } else {
      const i = await t.createAnchor(e.viewerPose.transform);
      e.running && i && (this._anchor = i);
    }
  }
  upVec = new y(0, 1, 0);
  lookPoint = new y();
  worldUpVec = new y(0, 1, 0);
  applyViewBasedTransform(e) {
    const t = this.context.mainCamera, i = e, n = t.worldPosition, o = i.worldPosition;
    this.upVec.set(0, 1, 0).applyQuaternion(e.quaternion);
    const r = t.worldPosition;
    r && e.position.clone().sub(r).angleTo(this.upVec) < Math.PI / 2 && this.upVec.negate();
    const a = this.upVec.angleTo(this.worldUpVec) * 180 / Math.PI, l = 30;
    a > l && a < 180 - l || a < -l && a > -180 + l ? (this.lookPoint.copy(e.position).add(this.upVec), this.lookPoint.y = e.position.y, e.lookAt(this.lookPoint)) : (n.y = o.y, e.lookAt(n));
  }
  onApplyPose(e) {
    const t = K.active?.rig?.gameObject;
    if (!t) {
      console.warn("No rig object to place");
      return;
    }
    const i = t.parent || this.context.scene;
    this._rigPlacementMatrix ? this._rigPlacementMatrix?.decompose(t.position, t.quaternion, t.scale) : this._rigPlacementMatrix = t.matrix.clone(), this.applyViewBasedTransform(e), e.updateMatrix(), this.context.scene.add(e), e.attach(t), e.removeFromParent(), t.scale.set(this.arScale, this.arScale, this.arScale), t.position.multiplyScalar(this.arScale), t.updateMatrix(), this.invertForward && t.matrix.premultiply(MR), t.matrix.premultiply(this._startOffset), t.matrix.decompose(t.position, t.quaternion, t.scale), i.add(t);
  }
}
class Rd {
  static up = new y(0, 1, 0);
  static zero = new y(0, 0, 0);
  static one = new y(1, 1, 1);
  oneFingerDrag = !0;
  twoFingerRotate = !0;
  twoFingerScale = !0;
  factor = 1;
  context;
  offset;
  plane;
  _scale = 1;
  _hasChanged = !1;
  get scale() {
    return this._scale;
  }
  // readonly translate: Vector3 = new Vector3();
  // readonly rotation: Quaternion = new Quaternion();
  // readonly scale: Vector3 = new Vector3(1, 1, 1);
  constructor(e) {
    this.context = e, this.offset = new ee(), this.plane = new rr(), this.plane.setFromNormalAndCoplanarPoint(Rd.up, Rd.zero);
  }
  _enabled = !1;
  reset() {
    this._scale = 1, this.offset.identity(), this._hasChanged = !0;
  }
  get hasChanged() {
    return this._hasChanged;
  }
  /**
   * Applies the matrix to the offset matrix
   * @param matrix the matrix to apply the drag offset to
   * @param invert if true the offset matrix will be inverted before applying it to the matrix and premultiplied 
   */
  applyMatrixTo(e, t) {
    this._hasChanged = !1, t ? (this.offset.invert(), e.premultiply(this.offset)) : e.multiply(this.offset);
  }
  currentlyUsedPointerIds = /* @__PURE__ */ new Set();
  currentlyUnusedPointerIds = /* @__PURE__ */ new Set();
  get isActive() {
    return this.currentlyUsedPointerIds.size <= 0 && this.currentlyUnusedPointerIds.size > 0;
  }
  enable() {
    this._enabled || (this._enabled = !0, this.context.input.addEventListener("pointerdown", this.onPointerDownEarly, { queue: fi.Early }), this.context.input.addEventListener("pointerdown", this.onPointerDownLate, { queue: fi.Late }), this.context.input.addEventListener("pointerup", this.onPointerUpEarly, { queue: fi.Early }), window.addEventListener("touchstart", this.touchStart, { passive: !1 }), window.addEventListener("touchmove", this.touchMove, { passive: !1 }), window.addEventListener("touchend", this.touchEnd, { passive: !1 }));
  }
  disable() {
    this._enabled && (this._enabled = !1, this.context.input.removeEventListener("pointerdown", this.onPointerDownEarly, { queue: fi.Early }), this.context.input.removeEventListener("pointerdown", this.onPointerDownLate, { queue: fi.Late }), this.context.input.removeEventListener("pointerup", this.onPointerUpEarly, { queue: fi.Early }), window.removeEventListener("touchstart", this.touchStart), window.removeEventListener("touchmove", this.touchMove), window.removeEventListener("touchend", this.touchEnd));
  }
  onPointerDownEarly = (e) => {
    this.isActive && e.stopPropagation();
  };
  onPointerDownLate = (e) => {
    e.used ? this.currentlyUsedPointerIds.add(e.pointerId) : this.currentlyUsedPointerIds.size <= 0 && this.currentlyUnusedPointerIds.add(e.pointerId);
  };
  onPointerUpEarly = (e) => {
    this.currentlyUsedPointerIds.delete(e.pointerId), this.currentlyUnusedPointerIds.delete(e.pointerId);
  };
  // private _needsUpdate: boolean = true;
  // private _rotationMatrix: Matrix4 = new Matrix4();
  // private updateMatrix() {
  //     this._needsUpdate = false;
  //     this._rotationMatrix.makeRotationFromQuaternion(this.rotation);
  //     this.offset.compose(this.translate, new Quaternion(), this.scale);
  //     // const rot = this._tempMatrix.makeRotationY(this.angle);
  //     // this.translate.applyMatrix4(rot);
  //     // this.offset.elements[12] = this.translate.x;
  //     // this.offset.elements[13] = this.translate.y;
  //     // this.offset.elements[14] = this.translate.z;
  //     // this.offset.premultiply(rot);
  //     // const s = this.scale;
  //     // this.offset.premultiply(this._tempMatrix.makeScale(s, s, s));
  // }
  prev = /* @__PURE__ */ new Map();
  _didMultitouch = !1;
  touchStart = (e) => {
    if (!e.defaultPrevented)
      for (let t = 0; t < e.changedTouches.length; t++) {
        const i = e.changedTouches[t], n = q.isAndroidDevice() && i.clientY < window.innerHeight * 0.1;
        this.prev.has(i.identifier) || this.prev.set(i.identifier, {
          ignore: n,
          x: 0,
          z: 0,
          screenx: 0,
          screeny: 0
        });
        const o = this.prev.get(i.identifier);
        if (o) {
          const r = this.getPositionOnPlane(i.clientX, i.clientY);
          o.x = r.x, o.z = r.z, o.screenx = i.clientX, o.screeny = i.clientY;
        }
      }
  };
  touchEnd = (e) => {
    e.touches.length <= 0 && (this._didMultitouch = !1);
    for (let t = 0; t < e.changedTouches.length; t++) {
      const i = e.changedTouches[t];
      this.prev.delete(i.identifier);
    }
  };
  touchMove = (e) => {
    if (!e.defaultPrevented && this.isActive) {
      if (e.touches.length === 1) {
        if (this._didMultitouch)
          return;
        const t = e.touches[0], i = this.prev.get(t.identifier);
        if (!i || i.ignore) return;
        const n = this.getPositionOnPlane(t.clientX, t.clientY), o = n.x - i.x, r = n.z - i.z;
        if (o === 0 && r === 0) return;
        this.oneFingerDrag && this.addMovement(o, r), i.x = n.x, i.z = n.z, i.screenx = t.clientX, i.screeny = t.clientY;
        return;
      } else if (e.touches.length === 2) {
        this._didMultitouch = !0;
        const t = e.touches[0], i = e.touches[1], n = this.prev.get(t.identifier), o = this.prev.get(i.identifier);
        if (!n || !o) return;
        if (this.twoFingerRotate) {
          const r = Math.atan2(t.clientY - i.clientY, t.clientX - i.clientX), a = Math.atan2(n.screeny - o.screeny, n.screenx - o.screenx), l = r - a;
          Math.abs(l) > 1e-3 && this.addRotation(l);
        }
        if (this.twoFingerScale) {
          const r = t.clientX - i.clientX, a = t.clientY - i.clientY, l = Math.sqrt(r * r + a * a), c = n.screenx - o.screenx, h = n.screeny - o.screeny, d = Math.sqrt(c * c + h * h), f = l - d;
          Math.abs(f) > 2 && this.addScale(f);
        }
        n.screenx = t.clientX, n.screeny = t.clientY, o.screenx = i.clientX, o.screeny = i.clientY;
      }
    }
  };
  _raycaster = new Nd();
  _intersection = new y();
  _screenPos = new y();
  getPositionOnPlane(e, t) {
    const i = this.context.mainCamera;
    return this._screenPos.x = e / window.innerWidth * 2 - 1, this._screenPos.y = -(t / window.innerHeight) * 2 + 1, this._screenPos.z = 1, this._screenPos.unproject(i), this._raycaster.set(i.position, this._screenPos.sub(i.position)), this._raycaster.ray.intersectPlane(this.plane, this._intersection), this._intersection;
  }
  addMovement(e, t) {
    e /= this._scale, t /= this._scale, e *= this.factor, t *= this.factor, this.offset.elements[12] += e, this.offset.elements[14] += t, (e !== 0 || t !== 0) && (this._hasChanged = !0);
  }
  _tempMatrix = new ee();
  addScale(e) {
    e /= window.innerWidth, e *= -1, this._scale *= 1 + e, this._tempMatrix.makeScale(1 - e, 1 - e, 1 - e), this.offset.premultiply(this._tempMatrix), e !== 0 && (this._hasChanged = !0);
  }
  addRotation(e) {
    e *= -1, this._tempMatrix.makeRotationY(e), this.offset.premultiply(this._tempMatrix), e !== 0 && (this._hasChanged = !0);
  }
}
const Js = w("debugautosync"), Gf = Symbol("syncerId");
class RR {
  _syncers = {};
  getOrCreateSyncer(e) {
    if (!e.guid) return null;
    if (this._syncers[e.guid]) return this._syncers[e.guid];
    const t = new TR(e);
    return t[Gf] = e.guid, this._syncers[t[Gf]] = t, t;
  }
  removeSyncer(e) {
    delete this._syncers[e[Gf]];
  }
}
const Pg = new RR();
class TR {
  comp;
  constructor(e) {
    this.comp = e;
  }
  // private getters: { [key: string]: Function } = {};
  hasChanges = !1;
  changedProperties = {};
  get networkingKey() {
    return this.comp.guid;
  }
  /** is set to true in on receive call to avoid circular sending */
  _isReceiving = !1;
  _isInit = !1;
  init(e) {
    if (this._isInit) return;
    this._isInit = !0, this.comp = e, this.comp.context.post_render_callbacks.push(this.onHandleSending), this.comp.context.connection.beginListen(this.networkingKey, this.onHandleReceiving);
    const t = this.comp.context.connection.tryGetState(this.comp.guid);
    t && this.onHandleReceiving(t);
  }
  destroy() {
    this._isInit && (this.comp.context.post_render_callbacks.splice(this.comp.context.post_render_callbacks.indexOf(this.onHandleSending), 1), this.comp.context.connection.stopListen(this.networkingKey, this.onHandleReceiving), this.comp = null, this._isInit = !1);
  }
  notifyChanged(e, t) {
    this._isReceiving || (Js && console.log("Property changed: " + e, t), this.hasChanges = !0, this.changedProperties[e] = t);
  }
  onHandleSending = () => {
    if (!this.hasChanges) return;
    this.hasChanges = !1;
    const e = this.comp.context.connection;
    if (!e || !e.isConnected || !e.isInRoom) {
      for (const t in this.changedProperties)
        delete this.changedProperties[t];
      return;
    }
    for (const t in this.changedProperties) {
      const i = this.changedProperties[t];
      Js && console.log("SEND", this.comp.guid, this.networkingKey), e.send(this.networkingKey, { guid: this.comp.guid, property: t, data: i }, wn.Queued), delete this.changedProperties[t];
    }
  };
  onHandleReceiving = (e) => {
    if (Js && console.log("SYNCFIELD RECEIVE", this.comp.name, this.comp.guid, e), !!this._isInit && this.comp && e.guid === this.comp.guid)
      try {
        this._isReceiving = !0, this.comp[e.property] = e.data;
      } catch (t) {
        console.error(t);
      } finally {
        this._isReceiving = !1;
      }
  };
}
function ER(s, e) {
  let t = e !== s;
  return !t && s && e && (Array.isArray(s) && Array.isArray(e) || typeof s == "object" && typeof e == "object") && (t = !0), t;
}
const ic = Symbol("AutoSyncHandler");
function AR(s) {
  if (s[ic])
    return s[ic];
  const e = Pg.getOrCreateSyncer(s);
  return e?.init(s), s[ic] = e, e;
}
function IR(s) {
  const e = s[ic];
  e && (Pg.removeSyncer(e), e.destroy(), delete s[ic]);
}
const Yv = function(s = null) {
  return function(e, t) {
    let i = "";
    typeof t == "string" ? i = t : i = t.name;
    let n = null, o;
    typeof s == "string" ? o = e[s] : typeof s == "function" && (o = s), o == null && (L() || Js) && s != null && console.warn('syncField: no callback function found for property "' + i + '"', '"' + s + '"');
    const r = e, a = r.__internalAwake;
    if (typeof a != "function") {
      (Js || L()) && console.error('@syncField can currently only used on Needle Engine Components, custom object of type "' + e?.constructor?.name + '" is not supported', e);
      return;
    }
    Js && console.log(i);
    const l = Symbol(i);
    r.__internalAwake = function() {
      if (this[l] !== void 0)
        return;
      if (this[l] = this[i], n = Pg.getOrCreateSyncer(this), Object.getOwnPropertyDescriptor(this, i)?.set === void 0) {
        let d = !1;
        Object.defineProperty(this, i, {
          set: function(f) {
            const p = this[l];
            if (this[l] = f, d) {
              (L() || Js) && console.warn("Recursive call detected", i);
              return;
            }
            d = !0;
            try {
              const g = ER(f, p);
              Js && console.log("SyncField assignment", i, "changed?", g, f, o), g && o?.call(this, f, p) !== !1 && AR(this)?.notifyChanged(i, f);
            } finally {
              d = !1;
            }
          },
          get: function() {
            return this[l];
          },
          configurable: !0,
          enumerable: !0
        });
      }
      n?.init(this), a.call(this);
    };
    const c = r.__internalDestroy;
    r.__internalDestroy = function() {
      IR(this), c.call(this);
    };
  };
};
var LR = Object.defineProperty, xu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && LR(e, t, n), n;
};
const Wt = w("debugplayersync"), Su = class Kv extends R {
  /**
   * This API is experimental and may change or be removed in the future.
   * Creates a PlayerSync instance at runtime from a given URL and sets it up for networking
   * @param url Path to the asset that should be instantiated for each player
   * @param init Optional initialization parameters for the PlayerSync component
   * @returns Promise resolving to a PlayerSync instance with a guaranteed asset property
   * @example
   * ```typescript
   * const res = await PlayerSync.setupFrom("/assets/demo.glb");
   * addComponent(res.asset?.asset, DragControls);
   * addComponent(res.asset?.asset, SyncedTransform);
   * scene.add(res.gameObject);
   * ```
   */
  static async setupFrom(e, t) {
    const i = ie.getOrCreateFromUrl(e);
    if (!i.asset) {
      const r = await i.loadAssetAsync();
      r && S.getOrAddComponent(r, Rn);
    }
    const n = new Kv();
    n._internalInit(t), n.asset = i;
    const o = new M();
    return o.guid = e, S.addComponent(o, n), n;
  }
  autoSync = !0;
  asset;
  onPlayerSpawned;
  _localInstance;
  awake() {
    this.watchTabVisible(), this.onPlayerSpawned || (this.onPlayerSpawned = new ce());
  }
  onEnable() {
    this.context.connection.beginListen(te.RoomStateSent, this.onJoinedRoom), this.context.connection.beginListen(te.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(te.LeftRoom, this.destroyInstance), this.context.connection.isInRoom && this.onJoinedRoom();
  }
  onDisable() {
    this.context.connection.stopListen(te.RoomStateSent, this.onJoinedRoom), this.context.connection.stopListen(te.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(te.LeftRoom, this.destroyInstance);
  }
  onJoinedRoom = () => {
    Wt && console.log("PlayerSync.joinedRoom. autoSync is set to " + this.autoSync), this.autoSync && this.getInstance();
  };
  /**
   * Gets or creates an instance of the assigned asset for the local player
   * @returns Promise resolving to the instantiated player object or null if creation failed
   */
  async getInstance() {
    if (this._localInstance) return this._localInstance;
    if (Wt && console.log("PlayerSync.createInstance", this.asset?.url), !this.asset?.asset && !this.asset?.url)
      return console.error('PlayerSync: can not create an instance because "asset" is not set and or has no URL!'), null;
    this.gameObject.guid || console.warn("PlayerSync: gameObject has no guid! This might cause issues with syncing the player state."), this._localInstance = this.asset?.instantiateSynced({ parent: this.gameObject, deleteOnDisconnect: !0 }, !0);
    const e = await this._localInstance;
    if (e) {
      const t = S.getComponentsInChildren(e, Rn);
      if (Wt && console.log(`PlayerSync.createInstance: found ${t?.length} PlayerState components. Owner: ${this.context.connection.connectionId}`), t?.length) {
        for (const i of t)
          i.owner = this.context.connection.connectionId;
        this.onPlayerSpawned?.invoke(e);
      } else
        this._localInstance = void 0, console.error("<strong>Failed finding PlayerState on " + this.asset?.url + "</strong>: please make sure the asset has a PlayerState component!"), S.destroySynced(e);
    } else
      this._localInstance = void 0, console.warn("PlayerSync: failed instantiating asset!");
    return this._localInstance;
  }
  /**
   * Destroys the current player instance and cleans up networking state
   */
  destroyInstance = () => {
    this._localInstance?.then((e) => {
      Wt && console.log("PlayerSync.destroyInstance", e), eu(e, this.context.connection, !0, { saveInRoom: !1 });
    }), this._localInstance = void 0;
  };
  /**
   * Sets up visibility change listeners to handle player cleanup when browser tab visibility changes
   */
  watchTabVisible() {
    window.addEventListener("visibilitychange", (e) => {
      if (document.visibilityState === "visible")
        for (let t = Rn.all.length - 1; t >= 0; t--) {
          const i = Rn.all[t];
          (!i.owner || !this.context.connection.userIsInRoom(i.owner)) && i.doDestroy();
        }
    });
  }
};
xu([
  u()
], Su.prototype, "autoSync");
xu([
  u(ie)
], Su.prototype, "asset");
xu([
  u(ce)
], Su.prototype, "onPlayerSpawned");
let Zv = Su;
var DR = /* @__PURE__ */ ((s) => (s.OwnerChanged = "ownerChanged", s))(DR || {});
const tm = class St extends R {
  static _all = [];
  /** All PlayerState instances for all players in the scene */
  static get all() {
    return St._all;
  }
  static _local = [];
  /** All PlayerState instances that belong to the local player */
  static get local() {
    return St._local;
  }
  /**
   * Gets the PlayerState component for a given object or component
   * @param obj Object3D or Component to find the PlayerState for
   * @returns The PlayerState component if found, undefined otherwise
   */
  static getFor(e) {
    if (e instanceof M)
      return S.getComponentInParent(e, St);
    if (e instanceof R)
      return S.getComponentInParent(e.gameObject, St);
  }
  /**
   * Checks if a given object or component belongs to the local player
   * @param obj Object3D or Component to check
   * @returns True if the object belongs to the local player, false otherwise
   */
  static isLocalPlayer(e) {
    return St.getFor(e)?.isLocalPlayer ?? !1;
  }
  static _callbacks = {};
  /**
   * Registers a callback for a specific PlayerState event
   * @param event The event to listen for
   * @param cb Callback function that will be invoked when the event occurs
   * @returns The provided callback function for chaining
   */
  static addEventListener(e, t) {
    return this._callbacks[e] || (this._callbacks[e] = []), this._callbacks[e].push(t), t;
  }
  /**
   * Removes a previously registered event callback
   * @param event The event type to remove the callback from
   * @param cb The callback function to remove
   */
  static removeEventListener(e, t) {
    if (!this._callbacks[e]) return;
    const i = this._callbacks[e].indexOf(t);
    i >= 0 && this._callbacks[e].splice(i, 1);
  }
  static dispatchEvent(e, t) {
    if (this._callbacks[e])
      for (const i of this._callbacks[e])
        i(t);
  }
  /** Event triggered when the owner of this PlayerState changes */
  onOwnerChangeEvent = new ce();
  /** Event triggered the first time an owner is assigned to this PlayerState */
  onFirstOwnerChangeEvent = new ce();
  /** Indicates if this PlayerState has an owner assigned */
  hasOwner = !1;
  owner;
  /** 
   * When enabled, PlayerState will not destroy itself when the owner is not connected anymore 
   */
  dontDestroy = !1;
  /**
   * Indicates if this PlayerState belongs to the local player
   */
  get isLocalPlayer() {
    return this.owner === this.context.connection.connectionId;
  }
  /**
   * Handles owner change events and updates relevant state
   * @param newOwner The new owner's connection ID
   * @param oldOwner The previous owner's connection ID
   */
  onOwnerChange(e, t) {
    Wt && console.log(`PlayerSync.onOwnerChange: ${t} → ${e} (me: ${this.context.connection.connectionId})`);
    const i = St._local.indexOf(this);
    i >= 0 && St._local.splice(i, 1);
    const n = {
      playerState: this,
      oldValue: t,
      newValue: e
    };
    if (this.hasOwner || (this.hasOwner = !0, this.onFirstOwnerChangeEvent?.invoke(n)), this.onOwnerChangeEvent?.invoke(n), this.owner === this.context.connection.connectionId) {
      St._local.push(this);
      const r = new CustomEvent("local-owner-changed", { detail: n });
      this.dispatchEvent(r);
    }
    const o = new CustomEvent("owner-changed", { detail: n });
    this.dispatchEvent(o), St.dispatchEvent("ownerChanged", o);
  }
  /** @internal */
  awake() {
    St.all.push(this), Wt && console.log("Registered new PlayerState", this.guid, St.all.length - 1, St.all), this.context.connection.beginListen(te.UserLeftRoom, this.onUserLeftRoom);
  }
  /** @internal */
  async start() {
    Wt && console.log("PLAYERSTATE.START, owner: " + this.owner, this.context.connection.usersInRoom([])), this.owner ? (this.context.connection.isInRoom || await Os(300), this.context.connection.userIsInRoom(this.owner) == !1 && (Wt && console.log(`PlayerSync.start → doDestroy "${this.name}" because user "${this.owner}" is not in room anymore...`, "Currently in room:", ...this.context.connection.usersInRoom()), this.doDestroy())) : this.owner || (Wt && console.warn("PlayerState.start → owner is undefined!", this.name), setTimeout(() => {
      !this.destroyed && !this.owner ? this.dontDestroy ? Wt && console.warn("PlayerState.start → owner is still undefined but dontDestroy is set to true", this.name) : (Wt && console.warn(`PlayerState.start → owner is still undefined: destroying "${this.name}" instance now`), this.doDestroy()) : Wt && console.log("PlayerState.start → owner is assigned", this.owner);
    }, 2e3));
  }
  /** Tells the server that this client has been destroyed, and the networking message for the instantiate will be removed      */
  doDestroy() {
    Wt && console.log("PlayerSync.doDestroy → syncDestroy", this.name), eu(this.gameObject, this.context.connection, !0, { saveInRoom: !1 });
  }
  /** @internal */
  onDestroy() {
    if (Wt && console.warn("PlayerState.onDestroy", this.owner), this.context.connection.stopListen(te.UserLeftRoom, this.onUserLeftRoom), St.all.splice(St.all.indexOf(this), 1), this.isLocalPlayer) {
      const e = St._local.indexOf(this);
      e >= 0 && St._local.splice(e, 1);
    }
  }
  /**
   * Handler for when a user leaves the networked room
   * @param model Object containing the ID of the user who left
   */
  onUserLeftRoom = (e) => {
    if (e.userId === this.owner) {
      Wt && console.log("PLAYERSYNC LEFT", this.owner), this.doDestroy();
      return;
    }
  };
};
xu([
  Yv(tm.prototype.onOwnerChange)
], tm.prototype, "owner");
let Rn = tm;
var jR = Object.defineProperty, Wa = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && jR(e, t, n), n;
};
class As extends R {
  position = "bottom";
  showNeedleLogo = !1;
  showSpatialMenu;
  createFullscreenButton;
  createMuteButton;
  createQRCodeButton;
  /** 
   * Applies the configured menu options when the component is enabled
   * @hidden
   */
  onEnable() {
    this.applyOptions();
  }
  /** 
   * Applies all configured options to the active {@link Context.menu}.
   */
  applyOptions() {
    this.context.menu.setPosition(this.position), this.context.menu.showNeedleLogo(this.showNeedleLogo), this.createFullscreenButton === !0 && this.context.menu.showFullscreenOption(!0), this.createMuteButton === !0 && this.context.menu.showAudioPlaybackOption(!0), this.showSpatialMenu === !0 && this.context.menu.showSpatialMenu(this.showSpatialMenu), this.createQRCodeButton === !0 && (q.isMobileDevice() || this.context.menu.showQRCodeButton(!0));
  }
}
Wa([
  u()
], As.prototype, "position");
Wa([
  u()
], As.prototype, "showNeedleLogo");
Wa([
  u()
], As.prototype, "showSpatialMenu");
Wa([
  u()
], As.prototype, "createFullscreenButton");
Wa([
  u()
], As.prototype, "createMuteButton");
Wa([
  u()
], As.prototype, "createQRCodeButton");
var BR = Object.defineProperty, Og = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && BR(e, t, n), n;
};
const gl = w("debugwebxr"), Q_ = new U().setFromAxisAngle(new y(0, 1, 0), Math.PI);
class dr extends R {
  head;
  leftHand;
  rightHand;
  _leftHandMeshes;
  _rightHandMeshes;
  _syncTransforms;
  async onEnterXR(e) {
    if (!this.activeAndEnabled) return;
    gl && console.warn("AVATAR ENTER XR", this.guid, this.sourceId, this, this.activeAndEnabled), this._syncTransforms && (this._syncTransforms.length = 0), await this.prepareAvatar();
    const t = Rn.getFor(this);
    if (t?.owner) {
      const i = this.gameObject.addComponent(je);
      i.avatar = this.gameObject, i.connectionId = t.owner;
    } else this.context.connection.isConnected ? console.error("No player state found for avatar", this) : t && !this.context.connection.isConnected && (t.dontDestroy = !0);
  }
  onLeaveXR(e) {
    const t = this.gameObject.getComponent(je);
    t && t.destroy();
  }
  onUpdateXR(e) {
    if (!this.activeAndEnabled) return;
    const t = Rn.isLocalPlayer(this);
    if (!t) return;
    const i = e.xr;
    if (i.rig && i.rig.gameObject !== this.gameObject.parent && (this.gameObject.position.set(0, 0, 0), this.gameObject.rotation.set(0, 0, 0), this.gameObject.scale.set(1, 1, 1), i.rig.gameObject.add(this.gameObject)), this._syncTransforms && t)
      for (const l of this._syncTransforms)
        l.fastMode = !0, l.isOwned() || l.requestOwnership();
    if (this.head && this.context.mainCamera) {
      const l = this.head.asset;
      if (l.position.copy(this.context.mainCamera.position), l.position.x *= -1, l.position.z *= -1, l.quaternion.copy(this.context.mainCamera.quaternion), l.quaternion.x *= -1, this.context.time.frameCount % 10 === 0 && this.head.asset) {
        const c = S.getComponentsInChildren(this.head.asset, rn);
        for (const h of c)
          h.enabled = !1, h.gameObject.visible = !1;
      }
    }
    const n = e.xr.leftController, o = this.leftHand?.asset;
    n && o ? (o.position.copy(n.gripPosition), o.quaternion.copy(n.gripQuaternion), o.quaternion.multiply(Q_), o.visible = n.isTracking, this.updateHandVisibility(n, o, this._leftHandMeshes)) : o && o.visible && (o.visible = !1);
    const r = e.xr.rightController, a = this.rightHand?.asset;
    r && a ? (a.position.copy(r.gripPosition), a.quaternion.copy(r.gripQuaternion), a.quaternion.multiply(Q_), a.visible = r.isTracking, this.updateHandVisibility(r, a, this._rightHandMeshes)) : a && a.visible && (a.visible = !1);
  }
  onBeforeRender() {
    this.context.xr && this.context.time.frame % 10 === 0 && this.updateRemoteAvatarVisibility();
  }
  updateHandVisibility(e, t, i) {
    if (i) {
      const n = e.model && e.model.visible && e.model !== t;
      i.forEach((o) => {
        ds(o, !n);
      });
    }
  }
  updateRemoteAvatarVisibility() {
    if (this.context.connection.isConnected) {
      const e = Rn.getFor(this);
      if (e && e.isLocalPlayer == !1) {
        const t = K.getXRSync(this.context);
        if (t && t.hasState(e.owner)) {
          this.tryFindAvatarObjectsIfMissing();
          const i = this.leftHand?.asset;
          i && (i.visible = t?.isTracking(e.owner, "left") ?? !1);
          const n = this.rightHand?.asset;
          n && (n.visible = t?.isTracking(e.owner, "right") ?? !1);
        }
        if (this.head?.asset) {
          const i = S.getComponentsInChildren(this.head.asset, rn);
          for (const n of i)
            n.enabled = !1, n.gameObject.visible = !0;
        }
      }
    }
  }
  tryFindAvatarObjectsIfMissing() {
    if (!this.head || !this.leftHand || !this.rightHand) {
      const e = { head: this.head, leftHand: this.leftHand, rightHand: this.rightHand };
      Z1.tryFindAvatarObjects(this.gameObject, this.sourceId || "", e), e.head && (this.head = e.head), e.leftHand && (this.leftHand = e.leftHand), e.rightHand && (this.rightHand = e.rightHand);
    }
  }
  async prepareAvatar() {
    if (this.tryFindAvatarObjectsIfMissing(), this.head)
      this.head instanceof M && (this.head = new ie("", this.sourceId, this.head));
    else {
      const e = new M();
      e.name = "Head";
      const t = La.createPrimitive(xa.Cube);
      e.add(t), this.gameObject.add(e), this.head = new ie("", this.sourceId, e), gl && console.log("Create head", e);
    }
    if (this.rightHand)
      this.rightHand instanceof M && (this.rightHand = new ie("", this.sourceId, this.rightHand));
    else {
      const e = new M();
      e.name = "Right Hand", this.gameObject.add(e), this.rightHand = new ie("", this.sourceId, e), gl && console.log("Create right hand", e);
    }
    if (this.leftHand)
      this.leftHand instanceof M && (this.leftHand = new ie("", this.sourceId, this.leftHand));
    else {
      const e = new M();
      e.name = "Left Hand", this.gameObject.add(e), this.leftHand = new ie("", this.sourceId, e), gl && console.log("Create left hand", e);
    }
    await this.loadAvatarObjects(this.head, this.leftHand, this.rightHand), this._leftHandMeshes = [], this.leftHand.asset?.traverse((e) => {
      e?.isMesh && this._leftHandMeshes.push(e);
    }), this._rightHandMeshes = [], this.rightHand.asset?.traverse((e) => {
      e?.isMesh && this._rightHandMeshes.push(e);
    }), Rn.isLocalPlayer(this.gameObject) && (this._syncTransforms = S.getComponentsInChildren(this.gameObject, zn));
  }
  async loadAvatarObjects(e, t, i) {
    const n = e.loadAssetAsync(), o = t.loadAssetAsync(), r = i.loadAssetAsync(), a = new Array();
    n && a.push(n), o && a.push(o), r && a.push(r);
    const l = await qb(a);
    gl && console.log("Avatar loaded results:", l);
  }
}
Og([
  u(ie)
], dr.prototype, "head");
Og([
  u(ie)
], dr.prototype, "leftHand");
Og([
  u(ie)
], dr.prototype, "rightHand");
var FR = Object.defineProperty, Cu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && FR(e, t, n), n;
};
const Us = w("debugwebxr"), Ns = new Array();
class mo extends R {
  createControllerModel = !0;
  createHandModel = !0;
  customLeftHand;
  customRightHand;
  static factory = new jS();
  supportsXR(e) {
    return e === "immersive-vr" || e === "immersive-ar";
  }
  _models = new Array();
  async onXRControllerAdded(e) {
    if (!(e.xr.isVR || e.xr.isPassThrough)) return;
    console.debug("XR Controller Added", e.controller.side, e.controller.index);
    const { controller: i } = e;
    if (this.createControllerModel || this.createHandModel) {
      if (i.hand) {
        if (this.createHandModel) {
          const n = await this.loadHandModel(this, i);
          if (!n || !i.connected || !i.isHand) {
            n?.handObject && hl(n.handObject, !1), n?.handObject?.destroy();
            return;
          }
          this._models.push({ controller: i, model: n.handObject, handmesh: n.handmesh }), this._models.sort((o, r) => o.controller.index - r.controller.index), this.scene.add(n.handObject), i.model = n.handObject;
        }
      } else if (this.createControllerModel) {
        const n = await i.getModelUrl();
        if (n) {
          const o = await this.loadModel(i, n);
          if (!o || !i.connected || i.isHand)
            return;
          this._models.push({ controller: i, model: o }), this._models.sort((r, a) => r.controller.index - a.controller.index), this.scene.add(o), o.traverse((r) => {
            r.layers.set(2), r.matrixAutoUpdate = !1, r.updateMatrix();
          }), i.model = o;
        } else i.targetRayMode !== "transient-pointer" && console.warn("XRControllerModel: no model found for " + i.side);
      }
    }
  }
  onXRControllerRemoved(e) {
    console.debug("XR Controller Removed", e.controller.side, e.controller.index);
    const t = this._models.findIndex((n) => n.controller === e.controller), i = this._models[t];
    i && (this._models.splice(t, 1), i.model && (hl(i.model, !1), i.model.destroy(), i.model = void 0));
  }
  onBeforeXR(e, t) {
    this.createHandModel && (this.customLeftHand || this.customRightHand) && (t.optionalFeatures = t.optionalFeatures || [], t.optionalFeatures.includes("hand-tracking") || t.optionalFeatures.push("hand-tracking"));
  }
  onLeaveXR(e) {
    for (const t of this._models)
      t && (t.model && (hl(t.model, !1), t.model.destroy(), t.model = void 0), t.controller.model === t.model && (t.controller.model = null));
    this._models.length = 0;
  }
  onBeforeRender() {
    if (K.active && (Us && (Ns[0] = Date.now()), this.updateRendering(K.active), Us)) {
      const e = Date.now() - Ns[0];
      Ns.push(e), Ns.length >= 30 && (Ns[0] = 0, Ns.reduce((t, i) => t + i, 0) / Ns.length, Ns.length = 0);
    }
  }
  updateRendering(e) {
    for (let t = 0; t < this._models.length; t++) {
      const i = this._models[t];
      if (!i) continue;
      const n = i.controller;
      if (!n.connected) {
        Us && console.warn("XRControllerModel.onUpdateXR: controller is not connected anymore", n.side, n.hand);
        continue;
      }
      if (i.model && !i.handmesh)
        i.model.matrixAutoUpdate = !1, i.model.matrix.copy(n.gripMatrix), i.model.visible = n.isTracking, e.rig?.gameObject.add(i.model);
      else if (n.inputSource.hand && i.handmesh) {
        const o = e.referenceSpace, r = this.context.renderer.xr.getHand(n.index);
        if (o && e.frame.getJointPose) {
          for (const a of n.inputSource.hand.values()) {
            const l = r.joints[a.jointName];
            if (l) {
              const c = n.getHandJointPose(a);
              if (c) {
                const h = c.transform.position, d = c.transform.orientation;
                l.position.copy(h), l.quaternion.copy(d), l.matrixAutoUpdate = !1;
              }
              l.visible = c != null;
            }
          }
          i.model && (i.model.visible = n.isTracking, i.model.visible && i.model.parent !== e.rig?.gameObject && e.rig?.gameObject.add(i.model)), i.model?.visible && (i.handmesh?.updateMesh(), i.model.matrixAutoUpdate = !1, i.model.matrix.identity(), i.model.applyMatrix4(na));
        }
      }
    }
  }
  async loadModel(e, t) {
    if (!e.connected)
      return console.warn("XRControllerModel.onXRControllerAdded: controller is not connected anymore", e.side), null;
    const n = await ie.getOrCreate("", t).instantiate();
    return hl(n), K.active?.isPassThrough && n.traverseVisible((o) => {
      this.makeOccluder(o);
    }), n;
  }
  async loadHandModel(e, t) {
    const i = this.context, n = i.renderer.xr.getHand(t.index);
    n || (Us ? z.DrawLabel(t.rayWorldPosition, "No hand found for index " + t.index, 0.05, 5) : console.warn("No hand found for index " + t.index));
    const o = new Ps();
    ig(o, i), await Qp(o, i, this.sourceId ?? "");
    const r = Mv(o);
    let a = "";
    const l = t.side === "left" ? this.customLeftHand : this.customRightHand;
    l ? (a = l.url.split(".").slice(0, -1).join("."), o.setPath("")) : (a = t.inputSource.handedness === "left" ? "left" : "right", o.setPath("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/"));
    const c = new M();
    hl(c);
    const h = new BS(c, n, o.path, a, o, (d) => {
      const f = r?.gltf;
      f?.scene.children?.length === 0 && (f.scene.children[0] = d), r?.gltf && Bn().createBuiltinComponents(e.context, e.sourceId || a, r.gltf, null, r), d.traverse((p) => {
        p.layers.set(2), K.active?.isPassThrough && !l && this.makeOccluder(p), p instanceof G && We.assignMeshLOD(p, 0);
      }), t.connected || (Us && z.DrawLabel(t.rayWorldPosition, "Hand is loaded but not connected anymore", 0.05, 5), d.removeFromParent());
    });
    if (Us && c.add(new vi(0.5)), t.inputSource.hand) {
      Us && console.log(t.inputSource.hand);
      for (const d of t.inputSource.hand.values())
        if (n.joints[d.jointName] === void 0) {
          const f = new so();
          f.matrixAutoUpdate = !1, f.visible = !0, n.joints[d.jointName] = f, n.add(f);
        }
    } else
      Us && z.DrawLabel(t.rayWorldPosition, "No inputSource.hand found for index " + t.index, 0.05, 5);
    return { handObject: c, handmesh: h };
  }
  makeOccluder(e) {
    if (e instanceof G) {
      let t = e.material;
      t instanceof _e && (t = e.material = t.clone(), t.depthWrite = !0, t.depthTest = !0, t.colorWrite = !1, e.receiveShadow = !1, e.renderOrder = -100);
    }
  }
}
Cu([
  u()
], mo.prototype, "createControllerModel");
Cu([
  u()
], mo.prototype, "createHandModel");
Cu([
  u(ie)
], mo.prototype, "customLeftHand");
Cu([
  u(ie)
], mo.prototype, "customRightHand");
class kg extends R {
}
var zR = Object.defineProperty, xo = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && zR(e, t, n), n;
};
const qf = w("debugwebxr");
class Yi extends R {
  movementSpeed = 1.5;
  rotationStep = 30;
  useTeleport = !0;
  usePinchToTeleport = !0;
  useTeleportTarget = !1;
  useTeleportFade = !1;
  showRays = !0;
  showHits = !0;
  isXRMovementHandler = !0;
  xrSessionMode = "immersive-vr";
  _didApplyRotation = !1;
  _didTeleport = !1;
  onUpdateXR(e) {
    const t = e.xr.rig;
    if (!t?.gameObject || e.xr.isPassThrough)
      return;
    const i = e.xr.leftController, n = e.xr.rightController;
    i && this.onHandleMovement(i, t.gameObject), n && (this.onHandleRotation(n, t.gameObject), this.useTeleport && this.onHandleTeleport(n, t.gameObject));
  }
  onLeaveXR(e) {
    for (const t of this._lines)
      t.removeFromParent();
    for (const t of this._hitDiscs)
      t?.removeFromParent();
  }
  onBeforeRender() {
    this.context.xr?.running && (this.showRays && this.renderRays(this.context.xr), this.showHits && this.renderHits(this.context.xr));
  }
  onHandleMovement(e, t) {
    const i = e.getStick("xr-standard-thumbstick");
    if (i.x != 0 || i.y != 0) {
      const n = H(i.x, 0, i.y);
      n.multiplyScalar(this.context.time.deltaTimeUnscaled * this.movementSpeed);
      const o = Qe(t);
      n.multiplyScalar(o.x), n.applyQuaternion(e.xr.poseOrientation), n.y = 0, n.applyQuaternion(t.worldQuaternion), L() && Number.isNaN(n.x) && console.error("Stick movement resulted in NaN", { stick: i, vec: n }), t.position.add(n), t.updateWorldMatrix(!1, !1);
      for (const r of t.children) r.updateWorldMatrix(!1, !1);
    }
  }
  onHandleRotation(e, t) {
    if (e._isMxInk) return;
    const n = e.getStick("xr-standard-thumbstick").x;
    if (this._didApplyRotation)
      Math.abs(n) < 0.3 && (this._didApplyRotation = !1);
    else if (Math.abs(n) > 0.5) {
      this._didApplyRotation = !0;
      const o = n > 0 ? 1 : -1, r = Z(this.context.mainCamera).clone();
      t.rotateY(o * j.toRadians(this.rotationStep));
      const l = Z(this.context.mainCamera).clone().sub(r);
      l.y = 0, t.position.sub(l);
    }
  }
  _teleportBuffer = new Array();
  onHandleTeleport(e, t) {
    let i = 0;
    if (e.hand && this.usePinchToTeleport && e.isTeleportGesture) {
      const n = e.getPointerId("primary");
      if (n != null && this.context.input.getIsPointerIdInUse(n))
        return;
      const o = e.getGesture("pinch");
      o && (i = o.value);
    } else
      i = e.getStick("xr-standard-thumbstick")?.y;
    if (this._didTeleport)
      i >= 0 && i < 0.4 ? this._didTeleport = !1 : i < 0 && i > -0.4 && (this._didTeleport = !1);
    else if (i > 0.8) {
      this._didTeleport = !0;
      const n = this.context.physics.raycastFromRay(e.ray)[0];
      if (n && n.object instanceof _a) {
        const r = n.normal?.dot(H(0, 1, 0));
        if (r !== void 0 && r < 0.4)
          return;
      }
      let o = n?.point;
      if (!o && !this.useTeleportTarget) {
        this._plane || (this._plane = new rr(new y(0, 1, 0), 0));
        const r = t.worldPosition;
        this._plane.setFromNormalAndCoplanarPoint(new y(0, 1, 0), r);
        const a = e.ray;
        o = r.clone(), this._plane.intersectLine(new sS(a.origin, H(a.direction).multiplyScalar(1e4).add(a.origin)), o), o.distanceTo(r) > t.scale.x * 10 && (o = null);
      }
      if (o) {
        if (this.useTeleportTarget && !S.getComponentInParent(n.object, kg))
          return;
        const r = o.clone();
        if (qf && z.DrawSphere(o, 0.025, 16711680, 5), this.context.mainCamera?.position) {
          const l = this.context.xr?.getUserOffsetInRig();
          l && (l.y = 0, r.sub(l), qf && z.DrawWireSphere(l.add(r), 0.025, 65280, 5));
        }
        this._teleportBuffer.push(t.matrix.clone()), this._teleportBuffer.length > 10 && this._teleportBuffer.shift(), this.useTeleportFade ? e.xr.fadeTransition()?.then(() => {
          t.worldPosition = r;
        }) : t.worldPosition = r;
      }
    } else if (i < -0.8 && (this._didTeleport = !0, this._teleportBuffer.length > 0)) {
      const n = this._teleportBuffer.pop();
      n && n.decompose(t.position, t.quaternion, t.scale);
    }
  }
  _plane = null;
  _lines = [];
  _hitDiscs = [];
  _hitDistances = [];
  _lastHitDistances = [];
  renderRays(e) {
    for (let t = 0; t < this._lines.length; t++) {
      const i = this._lines[t];
      i && (i.visible = !1);
    }
    for (let t = 0; t < e.controllers.length; t++) {
      const i = e.controllers[t];
      let n = this._lines[t];
      if (!i.connected || !i.isTracking || !i.ray || i.targetRayMode === "transient-pointer" || !i.hasSelectEvent) {
        n && (n.visible = !1);
        continue;
      }
      n || (n = this.createRayLineObject(), n.scale.z = 0.5, this._lines[t] = n), i.updateRayWorldPosition(), i.updateRayWorldQuaternion();
      const o = i.rayWorldPosition, r = i.rayWorldQuaternion;
      n.position.copy(o), n.quaternion.copy(r);
      const a = e.rigScale, l = this.usePinchToTeleport && i.isTeleportGesture, c = this._lastHitDistances[t], h = this._hitDistances[t] != null, d = c ?? a;
      n.scale.set(a, a, d), n.visible = !0, n.layers.disableAll(), n.layers.enable(2);
      let f = n.material.opacity;
      l ? f = 1 : this.showHits && d < e.rigScale * 0.5 ? f = 0 : i.getButton("primary")?.pressed ? f = 0.5 : f = h ? 0.2 : 0.1, n.material.opacity = j.lerp(n.material.opacity, f, this.context.time.deltaTimeUnscaled / 0.1), n.parent !== this.context.scene && this.context.scene.add(n);
    }
  }
  renderHits(e) {
    for (const t of this._hitDiscs) {
      if (!t) continue;
      const i = t.controller;
      if (!i || !i.connected || !i.isTracking) {
        t.visible = !1;
        continue;
      }
    }
    for (let t = 0; t < e.controllers.length; t++) {
      const i = e.controllers[t];
      if (!i.connected || !i.isTracking || !i.ray || !i.hasSelectEvent) continue;
      let n = this._hitDiscs[t], o = !0;
      const r = i.getPointerId("primary");
      r != null && this.context.input.getIsPointerIdInUse(r) && (n && (n.visible = !1), this._hitDistances[t] = null, this._lastHitDistances[t] = 0, o = !1);
      const a = this.context.time.smoothedFps >= 59 ? 1 : 10;
      if ((this.context.time.frame + i.index) % a !== 0 && (o = !1), !o) {
        const h = this._hitDiscs[t];
        h && h.visible && h.hit && this.updateHitPointerPosition(i, h, h.hit.distance);
        continue;
      }
      const l = this.context.physics.raycastFromRay(i.ray, { testObject: this.hitPointRaycastFilter, precise: !1 });
      let c = l.find((h) => this.usePinchToTeleport && i.isTeleportGesture ? !0 : this.isObjectWithInteractiveComponent(h.object));
      if (c || (c = l[0]), n && (n.controller = i, n.hit = c), this._hitDistances[t] = c?.distance || null, c) {
        this._lastHitDistances[t] = c.distance;
        const h = e.rigScale ?? 1;
        qf && (z.DrawWireSphere(c.point, 0.025 * h, 16711680), z.DrawLabel(H(0, 0.2, 0).add(c.point), c.object.name, 0.02, 0)), n || (n = this.createHitPointObject(), this._hitDiscs[t] = n), n.hit = c, n.visible = c.distance > h * 0.05;
        let d = 0.01 * (h + c.distance);
        const f = i.getButton("primary")?.pressed;
        f && (d *= 1.1), n.scale.set(d, d, d), n.layers.set(2);
        let p = n.material.opacity;
        if (f ? p = 1 : p = c.distance < 0.15 * h ? 0.2 : 0.6, n.material.opacity = j.lerp(n.material.opacity, p, this.context.time.deltaTimeUnscaled / 0.1), n.visible) {
          if (c.normal) {
            this.updateHitPointerPosition(i, n, c.distance);
            const g = c.normal.applyQuaternion(be(c.object));
            n.quaternion.setFromUnitVectors(UR, g);
          } else
            this.updateHitPointerPosition(i, n, c.distance);
          n.parent !== this.context.scene && this.context.scene.add(n);
        }
      } else
        this._hitDiscs[t] && (this._hitDiscs[t].visible = !1);
    }
  }
  isObjectWithInteractiveComponent(e, t = 0) {
    return Hp(e) || e.isUI === !0 ? !0 : e.isScene ? !1 : e.parent ? this.isObjectWithInteractiveComponent(e.parent, t + 1) : !1;
  }
  updateHitPointerPosition(e, t, i) {
    const n = H(e.rayWorldPosition);
    n.add(H(0, 0, i - 0.01).applyQuaternion(e.rayWorldQuaternion)), t.position.lerp(n, this.context.time.deltaTimeUnscaled / 0.05);
  }
  hitPointRaycastFilter = (e) => e.type === "SkinnedMesh" ? "continue in children" : !0;
  /** create an object to visualize hit points in the scene */
  createHitPointObject() {
    const e = new G(
      new Ud(0.3, 6, 6),
      // new RingGeometry(.3, 0.5, 32).rotateX(- Math.PI / 2),
      new we({
        color: 15658734,
        opacity: 0.7,
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
        side: xi
      })
    );
    return e.layers.disableAll(), e.layers.enable(2), e;
  }
  /** create an object to visualize controller rays */
  createRayLineObject() {
    const e = new FS();
    e.layers.disableAll(), e.layers.enable(2);
    const t = new zS();
    e.geometry = t;
    const i = new Float32Array(9);
    i.set([0, 0, 0.02, 0, 0, 0.4, 0, 0, 1]), t.setPositions(i);
    const n = new Float32Array(9);
    n.set([1, 1, 1, 0.1, 0.1, 0.1, 0, 0, 0]), t.setColors(n);
    const o = new US({
      color: 16777215,
      vertexColors: !0,
      worldUnits: !0,
      linewidth: 4e-3,
      transparent: !0,
      depthWrite: !1,
      // TODO: this doesnt work with passthrough
      blending: Eb,
      dashed: !1
      // alphaToCoverage: true,
    });
    return e.material = o, e;
  }
}
xo([
  u()
], Yi.prototype, "movementSpeed");
xo([
  u()
], Yi.prototype, "rotationStep");
xo([
  u()
], Yi.prototype, "useTeleport");
xo([
  u()
], Yi.prototype, "usePinchToTeleport");
xo([
  u()
], Yi.prototype, "useTeleportTarget");
xo([
  u()
], Yi.prototype, "useTeleportFade");
xo([
  u()
], Yi.prototype, "showRays");
xo([
  u()
], Yi.prototype, "showHits");
const UR = new y(0, 1, 0);
var NR = Object.defineProperty, yt = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && NR(e, t, n), n;
};
const yl = w("debugwebxr"), $R = w("debugusdz"), ct = class Qr extends R {
  createVRButton = !0;
  createARButton = !0;
  createSendToQuestButton = !0;
  createQRCode = !0;
  useDefaultControls = !0;
  showControllerModels = !0;
  showHandModels = !0;
  usePlacementReticle = !0;
  customARPlacementReticle;
  usePlacementAdjustment = !0;
  arScale = 1;
  useXRAnchor = !1;
  autoPlace = !1;
  autoCenter = !1;
  useQuicklookExport = !1;
  useDepthSensing = !1;
  useSpatialGrab = !0;
  defaultAvatar;
  _playerSync;
  /** these components were created by the WebXR component on session start and will be cleaned up again in session end */
  _createdComponentsInSession = [];
  _usdzExporter;
  static activeWebXRComponent = null;
  /**
   * Initializes the WebXR component by obtaining the XR sync object for this context.
   * @internal
   */
  awake() {
    K.getXRSync(this.context);
  }
  /**
   * Sets up the WebXR component when it's enabled. Checks for HTTPS connection,
   * sets up USDZ export if enabled, creates UI buttons, and configures avatar settings.
   * @internal
   */
  onEnable() {
    window.location.protocol !== "https:" && ge('<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API" target="_blank">WebXR</a> only works on secure connections (https).'), this.useQuicklookExport && (S.findObjectOfType(ws) || (yl && console.log("WebXR: Adding USDZExporter"), this._usdzExporter = S.addComponent(this.gameObject, ws), this._usdzExporter.objectToExport = this.context.scene, this._usdzExporter.autoExportAnimations = !0, this._usdzExporter.autoExportAudioSources = !0)), this.handleCreatingHTML(), this.handleOfferSession(), this.defaultAvatar === !0 && (yl && console.warn("WebXR: No default avatar set, using static default avatar"), this.defaultAvatar = new ie("https://cdn.needle.tools/static/avatars/DefaultAvatar.glb")), this.defaultAvatar && (this._playerSync = this.gameObject.getOrAddComponent(Zv), this._playerSync.autoSync = !1), this._playerSync && typeof this.defaultAvatar != "boolean" && (this._playerSync.asset = this.defaultAvatar, this._playerSync.onPlayerSpawned?.removeEventListener(this.onAvatarSpawned), this._playerSync.onPlayerSpawned?.addEventListener(this.onAvatarSpawned));
  }
  /**
   * Cleans up resources when the component is disabled.
   * Destroys the USDZ exporter if one was created and removes UI buttons.
   * @internal
   */
  onDisable() {
    this._usdzExporter?.destroy(), this.removeButtons();
  }
  /**
   * Checks if WebXR is supported and offers an appropriate session.
   * This is used to show the WebXR session joining prompt in browsers that support it.
   * @returns A Promise that resolves to true if a session was offered, false otherwise
   */
  async handleOfferSession() {
    return this.createVRButton && await K.isVRSupported() && this.createVRButton ? K.offerSession("immersive-vr", "default", this.context) : this.createARButton && await K.isARSupported() && this.createARButton ? K.offerSession("immersive-ar", "default", this.context) : !1;
  }
  /** the currently active webxr input session */
  get session() {
    return K.active ?? null;
  }
  /** immersive-vr or immersive-ar */
  get sessionMode() {
    return K.activeMode ?? null;
  }
  /** While AR: this will return the currently active WebARSessionRoot component.   
   * You can also query this component in your scene with `findObjectOfType(WebARSessionRoot)` 
   */
  get arSessionRoot() {
    return this._activeWebARSessionRoot;
  }
  /** Call to start an WebVR session.     
   * 
   * This is a shorthand for `NeedleXRSession.start("immersive-vr", init, this.context)`
  */
  async enterVR(e) {
    return K.start("immersive-vr", e, this.context);
  }
  /** Call to start an WebAR session   
   * 
   * This is a shorthand for `NeedleXRSession.start("immersive-ar", init, this.context)`
  */
  async enterAR(e) {
    return K.start("immersive-ar", e, this.context);
  }
  /** Call to end a WebXR (AR or VR) session.   
   * 
   * This is a shorthand for `NeedleXRSession.stop()`
   */
  exitXR() {
    K.stop();
  }
  _exitXRMenuButton;
  _previousXRState = 0;
  _spatialGrabRaycaster;
  _activeWebARSessionRoot = null;
  get isActiveWebXR() {
    return !Qr.activeWebXRComponent || Qr.activeWebXRComponent === this;
  }
  /**
   * Called before entering a WebXR session. Sets up optional features like depth sensing, if needed.
   * @param _mode The XR session mode being requested (immersive-ar or immersive-vr)
   * @param args The XRSessionInit object that will be passed to the WebXR API
   * @internal
   */
  onBeforeXR(e, t) {
    if (!this.isActiveWebXR) {
      console.warn(`WebXR: another WebXR component is already active (${Qr.activeWebXRComponent?.name}). This is ignored: ${this.name}`);
      return;
    }
    Qr.activeWebXRComponent = this, e == "immersive-ar" && this.useDepthSensing && (t.optionalFeatures = t.optionalFeatures || [], t.optionalFeatures.push("depth-sensing"));
  }
  /**
   * Called when a WebXR session begins. Sets up the scene for XR by configuring controllers,
   * AR placement, and other features based on component settings.
   * @param args Event arguments containing information about the started XR session
   * @internal
   */
  async onEnterXR(e) {
    if (!this.isActiveWebXR) return;
    yl && console.log("WebXR onEnterXR"), this._previousXRState = ei.Global.Mask;
    const t = e.xr.isVR;
    if (ei.Global.Set(t ? fs.VR : fs.AR), e.xr.isAR) {
      let i = S.findObjectOfType(Vi);
      if (!i)
        if (this.usePlacementReticle) {
          const n = new M();
          for (const o of this.context.scene.children)
            n.add(o);
          this.context.scene.add(n), i = S.addComponent(n, Vi), this._createdComponentsInSession.push(i);
        } else (yl || L()) && console.warn("WebXR: No WebARSessionRoot found in scene and usePlacementReticle is disabled in WebXR component.");
      this._activeWebARSessionRoot = i, i && (i.customReticle = this.customARPlacementReticle, i.arScale = this.arScale, i.arTouchTransform = this.usePlacementAdjustment, i.autoPlace = this.autoPlace, i.autoCenter = this.autoCenter, i.useXRAnchor = this.useXRAnchor);
    }
    this.useDefaultControls && this.setDefaultMovementEnabled(!0), (this.showControllerModels || this.showHandModels) && this.setDefaultControllerRenderingEnabled(!0), this.useSpatialGrab && (this._spatialGrabRaycaster = S.findObjectOfType(Ea) ?? void 0, this._spatialGrabRaycaster || (this._spatialGrabRaycaster = this.gameObject.addComponent(Ea))), this.createLocalAvatar(e.xr), e.xr.isScreenBasedAR || (this._exitXRMenuButton = this.context.menu.appendChild({
      label: "Quit XR",
      onClick: () => this.exitXR(),
      icon: "exit_to_app",
      priority: 2e4
    }));
  }
  /**
   * Called every frame during an active WebXR session.
   * Updates components that depend on the current XR state.
   * @param _args Event arguments containing information about the current XR session frame
   * @internal
   */
  onUpdateXR(e) {
    this.isActiveWebXR && this._spatialGrabRaycaster && (this._spatialGrabRaycaster.enabled = this.useSpatialGrab);
  }
  /**
   * Called when a WebXR session ends. Restores pre-session state,
   * removes temporary components, and cleans up resources.
   * @param _ Event arguments containing information about the ended XR session
   * @internal
   */
  onLeaveXR(e) {
    if (this._exitXRMenuButton?.remove(), !!this.isActiveWebXR) {
      ei.Global.Set(this._previousXRState), this._playerSync?.destroyInstance();
      for (const t of this._createdComponentsInSession)
        t.destroy();
      this._createdComponentsInSession.length = 0, this._activeWebARSessionRoot = null, this.handleOfferSession(), Qd(1).then(() => Qr.activeWebXRComponent = null);
    }
  }
  /** Call to enable or disable default controller behaviour */
  setDefaultMovementEnabled(e) {
    let t = this.gameObject.getComponent(Yi);
    return !t && e && (t = this.gameObject.addComponent(Yi), this._createdComponentsInSession.push(t)), t && (t.enabled = e), t;
  }
  /** Call to enable or disable default controller rendering */
  setDefaultControllerRenderingEnabled(e) {
    let t = this.gameObject.getComponent(mo);
    return !t && e && (t = this.gameObject.addComponent(mo), this._createdComponentsInSession.push(t), t.createControllerModel = this.showControllerModels, t.createHandModel == this.showHandModels), t && (t.enabled = e), t;
  }
  /**
   * Creates and instantiates the user's avatar representation in the WebXR session.
   * @param xr The active session
   */
  async createLocalAvatar(e) {
    this._playerSync && e.running && typeof this.defaultAvatar != "boolean" && (this._playerSync.asset = this.defaultAvatar, await this._playerSync.getInstance());
  }
  /**
   * Event handler called when a player avatar is spawned.
   * Ensures the avatar has the necessary Avatar component.
   * @param instance The spawned avatar 3D object
   */
  onAvatarSpawned = (e) => {
    yl && console.log("WebXR.onAvatarSpawned", e);
    let t = S.getComponentInChildren(e, dr);
    t ??= S.addComponent(e, dr);
  };
  // HTML UI
  /** @deprecated use {@link getButtonsFactory} or directly access {@link WebXRButtonFactory.getOrCreate} */
  getButtonsContainer() {
    return this.getButtonsFactory();
  }
  /**
   * Returns the WebXR button factory, creating one if it doesn't exist.
   * Use this to access and modify WebXR UI buttons.
   * @returns The WebXRButtonFactory instance
   */
  getButtonsFactory() {
    return this._buttonFactory || (this._buttonFactory = or.getOrCreate()), this._buttonFactory;
  }
  /**
   * Reference to the WebXR button factory used by this component.
   */
  _buttonFactory;
  /**
   * Creates and sets up UI elements for WebXR interaction based on component settings
   * and device capabilities. Handles creating AR, VR, QuickLook buttons and utility buttons like QR codes.
   */
  handleCreatingHTML() {
    if (this.createARButton || this.createVRButton || this.useQuicklookExport) {
      if ((q.isiOS() && q.isSafari() || $R) && this.useQuicklookExport) {
        const t = S.findObjectOfType(ws);
        if (!t || t && t.allowCreateQuicklookButton) {
          const i = this.getButtonsFactory().createQuicklookButton();
          this.addButton(i, 50);
        }
      }
      if (this.createARButton) {
        const t = this.getButtonsFactory().createARButton();
        this.addButton(t, 50);
      }
      if (this.createVRButton) {
        const t = this.getButtonsFactory().createVRButton();
        this.addButton(t, 50);
      }
    }
    if (this.createSendToQuestButton && !q.isQuest() && K.isVRSupported().then((t) => {
      if (!t) {
        const i = this.getButtonsFactory().createSendToQuestButton();
        this.addButton(i, 50);
      }
    }), this.createQRCode) {
      const t = su(As);
      if (t && t.createQRCodeButton === !1)
        L() && console.warn("WebXR: QRCode button is disabled in the Needle Menu component");
      else if (!q.isMobileDevice()) {
        const i = kn.getOrCreate().createQRCode();
        this.addButton(i, 50);
      }
    }
  }
  /**
   * Storage for UI buttons created by this component.
   */
  _buttons = [];
  /**
   * Adds a button to the UI with the specified priority.
   * @param button The HTML element to add
   * @param priority The button's priority value (lower numbers appear first)
   */
  addButton(e, t) {
    this._buttons.push(e), e.setAttribute("priority", t.toString()), this.context.menu.appendChild(e);
  }
  /**
   * Removes all buttons created by this component from the UI.
   */
  removeButtons() {
    for (const e of this._buttons)
      e.remove();
    this._buttons.length = 0;
  }
};
yt([
  u()
], ct.prototype, "createVRButton");
yt([
  u()
], ct.prototype, "createARButton");
yt([
  u()
], ct.prototype, "createSendToQuestButton");
yt([
  u()
], ct.prototype, "createQRCode");
yt([
  u()
], ct.prototype, "useDefaultControls");
yt([
  u()
], ct.prototype, "showControllerModels");
yt([
  u()
], ct.prototype, "showHandModels");
yt([
  u()
], ct.prototype, "usePlacementReticle");
yt([
  u(ie)
], ct.prototype, "customARPlacementReticle");
yt([
  u()
], ct.prototype, "usePlacementAdjustment");
yt([
  u()
], ct.prototype, "arScale");
yt([
  u()
], ct.prototype, "useXRAnchor");
yt([
  u()
], ct.prototype, "autoPlace");
yt([
  u()
], ct.prototype, "autoCenter");
yt([
  u()
], ct.prototype, "useQuicklookExport");
yt([
  u()
], ct.prototype, "useDepthSensing");
yt([
  u()
], ct.prototype, "useSpatialGrab");
yt([
  u(ie)
], ct.prototype, "defaultAvatar");
let Mg = ct;
const Ph = w("debugusdzbehaviours");
class Jv {
  get extensionName() {
    return "Behaviour";
  }
  behaviours = [];
  addBehavior(e) {
    this.behaviours.push(e);
  }
  /** Register audio clip for USDZ export. The clip will be embedded in the resulting file. */
  addAudioClip(e) {
    if (!e || typeof e != "string") return "";
    const i = "audio/" + Na.getName(e);
    return this.audioClips.push({ clipUrl: e, filesKey: i }), i;
  }
  behaviourComponents = [];
  behaviourComponentsCopy = [];
  audioClips = [];
  audioClipsCopy = [];
  targetUuids = /* @__PURE__ */ new Set();
  getAllTargetUuids() {
    return this.targetUuids;
  }
  onBeforeBuildDocument(e) {
    if (!e.root) return Promise.resolve();
    const t = [];
    return e.root.traverse((i) => {
      S.foreachComponent(i, (n) => {
        const o = n;
        if (typeof o.createBehaviours == "function" || typeof o.beforeCreateDocument == "function" || typeof o.afterCreateDocument == "function" || typeof o.afterSerialize == "function") {
          this.behaviourComponents.push(o);
          const r = o.beforeCreateDocument?.call(o, this, e);
          r instanceof Promise && t.push(r);
        }
      }, !1);
    }), Ph && console.log("onBeforeBuildDocument: all components", this.behaviourComponents), Promise.all(t);
  }
  onExportObject(e, t, i) {
    for (const n of this.behaviourComponents)
      n.createBehaviours?.call(n, this, t, i);
  }
  onAfterBuildDocument(e) {
    for (const d of this.behaviourComponents)
      typeof d.afterCreateDocument == "function" && d.afterCreateDocument(this, e);
    this.behaviourComponentsCopy = this.behaviourComponents.slice(), this.behaviourComponents.length = 0, this.audioClipsCopy = this.audioClips.slice(), this.audioClips.length = 0;
    const t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = Ph;
    let a = `graph LR
`, l = "";
    function c(d) {
      if (d instanceof ea) {
        r && (a += `subgraph Group_${d.id}
`);
        for (const f of d.actions)
          r && (a += `${d.id}[${d.id}] -- ${d.type},loops:${d.loops} --> ${f.id}[${f.id}]
`), c(f);
        r && (a += `end
`);
      } else if (d instanceof di) {
        d.tokenId === "StartAnimation" && o.add(d);
        let f = d.tokenId;
        d.type !== void 0 && (f += ":" + d.type);
        const p = d.affectedObjects;
        if (p)
          if (Array.isArray(p))
            for (const b of p)
              i.add(b), r && (l += `${d.id}[${d.id}
${f}] -- ${f} --> ${b.uuid}(("${b.displayName || b.name || b.uuid}"))
`);
          else typeof p == "object" ? (i.add(p), r && (l += `${d.id}[${d.id}
${f}] -- ${f} --> ${p.uuid}(("${p.displayName || p.name || p.uuid}"))
`)) : typeof p == "string" && i.add({ uuid: p });
        const g = d.xFormTarget;
        g && (typeof g == "object" ? (i.add(g), r && (l += `${d.id}[${d.id}
${f}] -- ${f} --> ${g.uuid}(("${g.displayName || g.name || g.uuid}"))
`)) : typeof g == "string" && i.add({ uuid: g }));
      }
    }
    function h(d, f) {
      if (Array.isArray(d))
        for (const p of d)
          h(p, f);
      else if (d instanceof sr) {
        let p = d.tokenId;
        d.type !== void 0 && (p += ":" + d.type), typeof d.targetId == "object" && (t.add(d.targetId), r && (l += `${d.targetId.uuid}(("${d.targetId.displayName}")) --> ${d.id}[${d.id}
${p}]
`)), r && (a += `${d.id}((${d.id})) -- ${p} --> ${f.id}[${f.tokenId || f.id}]
`);
      }
    }
    for (const d of this.behaviours)
      r && (a += `subgraph ${d.id}
`), c(d.action), h(d.trigger, d.action), r && (a += `end
`);
    r && (a += `
` + l), r && (console.log("All USDZ behaviours", this.behaviours), this.behaviours.length && (console.warn("The Mermaid graph can be pasted into https://massive-mermaid.glitch.me/ or https://mermaid.live/edit. It should be in your clipboard already!"), console.log(a), navigator.clipboard.writeText(a)));
    {
      let d = `gantt
title Animations
dateFormat X
axisFormat %s
`;
      const f = Array.from(o), p = /* @__PURE__ */ new Set();
      for (const v of f)
        if (v.affectedObjects && typeof v.affectedObjects != "string") {
          if (Array.isArray(v.affectedObjects))
            for (const _ of v.affectedObjects)
              p.add(_);
          else
            p.add(v.affectedObjects);
          r && (d += `section ${v.animationName} (${v.id})
`, d += `${v.id} : ${v.start}, ${v.duration}s
`);
        }
      r && o.size && console.log(d);
      const g = /* @__PURE__ */ new Set();
      for (const v of p) {
        v.getPath || console.error("USDZExporter: Animation target object has no getPath method. This is likely a bug", v);
        let _ = v.getPath();
        _.startsWith("<") && (_ = _.substring(1)), _.endsWith(">") && (_ = _.substring(0, _.length - 1)), g.add({ path: _, obj: v });
      }
      const b = Array.from(g).sort((v, _) => v.path.length - _.path.length), m = new Array();
      for (let v = 0; v < b.length; v++)
        for (let _ = v + 1; _ < b.length; _++)
          if (b[_].path.startsWith(b[v].path)) {
            const x = b[_], I = b[v];
            m.push({ child: x.obj.displayName + " (" + x.path + ")", parent: I.obj.displayName + " (" + I.path + ")" });
          }
      m.length && console.warn(
        "USDZExporter: There are overlapping PlayAnimation actions. This can lead to undefined runtime behaviour when playing multiple animations. Please restructure the hierarchy so that animations don't overlap.",
        {
          overlappingTargets: m,
          playAnimationActions: o
        }
      );
    }
    for (const d of /* @__PURE__ */ new Set([...t, ...i]))
      if (Array.isArray(d))
        for (const f of d)
          n.add(f.uuid);
      else
        n.add(d.uuid);
    Ph && console.log("All Behavior trigger sources and action targets", t, i, n), this.targetUuids = new Set(n);
  }
  onAfterHierarchy(e, t) {
    if (this.behaviours?.length) {
      t.beginBlock('def Scope "Behaviors"');
      for (const i of this.behaviours)
        i.writeTo(this, e.document, t);
      t.closeBlock();
    }
  }
  async onAfterSerialize(e) {
    Ph && console.log("onAfterSerialize behaviours", this.behaviourComponentsCopy);
    for (const t of this.behaviourComponentsCopy)
      typeof t.afterSerialize == "function" && (t.afterSerialize.constructor.name === "AsyncFunction" ? await t.afterSerialize(this, e) : t.afterSerialize(this, e));
    for (const { clipUrl: t, filesKey: i } of this.audioClipsCopy) {
      if (e.files[i]) return;
      const r = await (await (await fetch(t)).blob()).arrayBuffer(), a = new Uint8Array(r);
      e.files[i] = a;
    }
    this.behaviourComponentsCopy.length = 0, this.audioClipsCopy.length = 0;
  }
}
class ew {
  get extensionName() {
    return "Physics";
  }
  onExportObject(e, t, i) {
    const n = S.getComponents(e, rt).filter((l) => l.enabled), o = S.getComponents(e, Ci).filter((l) => l.enabled && !l.isTrigger);
    let r = n.length > 0 ? n[0] : null;
    const a = o.length > 0 ? o[0] : null;
    a && !r && (r = new rt(), r.isKinematic = !0), r && t.addEventListener("serialize", (l, c) => {
      if (r) {
        if (l.appendLine(), l.beginBlock('def RealityKitComponent "RigidBody"', "{", !0), r.useGravity || l.appendLine("bool gravityEnabled = 0"), l.appendLine('uniform token info:id = "RealityKit.RigidBody"'), r.isKinematic && l.appendLine('token motionType = "Kinematic"'), l.beginBlock('def RealityKitStruct "massFrame"', "{", !0), l.appendLine(`float m_mass = ${r.mass}`), l.beginBlock('def RealityKitStruct "m_pose"', "{", !0), l.appendLine(`float3 position = (${r.centerOfMass.x}, ${r.centerOfMass.y}, ${r.centerOfMass.z})`), l.closeBlock("}"), l.closeBlock("}"), o.length > 0) {
          const h = o[0];
          l.beginBlock('def RealityKitStruct "material"', "{", !0);
          const d = h.sharedMaterial;
          d && d.dynamicFriction !== void 0 && l.appendLine(`double dynamicFriction = ${h.sharedMaterial?.dynamicFriction}`), d && d.bounciness !== void 0 && l.appendLine(`double restitution = ${h.sharedMaterial?.bounciness}`), d && d.staticFriction !== void 0 && l.appendLine(`double staticFriction = ${h.sharedMaterial?.staticFriction}`), l.closeBlock("}");
        }
        l.closeBlock("}");
      }
    }), a && (t.addEventListener("serialize", (l, c) => {
      l.beginBlock('def RealityKitComponent "Collider"', "{", !0), l.appendLine("uint group = 1"), l.appendLine('uniform token info:id = "RealityKit.Collider"'), l.appendLine("uint mask = 4294967295");
      const d = a.isTrigger ? "Trigger" : "Default";
      if (l.appendLine(`token type = "${d}"`), l.beginBlock('def RealityKitStruct "Shape"', "{", !0), a instanceof Rc) {
        const f = a;
        l.appendLine('token shapeType = "Sphere"'), l.appendLine(`float radius = ${f.radius}`);
      } else if (a instanceof fg) {
        const f = a;
        l.appendLine('token shapeType = "Box"'), l.appendLine(`float3 extent = (${f.size.x}, ${f.size.y}, ${f.size.z})`);
      } else if (a instanceof po) {
        const f = a;
        l.appendLine('token shapeType = "Capsule"'), l.appendLine(`float radius = ${f.radius}`), l.appendLine(`float height = ${f.height}`);
      } else if (a instanceof xr && a.sharedMesh?.geometry) {
        const f = a.sharedMesh.geometry;
        f.boundingBox || f.computeBoundingBox();
        const p = a.sharedMesh.geometry.boundingBox;
        p && (l.appendLine('token shapeType = "Box"'), l.appendLine(`float3 extent = (${p.max.x - p.min.x}, ${p.max.y - p.min.y}, ${p.max.z - p.min.z})`), console.log("[USDZ] Only Box, Sphere, and Capsule colliders are supported in visionOS/iOS. MeshCollider will be exported as Box", a));
      } else
        console.warn("[USDZ] Only Box, Sphere, and Capsule colliders are supported in visionOS/iOS. Ignoring collider:", a);
      l.beginBlock('def RealityKitStruct "pose"', "{", !0), l.closeBlock("}"), l.closeBlock("}"), l.closeBlock("}");
    }), o.length > 1 && console.log("WARNING: Multiple colliders detected. visionOS / iOS can only support objects with a single collider, only exporting the first collider: ", a));
  }
}
const WR = w("debugshadowcomponents");
Wb.prototype.interactable = {
  get() {
    return this.interactive;
  },
  set(s) {
    this.interactable = s;
  }
};
class un extends R {
  /** Is this object on the root of the UI hierarchy ? */
  isRoot() {
    return this.Root?.gameObject === this.gameObject;
  }
  /** Access the parent canvas component */
  get canvas() {
    const e = this.Root;
    return e?.isCanvas ? e : null;
  }
  /** @deprecated use `canvas` */
  get Canvas() {
    return this.canvas;
  }
  /** Mark the UI dirty which will trigger an THREE-Mesh-UI update */
  markDirty() {
    ti.markUIDirty(this.context);
  }
  /** the underlying three-mesh-ui */
  get shadowComponent() {
    return this._shadowComponent;
  }
  set shadowComponent(e) {
    this._shadowComponent = e;
  }
  _shadowComponent = null;
  _controlsChildLayout = !0;
  get controlsChildLayout() {
    return this._controlsChildLayout;
  }
  set controlsChildLayout(e) {
    this._controlsChildLayout = e, this.shadowComponent && (this.shadowComponent.autoLayout = e);
  }
  _root = void 0;
  get Root() {
    return this._root === void 0 && (this._root = S.getComponentInParent(this.gameObject, Pu)), this._root;
  }
  // private _intermediate?: Object3D;
  _parentComponent = void 0;
  __internalNewInstanceCreated(e) {
    return super.__internalNewInstanceCreated(e), this.shadowComponent = null, this._root = void 0, this._parentComponent = void 0, this;
  }
  onEnable() {
    super.onEnable();
  }
  /** Add a three-mesh-ui object to the UI hierarchy 
   * @param container the three-mesh-ui object to add
   * @param parent the parent component to add the object to
  */
  addShadowComponent(e, t) {
    if (!e) return;
    this.removeShadowComponent();
    const i = this.isRoot() ? this.gameObject : this.gameObject.parent;
    if (this._parentComponent = S.getComponentInParent(i, un), !this._parentComponent) {
      console.warn(`Component "${this.name}" doesn't have a UI parent anywhere. Do you have an UI element outside a Canvas? UI components must be a child of a Canvas component`, this);
      return;
    }
    e.name = this.name + " (" + (this.constructor.name ?? "UI") + ")", e.autoLayout = this._parentComponent.controlsChildLayout, e[pi] = this, this.setShadowComponentOwner(e);
    let n = !1;
    if (this.Root?.gameObject === this.gameObject)
      this.gameObject.add(e);
    else {
      const o = this._parentComponent.shadowComponent;
      o && (o?.add(e), n = !0);
    }
    this.shadowComponent = e, t && t.shadowComponent && this.shadowComponent && t.shadowComponent.add(this.shadowComponent), Sc && e.add(new vi(0.5)), this.onAfterAddedToScene(), n && nC(), WR && console.warn("Added shadow component", this.shadowComponent);
  }
  setShadowComponentOwner(e) {
    if (e && (e[pi] === void 0 || e[pi] === this) && (e[pi] = this, e.children))
      for (const t of e.children)
        this.setShadowComponentOwner(t);
  }
  traverseOwnedShadowComponents(e, t, i) {
    if (e && e[pi] === t) {
      i(e);
      for (const n of e.children)
        this.traverseOwnedShadowComponents(n, t, i);
    }
  }
  /** Remove the underlying UI object from the hierarchy */
  removeShadowComponent() {
    this.shadowComponent && this.shadowComponent.removeFromParent();
  }
  onAfterAddedToScene() {
  }
  setInteractable(e) {
    this.shadowComponent && (this.shadowComponent.interactable = e);
  }
}
class Pu extends un {
  awake() {
    super.awake();
  }
}
var VR = Object.defineProperty, HR = Object.getOwnPropertyDescriptor, Lc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? HR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && VR(e, t, n), n;
};
const Xf = w("debugui"), Qf = w("debuguilayout");
class GR {
  width;
  height;
}
class qR {
  x;
  y;
  width;
  height;
}
const sn = new y(), _l = new ee(), Oh = new U(), Va = class tw extends un {
  get parent() {
    return this._parentRectTransform;
  }
  // @serializable(Object3D)
  // root? : Object3D;
  get translation() {
    return this.gameObject.position;
  }
  get rotation() {
    return this.gameObject.quaternion;
  }
  get scale() {
    return this.gameObject.scale;
  }
  _anchoredPosition;
  get anchoredPosition() {
    return this._anchoredPosition || (this._anchoredPosition = new J()), this._anchoredPosition;
  }
  set anchoredPosition(e) {
    this._anchoredPosition = e;
  }
  sizeDelta = new J(100, 100);
  pivot = new J(0.5, 0.5);
  anchorMin = new J(0, 0);
  anchorMax = new J(1, 1);
  // @serializable(Vector2)
  // offsetMin: Vector2 = new Vector2(0, 0);
  // @serializable(Vector2)
  // offsetMax: Vector2 = new Vector2(0, 0);
  /** Optional min width in pixel, set to undefined to disable it */
  minWidth;
  /** Optional min height in pixel, set to undefined to disable it */
  minHeight;
  get width() {
    let e = this.sizeDelta.x;
    if (this.anchorMin.x !== this.anchorMax.x && this._parentRectTransform) {
      const t = this._parentRectTransform.width, i = this.anchorMax.x - this.anchorMin.x;
      e = t * i, e += this.sizeDelta.x;
    }
    return this.minWidth !== void 0 && e < this.minWidth ? this.minWidth : e;
  }
  get height() {
    let e = this.sizeDelta.y;
    if (this.anchorMin.y !== this.anchorMax.y && this._parentRectTransform) {
      const t = this._parentRectTransform.height, i = this.anchorMax.y - this.anchorMin.y;
      e = t * i, e += this.sizeDelta.y;
    }
    return this.minHeight !== void 0 && e < this.minHeight ? this.minHeight : e;
  }
  // private lastMatrixWorld!: Matrix4;
  lastMatrix;
  rectBlock;
  _transformNeedsUpdate = !1;
  _initialPosition;
  _parentRectTransform;
  _lastUpdateFrame = -1;
  awake() {
    super.awake(), this._lastUpdateFrame = -1, this._parentRectTransform = void 0, this.rectBlock = new M(), this.rectBlock.name = this.name, this.lastMatrix = new ee(), this._lastAnchoring = null, this._initialPosition = this.gameObject.position.clone(), this._initialPosition.z = 0, this._anchoredPosition || (this._anchoredPosition = new J()), Vr(this, "_anchoredPosition", () => {
      this.markDirty();
    }), Vr(this, "sizeDelta", () => {
      this.markDirty();
    }), Vr(this, "pivot", () => {
      this.markDirty();
    }), Vr(this, "anchorMin", () => {
      this.markDirty();
    }), Vr(this, "anchorMax", () => {
      this.markDirty();
    });
  }
  onEnable() {
    super.onEnable(), this.rectBlock || (this.rectBlock = new M()), this.lastMatrix || (this.lastMatrix = new ee()), this._lastAnchoring || (this._lastAnchoring = new J()), this._initialPosition || (this._initialPosition = new y()), this._anchoredPosition || (this._anchoredPosition = new J()), this.addShadowComponent(this.rectBlock), this._transformNeedsUpdate = !0, this.canvas?.registerTransform(this);
  }
  onDisable() {
    super.onDisable(), this.removeShadowComponent(), this.canvas?.unregisterTransform(this);
  }
  onParentRectTransformChanged(e) {
    this._transformNeedsUpdate || this.onApplyTransform(Qf ? `${e.name} changed` : void 0);
  }
  get isDirty() {
    return this._transformNeedsUpdate || (this._transformNeedsUpdate = !this.lastMatrix.equals(this.gameObject.matrix)), this._transformNeedsUpdate;
  }
  // private _copyMatrixAfterRender: boolean = false;
  markDirty() {
    this._transformNeedsUpdate || (Qf && console.warn("RectTransform markDirty()", this.name), this._transformNeedsUpdate = !0, this._lastUpdateFrame = -1);
  }
  /** Will update the transforms if it changed or is dirty */
  updateTransform() {
    (this._transformNeedsUpdate || !this.lastMatrix.equals(this.gameObject.matrix)) && this.canUpdate() && this.onApplyTransform(this._transformNeedsUpdate ? "Marked dirty" : "Matrix changed");
  }
  canUpdate() {
    return this._transformNeedsUpdate && this.activeAndEnabled && this._lastUpdateFrame !== this.context.time.frame;
  }
  onApplyTransform(e) {
    if (this.context.time.frameCount === this._lastUpdateFrame) return;
    this._lastUpdateFrame = this.context.time.frameCount;
    const t = this.shadowComponent;
    if (!t) return;
    this.gameObject.parent ? this._parentRectTransform = S.getComponentInParent(this.gameObject.parent, tw) : this._parentRectTransform = void 0, this._transformNeedsUpdate = !1, Qf && console.warn("RectTransform → ApplyTransform", this.name + " because " + e), this.isRoot() ? this.Root.screenspace || (t.rotation.y = Math.PI) : (t.matrix.identity(), t.matrixAutoUpdate = !1, sn.set(0, 0, 0), this.applyPivot(sn), t.matrix.setPosition(sn.x, sn.y, 0), (this.gameObject.quaternion.x || this.gameObject.quaternion.y || this.gameObject.quaternion.z) && (Oh.copy(this.gameObject.quaternion), Oh.x *= -1, Oh.z *= -1, _l.makeRotationFromQuaternion(Oh), t.matrix.premultiply(_l)), sn.set(0, 0, 0), this.applyAnchoring(sn), this.canvas?.screenspace ? sn.z += 0.1 : sn.z += 0.01, _l.identity(), _l.setPosition(sn.x, sn.y, sn.z), t.matrix.premultiply(_l), t.matrix.scale(this.gameObject.scale)), this.lastMatrix.copy(this.gameObject.matrix);
    const i = !0;
    for (const n of Km(this.gameObject, un, i, 1)) {
      if (n === this || !n.activeAndEnabled) continue;
      const o = n;
      o.onParentRectTransformChanged && o.onParentRectTransformChanged(this);
    }
  }
  // onAfterRender() {
  //     if (this._copyMatrixAfterRender) {
  //         // can we only have this event when the transform changed in this frame? Otherwise all RectTransforms will be iterated. Not sure what is better
  //         this.lastMatrixWorld.copy(this.gameObject.matrixWorld);
  //     }
  // }
  _lastAnchoring;
  /** applies the position offset to the passed in vector */
  applyAnchoring(e) {
    this._lastAnchoring || (this._lastAnchoring = new J());
    const t = this._lastAnchoring.sub(this._anchoredPosition);
    this.gameObject.position.x += t.x, this.gameObject.position.y += t.y, this._lastAnchoring.copy(this._anchoredPosition), e.x += this._initialPosition.x - this.gameObject.position.x, e.y += this._initialPosition.y - this.gameObject.position.y, e.z += this._initialPosition.z - this.gameObject.position.z;
    const i = this._parentRectTransform;
    if (i) {
      let n = 0;
      const o = 1 - this.anchorMax.y - this.anchorMin.y;
      n -= i.height * 0.5 * o, e.y += n;
      let r = 0;
      const a = 1 - this.anchorMax.x - this.anchorMin.x;
      r -= i.width * 0.5 * a, e.x += r;
    }
  }
  /** applies the pivot offset to the passed in vector */
  applyPivot(e) {
    if (this.pivot && !this.isRoot()) {
      const t = this.pivot.x - 0.5;
      e.x -= t * this.sizeDelta.x * this.gameObject.scale.x;
      const i = this.pivot.y - 0.5;
      e.y -= i * this.sizeDelta.y * this.gameObject.scale.y;
    }
  }
  getBasicOptions() {
    const e = {
      width: this.sizeDelta.x,
      height: this.sizeDelta.y,
      // * this.context.mainCameraComponent!.aspect,
      offset: 0,
      backgroundOpacity: 0,
      borderWidth: 0,
      // if we dont specify width here a border will automatically propagated to child blocks
      borderRadius: 0,
      borderOpacity: 0,
      letterSpacing: -0.03
      // justifyContent: 'center',
      // alignItems: 'center',
      // alignContent: 'center',
      // backgroundColor: new Color(1, 1, 1),
    };
    return this.ensureValidSize(e), e;
  }
  // e.g. when a transform has the size 0,0 we still want to render the text
  ensureValidSize(e, t = 1e-4) {
    return e.width <= 0 && (e.width = t), e.height <= 0 && (e.height = 1e-4), e;
  }
  _createdBlocks = [];
  _createdTextBlocks = [];
  createNewBlock(e) {
    e = {
      ...this.getBasicOptions(),
      ...e
    }, Xf && console.log(this.name, e);
    const t = new Wb(e);
    return this._createdBlocks.push(t), t;
  }
  createNewText(e) {
    Xf && console.log(e), e = {
      ...this.getBasicOptions(),
      ...e
    }, Xf && console.log(this.name, e);
    const t = new $b(e);
    return this._createdTextBlocks.push(t), t;
  }
};
Lc([
  u(J)
], Va.prototype, "anchoredPosition", 1);
Lc([
  u(J)
], Va.prototype, "sizeDelta", 2);
Lc([
  u(J)
], Va.prototype, "pivot", 2);
Lc([
  u(J)
], Va.prototype, "anchorMin", 2);
Lc([
  u(J)
], Va.prototype, "anchorMax", 2);
let Un = Va;
var XR = Object.defineProperty, iw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && XR(e, t, n), n;
};
class Dc extends R {
  effectColor;
  effectDistance;
}
iw([
  u(oe)
], Dc.prototype, "effectColor");
iw([
  u(J)
], Dc.prototype, "effectDistance");
var QR = Object.defineProperty, YR = Object.getOwnPropertyDescriptor, nw = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? YR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && QR(e, t, n), n;
};
const kh = {
  backgroundColor: new se(1, 1, 1),
  backgroundOpacity: 1,
  borderColor: new se(1, 1, 1),
  borderOpacity: 1
}, Rg = class jl extends un {
  get isGraphic() {
    return !0;
  }
  get color() {
    return this._color || (this._color = new oe(1, 1, 1, 1)), this._color;
  }
  set color(e) {
    (!this._color || this._color.r !== e.r || this._color.g !== e.g || this._color.b !== e.b || this._color.alpha !== e.alpha) && (this._color || (this._color = new oe(1, 1, 1, 1)), this._color.copy(e), this.onColorChanged());
  }
  _alphaFactor = 1;
  setAlphaFactor(e) {
    this._alphaFactor = e, this.onColorChanged();
  }
  get alphaFactor() {
    return this._alphaFactor;
  }
  sRGBColor = new se(1, 0, 1);
  onColorChanged() {
    this.uiObject && (this.sRGBColor.copy(this._color), this.sRGBColor.convertLinearToSRGB(), kh.backgroundColor = this.sRGBColor, kh.backgroundOpacity = this._color.alpha * this._alphaFactor, this.applyEffects(kh, this._alphaFactor), this.uiObject.set(kh), this.markDirty());
  }
  // used via animations
  get m_Color() {
    return this._color;
  }
  raycastTarget = !0;
  uiObject = null;
  _color = null;
  _rect = null;
  _stateManager = null;
  get rectTransform() {
    if (this._rect || (this._rect = S.getComponent(this.gameObject, Un)), !this._rect) throw new Error("Not Supported: Make sure to add a RectTransform component before adding a UI Graphic component.");
    return this._rect;
  }
  onParentRectTransformChanged() {
    this.uiObject?.set({ width: this.rectTransform.width, height: this.rectTransform.height }), this.markDirty();
  }
  __internalNewInstanceCreated(e) {
    return super.__internalNewInstanceCreated(e), this._rect = null, this.uiObject = null, this._stateManager = null, this._color && (this._color = this._color.clone()), this;
  }
  setState(e) {
    this.makePanel(), this.uiObject && (this.uiObject.setState(e), this?.markDirty());
  }
  setupState(e) {
    this.makePanel(), this.uiObject && (this._stateManager || (this._stateManager = new sC(this.uiObject)), this.uiObject.setupState(e.state, e.attributes));
  }
  setOptions(e) {
    this.makePanel(), this.uiObject && this.uiObject.set(e);
  }
  awake() {
    super.awake(), this.makePanel(), Vr(this, "_color", () => kk(this, this.onColorChanged));
  }
  onEnable() {
    super.onEnable(), this.uiObject && (this.rectTransform.shadowComponent?.add(this.uiObject), this.addShadowComponent(this.uiObject, this.rectTransform));
  }
  onDisable() {
    super.onDisable(), this.uiObject && this.removeShadowComponent();
  }
  _currentlyCreatingPanel = !1;
  makePanel() {
    if (this.uiObject || this._currentlyCreatingPanel) return;
    this._currentlyCreatingPanel = !0;
    const t = {
      backgroundColor: this.color,
      backgroundOpacity: this.color.alpha,
      offset: 0.015
      // without a tiny offset we get z fighting
    };
    this.onBeforeCreate(t), this.applyEffects(t), this.onCreate(t), this.controlsChildLayout = !1, this._currentlyCreatingPanel = !1, this.onAfterCreated(), this.onColorChanged();
  }
  onBeforeCreate(e) {
  }
  onCreate(e) {
    this.uiObject = this.rectTransform.createNewBlock(e), this.uiObject.name = this.name;
  }
  onAfterCreated() {
  }
  applyEffects(e, t = 1) {
    const i = this.gameObject?.getComponent(Dc);
    i && (i.effectDistance && (e.borderWidth = Math.max(Math.abs(i.effectDistance.x), Math.abs(i.effectDistance.y))), i.effectColor && (e.borderColor = i.effectColor, e.borderOpacity = i.effectColor.alpha * t));
  }
  /** used internally to ensure textures assigned to UI use linear encoding */
  static textureCache = /* @__PURE__ */ new Map();
  async setTexture(e) {
    if (this.setOptions({ backgroundOpacity: 0 }), e) {
      if (jl.textureCache.has(e))
        e = jl.textureCache.get(e);
      else if (!e.isRenderTargetTexture) {
        const t = e.clone();
        t.colorSpace = Ss, jl.textureCache.set(e, t), e = t;
      }
      this.setOptions({ backgroundImage: e, borderRadius: 0, backgroundOpacity: this.color.alpha, backgroundSize: "stretch" }), We.assignTextureLOD(e, 0).then((t) => {
        t instanceof Te && (e && jl.textureCache.set(e, t), this.setOptions({ backgroundImage: t }), this.markDirty());
      });
    } else
      this.setOptions({ backgroundImage: void 0, borderRadius: 0, backgroundOpacity: this.color.alpha });
    this.markDirty();
  }
  onAfterAddedToScene() {
    super.onAfterAddedToScene(), this.shadowComponent && (this.shadowComponent.offset = this.shadowComponent.position.z);
  }
};
nw([
  u(oe)
], Rg.prototype, "color", 1);
nw([
  u()
], Rg.prototype, "raycastTarget", 2);
let Ou = Rg;
class ku extends Ou {
  _flippedObject = !1;
  onAfterCreated() {
    this.uiObject && !this._flippedObject && (this._flippedObject = !0, this.uiObject.scale.y *= -1);
  }
}
var KR = Object.defineProperty, ZR = Object.getOwnPropertyDescriptor, Is = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? ZR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && KR(e, t, n), n;
};
const Fo = w("debugtext");
var it = /* @__PURE__ */ ((s) => (s[s.UpperLeft = 0] = "UpperLeft", s[s.UpperCenter = 1] = "UpperCenter", s[s.UpperRight = 2] = "UpperRight", s[s.MiddleLeft = 3] = "MiddleLeft", s[s.MiddleCenter = 4] = "MiddleCenter", s[s.MiddleRight = 5] = "MiddleRight", s[s.LowerLeft = 6] = "LowerLeft", s[s.LowerCenter = 7] = "LowerCenter", s[s.LowerRight = 8] = "LowerRight", s))(it || {}), sw = /* @__PURE__ */ ((s) => (s[s.Normal = 0] = "Normal", s[s.Bold = 1] = "Bold", s[s.Italic = 2] = "Italic", s[s.BoldAndItalic = 3] = "BoldAndItalic", s))(sw || {});
class Xt extends Ou {
  alignment = 0;
  verticalOverflow = 0;
  horizontalOverflow = 0;
  lineSpacing = 1;
  supportRichText = !1;
  font;
  fontStyle = 0;
  // private _alphaFactor : number = 1;
  setAlphaFactor(e) {
    super.setAlphaFactor(e), this.uiObject?.set({ fontOpacity: this.color.alpha * this.alphaFactor }), this.markDirty();
  }
  get text() {
    return this._text;
  }
  set text(e) {
    e !== this._text && (this._text = e, this.feedText(this.text, this.supportRichText), this.markDirty());
  }
  set_text(e) {
    this.text = e;
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(e) {
    this._fontSize = e, this.uiObject?.set({ fontSize: e });
  }
  sRGBTextColor = new se(1, 0, 1);
  onColorChanged() {
    this.sRGBTextColor.copy(this.color), this.sRGBTextColor.convertLinearToSRGB(), this.uiObject?.set({ color: this.sRGBTextColor, fontOpacity: this.color.alpha });
  }
  onParentRectTransformChanged() {
    super.onParentRectTransformChanged(), this.uiObject && this.updateOverflow();
  }
  // onBeforeRender(): void {
  //     // TODO TMUI @swingingtom this is so we don't have text clipping
  //     if (this.uiObject && (this.Canvas?.screenspace || this.context.isInVR)) {
  //         this.updateOverflow();
  //     }
  // }
  onBeforeCanvasRender(e) {
    this.updateOverflow();
  }
  updateOverflow() {
    const e = this.uiObject?._overflow;
    e && (e._needsUpdate = !0);
  }
  onCreate(e) {
    Fo && console.log(this), this.horizontalOverflow == 1 && (e.whiteSpace = "pre"), this.verticalOverflow == 0 && (this.context.renderer.localClippingEnabled = !0, e.overflow = "hidden"), this.horizontalOverflow == 1 && this.verticalOverflow == 0, e.lineHeight = this.lineSpacing, delete e.backgroundOpacity, delete e.backgroundColor, Fo && (e.backgroundColor = 16750848, e.backgroundOpacity = 0.5);
    const t = this.rectTransform;
    e = { ...e, ...this.getTextOpts() }, this.getAlignment(e), Fo && (e.backgroundColor = Math.random() * 16777215, e.backgroundOpacity = 0.1), this.uiObject = t.createNewText(e), this.feedText(this.text, this.supportRichText);
  }
  onAfterAddedToScene() {
    super.onAfterAddedToScene(), this.handleTextRenderOnTop();
  }
  _text = "";
  _fontSize = 12;
  _textMeshUi = null;
  getTextOpts() {
    const e = this.fontSize, t = {
      color: this.color,
      fontOpacity: this.color.alpha,
      fontSize: e,
      fontKerning: "normal"
    };
    return this.setFont(t, this.fontStyle), t;
  }
  onEnable() {
    super.onEnable(), this._didHandleTextRenderOnTop = !1, this.uiObject && this.uiObject.addAfterUpdate(() => {
      this.setShadowComponentOwner(this.uiObject), this.markDirty();
    }), setTimeout(() => this.markDirty(), 10), this.canvas?.registerEventReceiver(this);
  }
  onDisable() {
    super.onDisable(), this.canvas?.unregisterEventReceiver(this);
  }
  getAlignment(e) {
    switch (e.flexDirection = "column", this.alignment) {
      case 0:
      case 3:
      case 6:
        e.textAlign = "left";
        break;
      case 1:
      case 4:
      case 7:
        e.textAlign = "center";
        break;
      case 2:
      case 5:
      case 8:
        e.textAlign = "right";
        break;
    }
    switch (this.alignment) {
      default:
      case 0:
      case 1:
      case 2:
        e.alignItems = "start";
        break;
      case 3:
      case 4:
      case 5:
        e.alignItems = "center";
        break;
      case 6:
      case 7:
      case 8:
        e.alignItems = "end";
        break;
    }
    return e;
  }
  feedText(e, t) {
    if (Fo && console.log("feedText", this.uiObject, e, t), !!this.uiObject)
      if (this._textMeshUi || (this._textMeshUi = []), this.uiObject.children.length = 0, !t || e.length === 0)
        this.uiObject.textContent = e;
      else {
        let i = this.getNextTag(e);
        if (i) {
          if (i.startIndex > 0) {
            for (let r = this.uiObject.children.length - 1; r >= 0; r--) {
              const a = this.uiObject.children[r];
              a.isUI && (this.uiObject.remove(a), a.clear());
            }
            const o = new sf({ textContent: e.substring(0, i.startIndex), color: "inherit" });
            this.uiObject.add(o);
          }
        } else {
          this.uiObject.textContent = "", this.setOptions({ textContent: e });
          return;
        }
        const n = [];
        for (; i; ) {
          const o = this.getNextTag(e, i.endIndex), r = {
            fontFamily: this.uiObject?.get("fontFamily"),
            color: "inherit",
            textContent: ""
          };
          if (o) {
            r.textContent = this.getText(e, i, o), this.handleTag(i, r, n);
            const a = new sf(r);
            this.uiObject?.add(a);
          } else {
            r.textContent = e.substring(i.endIndex), this.handleTag(i, r, n);
            const a = new sf(r);
            this.uiObject?.add(a);
          }
          i = o;
        }
      }
  }
  _didHandleTextRenderOnTop = !1;
  handleTextRenderOnTop() {
    this._didHandleTextRenderOnTop || (this._didHandleTextRenderOnTop = !0, this.startCoroutine(this.renderOnTopCoroutine()));
  }
  // waits for all the text objects to be ready to set the render on top setting
  // @THH :  this isn't true anymore. We can set mesh and material properties before their counterparts are created.
  //         Values would automatically be passed when created. Not sure for depthWrite but it can be added;
  *renderOnTopCoroutine() {
    if (!this.canvas) return;
    const e = [], t = this.canvas, i = {
      renderOnTop: t.renderOnTop,
      depthWrite: t.depthWrite,
      doubleSided: t.doubleSided
    };
    for (; ; ) {
      let n = !1;
      if (this._textMeshUi)
        for (let o = 0; o < this._textMeshUi.length; o++) {
          if (e[o] === !0) continue;
          n = !0;
          const r = this._textMeshUi[o];
          r.textContent && (xd(r, i), e[o] = !0);
        }
      if (!n) break;
      yield;
    }
  }
  handleTag(e, t, i) {
    if (!e.isEndTag) {
      if (e.type.includes("color")) {
        const n = new Yf(e, { color: t.color });
        if (i.push(n), e.type.length > 6) {
          const o = parseInt("0x" + e.type.substring(7));
          t.color = o;
        } else
          t.color = new se(1, 1, 1);
      } else if (e.type == "b") {
        this.setFont(
          t,
          1
          /* Bold */
        );
        const n = new Yf(e, {
          fontWeight: 700
        });
        i.push(n);
      } else if (e.type == "i") {
        this.setFont(
          t,
          2
          /* Italic */
        );
        const n = new Yf(e, {
          fontStyle: "italic"
        });
        i.push(n);
      }
    }
  }
  getText(e, t, i) {
    return e.substring(t.endIndex, i.startIndex);
  }
  getNextTag(e, t = 0) {
    const i = e.indexOf("<", t), n = e.indexOf(">", i);
    if (i >= 0 && n >= 0) {
      const o = e.substring(i + 1, n);
      return { type: o, startIndex: i, endIndex: n + 1, isEndTag: o.startsWith("/") };
    }
    return null;
  }
  /**
   * Update provided opts to have a proper fontDefinition : family+weight+style
   * Ensure Family and Variant are registered in FontLibrary
   *
   * @param opts
   * @param fontStyle
   * @private
   */
  setFont(e, t) {
    if (!this.font) return;
    const i = this.font, n = this.getFamilyNameWithCorrectSuffix(i, t);
    Fo && console.log("Selected font family:" + n);
    let o = my.getFontFamily(n);
    switch (o || (o = my.addFontFamily(n)), e.fontFamily = o, t) {
      default:
      case 0:
        e.fontWeight = 400, e.fontStyle = "normal";
        break;
      case 1:
        e.fontWeight = 700, e.fontStyle = "normal";
        break;
      case 2:
        e.fontWeight = 400, e.fontStyle = "italic";
        break;
      case 3:
        e.fontStyle = "italic", e.fontWeight = 400;
    }
    let r = o.getVariant(e.fontWeight, e.fontStyle);
    if (!r) {
      let a = n;
      a?.endsWith("-msdf.json") || (a += "-msdf.json");
      let l = n;
      l?.endsWith(".png") || (l += ".png"), r = o.addVariant(e.fontWeight, e.fontStyle, a, l), r?.addEventListener("ready", () => {
        this.markDirty();
      });
    }
  }
  getFamilyNameWithCorrectSuffix(e, t) {
    const i = e.lastIndexOf("-");
    if (i < 0) return e;
    const n = e.substring(i + 1)?.toLowerCase();
    if (JR.includes(n))
      return Fo && console.warn("Unsupported font style: " + n), e;
    const o = e.lastIndexOf("/");
    let r = e;
    o >= 0 && (r = r.substring(o + 1));
    const a = r[0] === r[0].toUpperCase(), l = e.substring(0, i);
    switch (Fo && console.log("Select font: ", e, sw[t], r, a, l), t) {
      case 0:
        return a ? l + "-Regular" : l + "-regular";
      case 1:
        return a ? l + "-Bold" : l + "-bold";
      case 2:
        return a ? l + "-Italic" : l + "-italic";
      case 3:
        return a ? l + "-BoldItalic" : l + "-bolditalic";
      default:
        return e;
    }
  }
}
Is([
  u()
], Xt.prototype, "alignment", 2);
Is([
  u()
], Xt.prototype, "verticalOverflow", 2);
Is([
  u()
], Xt.prototype, "horizontalOverflow", 2);
Is([
  u()
], Xt.prototype, "lineSpacing", 2);
Is([
  u()
], Xt.prototype, "supportRichText", 2);
Is([
  u(URL)
], Xt.prototype, "font", 2);
Is([
  u()
], Xt.prototype, "fontStyle", 2);
Is([
  u()
], Xt.prototype, "text", 1);
Is([
  u()
], Xt.prototype, "fontSize", 1);
class Yf {
  tag;
  previousValues;
  constructor(e, t) {
    this.tag = e, this.previousValues = t;
  }
}
const JR = [
  "medium",
  "mediumitalic",
  "black",
  "blackitalic",
  "thin",
  "thinitalic",
  "extrabold",
  "light",
  "lightitalic",
  "semibold"
];
class Bl {
  static global_id = 0;
  static getId() {
    return this.global_id++;
  }
  id;
  content = "";
  font = [];
  pointSize = 144;
  width;
  height;
  depth;
  wrapMode;
  horizontalAlignment;
  verticalAlignment;
  material;
  setDepth(e) {
    return this.depth = e, this;
  }
  setPointSize(e) {
    return this.pointSize = e, this;
  }
  setHorizontalAlignment(e) {
    return this.horizontalAlignment = e, this;
  }
  setVerticalAlignment(e) {
    return this.verticalAlignment = e, this;
  }
  constructor(e) {
    this.id = e;
  }
  writeTo(e, t) {
    t.beginBlock(`def Preliminary_Text "${this.id}"`, "(", !1), t.appendLine('prepend apiSchemas = ["MaterialBindingAPI"]'), t.closeBlock(")"), t.beginBlock(), this.content && t.appendLine(`string content = "${this.content}"`), (!this.font || this.font.length <= 0) && (this.font ||= [], this.font?.push("sans-serif"));
    const i = this.font.map((n) => `"${n}"`).join(", ");
    t.appendLine(`string[] font = [ ${i} ]`), t.appendLine(`double pointSize = ${this.pointSize}`), typeof this.width == "number" && t.appendLine(`double width = ${this.width}`), typeof this.height == "number" && t.appendLine(`double height = ${this.height}`), typeof this.depth == "number" && t.appendLine(`double depth = ${this.depth}`), this.wrapMode && t.appendLine(`token wrapMode = "${this.wrapMode}"`), this.horizontalAlignment && t.appendLine(`token horizontalAlignment = "${this.horizontalAlignment}"`), this.verticalAlignment && t.appendLine(`token verticalAlignment = "${this.verticalAlignment}"`), this.material !== void 0 && t.appendLine(`rel material:binding = </StageRoot/Materials/${_u(this.material)}>`), t.closeBlock();
  }
}
class ow {
  static singleLine(e, t, i) {
    const n = new Bl("text_" + Bl.getId());
    return n.content = e, t && (n.pointSize = t), i && (n.depth = i), n;
  }
  static multiLine(e, t, i, n, o, r) {
    const a = new Bl("text_" + Bl.getId());
    return a.content = e, a.width = t, a.height = i, a.horizontalAlignment = n, a.verticalAlignment = o, r !== void 0 && (a.wrapMode = r), a;
  }
}
const eT = new ee().makeRotationY(Math.PI), tT = new ee().makeScale(-1, 1, -1);
class Tg {
  get extensionName() {
    return "text";
  }
  exportText(e, t, i) {
    const n = S.getComponent(e, Xt);
    if (!n) return;
    const o = S.getComponent(e, Un);
    let r = 100, a = 100;
    o && (r = o.width, a = o.height);
    const l = eT.clone();
    o && l.premultiply(tT), t.setMatrix(l);
    const c = n.color.clone();
    t.material = new ut({ color: c, emissive: c }), t.addEventListener("serialize", (h, d) => {
      let f = n.text;
      f = f.replace(/\r/g, ""), f = f.replace(/\n/g, "\\n");
      const p = ow.multiLine(
        f,
        r,
        a,
        "center",
        "bottom",
        "flowing"
        /* flowing */
      );
      this.setTextAlignment(p, n.alignment), this.setOverflow(p, n), t.material && (p.material = t.material), p.pointSize = this.convertToTextSize(n.fontSize), p.depth = 1e-3, p.writeTo(void 0, h);
    });
  }
  convertToTextSize(e) {
    return 1 / 0.0502 * 144 * e;
  }
  setOverflow(e, t) {
    t.horizontalOverflow ? e.wrapMode = "singleLine" : e.wrapMode = "flowing";
  }
  setTextAlignment(e, t) {
    switch (t) {
      case it.LowerLeft:
      case it.MiddleLeft:
      case it.UpperLeft:
        e.horizontalAlignment = "left";
        break;
      case it.LowerCenter:
      case it.MiddleCenter:
      case it.UpperCenter:
        e.horizontalAlignment = "center";
        break;
      case it.LowerRight:
      case it.MiddleRight:
      case it.UpperRight:
        e.horizontalAlignment = "right";
        break;
    }
    switch (t) {
      case it.LowerLeft:
      case it.LowerCenter:
      case it.LowerRight:
        e.verticalAlignment = "bottom";
        break;
      case it.MiddleLeft:
      case it.MiddleCenter:
      case it.MiddleRight:
        e.verticalAlignment = "middle";
        break;
      case it.UpperLeft:
      case it.UpperCenter:
      case it.UpperRight:
        e.verticalAlignment = "top";
        break;
    }
  }
}
var iT = Object.defineProperty, Ye = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && iT(e, t, n), n;
};
const Y_ = w("debuguilayout");
class Ha {
  left = 0;
  right = 0;
  top = 0;
  bottom = 0;
  get vertical() {
    return this.top + this.bottom;
  }
  get horizontal() {
    return this.left + this.right;
  }
}
Ye([
  u()
], Ha.prototype, "left");
Ye([
  u()
], Ha.prototype, "right");
Ye([
  u()
], Ha.prototype, "top");
Ye([
  u()
], Ha.prototype, "bottom");
class Oi extends R {
  _rectTransform = null;
  get rectTransform() {
    return this._rectTransform;
  }
  onParentRectTransformChanged(e) {
    this._needsUpdate = !0;
  }
  _needsUpdate = !1;
  get isDirty() {
    return this._needsUpdate;
  }
  get isLayoutGroup() {
    return !0;
  }
  updateLayout() {
    this._rectTransform && (Y_ && console.warn("Layout Update", this.context.time.frame, this.name), this._needsUpdate = !1, this.onCalculateLayout(this._rectTransform));
  }
  childAlignment = 0;
  reverseArrangement = !1;
  spacing = 0;
  padding;
  minWidth = 0;
  minHeight = 0;
  flexibleHeight = 0;
  flexibleWidth = 0;
  preferredHeight = 0;
  preferredWidth = 0;
  start() {
    this._needsUpdate = !0;
  }
  onEnable() {
    Y_ && console.log(this.name, this), this._rectTransform = this.gameObject.getComponent(Un);
    const e = this.gameObject.getComponentInParent(bc);
    e && e.registerLayoutGroup(this), this._needsUpdate = !0;
  }
  onDisable() {
    const e = this.gameObject.getComponentInParent(bc);
    e && e.unregisterLayoutGroup(this);
  }
  // for animation:
  set m_Spacing(e) {
    e !== this.spacing && (this._needsUpdate = !0, this.spacing = e);
  }
  get m_Spacing() {
    return this.spacing;
  }
}
Ye([
  u()
], Oi.prototype, "childAlignment");
Ye([
  u()
], Oi.prototype, "reverseArrangement");
Ye([
  u()
], Oi.prototype, "spacing");
Ye([
  u(Ha)
], Oi.prototype, "padding");
Ye([
  u()
], Oi.prototype, "minWidth");
Ye([
  u()
], Oi.prototype, "minHeight");
Ye([
  u()
], Oi.prototype, "flexibleHeight");
Ye([
  u()
], Oi.prototype, "flexibleWidth");
Ye([
  u()
], Oi.prototype, "preferredHeight");
Ye([
  u()
], Oi.prototype, "preferredWidth");
class So extends Oi {
  childControlHeight = !0;
  childControlWidth = !0;
  childForceExpandHeight = !1;
  childForceExpandWidth = !1;
  childScaleHeight = !1;
  childScaleWidth = !1;
  onCalculateLayout(e) {
    const t = this.primaryAxis, i = e.width;
    let n = i;
    const o = e.height;
    let r = o;
    n -= this.padding.horizontal, r -= this.padding.vertical, t === "x" ? this.padding.horizontal : this.padding.vertical;
    const a = t === "x", l = a ? "y" : "x", c = a ? this.childControlWidth : this.childControlHeight, h = a ? this.childControlHeight : this.childControlWidth, d = a ? this.childForceExpandWidth : this.childForceExpandHeight, f = a ? this.childForceExpandHeight : this.childForceExpandWidth, p = a ? r : n, g = a ? i : o, b = 0.5 * (a ? this.childAlignment % 3 : Math.floor(this.childAlignment / 3));
    let m = 0;
    a ? m += this.padding.left : m += this.padding.top;
    let v = 0, _ = 0;
    for (let E = 0; E < this.gameObject.children.length; E++) {
      const B = this.gameObject.children[E], D = S.getComponent(B, Un);
      D?.activeAndEnabled && (_ += 1, a ? v += D.width : v += D.height);
    }
    let x = 0;
    const I = this.spacing * (_ - 1);
    if (d || c) {
      let E = 0;
      a ? E = n -= I : E = r -= I, _ > 0 && (x = E / _);
    }
    let O = 0;
    O += this.padding.left, O -= this.padding.right, b !== 0 && (m = g - v, m *= b, m -= I * b, a ? (m -= this.padding.right * b, m += this.padding.left * (1 - b), m < this.padding.left && (m = this.padding.left)) : (m -= this.padding.bottom * b, m += this.padding.top * (1 - b), m < this.padding.top && (m = this.padding.top)));
    let k = 1;
    for (let E = 0; E < this.gameObject.children.length; E++) {
      const B = this.gameObject.children[E], D = S.getComponent(B, Un);
      if (D?.activeAndEnabled) {
        D.pivot?.set(0.5, 0.5), D.anchorMin.set(0, 1), D.anchorMax.set(0, 1);
        const W = i * 0.5 + O * 0.5;
        D.anchoredPosition.x !== W && (D.anchoredPosition.x = W);
        const X = o * -0.5;
        D.anchoredPosition.y !== X && (D.anchoredPosition.y = X), f && h && D.sizeDelta[l] !== p && (D.sizeDelta[l] = p), d && c && D.sizeDelta[t] !== x && (D.sizeDelta[t] = x);
        const A = a ? D.width : D.height, $ = A * 0.5;
        if (m += $, d) {
          const ne = x * k - x * 0.5;
          ne > m && (m = ne - x * 0.5 + A + this.padding.left, m -= $);
        }
        let V = m;
        t === "y" && (V = -V), D.anchoredPosition[t] !== V && (D.anchoredPosition[t] = V), m += $, m += this.spacing, k += 1;
      }
    }
  }
}
Ye([
  u()
], So.prototype, "childControlHeight");
Ye([
  u()
], So.prototype, "childControlWidth");
Ye([
  u()
], So.prototype, "childForceExpandHeight");
Ye([
  u()
], So.prototype, "childForceExpandWidth");
Ye([
  u()
], So.prototype, "childScaleHeight");
Ye([
  u()
], So.prototype, "childScaleWidth");
class rw extends So {
  get primaryAxis() {
    return "y";
  }
}
class aw extends So {
  get primaryAxis() {
    return "x";
  }
}
class lw extends Oi {
  onCalculateLayout() {
  }
}
var nT = Object.defineProperty, sT = Object.getOwnPropertyDescriptor, Vn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? sT(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && nT(e, t, n), n;
}, cw = /* @__PURE__ */ ((s) => (s[s.ScreenSpaceOverlay = 0] = "ScreenSpaceOverlay", s[s.ScreenSpaceCamera = 1] = "ScreenSpaceCamera", s[s.WorldSpace = 2] = "WorldSpace", s[s.Undefined = -1] = "Undefined", s))(cw || {});
const Kf = w("debuguilayout"), Ki = class hw extends Pu {
  get isCanvas() {
    return !0;
  }
  get screenspace() {
    return this.renderMode !== 2;
  }
  set renderOnTop(e) {
    e !== this._renderOnTop && (this._renderOnTop = e, this.onRenderSettingsChanged());
  }
  get renderOnTop() {
    return this._renderOnTop !== void 0 ? this._renderOnTop : !!(this.screenspace && this._renderMode === 0);
  }
  _renderOnTop;
  set depthWrite(e) {
    this._depthWrite !== e && (this._depthWrite = e, this.onRenderSettingsChanged());
  }
  get depthWrite() {
    return this._depthWrite;
  }
  _depthWrite = !1;
  set doubleSided(e) {
    this._doubleSided !== e && (this._doubleSided = e, this.onRenderSettingsChanged());
  }
  get doubleSided() {
    return this._doubleSided;
  }
  _doubleSided = !0;
  set castShadows(e) {
    this._castShadows !== e && (this._castShadows = e, this.onRenderSettingsChanged());
  }
  get castShadows() {
    return this._castShadows;
  }
  _castShadows = !1;
  set receiveShadows(e) {
    this._receiveShadows !== e && (this._receiveShadows = e, this.onRenderSettingsChanged());
  }
  get receiveShadows() {
    return this._receiveShadows;
  }
  _receiveShadows = !1;
  get renderMode() {
    return this._renderMode;
  }
  set renderMode(e) {
    this._renderMode !== e && (this._renderMode = e, this.onRenderSettingsChanged());
  }
  _renderMode = -1;
  _rootCanvas;
  set rootCanvas(e) {
    this._rootCanvas instanceof hw || (this._rootCanvas = e);
  }
  get rootCanvas() {
    return this._rootCanvas;
  }
  _scaleFactor = 1;
  get scaleFactor() {
    return this._scaleFactor;
  }
  set scaleFactor(e) {
    this._scaleFactor = e;
  }
  worldCamera;
  planeDistance = -1;
  awake() {
    this.shadowComponent = this.gameObject, this.previousParent = this.gameObject.parent, Kf && console.log("Canvas.Awake()", this.previousParent?.name + "/" + this.gameObject.name), super.awake();
  }
  start() {
    this.applyRenderSettings();
  }
  onEnable() {
    super.onEnable(), this._updateRenderSettingsRoutine = void 0, this._lastMatrixWorld = new ee(), this.applyRenderSettings(), document.addEventListener("resize", this._boundRenderSettingsChanged), this.context.pre_render_callbacks.push(this.onBeforeRenderRoutine), this.context.post_render_callbacks.push(this.onAfterRenderRoutine);
  }
  onDisable() {
    super.onDisable(), document.removeEventListener("resize", this._boundRenderSettingsChanged);
    const e = this.context.pre_render_callbacks.indexOf(this.onBeforeRenderRoutine);
    e !== -1 && this.context.pre_render_callbacks.splice(e, 1);
    const t = this.context.post_render_callbacks.indexOf(this.onAfterRenderRoutine);
    t !== -1 && this.context.post_render_callbacks.splice(t, 1);
  }
  _boundRenderSettingsChanged = this.onRenderSettingsChanged.bind(this);
  previousParent = null;
  _lastMatrixWorld = null;
  _rectTransforms = [];
  registerTransform(e) {
    this._rectTransforms.push(e);
  }
  unregisterTransform(e) {
    const t = this._rectTransforms.indexOf(e);
    t !== -1 && this._rectTransforms.splice(t, 1);
  }
  _layoutGroups = /* @__PURE__ */ new Map();
  registerLayoutGroup(e) {
    const t = e.gameObject;
    this._layoutGroups.set(t, e);
  }
  unregisterLayoutGroup(e) {
    const t = e.gameObject;
    this._layoutGroups.delete(t);
  }
  _receivers = [];
  registerEventReceiver(e) {
    this._receivers.push(e);
  }
  unregisterEventReceiver(e) {
    const t = this._receivers.indexOf(e);
    t !== -1 && this._receivers.splice(t, 1);
  }
  async onEnterXR(e) {
    this.screenspace ? (e.xr.isVR || e.xr.isPassThrough) && (this.gameObject.visible = !1) : (this.gameObject.visible = !1, await Qd(1).then(() => {
      this.gameObject.visible = !0;
    }));
  }
  onLeaveXR(e) {
    this.screenspace && (e.xr.isVR || e.xr.isPassThrough) && (this.gameObject.visible = !0);
  }
  onBeforeRenderRoutine = () => {
    if (this.previousParent = this.gameObject.parent, (this.context.xr?.isVR || this.context.xr?.isPassThrough) && this.screenspace) {
      this.gameObject.visible = !1, this.gameObject.removeFromParent();
      return;
    }
    this.renderOnTop || this.screenspace ? this.gameObject.removeFromParent() : (this.onUpdateRenderMode(), this.handleLayoutUpdates(), this.shadowComponent?.updateMatrixWorld(!0), this.shadowComponent?.updateWorldMatrix(!0, !0), this.invokeBeforeRenderEvents(), ti.ensureUpdateMeshUI(gy, this.context));
  };
  onAfterRenderRoutine = () => {
    if ((this.context.xr?.isVR || this.context.xr?.isPassThrough) && this.screenspace) {
      this.previousParent?.add(this.gameObject);
      return;
    }
    if ((this.screenspace || this.renderOnTop) && this.previousParent && this.context.mainCamera) {
      this.screenspace ? this.context.mainCamera?.add(this.gameObject) : this.previousParent.add(this.gameObject);
      const e = this.context.renderer.autoClear, t = this.context.renderer.autoClearColor;
      this.context.renderer.autoClear = !1, this.context.renderer.autoClearColor = !1, this.context.renderer.clearDepth(), this.onUpdateRenderMode(!0), this.handleLayoutUpdates(), this.shadowComponent?.updateMatrixWorld(!0), this.invokeBeforeRenderEvents(), ti.ensureUpdateMeshUI(gy, this.context, !0), this.context.renderer.render(this.gameObject, this.context.mainCamera), this.context.renderer.autoClear = e, this.context.renderer.autoClearColor = t, this.previousParent.add(this.gameObject);
    }
    this._lastMatrixWorld?.copy(this.gameObject.matrixWorld);
  };
  invokeBeforeRenderEvents() {
    for (const e of this._receivers)
      e.onBeforeCanvasRender?.(this);
  }
  handleLayoutUpdates() {
    this._lastMatrixWorld === null && (this._lastMatrixWorld = new ee());
    const e = !this._lastMatrixWorld.equals(this.gameObject.matrixWorld);
    Kf && e && console.log("Canvas Layout changed", this.context.time.frameCount, this.name);
    for (const t of this._rectTransforms) {
      e && t.markDirty();
      let i = this._layoutGroups.get(t.gameObject);
      t.isDirty && !i && (i = t.gameObject.getComponentInParent(Oi)), (t.isDirty || i?.isDirty) && (Kf && console.log("CANVAS UPDATE ### " + t.name + " ##################################### " + this.context.time.frame), i?.updateLayout(), t.updateTransform());
    }
  }
  applyRenderSettings() {
    this.onRenderSettingsChanged();
  }
  _updateRenderSettingsRoutine;
  onRenderSettingsChanged() {
    this._updateRenderSettingsRoutine || (this._updateRenderSettingsRoutine = this.startCoroutine(this._updateRenderSettingsDelayed(), xe.OnBeforeRender));
  }
  *_updateRenderSettingsDelayed() {
    if (yield, this._updateRenderSettingsRoutine = void 0, this.shadowComponent) {
      this.onUpdateRenderMode(), xd(this.shadowComponent, this);
      for (const e of S.getComponentsInChildren(this.gameObject, un))
        xd(e.shadowComponent, this);
    }
  }
  _activeRenderMode = -1;
  _lastWidth = -1;
  _lastHeight = -1;
  onUpdateRenderMode(e = !1) {
    if (!e && this._renderMode === this._activeRenderMode && this._lastWidth === this.context.domWidth && this._lastHeight === this.context.domHeight)
      return;
    this._activeRenderMode = this._renderMode;
    let t = this.context.mainCameraComponent, i = 10;
    switch (t && t.nearClipPlane > 0 && t.farClipPlane > 0 && (i = j.lerp(t.nearClipPlane, t.farClipPlane, 0.01)), this._renderMode === 1 && (this.worldCamera && (t = this.worldCamera), this.planeDistance > 0 && (i = this.planeDistance)), this._renderMode) {
      case 0:
      case 1:
        if (this._lastWidth = this.context.domWidth, this._lastHeight = this.context.domHeight, !t) return;
        const n = i + 0.01;
        this.gameObject.position.x = 0, this.gameObject.position.y = 0, this.gameObject.position.z = -n, this.gameObject.quaternion.identity();
        const o = this.gameObject.getComponent(Un);
        let r = !1;
        o.sizeDelta.x !== this.context.domWidth && (r = !0), o.sizeDelta.y !== this.context.domHeight && (r = !0);
        const a = t.fieldOfView * Math.PI / 180, l = 2 * Math.tan(a / 2) * Math.abs(n);
        this.gameObject.scale.x = l / this.context.domHeight, this.gameObject.scale.y = l / this.context.domHeight, this.gameObject.scale.z = 0.01, r && (o.sizeDelta.x = this.context.domWidth, o.sizeDelta.y = this.context.domHeight, o?.markDirty());
        break;
      case 2:
        this._lastWidth = -1, this._lastHeight = -1;
        break;
    }
  }
};
Vn([
  u()
], Ki.prototype, "renderOnTop", 1);
Vn([
  u()
], Ki.prototype, "depthWrite", 1);
Vn([
  u()
], Ki.prototype, "doubleSided", 1);
Vn([
  u()
], Ki.prototype, "castShadows", 1);
Vn([
  u()
], Ki.prototype, "receiveShadows", 1);
Vn([
  u()
], Ki.prototype, "renderMode", 1);
Vn([
  u(Ki)
], Ki.prototype, "rootCanvas", 1);
Vn([
  u()
], Ki.prototype, "scaleFactor", 1);
Vn([
  u(yi)
], Ki.prototype, "worldCamera", 2);
Vn([
  u()
], Ki.prototype, "planeDistance", 2);
let bc = Ki;
var oT = Object.defineProperty, rT = Object.getOwnPropertyDescriptor, Eg = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? rT(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && oT(e, t, n), n;
};
class ur extends R {
  get alpha() {
    return this._alpha;
  }
  set alpha(e) {
    e !== this._alpha && (this._alpha = e, this.markDirty());
  }
  get isCanvasGroup() {
    return !0;
  }
  _alpha = 1;
  interactable = !0;
  blocksRaycasts = !0;
  _isDirty = !1;
  markDirty() {
    this._isDirty || (this._isDirty = !0, this.startCoroutine(this.applyChangesDelayed(), xe.OnBeforeRender));
  }
  *applyChangesDelayed() {
    this._isDirty = !1, this.applyChangesNow();
  }
  _buffer = [];
  applyChangesNow() {
    this._buffer.length = 0;
    for (const e of S.getComponentsInChildren(this.gameObject, un, this._buffer)) {
      const t = e;
      t.setAlphaFactor && t.setAlphaFactor(this._alpha);
    }
  }
}
Eg([
  u()
], ur.prototype, "alpha", 1);
Eg([
  u()
], ur.prototype, "interactable", 2);
Eg([
  u()
], ur.prototype, "blocksRaycasts", 2);
class dw {
  get extensionName() {
    return "tmui";
  }
  // TODO would probably be better to export each object instead of the entire Canvas
  // so that we don't export them twice (once as regular hierarchy, once as part of Canvas export)
  onExportObject(e, t, i) {
    const n = S.getComponent(e, bc);
    if (n && n.enabled && n.renderMode === cw.WorldSpace) {
      const o = new Tg(), r = S.getComponent(e, Un), a = S.getComponent(e, ur), l = new Array();
      if (r) {
        if (!S.isActiveSelf(e)) {
          const d = S.isActiveSelf(e);
          S.setActive(e, !0), r.onEnable(), r.updateTransform(), l.push(() => {
            r.onDisable(), S.setActive(e, d);
          });
        }
        e.traverse((d) => {
          if (!S.isActiveInHierarchy(d)) {
            const f = S.isActiveSelf(d);
            S.setActive(d, !0);
            const p = S.getComponent(d, un);
            p && (p.onEnable(), l.push(() => {
              p.onDisable();
            }));
            const g = S.getComponent(d, Un);
            g && (g.onEnable(), g.updateTransform(), g.onApplyTransform(), l.push(() => {
              g.onDisable();
            }));
            const b = S.getComponent(d, Xt);
            b && (b.onEnable(), l.push(() => {
              b.onDisable();
            })), l.push(() => {
              S.setActive(d, f);
            });
          }
        }), r.width, r.height;
        const c = st.createEmpty(), h = r.shadowComponent;
        if (t.add(c), h) {
          const d = h.matrix;
          c.setMatrix(d);
          const f = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map();
          f.set(h, c), p.set(h, a ? a.alpha : 1), h.traverse((g) => {
            if (g === h) return;
            const b = st.createEmpty();
            b.setMatrix(g.matrix);
            const m = g.parent, v = !!m && typeof m.textContent == "string" && m.textContent.length > 0;
            let _ = p.get(m) || 1;
            const x = S.getComponent(g, ur);
            if (x && (_ *= x.alpha), g instanceof G && v) {
              const O = g[pi];
              O ? o.exportText(O.gameObject, b, i) : console.error("Error when exporting UI: shadow component owner not found. This is likely a bug.", g);
            }
            if (g instanceof G && !v) {
              const O = g.geometry.clone();
              O.scale(1, 1, -1), this.flipWindingOrder(O), b.geometry = O;
              const k = new se(), E = g.material.opacity;
              k.copy(g.material.color), b.material = new we({
                color: k,
                opacity: E * _,
                map: g.material.map,
                transparent: !0
              });
            }
            f.set(g, b), p.set(g, _);
            const I = f.get(m);
            if (!I) {
              console.error("Error when exporting UI: shadow component parent not found!", g, g.parent);
              return;
            }
            I.add(b);
          });
        }
      }
      for (const c of l)
        c();
    }
  }
  flipWindingOrder(e) {
    const t = e.index.array;
    for (let i = 0, n = t.length / 3; i < n; i++) {
      const o = t[i * 3];
      t[i * 3] = t[i * 3 + 2], t[i * 3 + 2] = o;
    }
    e.index.needsUpdate = !0;
  }
}
const Fl = w("debugusdz");
function aT(s, e) {
  const t = [], i = S.getComponentsInChildren(s, kt), n = S.getComponentsInChildren(s, ni), o = new Array(), r = new Array();
  if (e.injectImplicitBehaviours)
    for (const a of i) {
      if (!a || !a.runtimeAnimatorController || !a.enabled) continue;
      const l = a.runtimeAnimatorController.activeState;
      if (!l || !l.motion || !l.motion.clip || l.motion.clip.tracks?.length < 1 || o.includes(a)) continue;
      const c = new Md();
      c.animator = a, c.stateName = l.name, c.trigger = "start", c.name = "PlayAnimationOnClick_implicitAtStart_" + c.stateName;
      const h = new M();
      S.addComponent(h, c), r.push(h), o.push(a), s.add(h);
    }
  else
    for (const a of i) {
      if (!a || !a.runtimeAnimatorController || !a.enabled) continue;
      Fl && console.log(a);
      const l = [];
      for (const c of a.runtimeAnimatorController.enumerateActions()) {
        Fl && console.log(c);
        const h = c.getClip();
        l.includes(h) || l.push(h);
      }
      t.push({ root: a.gameObject, clips: l });
    }
  if (e.injectImplicitBehaviours)
    for (const a of n) {
      if (!a || !a.clip || !a.enabled || !a.playAutomatically || o.includes(a)) continue;
      const l = new Md();
      l.animation = a, l.stateName = a.clip.name, l.trigger = "start", l.name = "PlayAnimationOnClick_implicitAtStart_" + l.stateName;
      const c = new M();
      S.addComponent(c, l), r.push(c), o.push(a), s.add(c);
    }
  else
    for (const a of n) {
      Fl && console.log(a);
      const l = [];
      for (const c of a.animations)
        l.includes(c) || l.push(c);
      t.push({ root: a.gameObject, clips: l });
    }
  Fl && t?.length > 0 && console.log("USDZ Animation Clips without behaviours", t);
  for (const a of t)
    for (const l of a.clips)
      e.registerAnimation(a.root, l);
  return r;
}
function lT(s, e) {
  const t = S.getComponentsInChildren(s, Xi), i = S.getComponentsInChildren(s, cr), n = new Array(), o = new Array();
  Fl && console.log({ audioSources: t, playAudioOnClicks: i });
  for (const r of i) {
    if (!r.target) continue;
    const a = t.indexOf(r.target);
    a > -1 && t.splice(a, 1);
  }
  for (const r of t) {
    if (!r || !r.clip || r.volume <= 0 || n.includes(r)) continue;
    const a = new cr();
    a.target = r, a.name = "PlayAudioOnClick_implicitAtStart_", a.trigger = "start";
    const l = new M();
    S.addComponent(l, a), console.log("implicit PlayAudioOnStart", l, a), o.push(l), n.push(r), s.add(l);
  }
  return o;
}
function cT(s) {
  return new It(
    "DisableAtStart",
    Gt.sceneStartTrigger(),
    me.fadeAction(s, 0, !1)
  );
}
function K_(s, e) {
  const t = s.domElement.shadowRoot.querySelector("link[rel='ar']");
  if (t) return t;
  const i = document.createElement("div");
  i.classList.add("menu"), i.classList.add("quicklook-menu"), i.style.display = "none", i.style.visibility = "hidden";
  const n = document.createElement("button");
  n.id = "open-in-ar", e ? (n.innerText = "View in AR", n.title = "View this scene in AR. The scene will be exported to USDZ and opened with Apple's QuickLook.") : (n.innerText = "View in AR", n.title = "Download this scene for AR. Open the downloaded USDZ file to view it in AR using Apple's QuickLook."), i.appendChild(n);
  const o = document.createElement("a");
  o.id = "needle-usdz-link", o.style.display = "none", o.rel = "ar", o.href = "", o.target = "_blank", i.appendChild(o);
  const r = document.createElement("img");
  return r.id = "button", o.appendChild(r), s.domElement.shadowRoot.appendChild(i), o;
}
var hT = Object.defineProperty, Mt = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && hT(e, t, n), n;
};
const ai = w("debugusdz"), dT = w("debugusdzpruning");
class Ga {
  callToAction;
  checkoutTitle;
  checkoutSubtitle;
  callToActionURL;
}
Mt([
  u()
], Ga.prototype, "callToAction");
Mt([
  u()
], Ga.prototype, "checkoutTitle");
Mt([
  u()
], Ga.prototype, "checkoutSubtitle");
Mt([
  u()
], Ga.prototype, "callToActionURL");
const ri = class zl extends R {
  static beforeExport = new ce();
  static afterExport = new ce();
  objectToExport = void 0;
  autoExportAnimations = !0;
  autoExportAudioSources = !0;
  exportFileName = void 0;
  customUsdzFile = void 0;
  customBranding;
  anchoringType = "plane";
  maxTextureSize = 2048;
  planeAnchoringAlignment = "horizontal";
  interactive = !0;
  physics = !0;
  allowCreateQuicklookButton = !0;
  quickLookCompatible = !0;
  /**
   * Extensions to add custom behaviors and interactions to the USDZ file.   
   * You can add your own extensions here by extending {@link IUSDExporterExtension}.
   */
  extensions = [];
  link;
  button;
  /** @internal */
  start() {
    ai && (console.log("USDZExporter", this), console.log("Debug USDZ Mode. Press 'T' to export"), window.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "t":
          this.exportAndOpen();
          break;
      }
    })), this.objectToExport || (this.objectToExport = this.gameObject), !this.objectToExport?.children?.length && !this.objectToExport?.isMesh && (this.objectToExport = this.context.scene);
  }
  /** @internal */
  onEnable() {
    const e = q.supportsQuickLookAR(), t = q.isiOS() || q.isiPad();
    !this.button && (ai || e || t) && (this.allowCreateQuicklookButton && (this.button = this.createQuicklookButton()), this.lastCallback = this.quicklookCallback.bind(this), this.link = K_(this.context, e), this.link.addEventListener("message", this.lastCallback)), ai && Be("USDZ Exporter enabled: " + this.name), document.getElementById("open-in-ar")?.addEventListener("click", this.onClickedOpenInARElement), dc.registerExporter(this);
  }
  /** @internal */
  onDisable() {
    this.button?.remove(), this.link?.removeEventListener("message", this.lastCallback), ai && Be("USDZ Exporter disabled: " + this.name), document.getElementById("open-in-ar")?.removeEventListener("click", this.onClickedOpenInARElement), dc.unregisterExporter(this);
  }
  onClickedOpenInARElement = (e) => {
    e.preventDefault(), this.exportAndOpen();
  };
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * Use the various public properties of USDZExporter to customize export behaviour.
   * @deprecated use {@link exportAndOpen} instead
   */
  async exportAsync() {
    return this.exportAndOpen();
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * @returns a Promise<Blob> containing the USDZ file
   */
  async exportAndOpen() {
    let e = this.exportFileName ?? this.objectToExport?.name ?? this.name;
    if (e += "-" + XM(), bs() || (e !== "" && (e += "-"), e += "MadeWithNeedle"), this.link || (this.link = K_(this.context, q.supportsQuickLookAR())), this.customUsdzFile)
      return ai && console.log("Exporting custom usdz", this.customUsdzFile), this.openInQuickLook(this.customUsdzFile, e), null;
    if (!this.objectToExport)
      return console.warn("No object to export", this), null;
    zl.beforeExport.invoke({ exporter: this });
    const t = await this.export(this.objectToExport).finally(() => {
      zl.afterExport.invoke({ exporter: this });
    });
    return t ? (ai && console.log("USDZ generation done. Downloading as " + e), this.openInQuickLook(t, e), t) : (console.error("USDZ generation failed. Please report a bug", this), null);
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * @returns a Promise<Blob> containing the USDZ file
   */
  async export(e) {
    if (!e)
      return console.warn("No object to export"), null;
    const t = this._currentExportTasks.get(e);
    if (t)
      return t;
    const i = this.internalExport(e);
    return i instanceof Promise ? (this._currentExportTasks.set(e, i), i.then((n) => (this._currentExportTasks.delete(e), n)).catch((n) => (this._currentExportTasks.delete(e), console.error("Error during USDZ export – please report a bug!", n), null))) : i;
  }
  _currentExportTasks = /* @__PURE__ */ new Map();
  _previousTimeScale = 1;
  async internalExport(e) {
    le.start("export-usdz", {
      onProgress: (O) => {
        this.dispatchEvent(new CustomEvent("export-progress", { detail: { progress: O } }));
      }
    }), le.report("export-usdz", { message: "Starting export", totalSteps: 40, currentStep: 0 }), le.report("export-usdz", { message: "Load progressive textures", autoStep: 5 }), le.start("export-usdz-textures", "export-usdz");
    const t = S.getComponentsInChildren(e, Pi);
    for (const O of t)
      O && O.enabled && O.updateSprite(!0);
    const i = S.getComponentsInChildren(e, Qi), n = new Array();
    let o = 0;
    for (const O of i) {
      for (const k of O.sharedMeshes)
        if (k) {
          const E = We.assignMeshLOD(k, 0);
          E instanceof Promise && n.push(new Promise((B, D) => {
            E.then(() => {
              o++, le.report("export-usdz-textures", { message: "Loaded progressive mesh", currentStep: o, totalSteps: n.length }), B();
            }).catch((W) => D(W));
          }));
        }
      for (const k of O.sharedMaterials)
        if (k) {
          const E = We.assignTextureLOD(k, 0);
          E instanceof Promise && n.push(new Promise((B, D) => {
            E.then(() => {
              o++, le.report("export-usdz-textures", { message: "Loaded progressive texture", currentStep: o, totalSteps: n.length }), B();
            }).catch((W) => D(W));
          }));
        }
    }
    ai && Be("Progressive Loading: " + n.length), await Promise.all(n), ai && Be("Progressive Loading: done"), le.end("export-usdz-textures");
    const r = ei.Global.Mask;
    ei.Global.Set(fs.AR);
    const a = new rR(), l = new xg(this.quickLookCompatible);
    let c;
    const h = [];
    this.interactive && (h.push(new Jv()), h.push(new Na()), globalThis.NEEDLE_USE_RAPIER && S.getComponentsInChildren(e, rt).length > 0 && (this.physics ? (c = new ew(), h.push(c)) : L() && console.warn("USDZExporter: Physics export is disabled, but there are active Rigidbody components in the scene. They will not be exported.")), h.push(new Tg()), h.push(new dw()));
    const d = [l, ...h, ...this.extensions], f = { self: this, exporter: a, extensions: d, object: e };
    le.report("export-usdz", "Invoking before-export"), this.dispatchEvent(new CustomEvent("before-export", { detail: f })), this.applyWebARSessionRoot(), this._previousTimeScale = this.context.time.timeScale, this.context.time.timeScale = 0, le.report("export-usdz", "auto export animations and audio sources");
    const p = new Array();
    this.autoExportAnimations && p.push(...aT(e, l)), d.find((O) => O.extensionName === "Audio") && this.autoExportAudioSources && p.push(...lT(e)), a.debug = ai, a.pruneUnusedNodes = !dT;
    const b = Aa.instance.objs.map((O) => O.batchedMesh);
    a.keepObject = (O) => {
      let k = !0;
      const E = S.getComponent(O, Qi);
      return E && !E.enabled && (k = !1), k && b.includes(O) && (k = !1), k && S.getComponentInParent(O, pu) && (k = !1), k && S.getComponentInParent(O, Rs) && (k = !1), ai && !k && console.log("USDZExporter: Discarding object", O), k;
    }, a.beforeWritingDocument = () => {
      if (L() && l && c) {
        const O = l.animatedRoots;
        for (const k of O) {
          const E = S.getComponentsInChildren(k, rt).filter((D) => D.enabled), B = S.getComponents(k, Ci).filter((D) => D.enabled && !D.isTrigger);
          (E.length > 0 || B.length > 0) && console.error("An animated object has physics components in its child hierarchy. This can lead to undefined behaviour due to a bug in Apple's QuickLook (FB15925487). Remove the physics components from child objects or verify that you get the expected results.", k);
        }
      }
    };
    const m = new Array();
    this.objectToExport && this.quickLookCompatible && this.interactive && this.objectToExport.traverse((O) => {
      O.visible || m.push(O);
    });
    const v = d.find((O) => O.extensionName === "Behaviour");
    this.interactive && v && m.length > 0 && v.addBehavior(cT(m));
    let _ = !0;
    this.quickLookCompatible && !this.interactive && (_ = !1), this.anchoringType !== "plane" && this.anchoringType !== "none" && this.anchoringType !== "image" && this.anchoringType !== "face" && (this.anchoringType = "plane"), this.planeAnchoringAlignment !== "horizontal" && this.planeAnchoringAlignment !== "vertical" && this.planeAnchoringAlignment !== "any" && (this.planeAnchoringAlignment = "horizontal"), le.report("export-usdz", "Invoking exporter.parse");
    const x = await a.parse(this.objectToExport, {
      ar: {
        anchoring: {
          type: this.anchoringType
        },
        planeAnchoring: {
          alignment: this.planeAnchoringAlignment
        }
      },
      extensions: d,
      quickLookCompatible: this.quickLookCompatible,
      maxTextureSize: this.maxTextureSize,
      exportInvisible: _
    }), I = new Blob([x], { type: "model/vnd.usdz+zip" });
    this.revertWebARSessionRoot(), this.context.time.timeScale = this._previousTimeScale, le.report("export-usdz", "Invoking after-export"), this.dispatchEvent(new CustomEvent("after-export", { detail: f }));
    for (const O of p)
      S.destroy(O);
    return ei.Global.Set(r), le.end("export-usdz"), I;
  }
  /**
   * Opens QuickLook on iOS/iPadOS/visionOS with the given content in AR mode.
   * @param content The URL to the .usdz or .reality file or a blob containing an USDZ file.
   * @param name Download filename
   */
  openInQuickLook(e, t) {
    const i = e instanceof Blob ? URL.createObjectURL(e) : e, n = this.buildQuicklookOverlay();
    ai && console.log("QuickLook Overlay", n);
    const o = n.callToAction ? encodeURIComponent(n.callToAction) : "", r = n.checkoutTitle ? encodeURIComponent(n.checkoutTitle) : "", a = n.checkoutSubtitle ? encodeURIComponent(n.checkoutSubtitle) : "";
    this.link.href = i + `#callToAction=${o}&checkoutTitle=${r}&checkoutSubtitle=${a}&callToActionURL=${n.callToActionURL}`, this.lastCallback || (this.lastCallback = this.quicklookCallback.bind(this), this.link.addEventListener("message", this.lastCallback)), this.link.download = t + ".usdz", this.link.click();
  }
  /**
   * Downloads the given blob as a file.
   */
  download(e, t) {
    zl.save(e, t);
  }
  // Matches GltfExport.save(blob, filename)
  static save(e, t) {
    const i = document.createElement("a");
    i.style.display = "none", document.body.appendChild(i), typeof e == "string" ? i.href = e : i.href = URL.createObjectURL(e), i.download = t, i.click(), i.remove();
  }
  lastCallback;
  quicklookCallback(e) {
    if (e?.data == "_apple_ar_quicklook_button_tapped") {
      ai && ge("Quicklook closed via call to action button");
      var t = new CustomEvent("quicklook-button-tapped", { detail: this });
      if (this.dispatchEvent(t), !t.defaultPrevented) {
        const i = new URLSearchParams(this.link.href);
        if (i) {
          const n = i.get("callToActionURL");
          ai && Be("Quicklook url: " + n), n && (bs() ? globalThis.open(n, "_blank") : console.warn("Quicklook closed: custom redirects require a Needle Engine Pro license: https://needle.tools/pricing", n));
        }
      }
    }
  }
  buildQuicklookOverlay() {
    const e = {};
    return this.customBranding && Object.assign(e, this.customBranding), bs() || (console.log("Custom Quicklook banner text requires pro license: https://needle.tools/pricing"), e.callToAction = "Close", e.checkoutTitle = "🌵 Made with Needle", e.checkoutSubtitle = "_"), (e.callToAction?.length || e.checkoutTitle?.length || e.checkoutSubtitle?.length) && (e.callToAction?.length || (e.callToAction = "\0"), e.checkoutTitle?.length || (e.checkoutTitle = "\0"), e.checkoutSubtitle?.length || (e.checkoutSubtitle = "\0")), this.dispatchEvent(new CustomEvent("quicklook-overlay", { detail: e })), e;
  }
  static invertForwardMatrix = new ee().makeRotationY(Math.PI);
  static invertForwardQuaternion = new U().setFromEuler(new ot(0, Math.PI, 0));
  _rootSessionRootWasAppliedTo = null;
  _rootPositionBeforeExport = new y();
  _rootRotationBeforeExport = new U();
  _rootScaleBeforeExport = new y();
  getARScaleAndTarget() {
    if (!this.objectToExport) return { scale: 1, _invertForward: !1, target: this.gameObject, sessionRoot: null };
    const e = S.findObjectOfType(Mg);
    let t = S.getComponentInParent(this.objectToExport, Vi);
    t || (t = S.getComponentInChildren(this.objectToExport, Vi));
    let i = 1, n = !1;
    const o = this.objectToExport;
    return e ? i = e.arScale : t && (i = t.arScale, n = t.invertForward), { scale: 1 / i, _invertForward: n, target: o, sessionRoot: t?.gameObject ?? null };
  }
  applyWebARSessionRoot() {
    if (!this.objectToExport) return;
    const { scale: e, _invertForward: t, target: i, sessionRoot: n } = this.getARScaleAndTarget(), o = n?.matrixWorld.clone().invert();
    this._rootSessionRootWasAppliedTo = i, this._rootPositionBeforeExport.copy(i.position), this._rootRotationBeforeExport.copy(i.quaternion), this._rootScaleBeforeExport.copy(i.scale), i.scale.multiplyScalar(e), t && i.quaternion.multiply(zl.invertForwardQuaternion), i.updateMatrix(), i.updateMatrixWorld(!0), n && o && i.matrix.premultiply(o);
  }
  revertWebARSessionRoot() {
    if (!this.objectToExport || !this._rootSessionRootWasAppliedTo) return;
    const e = this._rootSessionRootWasAppliedTo;
    e.position.copy(this._rootPositionBeforeExport), e.quaternion.copy(this._rootRotationBeforeExport), e.scale.copy(this._rootScaleBeforeExport), e.updateMatrix(), e.updateMatrixWorld(!0), this._rootSessionRootWasAppliedTo = null;
  }
  createQuicklookButton() {
    const t = or.getOrCreate().createQuicklookButton();
    return t.parentNode || this.context.menu.appendChild(t), t;
  }
};
Mt([
  u(M)
], ri.prototype, "objectToExport");
Mt([
  u()
], ri.prototype, "autoExportAnimations");
Mt([
  u()
], ri.prototype, "autoExportAudioSources");
Mt([
  u()
], ri.prototype, "exportFileName");
Mt([
  u(URL)
], ri.prototype, "customUsdzFile");
Mt([
  u(Ga)
], ri.prototype, "customBranding");
Mt([
  u()
], ri.prototype, "anchoringType");
Mt([
  u()
], ri.prototype, "maxTextureSize");
Mt([
  u()
], ri.prototype, "planeAnchoringAlignment");
Mt([
  u()
], ri.prototype, "interactive");
Mt([
  u()
], ri.prototype, "physics");
Mt([
  u()
], ri.prototype, "allowCreateQuicklookButton");
Mt([
  u()
], ri.prototype, "quickLookCompatible");
let ws = ri;
var uT = Object.defineProperty, fT = Object.getOwnPropertyDescriptor, Ag = (s, e, t, i) => {
  for (var n = fT(e, t), o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && uT(e, t, n), n;
};
class jc extends R {
  get fog() {
    return this._fog || (this._fog = new Ob(0, 0, 50)), this._fog;
  }
  get mode() {
    return 1;
  }
  set near(e) {
    this.fog.near = e;
  }
  get near() {
    return this.fog.near;
  }
  set far(e) {
    this.fog.far = e;
  }
  get far() {
    return this.fog.far;
  }
  set color(e) {
    this.fog.color.copy(e);
  }
  get color() {
    return this.fog.color;
  }
  _fog;
  onEnable() {
    this.scene.fog = this.fog;
  }
  onDisable() {
    this.scene.fog === this._fog && (this.scene.fog = null);
  }
}
Ag([
  u()
], jc.prototype, "near");
Ag([
  u()
], jc.prototype, "far");
Ag([
  u(se)
], jc.prototype, "color");
var pT = Object.defineProperty, Ig = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && pT(e, t, n), n;
};
class qa extends R {
  objectBounds = !1;
  color;
  isGizmo = !0;
  _gizmoObject = null;
  _boxHelper = null;
  onEnable() {
    this.isGizmo && !Sc || (this._gizmoObject || (this.objectBounds ? this._gizmoObject = new oS(this.gameObject, this.color ?? 16776960) : (this.objectBounds = !1, this._gizmoObject = Wm(this.color ?? 16776960))), this.objectBounds ? (this.scene.add(this._gizmoObject), this._boxHelper = this._gizmoObject, this.startCoroutine(this.syncObjectBounds(), xe.OnBeforeRender)) : this.gameObject.add(this._gizmoObject));
  }
  onDisable() {
    this._gizmoObject && this.gameObject.remove(this._gizmoObject);
  }
  *syncObjectBounds() {
    for (; this._boxHelper; )
      this._boxHelper?.update(), yield;
  }
}
Ig([
  u()
], qa.prototype, "objectBounds");
Ig([
  u(se)
], qa.prototype, "color");
Ig([
  u()
], qa.prototype, "isGizmo");
var mT = Object.defineProperty, Lg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && mT(e, t, n), n;
};
class Bc extends R {
  isGizmo = !1;
  color0;
  color1;
  gridHelper;
  size;
  divisions;
  offset;
  /** @internal */
  onEnable() {
    if (this.isGizmo && !Sc) return;
    const e = this.size, t = this.divisions;
    this.gridHelper || (this.gridHelper = new bm(e, t, this.color0 ?? new se(0.4, 0.4, 0.4), this.color1 ?? new se(0.6, 0.6, 0.6)), this.offset !== void 0 && (this.gridHelper.position.y += this.offset)), this.gridHelper && this.gameObject.add(this.gridHelper);
  }
  /** @internal */
  onDisable() {
    this.gridHelper && (this.gameObject.remove(this.gridHelper), this.gridHelper = null);
  }
}
Lg([
  u()
], Bc.prototype, "isGizmo");
Lg([
  u(se)
], Bc.prototype, "color0");
Lg([
  u(se)
], Bc.prototype, "color1");
var gT = Object.defineProperty, Dg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && gT(e, t, n), n;
};
class jg extends R {
  connectedBody;
  get rigidBody() {
    return this._rigidBody;
  }
  _rigidBody = null;
  onEnable() {
    this._rigidBody || (this._rigidBody = this.gameObject.getComponent(rt)), this.rigidBody && this.connectedBody && this.startCoroutine(this.create());
  }
  *create() {
    yield, this.rigidBody && this.connectedBody && this.activeAndEnabled && this.createJoint(this.rigidBody, this.connectedBody);
  }
}
Dg([
  u(rt)
], jg.prototype, "connectedBody");
class uw extends jg {
  createJoint(e, t) {
    this.context.physics.engine?.addFixedJoint(e, t);
  }
}
class Mu extends jg {
  anchor;
  axis;
  createJoint(e, t) {
    this.axis && this.anchor && this.context.physics.engine?.addHingeJoint(e, t, this.anchor, this.axis);
  }
}
Dg([
  u(y)
], Mu.prototype, "anchor");
Dg([
  u(y)
], Mu.prototype, "axis");
var yT = Object.defineProperty, _T = Object.getOwnPropertyDescriptor, Hn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? _T(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && yT(e, t, n), n;
};
function Zf(s) {
  return s * Math.PI / 180;
}
const Z_ = 300, $s = w("debuglights");
class ki extends R {
  type = 0;
  /**
   * The maximum distance the light affects
   */
  range = 1;
  /**
   * The full outer angle of the spotlight cone in degrees
   */
  spotAngle = 1;
  /**
   * The angle of the inner cone in degrees for soft-edge spotlights
   */
  innerSpotAngle = 1;
  set color(e) {
    this._color = e, this.light !== void 0 && (this.light.color = e);
  }
  get color() {
    return this.light ? this.light.color : this._color;
  }
  _color = new se(16777215);
  set shadowNearPlane(e) {
    if (e !== this._shadowNearPlane && (this._shadowNearPlane = e, this.light?.shadow?.camera !== void 0)) {
      const t = this.light.shadow.camera;
      t.near = e;
    }
  }
  get shadowNearPlane() {
    return this._shadowNearPlane;
  }
  _shadowNearPlane = 0.1;
  set shadowBias(e) {
    e !== this._shadowBias && (this._shadowBias = e, this.light?.shadow?.bias !== void 0 && (this.light.shadow.bias = e, this.light.shadow.needsUpdate = !0));
  }
  get shadowBias() {
    return this._shadowBias;
  }
  _shadowBias = 0;
  set shadowNormalBias(e) {
    e !== this._shadowNormalBias && (this._shadowNormalBias = e, this.light?.shadow?.normalBias !== void 0 && (this.light.shadow.normalBias = e, this.light.shadow.needsUpdate = !0));
  }
  get shadowNormalBias() {
    return this._shadowNormalBias;
  }
  _shadowNormalBias = 0;
  /** when enabled this will remove the multiplication when setting the shadow bias settings initially */
  _overrideShadowBiasSettings = !1;
  set shadows(e) {
    this._shadows = e, this.light && (this.light.castShadow = e !== 0, this.updateShadowSoftHard());
  }
  get shadows() {
    return this._shadows;
  }
  _shadows = 1;
  lightmapBakeType = 4;
  set intensity(e) {
    if (this._intensity = e, this.light) {
      let t = 1;
      if (this.context.isInXR && this._webARRoot) {
        const i = this._webARRoot?.arScale;
        typeof i == "number" && i > 0 && (t /= i);
      }
      this.light.intensity = e * t;
    }
    $s && console.log("Set light intensity to " + this._intensity, e, this);
  }
  get intensity() {
    return this._intensity;
  }
  _intensity = -1;
  get shadowDistance() {
    const e = this.light;
    return e?.shadow ? e.shadow.camera.far : -1;
  }
  set shadowDistance(e) {
    this._shadowDistance = e;
    const t = this.light;
    if (t?.shadow) {
      const i = t.shadow.camera;
      i.far = e, i.updateProjectionMatrix();
    }
  }
  _shadowDistance;
  // set from additional component
  shadowWidth;
  shadowHeight;
  get shadowResolution() {
    const e = this.light;
    return e?.shadow ? e.shadow.mapSize.x : -1;
  }
  set shadowResolution(e) {
    if (e === this._shadowResolution) return;
    this._shadowResolution = e;
    const t = this.light;
    t?.shadow && (t.shadow.mapSize.set(e, e), t.shadow.needsUpdate = !0);
  }
  _shadowResolution = void 0;
  /**
   * Whether this light's illumination is entirely baked into lightmaps
   */
  get isBaked() {
    return this.lightmapBakeType === 2;
  }
  /**
   * Checks if the GameObject itself is a {@link ThreeLight} object
   */
  get selfIsLight() {
    if (this.gameObject.isLight === !0) return !0;
    switch (this.gameObject.type) {
      case "SpotLight":
      case "PointLight":
      case "DirectionalLight":
        return !0;
    }
    return !1;
  }
  /**
   * The underlying three.js {@link ThreeLight} instance
   */
  light = void 0;
  /**
   * Gets the world position of the light
   * @param vec Vector3 to store the result
   * @returns The world position as a Vector3
   */
  getWorldPosition(e) {
    return this.light ? this.type === 1 ? this.light.getWorldPosition(e).multiplyScalar(1) : this.light.getWorldPosition(e) : e;
  }
  // public updateIntensity() {
  //     this.intensity = this._intensity;
  // }
  awake() {
    this.color = new se(this.color ?? 16777215), $s && console.log(this.name, this);
  }
  onEnable() {
    $s && console.log("ENABLE LIGHT", this.name), this.createLight(), !this.isBaked && (this.light && (this.light.visible = !0, this.light.intensity = this._intensity, $s && console.log("Set light intensity to " + this.light.intensity, this.name), this.selfIsLight || this.light.parent !== this.gameObject && this.gameObject.add(this.light)), this.type === 1 && this.startCoroutine(this.updateMainLightRoutine(), xe.LateUpdate));
  }
  onDisable() {
    $s && console.log("DISABLE LIGHT", this.name), this.light && (this.selfIsLight ? this.light.intensity = 0 : this.light.visible = !1);
  }
  _webXRStartedListener;
  _webXREndedListener;
  _webARRoot;
  onEnterXR(e) {
    this._webARRoot = S.getComponentInParent(this.gameObject, Vi) ?? void 0;
  }
  // private *_updateLightIntensityInARRoutine() {
  //     while (this.context.isInAR) {
  //         yield;
  //         // this.updateIntensity();
  //         for (let i = 0; i < 30; i++) yield;
  //     }
  // }
  onLeaveXR(e) {
  }
  /**
   * Creates the appropriate three.js light based on the configured light type
   * and applies all settings like shadows, intensity, and color.
   */
  createLight() {
    const e = this.selfIsLight;
    if (e && !this.light)
      switch (this.light = this.gameObject, this.light.name = this.name, this._intensity = this.light.intensity, this.type) {
        case 1:
          this.setDirectionalLight(this.light);
          break;
      }
    else if (!this.light)
      switch (this.type) {
        case 1:
          const t = new fp(this.color, this.intensity * Math.PI);
          if (t.position.set(0, 0, -Z_ * 0.5).applyQuaternion(this.gameObject.quaternion), this.gameObject.add(t.target), ba(t.target, 0, 0, 0), this.light = t, this.gameObject.position.set(0, 0, 0), this.gameObject.rotation.set(0, 0, 0), $s) {
            const r = new aS(this.light, 0.2, this.color);
            this.context.scene.add(r);
          }
          break;
        case 0:
          const i = new rS(this.color, this.intensity * Math.PI, this.range, Zf(this.spotAngle / 2), 1 - Zf(this.innerSpotAngle / 2) / Zf(this.spotAngle / 2), 2);
          i.position.set(0, 0, 0), i.rotation.set(0, 0, 0), this.light = i;
          const n = i.target;
          i.add(n), n.position.set(0, 0, this.range), n.rotation.set(0, 0, 0);
          break;
        case 2:
          const o = new vm(this.color, this.intensity * Math.PI, this.range);
          this.light = o;
          break;
      }
    if (this.light) {
      if (this._intensity >= 0 ? this.light.intensity = this._intensity : this._intensity = this.light.intensity, this.shadows !== 0 ? this.light.castShadow = !0 : this.light.castShadow = !1, this.light.shadow) {
        this._shadowResolution !== void 0 && this._shadowResolution > 4 ? (this.light.shadow.mapSize.width = this._shadowResolution, this.light.shadow.mapSize.height = this._shadowResolution) : (this.light.shadow.mapSize.width = 2048, this.light.shadow.mapSize.height = 2048), $s && console.log("Override shadow bias?", this._overrideShadowBiasSettings, this.shadowBias, this.shadowNormalBias), this.light.shadow.bias = this.shadowBias, this.light.shadow.normalBias = this.shadowNormalBias, this.updateShadowSoftHard();
        const t = this.light.shadow.camera;
        if (t.near = this.shadowNearPlane, this._shadowDistance !== void 0 && typeof this._shadowDistance == "number" ? t.far = this._shadowDistance : t.far = Z_ * Math.abs(this.gameObject.scale.z), this.gameObject.scale.set(1, 1, 1), this.shadowWidth !== void 0)
          t.left = -this.shadowWidth / 2, t.right = this.shadowWidth / 2;
        else {
          const i = this.gameObject.scale.x;
          t.left *= i, t.right *= i;
        }
        if (this.shadowHeight !== void 0)
          t.top = this.shadowHeight / 2, t.bottom = -this.shadowHeight / 2;
        else {
          const i = this.gameObject.scale.y;
          t.top *= i, t.bottom *= i;
        }
        this.light.shadow.needsUpdate = !0, $s && this.context.scene.add(new lS(t));
      }
      this.isBaked ? this.light.removeFromParent() : e || this.gameObject.add(this.light);
    }
  }
  /**
   * Coroutine that updates the main light reference in the context
   * if this directional light should be the main light
   */
  *updateMainLightRoutine() {
    for (; ; ) {
      this.type === 1 && ((!this.context.mainLight || this.intensity > this.context.mainLight.intensity) && (this.context.mainLight = this), yield);
      break;
    }
  }
  /**
   * Controls whether the renderer's shadow map type can be changed when soft shadows are used
   */
  static allowChangingRendererShadowMapType = !0;
  /**
   * Updates shadow settings based on whether the shadows are set to hard or soft
   */
  updateShadowSoftHard() {
    this.light && this.light.shadow && (this.shadows === 2 || (this.light.shadow.radius = 1, this.light.shadow.blurSamples = 1));
  }
  /**
   * Configures a directional light by adding and positioning its target
   * @param dirLight The directional light to set up
   */
  setDirectionalLight(e) {
    e.add(e.target), e.target.position.set(0, 0, -1);
  }
}
Hn([
  u()
], ki.prototype, "type", 2);
Hn([
  u(se)
], ki.prototype, "color", 1);
Hn([
  u()
], ki.prototype, "shadowNearPlane", 1);
Hn([
  u()
], ki.prototype, "shadowBias", 1);
Hn([
  u()
], ki.prototype, "shadowNormalBias", 1);
Hn([
  u()
], ki.prototype, "shadows", 1);
Hn([
  u()
], ki.prototype, "lightmapBakeType", 2);
Hn([
  u()
], ki.prototype, "intensity", 1);
Hn([
  u()
], ki.prototype, "shadowDistance", 1);
Hn([
  u()
], ki.prototype, "shadowResolution", 1);
new y(0, 0, 0);
var bT = Object.defineProperty, Fc = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && bT(e, t, n), n;
};
const Jf = w("debuglods"), vT = w("nolods");
class zc {
  screenRelativeTransitionHeight;
  distance;
  renderers;
}
Fc([
  u()
], zc.prototype, "screenRelativeTransitionHeight");
Fc([
  u()
], zc.prototype, "distance");
Fc([
  u(Qi)
], zc.prototype, "renderers");
class wT {
  model;
  get renderers() {
    return this.model.renderers;
  }
  constructor(e) {
    this.model = e;
  }
}
class Ru extends R {
  fadeMode = 0;
  localReferencePoint = void 0;
  lodCount = 0;
  size = 0;
  animateCrossFading = !1;
  lodModels;
  _lods = [];
  _settings = [];
  // https://threejs.org/docs/#api/en/objects/LOD
  _lodsHandler;
  start() {
    if (Jf && console.log("LODGROUP", this.name, this.lodModels, this), !vT && !this._lodsHandler && this.gameObject && this.lodModels && Array.isArray(this.lodModels)) {
      const e = [];
      for (const i of this.lodModels) {
        const n = new wT(i);
        this._lods.push(n);
        for (const o of n.renderers)
          e.includes(o) || e.push(o);
      }
      this._lodsHandler = new Array();
      for (let i = 0; i < e.length; i++) {
        const n = new cS();
        this._lodsHandler.push(n), this.gameObject.add(n);
      }
      const t = new M();
      t.name = "Cull " + this.name;
      for (let i = 0; i < e.length; i++) {
        const n = e[i], o = this._lodsHandler[i], r = n.gameObject;
        Jf && console.log(i, r.name);
        for (const a of this._lods) {
          const l = a.model.distance;
          let c = null;
          if (a.renderers.includes(n) ? c = r : c = t, c.type === "Group") {
            console.warn(`LODGroup ${this.name}: Group or MultiMaterial object's are not supported as LOD object: ${c.name}`);
            continue;
          }
          Jf && console.log("LEVEL", c.name, l), o.autoUpdate = !1, this.onAddLodLevel(o, c, a.model.distance);
        }
      }
    }
  }
  onAfterRender() {
    if (!this.gameObject || !this._lodsHandler) return;
    const e = this.context.mainCamera;
    if (e)
      for (const t of this._lodsHandler) {
        t.update(e);
        const i = t.getCurrentLevel(), n = t.levels[i];
        t.layers.mask = n.object.layers.mask;
      }
  }
  onAddLodLevel(e, t, i) {
    if (t === this.gameObject) {
      console.warn("LODGroup component must be on parent object and not mesh directly at the moment", t.name, t);
      return;
    }
    e.addLevel(t, i * this._distanceFactor, 0.01);
    const n = { lod: e, levelIndex: e.levels.length - 1, distance: i };
    this._settings.push(n);
  }
  _distanceFactor = 1;
  distanceFactor(e) {
    if (e !== this._distanceFactor) {
      this._distanceFactor = e;
      for (const t of this._settings) {
        const i = t.lod.levels[t.levelIndex];
        i.distance = t.distance * e;
      }
    }
  }
}
Fc([
  u(y)
], Ru.prototype, "localReferencePoint");
Fc([
  u(zc)
], Ru.prototype, "lodModels");
var xT = Object.defineProperty, fw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && xT(e, t, n), n;
};
const Mh = w("debugnestedgltf");
class Tu extends R {
  filePath;
  loaded = new ce();
  /**
   * EXPERIMENTAL for cloud asset loading
   */
  loadAssetInParent = !0;
  _isLoadingOrDoneLoading = !1;
  /** Register a callback that will be called when the progress of the loading changes */
  listenToProgress(e) {
    this.filePath?.beginListenDownload(e);
  }
  /** Begin loading the referenced gltf file in filePath */
  preload() {
    return this.filePath?.preload() || null;
  }
  /** @internal */
  async start() {
    if (this._isLoadingOrDoneLoading) return;
    Mh && console.log(this, this.guid);
    const e = this.gameObject.parent;
    if (e && this.filePath) {
      this._isLoadingOrDoneLoading = !0;
      const t = new $n();
      t.idProvider = new At(this.hash(this.guid)), t.parent = this.loadAssetInParent !== !1 ? e : this.gameObject, this.gameObject.updateMatrix();
      const i = this.gameObject.matrix;
      Mh && console.log("Load nested:", this.filePath?.url ?? this.filePath, this.gameObject.position);
      const n = await this.filePath?.instantiate?.call(this.filePath, t);
      Mh && console.log("Nested loaded:", this.filePath?.url ?? this.filePath, n), n && this.loadAssetInParent !== !1 && (n.matrixAutoUpdate = !1, n.matrix.identity(), n.applyMatrix4(i), n.matrixAutoUpdate = !0, n.layers.disableAll(), n.layers.set(this.layer), this.loaded.invoke({ component: this, instance: n, asset: this.filePath })), Mh && console.log("Nested loading done:", this.filePath?.url ?? this.filePath, n);
    }
  }
  /** @internal */
  onDestroy() {
    this.filePath?.unload();
  }
  hash(e) {
    let t = 0;
    for (let i = 0; i < e.length; i++)
      t = e.charCodeAt(i) + ((t << 5) - t);
    return t;
  }
}
fw([
  u(ie)
], Tu.prototype, "filePath");
fw([
  u(ce)
], Tu.prototype, "loaded");
var ST = Object.defineProperty, Bg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && ST(e, t, n), n;
};
const CT = w("debugnet"), Eu = class im extends R {
  url = null;
  urlParameterName = null;
  localhost = null;
  /** @internal */
  awake() {
    CT && console.log(this), this.context.connection.registerProvider(this);
  }
  /** 
   * Determines the websocket URL to use for networking connections.
   * Processes the configured URL, applying localhost fallbacks when appropriate and
   * handling URL parameter overrides if specified.
   * @returns The formatted websocket URL string or null if no valid URL could be determined
   * @internal
   */
  getWebsocketUrl() {
    let e = this.url ? im.GetUrl(this.url, this.localhost) : null;
    if (this.urlParameterName) {
      const o = w(this.urlParameterName);
      o && typeof o == "string" && (e = o);
    }
    if (!e) return null;
    const i = new RegExp("(((https?)|(?<socket_prefix>wss?))://)?(www.)?(?<url>.+)", "gm").exec(e);
    return i?.groups ? i?.groups.socket_prefix ? e : "wss://" + i?.groups.url : null;
  }
  /**
   * Processes a URL string applying various transformations based on network environment.
   * Handles relative paths and localhost fallbacks for local network environments.
   * @param url The original URL to process
   * @param localhostFallback Alternative URL to use when on a local network
   * @returns The processed URL string or null/undefined if input was invalid
   */
  static GetUrl(e, t) {
    let i = e;
    const n = im.IsLocalNetwork() && t;
    if (n && (i = t), e?.startsWith("/")) {
      const o = n ? i : window.location.origin;
      o?.endsWith("/") && e.startsWith("/") && (e = e.substring(1)), i = o + e;
    }
    return i;
  }
  /**
   * Determines if the current connection is on a local network.
   * Useful for applying different networking configurations in local development environments.
   * This is the same as calling {@link isLocalNetwork}.
   * @param hostname Optional hostname to check instead of the current window location
   * @returns True if the connection is on a local network, false otherwise
   */
  static IsLocalNetwork(e = window.location.hostname) {
    return hn(e);
  }
};
Bg([
  u()
], Eu.prototype, "url");
Bg([
  u()
], Eu.prototype, "urlParameterName");
Bg([
  u()
], Eu.prototype, "localhost");
let pw = Eu;
var PT = Object.defineProperty, Au = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && PT(e, t, n), n;
};
class Xa extends R {
  referenceSpace;
  from;
  affectPosition = !1;
  affectRotation = !1;
  alignLookDirection = !1;
  levelLookDirection = !1;
  levelPosition = !1;
  positionOffset = new y(0, 0, 0);
  rotationOffset = new y(0, 0, 0);
  offset = new y(0, 0, 0);
  update() {
    if (!this.from) return;
    var e = Z(this.from), t = be(this.from);
    this.offset.copy(this.positionOffset);
    const i = this.offset.length();
    if (this.referenceSpace && this.offset.transformDirection(this.referenceSpace.matrixWorld).multiplyScalar(i), e.add(this.offset), this.levelPosition && this.referenceSpace) {
      const a = new rr(this.gameObject.up, 0), l = Z(this.referenceSpace);
      a.setFromNormalAndCoplanarPoint(this.gameObject.up, l);
      const c = new y(0, 0, 0);
      a.projectPoint(e, c), e.copy(c);
    }
    this.affectPosition && Ot(this.gameObject, e);
    const n = new ot(this.rotationOffset.x, this.rotationOffset.y, this.rotationOffset.z), o = new U().setFromEuler(n);
    this.affectRotation && jn(this.gameObject, t.multiply(o));
    const r = new y();
    this.from.getWorldDirection(r).multiplyScalar(50), this.levelLookDirection && (r.y = 0), this.alignLookDirection && this.gameObject.lookAt(r);
  }
}
Au([
  u(S)
], Xa.prototype, "referenceSpace");
Au([
  u(S)
], Xa.prototype, "from");
Au([
  u(y)
], Xa.prototype, "positionOffset");
Au([
  u(y)
], Xa.prototype, "rotationOffset");
var OT = Object.defineProperty, Co = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && OT(e, t, n), n;
};
class _i {
  time = 0;
  value = 0;
  inTangent = 1 / 0;
  inWeight;
  outTangent = 1 / 0;
  outWeight;
  weightedMode;
  constructor(e = 0, t = 0) {
    this.time = e, this.value = t;
  }
}
Co([
  u()
], _i.prototype, "time");
Co([
  u()
], _i.prototype, "value");
Co([
  u()
], _i.prototype, "inTangent");
Co([
  u()
], _i.prototype, "inWeight");
Co([
  u()
], _i.prototype, "outTangent");
Co([
  u()
], _i.prototype, "outWeight");
Co([
  u()
], _i.prototype, "weightedMode");
const mw = class Ul {
  /**
   * Creates an animation curve that goes from the `from` value to the `to` value over the given `duration`.
   */
  static linearFromTo(e, t, i) {
    const n = new Ul(), o = new _i();
    o.time = 0, o.value = e;
    const r = new _i();
    return r.time = i, r.value = t, n.keys.push(o, r), n;
  }
  /** Creates an animation curve with just one keyframe */
  static constant(e) {
    const t = new Ul(), i = new _i();
    return i.time = 0, i.value = e, t.keys.push(i), t;
  }
  keys = [];
  /** 
   * Clones this AnimationCurve and returns a new instance with the same keyframes (the keyframes are also cloned).
  */
  clone() {
    const e = new Ul();
    return e.keys = this.keys?.map((t) => {
      const i = new _i();
      return i.time = t.time, i.value = t.value, i.inTangent = t.inTangent, i.inWeight = t.inWeight, i.outTangent = t.outTangent, i.outWeight = t.outWeight, i.weightedMode = t.weightedMode, i;
    }) || [], e;
  }
  /** The duration of the curve, which is the time of the last keyframe. */
  get duration() {
    return !this.keys || this.keys.length == 0 ? 0 : this.keys[this.keys.length - 1].time;
  }
  /** Evaluates the curve at the given time and returns the value of the curve at that time.
   * @param time The time at which to evaluate the curve.
   * @returns The value of the curve at the given time.
   */
  evaluate(e) {
    if (!this.keys || this.keys.length == 0) return 0;
    if (this.keys.length === 1)
      return this.keys[0].value;
    if (this.keys[0].time >= e)
      return this.keys[0].value;
    for (let t = 0; t < this.keys.length; t++) {
      const i = this.keys[t];
      if (i.time <= e)
        if (t + 1 < this.keys.length) {
          const o = this.keys[t + 1];
          if (o.time < e) continue;
          return !isFinite(i.outTangent) || !isFinite(o.inTangent) ? i.value : Ul.interpolateValue(e, i, o);
        } else
          return i.value;
    }
    return this.keys[this.keys.length - 1].value;
  }
  static interpolateValue(e, t, i) {
    const n = t.time, o = t.value, r = t.outTangent, a = i.time, l = i.value, c = i.inTangent, h = a - n, d = h * h, f = d * h, p = ((r + c) * h - 2 * (l - o)) / f, g = (3 * (l - o) - (c + 2 * r) * h) / d, b = r, m = o, v = e - n, _ = v * v, x = _ * v;
    return p * x + g * _ + b * v + m;
  }
};
Co([
  u(_i)
], mw.prototype, "keys");
let Iu = mw;
var kT = Object.defineProperty, C = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && kT(e, t, n), n;
};
const Rh = w("debugparticles");
var cs = /* @__PURE__ */ ((s) => (s[s.Billboard = 0] = "Billboard", s[s.Stretch = 1] = "Stretch", s[s.HorizontalBillboard = 2] = "HorizontalBillboard", s[s.VerticalBillboard = 3] = "VerticalBillboard", s[s.Mesh = 4] = "Mesh", s))(cs || {});
class Qa {
  alphaKeys = [];
  colorKeys = [];
  get duration() {
    return 1;
  }
  evaluate(e, t) {
    let i, n = 0, o = null, r = 0;
    for (let a = 0; a < this.alphaKeys.length; a++) {
      const l = this.alphaKeys[a];
      (l.time < e || !i) && (i = l, n = a);
    }
    for (let a = 0; a < this.colorKeys.length; a++) {
      const l = this.colorKeys[a];
      (l.time < e || !o) && (o = l, r = a);
    }
    if (o)
      if (r + 1 < this.colorKeys.length) {
        const l = this.colorKeys[r + 1], c = j.remap(e, o.time, l.time, 0, 1);
        t.r = j.lerp(o.color.r, l.color.r, c), t.g = j.lerp(o.color.g, l.color.g, c), t.b = j.lerp(o.color.b, l.color.b, c);
      } else
        t.r = o.color.r, t.g = o.color.g, t.b = o.color.b;
    if (i)
      if (n + 1 < this.alphaKeys.length) {
        const l = this.alphaKeys[n + 1], c = j.remap(e, i.time, l.time, 0, 1);
        t.alpha = j.lerp(i.alpha, l.alpha, c);
      } else
        t.alpha = i.alpha;
    return t;
  }
}
C([
  u()
], Qa.prototype, "alphaKeys");
C([
  u()
], Qa.prototype, "colorKeys");
var vc = /* @__PURE__ */ ((s) => (s[s.Local = 0] = "Local", s[s.World = 1] = "World", s[s.Custom = 2] = "Custom", s))(vc || {}), nm = /* @__PURE__ */ ((s) => (s[s.Sphere = 0] = "Sphere", s[s.SphereShell = 1] = "SphereShell", s[s.Hemisphere = 2] = "Hemisphere", s[s.HemisphereShell = 3] = "HemisphereShell", s[s.Cone = 4] = "Cone", s[s.Box = 5] = "Box", s[s.Mesh = 6] = "Mesh", s[s.ConeShell = 7] = "ConeShell", s[s.ConeVolume = 8] = "ConeVolume", s[s.ConeVolumeShell = 9] = "ConeVolumeShell", s[s.Circle = 10] = "Circle", s[s.CircleEdge = 11] = "CircleEdge", s[s.SingleSidedEdge = 12] = "SingleSidedEdge", s[s.MeshRenderer = 13] = "MeshRenderer", s[s.SkinnedMeshRenderer = 14] = "SkinnedMeshRenderer", s[s.BoxShell = 15] = "BoxShell", s[s.BoxEdge = 16] = "BoxEdge", s[s.Donut = 17] = "Donut", s[s.Rectangle = 18] = "Rectangle", s[s.Sprite = 19] = "Sprite", s[s.SpriteRenderer = 20] = "SpriteRenderer", s))(nm || {});
const Ls = class Nl {
  static constant(e) {
    const t = new Nl();
    return t.setConstant(e), t;
  }
  static betweenTwoConstants(e, t) {
    const i = new Nl();
    return i.setMinMaxConstant(e, t), i;
  }
  static curve(e, t = 1) {
    const i = new Nl();
    return i.setCurve(e, t), i;
  }
  setConstant(e) {
    this.mode = 0, this.constant = e;
  }
  setMinMaxConstant(e, t) {
    this.mode = 3, this.constantMin = e, this.constantMax = t;
  }
  setCurve(e, t = 1) {
    this.mode = 1, this.curve = e, this.curveMultiplier = t;
  }
  mode = "Constant";
  constant;
  constantMin;
  constantMax;
  curve;
  curveMin;
  curveMax;
  curveMultiplier;
  clone() {
    const e = new Nl();
    return e.mode = this.mode, e.constant = this.constant, e.constantMin = this.constantMin, e.constantMax = this.constantMax, e.curve = this.curve?.clone(), e.curveMin = this.curveMin?.clone(), e.curveMax = this.curveMax?.clone(), e.curveMultiplier = this.curveMultiplier, e;
  }
  evaluate(e, t) {
    const i = t === void 0 ? Math.random() : t;
    switch (this.mode) {
      case 0:
      case "Constant":
        return this.constant;
      case 1:
      case "Curve":
        return e = j.clamp01(e), this.curve.evaluate(e) * this.curveMultiplier;
      case 2:
      case "TwoCurves":
        const n = e * this.curveMin.duration, o = e * this.curveMax.duration;
        return j.lerp(this.curveMin.evaluate(n), this.curveMax.evaluate(o), i % 1) * this.curveMultiplier;
      case 3:
      case "TwoConstants":
        return j.lerp(this.constantMin, this.constantMax, i % 1);
      default:
        this.curveMax.evaluate(e) * this.curveMultiplier;
        break;
    }
    return 0;
  }
  getMax() {
    switch (this.mode) {
      case 0:
      case "Constant":
        return this.constant;
      case 1:
      case "Curve":
        return this.getMaxFromCurve(this.curve) * this.curveMultiplier;
      case 2:
      case "TwoCurves":
        return Math.max(this.getMaxFromCurve(this.curveMin), this.getMaxFromCurve(this.curveMax)) * this.curveMultiplier;
      case 3:
      case "TwoConstants":
        return Math.max(this.constantMin, this.constantMax);
      default:
        return 0;
    }
  }
  getMaxFromCurve(e) {
    if (!e) return 0;
    let t = Number.MIN_VALUE;
    for (let i = 0; i < e.keys.length; i++) {
      const n = e.keys[i];
      n.value > t && (t = n.value);
    }
    return t;
  }
};
C([
  u()
], Ls.prototype, "mode");
C([
  u()
], Ls.prototype, "constant");
C([
  u()
], Ls.prototype, "constantMin");
C([
  u()
], Ls.prototype, "constantMax");
C([
  u(Iu)
], Ls.prototype, "curve");
C([
  u(Iu)
], Ls.prototype, "curveMin");
C([
  u(Iu)
], Ls.prototype, "curveMax");
C([
  u()
], Ls.prototype, "curveMultiplier");
let Y = Ls;
const Po = class Ct {
  static constant(e) {
    const t = new Ct();
    return t.constant(e), t;
  }
  static betweenTwoColors(e, t) {
    const i = new Ct();
    return i.betweenTwoColors(e, t), i;
  }
  constant(e) {
    return this.mode = 0, this.color = e, this;
  }
  betweenTwoColors(e, t) {
    return this.mode = 2, this.colorMin = e, this.colorMax = t, this;
  }
  mode = 0;
  color;
  colorMin;
  colorMax;
  gradient;
  gradientMin;
  gradientMax;
  static _temp = new oe(0, 0, 0, 1);
  static _temp2 = new oe(0, 0, 0, 1);
  evaluate(e, t) {
    const i = t === void 0 ? Math.random() : t;
    switch (this.mode) {
      case 0:
      case "Color":
        return this.color;
      case 1:
      case "Gradient":
        return this.gradient.evaluate(e, Ct._temp), Ct._temp;
      case 2:
      case "TwoColors":
        return Ct._temp.lerpColors(this.colorMin, this.colorMax, i);
      case 3:
      case "TwoGradients":
        return this.gradientMin.evaluate(e, Ct._temp), this.gradientMax.evaluate(e, Ct._temp2), Ct._temp.lerp(Ct._temp2, i);
      case 4:
      case "RandomColor":
        const o = Math.random();
        return this.gradientMin.evaluate(e, Ct._temp), this.gradientMax.evaluate(e, Ct._temp2), Ct._temp.lerp(Ct._temp2, o);
    }
    return Ct._temp.set(16777215), Ct._temp.alpha = 1, Ct._temp;
  }
};
C([
  u()
], Po.prototype, "mode");
C([
  u(oe)
], Po.prototype, "color");
C([
  u(oe)
], Po.prototype, "colorMin");
C([
  u(oe)
], Po.prototype, "colorMax");
C([
  u(Qa)
], Po.prototype, "gradient");
C([
  u(Qa)
], Po.prototype, "gradientMin");
C([
  u(Qa)
], Po.prototype, "gradientMax");
let Ya = Po;
var sm = /* @__PURE__ */ ((s) => (s[s.Hierarchy = 0] = "Hierarchy", s[s.Local = 1] = "Local", s[s.Shape = 2] = "Shape", s))(sm || {});
class Qt {
  cullingMode;
  duration;
  emitterVelocityMode;
  flipRotation;
  gravityModifier;
  gravityModifierMultiplier;
  loop;
  maxParticles;
  playOnAwake;
  prewarm;
  ringBufferLoopRange;
  ringBufferMode;
  scalingMode;
  simulationSpace;
  simulationSpeed;
  startColor;
  startDelay;
  startDelayMultiplier;
  startLifetime;
  startLifetimeMultiplier;
  startRotation;
  startRotationMultiplier;
  startRotation3D;
  startRotationX;
  startRotationXMultiplier;
  startRotationY;
  startRotationYMultiplier;
  startRotationZ;
  startRotationZMultiplier;
  startSize;
  startSize3D;
  startSizeMultiplier;
  startSizeX;
  startSizeXMultiplier;
  startSizeY;
  startSizeYMultiplier;
  startSizeZ;
  startSizeZMultiplier;
  startSpeed;
  startSpeedMultiplier;
  stopAction;
  useUnscaledTime;
}
C([
  u(Y)
], Qt.prototype, "gravityModifier");
C([
  u(Ya)
], Qt.prototype, "startColor");
C([
  u(Y)
], Qt.prototype, "startDelay");
C([
  u(Y)
], Qt.prototype, "startLifetime");
C([
  u(Y)
], Qt.prototype, "startRotation");
C([
  u(Y)
], Qt.prototype, "startRotationX");
C([
  u(Y)
], Qt.prototype, "startRotationY");
C([
  u(Y)
], Qt.prototype, "startRotationZ");
C([
  u(Y)
], Qt.prototype, "startSize");
C([
  u(Y)
], Qt.prototype, "startSizeX");
C([
  u(Y)
], Qt.prototype, "startSizeY");
C([
  u(Y)
], Qt.prototype, "startSizeZ");
C([
  u(Y)
], Qt.prototype, "startSpeed");
class om {
  cycleCount;
  maxCount;
  minCount;
  probability;
  repeatInterval;
  time;
  count;
  _performed = 0;
  reset() {
    this._performed = 0;
  }
  run(e) {
    if (e <= this.time)
      return 0;
    let t = 0;
    if (this.cycleCount === 0 || this._performed < this.cycleCount) {
      const i = this.time + this.repeatInterval * this._performed;
      if (e >= i && (this._performed += 1, Math.random() < this.probability))
        switch (this.count.mode) {
          case 0:
            t = this.count.constant;
            break;
          case 3:
            t = j.lerp(this.count.constantMin, this.count.constantMax, Math.random());
            break;
          case 1:
            t = this.count.curve.evaluate(Math.random());
            break;
          case 2:
            const n = Math.random();
            t = j.lerp(this.count.curveMin.evaluate(n), this.count.curveMax.evaluate(n), Math.random());
            break;
        }
    }
    return t;
  }
}
class Oo {
  enabled;
  get burstCount() {
    return this.bursts?.length ?? 0;
  }
  bursts;
  rateOverTime;
  rateOverTimeMultiplier;
  rateOverDistance;
  rateOverDistanceMultiplier;
  /** set from system */
  system;
  reset() {
    this.bursts?.forEach((e) => e.reset());
  }
  getBurst() {
    let e = 0;
    if (this.burstCount > 0)
      for (let t = 0; t < this.burstCount; t++) {
        const i = this.bursts[t];
        this.system.main.loop && i.time >= this.system.time && i.reset(), e += Math.round(i.run(this.system.time));
      }
    return e;
  }
}
C([
  u()
], Oo.prototype, "enabled");
C([
  u()
], Oo.prototype, "bursts");
C([
  u(Y)
], Oo.prototype, "rateOverTime");
C([
  u()
], Oo.prototype, "rateOverTimeMultiplier");
C([
  u(Y)
], Oo.prototype, "rateOverDistance");
C([
  u()
], Oo.prototype, "rateOverDistanceMultiplier");
class Fg {
  enabled;
  color;
}
C([
  u(Ya)
], Fg.prototype, "color");
class Ka {
  enabled;
  separateAxes;
  size;
  sizeMultiplier;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  _time = 0;
  _temp = new y();
  evaluate(e, t, i) {
    if (t || (t = this._temp), !this.enabled)
      return t.x = t.y = t.z = 1, t;
    if (this.separateAxes)
      t.x = this.x.evaluate(e, i) * this.xMultiplier, t.y = this.y.evaluate(e, i) * this.yMultiplier, t.z = this.z.evaluate(e, i) * this.zMultiplier;
    else {
      const n = this.size.evaluate(e, i) * this.sizeMultiplier;
      t.x = n;
    }
    return t;
  }
}
C([
  u(Y)
], Ka.prototype, "size");
C([
  u(Y)
], Ka.prototype, "x");
C([
  u(Y)
], Ka.prototype, "y");
C([
  u(Y)
], Ka.prototype, "z");
const Ke = class $l {
  // Emittershape start
  get type() {
    return nm[this.shapeType];
  }
  initialize(e) {
    this.onInitialize(e), e.position.x = this._vector.x, e.position.y = this._vector.y, e.position.z = this._vector.z;
  }
  toJSON() {
    return this;
  }
  clone() {
    return new $l();
  }
  shapeType = 5;
  enabled = !0;
  alignToDirection = !1;
  angle = 0;
  arc = 360;
  arcSpread;
  arcSpeedMultiplier;
  arcMode;
  boxThickness;
  position;
  rotation;
  _rotation = new ot();
  scale;
  radius;
  radiusThickness;
  sphericalDirectionAmount;
  randomDirectionAmount;
  randomPositionAmount;
  meshShapeType;
  meshRenderer;
  _meshObj;
  _meshGeometry;
  setMesh(e) {
    this.meshRenderer = e, e ? (this._meshObj = e.sharedMeshes[Math.floor(Math.random() * e.sharedMeshes.length)], this._meshGeometry = this._meshObj.geometry) : (this._meshObj = void 0, this._meshGeometry = void 0);
  }
  system;
  _space;
  _worldSpaceMatrix = new ee();
  _worldSpaceMatrixInverse = new ee();
  constructor() {
    Rh && console.log(this);
  }
  update(e, t) {
  }
  onUpdate(e, t, i, n) {
    this.system = e, this._space = i, i === 1 && (this._worldSpaceMatrix.copy(n.matrixWorld), this._worldSpaceMatrix.elements[0] = 1, this._worldSpaceMatrix.elements[5] = 1, this._worldSpaceMatrix.elements[10] = 1, this._worldSpaceMatrixInverse.copy(this._worldSpaceMatrix).invert());
  }
  applyRotation(e) {
    const t = this.rotation.x !== 0 || this.rotation.y !== 0 || this.rotation.z !== 0;
    return t && (this._rotation.x = j.toRadians(this.rotation.x), this._rotation.y = j.toRadians(this.rotation.y), this._rotation.z = j.toRadians(this.rotation.z), this._rotation.order = "ZYX", e.applyEuler(this._rotation)), t;
  }
  /** nebula implementations: */
  /** initializer implementation */
  _vector = new y(0, 0, 0);
  _temp = new y(0, 0, 0);
  _triangle = new hS();
  onInitialize(e) {
    this._vector.set(0, 0, 0), e.mesh = void 0, e.mesh_geometry = void 0;
    const t = this._temp.copy(this.position), i = this._space === 1;
    i && t.applyQuaternion(this.system.worldQuaternion);
    let n = this.radius;
    if (i && (n *= this.system.worldScale.x), this.enabled) {
      switch (this.shapeType) {
        case 5:
          Rh && z.DrawWireBox(this.position, this.scale, 14540253, 1), this._vector.x = Math.random() * this.scale.x - this.scale.x / 2, this._vector.y = Math.random() * this.scale.y - this.scale.y / 2, this._vector.z = Math.random() * this.scale.z - this.scale.z / 2, this._vector.add(t);
          break;
        case 4:
          this.randomConePoint(this.position, this.angle, n, this.radiusThickness, this.arc, this.arcMode, this._vector);
          break;
        case 0:
          this.randomSpherePoint(this.position, n, this.radiusThickness, this.arc, this._vector);
          break;
        case 10:
          this.randomCirclePoint(this.position, n, this.radiusThickness, this.arc, this._vector);
          break;
        case 13:
          const o = this.meshRenderer;
          o?.destroyed == !1 && this.setMesh(o);
          const r = e.mesh = this._meshObj, a = e.mesh_geometry = this._meshGeometry;
          if (r && a)
            switch (this.meshShapeType) {
              case 0:
                {
                  const l = a.getAttribute("position"), c = Math.floor(Math.random() * l.count);
                  this._vector.fromBufferAttribute(l, c), this._vector.applyMatrix4(r.matrixWorld), e.mesh_normal = c;
                }
                break;
              case 1:
                break;
              case 2:
                {
                  const l = a.index;
                  if (l) {
                    let c = Math.random(), h = Math.random();
                    c + h > 1 && (c = 1 - c, h = 1 - h);
                    const d = Math.floor(Math.random() * (l.count / 3));
                    let f = d * 3, p = d * 3 + 1, g = d * 3 + 2;
                    f = l.getX(f), p = l.getX(p), g = l.getX(g);
                    const b = a.getAttribute("position");
                    this._triangle.a.fromBufferAttribute(b, f), this._triangle.b.fromBufferAttribute(b, p), this._triangle.c.fromBufferAttribute(b, g), this._vector.set(0, 0, 0).addScaledVector(this._triangle.a, c).addScaledVector(this._triangle.b, h).addScaledVector(this._triangle.c, 1 - (c + h)), this._vector.applyMatrix4(r.matrixWorld), e.mesh_normal = d;
                  }
                }
                break;
            }
          break;
        default:
          this._vector.set(0, 0, 0), L() && !globalThis.__particlesystem_shapetype_unsupported && (console.warn("ParticleSystem ShapeType is not supported:", nm[this.shapeType]), globalThis.__particlesystem_shapetype_unsupported = !0);
          break;
      }
      this.randomizePosition(this._vector, this.randomPositionAmount);
    }
    this.applyRotation(this._vector), i && (this._vector.applyQuaternion(this.system.worldQuaternion), this._vector.add(this.system.worldPos)), Rh && z.DrawSphere(this._vector, 0.03, 16711680, 0.5, !0);
  }
  _dir = new y();
  getDirection(e, t) {
    if (!this.enabled)
      return this._dir.set(0, 0, 1), this._dir;
    switch (this.shapeType) {
      case 5:
        this._dir.set(0, 0, 1);
        break;
      case 4:
        this._dir.set(0, 0, 1);
        break;
      case 10:
      case 0:
        const i = t.x, n = t.y, o = t.z;
        this._dir.set(i, n, o), this.system?.worldspace ? this._dir.sub(this.system.worldPos) : this._dir.sub(this.position);
        break;
      case 13:
        const r = e.mesh, a = e.mesh_geometry;
        if (r && a)
          switch (this.meshShapeType) {
            case 0:
              {
                const l = a.getAttribute("normal"), c = e.mesh_normal;
                this._dir.fromBufferAttribute(l, c);
              }
              break;
            case 1:
              break;
            case 2:
              {
                const l = a.index;
                if (l) {
                  const c = e.mesh_normal, h = l.getX(c * 3), d = l.getX(c * 3 + 1), f = l.getX(c * 3 + 2), p = a.getAttribute("position"), g = H(), b = H(), m = H();
                  g.fromBufferAttribute(p, h), b.fromBufferAttribute(p, d), m.fromBufferAttribute(p, f), g.sub(b), m.sub(b), g.cross(m), this._dir.copy(g).multiplyScalar(-1);
                  const v = be(r);
                  this._dir.applyQuaternion(v);
                }
              }
              break;
          }
        break;
      default:
        this._dir.set(0, 0, 1);
        break;
    }
    return this._space === 1 && this._dir.applyQuaternion(this.system.worldQuaternion), this.applyRotation(this._dir), this._dir.normalize(), this.spherizeDirection(this._dir, this.sphericalDirectionAmount), this.randomizeDirection(this._dir, this.randomDirectionAmount), Rh && (z.DrawSphere(t, 0.01, 8925952, 0.5, !0), z.DrawDirection(t, this._dir, 8925952, 0.5, !0)), this._dir;
  }
  static _randomQuat = new U();
  static _tempVec = new y();
  randomizePosition(e, t) {
    if (t <= 0) return;
    const i = $l._tempVec;
    i.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1), i.x *= t * this.scale.x, i.y *= t * this.scale.y, i.z *= t * this.scale.z, e.add(i);
  }
  randomizeDirection(e, t) {
    if (t === 0) return;
    const i = $l._randomQuat, n = $l._tempVec;
    n.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(), i.setFromAxisAngle(n, t * Math.random() * Math.PI), e.applyQuaternion(i);
  }
  spherizeDirection(e, t) {
    if (t === 0) return;
    const i = Math.random() * Math.PI * 2, n = Math.acos(1 - Math.random() * 2), o = Math.sin(n) * Math.cos(i), r = Math.sin(n) * Math.sin(i), a = Math.cos(n), l = new y(o, r, a);
    e.lerp(l, t);
  }
  randomSpherePoint(e, t, i, n, o) {
    const r = Math.random(), a = Math.random(), l = 2 * Math.PI * r * (n / 360), c = Math.acos(2 * a - 1), h = j.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), i) * t, d = e.x + this.scale.x * (-h * Math.sin(c) * Math.cos(l)), f = e.y + this.scale.y * (h * Math.sin(c) * Math.sin(l)), p = e.z + this.scale.z * (h * Math.cos(c));
    o.x = d, o.y = f, o.z = p;
  }
  randomCirclePoint(e, t, i, n, o) {
    const r = Math.random(), a = 2 * Math.PI * r * (n / 360), l = j.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), i) * t, c = e.x + this.scale.x * l * Math.cos(a), h = e.y + this.scale.y * l * Math.sin(a), d = e.z;
    o.x = c, o.y = h, o.z = d;
  }
  _loopTime = 0;
  _loopDirection = 1;
  randomConePoint(e, t, i, n, o, r, a) {
    let l = 0, c = 0;
    switch (r) {
      case 0:
        l = Math.random(), c = Math.random();
        break;
      case 2:
        this._loopTime > 1 && (this._loopDirection = -1), this._loopTime < 0 && (this._loopDirection = 1);
      // continue with loop 
      case 1:
        l = 0.5, c = Math.random(), this._loopTime += this.system.deltaTime * this._loopDirection;
        break;
    }
    let h = 2 * Math.PI * l * (o / 360);
    switch (r) {
      case 2:
      case 1:
        h += Math.PI + 0.5, h += this._loopTime * Math.PI * 2, h %= j.toRadians(o);
        break;
    }
    const d = Math.acos(2 * c - 1), f = j.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), n) * i, p = e.x + -f * Math.sin(d) * Math.cos(h), g = e.y + f * Math.sin(d) * Math.sin(h), b = e.z;
    a.x = p * this.scale.x, a.y = g * this.scale.y, a.z = b * this.scale.z;
  }
};
C([
  u()
], Ke.prototype, "shapeType");
C([
  u()
], Ke.prototype, "enabled");
C([
  u()
], Ke.prototype, "alignToDirection");
C([
  u()
], Ke.prototype, "angle");
C([
  u()
], Ke.prototype, "arc");
C([
  u()
], Ke.prototype, "arcSpread");
C([
  u()
], Ke.prototype, "arcSpeedMultiplier");
C([
  u()
], Ke.prototype, "arcMode");
C([
  u(y)
], Ke.prototype, "boxThickness");
C([
  u(y)
], Ke.prototype, "position");
C([
  u(y)
], Ke.prototype, "rotation");
C([
  u(y)
], Ke.prototype, "scale");
C([
  u()
], Ke.prototype, "radius");
C([
  u()
], Ke.prototype, "radiusThickness");
C([
  u()
], Ke.prototype, "sphericalDirectionAmount");
C([
  u()
], Ke.prototype, "randomDirectionAmount");
C([
  u()
], Ke.prototype, "randomPositionAmount");
C([
  u()
], Ke.prototype, "meshShapeType");
C([
  u(yu)
], Ke.prototype, "meshRenderer");
let gw = Ke;
class ve {
  damping;
  enabled;
  frequency;
  octaveCount;
  octaveMultiplier;
  octaveScale;
  positionAmount;
  quality;
  remap;
  remapEnabled;
  remapMultiplier;
  remapX;
  remapXMultiplier;
  remapY;
  remapYMultiplier;
  remapZ;
  remapZMultiplier;
  scrollSpeedMultiplier;
  separateAxes;
  strengthMultiplier;
  strengthX;
  strengthXMultiplier;
  strengthY;
  strengthYMultiplier;
  strengthZ;
  strengthZMultiplier;
  _noise;
  _time = 0;
  update(e) {
    this._time += e.time.deltaTime * this.scrollSpeedMultiplier;
  }
  /** nebula implementations: */
  _temp = new y();
  apply(e, t, i, n, o, r) {
    if (!this.enabled) return;
    this._noise || (this._noise = QS(() => 0));
    const a = this._temp.set(t.x, t.y, t.z).multiplyScalar(this.frequency), l = this._noise(a.x, a.y, a.z, this._time), c = this._noise(a.x, a.y, a.z, this._time + 1e3 * this.frequency), h = this._noise(a.x, a.y, a.z, this._time + 2e3 * this.frequency);
    this._temp.set(l, c, h).normalize();
    const d = o / r;
    let f = this.positionAmount.evaluate(d);
    this.separateAxes ? (this._temp.x *= f * this.strengthXMultiplier, this._temp.y *= f * this.strengthYMultiplier, this._temp.z *= f * this.strengthZMultiplier) : (this.strengthX && (f *= this.strengthX.evaluate(d) * 1.5), this._temp.multiplyScalar(f)), i.x += this._temp.x, i.y += this._temp.y, i.z += this._temp.z;
  }
}
C([
  u()
], ve.prototype, "damping");
C([
  u()
], ve.prototype, "enabled");
C([
  u()
], ve.prototype, "frequency");
C([
  u()
], ve.prototype, "octaveCount");
C([
  u()
], ve.prototype, "octaveMultiplier");
C([
  u()
], ve.prototype, "octaveScale");
C([
  u(Y)
], ve.prototype, "positionAmount");
C([
  u()
], ve.prototype, "quality");
C([
  u(Y)
], ve.prototype, "remap");
C([
  u()
], ve.prototype, "remapEnabled");
C([
  u()
], ve.prototype, "remapMultiplier");
C([
  u(Y)
], ve.prototype, "remapX");
C([
  u()
], ve.prototype, "remapXMultiplier");
C([
  u(Y)
], ve.prototype, "remapY");
C([
  u()
], ve.prototype, "remapYMultiplier");
C([
  u(Y)
], ve.prototype, "remapZ");
C([
  u()
], ve.prototype, "remapZMultiplier");
C([
  u()
], ve.prototype, "scrollSpeedMultiplier");
C([
  u()
], ve.prototype, "separateAxes");
C([
  u()
], ve.prototype, "strengthMultiplier");
C([
  u(Y)
], ve.prototype, "strengthX");
C([
  u()
], ve.prototype, "strengthXMultiplier");
C([
  u(Y)
], ve.prototype, "strengthY");
C([
  u()
], ve.prototype, "strengthYMultiplier");
C([
  u(Y)
], ve.prototype, "strengthZ");
C([
  u()
], ve.prototype, "strengthZMultiplier");
class Ne {
  enabled;
  attachRibbonToTransform = !1;
  colorOverLifetime;
  colorOverTrail;
  dieWithParticles = !0;
  inheritParticleColor = !0;
  lifetime;
  lifetimeMultiplier;
  minVertexDistance = 0.2;
  mode = 0;
  ratio = 1;
  ribbonCount = 1;
  shadowBias = 0;
  sizeAffectsLifetime = !1;
  sizeAffectsWidth = !1;
  splitSubEmitterRibbons = !1;
  textureMode = 0;
  widthOverTrail;
  widthOverTrailMultiplier;
  worldSpace = !1;
  getWidth(e, t, i, n) {
    const o = this.widthOverTrail.evaluate(i, n);
    return e *= o, e;
  }
  getColor(e, t, i) {
    const n = this.colorOverTrail.evaluate(i), o = this.colorOverLifetime.evaluate(t);
    e.x *= n.r * o.r, e.y *= n.g * o.g, e.z *= n.b * o.b, "alpha" in n && "alpha" in o && (e.w *= n.alpha * o.alpha);
  }
}
C([
  u()
], Ne.prototype, "enabled");
C([
  u()
], Ne.prototype, "attachRibbonToTransform");
C([
  u(Ya)
], Ne.prototype, "colorOverLifetime");
C([
  u(Ya)
], Ne.prototype, "colorOverTrail");
C([
  u()
], Ne.prototype, "dieWithParticles");
C([
  u()
], Ne.prototype, "inheritParticleColor");
C([
  u(Y)
], Ne.prototype, "lifetime");
C([
  u()
], Ne.prototype, "lifetimeMultiplier");
C([
  u()
], Ne.prototype, "minVertexDistance");
C([
  u()
], Ne.prototype, "mode");
C([
  u()
], Ne.prototype, "ratio");
C([
  u()
], Ne.prototype, "ribbonCount");
C([
  u()
], Ne.prototype, "shadowBias");
C([
  u()
], Ne.prototype, "sizeAffectsLifetime");
C([
  u()
], Ne.prototype, "sizeAffectsWidth");
C([
  u()
], Ne.prototype, "splitSubEmitterRibbons");
C([
  u()
], Ne.prototype, "textureMode");
C([
  u(Y)
], Ne.prototype, "widthOverTrail");
C([
  u()
], Ne.prototype, "widthOverTrailMultiplier");
C([
  u()
], Ne.prototype, "worldSpace");
class Ve {
  enabled;
  space = 0;
  orbitalX;
  orbitalY;
  orbitalZ;
  orbitalXMultiplier;
  orbitalYMultiplier;
  orbitalZMultiplier;
  orbitalOffsetX;
  orbitalOffsetY;
  orbitalOffsetZ;
  speedModifier;
  speedModifierMultiplier;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  _system;
  // private _worldRotation: Quaternion = new Quaternion();
  update(e) {
    this._system = e;
  }
  _temp = new y();
  _temp2 = new y();
  _temp3 = new y();
  _hasOrbital = !1;
  _index = 0;
  _orbitalMatrix = new ee();
  init(e) {
    this._index == 0 && (e.debug = !0), this._index += 1, e.orbitx = this.orbitalX.evaluate(Math.random()), e.orbity = this.orbitalY.evaluate(Math.random()), e.orbitz = this.orbitalZ.evaluate(Math.random()), this._hasOrbital = e.orbitx != 0 || e.orbity != 0 || e.orbitz != 0;
  }
  apply(e, t, i, n, o, r, a) {
    if (!this.enabled) return;
    const l = r / a, c = this.speedModifier.evaluate(l) * this.speedModifierMultiplier, h = this.x.evaluate(l), d = this.y.evaluate(l), f = this.z.evaluate(l);
    if (this._temp.set(-h, d, f), this._system && this._system.main.simulationSpace === 1 && this._temp.applyQuaternion(this._system.worldQuaternion), this._hasOrbital && this._system?.worldPos) {
      const g = this._temp2.set(i.x, i.y, i.z), b = this.orbitalXMultiplier, m = this.orbitalYMultiplier, v = this.orbitalZMultiplier, _ = c * Math.PI * 2 * 10, x = Math.cos(_ * b), I = Math.sin(_ * b), O = Math.cos(_ * m), k = Math.sin(_ * m), E = Math.cos(_ * v), B = Math.sin(_ * v), D = g.x * (O * E) + g.y * (O * B) + g.z * -k, W = g.x * (I * k * E - x * B) + g.y * (I * k * B + x * E) + g.z * (I * O), X = g.x * (x * k * E + I * B) + g.y * (x * k * B - I * E) + g.z * (x * O), A = this._temp3.set(g.x - D, g.y - W, g.z - X);
      A.normalize(), A.multiplyScalar(0.2 / o * Math.max(this.orbitalXMultiplier, this.orbitalYMultiplier, this.orbitalZMultiplier)), n.x += A.x, n.y += A.y, n.z += A.z;
    }
    n.x += this._temp.x, n.y += this._temp.y, n.z += this._temp.z, n.x *= c, n.y *= c, n.z *= c;
  }
}
C([
  u()
], Ve.prototype, "enabled");
C([
  u()
], Ve.prototype, "space");
C([
  u(Y)
], Ve.prototype, "orbitalX");
C([
  u(Y)
], Ve.prototype, "orbitalY");
C([
  u(Y)
], Ve.prototype, "orbitalZ");
C([
  u()
], Ve.prototype, "orbitalXMultiplier");
C([
  u()
], Ve.prototype, "orbitalYMultiplier");
C([
  u()
], Ve.prototype, "orbitalZMultiplier");
C([
  u()
], Ve.prototype, "orbitalOffsetX");
C([
  u()
], Ve.prototype, "orbitalOffsetY");
C([
  u()
], Ve.prototype, "orbitalOffsetZ");
C([
  u(Y)
], Ve.prototype, "speedModifier");
C([
  u()
], Ve.prototype, "speedModifierMultiplier");
C([
  u(Y)
], Ve.prototype, "x");
C([
  u()
], Ve.prototype, "xMultiplier");
C([
  u(Y)
], Ve.prototype, "y");
C([
  u()
], Ve.prototype, "yMultiplier");
C([
  u(Y)
], Ve.prototype, "z");
C([
  u()
], Ve.prototype, "zMultiplier");
class Yt {
  animation;
  enabled;
  cycleCount;
  frameOverTime;
  frameOverTimeMultiplier;
  numTilesX;
  numTilesY;
  startFrame;
  startFrameMultiplier;
  rowMode;
  rowIndex;
  spriteCount;
  timeMode;
  sampleOnceAtStart() {
    if (this.timeMode === 0)
      switch (this.frameOverTime.mode) {
        case 0:
        case 3:
        case 2:
        case 1:
          return !0;
      }
    return !1;
  }
  getStartIndex() {
    return this.sampleOnceAtStart() ? Math.random() * (this.numTilesX * this.numTilesY) : 0;
  }
  evaluate(e) {
    if (!this.sampleOnceAtStart())
      return this.getIndex(e);
  }
  getIndex(e) {
    const t = this.numTilesX * this.numTilesY;
    e = e * this.cycleCount;
    let i = this.frameOverTime.evaluate(e % 1);
    return i *= this.frameOverTimeMultiplier, i *= t, i = i % t, i = Math.floor(i), i;
  }
}
C([
  u()
], Yt.prototype, "animation");
C([
  u()
], Yt.prototype, "enabled");
C([
  u()
], Yt.prototype, "cycleCount");
C([
  u(Y)
], Yt.prototype, "frameOverTime");
C([
  u()
], Yt.prototype, "frameOverTimeMultiplier");
C([
  u()
], Yt.prototype, "numTilesX");
C([
  u()
], Yt.prototype, "numTilesY");
C([
  u(Y)
], Yt.prototype, "startFrame");
C([
  u()
], Yt.prototype, "startFrameMultiplier");
C([
  u()
], Yt.prototype, "rowMode");
C([
  u()
], Yt.prototype, "rowIndex");
C([
  u()
], Yt.prototype, "spriteCount");
C([
  u()
], Yt.prototype, "timeMode");
class Gn {
  enabled;
  separateAxes;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  evaluate(e, t) {
    return this.enabled ? this.separateAxes ? 0 : this.z.evaluate(e, t) * -1 : 0;
  }
}
C([
  u()
], Gn.prototype, "enabled");
C([
  u()
], Gn.prototype, "separateAxes");
C([
  u(Y)
], Gn.prototype, "x");
C([
  u()
], Gn.prototype, "xMultiplier");
C([
  u(Y)
], Gn.prototype, "y");
C([
  u()
], Gn.prototype, "yMultiplier");
C([
  u(Y)
], Gn.prototype, "z");
C([
  u()
], Gn.prototype, "zMultiplier");
class pn {
  enabled;
  range;
  separateAxes;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  evaluate(e, t) {
    if (!this.enabled) return 0;
    if (!this.separateAxes) {
      const i = j.lerp(this.range.x, this.range.y, t);
      return this.z.evaluate(i) * -1;
    }
    return 0;
  }
}
C([
  u()
], pn.prototype, "enabled");
C([
  u()
], pn.prototype, "range");
C([
  u()
], pn.prototype, "separateAxes");
C([
  u(Y)
], pn.prototype, "x");
C([
  u()
], pn.prototype, "xMultiplier");
C([
  u(Y)
], pn.prototype, "y");
C([
  u()
], pn.prototype, "yMultiplier");
C([
  u(Y)
], pn.prototype, "z");
C([
  u()
], pn.prototype, "zMultiplier");
class _t {
  enabled;
  dampen;
  drag;
  dragMultiplier;
  limit;
  limitMultiplier;
  separateAxes;
  limitX;
  limitXMultiplier;
  limitY;
  limitYMultiplier;
  limitZ;
  limitZMultiplier;
  multiplyDragByParticleSize = !1;
  multiplyDragByParticleVelocity = !1;
  space;
  _temp = new y();
  _temp2 = new y();
  apply(e, t, i, n, o, r, a) {
    if (this.enabled) {
      const l = this.limit.evaluate(o) * this.limitMultiplier;
      if (t.length() > l) {
        this._temp.copy(t).normalize().multiplyScalar(l);
        const h = this.dampen * 0.5;
        t.x = j.lerp(t.x, this._temp.x, h), t.y = j.lerp(t.y, this._temp.y, h), t.z = j.lerp(t.z, this._temp.z, h), i.x = j.lerp(i.x, this._temp.x, h), i.y = j.lerp(i.y, this._temp.y, h), i.z = j.lerp(i.z, this._temp.z, h);
      }
    }
  }
}
C([
  u()
], _t.prototype, "enabled");
C([
  u()
], _t.prototype, "dampen");
C([
  u(Y)
], _t.prototype, "drag");
C([
  u()
], _t.prototype, "dragMultiplier");
C([
  u(Y)
], _t.prototype, "limit");
C([
  u()
], _t.prototype, "limitMultiplier");
C([
  u()
], _t.prototype, "separateAxes");
C([
  u(Y)
], _t.prototype, "limitX");
C([
  u()
], _t.prototype, "limitXMultiplier");
C([
  u(Y)
], _t.prototype, "limitY");
C([
  u()
], _t.prototype, "limitYMultiplier");
C([
  u(Y)
], _t.prototype, "limitZ");
C([
  u()
], _t.prototype, "limitZMultiplier");
C([
  u()
], _t.prototype, "multiplyDragByParticleSize");
C([
  u()
], _t.prototype, "multiplyDragByParticleVelocity");
C([
  u()
], _t.prototype, "space");
const Uc = class yw {
  enabled;
  curve;
  curveMultiplier;
  mode;
  clone() {
    const e = new yw();
    return e.enabled = this.enabled, e.curve = this.curve?.clone(), e.curveMultiplier = this.curveMultiplier, e.mode = this.mode, e;
  }
  system;
  get _lastWorldPosition() {
    return this.system._iv_lastWorldPosition || (this.system._iv_lastWorldPosition = new y()), this.system._iv_lastWorldPosition;
  }
  get _velocity() {
    return this.system._iv_velocity || (this.system._iv_velocity = new y()), this.system._iv_velocity;
  }
  _temp = new y();
  _firstUpdate = !0;
  awake(e) {
    this.system = e, this.reset();
  }
  reset() {
    this._firstUpdate = !0;
  }
  update(e) {
    this.enabled && this.system.worldspace !== !1 && (this._firstUpdate ? (this._firstUpdate = !1, this._velocity.set(0, 0, 0), this._lastWorldPosition.copy(this.system.worldPos)) : this._lastWorldPosition && (this._velocity.copy(this.system.worldPos).sub(this._lastWorldPosition).multiplyScalar(1 / this.system.deltaTime), this._lastWorldPosition.copy(this.system.worldPos)));
  }
  // TODO: make work for subsystems
  applyInitial(e) {
    if (this.enabled && this.system.worldspace !== !1 && this.mode === 0) {
      const t = this.curve.evaluate(Math.random(), Math.random());
      this._temp.copy(this._velocity).multiplyScalar(t), e.x += this._temp.x, e.y += this._temp.y, e.z += this._temp.z;
    }
  }
  _frames = 0;
  applyCurrent(e, t, i) {
    if (this.enabled && this.system && this.system.worldspace !== !1 && this.mode === 1) {
      const n = this.curve.evaluate(t, i);
      this._temp.copy(this._velocity).multiplyScalar(n), e.x += this._temp.x, e.y += this._temp.y, e.z += this._temp.z;
    }
  }
};
C([
  u()
], Uc.prototype, "enabled");
C([
  u(Y)
], Uc.prototype, "curve");
C([
  u()
], Uc.prototype, "curveMultiplier");
C([
  u()
], Uc.prototype, "mode");
let _w = Uc;
class Mi {
  enabled;
  range;
  separateAxes;
  size;
  sizeMultiplier;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  evaluate(e, t, i, n) {
    const o = e.length(), r = j.remap(o, this.range.x, this.range.y, 0, 1), a = this.size.evaluate(r, i);
    return n.x *= a, n.y *= a, n.z *= a, n;
  }
}
C([
  u()
], Mi.prototype, "enabled");
C([
  u(J)
], Mi.prototype, "range");
C([
  u()
], Mi.prototype, "separateAxes");
C([
  u(Y)
], Mi.prototype, "size");
C([
  u()
], Mi.prototype, "sizeMultiplier");
C([
  u(Y)
], Mi.prototype, "x");
C([
  u()
], Mi.prototype, "xMultiplier");
C([
  u(Y)
], Mi.prototype, "y");
C([
  u()
], Mi.prototype, "yMultiplier");
C([
  u(Y)
], Mi.prototype, "z");
C([
  u()
], Mi.prototype, "zMultiplier");
class Nc {
  enabled;
  range;
  color;
  evaluate(e, t, i) {
    const n = e.length(), o = j.remap(n, this.range.x, this.range.y, 0, 1), r = this.color.evaluate(o, t);
    i.x *= r.r, i.y *= r.g, i.z *= r.b, "alpha" in r && (i.w *= r.alpha);
  }
}
C([
  u()
], Nc.prototype, "enabled");
C([
  u(J)
], Nc.prototype, "range");
C([
  u(Ya)
], Nc.prototype, "color");
new y(1, 1, 1);
new y(0, 0, 1);
class bw {
  constructor(e, t, i, n) {
    this.system = e, this.particleSystem = t, this.subSystem = i, this.subParticleSystem = n, this.subParticleSystem && this.subParticleSystem && (this.subParticleSystem.onlyUsedByOther = !0);
    const o = 1e3;
    this._circularBuffer = new Hi(() => new nf(), o);
  }
  type = "NeedleParticleSubEmitter";
  emitterType;
  emitterProbability;
  //private matrix_ = new Matrix4();
  q_ = new U();
  v_ = new y();
  v2_ = new y();
  _emitterMatrix = new nf();
  _circularBuffer;
  clone() {
    throw new Error("Method not implemented.");
  }
  initialize(e) {
    e.emissionState = {
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0
      // matrix: new Matrix4(),
    }, this._emitterMatrix.copy(this.subSystem.matrixWorld).invert().premultiply(this.system.matrixWorld), this._emitterMatrix.setPosition(0, 0, 0), this.emitterType === rm.Birth && this.run(e);
  }
  update(e, t) {
    this.run(e);
  }
  frameUpdate(e) {
  }
  toJSON() {
  }
  reset() {
  }
  run(e) {
    if (this.subSystem.currentParticles >= this.subSystem.main.maxParticles || !this.subParticleSystem || !e.emissionState || this.emitterProbability && Math.random() > this.emitterProbability)
      return;
    const t = this.system.deltaTime;
    if (this.emitterType === rm.Death) {
      let n = e.life;
      if (e[ta] !== void 0 && (n = e[ta]), !(e.age + t * 1.2 >= n)) return;
      const r = this.subSystem.main.maxParticles - this.subSystem.currentParticles;
      e.emissionState.waitEmiting = r;
    }
    const i = new nf();
    i.set(
      1,
      0,
      0,
      e.position.x,
      0,
      1,
      0,
      e.position.y,
      0,
      0,
      1,
      e.position.z,
      0,
      0,
      0,
      1
    ), this.particleSystem.worldSpace || i.multiplyMatrices(this._emitterMatrix, i), this.subParticleSystem.emit(t, e.emissionState, i);
  }
}
var MT = Object.defineProperty, ze = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && MT(e, t, n), n;
};
const Ys = w("debugparticles"), RT = w("noprogressive"), TT = w("debugprogressive");
var rm = /* @__PURE__ */ ((s) => (s[s.Birth = 0] = "Birth", s[s.Collision = 1] = "Collision", s[s.Death = 2] = "Death", s[s.Trigger = 3] = "Trigger", s[s.Manual = 4] = "Manual", s))(rm || {});
class mn extends R {
  renderMode;
  particleMaterial;
  trailMaterial;
  // @serializable(Mesh)
  particleMesh;
  maxParticleSize;
  minParticleSize;
  velocityScale;
  cameraVelocityScale;
  lengthScale;
  start() {
    if (this.maxParticleSize !== 0.5 && this.minParticleSize !== 0 && L()) {
      const e = `ParticleSystem "${this.name}" has non-default min/max particle size. This may not render correctly. Please set min size to 0 and the max size to 0.5 and use the "StartSize" setting instead`;
      console.warn(e);
    }
  }
  get transparent() {
    return this.particleMaterial?.transparent ?? !1;
  }
  getMaterial(e = !1) {
    let t = e === !0 && this.trailMaterial ? this.trailMaterial : this.particleMaterial;
    if (t) {
      if (t.type === "MeshStandardMaterial") {
        Ys && console.debug("ParticleSystemRenderer.getMaterial: MeshStandardMaterial detected, converting to MeshBasicMaterial. See https://github.com/Alchemist0823/three.quarks/issues/101"), "map" in t && t.map && (t.map.colorSpace = Ss, t.map.premultiplyAlpha = !1);
        const i = new we();
        i.copy(t), e ? this.trailMaterial = i : this.particleMaterial = i;
      }
      t.map && (t.map.colorSpace = Ss, t.map.premultiplyAlpha = !1), e && t.side === fo && (t = t.clone(), t.side = Gd, e ? this.trailMaterial = t : this.particleMaterial = t);
    }
    return t && !RT && t._didRequestTextureLOD === void 0 && (t._didRequestTextureLOD = 0, TT && console.log("Load material LOD", t.name), We.assignTextureLOD(t, 0)), t;
  }
  getMesh(e) {
    let t = null;
    if (!t && (this.particleMesh instanceof G && (t = this.particleMesh.geometry), t === null)) {
      t = new Nn(1, 1);
      const n = t.attributes.uv;
      for (let o = 0; o < n.count; o++)
        n.setX(o, 1 - n.getX(o));
    }
    return new G(t, this.getMaterial());
  }
}
ze([
  u()
], mn.prototype, "renderMode");
ze([
  u(_e)
], mn.prototype, "particleMaterial");
ze([
  u(_e)
], mn.prototype, "trailMaterial");
ze([
  u()
], mn.prototype, "maxParticleSize");
ze([
  u()
], mn.prototype, "minParticleSize");
ze([
  u()
], mn.prototype, "velocityScale");
ze([
  u()
], mn.prototype, "cameraVelocityScale");
ze([
  u()
], mn.prototype, "lengthScale");
class Th {
  _curve;
  _factor;
  constructor(e, t = 1) {
    this._curve = e, this._factor = t;
  }
  type = "function";
  startGen(e) {
  }
  genValue(e, t) {
    return this._curve.evaluate(t, Math.random()) * this._factor;
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
}
class zg {
  type = "value";
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  startGen(e) {
  }
  system;
  constructor(e) {
    this.system = e;
  }
}
class ET extends zg {
  genValue() {
    return this.system.textureSheetAnimation.getStartIndex();
  }
}
class AT extends zg {
  _lastPosition = new y();
  _lastDistance = 0;
  update() {
    const e = Z(this.system.gameObject);
    this._lastDistance = this._lastPosition.distanceTo(e), this._lastPosition.copy(e);
  }
  genValue() {
    if (!this.system.isPlaying || !this.system.emission.enabled || this.system.currentParticles >= this.system.maxParticles) return 0;
    let e = this.system.emission.rateOverTime.evaluate(this.system.time / this.system.duration, Math.random());
    if (this.system.deltaTime > 0) {
      const n = this.system.emission.rateOverDistance.evaluate(this.system.time / this.system.duration, Math.random());
      let r = this._lastDistance / this.system.deltaTime * n;
      Number.isFinite(r) || (r = 0), e += r;
    }
    const t = this.system.emission.getBurst();
    t > 0 && (e += t / this.system.deltaTime);
    const i = this.system.maxParticles - this.system.currentParticles;
    return j.clamp(e, 0, i / this.system.deltaTime);
  }
}
class IT extends zg {
  genValue() {
    return this.system.isPlaying, 0;
  }
}
class Pr {
  system;
  get context() {
    return this.system.context;
  }
  constructor(e) {
    this.type = Object.getPrototypeOf(this).constructor.name || "ParticleSystemBaseBehaviour", e && (this.system = e);
  }
  type;
  initialize(e) {
  }
  update(e, t) {
  }
  frameUpdate(e) {
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  reset() {
  }
}
class LT extends Pr {
  type = "NeedleTextureSheet";
  // initialize(_particle: Particle): void {
  //     _particle[$startFrame] = this.system.textureSheetAnimation.getStartIndex();
  // }
  update(e, t) {
    const i = this.system.textureSheetAnimation;
    if (i.enabled) {
      const n = e.age / e.life, o = i.evaluate(n);
      o !== void 0 && (e.uvTile = o);
    }
  }
}
const J_ = Symbol("particleRotation");
class DT extends Pr {
  type = "NeedleRotation";
  initialize(e) {
    e[J_] = Math.random();
  }
  update(e, t) {
    if (e.rotation === void 0) return;
    const i = e.age / e.life;
    if (typeof e.rotation == "number" && (this.system.rotationOverLifetime.enabled ? e.rotation += this.system.rotationOverLifetime.evaluate(i, e[J_]) * t : this.system.renderer.renderMode === cs.Billboard && (e.rotation = Math.PI), this.system.rotationBySpeed.enabled)) {
      const n = e.velocity.length();
      e.rotation += this.system.rotationBySpeed.evaluate(i, n) * t;
    }
  }
}
const eb = Symbol("sizeLerpFactor"), jT = new y();
class BT extends Pr {
  type = "NeedleSize";
  _minSize = 0;
  _maxSize = 1;
  initialize(e) {
    e[eb] = Math.random(), this._minSize = this.system.renderer.minParticleSize, this._maxSize = this.system.renderer.maxParticleSize;
  }
  update(e, t) {
    const i = e.age / e.life;
    let n = 1;
    this.system.sizeOverLifetime.enabled && (n *= this.system.sizeOverLifetime.evaluate(i, void 0, e[eb]).x);
    let o = 1;
    this.system.renderer.renderMode !== cs.Mesh && (o = this.system.worldScale.x / this.system.cameraScale);
    const r = H(e.startSize).multiplyScalar(n * o);
    if (e.size.set(r.x, r.y, r.z), this.system.localspace) {
      const a = vw(this.system, jT);
      e.size.x *= a.x, e.size.y *= a.y, e.size.z *= a.z;
    }
  }
}
const ta = Symbol("particleLife"), ep = Symbol("trailLifetime"), tb = Symbol("trailStartLength"), tp = Symbol("trailWidthRandom");
class FT extends Pr {
  type = "NeedleTrail";
  initialize(e) {
    e instanceof py && (e[ta] = e.life, this.system.trails.enabled && this.system.trails.dieWithParticles === !1 && (e[ep] = this.system.trails.lifetime.evaluate(Math.random(), Math.random()), e.life += e[ep]), e[tb] = e.length, e[tp] = Math.random());
  }
  update(e) {
    if (this.system.trails?.enabled && e instanceof py) {
      const t = e, i = e.age / e[ta], n = e.previous.values(), o = e.previous.length;
      for (let r = 0; r < o; r++) {
        const l = n.next().value, c = 1 - r / (o - 1), h = e.size;
        if (h.x <= 0 && !this.system.trails.sizeAffectsWidth) {
          const d = 20 * this.system.trails.widthOverTrail.evaluate(0.5, t[tp]);
          h.x = d, h.y = d, h.z = d;
        }
        l.size = this.system.trails.getWidth(h.x, i, c, t[tp]), l.color.copy(e.color), this.system.trails.getColor(l.color, i, c);
      }
      if (e.age > e[ta]) {
        e.velocity.set(0, 0, 0);
        const r = (e.age - e[ta]) / e[ep];
        t.length = j.lerp(e[tb], 0, r);
      }
    }
  }
}
const Eh = Symbol("startVelocity"), ib = Symbol("gravityModifier"), ip = Symbol("gravitySpeed"), Ah = Symbol("velocity lerp factor"), am = new y();
class zT extends Pr {
  type = "NeedleVelocity";
  _gravityDirection = new y();
  initialize(e) {
    const t = this.system.main.simulationSpeed;
    e.startSpeed = this.system.main.startSpeed.evaluate(Math.random(), Math.random());
    const i = this.system.shape.getDirection(e, e.position);
    e.velocity.x = i.x * e.startSpeed, e.velocity.y = i.y * e.startSpeed, e.velocity.z = i.z * e.startSpeed, this.system.inheritVelocity?.enabled && this.system.inheritVelocity.applyInitial(e.velocity), e[Eh] ? e[Eh].copy(e.velocity) : e[Eh] = e.velocity.clone();
    const n = this.system.main.gravityModifier.evaluate(Math.random(), Math.random());
    e[ib] = n * t, e[ip] = n * t * 0.5, e[Ah] = Math.random(), this.system.velocityOverLifetime?.init(e), this._gravityDirection.set(0, -1, 0), this.system.main.simulationSpace === vc.Local && this._gravityDirection.applyQuaternion(this.system.worldQuaternionInverted).normalize();
  }
  update(e, t) {
    const i = e[Eh], n = e[ib];
    if (n !== 0) {
      const d = n * e[ip];
      am.copy(this._gravityDirection).multiplyScalar(d), e[ip] += t * 0.05, i.add(am);
    }
    e.velocity.copy(i);
    const o = e.age / e.life;
    this.system.inheritVelocity?.enabled && this.system.inheritVelocity.applyCurrent(e.velocity, o, e[Ah]);
    const r = this.system.noise;
    r.enabled && r.apply(0, e.position, e.velocity, t, e.age, e.life);
    const a = this.system.sizeBySpeed;
    a?.enabled && (e.size = a.evaluate(e.velocity, o, e[Ah], e.size));
    const l = this.system.colorBySpeed;
    l?.enabled && l.evaluate(e.velocity, e[Ah], e.color);
    const c = this.system.velocityOverLifetime;
    c.enabled && c.apply(e, 0, e.position, e.velocity, t, e.age, e.life);
    const h = this.system.limitVelocityOverLifetime;
    if (h.enabled && h.apply(e.position, i, e.velocity, e.size, o, t, 1), this.system.worldspace) {
      const d = this.system.worldScale;
      e.velocity.x *= d.x, e.velocity.y *= d.y, e.velocity.z *= d.z;
    }
  }
}
const nb = Symbol("colorLerpFactor"), sb = new oe(1, 1, 1, 1), zo = new oe(1, 1, 1, 1);
class UT extends Pr {
  type = "NeedleColor";
  initialize(e) {
  }
  _init(e) {
    const t = this.system.renderer.particleMaterial;
    zo.copy(this.system.main.startColor.evaluate(Math.random())), t?.color && (sb.copy(t.color), zo.multiply(sb)), zo.convertLinearToSRGB(), e.startColor.set(zo.r, zo.g, zo.b, zo.alpha), e.color.copy(e.startColor), e[nb] = Math.random();
  }
  update(e, t) {
    if (e.age === 0 && this._init(e), this.system.colorOverLifetime.enabled) {
      const i = e.age / e.life, n = this.system.colorOverLifetime.color.evaluate(i, e[nb]);
      e.color.set(n.r, n.g, n.b, "alpha" in n ? n.alpha : 1).multiply(e.startColor);
    } else
      e.color.copy(e.startColor);
  }
}
class NT {
  system;
  emission;
  get anim() {
    return this.system.textureSheetAnimation;
  }
  constructor(e) {
    this.system = e, this.emission = new AT(this.system);
  }
  get prewarm() {
    return !1;
  }
  // force disable three.quark prewarm, we have our own!
  get material() {
    return this.system.renderer.getMaterial(this.system.trails.enabled);
  }
  get layers() {
    return this.system.gameObject.layers;
  }
  update() {
    this.emission.update();
  }
  autoDestroy;
  get looping() {
    return this.system.main.loop;
  }
  get duration() {
    return this.system.duration;
  }
  get shape() {
    return this.system.shape;
  }
  get startLife() {
    return new Th(this.system.main.startLifetime);
  }
  get startSpeed() {
    return new Th(this.system.main.startSpeed);
  }
  get startRotation() {
    return new Th(this.system.main.startRotation);
  }
  get startSize() {
    return new Th(this.system.main.startSize);
  }
  startLength;
  /** start length is for trails */
  get startColor() {
    return new ZS(new JS(1, 1, 1, 1));
  }
  get emissionOverTime() {
    return this.emission;
  }
  /** this is not supported yet */
  get emissionOverDistance() {
    return new IT(this.system);
  }
  /** not used - burst is controled via emissionOverTime */
  emissionBursts;
  onlyUsedByOther;
  behaviors = [];
  get instancingGeometry() {
    return this.system.renderer.getMesh(this.system.renderer.renderMode).geometry;
  }
  get renderMode() {
    if (this.system.trails.enabled === !0)
      return ls.Trail;
    switch (this.system.renderer.renderMode) {
      case cs.Billboard:
        return ls.BillBoard;
      case cs.Stretch:
        return ls.StretchedBillBoard;
      case cs.HorizontalBillboard:
        return ls.HorizontalBillBoard;
      case cs.VerticalBillboard:
        return ls.VerticalBillBoard;
      case cs.Mesh:
        return ls.Mesh;
    }
    return ls.BillBoard;
  }
  rendererEmitterSettings = {
    startLength: new eC(220),
    followLocalOrigin: !1
  };
  get speedFactor() {
    let e = this.system.main.simulationSpeed;
    return this.system.renderer?.renderMode === cs.Stretch && (e *= this.system.renderer.velocityScale ?? 1), e;
  }
  flatWhiteTexture;
  clonedTexture = { original: void 0, clone: void 0 };
  get texture() {
    const e = this.material;
    if (e && e.map) {
      const t = e.map;
      if (this.clonedTexture.original !== t || !this.clonedTexture.clone) {
        const i = t.clone();
        i.premultiplyAlpha = !1, i.colorSpace = Ss, this.clonedTexture.original = t, this.clonedTexture.clone = i;
      }
      return this.clonedTexture.clone;
    }
    return this.flatWhiteTexture || (this.flatWhiteTexture = Zm(new oe(1, 1, 1, 1), 1)), this.flatWhiteTexture;
  }
  get startTileIndex() {
    return new ET(this.system);
  }
  get uTileCount() {
    return this.anim.enabled ? this.anim?.numTilesX : void 0;
  }
  get vTileCount() {
    return this.anim.enabled ? this.anim?.numTilesY : void 0;
  }
  get renderOrder() {
    return 1;
  }
  get blending() {
    return this.system.renderer.particleMaterial?.blending ?? dS;
  }
  get transparent() {
    return this.system.renderer.transparent;
  }
  get worldSpace() {
    return this.system.main.simulationSpace === vc.World;
  }
}
class $T {
  burstParticleIndex = 0;
  burstParticleCount = 0;
  isBursting = !1;
  travelDistance = 0;
  previousWorldPos;
  burstIndex = 0;
  burstWaveIndex = 0;
  time = 0;
  waitEmiting = 0;
}
const jt = class Zh extends R {
  play(e = !1) {
    e && S.foreachComponent(this.gameObject, (t) => {
      t instanceof Zh && t !== this && t.play(!1);
    }, !0), this._isPlaying = !0, this._particleSystem && (this._particleSystem.emissionState.time = 0, this._particleSystem.emitEnded = !1), this.emission?.reset();
  }
  pause(e = !0) {
    e && S.foreachComponent(this.gameObject, (t) => {
      t instanceof Zh && t !== this && t.pause(!1);
    }, !0), this._isPlaying = !1;
  }
  /** clear=true removes all emitted particles */
  stop(e = !0, t = !1) {
    e && S.foreachComponent(this.gameObject, (i) => {
      i instanceof Zh && i !== this && i.stop(!1, t);
    }, !0), this._isPlaying = !1, this._time = 0, t && this.reset();
  }
  /** remove emitted particles and reset time */
  reset() {
    this._time = 0, this._particleSystem && (this._particleSystem.particleNum = 0, this._particleSystem.emissionState.time = 0, this._particleSystem.emitEnded = !1, this.emission?.reset());
  }
  _state;
  emit(e) {
    if (this._particleSystem) {
      this.onUpdate(), e = Math.min(e, this.maxParticles - this.currentParticles), this._state || (this._state = new $T()), this._state.waitEmiting = e, this._state.time = 0;
      const t = this._particleSystem.emitEnded;
      this._particleSystem.emitEnded = !1, this._particleSystem.emit(this.deltaTime, this._state, this._particleSystem.emitter.matrixWorld), this._particleSystem.emitEnded = t;
    }
  }
  get playOnAwake() {
    return this.main.playOnAwake;
  }
  set playOnAwake(e) {
    this.main.playOnAwake = e;
  }
  colorOverLifetime;
  main;
  emission;
  sizeOverLifetime;
  shape;
  noise;
  trails;
  velocityOverLifetime;
  limitVelocityOverLifetime;
  inheritVelocity;
  colorBySpeed;
  textureSheetAnimation;
  rotationOverLifetime;
  rotationBySpeed;
  sizeBySpeed;
  get renderer() {
    return this._renderer;
  }
  get isPlaying() {
    return this._isPlaying;
  }
  get currentParticles() {
    return this._particleSystem?.particleNum ?? 0;
  }
  get maxParticles() {
    return this.main.maxParticles;
  }
  get time() {
    return this._time;
  }
  get duration() {
    return this.main.duration;
  }
  get deltaTime() {
    return this.context.time.deltaTime * this.main.simulationSpeed;
  }
  get scale() {
    return this.gameObject.scale.x;
  }
  get cameraScale() {
    return this._cameraScale;
  }
  _cameraScale = 1;
  get container() {
    return this._container;
  }
  get worldspace() {
    return this.main.simulationSpace === vc.World;
  }
  get localspace() {
    return this.main.simulationSpace === vc.Local;
  }
  __worldQuaternion = new U();
  get worldQuaternion() {
    return this.__worldQuaternion;
  }
  _worldQuaternionInverted = new U();
  get worldQuaternionInverted() {
    return this._worldQuaternionInverted;
  }
  _worldScale = new y();
  get worldScale() {
    return this._worldScale;
  }
  _worldPositionFrame = -1;
  _worldPos = new y();
  get worldPos() {
    return this._worldPositionFrame !== this.context.time.frame && (this._worldPositionFrame = this.context.time.frame, Z(this.gameObject, this._worldPos)), this._worldPos;
  }
  get matrixWorld() {
    return this._container.matrixWorld;
  }
  get isSubsystem() {
    return this._isUsedAsSubsystem;
  }
  /** Add a custom quarks behaviour to the particle system.   
   * You can add a quarks.Behaviour type or derive from {@link ParticleSystemBaseBehaviour}  
   * @link https://github.com/Alchemist0823/three.quarks    
   * @example
   * ```typescript
   * class MyBehaviour extends ParticleSystemBaseBehaviour {
   *    initialize(particle: Particle) {
   *       // initialize the particle
   *   }
   *    update(particle: Particle, delta: number) {  
   *        // do something with the particle
   *   }
   * }
   * 
   * const system = gameObject.getComponent(ParticleSystem);
   * system.addBehaviour(new MyBehaviour());
   * ```
  */
  addBehaviour(e) {
    return this._particleSystem ? (e instanceof Pr && (e.system = this), Ys && console.debug("Add custom ParticleSystem Behaviour", e), this._particleSystem.addBehavior(e), !0) : !1;
  }
  /** Remove a custom quarks behaviour from the particle system. **/
  removeBehaviour(e) {
    if (!this._particleSystem)
      return !1;
    const t = this._particleSystem.behaviors, i = t.indexOf(e);
    return i !== -1 && ((L() || Ys) && console.debug("Remove custom ParticleSystem Behaviour", i, e), t.splice(i, 1)), !0;
  }
  /** Removes all behaviours from the particle system  
   * **Note:** this will also remove the default behaviours like SizeBehaviour, ColorBehaviour etc.
   */
  removeAllBehaviours() {
    return this._particleSystem ? (this._particleSystem.behaviors.length = 0, !0) : !1;
  }
  /** Get the underlying three.quarks particle system behaviours. This can be used to fully customize the behaviour of the particles. */
  get behaviours() {
    return this._particleSystem ? this._particleSystem.behaviors : null;
  }
  /** Get access to the underlying quarks particle system if you need more control  
   * @link https://github.com/Alchemist0823/three.quarks
   */
  get particleSystem() {
    return this._particleSystem ?? null;
  }
  _renderer;
  _batchSystem;
  _particleSystem;
  _interface;
  // private _system!: System;
  // private _emitter: Emitter;
  // private _size!: SizeBehaviour;
  _container;
  _time = 0;
  _isPlaying = !0;
  _isUsedAsSubsystem = !1;
  _didPreWarm = !1;
  /** called from deserialization */
  set bursts(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      if (!(i instanceof om)) {
        const n = new om();
        Ca(n, i), e[t] = n;
      }
    }
    this._bursts = e;
  }
  _bursts;
  /** called from deserialization */
  set subEmitterSystems(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      if (!(i instanceof lm)) {
        const n = new lm();
        Ca(n, i), e[t] = n;
      }
    }
    Ys && e.length > 0 && console.log("SubEmitters: ", e, this), this._subEmitterSystems = e;
  }
  _subEmitterSystems;
  /** @internal */
  onAfterDeserialize(e) {
    if (this._subEmitterSystems && Array.isArray(this._subEmitterSystems))
      for (const t of this._subEmitterSystems)
        t._deserialize(this.context, this.gameObject);
  }
  /** @internal */
  awake() {
    if (this._worldPositionFrame = -1, this._renderer = this.gameObject.getComponent(mn), !this.main)
      throw new Error("Not Supported: ParticleSystem needs a serialized MainModule. Creating new particle systems at runtime is currently not supported.");
    this._container = new M(), this._container.matrixAutoUpdate = !1, this.context.scene.add(this._container), this._batchSystem = new YS(), this._batchSystem.name = this.gameObject.name, this._container.add(this._batchSystem), this._interface = new NT(this), this._particleSystem = new KS(this._interface), this._particleSystem.addBehavior(new BT(this)), this._particleSystem.addBehavior(new UT(this)), this._particleSystem.addBehavior(new LT(this)), this._particleSystem.addBehavior(new DT(this)), this._particleSystem.addBehavior(new zT(this)), this._particleSystem.addBehavior(new FT(this)), this._batchSystem.addSystem(this._particleSystem);
    const e = this._particleSystem.emitter;
    this.context.scene.add(e), this.inheritVelocity.system && this.inheritVelocity.system !== this && (this.inheritVelocity = this.inheritVelocity.clone()), this.inheritVelocity.awake(this), Ys && (console.log(this), this.gameObject.add(new vi(1)));
  }
  /** @internal */
  start() {
    this.addSubParticleSystems(), this.updateLayers(), this.renderer.particleMesh instanceof G && this._interface.renderMode == ls.Mesh && We.assignMeshLOD(this.renderer.particleMesh, 0).then((e) => {
      e && this.particleSystem && this._interface.renderMode == ls.Mesh && (this.particleSystem.instancingGeometry = e);
    });
  }
  /** @internal */
  onDestroy() {
    this._container?.removeFromParent(), this._batchSystem?.removeFromParent(), this._particleSystem?.emitter.removeFromParent(), this._particleSystem?.dispose();
  }
  /** @internal */
  onEnable() {
    this.main && (this.inheritVelocity && (this.inheritVelocity.system = this), this._batchSystem && (this._batchSystem.visible = !0), this.playOnAwake && this.play(), this._isPlaying = this.playOnAwake);
  }
  onDisable() {
    this._batchSystem && (this._batchSystem.visible = !1);
  }
  /** @internal */
  onBeforeRender() {
    this.main && (this._didPreWarm === !1 && this.main?.prewarm === !0 && (this._didPreWarm = !0, this.preWarm()), this.onUpdate(), this.onSimulate(this.deltaTime));
  }
  preWarm() {
    if (!this.emission?.enabled || this.emission.rateOverTime.getMax() <= 0) return;
    const t = 1 / 60, i = this.main.duration, n = this.main.startLifetime.getMax(), r = Math.min(Math.max(i, n) / Math.max(0.01, this.main.simulationSpeed), 1e3), a = Math.ceil(r / t), l = Date.now();
    Ys && console.log(`Particles ${this.name} - Prewarm for ${a} frames (${r} sec). Duration: ${i}, Lifetime: ${n}`);
    for (let c = 0; c < a && !(this.currentParticles >= this.maxParticles); c++) {
      const h = Date.now() - l;
      if (h > 2e3) {
        console.warn(`Particles ${this.name} - Prewarm took too long. Aborting: ${h}`);
        break;
      }
      this.onUpdate(), this.onSimulate(t);
    }
  }
  _lastBatchesCount = -1;
  onSimulate(e) {
    if (this._batchSystem) {
      let t = this.context.time.frameCount % 60 === 0;
      this._lastBatchesCount !== this._batchSystem.batches.length && (this._lastBatchesCount = this._batchSystem.batches.length, t = !0), t && this.updateLayers(), this._batchSystem.update(e);
    }
    this._time += e, this._time > this.duration && (this._time = 0);
  }
  updateLayers() {
    if (this._batchSystem)
      for (let e = 0; e < this._batchSystem.batches.length; e++) {
        const t = this._batchSystem.batches[e];
        t.layers.disableAll();
        const i = this.layer;
        t.layers.mask = 1 << i;
      }
  }
  // private lastMaterialVersion: number = -1;
  onUpdate() {
    if (this._bursts && (this.emission.bursts = this._bursts, delete this._bursts), !this._isPlaying) return;
    const e = this.context.mainCamera;
    if (e) {
      const n = Qe(e);
      this._cameraScale = n.x;
    }
    const t = !this.worldspace, i = this.gameObject;
    if (be(i, this.__worldQuaternion), this._worldQuaternionInverted.copy(this.__worldQuaternion).invert(), Qe(this.gameObject, this._worldScale), t && this._container && this.gameObject?.parent) {
      const n = vw(this, am);
      this._container.matrix.makeScale(n.x, n.y, n.z), this._container.matrix.makeRotationFromQuaternion(this.__worldQuaternion), this._container.matrix.setPosition(this.worldPos), this._container.matrix.scale(this.gameObject.scale);
    }
    this.emission.system = this, this._interface.update(), this.shape.onUpdate(this, this.context, this.main.simulationSpace, this.gameObject), this.noise.update(this.context), this.inheritVelocity?.update(this.context), this.velocityOverLifetime.update(this);
  }
  addSubParticleSystems() {
    if (this._subEmitterSystems && this._particleSystem)
      for (const e of this._subEmitterSystems) {
        e.particleSystem && (e.particleSystem.__internalAwake ? e.particleSystem.__internalAwake() : L() && console.warn("SubParticleSystem serialization issue(?)", e.particleSystem, e));
        const t = e.particleSystem?._particleSystem;
        if (t) {
          e.particleSystem._isUsedAsSubsystem = !0;
          const i = new bw(this, this._particleSystem, e.particleSystem, t);
          i.emitterType = e.type, i.emitterProbability = e.emitProbability, this._particleSystem.addBehavior(i);
        } else Ys && console.warn("Could not add SubParticleSystem", e, this);
      }
  }
};
ze([
  u(Fg)
], jt.prototype, "colorOverLifetime");
ze([
  u(Qt)
], jt.prototype, "main");
ze([
  u(Oo)
], jt.prototype, "emission");
ze([
  u(Ka)
], jt.prototype, "sizeOverLifetime");
ze([
  u(gw)
], jt.prototype, "shape");
ze([
  u(ve)
], jt.prototype, "noise");
ze([
  u(Ne)
], jt.prototype, "trails");
ze([
  u(Ve)
], jt.prototype, "velocityOverLifetime");
ze([
  u(_t)
], jt.prototype, "limitVelocityOverLifetime");
ze([
  u(_w)
], jt.prototype, "inheritVelocity");
ze([
  u(Nc)
], jt.prototype, "colorBySpeed");
ze([
  u(Yt)
], jt.prototype, "textureSheetAnimation");
ze([
  u(Gn)
], jt.prototype, "rotationOverLifetime");
ze([
  u(pn)
], jt.prototype, "rotationBySpeed");
ze([
  u(Mi)
], jt.prototype, "sizeBySpeed");
let Td = jt;
class lm {
  particleSystem;
  emitProbability = 1;
  properties;
  type;
  _deserialize(e, t) {
    const i = this.particleSystem;
    if (i instanceof Td) return;
    let n = "";
    i && typeof i.guid == "string" && (n = i.guid, this.particleSystem = S.findByGuid(n, t)), Ys && !(this.particleSystem instanceof Td) && console.warn("Could not find particle system for sub emitter", n, t, this);
  }
}
function vw(s, e) {
  if (e.set(1, 1, 1), s.gameObject.parent && s.localspace)
    switch (s.main.scalingMode) {
      case sm.Local:
        e = Qe(s.gameObject.parent, e), e.x = 1 / e.x, e.y = 1 / e.y, e.z = 1 / e.z;
        break;
      default:
        if (!s.unsupported_scaling_mode) {
          s.unsupported_scaling_mode = !0;
          const t = "ParticleSystem scale mode " + sm[s.main.scalingMode] + " is not supported";
          L() && ge(t), console.warn(t, s.name, s);
        }
        e = Qe(s.gameObject, e);
        break;
    }
  return e;
}
var WT = Object.defineProperty, Ug = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && WT(e, t, n), n;
};
class $c extends R {
  strength = 1;
  radius = 2;
  targets = [];
  update() {
    const e = this.gameObject.worldPosition, t = -this.strength * this.context.time.deltaTime;
    this.targets?.forEach((i) => {
      if (!i) return;
      const n = i.gameObject.worldPosition.sub(e), o = n.length();
      if (o > this.radius) return;
      let r = t;
      o > 1 ? r /= o * o : r /= Math.max(0.05, o), i.applyImpulse(n.multiplyScalar(r));
    });
  }
}
Ug([
  u()
], $c.prototype, "strength");
Ug([
  u()
], $c.prototype, "radius");
Ug([
  u(rt)
], $c.prototype, "targets");
class wc extends R {
  _didAssignPlayerColor = !1;
  onEnable() {
    this.context.connection.beginListen(te.JoinedRoom, this.tryAssignColor), this._didAssignPlayerColor || this.startCoroutine(this.waitForConnection());
  }
  onDisable() {
    this.context.connection.stopListen(te.JoinedRoom, this.tryAssignColor);
  }
  *waitForConnection() {
    for (; !this.destroyed && this.activeAndEnabled && (yield q0(0.2), !this.tryAssignColor()); )
      ;
  }
  tryAssignColor = () => {
    const e = S.getComponentInParent(this.gameObject, Rn);
    if (e && e.owner)
      return this._didAssignPlayerColor = !0, this.assignUserColor(e.owner), !0;
    const t = S.getComponentInParent(this.gameObject, je);
    return t?.connectionId ? (this._didAssignPlayerColor = !0, this.assignUserColor(t.connectionId), !0) : !1;
  };
  assignUserColor(e) {
    const t = wc.hashCode(e), i = wc.colorFromHashCode(t);
    if (this.gameObject.type === "Mesh") {
      const n = this.gameObject;
      this.assignColor(i, e, n);
    } else if (this.gameObject.children)
      for (const n of this.gameObject.children) {
        const o = n;
        o.material && o.material.color && this.assignColor(i, e, o);
      }
  }
  assignColor(e, t, i) {
    let n = i.material;
    n && (n._playerMaterial !== t && (n = n.clone(), n._playerMaterial = t, i.material = n), n.color = e);
  }
  static hashCode(e) {
    var t = 0, i, n;
    if (e.length === 0) return t;
    for (i = 0; i < e.length; i++)
      n = e.charCodeAt(i), t = (t << 5) - t + n, t |= 0;
    return t;
  }
  static colorFromHashCode(e) {
    const t = (e & 16711680) >> 16, i = (e & 65280) >> 8, n = e & 255;
    return new se(t / 255, i / 255, n / 255);
  }
}
const Wl = w("debugpost");
let cm = null;
function VT(s) {
  cm = s;
}
function ww(s) {
  let e = s.gameObject;
  for (; e; ) {
    for (const t of Km(e))
      if (t.isPostProcessingManager === !0)
        return t;
    e = e.parent;
  }
  return null;
}
function HT(s) {
  let e = ww(s);
  if (!e)
    if (cm) {
      Wl && console.warn("Adding postprocessing manager to the scene.");
      const t = s.scene;
      e = An(t, cm);
    } else
      L() && console.warn("No post processing manager found");
  return e;
}
const dt = {
  /** Used to render effects at the start of the post-processing chain */
  AT_START: -1e4,
  NormalPass: 0,
  DepthDownsamplingPass: 10,
  SSAO: 20,
  SMAA: 30,
  TiltShift: 40,
  DepthOfField: 50,
  ChromaticAberration: 60,
  Bloom: 70,
  Vignette: 80,
  Pixelation: 90,
  ToneMapping: 100,
  HueSaturation: 110,
  BrightnessContrast: 120,
  Sharpening: 130,
  /** Used to render effects at the end of the post-processing chain, e.g. for final adjustments or overlays. */
  AT_END: 1e4
};
let He = null;
function GT(s) {
  Wl === "verbose" && console.debug("Before ordering effects", [...s]), He || (He = /* @__PURE__ */ new Map(), He.set(T.POSTPROCESSING.MODULE.NormalPass, dt.NormalPass), He.set(T.POSTPROCESSING.MODULE.DepthDownsamplingPass, dt.DepthDownsamplingPass), He.set(T.POSTPROCESSING.MODULE.SMAAEffect, dt.SMAA), He.set(T.POSTPROCESSING.MODULE.SSAOEffect, dt.SSAO), He.set(T.POSTPROCESSING_AO.MODULE.N8AOPostPass, dt.SSAO), He.set(T.POSTPROCESSING_AO.MODULE.N8AOPass, dt.SSAO), He.set(T.POSTPROCESSING.MODULE.TiltShiftEffect, dt.TiltShift), He.set(T.POSTPROCESSING.MODULE.DepthOfFieldEffect, dt.DepthOfField), He.set(T.POSTPROCESSING.MODULE.ChromaticAberrationEffect, dt.ChromaticAberration), He.set(T.POSTPROCESSING.MODULE.BloomEffect, dt.Bloom), He.set(T.POSTPROCESSING.MODULE.SelectiveBloomEffect, dt.Bloom), He.set(T.POSTPROCESSING.MODULE.VignetteEffect, dt.Vignette), He.set(T.POSTPROCESSING.MODULE.PixelationEffect, dt.Pixelation), He.set(T.POSTPROCESSING.MODULE.ToneMappingEffect, dt.ToneMapping), He.set(T.POSTPROCESSING.MODULE.HueSaturationEffect, dt.HueSaturation), He.set(T.POSTPROCESSING.MODULE.BrightnessContrastEffect, dt.BrightnessContrast)), s.sort((e, t) => {
    const i = typeof e.priority == "number" ? e.priority : He.get(e.effect.constructor) ?? Number.NEGATIVE_INFINITY, n = typeof t.priority == "number" ? t.priority : He.get(t.effect.constructor) ?? Number.NEGATIVE_INFINITY;
    return i === Number.NEGATIVE_INFINITY ? (Wl && console.warn("Unknown effect found: ", e.constructor.name, e), 1) : n === Number.NEGATIVE_INFINITY ? (Wl && console.warn("Unknown effect found: ", t.constructor.name, t), -1) : i - n;
  }), Wl === "verbose" && console.debug("After ordering effects", [...s]);
}
var qT = Object.defineProperty, XT = Object.getOwnPropertyDescriptor, xw = (s, e, t, i) => {
  for (var n = XT(e, t), o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && qT(e, t, n), n;
};
const QT = w("debugpost");
class F {
  isVolumeParameter = !0;
  constructor(e) {
    e !== void 0 && this.initialize(e);
  }
  _isInitialized = !1;
  get isInitialized() {
    return this._isInitialized;
  }
  initialize(e) {
    e !== void 0 && (this._value = e, this._defaultValue = e, this._valueRaw = e, this._isInitialized = !0);
  }
  get overrideState() {
    return this._active;
  }
  set overrideState(e) {
    if (this._active === e) return;
    this._active = e;
    const t = e ? this._valueRaw : this._defaultValue;
    this.processValue(t, !0);
  }
  _active = !0;
  get value() {
    return this._valueRaw;
  }
  set value(e) {
    this.isInitialized || this.initialize(e), this.processValue(e, !1);
  }
  _value;
  _valueRaw;
  set defaultValue(e) {
    this._defaultValue = e;
  }
  _defaultValue = void 0;
  /** enforce the value to be set and onValueChanged to be called if assigned */
  __init() {
    this.processValue(this._valueRaw, !0);
  }
  /** called to modify a changing value before it is saved */
  valueProcessor;
  /** called when a value has changed (with the final value) */
  onValueChanged;
  processValue(e, t) {
    if (e == null || !t && this.testIfValueChanged(e) === !1)
      return;
    const i = this._value;
    QT && typeof i == "number" && typeof e == "number" && (i?.toFixed(4), e?.toFixed(4)), !this._active && this._defaultValue !== void 0 ? (this._value = this._defaultValue, e = this._defaultValue, this._valueRaw = e) : (this._valueRaw = e, this._active && this.valueProcessor && (e = this.valueProcessor(e)), this._value = e), this.onValueChanged && this.onValueChanged(e, i, this);
  }
  testIfValueChanged(e) {
    return this._valueRaw !== e;
  }
}
xw([
  u()
], F.prototype, "overrideState");
xw([
  u()
], F.prototype, "value");
class YT extends Zi {
  constructor() {
    super([F]);
  }
  onSerialize(e, t) {
  }
  onDeserialize(e, t) {
    const i = t.target, n = t.path;
    let o;
    if (i && n && (o = i[n]), (typeof o != "object" || typeof o == "object" && o.isVolumeParameter !== !0) && (o = new F()), typeof e == "object" && "value" in e) {
      const r = e.value;
      o.initialize(r), o.overrideState = e.overrideState;
    } else
      o.value = e;
    return o;
  }
}
new YT();
var KT = Object.defineProperty, ZT = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && KT(e, t, n), n;
};
const np = w("debugpost");
class at extends R {
  get isPostProcessingEffect() {
    return !0;
  }
  /**
   * The order of this effect. The higher the order the later the effect will be applied in the post processing stack.
   * This can be used to control the order of effects when multiple effects are applied.  
   * It is recommended to use the PostProcessingEffectOrder constant to order your custom effects before or after built-in effects.  
   * @default `undefined` (no specific order set, will be applied in the order of registration)
   * 
   * @example
   * ```typescript
   * import { PostProcessingEffectOrder } from "@needle-tools/engine"
   * 
   * export class MyCustomEffect extends PostProcessingEffect {
   *    order: PostProcessingEffectOrder.Bloom + 1; // render after bloom
   *    // This will ensure that the effect is applied after the bloom effect in the post processing stack.
   *    // ... the rest of your effect code
   * }
   * ```
   */
  order = void 0;
  constructor(e = void 0) {
    if (super(), e)
      for (const t of Object.keys(e)) {
        const i = e[t], n = this[t];
        n instanceof F ? n.initialize(i) : n !== void 0 && (this[t] = i);
      }
  }
  active = !0;
  _manager = null;
  onEnable() {
    super.onEnable(), np && console.warn("Enable", this.constructor.name + (this.__internalDidAwakeAndStart ? "" : " (awake)")), this.__internalDidAwakeAndStart && (this.active = !0), this.onEffectEnabled();
  }
  onDisable() {
    super.onDisable(), np && console.warn("Disable", this.constructor.name), this._manager?.removeEffect(this), this.active = !1;
  }
  onEffectEnabled(e) {
    e && e.isPostProcessingManager === !0 ? this._manager = e : this._manager || (this._manager = HT(this)), this._manager.addEffect(this), this._manager.dirty = !0;
  }
  /** override to initialize bindings on parameters */
  init() {
  }
  /** previously created effect (if any) */
  _result;
  _postprocessingContext = null;
  get postprocessingContext() {
    return this._postprocessingContext;
  }
  /** Apply post settings. Make sure to call super.apply() if you also create an effect */
  apply(e) {
    return this._postprocessingContext = e, this._result || (this.initParameters(), this._result = this.onCreateEffect?.call(this)), this._result && this.initParameters(), this._result;
  }
  /** Reset previously set values (e.g. when adjusting settings on the renderer like Tonemapping) */
  unapply() {
  }
  dispose() {
    np && console.warn("DISPOSE", this), this._result && (Array.isArray(this._result) ? this._result.forEach((e) => e.dispose()) : this._result.dispose()), this._result = void 0;
  }
  initParameters() {
    const e = Object.keys(this);
    for (const t of e) {
      const i = this[t];
      i instanceof F && i.__init();
    }
  }
  // TODO this is currently not used for post processing effects that are part of Volume stacks,
  // since these handle that already.
  onEditorModification(e) {
    const t = e.propertyName;
    if (this[t] instanceof F) {
      const i = e.value;
      return this[t].value = i, !0;
    }
  }
}
ZT([
  u()
], at.prototype, "active");
var JT = Object.defineProperty, eE = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && JT(e, t, n), n;
};
const tE = w("debugpost"), hm = {};
function gn(s, e) {
  hm[s] = e;
}
function iE(s) {
  return s.__type in hm ? hm[s.__type] : (tE && s.__type && console.warn("Unknown postprocessing type", s.__type, s), at);
}
class Ng {
  components = [];
  /**
   * call init on all components 
   * @hidden
   **/
  __init(e) {
    this.components?.forEach((t) => {
      t.gameObject === void 0 && e.gameObject.addComponent(t), t.init();
    });
  }
  addEffect(e) {
    this.components.push(e);
  }
  removeEffect(e) {
    const t = this.components.indexOf(e);
    t >= 0 && this.components.splice(t, 1);
  }
}
eE([
  lt([(s) => iE(s), at])
], Ng.prototype, "components");
var nE = Object.defineProperty, sE = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && nE(e, t, n), n;
};
const oE = w("debugpost");
class Lu extends at {
  get typeName() {
    return "Antialiasing";
  }
  preset = new F(2);
  // 2 is HIGH: https://github.com/pmndrs/postprocessing/blob/main/src/enums/SMAAPreset.js#L14
  onCreateEffect() {
    const e = new T.POSTPROCESSING.MODULE.SMAAEffect({
      preset: this.preset?.value ?? T.POSTPROCESSING.MODULE.SMAAPreset.HIGH,
      edgeDetectionMode: T.POSTPROCESSING.MODULE.EdgeDetectionMode.LUMA
      // Keep predication mode disabled (default) since it looks better
      // predicationMode: MODULES.POSTPROCESSING.MODULE.PredicationMode.DEPTH,
    });
    return this.preset.onValueChanged = (t) => {
      oE && console.log("Antialiasing preset changed to", t), e.applyPreset(t);
    }, e;
  }
}
sE([
  u(F)
], Lu.prototype, "preset");
gn("Antialiasing", Lu);
var rE = Object.defineProperty, $g = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && rE(e, t, n), n;
};
const Du = class Sw extends at {
  /** Whether to use selective bloom by default */
  static useSelectiveBloom = !1;
  get typeName() {
    return "Bloom";
  }
  threshold = new F(0.9);
  intensity = new F(1);
  scatter = new F(0.7);
  /**
   * Set to true to use selective bloom when the effect gets created.
   * @default false
   */
  selectiveBloom;
  init() {
    this.threshold.valueProcessor = (e) => e, this.intensity.valueProcessor = (e) => e, this.scatter.valueProcessor = (e) => e;
  }
  onCreateEffect() {
    let e;
    if (this.selectiveBloom == null && (this.selectiveBloom = Sw.useSelectiveBloom), this.selectiveBloom) {
      const t = e = new T.POSTPROCESSING.MODULE.SelectiveBloomEffect(this.context.scene, this.context.mainCamera, {
        blendFunction: T.POSTPROCESSING.MODULE.BlendFunction.ADD,
        mipmapBlur: !0,
        luminanceThreshold: this.threshold.value,
        luminanceSmoothing: this.scatter.value,
        radius: 0.85,
        // default value
        intensity: this.intensity.value
      });
      t.inverted = !0;
    } else
      e = new T.POSTPROCESSING.MODULE.BloomEffect({
        blendFunction: T.POSTPROCESSING.MODULE.BlendFunction.ADD,
        mipmapBlur: !0,
        luminanceThreshold: this.threshold.value,
        luminanceSmoothing: this.scatter.value,
        radius: 0.85,
        // default value
        intensity: this.intensity.value
      });
    return this.intensity.onValueChanged = (t) => {
      e.intensity = t;
    }, this.threshold.onValueChanged = (t) => {
      e.luminanceMaterial.threshold = Math.pow(t, 2.2);
    }, this.scatter.onValueChanged = (t) => {
      e.luminancePass.enabled = !0, e.luminanceMaterial.smoothing = t, e.mipmapBlurPass && (e.mipmapBlurPass.radius = ys.lerp(0.1, 0.9, t));
    }, e;
  }
};
$g([
  u(F)
], Du.prototype, "threshold");
$g([
  u(F)
], Du.prototype, "intensity");
$g([
  u(F)
], Du.prototype, "scatter");
let Wg = Du;
gn("Bloom", Wg);
var aE = Object.defineProperty, lE = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && aE(e, t, n), n;
};
class ju extends at {
  get typeName() {
    return "ChromaticAberration";
  }
  intensity = new F(0);
  onCreateEffect() {
    const e = new T.POSTPROCESSING.MODULE.ChromaticAberrationEffect();
    return e.offset = new J(0, 0), e.radialModulation = !0, e.modulationOffset = 0.15, this.intensity.valueProcessor = (t) => t * 0.02, this.intensity.onValueChanged = (t) => {
      e.offset.x = -t, e.offset.y = t;
    }, e;
  }
}
lE([
  u(F)
], ju.prototype, "intensity");
gn("ChromaticAberration", ju);
var Vl = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Neutral = 1] = "Neutral", s[s.ACES = 2] = "ACES", s[s.AgX = 3] = "AgX", s[s.KhronosNeutral = 4] = "KhronosNeutral", s))(Vl || {});
const ob = /* @__PURE__ */ new Map();
function sp(s) {
  switch (s) {
    case 0:
      return km;
    case 1:
      return Om;
    case 2:
      return Hd;
    case 3:
      return Vd;
    case 4:
      return ya;
    default:
      return ob.has(s) || (ob.set(s, !0), console.warn("[Postprocessing] Unknown tone mapping mode", s)), ya;
  }
}
function cE(s) {
  switch (s) {
    case km:
      return 0;
    case Hd:
      return 2;
    case Vd:
      return 3;
    case ya:
      return 1;
    case Om:
      return 1;
    default:
      return 0;
  }
}
function Jh(s) {
  switch (s) {
    case km:
      return T.POSTPROCESSING.MODULE.ToneMappingMode.LINEAR;
    case Hd:
      return T.POSTPROCESSING.MODULE.ToneMappingMode.ACES_FILMIC;
    case Vd:
      return T.POSTPROCESSING.MODULE.ToneMappingMode.AGX;
    case ya:
      return T.POSTPROCESSING.MODULE.ToneMappingMode.NEUTRAL;
    case Om:
      return T.POSTPROCESSING.MODULE.ToneMappingMode.REINHARD;
    default:
      return T.POSTPROCESSING.MODULE.ToneMappingMode.LINEAR;
  }
}
var hE = Object.defineProperty, Cw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && hE(e, t, n), n;
};
const op = w("debugpost");
class fr extends at {
  get typeName() {
    return "ToneMapping";
  }
  mode = new F(void 0);
  exposure = new F(1);
  /** Set the tonemapping mode to e.g. "agx" */
  setMode(e) {
    const t = Vl[e];
    return t === void 0 ? (console.error("[PostProcessing] Invalid ToneMapping mode", e), this) : (this.mode.value = t, this);
  }
  get isToneMapping() {
    return !0;
  }
  onEffectEnabled() {
    const e = ww(this);
    e && super.onEffectEnabled(e);
  }
  _tonemappingEffect = null;
  onCreateEffect() {
    if (this.mode.isInitialized == !1) {
      const i = cE(this.context.renderer.toneMapping);
      op && console.log("[PostProcessing] Initializing ToneMapping mode to renderer.toneMapping", this.context.renderer.toneMapping + " → " + i), this.mode.initialize(i);
    }
    this._tonemappingEffect?.dispose();
    const e = sp(this.mode.value), t = this._tonemappingEffect = new T.POSTPROCESSING.MODULE.ToneMappingEffect({
      mode: Jh(e)
    });
    return this.mode.onValueChanged = (i) => {
      if (typeof i == "string")
        i = Q0(i), t.mode = Jh(i);
      else {
        const n = sp(i);
        t.mode = Jh(n);
      }
      t.name = "ToneMapping (" + Vl[i] + ")", op && console.log("[PostProcessing] ToneMapping mode changed to", Vl[i], e, t.mode);
    }, op && console.log("[PostProcessing] Use ToneMapping", Vl[this.mode.value], e, t.mode, "renderer.tonemapping: " + this.context.renderer.toneMapping), t;
  }
  onBeforeRender() {
    if (this._tonemappingEffect && this.postprocessingContext?.handler.getEffectIsActive(this._tonemappingEffect) && (this.mode.overrideState && (this.context.renderer.toneMapping = sp(this.mode.value)), this.exposure.overrideState && this.exposure.value !== void 0)) {
      const e = Math.max(0, this.exposure.value);
      this.context.renderer.toneMappingExposure = e;
    }
  }
}
Cw([
  u(F)
], fr.prototype, "mode");
Cw([
  u(F)
], fr.prototype, "exposure");
gn("Tonemapping", fr);
var dE = Object.defineProperty, Bu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && dE(e, t, n), n;
};
class Or extends at {
  get typeName() {
    return "ColorAdjustments";
  }
  /**
   * Whether values for contrast, hueshift or saturation are remapped to a different range.
   */
  remap = !0;
  postExposure = new F(1);
  contrast = new F(0);
  hueShift = new F(0);
  saturation = new F(0);
  init() {
    this.postExposure.valueProcessor = (e) => (this.remap && (e = Math.pow(2, e)), e), this.contrast.valueProcessor = (e) => {
      if (!this.remap) return e;
      let t = 1;
      return e > 0 ? t = 200 : e < 0 && (t = 100), e / t;
    }, this.contrast.defaultValue = 0, this.hueShift.valueProcessor = (e) => this.remap ? Math.PI * e / 180 : e, this.hueShift.defaultValue = 0, this.saturation.valueProcessor = (e) => this.remap ? e < 0 ? e / 100 : e / (100 * Math.PI) : e, this.saturation.defaultValue = 0;
  }
  onCreateEffect() {
    const e = [];
    let t = this.postprocessingContext?.components.find((o) => o instanceof fr);
    t || (t = new fr(), this.postprocessingContext?.components.push(t)), this.postExposure.onValueChanged = (o) => {
      this.postExposure.overrideState && t ? t.exposure.value = o : console.warn("[PostProcessing] PostExposure is set to override but no ToneMappingEffect found in the postprocessing stack. Please add a ToneMappingEffect to your postprocessing stack to use PostExposure.");
    };
    const i = new T.POSTPROCESSING.MODULE.BrightnessContrastEffect();
    this.contrast.onValueChanged = (o) => i.contrast = o;
    const n = new T.POSTPROCESSING.MODULE.HueSaturationEffect();
    return this.hueShift.onValueChanged = (o) => n.hue = o, this.saturation.onValueChanged = (o) => n.saturation = o, e.push(i), e.push(n), e;
  }
}
Bu([
  u(F)
], Or.prototype, "postExposure");
Bu([
  u(F)
], Or.prototype, "contrast");
Bu([
  u(F)
], Or.prototype, "hueShift");
Bu([
  u(F)
], Or.prototype, "saturation");
gn("ColorAdjustments", Or);
var uE = Object.defineProperty, kr = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && uE(e, t, n), n;
};
const fE = w("debugpost");
class qn extends at {
  get typeName() {
    return "DepthOfField";
  }
  mode;
  focusDistance = new F(1);
  focalLength = new F(0.2);
  aperture = new F(20);
  gaussianMaxRadius = new F();
  resolutionScale = new F(1 / window.devicePixelRatio);
  bokehScale = new F();
  init() {
    this.focalLength.valueProcessor = (t) => {
      const i = t / 300;
      return j.lerp(2, 0.01, i);
    };
    const e = 20;
    this.aperture.valueProcessor = (t) => {
      const i = 1 - t / 32;
      return j.lerp(1, e, i);
    };
  }
  onCreateEffect() {
    if (this.mode === 0) {
      fE && console.warn("DepthOfField: Mode is set to Off");
      return;
    }
    const e = new T.POSTPROCESSING.MODULE.DepthOfFieldEffect(this.context.mainCamera, {
      worldFocusRange: 0.2,
      focalLength: 1,
      bokehScale: 20,
      resolutionScale: this.resolutionScale.value
    });
    return this.focusDistance.onValueChanged = (t) => {
      e.cocMaterial.worldFocusDistance = t;
    }, this.focalLength.onValueChanged = (t) => e.cocMaterial.worldFocusRange = t, this.aperture.onValueChanged = (t) => e.bokehScale = t, this.resolutionScale && (this.resolutionScale.onValueChanged = (t) => e.resolution.scale = t), [e];
  }
  unapply() {
  }
}
kr([
  u()
], qn.prototype, "mode");
kr([
  u(F)
], qn.prototype, "focusDistance");
kr([
  u(F)
], qn.prototype, "focalLength");
kr([
  u(F)
], qn.prototype, "aperture");
kr([
  u(F)
], qn.prototype, "gaussianMaxRadius");
kr([
  u(F)
], qn.prototype, "resolutionScale");
kr([
  u(F)
], qn.prototype, "bokehScale");
gn("DepthOfField", qn);
class Ed extends at {
  effect;
  constructor(e) {
    super(), this.effect = e;
  }
  get typeName() {
    return this.effect.constructor.name;
  }
  onCreateEffect() {
    return this.effect;
  }
}
var pE = Object.defineProperty, mE = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && pE(e, t, n), n;
};
class Fu extends at {
  get typeName() {
    return "PixelationEffect";
  }
  granularity = new F(10);
  onCreateEffect() {
    const e = new T.POSTPROCESSING.MODULE.PixelationEffect();
    return this.granularity.onValueChanged = (t) => {
      e.granularity = t;
    }, e;
  }
}
mE([
  u(F)
], Fu.prototype, "granularity");
gn("PixelationEffect", Fu);
var gE = Object.defineProperty, Wc = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && gE(e, t, n), n;
};
class ko extends at {
  get typeName() {
    return "ScreenSpaceAmbientOcclusion";
  }
  intensity = new F(2);
  falloff = new F(1);
  samples = new F(9);
  color = new F(new se(0, 0, 0));
  luminanceInfluence = new F(0.7);
  onBeforeRender() {
    if (this._ssao && this.context.mainCamera instanceof de) {
      const e = this.context.mainCamera.far - this.context.mainCamera.near;
      this._ssao.ssaoMaterial.worldDistanceFalloff = e * 0.01, this._ssao.ssaoMaterial.worldDistanceThreshold = this.context.mainCamera.far;
    }
  }
  _ssao;
  onCreateEffect() {
    const e = this.context.mainCamera, t = new T.POSTPROCESSING.MODULE.NormalPass(this.context.scene, e), i = new T.POSTPROCESSING.MODULE.DepthDownsamplingPass({
      normalBuffer: t.texture,
      resolutionScale: 0.5
    }), n = this._ssao = new T.POSTPROCESSING.MODULE.SSAOEffect(e, t.texture, {
      normalDepthBuffer: i.texture,
      worldDistanceThreshold: 1,
      // when it starts to fade out
      worldDistanceFalloff: 1,
      // smoothness of cutoff
      worldProximityThreshold: 0.1,
      worldProximityFalloff: 2,
      intensity: 1,
      blendFunction: T.POSTPROCESSING.MODULE.BlendFunction.MULTIPLY,
      luminanceInfluence: 0.5
    });
    this.intensity.onValueChanged = (r) => {
      n.intensity = r;
    }, this.falloff.onValueChanged = (r) => {
      n.ssaoMaterial.radius = r * 0.1;
    }, this.samples.onValueChanged = (r) => {
      n.ssaoMaterial.samples = r;
    }, this.color.onValueChanged = (r) => {
      n.color || (n.color = new se()), n.color.copy(r);
    }, this.luminanceInfluence.onValueChanged = (r) => {
      n.luminanceInfluence = r;
    };
    const o = new Array();
    return o.push(t), o.push(i), o.push(n), o;
  }
}
Wc([
  u(F)
], ko.prototype, "intensity");
Wc([
  u(F)
], ko.prototype, "falloff");
Wc([
  u(F)
], ko.prototype, "samples");
Wc([
  u(F)
], ko.prototype, "color");
Wc([
  u(F)
], ko.prototype, "luminanceInfluence");
gn("ScreenSpaceAmbientOcclusion", ko);
var yE = Object.defineProperty, Mr = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && yE(e, t, n), n;
};
const _E = w("debugN8AO");
var dm = /* @__PURE__ */ ((s) => (s[s.Performance = 0] = "Performance", s[s.Low = 1] = "Low", s[s.Medium = 2] = "Medium", s[s.High = 3] = "High", s[s.Ultra = 4] = "Ultra", s))(dm || {});
class Xn extends at {
  get typeName() {
    return "ScreenSpaceAmbientOcclusionN8";
  }
  get pass() {
    return this._ssao;
  }
  gammaCorrection = !0;
  aoRadius = new F(1);
  falloff = new F(1);
  intensity = new F(1);
  color = new F(new se(0, 0, 0));
  screenspaceRadius = !1;
  quality = 2;
  _ssao;
  onValidate() {
    this._ssao && (this._ssao.setQualityMode(dm[this.quality]), this._ssao.configuration.gammaCorrection = this.gammaCorrection, this._ssao.configuration.screenSpaceRadius = this.screenspaceRadius);
  }
  onCreateEffect() {
    const e = this.context.mainCamera, t = this.context.domWidth, i = this.context.domHeight, n = this._ssao = new T.POSTPROCESSING_AO.MODULE.N8AOPostPass(
      this.context.scene,
      e,
      t,
      i
    );
    n.name = "SSAO_N8";
    const o = dm[this.quality];
    n.setQualityMode(o), n.configuration.transparencyAware = !1;
    const r = new Dn(t, i);
    return n.configuration.beautyRenderTarget = r, n.configuration.autoRenderBeauty = !1, n.configuration.gammaCorrection = this.gammaCorrection, n.configuration.screenSpaceRadius = this.screenspaceRadius, _E && (n.enableDebugMode(), console.log(n), setInterval(() => {
      console.log("SSAO", n.lastTime);
    }, 1e3), setInterval(() => {
      console.log("SSAO", n.enabled, { ssao: n, autoRenderBeauty: n.configuration.autoRenderBeauty });
    }, 4e3)), this.intensity.onValueChanged = (a) => {
      n.configuration.intensity = a;
    }, this.falloff.onValueChanged = (a) => {
      n.configuration.distanceFalloff = a;
    }, this.aoRadius.onValueChanged = (a) => {
      n.configuration.aoRadius = a;
    }, this.color.onValueChanged = (a) => {
      n.color || (n.color = new se()), n.configuration.color.copy(a);
    }, n;
  }
}
Mr([
  Lt(),
  u()
], Xn.prototype, "gammaCorrection");
Mr([
  u(F)
], Xn.prototype, "aoRadius");
Mr([
  u(F)
], Xn.prototype, "falloff");
Mr([
  u(F)
], Xn.prototype, "intensity");
Mr([
  u(F)
], Xn.prototype, "color");
Mr([
  Lt(),
  u()
], Xn.prototype, "screenspaceRadius");
Mr([
  Lt(),
  u()
], Xn.prototype, "quality");
gn("ScreenSpaceAmbientOcclusionN8", Xn);
var bE = Object.defineProperty, vE = Object.getOwnPropertyDescriptor, Pw = (s, e, t, i) => {
  for (var n = vE(e, t), o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && bE(e, t, n), n;
};
class zu extends at {
  get typeName() {
    return "Sharpening";
  }
  order = dt.Sharpening;
  _effect;
  onCreateEffect() {
    return this._effect ??= new (wE())(), this.effect;
  }
  get effect() {
    return this._effect;
  }
  set amount(e) {
    this._amount = e, this._effect && (this._effect.uniforms.get("amount").value = e);
  }
  get amount() {
    return this._effect ? this._effect.uniforms.get("amount").value : this._amount;
  }
  _amount = 1;
  set radius(e) {
    this._radius = e, this._effect && (this._effect.uniforms.get("radius").value = e);
  }
  get radius() {
    return this._effect ? this._effect.uniforms.get("radius").value : this._radius;
  }
  _radius = 1;
  // @serializable()
  // set threshold(value: number) {
  //     this.effect.uniforms.get("threshold")!.value = value;
  // }
  // get threshold() {
  //     return this.effect.uniforms.get("threshold")!.value;
  // }
}
Pw([
  u()
], zu.prototype, "amount");
Pw([
  u()
], zu.prototype, "radius");
function wE() {
  const s = `
      void mainSupport() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `, e = `
    uniform sampler2D tDiffuse;
    uniform float amount;
    uniform float radius;
    
    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        float tx = 1.0 / resolution.x;
        float ty = 1.0 / resolution.y;
        vec2 texelSize = vec2(tx, ty);
    
        vec4 blurred = vec4(0.0);
        float total = 0.0;
    
        for (float x = -radius; x <= radius; x++) {
            for (float y = -radius; y <= radius; y++) {
                vec2 offset = vec2(x, y) * texelSize;
                vec4 diffuse = texture2D(tDiffuse, uv + offset);
                float weight = exp(-length(offset) * amount);
                blurred += diffuse * weight;
                total += weight;
            }
        }
    
        if (total > 0.0) {
            blurred /= total;
        }
    
        // Calculate the sharpened color using inputColor
        vec4 sharp = inputColor + clamp(inputColor - blurred, 0.0, 1.0) * amount;
        // Keep original alpha
        sharp.a = inputColor.a;
    
        // Ensure the sharp color does not go below 0 or above 1
        // This means: sharpening must happen AFTER tonemapping.
        sharp = clamp(sharp, 0.0, 1.0);
    
        outputColor = sharp;
    }
    
    `;
  class t extends T.POSTPROCESSING.MODULE.Effect {
    constructor() {
      super("Sharpening", e, {
        vertexShader: s,
        blendFunction: T.POSTPROCESSING.MODULE.BlendFunction.NORMAL,
        uniforms: /* @__PURE__ */ new Map([
          ["amount", new $i(1)],
          ["radius", new $i(1)]
          // ["threshold", new Uniform(0)],
        ]),
        attributes: oC.CONVOLUTION
      });
    }
  }
  return t;
}
var xE = Object.defineProperty, Za = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && xE(e, t, n), n;
};
class Ds extends at {
  get typeName() {
    return "TiltShiftEffect";
  }
  offset = new F(0);
  rotation = new F(0);
  focusArea = new F(0.4);
  feather = new F(0.3);
  kernelSize = new F(2);
  resolutionScale = new F(1 / window.devicePixelRatio);
  init() {
    this.offset.defaultValue = 0, this.rotation.defaultValue = 0, this.focusArea.defaultValue = 0.4, this.feather.defaultValue = 0.3, this.kernelSize.defaultValue = T.POSTPROCESSING.MODULE.KernelSize.MEDIUM, this.resolutionScale.defaultValue = 1 / window.devicePixelRatio;
  }
  onCreateEffect() {
    const e = new T.POSTPROCESSING.MODULE.TiltShiftEffect({
      kernelSize: T.POSTPROCESSING.MODULE.KernelSize.VERY_LARGE,
      offset: this.offset.value,
      rotation: this.rotation.value,
      focusArea: this.focusArea.value,
      feather: this.feather.value
    });
    return this.offset.onValueChanged = (t) => e.offset = t, this.rotation.onValueChanged = (t) => e.rotation = t, this.focusArea.onValueChanged = (t) => e.focusArea = t, this.feather.onValueChanged = (t) => e.feather = t, this.kernelSize.onValueChanged = (t) => e.blurPass.kernelSize = t, this.resolutionScale.onValueChanged = (t) => e.resolution.scale = t / window.devicePixelRatio, e;
  }
}
Za([
  u(F)
], Ds.prototype, "offset");
Za([
  u(F)
], Ds.prototype, "rotation");
Za([
  u(F)
], Ds.prototype, "focusArea");
Za([
  u(F)
], Ds.prototype, "feather");
Za([
  u(F)
], Ds.prototype, "kernelSize");
Za([
  u(F)
], Ds.prototype, "resolutionScale");
gn("TiltShiftEffect", Ds);
var SE = Object.defineProperty, Vg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && SE(e, t, n), n;
};
class Ja extends at {
  get typeName() {
    return "Vignette";
  }
  color = new F({ r: 0, g: 0, b: 0, a: 1 });
  intensity = new F(0);
  center = new F({ x: 0.5, y: 0.5 });
  init() {
    this.color.defaultValue = { r: 0, g: 0, b: 0, a: 1 }, this.intensity.defaultValue = 0, this.center.defaultValue = { x: 0.5, y: 0.5 };
  }
  onCreateEffect() {
    const e = new T.POSTPROCESSING.MODULE.VignetteEffect();
    return this.intensity.onValueChanged = (t) => {
      e.offset = t, this.updateDarkness(e);
    }, this.color.onValueChanged = (t) => {
      this.updateDarkness(e);
    }, e;
  }
  updateDarkness(e) {
    const t = this.intensity.value;
    e.darkness = t;
  }
}
Vg([
  u(F)
], Ja.prototype, "color");
Vg([
  u(F)
], Ja.prototype, "intensity");
Vg([
  u(F)
], Ja.prototype, "center");
gn("Vignette", Ja);
globalThis.NEEDLE_USE_POSTPROCESSING = globalThis.NEEDLE_USE_POSTPROCESSING !== void 0 ? globalThis.NEEDLE_USE_POSTPROCESSING : !0;
const ts = w("debugpost"), rp = Symbol("needle:postprocessing-handler"), bl = Symbol("needle:previous-autoclear-state"), vl = Symbol("needle:previous-tone-mapping");
class Ow {
  _composer = null;
  _lastVolumeComponents;
  _effects = [];
  /**
   * Returns true if a specific effect is currently active in the post processing stack.
   */
  getEffectIsActive(e) {
    return e ? this._isActive && this._effects.some((t) => t.effect === e) : !1;
  }
  get isActive() {
    return this._isActive;
  }
  get composer() {
    return this._composer;
  }
  _isActive = !1;
  context;
  constructor(e) {
    this.context = e;
  }
  apply(e) {
    return this._isActive = !0, this.onApply(this.context, e);
  }
  unapply(e = !0) {
    if (ts && console.log("Unapplying postprocessing effects"), this._isActive = !1, this._lastVolumeComponents) {
      for (const n of this._lastVolumeComponents)
        n.unapply();
      this._lastVolumeComponents.length = 0;
    }
    const t = this.context;
    t[rp] === this && (delete t[rp], typeof t.renderer[bl] == "boolean" && (t.renderer.autoClear = t.renderer[bl]), typeof t.renderer[vl] == "number" && (t.renderer.toneMapping = t.renderer[vl])), this._composer?.removeAllPasses(), e && this._composer?.dispose(), t.composer === this._composer && (t.composer = null), this.handleDevicePixelRatio();
  }
  dispose() {
    this.unapply(!0);
    for (const e of this._effects)
      e.effect.dispose();
    this._effects.length = 0, this._composer = null;
  }
  async onApply(e, t) {
    if (!t) return;
    await Promise.all([
      T.POSTPROCESSING.load(),
      T.POSTPROCESSING_AO.load()
      // import("./Effects/Sharpening.effect")
    ]), e[rp] = this, ts && console.log("Apply Postprocessing Effects", t), this._lastVolumeComponents = [...t], this._effects.length = 0;
    const i = {
      handler: this,
      components: this._lastVolumeComponents
    };
    for (let n = 0; n < this._lastVolumeComponents.length; n++) {
      const o = this._lastVolumeComponents[n];
      if (o.context = e, o.apply) {
        if (o.active) {
          let r = function(c, h) {
            return h ? (h instanceof T.POSTPROCESSING.MODULE.Effect || h instanceof T.POSTPROCESSING.MODULE.Pass || console.warn(`PostprocessingEffect ${c} created neither Effect nor Pass - this might be caused by a bundler error or false import. Below you find some possible solutions:
- If you create custom effect try creating it like this: 'new NEEDLE_ENGINE_MODULES.POSTPROCESSING.MODULE.Effect(...)' instead of 'new Effect(...)'`), !0) : !1;
          };
          if (!e.mainCameraComponent) {
            console.error("No camera in scene found or available yet - can not create postprocessing effects");
            return;
          }
          const a = o.apply(i);
          if (!a) continue;
          const l = o.typeName || o.constructor.name;
          if (Array.isArray(a))
            for (const c of a)
              r(l, c) && this._effects.push({
                effect: c,
                typeName: o.typeName,
                priority: o.order
              });
          else {
            if (!r(l, a)) continue;
            this._effects.push({
              effect: a,
              typeName: o.typeName,
              priority: o.order
            });
          }
        }
      } else
        o.active && ge("Volume component is not a VolumeComponent: " + o.__type);
    }
    this.applyEffects(e);
  }
  _anyPassHasDepth = !1;
  _anyPassHasNormal = !1;
  _hasSmaaEffect = !1;
  get anyPassHasDepth() {
    return this._anyPassHasDepth;
  }
  get anyPassHasNormal() {
    return this._anyPassHasNormal;
  }
  get hasSmaaEffect() {
    return this._hasSmaaEffect;
  }
  _customInputBuffer = null;
  _customInputBufferId = 0;
  _multisampling = 0;
  set multisampling(e) {
    this._multisampling = e;
  }
  get multisampling() {
    return this._multisampling;
  }
  /** Build composer passes */
  applyEffects(e) {
    if (this._anyPassHasDepth = !1, this._anyPassHasNormal = !1, this._hasSmaaEffect = !1, this._effects.length <= 0)
      return;
    const t = e.mainCameraComponent, i = e.renderer, n = e.scene, o = t.threeCamera;
    if (typeof i[bl] == "boolean" && (i.autoClear = i[bl]), i[bl] = i.autoClear, typeof i[vl] == "number" && (i.toneMapping = i[vl]), i[vl] = i.toneMapping, i.toneMapping != id && !this._effects.find((h) => h instanceof T.POSTPROCESSING.MODULE.ToneMappingEffect)) {
      const h = new T.POSTPROCESSING.MODULE.ToneMappingEffect();
      h.name = `ToneMapping (${i.toneMapping})`, h.mode = Jh(i.toneMapping), this._effects.push({
        typeName: "ToneMapping",
        effect: h,
        priority: dt.ToneMapping
      });
    }
    this._composer || (this._composer = new T.POSTPROCESSING.MODULE.EffectComposer(i, {
      frameBufferType: tf,
      stencilBuffer: !0
    })), e.composer && e.composer !== this._composer && console.warn("There's already an active EffectComposer in your scene: replacing it with a new one. This might cause unexpected behaviour. Make sure to only use one PostprocessingManager/Volume in your scene."), e.composer = this._composer;
    const r = e.composer;
    r.setMainCamera(o), r.setRenderer(i), r.setMainScene(n), r.autoRenderToScreen = !0, r.multisampling = 0;
    for (const h of r.passes)
      h.dispose();
    r.removeAllPasses();
    const a = new T.POSTPROCESSING.MODULE.RenderPass(n, o);
    a.name = "RenderPass", a.mainScene = n, r.addPass(a);
    const l = a.render;
    this._customInputBuffer?.dispose(), this._customInputBuffer = null, a.render = (h, d, f, p, g) => {
      d && (d.samples = 0, f && (f.samples = 0), (!this._customInputBuffer || this._customInputBuffer.width !== d.width || this._customInputBuffer.height !== d.height || this._customInputBuffer.samples !== this._multisampling || this._customInputBuffer.texture.format !== d.texture.format || this._customInputBuffer.texture.type !== tf) && (this._customInputBuffer?.dispose(), this._customInputBuffer = new Dn(d.width, d.height, {
        format: d.texture.format,
        type: tf,
        depthBuffer: d.depthBuffer,
        depthTexture: d.depthTexture ? new Rb(d.width, d.height) : void 0,
        stencilBuffer: d.stencilBuffer,
        samples: Math.max(0, this._multisampling),
        minFilter: d.texture.minFilter ?? sd,
        magFilter: d.texture.magFilter ?? sd,
        generateMipmaps: d.texture.generateMipmaps
      }), this._customInputBufferId++, this._customInputBuffer.texture.name = `CustomInputBuffer-${this._customInputBufferId}`, this._customInputBuffer.depthTexture && d.depthTexture && (this._customInputBuffer.depthTexture.format = d.depthTexture.format, this._customInputBuffer.depthTexture.type = d.depthTexture.type), this._customInputBuffer.samples > 0 && (this._customInputBuffer.ignoreDepthForMultisampleCopy = !1), ts && console.warn(`[PostProcessing] Input buffer created with size ${this._customInputBuffer.width}x${this._customInputBuffer.height} and samples ${this._customInputBuffer.samples}`)), l.call(a, h, this._customInputBuffer, f, p, g), ar.blit(this._customInputBuffer.texture, d, {
        renderer: h,
        depthTexture: this._customInputBuffer.depthTexture,
        depthWrite: !0,
        depthTest: !0
      }));
    };
    try {
      GT(this._effects);
      let h = !1, d = null;
      for (let g = this._effects.length - 1; g >= 0; g--) {
        const b = this._effects[g].effect;
        if (b instanceof T.POSTPROCESSING.MODULE.ToneMappingEffect) {
          if (h) {
            ts && console.warn(`[PostProcessing] Found multiple tonemapping effects in the scene: ${b.name} and ${d?.name}. Only the last one added will be used.`), this._effects.splice(g, 1);
            continue;
          }
          d = b, h = !0;
        }
      }
      const f = [];
      let p = !1;
      for (let g = 0; g < this._effects.length; g++) {
        const m = this._effects[g].effect;
        if (m instanceof T.POSTPROCESSING.MODULE.SMAAEffect ? this._hasSmaaEffect = !0 : m instanceof T.POSTPROCESSING.MODULE.NormalPass && (this._anyPassHasNormal = !0), !(m instanceof T.POSTPROCESSING.MODULE.ToneMappingEffect && d !== m))
          if (m instanceof T.POSTPROCESSING.MODULE.Effect) {
            const v = m.getAttributes(), _ = T.POSTPROCESSING.MODULE.EffectAttribute.CONVOLUTION;
            v & _ && (ts && console.log("[PostProcessing] Convolution effect: " + m.name), p && (ts && console.log("[PostProcessing] → Merging effects [" + f.map((x) => x.name).join(", ") + "]"), this.createPassForMergeableEffects(f, r, o, n)), p = !0), f.push(m);
          } else m instanceof T.POSTPROCESSING.MODULE.Pass ? (p = !1, this.createPassForMergeableEffects(f, r, o, n), m.renderToScreen = !1, r.addPass(m)) : (p = !1, this.createPassForMergeableEffects(f, r, o, n), r.addPass(m));
      }
      this.createPassForMergeableEffects(f, r, o, n);
    } catch (h) {
      console.error("Error while applying postprocessing effects", h), r.passes.forEach((d) => d.dispose()), r.removeAllPasses();
    }
    let c = !1;
    for (let h = r.passes.length - 1; h >= 0; h--) {
      const d = r.passes[h];
      let f = !1, p = !1;
      d.enabled && (c || (f = !0, p = !0), c = !0), d.renderToScreen = p, d?.configuration !== void 0 ? d.configuration.gammaCorrection = f : "autosetGamma" in d && (d.autosetGamma = f), this._anyPassHasDepth ||= d.needsDepthTexture;
    }
    this.handleDevicePixelRatio(), ts && console.log("[PostProcessing] Passes →", [...r.passes], `
---------------------------------
• ` + r.passes.map((h) => h.name || h.constructor.name + "*").join(`
• `) + `
`), ts && this._onCreateEffectsDebug(this._composer, o);
  }
  /** Should be called before `composer.addPass()` to create an effect pass with all previously collected effects that can be merged up to that point */
  createPassForMergeableEffects(e, t, i, n) {
    if (e.length > 0) {
      const o = new T.POSTPROCESSING.MODULE.EffectPass(i, ...e);
      o.name = e.map((r) => r.name).join(", "), o.mainScene = n, o.enabled = !0, o.renderToScreen = !1, t.addPass(o), e.length = 0;
    }
  }
  handleDevicePixelRatio() {
    typeof this.context.devicePixelRatio == "number" && this.context.requestSizeUpdate();
  }
  _menuEntry = null;
  _passIndices = null;
  _onCreateEffectsDebug(e, t) {
    if (ts === "passes") {
      const i = new T.POSTPROCESSING.MODULE.DepthEffect({
        blendFunction: T.POSTPROCESSING.MODULE.BlendFunction.NORMAL,
        inverted: !0
      });
      i.name = "Depth Effect";
      const n = new T.POSTPROCESSING.MODULE.EffectPass(t, i);
      if (n.name = "Depth Effect Pass", n.enabled = !1, e.passes.push(n), this._passIndices !== null) {
        const r = [e.passes[0]];
        this._passIndices.length > 0 && r.push(
          ...this._passIndices.filter((a) => a !== 0).map((a) => e.passes[a]).filter((a) => a)
        ), r.length > 0 && console.log("[PostProcessing] Passes (selected) →", r), e.passes.length = 0;
        for (const a of r)
          a.enabled = !0, a.renderToScreen = !1, e.addPass(a);
      }
      const o = this.context.menu;
      if (o && this._passIndices === null) {
        this._menuEntry && this._menuEntry.remove();
        const r = document.createElement("select");
        r.multiple = !0;
        const a = document.createElement("option");
        a.innerText = "Final Output", a.value = "-1", r.appendChild(a);
        for (const l of e.passes) {
          const c = document.createElement("option");
          c.innerText = l.name, c.value = `${e.passes.indexOf(l)}`, c.title = l.name, r.appendChild(c);
        }
        o.appendChild(r), this._menuEntry = r, r.addEventListener("change", () => {
          const l = Array.from(r.selectedOptions).map((c) => parseInt(c.value));
          l.length === 1 && l[0] === -1 ? this._passIndices = null : this._passIndices = l, this.applyEffects(this.context);
        });
      }
    }
  }
}
var CE = Object.defineProperty, kw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && CE(e, t, n), n;
};
const Uo = w("debugpost");
class Vc extends R {
  get isPostProcessingManager() {
    return !0;
  }
  /** Currently active postprocessing effects */
  get effects() {
    return this._activeEffects;
  }
  get dirty() {
    return this._isDirty;
  }
  set dirty(e) {
    this._isDirty = e;
  }
  sharedProfile;
  multisampling = "auto";
  /**
   * Add a post processing effect to the stack and schedules the effect stack to be re-created.  
   */
  addEffect(e) {
    let t = e;
    return t instanceof at || (t = new Ed(t), typeof e.order == "number" && (t.order = e.order)), t.gameObject === void 0 && this.gameObject.addComponent(t), this._effects.includes(t) || (this._effects.push(t), this._isDirty = !0), e;
  }
  /**
   * Remove a post processing effect from the stack and schedules the effect stack to be re-created.
   */
  removeEffect(e) {
    let t = -1;
    if (e instanceof at ? t = this._effects.indexOf(e) : t = this._effects.findIndex((i) => i instanceof Ed && i.effect === e), t !== -1)
      return this._effects.splice(t, 1), this._isDirty = !0, e;
    if (e instanceof at) {
      const i = this.sharedProfile?.components?.indexOf(e);
      i !== void 0 && i !== -1 && (this._isDirty = !0, this.sharedProfile?.components?.splice(i, 1));
    }
    return e;
  }
  _postprocessing;
  _activeEffects = [];
  _effects = [];
  /**
   * When dirty the post processing effects will be re-applied
   */
  markDirty() {
    this._isDirty = !0;
  }
  /** @internal */
  awake() {
    Uo && (console.log("PostprocessingManager Awake", this), console.log("Press P to toggle post processing"), window.addEventListener("keydown", (e) => {
      e.key === "p" && (this.enabled = !this.enabled, Be("Toggle PostProcessing " + this.name + ": Enabled=" + this.enabled), this.markDirty());
    })), this.sharedProfile?.__init(this);
  }
  _componentEnabledTime = -1;
  _multisampleAutoChangeTime = 0;
  _multisampleAutoDecreaseTime = 0;
  /** @internal */
  onEnable() {
    this._componentEnabledTime = this.context.time.realtimeSinceStartup, this._isDirty = !0;
  }
  /** @internal */
  onDisable() {
    this._postprocessing?.unapply(), this._isDirty = !1;
  }
  /** @internal */
  onBeforeRender() {
    if (!this.context.isInXR && (this.context.mainCamera && this._isDirty && this.apply(), this.context.composer && this._postprocessing && this._postprocessing.composer === this.context.composer)) {
      if (this.context.renderer.getContext().isContextLost() && this.context.renderer.forceContextRestore(), this.context.composer.getRenderer() !== this.context.renderer && this.context.composer.setRenderer(this.context.renderer), this.context.composer.setMainScene(this.context.scene), this.multisampling === "auto")
        if (this._postprocessing && this._postprocessing.hasSmaaEffect)
          this._postprocessing.multisampling !== 0 && (this._postprocessing.multisampling = 0, (Uo || L()) && console.log(`[PostProcessing] multisampling is disabled because it's set to 'auto' on your PostprocessingManager/Volume component that also has an SMAA effect.

If you need multisampling consider changing 'auto' to a fixed value (e.g. 4).`));
        else {
          const e = this.context.time.realtimeSinceStartup - this._multisampleAutoChangeTime;
          if (this.context.time.realtimeSinceStartup - this._componentEnabledTime > 2 && e > 0.5) {
            const t = this._postprocessing.multisampling;
            if (this._postprocessing.multisampling > 0 && this.context.time.smoothedFps <= 50) {
              this._multisampleAutoChangeTime = this.context.time.realtimeSinceStartup, this._multisampleAutoDecreaseTime = this.context.time.realtimeSinceStartup;
              let i = this._postprocessing.multisampling * 0.5;
              i = Math.floor(i), i != this._postprocessing.multisampling && (this._postprocessing.multisampling = i), Uo && console.debug(`[PostProcessing] Reduced multisampling from ${t} to ${this._postprocessing.multisampling}`);
            } else if (e > 1 && this.context.time.smoothedFps >= 59 && this._postprocessing.multisampling < this.context.renderer.capabilities.maxSamples && this.context.time.realtimeSinceStartup - this._multisampleAutoDecreaseTime > 10) {
              this._multisampleAutoChangeTime = this.context.time.realtimeSinceStartup;
              let i = this._postprocessing.multisampling <= 0 ? 1 : this._postprocessing.multisampling * 2;
              i = Math.floor(i), i !== this._postprocessing.multisampling && (this._postprocessing.multisampling = i), Uo && console.debug(`[PostProcessing] Increased multisampling from ${t} to ${this._postprocessing.multisampling}`);
            }
          }
        }
      else {
        const e = Math.max(0, Math.min(this.multisampling, this.context.renderer.capabilities.maxSamples));
        e !== this._postprocessing.multisampling && (this._postprocessing.multisampling = e);
      }
      if (this.context.mainCamera) {
        const e = this.context.composer.passes;
        for (const t of e)
          if (t.mainCamera && t.mainCamera !== this.context.mainCamera) {
            this.context.composer.setMainCamera(this.context.mainCamera);
            break;
          }
      }
    }
  }
  /** @internal */
  onDestroy() {
    this._postprocessing?.dispose();
  }
  _lastApplyTime;
  _rapidApplyCount = 0;
  _isDirty = !1;
  apply() {
    if (Uo && console.log(`Apply PostProcessing "${this.name || "unnamed"}"`), L() && (this._lastApplyTime !== void 0 && Date.now() - this._lastApplyTime < 100 && (this._rapidApplyCount++, this._rapidApplyCount === 5 && console.warn("Detected rapid post processing modifications - this might be a bug", this)), this._lastApplyTime = Date.now()), this._isDirty = !1, this._activeEffects.length = 0, this.sharedProfile?.components) {
      const e = this.sharedProfile.components;
      for (const t of e)
        t.active && t.enabled && !this._activeEffects.includes(t) && this._activeEffects.push(t);
    }
    for (const e of this._effects)
      e.active && e.enabled && !this._activeEffects.includes(e) && this._activeEffects.push(e);
    this._activeEffects.length > 0 ? (this._postprocessing || (this._postprocessing = new Ow(this.context)), this._postprocessing.apply(this._activeEffects)?.then(() => {
      this.activeAndEnabled && (this._applyPostQueue(), this._postprocessing ? (this.multisampling === "auto" ? this._postprocessing.multisampling = q.isMobileDevice() ? 2 : 4 : this._postprocessing.multisampling = Math.max(0, Math.min(this.multisampling, this.context.renderer.capabilities.maxSamples)), Uo && console.debug(`[PostProcessing] Set multisampling to ${this._postprocessing.multisampling} (Is Mobile: ${q.isMobileDevice()})`)) : Uo && console.warn("[PostProcessing] No composer found"));
    })) : this._postprocessing?.unapply(!1);
  }
  _applyPostQueue() {
    if (this._modificationQueue) {
      for (const e of this._modificationQueue.values()) this.onEditorModification(e);
      this._modificationQueue.clear();
    }
  }
  /** called from needle editor sync package if its active */
  onEditorModification(e) {
    if (e.propertyName.startsWith("postprocessing.")) {
      if (!this._postprocessing)
        return this._modificationQueue || (this._modificationQueue = /* @__PURE__ */ new Map()), this._modificationQueue.set(e.propertyName, e), !0;
      if (!this._activeEffects?.length) return;
      const t = e.propertyName.split(".");
      if (t.length === 3 || t.length === 4) {
        const i = t[1], n = t[2];
        for (const o of this._activeEffects)
          if (o.typeName?.toLowerCase() === i.toLowerCase()) {
            if (n === "active") {
              o.active = e.value, this.scheduleRecreate();
              return;
            }
            if (!Ih.has(i)) {
              const r = new Array();
              Ih.set(i, r);
              const a = Object.keys(o);
              for (const l of a)
                o[l] instanceof F && r.push(l);
            }
            if (Ih.has(i)) {
              const r = n.toLowerCase(), a = Ih.get(i);
              for (const l of a)
                if (l.toLowerCase() === r) {
                  const c = o[l];
                  c instanceof F && (t.length === 4 && t[3] === "active" ? (c.overrideState = e.value, this.scheduleRecreate()) : c && c.value !== void 0 && (c.value = e.value));
                  return;
                }
            }
            console.warn("Unknown modification", n);
            return;
          }
      }
      return !0;
    }
    return !1;
  }
  _modificationQueue;
  _recreateId = -1;
  scheduleRecreate() {
    const e = ++this._recreateId;
    setTimeout(() => {
      e === this._recreateId && (this.onDisable(), this.onEnable());
    }, 200);
  }
}
kw([
  lt(Ng)
], Vc.prototype, "sharedProfile");
kw([
  lt()
], Vc.prototype, "multisampling");
const Ih = /* @__PURE__ */ new Map();
VT(Vc);
async function Hg(s) {
  const { NeedleEngineWebComponent: e } = await Promise.resolve().then(() => aI);
  e.observedAttributes.includes(s) || e.observedAttributes.push(s);
}
var PE = Object.defineProperty, bt = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && PE(e, t, n), n;
};
const Tt = w("debugsceneswitcher"), OE = w("sceneswitcher:clearscene"), ed = "scene";
Hg(ed);
const Ws = Promise.resolve(!1);
class Ze extends R {
  autoLoadFirstScene = !0;
  scenes = [];
  loadingScene;
  queryParameterName = "scene";
  useSceneName = !0;
  clamp = !0;
  useHistory = !0;
  useKeyboard = !0;
  useSwipe = !0;
  useSceneLighting = !0;
  useSceneBackground = !0;
  preloadNext = 1;
  preloadPrevious = 1;
  preloadConcurrent = 2;
  createMenuButtons = !1;
  /** The index of the currently loaded and active scene */
  get currentIndex() {
    return this._currentIndex;
  }
  /** Get the progress of the currently loading scene. This is undefined if no scene is loading  
   * You can also subscribe to the loading event by adding an event listener to the scene switcher.  
   * For example like this `sceneSwitcher.addEventListeneer("progress", (e) => {...})`
   */
  get currentLoadingProgress() {
    return this._currentLoadingProgress;
  }
  /** The currently loading scene. This is undefined if no scene is loading. */
  get currentlyLoadingScene() {
    return this._currentlyLoadingScene;
  }
  /**
   * The currently loaded scene. This is undefined if no scene is loaded.
   */
  get currentlyLoadedScene() {
    return this._currentScene;
  }
  sceneLoadingStart = new ce();
  sceneLoadingProgress = new ce();
  sceneLoaded = new ce();
  _currentIndex = -1;
  _currentScene = void 0;
  _engineElementOverserver = void 0;
  _preloadScheduler;
  _menuButtons;
  /** @internal */
  awake() {
    this.scenes === void 0 && (this.scenes = []);
    for (const e of this.scenes)
      e && !e.hasUrl && e.asset instanceof M ? S.remove(e.asset) : e instanceof M && S.remove(e);
    Tt && console.log("SceneSwitcher", this);
  }
  /** @internal */
  async onEnable() {
    if (globalThis.addEventListener("popstate", this.onPopState), this.context.input.addEventListener(De.KeyDown, this.onInputKeyDown), this.context.input.addEventListener(De.PointerMove, this.onInputPointerMove), this.context.input.addEventListener(De.PointerUp, this.onInputPointerUp), this._engineElementOverserver || (this._engineElementOverserver = new MutationObserver((e) => {
      for (const t of e)
        if (t.type === "attributes" && t.attributeName === ed) {
          const i = this.context.domElement.getAttribute(ed);
          i !== null && this.trySelectSceneFromValue(i);
        }
    })), this._engineElementOverserver.observe(this.context.domElement, {
      attributes: !0
    }), this._preloadScheduler || (this._preloadScheduler = new kE(this)), this._preloadScheduler.maxLoadAhead = this.preloadNext, this._preloadScheduler.maxLoadBehind = this.preloadPrevious, this._preloadScheduler.maxConcurrent = this.preloadConcurrent, this._preloadScheduler.begin(2e3), this.autoLoadFirstScene && this._currentIndex === -1 && !await this.tryLoadFromQueryParam()) {
      const e = this.context.domElement.getAttribute(ed);
      try {
        (e === null || !await this.trySelectSceneFromValue(e)) && this._currentIndex === -1 && this.select(0);
      } finally {
      }
    }
    this.createMenuButtons && (this._menuButtons ??= [], this._menuButtons.push(this.context.menu.appendChild({
      label: "Previous",
      icon: "arrow_back_ios",
      onClick: () => this.selectPrev(),
      priority: -1005,
      class: "row2"
    })), this._menuButtons.push(this.context.menu.appendChild({
      label: "Next",
      icon: "arrow_forward_ios",
      iconSide: "right",
      onClick: () => this.selectNext(),
      priority: -1e3,
      class: "row2"
    })));
  }
  /** @internal */
  onDisable() {
    if (globalThis.removeEventListener("popstate", this.onPopState), this.context.input.removeEventListener(De.KeyDown, this.onInputKeyDown), this.context.input.removeEventListener(De.PointerMove, this.onInputPointerMove), this.context.input.removeEventListener(De.PointerUp, this.onInputPointerUp), this._preloadScheduler?.stop(), this._menuButtons) {
      for (const e of this._menuButtons)
        e.remove();
      this._menuButtons = void 0;
    }
  }
  onPopState = async (e) => {
    if (!this.useHistory) return;
    const t = this.useHistory;
    try {
      this.useHistory = !1;
      let i = !1;
      if (this.queryParameterName && (i = await this.tryLoadFromQueryParam()), !i) {
        const n = e?.state;
        if (n && n.startsWith(this.guid)) {
          const o = n.substr(this.guid.length + 2);
          Tt && console.log("PopState", o), await this.trySelectSceneFromValue(o);
        }
      }
    } finally {
      this.useHistory = t;
    }
  };
  normalizedSwipeThresholdX = 0.1;
  _didSwipe = !1;
  onInputPointerMove = (e) => {
    if (this.useSwipe && !this._didSwipe && e.button === 0 && e.pointerType === "touch" && this.context.input.getPointerPressedCount() === 1) {
      const t = this.context.input.getPointerPositionDelta(e.button);
      if (t) {
        const i = t.x / this.context.domWidth;
        i >= this.normalizedSwipeThresholdX ? (this._didSwipe = !0, this.selectPrev()) : i <= -this.normalizedSwipeThresholdX && (this._didSwipe = !0, this.selectNext());
      }
    }
  };
  onInputPointerUp = (e) => {
    e.button === 0 && (this._didSwipe = !1);
  };
  onInputKeyDown = (e) => {
    if (!this.useKeyboard || !this.scenes) return;
    const t = e.key.toLowerCase();
    if (!t) return;
    const i = parseInt(t) - 1;
    if (i >= 0) {
      this.trySelectSceneFromValue(i);
      return;
    }
    switch (t) {
      case "arrowright":
      case "d":
        this.selectNext();
        break;
      case "arrowleft":
      case "a":
        this.selectPrev();
        break;
    }
  };
  /**
   * Add a scene to the SceneSwitcher.     
   * If the scene is already added it will be added again.
   * @param urlOrAssetReference The url of the scene or an AssetReference to the scene  
   * @returns The AssetReference of the scene that was added
   * @example
   * ```ts
   * // adding a scene:
   * sceneSwitcher.addScene("scene1.glb");
   * // add another scene and load it:
   * const scene2 = sceneSwitcher.addScene("scene2.glb");
   * sceneSwitcher.switchScene(scene2).then(res => { console.log("Scene loaded", res); });
   * ```
   */
  addScene(e) {
    if (typeof e == "string") {
      let t = this.context.addressables.findAssetReference(e);
      return t || (t = new ie(e), this.context.addressables.registerAssetReference(t)), this.scenes.push(t), t;
    }
    return this.scenes.push(e), e;
  }
  /**
   * Load the next scene in the scenes array ({@link this.currentIndex} + 1)  
   * If the current scene is the last scene in the array and {@link this.clamp} is disabled then the first scene will be loaded.
   * @returns a promise that resolves to true if the scene was loaded successfully    
   */
  selectNext() {
    return this.select(this._currentIndex + 1);
  }
  /**
   * Load the previous scene in the scenes array ({@link this.currentIndex} - 1)  
   * If the current scene is the first scene in the array and {@link this.clamp} is disabled then the last scene will be loaded.
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  selectPrev() {
    return this.select(this._currentIndex - 1);
  }
  /**
   * Load a scene by its index in the scenes array.
   * @param index The index of the scene or a string that represents the scene uri (if the url is not known to the SceneSwitcher it will try to load the scene by its uri but it won't be added to the current scenes array. Use {@link addScene} to add a scene to the SceneSwitcher)  
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  select(e) {
    if (Tt && console.log("select", e), typeof e == "object" && console.warn('Switching to "' + e + '" might not work. Please either use an index or a AssetReference (not a scene reference)'), typeof e == "string") {
      const i = this.scenes?.find((n) => n.url === e);
      if (!i) {
        const n = ie.getOrCreate(this.sourceId ?? "", e, this.context);
        return this.switchScene(n);
      }
      if (i) e = this.scenes?.indexOf(i);
      else return Ws;
    }
    if (!this.scenes?.length) return Ws;
    if (e < 0) {
      if (this.clamp) return Ws;
      e = this.scenes.length - 1;
    } else if (e >= this.scenes.length) {
      if (this.clamp) return Ws;
      e = 0;
    }
    const t = this.scenes[e];
    return this.switchScene(t);
  }
  /**
   * Unload the currently loaded scene.
   */
  unload() {
    return this.__lastSwitchScene = void 0, this.__lastSwitchScenePromise = void 0, this.__unloadCurrentScene();
  }
  /**
   * Reload the last scene that was loaded
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  async reload() {
    if (this.__lastSwitchScene) {
      const e = this.__lastSwitchScene;
      return this.__lastSwitchScene = void 0, this.switchScene(e);
    }
    return !1;
  }
  // this is the scene that was requested last
  __lastSwitchScene;
  __lastSwitchScenePromise;
  /**
   * Switch to a scene by its AssetReference.  
   * If the scene is already loaded it will be unloaded and the new scene will be loaded.  
   * If the scene is already loading it will wait for the scene to be loaded.  
   * If the scene is already loaded and the same scene is requested again it will return the same promise that was returned the first time the scene was requested.  
   * @param scene The AssetReference of the scene to switch to
   * @returns a promise that resolves to true if the scene was loaded successfully
   * @example
   * ```ts
   * const myAssetReference = new AssetReference("scene1.glb");
   * sceneSwitcher.switchScene(myAssetReference).then(res => { console.log("Scene loaded", res); });
   * ```
   */
  async switchScene(e) {
    if (!(e instanceof ie)) {
      const i = typeof e;
      if (i === "string")
        return this.select(e);
      if (i === "number")
        return this.select(e);
      if (e && e instanceof M) {
        const n = this.scenes?.indexOf(e);
        e = new ie(e.name, void 0, e), n >= 0 && (this.scenes[n] = e);
      } else
        return console.warn(`[SceneSwitcher] Can't switch to scene of type ${i}`), !1;
    }
    return e.url === this.sourceId ? (console.warn("[SceneSwitcher] Can't load own scene - prevent recursive loading", this.sourceId), !1) : this.__lastSwitchScene === e && this.__lastSwitchScenePromise ? this.__lastSwitchScenePromise : (this.__lastSwitchScene = e, this.__lastSwitchScenePromise = this.__internalSwitchScene(e), await this.__lastSwitchScenePromise);
  }
  async __unloadCurrentScene() {
    const e = this._currentScene;
    if (this._currentScene = void 0, e) {
      Tt && console.log("UNLOAD", e.url, "HasURL?: " + e.hasUrl);
      const t = this.tryGetSceneEventListener(e.asset);
      if (t?.sceneClosing) {
        const i = t.sceneClosing();
        i instanceof Promise && await i;
      }
      e.hasUrl ? e.unload() : e.asset instanceof M && S.remove(e.asset);
    }
  }
  _currentlyLoadingScene;
  /** @internal */
  async __internalSwitchScene(e) {
    await this.__unloadCurrentScene();
    const t = this._currentIndex = this.scenes?.indexOf(e) ?? -1;
    try {
      this._currentlyLoadingScene = e, this._currentLoadingProgress = new ProgressEvent("progress", { loaded: 0, total: 1 });
      const i = new CustomEvent("loadscene-start", { detail: { scene: e, switcher: this, index: t } });
      this.dispatchEvent(i), this.sceneLoadingStart?.invoke(i.detail), await this.onStartLoading(), await e.loadAssetAsync((o, r) => {
        if (Tt) {
          const a = r.loaded / r.total, l = "[" + "=".repeat(Math.floor(a * 20)) + "-".repeat(20 - Math.floor(a * 20)) + "]";
          console.debug(`[SceneSwitcher] Download ${(a * 100).toFixed(1)} % ${l}`, e.url);
        }
        this._currentLoadingProgress = r, this.dispatchEvent(r), this.sceneLoadingProgress?.invoke(r);
      }).catch(console.error), await this.onEndLoading();
      const n = new CustomEvent("loadscene-finished", { detail: { scene: e, switcher: this, index: t } });
      if (this.dispatchEvent(n), this._currentLoadingProgress = void 0, this._currentlyLoadingScene = void 0, n.defaultPrevented)
        return Tt && console.warn("Adding loaded scene prevented:", e, n), !1;
      if (!e.asset)
        return Tt && console.warn("Failed loading scene:", e), !1;
      if (this._currentIndex === t) {
        if (Tt && console.log("ADD", e.url), this._currentScene = e, OE) {
          const a = this.context.mainCameraComponent?.gameObject || this.context.mainCamera;
          a?.removeFromParent();
          const l = this.gameObject.removeFromParent();
          Gi(this.context.scene, !0, !0), this.context.scene = new wi(), this.context.scene.add(l), a && this.context.scene.add(a);
        }
        if (S.add(e.asset, this.gameObject), this.useSceneLighting && this.context.sceneLighting.enable(e), this.useSceneBackground) {
          const a = this.context.lightmaps.tryGetSkybox(e.url);
          a ? (a.mapping = _s, this.context.scene.background = a) : Tt && console.warn("SceneSwitcher: Can't find skybox for scene " + e.url);
        }
        if (this.useHistory && t >= 0) {
          let a = t.toString();
          if (this.useSceneName && (e instanceof M ? a = e.name : e.url && (a = rb(e.url))), this.queryParameterName?.length)
            rd(this.queryParameterName, a, this.useHistory);
          else {
            const l = history.state, c = this.guid + "::" + t;
            l !== c && history.pushState(c, "unused", location.href);
          }
        }
        const o = this.tryGetSceneEventListener(e.asset);
        if (o?.sceneOpened) {
          const a = o.sceneOpened(this);
          a instanceof Promise && await a;
        }
        const r = new CustomEvent("scene-opened", { detail: { scene: e, switcher: this, index: t } });
        return this.dispatchEvent(r), this.sceneLoaded?.invoke(this), !0;
      }
    } catch (i) {
      console.error(i);
    }
    return !1;
  }
  preload(e) {
    if (e >= 0 && e < this.scenes.length) {
      const t = this.scenes[e];
      if (t instanceof ie)
        return t.preload();
    }
    return Ws;
  }
  tryLoadFromQueryParam() {
    if (!this.queryParameterName?.length) return Ws;
    const e = w(this.queryParameterName);
    return typeof e == "boolean" ? Ws : this.trySelectSceneFromValue(e);
  }
  /** try to select a scene from a string or index */
  trySelectSceneFromValue(e) {
    if (typeof e == "string") {
      const t = parseInt(e);
      if (t >= 0 && t < this.scenes.length)
        return this.select(t);
      {
        const i = e.toLowerCase();
        for (let n = 0; n < this.scenes.length; n++) {
          const o = this.scenes[n];
          if (!o) continue;
          if ((o instanceof M ? o.name : rb(o.url)).toLowerCase().includes(i))
            return this.select(n);
        }
      }
    } else if (typeof e == "number" && e >= 0 && e < this.scenes.length)
      return this.select(e);
    return hn() && console.warn('Can not find scene: "' + e + '"', this), Ws;
  }
  _lastLoadingScene = void 0;
  _loadingScenePromise = void 0;
  _isCurrentlyLoading = !1;
  _currentLoadingProgress = void 0;
  async onStartLoading() {
    if (this._isCurrentlyLoading = !0, this.loadingScene && (this._lastLoadingScene !== this.loadingScene && (this._loadingScenePromise = void 0), this._lastLoadingScene = this.loadingScene, this._loadingScenePromise || (this._loadingScenePromise = this.loadingScene?.loadAssetAsync().then((e) => e != null)), await this._loadingScenePromise, this._isCurrentlyLoading && this.loadingScene?.asset)) {
      Tt && console.log("Add loading scene", this.loadingScene.url, this.loadingScene.asset);
      const e = this.loadingScene.asset;
      S.add(e, this.gameObject);
      const t = this.tryGetSceneEventListener(e);
      if (t?.sceneOpened) {
        const i = t.sceneOpened(this);
        i instanceof Promise && await i;
      }
    }
    if (this._isCurrentlyLoading) {
      const e = this.tryGetSceneEventListener(this.gameObject);
      if (e && e.sceneOpened) {
        const t = e.sceneOpened(this);
        t instanceof Promise && await t;
      }
    }
  }
  async onEndLoading() {
    if (this._isCurrentlyLoading = !1, this.loadingScene?.asset) {
      Tt && console.log("Remove loading scene", this.loadingScene.url);
      const e = this.loadingScene.asset, t = this.tryGetSceneEventListener(e);
      if (typeof t?.sceneClosing == "function") {
        const i = t.sceneClosing();
        i instanceof Promise && await i;
      }
      S.remove(e);
    }
    if (!this._isCurrentlyLoading) {
      const e = this.tryGetSceneEventListener(this.gameObject);
      if (e && e.sceneClosing) {
        const t = e.sceneClosing();
        t instanceof Promise && await t;
      }
    }
  }
  tryGetSceneEventListener(e, t = 0) {
    if (!e)
      return null;
    const i = S.foreachComponent(e, (n) => {
      const o = n;
      if (o.sceneClosing || o.sceneOpened) return o;
    });
    if (t === 0 && !i && e.children.length)
      for (const n of e.children) {
        const o = this.tryGetSceneEventListener(n, t + 1);
        if (o) return o;
      }
    return i || null;
  }
}
bt([
  u()
], Ze.prototype, "autoLoadFirstScene");
bt([
  u(ie)
], Ze.prototype, "scenes");
bt([
  u(ie)
], Ze.prototype, "loadingScene");
bt([
  u()
], Ze.prototype, "queryParameterName");
bt([
  u()
], Ze.prototype, "useSceneName");
bt([
  u()
], Ze.prototype, "clamp");
bt([
  u()
], Ze.prototype, "useHistory");
bt([
  u()
], Ze.prototype, "useKeyboard");
bt([
  u()
], Ze.prototype, "useSwipe");
bt([
  u()
], Ze.prototype, "useSceneLighting");
bt([
  u()
], Ze.prototype, "useSceneBackground");
bt([
  u()
], Ze.prototype, "preloadNext");
bt([
  u()
], Ze.prototype, "preloadPrevious");
bt([
  u()
], Ze.prototype, "preloadConcurrent");
bt([
  u()
], Ze.prototype, "createMenuButtons");
bt([
  u(ce)
], Ze.prototype, "sceneLoadingStart");
bt([
  u(ce)
], Ze.prototype, "sceneLoadingProgress");
bt([
  u(ce)
], Ze.prototype, "sceneLoaded");
function rb(s) {
  const t = s.split("/").pop()?.split(".").shift();
  return t?.length ? t : s;
}
class kE {
  /** Maximum number of scenes to preload ahead of the current scene */
  maxLoadAhead;
  /** Maximum number of scenes to preload behind the current scene */
  maxLoadBehind;
  /** Maximum number of scenes that can be preloaded concurrently */
  maxConcurrent;
  _isRunning = !1;
  _switcher;
  _loadTasks = [];
  _maxConcurrentLoads = 1;
  /**
   * Creates a new PreLoadScheduler instance
   * @param rooms The SceneSwitcher that this scheduler belongs to
   * @param ahead Number of scenes to preload ahead of current scene
   * @param behind Number of scenes to preload behind current scene
   * @param maxConcurrent Maximum number of concurrent preloads allowed
   */
  constructor(e, t = 1, i = 1, n = 2) {
    this._switcher = e, this.maxLoadAhead = t, this.maxLoadBehind = i, this.maxConcurrent = n;
  }
  /**
   * Starts the preloading process after a specified delay
   * @param delay Time in milliseconds to wait before starting preload
   */
  begin(e) {
    if (this._isRunning) return;
    Tt && console.log("Preload begin", { delay: e }), this._isRunning = !0;
    let t = -10, i, n;
    const o = this._switcher.scenes, r = Date.now() + e, a = setInterval(() => {
      if (this.allLoaded() && (Tt && console.log("All scenes (pre-)loaded"), this.stop()), !this._isRunning) {
        clearInterval(a);
        return;
      }
      if (Date.now() < r || this.canLoadNewScene() === !1) return;
      (t === -10 || t !== this._switcher.currentIndex) && (t = this._switcher.currentIndex, n = 0, i = 0);
      const l = n % 2 === 0;
      l && (i += 1), n += 1;
      const c = l ? this.maxLoadAhead : this.maxLoadBehind;
      if (i > c) return;
      const h = l ? t + i : t - i;
      if (!(h < 0) && !(h < 0 || h >= o.length) && !this._loadTasks.some((d) => d.index === h)) {
        const d = o[h];
        Tt && console.log("Preload scene", { roomIndex: h, searchForward: l, lastRoom: t, currentIndex: this._switcher.currentIndex, tasks: this._loadTasks.length }, d?.url), new ME(h, d, this._loadTasks);
      }
    }, 200);
  }
  /**
   * Stops the preloading process
   */
  stop() {
    this._isRunning = !1;
  }
  /**
   * Checks if a new scene can be loaded based on current load limits
   * @returns True if a new scene can be loaded, false otherwise
   */
  canLoadNewScene() {
    return this._loadTasks.length < this._maxConcurrentLoads;
  }
  /**
   * Checks if all scenes in the SceneSwitcher have been loaded
   * @returns True if all scenes are loaded, false otherwise
   */
  allLoaded() {
    if (this._switcher.scenes) {
      for (const e of this._switcher.scenes)
        if (e?.isLoaded && e.isLoaded() === !1)
          return !1;
    }
    return !0;
  }
}
class ME {
  /** The index of the scene in the scenes array */
  index;
  /** The AssetReference to be loaded */
  asset;
  /** The collection of active load tasks this task belongs to */
  tasks;
  /**
   * Creates a new LoadTask and begins loading immediately
   * @param index The index of the scene in the scenes array
   * @param asset The AssetReference to preload
   * @param tasks The collection of active load tasks
   */
  constructor(e, t, i) {
    this.index = e, this.asset = t, this.tasks = i, i.push(this), this.awaitLoading();
  }
  /**
   * Asynchronously loads the asset and removes this task from the active tasks list when complete
   */
  async awaitLoading() {
    this.asset && !this.asset.isLoaded() && (Tt && console.log("Preload start: " + this.asset.url, this.index), await this.asset.preload(), Tt && console.log("Preload finished: " + this.asset.url, this.index));
    const e = this.tasks.indexOf(this);
    e >= 0 && this.tasks.splice(e, 1);
  }
}
function RE() {
  return new Promise((s, e) => {
    const i = () => {
      i != null && (document.removeEventListener("pointerdown", i), document.removeEventListener("click", i), document.removeEventListener("dragstart", i), document.removeEventListener("touchstart", i), s());
    };
    document.addEventListener("pointerdown", i), document.addEventListener("click", i), document.addEventListener("dragstart", i), document.addEventListener("touchstart", i);
  });
}
async function TE(s) {
  await RE(), s();
}
var EE = Object.defineProperty, AE = Object.getOwnPropertyDescriptor, Ri = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? AE(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && EE(e, t, n), n;
};
const ht = w("debugvideo");
var Mw = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.AdjustHeight = 1] = "AdjustHeight", s[s.AdjustWidth = 2] = "AdjustWidth", s))(Mw || {}), Rw = /* @__PURE__ */ ((s) => (s[s.VideoClip = 0] = "VideoClip", s[s.Url = 1] = "Url", s))(Rw || {}), Tw = /* @__PURE__ */ ((s) => (s[s.CameraFarPlane = 0] = "CameraFarPlane", s[s.CameraNearPlane = 1] = "CameraNearPlane", s[s.RenderTexture = 2] = "RenderTexture", s[s.MaterialOverride = 3] = "MaterialOverride", s))(Tw || {});
class mt extends R {
  playOnAwake = !0;
  aspectMode = 0;
  clip = null;
  source = 1;
  get url() {
    return this._url;
  }
  /**
   * The video clip to play. 
   */
  set url(e) {
    const i = this._url !== e;
    this.__didAwake ? i && this.setClipURL(e ?? "") : this._url = e;
  }
  _url = null;
  renderMode;
  targetMaterialProperty;
  targetMaterialRenderer;
  targetTexture;
  time = 0;
  _playbackSpeed = 1;
  get playbackSpeed() {
    return this._videoElement?.playbackRate ?? this._playbackSpeed;
  }
  /**
   * Set the video playback speed. Increasing this value will speed up the video, decreasing it will slow it down.
   */
  set playbackSpeed(e) {
    this._playbackSpeed = e, this._videoElement && (this._videoElement.playbackRate = e);
  }
  _isLooping = !1;
  get isLooping() {
    return this._videoElement?.loop ?? this._isLooping;
  }
  set isLooping(e) {
    this._isLooping = e, this._videoElement && (this._videoElement.loop = e);
  }
  /**
   * @returns the current time of the video in seconds
   */
  get currentTime() {
    return this._videoElement?.currentTime ?? this.time;
  }
  /**
   * set the current time of the video in seconds
   */
  set currentTime(e) {
    this._videoElement ? this._videoElement.currentTime = e : this.time = e;
  }
  /**
   * @returns true if the video is currently playing
   */
  get isPlaying() {
    const e = this._videoElement;
    if (e) {
      if (e.currentTime > 0 && !e.paused && !e.ended && e.readyState > e.HAVE_CURRENT_DATA)
        return !0;
      if (e.srcObject && e.srcObject.active)
        return !0;
    }
    return !1;
  }
  get crossOrigin() {
    return this._videoElement?.crossOrigin ?? this._crossOrigin;
  }
  set crossOrigin(e) {
    this._crossOrigin = e, this._videoElement && (e !== null ? this._videoElement.setAttribute("crossorigin", e) : this._videoElement.removeAttribute("crossorigin"));
  }
  /**
   * the material that is used to render the video
   */
  get videoMaterial() {
    return !this._videoMaterial && !this.create(!1) ? null : this._videoMaterial;
  }
  /**
   * the video texture that is used to render the video
   */
  get videoTexture() {
    return !this._videoTexture && !this.create(!1) ? null : this._videoTexture;
  }
  /**
   * the HTMLVideoElement that is used to play the video
   */
  get videoElement() {
    return !this._videoElement && !this.create(!1) ? null : this._videoElement;
  }
  /**
   * Request the browser to enter picture in picture mode
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Picture-in-Picture_API
   * @returns the promise returned by the browser
   */
  requestPictureInPicture() {
    return this._videoElement ? this._videoElement.requestPictureInPicture() : null;
  }
  /**
   * @returns true if the video is muted
   */
  get muted() {
    return this._videoElement?.muted ?? this._muted;
  }
  /**
   * set the video to be muted
   */
  set muted(e) {
    this._muted = e, this._videoElement && (this._videoElement.muted = e);
  }
  _muted = !1;
  /**
   * The current video clip that is being played
   */
  get currentVideo() {
    return this.clip;
  }
  set audioOutputMode(e) {
    e !== this._audioOutputMode && (e === 1 && L() && console.warn("VideoAudioOutputMode.AudioSource is not yet implemented"), this._audioOutputMode = e, this.updateVideoElementSettings());
  }
  get audioOutputMode() {
    return this._audioOutputMode;
  }
  _audioOutputMode = 2;
  /** Set this to false to pause video playback while the tab is not active 
   * @default true
  */
  playInBackground = !0;
  _crossOrigin = "anonymous";
  _videoElement = null;
  _videoTexture = null;
  _videoMaterial = null;
  _isPlaying = !1;
  wasPlaying = !1;
  /** ensure's the video element has been created and will start loading the clip */
  preloadVideo() {
    ht && console.log("Video Preload: " + this.name, this.clip), this.create(!1);
  }
  /** @deprecated use `preloadVideo()` */
  preload() {
    this.preloadVideo();
  }
  /** Set a new video stream  
   * starts to play automatically if the videoplayer hasnt been active before and playOnAwake is true */
  setVideo(e) {
    this.clip = e, this.source = 0, this._videoElement ? (this._videoElement.srcObject = e, this._isPlaying && this.play(), this.updateAspect()) : this.create(this.playOnAwake);
  }
  setClipURL(e) {
    this._url !== e && (this._url = e, this.source = 1, ht && console.log("set url", e), this._videoElement ? e.endsWith(".m3u8") || e.includes(".m3u") ? this.ensureM3UCanBePlayed() : (this._videoElement.src = e, this._isPlaying && (this.stop(), this.play())) : this.create(this.playOnAwake));
  }
  /** @internal */
  onEnable() {
    ht && console.log("VideoPlayer.onEnable", Rw[this.source], this.clip, this.url, this), window.addEventListener("visibilitychange", this.visibilityChanged), this.playOnAwake === !0 ? this.create(!0) : this.preloadVideo(), this.screenspace ? this._overlay?.start() : this._overlay?.stop();
  }
  /** @internal */
  onDisable() {
    window.removeEventListener("visibilitychange", this.visibilityChanged), this._overlay?.stop(), this.pause();
  }
  visibilityChanged = (e) => {
    switch (document.visibilityState) {
      case "hidden":
        this.playInBackground || (this.wasPlaying = this._isPlaying, this.pause());
        break;
      case "visible":
        this.wasPlaying && !this._isPlaying && this.play();
        break;
    }
  };
  /** @internal */
  onDestroy() {
    this._videoElement && (this.videoElement?.remove(), this._videoElement = null), this._videoTexture && (this._videoTexture.dispose(), this._videoTexture = null);
  }
  _receivedInput = !1;
  /**
   * @internal
   */
  constructor() {
    super(), TE(() => {
      this._receivedInput = !0, this.updateVideoElementSettings();
    }), this._targetObjects = [], w("videoscreenspace") && window.addEventListener("keydown", (e) => {
      e.key === "f" && (this.screenspace = !this.screenspace);
    });
  }
  /** start playing the video source */
  play() {
    if (this._videoElement || this.create(!1), !this._videoElement) {
      ht && console.warn("Can not play: no video element found", this);
      return;
    }
    if (!(this._isPlaying && !this._videoElement?.ended && !this._videoElement?.paused)) {
      if (this._isPlaying = !0, this._receivedInput || (this._videoElement.muted = !0), this.handleBeginPlaying(!1), this.shouldUseM3U) {
        this.ensureM3UCanBePlayed();
        return;
      }
      ht && console.log("Video Play()", this.clip, this._videoElement, this.time), this._videoElement.currentTime = this.time, this._videoElement.play().catch((e) => {
        console.log(e), ht && console.error("Error playing video", e, "CODE=" + e.code, this.videoElement?.src, this), setTimeout(() => {
          this._isPlaying && !this.destroyed && this.activeAndEnabled && this.play();
        }, 1e3);
      }), ht && console.log("play", this._videoElement, this.time);
    }
  }
  /**
   * Stop the video playback. This will reset the video to the beginning
   */
  stop() {
    this._isPlaying = !1, this.time = 0, this._videoElement && (this._videoElement.currentTime = 0, this._videoElement.pause(), ht && console.log("STOP", this));
  }
  /**
   * Pause the video playback
   */
  pause() {
    this.time = this._videoElement?.currentTime ?? 0, this._isPlaying = !1, this._videoElement?.pause(), ht && console.log("PAUSE", this, this.currentTime);
  }
  /** create the video element and assign the video source url or stream */
  create(e) {
    let t;
    switch (this.source) {
      case 0:
        t = this.clip;
        break;
      case 1:
        t = this.url, !t?.length && typeof this.clip == "string" && (t = this.clip);
        break;
    }
    return t ? (this._videoElement || (ht && console.warn("Create VideoElement", this), this._videoElement = this.createVideoElement(), this.context.domElement.shadowRoot.prepend(this._videoElement), this.updateVideoElementStyles()), typeof t == "string" ? (ht && console.log("Set Video src", t), this._videoElement.src = t) : (ht && console.log("Set Video srcObject", t), this._videoElement.srcObject = t), this._videoTexture || (this._videoTexture = new uS(this._videoElement)), this._videoTexture.flipY = !1, this._videoTexture.colorSpace = Cs, e && this.handleBeginPlaying(e), ht && console.log("Video: handle playing done...", t, e), !0) : (ht && console.warn("No video source set", this), !1);
  }
  updateAspect() {
    this.aspectMode !== 0 && this.startCoroutine(this.updateAspectImpl());
  }
  _overlay = null;
  /**
   * If true the video will be rendered in screenspace mode and overlayed on top of the scene.
   * Alternatively you can also request the video to be played in PictureInPicture mode by calling `requestPictureInPicture()`
   */
  get screenspace() {
    return this._overlay?.enabled ?? !1;
  }
  set screenspace(e) {
    if (e) {
      if (!this._videoTexture) return;
      this._overlay || (this._overlay = new IE(this.context)), this._overlay.add(this._videoTexture);
    } else this._overlay?.remove(this._videoTexture);
    this._overlay && (this._overlay.enabled = e);
  }
  _targetObjects;
  createVideoElement() {
    const e = document.createElement("video");
    return this._crossOrigin && e.setAttribute("crossorigin", this._crossOrigin), ht && console.log("created video element", e), e;
  }
  handleBeginPlaying(e) {
    if (!this.activeAndEnabled || !this._videoElement) return;
    this._targetObjects.length = 0;
    let t = this.gameObject;
    switch (this.renderMode) {
      case 3:
        t = this.targetMaterialRenderer?.gameObject, t || (t = S.getComponent(this.gameObject, Qi)?.gameObject);
        break;
      case 2:
        console.error("VideoPlayer renderTexture not implemented yet. Please use material override instead");
        return;
    }
    if (!t) {
      console.error("Missing target for video material renderer", this.name, Tw[this.renderMode], this);
      return;
    }
    const i = t.material;
    if (i) {
      this._targetObjects.push(t), i !== this._videoMaterial && (this._videoMaterial = i.clone(), t.material = this._videoMaterial);
      const n = "map", o = this._videoMaterial;
      if (!this.targetMaterialProperty)
        o[n] = this._videoTexture;
      else
        switch (this.targetMaterialProperty) {
          default:
            o[n] = this._videoTexture;
            break;
        }
    } else {
      console.warn("Can not play video, no material found, this might be a multimaterial case which is not supported yet");
      return;
    }
    this.updateVideoElementSettings(), this.updateVideoElementStyles(), e && (this.shouldUseM3U && this.ensureM3UCanBePlayed(), this.play());
  }
  updateVideoElementSettings() {
    if (!this._videoElement) return;
    this._videoElement.loop = this._isLooping, this._videoElement.currentTime = this.currentTime, this._videoElement.playbackRate = this._playbackSpeed, this._videoElement.playsInline = !0;
    let e = !this._receivedInput || this.audioOutputMode === 0;
    !e && this._muted && (e = !0), this._videoElement.muted = e, this.playOnAwake && (this._videoElement.autoplay = !0);
  }
  updateVideoElementStyles() {
    this._videoElement && (this._videoElement.style.userSelect = "none", this._videoElement.style.visibility = "hidden", this._videoElement.style.display = "none", this.updateAspect());
  }
  _updateAspectRoutineId = -1;
  *updateAspectImpl() {
    const e = ++this._updateAspectRoutineId, t = void 0, i = this.clip;
    for (; e === this._updateAspectRoutineId && this.aspectMode !== 0 && this.clip && i === this.clip && this._isPlaying; ) {
      if (!i || typeof i == "string")
        return;
      let n;
      for (const o of i.getVideoTracks()) {
        const r = o.getSettings();
        if (r && r.width && r.height) {
          n = r.width / r.height;
          break;
        } else
          n = this.context.renderer.domElement.clientWidth / this.context.renderer.domElement.clientHeight;
      }
      if (n === void 0) {
        for (let o = 0; o < 10; o++)
          yield;
        if (!this.isPlaying) break;
        continue;
      }
      if (t === n) {
        yield;
        continue;
      }
      for (const o of this._targetObjects) {
        let r = 1;
        if (o.parent) {
          const a = Qe(o.parent);
          r = a.x / a.y;
        }
        switch (this.aspectMode) {
          case 1:
            o.scale.y = 1 / n * o.scale.x * r;
            break;
          case 2:
            o.scale.x = n * o.scale.y * r;
            break;
        }
      }
      for (let o = 0; o < 3; o++)
        yield;
    }
  }
  get shouldUseM3U() {
    return this.url != null && (this.url.endsWith(".m3u8") || this.url.endsWith(".m3u")) && this.source === 1;
  }
  ensureM3UCanBePlayed() {
    if (!this.shouldUseM3U) return;
    let e = document.head.querySelector("script[data-hls_library]");
    e ? globalThis.Hls ? this.onHlsAvailable() : e.addEventListener("load", this.onHlsAvailable) : (ht && console.log("HLS: load script"), e = document.createElement("script"), e.dataset.hls_library = "hls.js", e.src = "https://cdn.jsdelivr.net/npm/hls.js@1", e.addEventListener("load", this.onHlsAvailable), document.head.append(e));
  }
  _hls;
  onHlsAvailable = () => {
    ht && console.log("HLS: available", this.clip), !(!this.shouldUseM3U || !this.url) && (this._hls || (this._hls = new Hls()), this.videoElement.autoplay = !0, this._hls.loadSource(this.url), this._hls.attachMedia(this.videoElement), this._videoElement?.play(), ht && console.log("HLS: loaded", this.clip));
  };
}
Ri([
  u()
], mt.prototype, "playOnAwake", 2);
Ri([
  u()
], mt.prototype, "aspectMode", 2);
Ri([
  u(URL)
], mt.prototype, "clip", 2);
Ri([
  u()
], mt.prototype, "source", 2);
Ri([
  u(URL)
], mt.prototype, "url", 1);
Ri([
  u()
], mt.prototype, "renderMode", 2);
Ri([
  u()
], mt.prototype, "targetMaterialProperty", 2);
Ri([
  u(Qi)
], mt.prototype, "targetMaterialRenderer", 2);
Ri([
  u(Te)
], mt.prototype, "targetTexture", 2);
Ri([
  u()
], mt.prototype, "time", 2);
Ri([
  u()
], mt.prototype, "playbackSpeed", 1);
Ri([
  u()
], mt.prototype, "isLooping", 1);
Ri([
  u()
], mt.prototype, "audioOutputMode", 1);
class IE {
  context;
  constructor(e) {
    this.context = e, this._input = new LE(this);
  }
  get enabled() {
    return this._isInScreenspaceMode;
  }
  set enabled(e) {
    e ? this.start() : this.stop();
  }
  add(e) {
    this._videos.indexOf(e) === -1 && this._videos.push(e);
  }
  remove(e) {
    if (!e) return;
    const t = this._videos.indexOf(e);
    t >= 0 && this._videos.splice(t, 1);
  }
  start() {
    if (this._isInScreenspaceMode || this._videos.length < 0) return;
    const e = this._videos[this._videos.length - 1];
    if (!e) return;
    if (this._isInScreenspaceMode = !0, !this._screenspaceModeQuad) {
      if (this._screenspaceModeQuad = La.createPrimitive(xa.Quad, {
        material: new DE(e)
      }), !this._screenspaceModeQuad) return;
      this._screenspaceModeQuad.geometry.scale(2, 2, 2);
    }
    const t = this._screenspaceModeQuad;
    this.context.scene.add(t), this.updateScreenspaceMaterialUniforms();
    const i = t.material;
    i?.reset(), this._input?.enable(i);
  }
  stop() {
    this._isInScreenspaceMode = !1, this._screenspaceModeQuad && (this._input?.disable(), this._screenspaceModeQuad.removeFromParent());
  }
  updateScreenspaceMaterialUniforms() {
    const e = this._screenspaceModeQuad?.material;
    e && (e.screenAspect = this.context.domElement.clientWidth / this.context.domElement.clientHeight);
  }
  _videos = [];
  _screenspaceModeQuad;
  _isInScreenspaceMode = !1;
  _input;
}
class LE {
  _onResizeScreenFn;
  _onKeyUpFn;
  _onMouseWheelFn;
  context;
  overlay;
  constructor(e) {
    this.overlay = e, this.context = e.context;
  }
  _material;
  enable(e) {
    this._material = e, window.addEventListener("resize", this._onResizeScreenFn = () => {
      this.overlay.updateScreenspaceMaterialUniforms();
    }), window.addEventListener("keyup", this._onKeyUpFn = (n) => {
      n.key === "Escape" && this.overlay.stop();
    }), window.addEventListener("wheel", this._onMouseWheelFn = (n) => {
      this.overlay.enabled && (e.zoom += n.deltaY * 5e-4, n.preventDefault());
    }, { passive: !1 });
    const t = new J();
    window.addEventListener("mousemove", (n) => {
      if (this.overlay.enabled && this.context.input.getPointerPressed(0)) {
        const o = new J(n.movementX, n.movementY);
        o.x /= this.context.domElement.clientWidth, o.y /= this.context.domElement.clientHeight, t.set(o.x, o.y), t.multiplyScalar(e.zoom / -this.context.time.deltaTime * 0.01), e.offset = e.offset.add(t);
      }
    }), window.addEventListener("pointermove", (n) => {
      this.overlay.enabled && this.context.input.getPointerPressed(0) && this.context.input.getTouchesPressedCount() === 1 && (t.set(n.movementX, n.movementY), t.multiplyScalar(e.zoom * -this.context.time.deltaTime * 0.05), e.offset = e.offset.add(t));
    });
    let i = 0;
    window.addEventListener("touchstart", (n) => {
      if (n.touches.length < 2) {
        this.context.time.time - i < 0.3 && this.overlay.stop(), i = this.context.time.time;
        return;
      }
      this._isPinching = !0, this._lastPinch = 0;
    }), window.addEventListener("touchmove", (n) => {
      if (!this._isPinching || !this._material) return;
      const o = n.touches[0], r = n.touches[1], a = o.clientX - r.clientX, l = o.clientY - r.clientY, c = Math.sqrt(a * a + l * l);
      if (this._lastPinch !== 0) {
        const h = c - this._lastPinch;
        this._material.zoom -= h * 4e-3;
      }
      this._lastPinch = c;
    }), window.addEventListener("touchend", () => {
      this._isPinching = !1;
    });
  }
  _isPinching = !1;
  _lastPinch = 0;
  disable() {
    this._onResizeScreenFn && (window.removeEventListener("resize", this._onResizeScreenFn), this._onResizeScreenFn = void 0), this._onKeyUpFn && (window.removeEventListener("keyup", this._onKeyUpFn), this._onKeyUpFn = void 0), this._onMouseWheelFn && (window.removeEventListener("wheel", this._onMouseWheelFn), this._onMouseWheelFn = void 0);
  }
}
class DE extends Ln {
  set screenAspect(e) {
    this.uniforms.screenAspect.value = e, this.needsUpdate = !0;
  }
  set offset(e) {
    const t = this.uniforms.offsetScale.value;
    t.x = e.x, t.y = e.y, this.uniforms.offsetScale.value = t, this.needsUpdate = !0;
  }
  _offset = new J();
  get offset() {
    const e = this.uniforms.offsetScale.value;
    return this._offset.set(e.x, e.y), this._offset;
  }
  set zoom(e) {
    const t = this.uniforms.offsetScale.value;
    e < 1e-3 && (e = 1e-3), t.z = e, this.needsUpdate = !0;
  }
  get zoom() {
    return this.uniforms.offsetScale.value.z;
  }
  reset() {
    this.offset = this.offset.set(0, 0), this.zoom = 1, this.needsUpdate = !0;
  }
  // maxZoom : number = 10
  constructor(e) {
    super(), this.uniforms = {
      map: { value: e },
      screenAspect: { value: 1 },
      offsetScale: { value: new fe(0, 0, 1, 1) }
    }, this.vertexShader = `
        uniform sampler2D map;
        uniform float screenAspect;
        uniform vec4 offsetScale;
        varying vec2 vUv;

        void main() {

            gl_Position = vec4( position , 1.0 );
            vUv = uv;
            vUv.y = 1. - vUv.y;

            // fit into screen
            ivec2 res = textureSize(map, 0);
            float videoAspect = float(res.x) / float(res.y);
            float aspect = videoAspect / screenAspect;
            if(aspect >= 1.0) 
            {
                vUv.y = vUv.y * aspect;
                float offset = (1. - aspect) * .5;
                vUv.y = vUv.y + offset;
            }
            else
            {
                vUv.x = vUv.x / aspect;
                float offset = (1. - 1. / aspect) * .5;
                vUv.x = vUv.x + offset;
            }

            vUv.x -= .5;
            vUv.y -= .5;

            vUv.x *= offsetScale.z;
            vUv.y *= offsetScale.z;
            vUv.x += offsetScale.x;
            vUv.y += offsetScale.y;

            vUv.x += .5;
            vUv.y += .5;
        }

        `, this.fragmentShader = `
        uniform sampler2D map;
        varying vec2 vUv;
        void main() {
            if(vUv.x < 0. || vUv.x > 1. || vUv.y < 0. || vUv.y > 1.)
                gl_FragColor = vec4(0., 0., 0., 1.);
            else
            {
                vec4 texcolor = texture2D(map, vUv);
                gl_FragColor = texcolor;
            }
        }
        `;
  }
}
var jE = Object.defineProperty, BE = Object.getOwnPropertyDescriptor, Hc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? BE(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && jE(e, t, n), n;
};
const wt = w("debugscreensharing");
var Ew = /* @__PURE__ */ ((s) => (s[s.Screen = 0] = "Screen", s[s.Camera = 1] = "Camera", s[s.Canvas = 2] = "Canvas", s[s.Microphone = 3] = "Microphone", s))(Ew || {});
class Rr extends R {
  allowStartOnClick = !0;
  /** @internal */
  onPointerEnter() {
    this.context.connection.allowEditing != !1 && this.allowStartOnClick && this.context.input.setCursor("pointer");
  }
  /** @internal */
  onPointerExit() {
    this.context.connection.allowEditing != !1 && this.allowStartOnClick && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerClick(e) {
    if (this.context.connection.allowEditing != !1 && this.allowStartOnClick && !(e && e.pointerId !== 0)) {
      if (this.isReceiving && this.videoPlayer?.isPlaying) {
        this.videoPlayer && (this.videoPlayer.screenspace = !this.videoPlayer.screenspace);
        return;
      }
      if (this.isSending) {
        this.close();
        return;
      }
      this.share();
    }
  }
  autoConnect = !1;
  set videoPlayer(e) {
    this._videoPlayer && (this.isSending || this.isReceiving) && this._videoPlayer.stop(), this._videoPlayer = e, this._videoPlayer && this._currentStream && (this.isSending || this.isReceiving) && this._videoPlayer.setVideo(this._currentStream);
  }
  get videoPlayer() {
    return this._videoPlayer;
  }
  _videoPlayer;
  _audioSource;
  /**
   * When enabled the video will be displayed in the screenspace of the VideoPlayer component.
   */
  get screenspace() {
    return this.videoPlayer?.screenspace ?? !1;
  }
  set screenspace(e) {
    this.videoPlayer && (this.videoPlayer.screenspace = e);
  }
  device = "Screen";
  deviceName;
  /**
   * Filter which device should be chosen for sharing by id or label.  
   * Assign a method to this property to manually filter the available devices.  
   */
  deviceFilter;
  /**
   * the current stream that is being shared or received  
   * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream
   */
  get currentScream() {
    return this._currentStream;
  }
  get currentMode() {
    return this._currentMode;
  }
  /**
   * @returns true if the component is currently sending a stream
   */
  get isSending() {
    return this._currentStream?.active && this._currentMode === 1;
  }
  /**
   * @returns true if the component is currently receiving a stream
   */
  get isReceiving() {
    if (this._currentMode === 2) {
      if (!this._currentStream || this._currentStream.active === !1) return !1;
      const e = this._currentStream.getTracks();
      for (const t of e)
        if (t.readyState === "live") return !0;
    }
    return !1;
  }
  get requiresVideoPlayer() {
    return this.device !== "Microphone";
  }
  _net;
  _requestOpen = !1;
  _currentStream = null;
  _currentMode = 0;
  /** @internal */
  awake() {
    typeof this.device == "number" && (this.device = Ew[this.device]), wt && console.log("Screensharing", this.name, this), Xi.registerWaitForAllowAudio(() => {
      this._videoPlayer && this._currentStream && this._currentMode === 2 && (this._videoPlayer.playInBackground = !0, this._videoPlayer.setVideo(this._currentStream));
    }), this._net = new hu(this);
  }
  /** @internal */
  onEnable() {
    this._net?.enable(), this._net?.addEventListener(ms.StreamReceived, this.onReceiveStream), this._net?.addEventListener(ms.StreamEnded, this.onCallEnded), this.context.connection.beginListen(te.JoinedRoom, this.onJoinedRoom), this.autoConnect && Os(1e3).then(() => (this.enabled && this.autoConnect && !this.isReceiving && !this.isSending && this.context.connection.isInRoom && this.share(), 0));
  }
  /** @internal */
  onDisable() {
    this._net?.removeEventListener(ms.StreamReceived, this.onReceiveStream), this._net?.removeEventListener(ms.StreamEnded, this.onCallEnded), this.context.connection.stopListen(te.JoinedRoom, this.onJoinedRoom), this._net?.disable(), this.close();
  }
  onJoinedRoom = async () => {
    await Os(1e3), this.autoConnect && !this.isSending && !this.isReceiving && this.context.connection.isInRoom && this.share();
  };
  _ensureVideoPlayer() {
    const e = new mt();
    e.aspectMode = Mw.AdjustWidth, S.addComponent(this.gameObject, e), this._videoPlayer = e;
  }
  _activeShareRequest = null;
  /** Call to begin screensharing */
  async share(e) {
    return this._activeShareRequest ? this._activeShareRequest : (this._activeShareRequest = this.internalShare(e), this._activeShareRequest.then(() => this._activeShareRequest = null));
  }
  async internalShare(e) {
    if (this.context.connection.isInRoom === !1) {
      console.warn("Can not start screensharing: requires network connection"), L() && ge("Can not start screensharing: requires network connection. Add a SyncedRoom component or join a room first.");
      return;
    }
    if (e?.device && (this.device = e.device), !this.videoPlayer && this.requiresVideoPlayer && (this._videoPlayer || (this._videoPlayer = S.getComponent(this.gameObject, mt) ?? void 0), this.videoPlayer || this._ensureVideoPlayer(), !this.videoPlayer)) {
      console.warn("Can not share video without a videoPlayer assigned");
      return;
    }
    this._requestOpen = !0;
    try {
      const t = e?.constraints ?? {
        echoCancellation: !0,
        autoGainControl: !1
      }, i = {
        video: t,
        audio: t
      }, n = i.video;
      switch (n !== void 0 && typeof n != "boolean" && (n.width || (n.width = { max: 1920 }), n.height || (n.height = { max: 1920 }), n.aspectRatio || (n.aspectRatio = { ideal: 1.7777777778 }), n.frameRate || (n.frameRate = { ideal: 24 }), n.facingMode || (n.facingMode = { ideal: "user" })), this.device) {
        // Capture a connected camera
        case "Camera":
          this.tryShareUserCamera(i, e);
          break;
        // capture any screen, will show a popup
        case "Screen":
          {
            if (!navigator.mediaDevices.getDisplayMedia) {
              console.error("No getDisplayMedia support");
              return;
            }
            const a = await navigator.mediaDevices.getDisplayMedia(i);
            this._requestOpen ? this.setStream(
              a,
              1
              /* Sending */
            ) : gs(a);
          }
          break;
        // capture the canvas meaning the threejs view
        case "Canvas":
          const r = this.context.renderer.domElement.captureStream(0);
          this.setStream(
            r,
            1
            /* Sending */
          );
          break;
        case "Microphone":
          {
            if (!navigator.mediaDevices.getUserMedia) {
              console.error("No getDisplayMedia support");
              return;
            }
            i.video = !1;
            const a = await navigator.mediaDevices.getUserMedia(i);
            this._requestOpen ? this.setStream(
              a,
              1
              /* Sending */
            ) : gs(a);
          }
          break;
        default:
          console.error("Can not start screen sharing: Unknown device type", this.device);
      }
    } catch (t) {
      if (t.name === "NotAllowedError") {
        console.log("Selection cancelled"), this._requestOpen = !1;
        return;
      }
      console.error("Error opening video", t);
    }
  }
  close() {
    this._requestOpen = !1, this._currentStream && (wt && console.warn("Close current stream / disposing resources, stream was active?", this._currentStream.active), this._net?.stopSendingStream(this._currentStream), gs(this._currentStream), this._currentMode = 0, this._currentStream = null);
  }
  setStream(e, t) {
    if (e === this._currentStream || (this.close(), !e)) return;
    this._currentStream = e, this._requestOpen = !0, this._currentMode = t;
    const i = this.device !== "Microphone", n = t === 1;
    i ? (this._videoPlayer || this._ensureVideoPlayer(), this._videoPlayer ? this._videoPlayer.setVideo(e) : console.error("No video player assigned for video stream")) : (this._audioSource || (this._audioSource = new Xi(), this._audioSource.spatialBlend = 0, this._audioSource.volume = 1, this.gameObject.addComponent(this._audioSource)), n || (wt && console.log("PLAY", e.getAudioTracks()), this._audioSource.volume = 1, this._audioSource?.play(e))), n && this._net?.startSendingStream(e), n && (this._videoPlayer && (this._videoPlayer.muted = !0), this._audioSource?.stop());
    for (const o of e.getTracks())
      o.addEventListener("ended", () => {
        wt && console.log("Track ended", o), this.close();
      }), wt && o.kind === "video" && console.log(n ? "Video →" : "Video ←", o.getSettings());
  }
  onReceiveStream = (e) => {
    e.stream?.active === !0 && this.setStream(
      e.stream,
      2
      /* Receiving */
    );
  };
  onCallEnded = (e) => {
    wt && console.log("CALL ENDED", this.isReceiving, this?.screenspace), this.isReceiving && (this.screenspace = !1);
  };
  async tryShareUserCamera(e, t) {
    const i = (await navigator.mediaDevices.enumerateDevices()).filter((o) => o.kind === "videoinput");
    wt && console.log(`Request camera. These are your kind:videoinput devices:
`, i);
    let n = !1;
    for (const o of i)
      try {
        if (!this._requestOpen) {
          wt && console.log("Camera selection cancelled");
          break;
        }
        if (o.kind !== "videoinput") {
          wt && console.log("Skipping non-video device", o);
          continue;
        }
        const r = o.deviceId;
        if (t?.deviceId != null || t?.deviceFilter != null) {
          if (t?.deviceId !== void 0 && r !== t.deviceId) {
            wt && console.log("Skipping device due to options.deviceId: " + o.label + "; " + o.deviceId);
            continue;
          }
          if (t?.deviceFilter && t.deviceFilter(o) === !1) {
            wt && console.log("Skipping device due to options.deviceFilter: " + o.label + "; " + o.deviceId);
            continue;
          }
        } else if (this.deviceFilter)
          if (this.deviceFilter(o) === !1) {
            wt && console.log("Skipping device due to ScreenShare.deviceFilter: " + o.label + "; " + o.deviceId);
            continue;
          } else wt && console.log("Selected device by filter", o);
        else if (this.deviceName) {
          const c = o.label.toLowerCase(), h = this.deviceName.toLowerCase(), d = c.includes(h), f = o.deviceId === this.deviceName;
          if (!d && !f) {
            wt && console.log("Skipping device due to ScreenShare.deviceName: " + o.label + "; " + o.deviceId);
            continue;
          } else wt && console.log("Selected device by name", o);
        }
        e.video !== !1 && ((typeof e.video > "u" || typeof e.video == "boolean") && (e.video = {}), e.video.deviceId = r), n = !0;
        const l = await navigator.mediaDevices.getUserMedia(e).catch((c) => (console.error("Failed to get user media", c), null));
        if (l === null)
          continue;
        this._requestOpen ? (this.setStream(
          l,
          1
          /* Sending */
        ), wt && console.log("Selected camera", o)) : (gs(l), wt && console.log("Camera selection cancelled"));
        break;
      } catch (r) {
        if (r.message === "Failed to allocate videosource" || r.message === "Could not start video source") {
          ge("Failed to start video: Try another camera (Code " + r.code + ")"), console.warn(r);
          continue;
        } else
          console.error("Failed to get user media", r.message, r.code, r);
      }
    !n && L() && (ge("No camera found for sharing. Please connect a camera (see console for more information)"), console.warn("No camera found for sharing. Please connect a camera", i, this.deviceName, "Using deviceFilter? " + this.deviceFilter != null, "Using options? " + t != null, "Using deviceName? " + this.deviceName != null, "Using options.deviceId? " + t?.deviceId != null, "Using options.deviceFilter? " + t?.deviceFilter != null));
  }
  // private _cameraSelectionWindow : Window | null = null;
  // private openWindowToSelectCamera(){
  // }
}
Hc([
  u()
], Rr.prototype, "allowStartOnClick", 2);
Hc([
  u()
], Rr.prototype, "autoConnect", 2);
Hc([
  u(mt)
], Rr.prototype, "videoPlayer", 1);
Hc([
  u()
], Rr.prototype, "device", 2);
Hc([
  u()
], Rr.prototype, "deviceName", 2);
var FE = Object.defineProperty, Aw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && FE(e, t, n), n;
};
class Uu extends R {
  mode = 0;
  shadowColor = new oe(0, 0, 0, 1);
  targetMesh;
  /** @internal */
  start() {
    if (this.gameObject instanceof G)
      this.gameObject instanceof G && this.gameObject.material && (this.gameObject.material = this.gameObject.material.clone(), this.targetMesh = this.gameObject, this.targetMesh.receiveShadow = !0);
    else {
      const e = La.createPrimitive(xa.Quad, {
        name: "ShadowCatcher",
        material: new ut({
          // HACK heuristic to get approx. the same colors out as with the current default ShadowCatcher material
          // not clear why this is needed; assumption is that the Renderer component does something we're not respecting here
          color: 10066329,
          roughness: 1,
          metalness: 0,
          transparent: !0
        })
      });
      e.receiveShadow = !0, e.geometry.rotateX(-Math.PI / 2), this.gameObject.add(e), this.targetMesh = e;
    }
    if (!this.targetMesh) {
      console.warn("ShadowCatcher: no mesh to apply shadow catching to. Groups are currently not supported.");
      return;
    }
    switch (this.targetMesh.layers.set(2), this.mode) {
      case 0:
        this.applyShadowMaterial();
        break;
      case 1:
        this.applyLightBlendMaterial();
        break;
      case 2:
        this.applyOccluderMaterial();
        break;
    }
  }
  // Custom blending, diffuse-only lighting blended onto the scene additively.
  // Works great for Point Lights and spot lights, 
  // doesn't work for directional lights (since they're lighting up everything else).
  // Works even better with an additional black-ish gradient to darken parts of the AR scene
  // so that lights become more visible on bright surfaces.
  applyLightBlendMaterial() {
    if (!this.targetMesh) return;
    const e = this.targetMesh.material;
    e.blending = Eb, this.applyMaterialOptions(e), e.onBeforeCompile = (t) => {
      t.fragmentShader = t.fragmentShader.replace(
        "vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;",
        `vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
            // diffuse-only lighting with overdrive to somewhat compensate
            // for the loss of indirect lighting and to make it more visible.
            vec3 direct = (reflectedLight.directDiffuse + reflectedLight.directSpecular) * 6.6;
            float max = max(direct.r, max(direct.g, direct.b));
            
            // early out - we're simply returning direct lighting and some alpha based on it so it can 
            // be blended onto the scene.
            gl_FragColor = vec4(direct, max);
            return;
            `
      );
    }, e.userData.isLightBlendMaterial = !0;
  }
  // ShadowMaterial: only does a mask; shadowed areas are fully black.
  // doesn't take light attenuation into account.
  // works great for Directional Lights.
  applyShadowMaterial() {
    if (this.targetMesh)
      if (this.targetMesh.material.type !== "ShadowMaterial") {
        const e = new Sb();
        e.color = this.shadowColor, e.opacity = this.shadowColor.alpha, this.applyMaterialOptions(e), this.targetMesh.material = e, e.userData.isShadowCatcherMaterial = !0;
      } else {
        const e = this.targetMesh.material;
        e.color = this.shadowColor, e.opacity = this.shadowColor.alpha, this.applyMaterialOptions(e), e.userData.isShadowCatcherMaterial = !0;
      }
  }
  applyOccluderMaterial() {
    if (this.targetMesh) {
      let e = this.targetMesh.material;
      if (!e) {
        const t = new we();
        this.targetMesh.material = t, e = t;
      }
      e.depthWrite = !0, e.stencilWrite = !0, e.colorWrite = !1, this.gameObject.renderOrder = -100;
    }
  }
  applyMaterialOptions(e) {
    e && (e.depthWrite = !1, e.stencilWrite = !1);
  }
}
Aw([
  u()
], Uu.prototype, "mode");
Aw([
  u(oe)
], Uu.prototype, "shadowColor");
const Lh = /* @__PURE__ */ new Map();
function zE(s, e) {
  if (Lh.has(s))
    return Lh.get(s);
  const t = new URL(s, window.location.href), i = UE(t, e);
  return Lh.set(s, i), i.finally(() => {
    Lh.delete(s);
  }), i;
}
async function UE(s, e) {
  if (!s) return Promise.resolve(null);
  const t = s.pathname, i = s.toString().toLowerCase().includes("pmrem") || s.searchParams.get("pmrem") != null, n = t.endsWith(".exr"), o = t.endsWith(".hdr"), r = t.endsWith(".ktx2");
  let a;
  if (n)
    a = new Rm();
  else if (o)
    a = new jb();
  else if (r) {
    const { ktx2Loader: d } = Mm(e);
    a = d;
  } else
    a = new lc();
  const l = s.toString();
  return await a.loadAsync(l).then((d) => {
    if (d) {
      const f = t.lastIndexOf("/");
      d.name = t.substring(f >= 0 ? f + 1 : 0), i && (d.mapping = Ab), a instanceof lc && (d.colorSpace = Cs);
    }
    return d;
  }).catch((d) => (console.warn("Failed to load texture from url:", s), null));
}
var NE = Object.defineProperty, Gc = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && NE(e, t, n), n;
};
const Jt = w("debugskybox");
Hg("background-image");
Hg("environment-image");
function ab(s, e, t, i, n) {
  if (e === "transparent" || e?.startsWith("rgb") || e?.startsWith("#"))
    return console.warn(`Needle Engine: Invalid ${n} value (${e}). Did you mean to set background-color instead?`), null;
  const o = new Gg();
  o.allowDrop = !1, o.allowNetworking = !1, o.background = t, o.environment = i, S.addComponent(s.scene, o);
  const r = (a) => {
    typeof a == "string" && (Jt && console.log(n, "CHANGED TO", a), o.setSkybox(a));
  };
  return wC(s.domElement, n, r), o.addEventListener("destroy", () => {
    Jt && console.log("Destroyed attribute remote skybox", n), xC(s.domElement, n, r);
  }), o.setSkybox(e);
}
const Ad = new Array();
ue.registerCallback(he.ContextCreationStart, (s) => {
  const e = s.context, t = e.domElement.getAttribute("background-image"), i = e.domElement.getAttribute("environment-image");
  if (t) {
    Jt && console.log("Creating RemoteSkybox to load background " + t);
    const n = ab(e, t, !0, !1, "background-image");
    n && Ad.push(n);
  }
  if (i) {
    Jt && console.log("Creating RemoteSkybox to load environment " + i);
    const n = ab(e, i, !1, !0, "environment-image");
    n && Ad.push(n);
  }
});
ue.registerCallback(he.ContextCreationStart, () => Promise.all(Ad).finally(() => {
  Ad.length = 0;
}));
const pr = class extends R {
  url;
  allowDrop = !0;
  background = !0;
  environment = !0;
  allowNetworking = !0;
  _prevUrl;
  _prevLoadedEnvironment;
  _prevEnvironment = null;
  _prevBackground = null;
  /** @internal */
  onEnable() {
    this.setSkybox(this.url), this.registerDropEvents();
  }
  /** @internal */
  onDisable() {
    this.context.scene.environment === this._prevLoadedEnvironment && (this.context.scene.environment = this._prevEnvironment, yi.backgroundShouldBeTransparent(this.context) || (this.context.scene.background = this._prevBackground), this._prevLoadedEnvironment = void 0), this.unregisterDropEvents(), this.context.mainCameraComponent?.applyClearFlags();
  }
  urlChangedSyncField() {
    this.allowNetworking && this.url && (this.isRemoteTexture(this.url) ? this.setSkybox(this.url) : Jt && console.warn(`RemoteSkybox: Not setting skybox: ${this.url} is not a remote texture. If you want to set a local texture, set allowNetworking to false.`));
  }
  /**
   * Set the skybox from a given url
   * @param url The url of the skybox image
   * @param name Define name of the file with extension if it isn't apart of the url
   * @returns Whether the skybox was successfully set
   */
  async setSkybox(e, t) {
    if (!this.activeAndEnabled || (e = $E(e, this.environment, this.background), !e)) return !1;
    if (t ??= e, this.isValidTextureType(t) || console.warn('Potentially invalid skybox URL: "' + t + '" on ' + (this.name || this.gameObject?.name || "context")), Jt && console.log("Set RemoteSkybox url: " + e), this._prevUrl === e && this._prevLoadedEnvironment)
      return this.apply(), !0;
    this._prevLoadedEnvironment?.dispose(), this._prevLoadedEnvironment = void 0, this._prevUrl = e;
    const i = await zE(e, this.context.renderer);
    return i ? !this.enabled || this.destroyed ? (Jt && console.warn("RemoteSkybox: Component is disabled or destroyed"), !1) : this._prevUrl !== e ? (Jt && console.warn("RemoteSkybox: URL changed while loading texture, aborting setSkybox"), !1) : (this.url = e, this._prevLoadedEnvironment = i, this.apply(), !0) : (Jt && console.warn("RemoteSkybox: Failed to load texture from url", e), !1);
  }
  apply() {
    const e = this._prevLoadedEnvironment;
    if (e && (e instanceof fS || e instanceof pS || e.mapping == Ab || (e.mapping = mS, e.needsUpdate = !0), !this.destroyed)) {
      if (!this.context) {
        console.warn("RemoteSkybox: Context is not available - can not apply skybox.");
        return;
      }
      this.context.scene.background !== e && (this._prevBackground = this.context.scene.background), this.context.scene.environment !== e && (this._prevEnvironment = this.context.scene.environment), Jt && console.log("Set RemoteSkybox (" + (this.environment && this.background ? "environment and background" : this.environment ? "environment" : this.background ? "background" : "none") + ")", this.url, !yi.backgroundShouldBeTransparent(this.context)), this.environment && (this.context.scene.environment = e), this.background && !yi.backgroundShouldBeTransparent(this.context) && (this.context.scene.background = e), this.context.mainCameraComponent?.backgroundBlurriness !== void 0 && (this.context.scene.backgroundBlurriness = this.context.mainCameraComponent.backgroundBlurriness);
    }
  }
  validProtocols = ["file:", "blob:", "data:"];
  validTextureTypes = [".ktx2", ".hdr", ".exr", ".jpg", ".jpeg", ".png"];
  isRemoteTexture(e) {
    return e.startsWith("http://") || e.startsWith("https://");
  }
  isValidTextureType(e) {
    for (const t of this.validTextureTypes)
      if (e.includes(t)) return !0;
    for (const t of this.validProtocols)
      if (e.startsWith(t)) return !0;
    return !1;
  }
  registerDropEvents() {
    this.unregisterDropEvents(), this.context.domElement.addEventListener("dragover", this.onDragOverEvent), this.context.domElement.addEventListener("drop", this.onDrop);
  }
  unregisterDropEvents() {
    this.context.domElement.removeEventListener("dragover", this.onDragOverEvent), this.context.domElement.removeEventListener("drop", this.onDrop);
  }
  onDragOverEvent = (e) => {
    if (this.allowDrop && e.dataTransfer)
      for (const t of e.dataTransfer.types)
        (t === "text/uri-list" || t === "Files") && e.preventDefault();
  };
  onDrop = (e) => {
    if (this.allowDrop && e.dataTransfer) {
      for (const t of e.dataTransfer.types)
        if (Jt && console.log(t), t === "text/uri-list") {
          const i = e.dataTransfer.getData(t);
          Jt && console.log(t, i);
          let n = new RegExp(/polyhaven.com\/asset_img\/.+?\/(?<name>.+)\.png/).exec(i)?.groups?.name;
          if (n || (n = new RegExp(/polyhaven\.com\/a\/(?<name>.+)/).exec(i)?.groups?.name), Jt && console.log(n), n) {
            const o = "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/" + n + "_1k.exr";
            console.log(`[Remote Skybox] Setting skybox from url: ${o}`), e.preventDefault(), this.setSkybox(o);
            break;
          } else if (this.isValidTextureType(i)) {
            console.log("[Remote Skybox] Setting skybox from url: " + i), e.preventDefault(), this.setSkybox(i);
            break;
          } else {
            console.warn(`[RemoteSkybox] Unknown url ${i}. If you want to load a skybox from a url, make sure it is a valid image url. Url must end with${this.validTextureTypes.join(", ")}.`);
            const o = new CustomEvent("dropped-unknown-url", {
              detail: {
                sender: this,
                event: e,
                url: i,
                apply: (r) => {
                  e.preventDefault(), this.setSkybox(r);
                }
              }
            });
            this.dispatchEvent(o);
          }
        } else if (t == "Files") {
          const i = e.dataTransfer.files.item(0);
          if (Jt && console.log(t, i), !i) continue;
          if (!this.isValidTextureType(i.name)) {
            console.warn(`[RemoteSkybox]: File "${i.name}" is not supported. Supported files are ${this.validTextureTypes.join(", ")}`);
            return;
          }
          e.preventDefault(), this.setSkybox(i.name);
          break;
        }
    }
  };
};
Gc([
  Yv(pr.prototype.urlChangedSyncField),
  u(URL)
], pr.prototype, "url");
Gc([
  u()
], pr.prototype, "allowDrop");
Gc([
  u()
], pr.prototype, "background");
Gc([
  u()
], pr.prototype, "environment");
Gc([
  u()
], pr.prototype, "allowNetworking");
let Gg = pr;
function $E(s, e, t) {
  if (s == null) return null;
  const i = e && !t;
  switch (s.toLowerCase()) {
    case "studio":
      return i ? "https://cdn.needle.tools/static/skybox/modelviewer-Neutral-small.pmrem4x4.ktx2?pmrem" : "https://cdn.needle.tools/static/skybox/modelviewer-Neutral.pmrem4x4.ktx2?pmrem";
    case "blurred-skybox":
      return i ? "https://cdn.needle.tools/static/skybox/blurred-skybox-small.pmrem4x4.ktx2?pmrem" : "https://cdn.needle.tools/static/skybox/blurred-skybox.pmrem4x4.ktx2?pmrem";
    case "quicklook-ar":
      return i ? "https://cdn.needle.tools/static/skybox/QuickLook-ARMode-small.pmrem4x4.ktx2?pmrem" : "https://cdn.needle.tools/static/skybox/QuickLook-ARMode.pmrem4x4.ktx2?pmrem";
    case "quicklook":
      return i ? "https://cdn.needle.tools/static/skybox/QuickLook-ObjectMode-small.pmrem4x4.ktx2?pmrem" : "https://cdn.needle.tools/static/skybox/QuickLook-ObjectMode.pmrem4x4.ktx2?pmrem";
  }
  return s;
}
var WE = Object.defineProperty, Nu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && WE(e, t, n), n;
};
const qc = class Iw extends R {
  target = null;
  followFactor = 0.1;
  rotateFactor = 0.1;
  positionAxes = Al.All;
  flipForward = !1;
  static _invertForward = new U().setFromAxisAngle(new y(0, 1, 0), Math.PI);
  _firstUpdate = !0;
  /**
   * Update the position and rotation of the GameObject to follow the target.
   */
  onBeforeRender() {
    this.updateNow(!1);
  }
  updateNow(e) {
    if (!(!this.target || this.target === this.gameObject)) {
      if (this.followFactor > 0) {
        const t = Z(this.target), i = this._firstUpdate || e ? 1 : j.clamp01(this.context.time.deltaTime * this.followFactor), n = this.worldPosition;
        this.positionAxes & Al.X && (n.x = j.lerp(n.x, t.x, i)), this.positionAxes & Al.Y && (n.y = j.lerp(n.y, t.y, i)), this.positionAxes & Al.Z && (n.z = j.lerp(n.z, t.z, i)), this.worldPosition = n;
      }
      if (this.rotateFactor > 0) {
        const t = be(this.target);
        this.flipForward && t.premultiply(Iw._invertForward);
        const i = this._firstUpdate || e ? 1 : j.clamp01(this.context.time.deltaTime * this.rotateFactor);
        this.worldQuaternion = this.worldQuaternion.slerp(t, i);
      }
      this._firstUpdate = !1;
    }
  }
};
Nu([
  u(M)
], qc.prototype, "target");
Nu([
  u()
], qc.prototype, "followFactor");
Nu([
  u()
], qc.prototype, "rotateFactor");
Nu([
  u()
], qc.prototype, "positionAxes");
let qg = qc;
var VE = Object.defineProperty, Xc = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && VE(e, t, n), n;
};
const nc = w("debugspatialtrigger"), lb = new ho(), cb = new ho();
function HE(s, e) {
  return lb.mask = s, cb.mask = e, lb.test(cb);
}
class xs extends R {
  triggerMask = 0;
  onEnter;
  onStay;
  onExit;
  /** 
   * Initializes the receiver and logs debug info if enabled
   * @internal
   */
  start() {
    nc && console.log(this.name, this.triggerMask, this);
  }
  /**
   * Checks for intersections with spatial triggers and fires appropriate events
   * Handles enter, stay, and exit events for all relevant triggers
   * @internal
   */
  update() {
    this.currentIntersected.length = 0;
    for (const e of Xg.triggers)
      HE(e.triggerMask, this.triggerMask) && e.test(this.gameObject) && this.currentIntersected.push(e);
    for (let e = this.lastIntersected.length - 1; e >= 0; e--) {
      const t = this.lastIntersected[e];
      this.currentIntersected.indexOf(t) < 0 && (this.onExitTrigger(t), this.lastIntersected.splice(e, 1));
    }
    for (const e of this.currentIntersected)
      this.lastIntersected.indexOf(e) < 0 && this.onEnterTrigger(e), this.onStayTrigger(e);
    this.lastIntersected.length = 0, this.lastIntersected.push(...this.currentIntersected);
  }
  /** Array of triggers currently intersecting with this receiver */
  currentIntersected = [];
  /** Array of triggers that intersected with this receiver in the previous frame */
  lastIntersected = [];
  /**
   * Handles trigger enter events.
   * @param trigger The spatial trigger that was entered
   */
  onEnterTrigger(e) {
    nc && console.log("ENTER TRIGGER", this.name, e.name, this, e), e.raiseOnEnterEvent(this), this.onEnter?.invoke();
  }
  /**
   * Handles trigger exit events.
   * @param trigger The spatial trigger that was exited
   */
  onExitTrigger(e) {
    nc && console.log("EXIT TRIGGER", this.name, e.name), e.raiseOnExitEvent(this), this.onExit?.invoke();
  }
  /**
   * Handles trigger stay events.
   * @param trigger The spatial trigger that the receiver is staying in
   */
  onStayTrigger(e) {
    e.raiseOnStayEvent(this), this.onStay?.invoke();
  }
}
Xc([
  u()
], xs.prototype, "triggerMask");
Xc([
  u(ce)
], xs.prototype, "onEnter");
Xc([
  u(ce)
], xs.prototype, "onStay");
Xc([
  u(ce)
], xs.prototype, "onExit");
const Lw = class td extends R {
  /** Global registry of all active spatial triggers in the scene */
  static triggers = [];
  triggerMask;
  /** Box helper component used to visualize and calculate the trigger area */
  boxHelper;
  /**
   * Initializes the trigger and logs debug info if enabled
   */
  start() {
    nc && console.log(this.name, this.triggerMask, this);
  }
  /**
   * Registers this trigger in the global registry and sets up debug visualization if enabled
   */
  onEnable() {
    td.triggers.push(this), this.boxHelper || (this.boxHelper = S.addComponent(this.gameObject, Pt), this.boxHelper?.showHelper(null, nc));
  }
  /**
   * Removes this trigger from the global registry when disabled
   */
  onDisable() {
    td.triggers.splice(td.triggers.indexOf(this), 1);
  }
  /**
   * Tests if an object is inside this trigger's box
   * @param obj The object to test against this trigger
   * @returns True if the object is inside the trigger box
   */
  test(e) {
    return this.boxHelper ? this.boxHelper.isInBox(e) ?? !1 : !1;
  }
  // private args: SpatialTriggerEventArgs = new SpatialTriggerEventArgs();
  /**
   * Raises the onEnter event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that entered this trigger
   */
  raiseOnEnterEvent(e) {
    S.foreachComponent(this.gameObject, (t) => {
      t !== e && t instanceof xs && t.onEnterTrigger(this);
    }, !1);
  }
  /**
   * Raises the onStay event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that is staying in this trigger
   */
  raiseOnStayEvent(e) {
    S.foreachComponent(this.gameObject, (t) => {
      t !== e && t instanceof xs && t.onStayTrigger(this);
    }, !1);
  }
  /**
   * Raises the onExit event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that exited this trigger
   */
  raiseOnExitEvent(e) {
    S.foreachComponent(this.gameObject, (t) => {
      t !== e && t instanceof xs && t.onExitTrigger(this);
    }, !1);
  }
};
Xc([
  u()
], Lw.prototype, "triggerMask");
let Xg = Lw;
var GE = Object.defineProperty, qE = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && GE(e, t, n), n;
};
const gi = w("debugspectator");
class Qg extends R {
  /** Reference to the Camera component on this GameObject */
  cam = null;
  useKeys = !0;
  _mode = 0;
  /** Gets the current spectator perspective mode */
  get mode() {
    return this._mode;
  }
  /** Sets the current spectator perspective mode */
  set mode(e) {
    this._mode = e;
  }
  /** Returns whether this user is currently spectating another user */
  get isSpectating() {
    return this._handler?.currentTarget !== void 0;
  }
  /**
   * Checks if this instance is spectating the user with the given ID
   * @param userId The user ID to check
   * @returns True if spectating the specified user, false otherwise
   */
  isSpectatingUser(e) {
    return this.target?.userId === e;
  }
  /**
   * Checks if the user with the specified ID is following this user
   * @param userId The user ID to check
   * @returns True if the specified user is following this user, false otherwise
   */
  isFollowedBy(e) {
    return this.followers?.includes(e);
  }
  /** List of user IDs that are currently following the user */
  get followers() {
    return this._networking.followers;
  }
  /** Stops the current spectating session */
  stopSpectating() {
    if (this.context.isInXR) {
      this.followSelf();
      return;
    }
    this.target = void 0;
  }
  /** Gets the local player's connection ID */
  get localId() {
    return this.context.connection.connectionId ?? "local";
  }
  /** 
   * Sets the player view to follow
   * @param target The PlayerView to follow, or undefined to stop spectating
   */
  set target(e) {
    if (this._handler) {
      const t = this._handler.currentTarget?.userId, i = this.context.players.getPlayerView(this.localId);
      e === void 0 || this.context.isInXR === !1 && i?.currentObject === e.currentObject ? this._handler.currentTarget !== void 0 && (this._handler.disable(), S.setActive(this.gameObject, !1), this.orbit && (this.orbit.enabled = !0), this._networking.onSpectatedObjectChanged(e, t)) : this._handler.currentTarget !== e && (this._handler.set(e), S.setActive(this.gameObject, !0), this.orbit && (this.orbit.enabled = !1), this._networking.onSpectatedObjectChanged(e, t));
    }
  }
  /** Gets the currently followed player view */
  get target() {
    return this._handler?.currentTarget;
  }
  /** Sends a network request for all users to follow this player */
  requestAllFollowMe() {
    this._networking.onRequestFollowMe();
  }
  /** Determines if the camera is spectating the local player */
  get isSpectatingSelf() {
    return this.isSpectating && this.target?.currentObject === this.context.players.getPlayerView(this.localId)?.currentObject;
  }
  // private currentViewport : Vector4 = new Vector4();
  // private currentScissor : Vector4 = new Vector4();
  // private currentScissorTest : boolean = false;
  orbit = null;
  _handler;
  eventSub_WebXRRequestStartEvent = null;
  eventSub_WebXRStartEvent = null;
  eventSub_WebXREndEvent = null;
  _debug;
  _networking;
  awake() {
    if (this._debug = new YE(this.context, this), this._networking = new JE(this.context, this), this._networking.awake(), S.setActive(this.gameObject, !1), this.cam = S.getComponent(this.gameObject, yi), !this.cam) {
      console.warn("SpectatorCamera: Spectator camera needs camera component on the same object.", this);
      return;
    }
    !this._handler && this.cam && (this._handler = new XE(this.context, this.cam, this)), this.orbit = S.getComponent(this.context.mainCamera, ye);
  }
  onDestroy() {
    this.stopSpectating(), this._handler?.destroy(), this._networking?.destroy();
  }
  /**
   * Checks if the current platform supports spectator mode
   * @returns True if the platform is supported, false otherwise
   */
  isSupportedPlatform() {
    const e = window.navigator.userAgent, t = /Windows|MacOS/.test(e), i = /Windows NT/.test(e) && /Edg/.test(e) && !/Win64/.test(e);
    return t && !i;
  }
  /**
   * Called before entering WebXR mode
   * @param _evt The WebXR event
   */
  onBeforeXR(e) {
    this.isSupportedPlatform() && S.setActive(this.gameObject, !0);
  }
  /**
   * Called when entering WebXR mode
   * @param _evt The WebXR event
   */
  onEnterXR(e) {
    this.isSupportedPlatform() && (gi && console.log(this.context.mainCamera), this.context.mainCamera && this.followSelf());
  }
  /**
   * Called when exiting WebXR mode
   * @param _evt The WebXR event
   */
  onLeaveXR(e) {
    this.context.removeCamera(this.cam), S.setActive(this.gameObject, !1), this.orbit && (this.orbit.enabled = !0), this._handler?.set(void 0), this._handler?.disable(), this.isSpectatingSelf && this.stopSpectating();
  }
  /**
   * Sets the target to follow the local player
   */
  followSelf() {
    this.target = this.context.players.getPlayerView(this.context.connection.connectionId), this.target || (this.context.players.setPlayerView(this.localId, this.context.mainCamera, tr.Headset), this.target = this.context.players.getPlayerView(this.localId)), gi && console.log("Follow self", this.target);
  }
  // TODO: only show Spectator cam for DesktopVR;
  // don't show for AR, don't show on Quest
  // TODO: properly align cameras on enter/exit VR, seems currently spectator cam breaks alignment
  /**
   * Called after the main rendering pass to render the spectator view
   */
  onAfterRender() {
    if (!this.cam) return;
    const e = this.context.renderer, t = e.xr.enabled;
    if (!e.xr.isPresenting && !this._handler?.currentTarget) return;
    this._handler?.update(this._mode);
    const i = e.getRenderTarget();
    let n = null;
    const o = e.state;
    if (!i) {
      if (!e.state.bindFramebuffer || !o.bindXRFramebuffer)
        return;
      n = e._framebuffer, o.bindXRFramebuffer(null);
    }
    this.setAvatarFlagsBeforeRender();
    const r = this.context.mainCameraComponent;
    if (r) {
      const c = r.backgroundColor;
      c && e.setClearColor(c, c.alpha), this.cam.backgroundColor = c, this.cam.clearFlags = r.clearFlags, this.cam.nearClipPlane = r.nearClipPlane, this.cam.farClipPlane = r.farClipPlane;
    } else
      e.setClearColor(new se(1, 1, 1));
    e.setRenderTarget(null), e.xr.enabled = !1;
    const a = this.cam?.threeCamera;
    this.context.updateAspect(a);
    const l = e.xr.isPresenting;
    e.xr.isPresenting = !1, e.setSize(this.context.domWidth, this.context.domHeight), e.render(this.context.scene, a), e.xr.isPresenting = l, e.xr.enabled = t, i ? e.setRenderTarget(i) : o.bindXRFramebuffer && o.bindXRFramebuffer(n), this.resetAvatarFlags();
  }
  /**
   * Updates avatar visibility flags for rendering in spectator mode
   */
  setAvatarFlagsBeforeRender() {
    const e = this._mode === 0;
    for (const t of je.instances)
      if (t.avatar && "isLocalAvatar" in t.avatar && "flags" in t.avatar) {
        let i = fs.All;
        this.isSpectatingSelf && (i = e && t.avatar.isLocalAvatar ? fs.FirstPerson : fs.ThirdPerson);
        const n = t.avatar.flags;
        if (!n) continue;
        for (const o of n)
          o.UpdateVisible(i);
      }
  }
  /**
   * Restores avatar visibility flags after spectator rendering
   */
  resetAvatarFlags() {
    for (const e of je.instances)
      if (e.avatar && "flags" in e.avatar) {
        const t = e.avatar.flags;
        if (!t) continue;
        for (const i of t)
          "isLocalAvatar" in e.avatar && e.avatar?.isLocalAvatar ? i.UpdateVisible(fs.FirstPerson) : i.UpdateVisible(fs.ThirdPerson);
      }
  }
}
qE([
  u()
], Qg.prototype, "useKeys");
class XE {
  context;
  cam;
  spectator;
  follow;
  target;
  view;
  currentObject;
  /** Gets the currently targeted player view */
  get currentTarget() {
    return this.view;
  }
  constructor(e, t, i) {
    this.context = e, this.cam = t, this.spectator = i;
  }
  /**
   * Sets the target player view to follow
   * @param view The PlayerView to follow
   */
  set(e) {
    const t = e?.currentObject;
    if (!t) {
      this.spectator.stopSpectating();
      return;
    }
    t !== this.currentObject && (this.currentObject = t, this.view = e, this.follow || (this.follow = S.addComponent(this.cam.gameObject, qg)), this.target || (this.target = new M()), t.add(this.target), this.follow.enabled = !0, this.follow.target = this.target, gi && console.log("FOLLOW", t), this.context.isInXR ? this.context.removeCamera(this.cam) : this.context.setCurrentCamera(this.cam));
  }
  /** Disables the spectator following behavior */
  disable() {
    gi && console.log("STOP FOLLOW", this.currentObject), this.view = void 0, this.currentObject = void 0, this.context.removeCamera(this.cam), this.follow && (this.follow.enabled = !1);
  }
  /** Cleans up resources used by the handler */
  destroy() {
    this.target?.removeFromParent(), this.follow && S.destroy(this.follow);
  }
  /**
   * Updates the camera position and orientation based on the spectator mode
   * @param mode The current spectator mode (first or third person)
   */
  update(e) {
    if (this.currentTarget?.isConnected === !1 || this.currentTarget?.removed === !0) {
      gi && console.log("Target disconnected or timeout", this.currentTarget), this.spectator.stopSpectating();
      return;
    }
    this.currentTarget && this.currentTarget?.currentObject !== this.currentObject && (gi && console.log("Target changed", this.currentObject, "to", this.currentTarget.currentObject), this.set(this.currentTarget));
    const t = this.context.mainCamera;
    if (t) {
      const n = this.cam.threeCamera;
      (n.near !== t.near || n.far !== t.far) && (n.near = t.near, n.far = t.far, n.updateProjectionMatrix());
    }
    const i = this.follow?.target;
    if (!(!i || !this.follow)) {
      switch (e) {
        case 0:
          this.view?.viewDevice !== tr.Browser ? (this.follow.followFactor = 5, this.follow.rotateFactor = 5) : (this.follow.followFactor = 50, this.follow.rotateFactor = 50), i.position.set(0, 0, 0);
          break;
        case 1:
          this.follow.followFactor = 3, this.follow.rotateFactor = 2, i.position.set(0, 0.5, 1.5);
          break;
      }
      this.follow.flipForward = !1, this.view?.viewDevice !== tr.Browser ? i.quaternion.copy(QE) : i.quaternion.identity();
    }
  }
}
const QE = new U().setFromAxisAngle(new y(0, 1, 0), Math.PI);
class YE {
  context;
  spectator;
  constructor(e, t) {
    this.context = e, this.spectator = t, console.log("[Spectator Camera] Click other avatars or cameras to follow them. Press ESC to exit spectator mode."), this.context.domElement.addEventListener("keydown", (n) => {
      if (!this.spectator.useKeys) return;
      n.key === "Escape" && this.spectator.stopSpectating();
    });
    let i = 0;
    this.context.input.addEventListener(De.PointerDown, (n) => {
      i = this.context.time.time;
    }), this.context.input.addEventListener(De.PointerUp, (n) => {
      const o = this.context.time.time - i;
      o > 1 ? this.spectator.stopSpectating() : this.context.input.getPointerClicked(0) && o < 0.3 && this.trySelectObject();
    });
  }
  /**
   * Attempts to select an avatar to spectate through raycasting
   */
  trySelectObject() {
    const e = new _r();
    e.setMask(16777215);
    const t = this.context.physics.raycast(e);
    if (gi && console.log(...t), t?.length)
      for (const i of t) {
        if (i.distance < 0.2) continue;
        const n = i.object, o = S.getComponentInParent(n, je), r = o?.connectionId;
        if (r) {
          const a = this.context.players.getPlayerView(r);
          this.spectator.target = a, gi && console.log("spectate", r, o);
          break;
        }
      }
  }
}
class KE {
  /** The user ID that is following */
  guid;
  dontSave = !0;
  /** The user ID being followed */
  targetUserId;
  /** Indicates if the user stopped following */
  stoppedFollowing;
  constructor(e, t, i) {
    this.guid = e, this.targetUserId = t, this.stoppedFollowing = i;
  }
}
class ZE {
  guid;
  userId;
  constructor(e, t) {
    this.guid = e.guid, this.userId = t;
  }
}
class JE {
  /** List of user IDs currently following this player */
  followers = [];
  context;
  spectator;
  _followerEventMethod;
  _requestFollowMethod;
  _joinedRoomMethod;
  constructor(e, t) {
    this.context = e, this.spectator = t, this._followerEventMethod = this.onFollowerEvent.bind(this), this._requestFollowMethod = this.onRequestFollowEvent.bind(this), this._joinedRoomMethod = this.onUserJoinedRoom.bind(this);
  }
  /**
   * Initializes network event listeners
   */
  awake() {
    this.context.connection.beginListen("spectator-follower-changed", this._followerEventMethod), this.context.connection.beginListen("spectator-request-follow", this._requestFollowMethod), this.context.connection.beginListen(te.JoinedRoom, this._joinedRoomMethod), this.context.domElement.addEventListener("keydown", (e) => {
      this.spectator.useKeys && (e.key === "f" ? this.onRequestFollowMe() : e.key === "Escape" && this.onRequestFollowMe(!0));
    });
  }
  /**
   * Removes network event listeners
   */
  destroy() {
    this.context.connection.stopListen("spectator-follower-changed", this._followerEventMethod), this.context.connection.stopListen("spectator-request-follow", this._requestFollowMethod), this.context.connection.stopListen(te.JoinedRoom, this._joinedRoomMethod);
  }
  /**
   * Notifies other users about spectating target changes
   * @param target The new target being spectated
   * @param _prevId The previous target's user ID
   */
  onSpectatedObjectChanged(e, t) {
    if (gi && console.log(this.context.connection.connectionId, "onSpectatedObjectChanged", e, t), this.context.connection.connectionId) {
      const i = e?.userId === void 0, n = i ? t : e?.userId, o = new KE(this.context.connection.connectionId, n, i);
      this.context.connection.send("spectator-follower-changed", o);
    }
  }
  /**
   * Requests other users to follow this player or stop following
   * @param stop Whether to request users to stop following
   */
  onRequestFollowMe(e = !1) {
    if (gi && console.log("Request follow", this.context.connection.connectionId), this.context.connection.connectionId) {
      this.spectator.stopSpectating();
      const t = e ? void 0 : this.context.connection.connectionId, i = new ZE(this.spectator, t);
      this.context.connection.send("spectator-request-follow", i);
    }
  }
  /**
   * Handles room join events
   */
  onUserJoinedRoom() {
    w("followme") && this.onRequestFollowMe();
  }
  /**
   * Processes follower status change events from the network
   * @param evt The follower change event data
   */
  onFollowerEvent(e) {
    const t = e.targetUserId, i = e.guid;
    if (gi && console.log(e), t === this.context.connection.connectionId)
      if (e.stoppedFollowing) {
        const n = this.followers.indexOf(i);
        n !== -1 && (this.followers.splice(n, 1), this.removeDisconnectedFollowers(), console.log(i, "unfollows you", this.followers.length));
      } else
        this.followers.includes(i) || (this.followers.push(i), this.removeDisconnectedFollowers(), console.log(i, "follows you", this.followers.length));
  }
  /**
   * Removes followers that are no longer connected to the room
   */
  removeDisconnectedFollowers() {
    for (let e = this.followers.length - 1; e >= 0; e--) {
      const t = this.followers[e];
      this.context.connection.userIsInRoom(t) === !1 && this.followers.splice(e, 1);
    }
  }
  _lastRequestFollowUser;
  /**
   * Handles follow requests from other users
   * @param evt The follow request event
   * @returns True if the request was handled successfully
   */
  onRequestFollowEvent(e) {
    if (this._lastRequestFollowUser = e, e.userId === this.context.connection.connectionId)
      this.spectator.stopSpectating();
    else if (e.userId === void 0)
      this.spectator.stopSpectating();
    else {
      const t = this.context.players.getPlayerView(e.userId);
      if (t)
        this.spectator.target = t;
      else
        return gi && console.warn("Could not find view", e.userId), this.enforceFollow(), !1;
    }
    return !0;
  }
  _enforceFollowInterval;
  /**
   * Periodically retries following a user if the initial attempt failed
   */
  enforceFollow() {
    this._enforceFollowInterval || (this._enforceFollowInterval = setInterval(() => {
      this._lastRequestFollowUser === void 0 || this._lastRequestFollowUser.userId && this.spectator.isFollowedBy(this._lastRequestFollowUser.userId) ? (clearInterval(this._enforceFollowInterval), this._enforceFollowInterval = void 0) : (gi && console.log("REQUEST FOLLOW AGAIN", this._lastRequestFollowUser.userId), this.onRequestFollowEvent(this._lastRequestFollowUser));
    }, 1e3));
  }
}
var eA = Object.defineProperty, tA = Object.getOwnPropertyDescriptor, el = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? tA(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && eA(e, t, n), n;
};
const hb = w("debugsplines");
class ks {
  position = new y();
  rotation = new U();
  tangentIn = new y();
  tangentOut = new y();
}
el([
  lt(y)
], ks.prototype, "position", 2);
el([
  lt(U)
], ks.prototype, "rotation", 2);
el([
  lt(y)
], ks.prototype, "tangentIn", 2);
el([
  lt(y)
], ks.prototype, "tangentOut", 2);
class tl extends R {
  /**
   * Adds a knot to the end of the spline.
   */
  addKnot(e) {
    if (e instanceof ks)
      this.spline.push(e), this._isDirty = !0;
    else {
      const t = new ks();
      t.position.copy(e.position), this.spline.push(t), this._isDirty = !0;
    }
    return this;
  }
  /**
   * Removes a knot by index or by reference.
   */
  removeKnot(e) {
    if (typeof e == "number")
      this.spline.splice(e, 1), this._isDirty = !0;
    else {
      const t = this.spline.indexOf(e);
      t !== -1 && (this.spline.splice(t, 1), this._isDirty = !0);
    }
    return this;
  }
  /**
   * Gets a point on the spline in world space.
   */
  getPointAt(e, t) {
    if (!this.curve) return new y();
    const i = this.curve.getPointAt(j.clamp01(e), t), n = this.gameObject.matrixWorld ?? void 0;
    return n && i.applyMatrix4(n), i;
  }
  /**
   * Marks the spline as dirty, causing it to be rebuilt on the next update.
   */
  markDirty() {
    this._isDirty = !0;
  }
  /**
   * Gets the tangent vector on the spline in world space.
   */
  getTangentAt(e, t) {
    if (!this.curve) return t ?? new y();
    const i = this.gameObject.worldQuaternion;
    return this.curve.getTangentAt(j.clamp01(e), t).applyQuaternion(i);
  }
  set closed(e) {
    this._closed = e, this._isDirty = !0;
  }
  get closed() {
    return this._closed;
  }
  _closed = !1;
  spline = [];
  /** Enable to render the spline curve for debugging */
  set debug(e) {
    e && !this._builtCurve && this.buildCurve(), this._debugLine && (this._debugLine.visible = e);
  }
  /** Gets the spline curve generated from the 'spline' data */
  get curve() {
    return this._curve;
  }
  get isDirty() {
    return this._isDirty;
  }
  _isDirty = !1;
  _curve = null;
  _builtCurve = !1;
  _debugLine = null;
  /** @internal */
  awake() {
    hb && (console.log(`[Spline] ${this.name}`, this), this.buildCurve());
  }
  /** @internal */
  update() {
    this._isDirty && this.buildCurve(!0), this._debugLine && this._debugLine.parent !== this.gameObject && this.gameObject.add(this._debugLine);
  }
  buildCurve(e = !1) {
    if (!(this._builtCurve && !e)) {
      if (this._builtCurve = !0, !this.spline) {
        console.error("[Spline] Can not build curve, no spline data", this.name);
        return;
      }
      this._isDirty = !1, this._curve = iA(this.spline, this.closed), this.buildDebugCurve();
    }
  }
  buildDebugCurve() {
    if (hb && this.spline && this._curve) {
      this._debugLine?.removeFromParent(), this._debugLine = null;
      const e = new wm({
        color: 6684927
      }), t = this.spline.length * 10, i = this._curve.getPoints(t), n = new an().setFromPoints(i);
      this._debugLine = new ma(n, e), this.gameObject?.add(this._debugLine);
    }
  }
}
el([
  lt()
], tl.prototype, "closed", 1);
el([
  lt(ks)
], tl.prototype, "spline", 2);
function iA(s, e) {
  const t = s.map((o) => new y(-o.position.x, o.position.y, o.position.z));
  t.length === 1 && t.push(t[0]);
  const i = s.reduce((o, r) => o + Math.abs(r.tangentOut.x) + Math.abs(r.tangentOut.y) + Math.abs(r.tangentOut.z), 0) / s.length, n = j.remap(i, 0, 0.3, 0, 0.5);
  return new gS(t, e, "catmullrom", n);
}
var nA = Object.defineProperty, sA = Object.getOwnPropertyDescriptor, Tr = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? sA(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && nA(e, t, n), n;
};
class Qn extends R {
  spline = null;
  object = void 0;
  lookAt = null;
  clamp = !1;
  get position01() {
    return this._position01;
  }
  set position01(e) {
    this._position01 = e, this.updateFromPosition();
  }
  /** Resets the position to 0 */
  reset() {
    this._position01 = 0;
  }
  autoRun = !0;
  duration = 10;
  // #region internal
  _position01 = 0;
  /** @internal */
  start() {
    this.object === void 0 && (this.object = this.gameObject), this.updateFromPosition();
  }
  update() {
    this.autoRun && (this._position01 += this.context.time.deltaTime / this.duration, this.updateFromPosition());
  }
  updateFromPosition() {
    if (!this.spline || !this.spline.curve || !this.object) return;
    this.clamp ? this._position01 = j.clamp01(this._position01) : this._position01 = this._position01 % 1;
    const e = this._position01 >= 1 ? 1 : this._position01 % 1, t = this.spline.getPointAt(e);
    if (this.object.worldPosition = t, this.lookAt)
      this.object.lookAt(this.lookAt.worldPosition);
    else {
      const i = this.spline.getTangentAt(e);
      this.object.lookAt(t.add(i));
    }
  }
}
Tr([
  lt(tl)
], Qn.prototype, "spline", 2);
Tr([
  lt(M)
], Qn.prototype, "object", 2);
Tr([
  lt(M)
], Qn.prototype, "lookAt", 2);
Tr([
  lt()
], Qn.prototype, "clamp", 2);
Tr([
  lt()
], Qn.prototype, "position01", 1);
Tr([
  lt()
], Qn.prototype, "autoRun", 2);
Tr([
  lt()
], Qn.prototype, "duration", 2);
class Pn {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsSyncedCameraModel(e, t) {
    return (t || new Pn()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsSyncedCameraModel(e, t) {
    return e.setPosition(e.position() + Nb), (t || new Pn()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  userId(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  guid(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  dontSave() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  pos(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? (e || new ir()).__init(this.bb_pos + t, this.bb) : null;
  }
  rot(e) {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? (e || new ir()).__init(this.bb_pos + t, this.bb) : null;
  }
  static startSyncedCameraModel(e) {
    e.startObject(5);
  }
  static addUserId(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addGuid(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static addDontSave(e, t) {
    e.addFieldInt8(2, +t, 0);
  }
  static addPos(e, t) {
    e.addFieldStruct(3, t, 0);
  }
  static addRot(e, t) {
    e.addFieldStruct(4, t, 0);
  }
  static endSyncedCameraModel(e) {
    return e.endObject();
  }
  static finishSyncedCameraModelBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedSyncedCameraModelBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
var oA = Object.defineProperty, rA = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && oA(e, t, n), n;
};
const Id = "SCAM";
_0(Id, Pn.getRootAsSyncedCameraModel);
const li = new Em();
class aA {
  userId;
  guid;
  // dontSave: boolean = true;
  // pos: { x: number, y: number, z: number } = { x: 0, y: 0, z: 0 };
  // rot: { x: number, y: number, z: number } = { x: 0, y: 0, z: 0 };
  constructor(e, t) {
    this.guid = t, this.userId = e;
  }
  send(e, t) {
    if (e) {
      li.clear();
      const i = li.createString(this.guid), n = li.createString(this.userId);
      Pn.startSyncedCameraModel(li), Pn.addGuid(li, i), Pn.addUserId(li, n);
      const o = Z(e), r = Dm(e);
      Pn.addPos(li, ir.createVec3(li, o.x, o.y, o.z)), Pn.addRot(li, ir.createVec3(li, r.x, r.y, r.z));
      const a = Pn.endSyncedCameraModel(li);
      li.finish(a, Id), t.sendBinary(li.asUint8Array());
    }
  }
}
const Dw = class um extends R {
  static instances = [];
  getCameraObject(e) {
    const t = this.userToCamMap[e];
    return t ? this.remoteCams[t].obj : null;
  }
  cameraPrefab = null;
  _lastWorldPosition;
  _lastWorldQuaternion;
  _model = null;
  _needsUpdate = !0;
  _lastUpdateTime = 0;
  remoteCams = {};
  userToCamMap = {};
  _camTimeoutInSeconds = 10;
  _receiveCallback = null;
  /** @internal */
  async awake() {
    this._lastWorldPosition = this.worldPosition.clone(), this._lastWorldQuaternion = this.worldQuaternion.clone(), this.cameraPrefab && ("uri" in this.cameraPrefab && (this.cameraPrefab = await this.cameraPrefab.instantiate(this.gameObject)), this.cameraPrefab && "isObject3D" in this.cameraPrefab && (this.cameraPrefab.visible = !1));
  }
  /** @internal */
  onEnable() {
    this._receiveCallback = this.context.connection.beginListenBinary(Id, this.onReceivedRemoteCameraInfoBin.bind(this));
  }
  /** @internal */
  onDisable() {
    this.context.connection.stopListenBinary(Id, this._receiveCallback);
  }
  /** @internal */
  update() {
    for (const n in this.remoteCams) {
      const o = this.remoteCams[n], r = this.context.time.realtimeSinceStartup - o.lastUpdate;
      if (!o || r > this._camTimeoutInSeconds) {
        L() && console.log("Remote cam timeout", n), o?.obj && S.destroy(o.obj), delete this.remoteCams[n], o && delete this.userToCamMap[o.userId], um.instances.push(o), this.context.players.removePlayerView(o.userId, tr.Browser);
        continue;
      }
    }
    if (this.context.isInXR) return;
    const e = this.context.mainCamera;
    if (e === null) {
      this.enabled = !1;
      return;
    }
    if (!this.context.connection.isConnected || this.context.connection.connectionId === null) return;
    this._model === null && (this._model = new aA(this.context.connection.connectionId, this.context.connection.connectionId + "_camera"));
    const t = Z(e), i = be(e);
    (t.distanceTo(this._lastWorldPosition) > 1e-3 || i.angleTo(this._lastWorldQuaternion) > 0.01) && (this._needsUpdate = !0), this._lastWorldPosition.copy(t), this._lastWorldQuaternion.copy(i), !((!this._needsUpdate || this.context.time.frameCount % 2 !== 0) && !(this.context.time.realtimeSinceStartup - this._lastUpdateTime > this._camTimeoutInSeconds * 0.5)) && (this._lastUpdateTime = this.context.time.realtimeSinceStartup, this._needsUpdate = !1, this._model.send(e, this.context.connection), this.context.isInXR || this.context.players.setPlayerView(this.context.connection.connectionId, e, tr.Browser));
  }
  onReceivedRemoteCameraInfoBin(e) {
    const t = e.guid();
    if (!t) return;
    const i = e.userId();
    if (!i || !this.context.connection.userIsInRoom(i) || !this.cameraPrefab) return;
    let n = this.remoteCams[t];
    if (!n)
      if ("isObject3D" in this.cameraPrefab) {
        const l = new $n();
        l.context = this.context;
        const c = S.instantiate(this.cameraPrefab, l);
        n = this.remoteCams[t] = { obj: c, lastUpdate: this.context.time.realtimeSinceStartup, userId: i }, n.obj.visible = !0, this.gameObject.add(c), this.userToCamMap[i] = t, um.instances.push(n);
        const h = S.getOrAddComponent(c, je);
        h.connectionId = i, h.avatar = c;
      } else
        return;
    const o = n.obj;
    this.context.players.setPlayerView(i, o, tr.Browser), n.lastUpdate = this.context.time.realtimeSinceStartup, ln.markDirty(o);
    const r = e.pos();
    r && ba(o, r.x(), r.y(), r.z());
    const a = e.rot();
    a && Kd(o, a.x(), a.y(), a.z());
  }
};
rA([
  u([M, ie])
], Dw.prototype, "cameraPrefab");
let jw = Dw;
var lA = Object.defineProperty, cA = Object.getOwnPropertyDescriptor, Mo = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? cA(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && lA(e, t, n), n;
};
const ap = "view", lp = w("debugsyncedroom");
class Yn extends R {
  roomName = "";
  urlParameterName = "room";
  joinRandomRoom;
  requireRoomParameter = !1;
  autoRejoin = !0;
  createJoinButton = !0;
  createViewOnlyButton = !1;
  /**
   * Get current room name from the URL parameter or the view parameter.
   */
  get currentRoomName() {
    const e = w(ap);
    return e || w(this.urlParameterName);
  }
  _lastJoinedRoom;
  set roomPrefix(e) {
    this._roomPrefix = e;
  }
  get roomPrefix() {
    return this._roomPrefix;
  }
  _roomPrefix = "";
  /** @internal */
  awake() {
    this.joinRandomRoom === void 0 && this.roomName?.length <= 0 && (this.joinRandomRoom = !0), lp && console.log(`SyncedRoom roomName:${this.roomName}, urlParamName:${this.urlParameterName}, joinRandomRoom:${this.joinRandomRoom}`);
  }
  /** @internal */
  onEnable() {
    const e = w(ap);
    if (e && typeof e == "string" && e.length > 0) {
      console.log("Join as viewer"), this.context.connection.joinRoom(e, !0);
      return;
    }
    if (this.tryJoinRoom(), this.createJoinButton) {
      const t = this.createRoomButton();
      this.context.menu.appendChild(t);
    }
    this.createViewOnlyButton && this.onEnableViewOnlyButton();
  }
  /** @internal */
  onDisable() {
    this._roomButton?.remove(), this.onDisableViewOnlyButton(), this.roomName && this.roomName.length > 0 && this.context.connection.leaveRoom(this.roomName);
  }
  /** @internal */
  onDestroy() {
    this.destroyRoomButton();
  }
  /** Will generate a random room name, set it as an URL parameter and attempt to join the room */
  tryJoinRandomRoom() {
    this.setRandomRoomUrlParameter(), this.tryJoinRoom();
  }
  /** Try to join the currently set roomName */
  tryJoinRoom(e = 0) {
    e === void 0 && (e = 0);
    let t = !1;
    if (this.urlParameterName?.length > 0) {
      const i = w(this.urlParameterName);
      if (i && (typeof i == "string" || typeof i == "number")) {
        t = !0;
        const n = _C(i.toString());
        this.roomName = n;
      } else if (this.joinRandomRoom && (console.log("No room name found in url, generating random one"), this.setRandomRoomUrlParameter(), e < 1))
        return this.tryJoinRoom(e + 1);
    } else
      this.joinRandomRoom && (this.roomName === null || this.roomName === void 0 || this.roomName.length <= 0) && (this.roomName = this.generateRoomName());
    return this.requireRoomParameter && !t ? ((lp || L()) && console.warn('[SyncedRoom] Missing required room parameter "' + this.urlParameterName + `" in url - will not connect.
To allow joining a room without a query parameter you can set "requireRoomParameter" to false.`), !1) : (this.context.connection.isConnected || this.context.connection.connect(), this._lastJoinedRoom = this.roomName, this._roomPrefix && (this.roomName = this._roomPrefix + this.roomName), this.roomName.length <= 0 ? (console.warn(`[SyncedRoom] Room name is not set so we can not join a networked room.
Please choose one of the following options to fix this:
A) Set a room name in the SyncedRoom component
B) Set a room name in the URL parameter "?` + this.urlParameterName + `=my_room"
C) Set "joinRandomRoom" to true`), !1) : (lp && console.log("Join " + this.roomName), this._userWantsToBeInARoom = !0, this.context.connection.joinRoom(this.roomName), !0));
  }
  _lastPingTime = 0;
  _lastRoomTime = -1;
  _userWantsToBeInARoom = !1;
  /** @internal */
  update() {
    this.context.connection.isConnected && (this.context.time.time - this._lastPingTime > 3 && (this._lastPingTime = this.context.time.time, this.context.connection.sendPing()), this.context.connection.isInRoom && (this._lastRoomTime = this.context.time.time)), this._lastRoomTime > 0 && this.context.time.time - this._lastRoomTime > 0.3 && (this._lastRoomTime = -1, this.autoRejoin ? this._userWantsToBeInARoom && (console.log("Disconnected from networking backend - attempt reconnecting now"), this.tryJoinRoom()) : L() && console.warn("You are not connected to a room anymore (possibly because the tab was inactive for too long and the server kicked you?)"));
  }
  /**
   * Get the URL to view the current room in view only mode.
   */
  getViewOnlyUrl() {
    if (this.context.connection.isConnected && this.context.connection.currentRoomViewId) {
      const e = window.location.search, t = new URLSearchParams(e);
      return t.has(this.urlParameterName) && t.delete(this.urlParameterName), t.set(ap, this.context.connection.currentRoomViewId), window.location.origin + window.location.pathname + "?" + t.toString();
    }
    return null;
  }
  setRandomRoomUrlParameter() {
    const e = qd(), t = this.generateRoomName();
    w(this.urlParameterName) ? e.set(this.urlParameterName, t) : e.append(this.urlParameterName, t), Hb(t, e);
  }
  generateRoomName() {
    let e = "";
    for (let t = 0; t < 6; t++)
      e += Math.floor(Math.random() * 10).toFixed(0);
    return e;
  }
  _roomButton;
  _roomButtonIconJoin;
  _roomButtonIconLeave;
  createRoomButton() {
    if (this._roomButton)
      return this._roomButton;
    const e = document.createElement("button");
    return this._roomButton = e, e.classList.add("create-room-button"), e.setAttribute("priority", "90"), e.onclick = () => {
      if (this.context.connection.isInRoom)
        this.urlParameterName && rd(this.urlParameterName, null), this.context.connection.leaveRoom(), this._userWantsToBeInARoom = !1;
      else {
        if (this.urlParameterName) {
          const t = w(this.urlParameterName);
          (!t || t === !0) && (this._lastJoinedRoom ? rd(this.urlParameterName, this._lastJoinedRoom) : this.setRandomRoomUrlParameter());
        }
        this.tryJoinRoom();
      }
    }, this._roomButtonIconJoin = Et("group"), this._roomButtonIconLeave = Et("group_off"), this.updateRoomButtonState(), this.context.connection.beginListen(te.JoinedRoom, this.updateRoomButtonState), this.context.connection.beginListen(te.LeftRoom, this.updateRoomButtonState), e;
  }
  updateRoomButtonState = () => {
    this._roomButton && (this.context.connection.isInRoom ? (this._roomButton.title = "Leave the networked room", this._roomButton.textContent = "Leave Room", this._roomButtonIconJoin?.remove(), this._roomButton.prepend(this._roomButtonIconLeave)) : (this._roomButton.title = "Create or join a networked room", this._roomButton.textContent = "Join Room", this._roomButtonIconLeave?.remove(), this._roomButton.prepend(this._roomButtonIconJoin)));
  };
  destroyRoomButton() {
    this.context.connection.stopListen(te.JoinedRoom, this.updateRoomButtonState), this.context.connection.stopListen(te.LeftRoom, this.updateRoomButtonState);
  }
  _viewOnlyButton;
  onEnableViewOnlyButton() {
    this.context.connection.isConnected ? this.onCreateViewOnlyButton() : (this.context.connection.stopListen(te.JoinedRoom, this.onCreateViewOnlyButton), this.context.connection.beginListen(te.JoinedRoom, this.onCreateViewOnlyButton));
  }
  onDisableViewOnlyButton() {
    this.context.connection.stopListen(te.JoinedRoom, this.onCreateViewOnlyButton), this._viewOnlyButton?.remove();
  }
  onCreateViewOnlyButton = () => {
    if (!this._viewOnlyButton) {
      const e = document.createElement("button");
      this._viewOnlyButton = e, e.classList.add("view-only-button"), e.setAttribute("priority", "90"), e.onclick = () => {
        const t = this.getViewOnlyUrl();
        t?.length ? navigator.canShare({ url: t }) ? navigator.share({ url: t })?.catch((i) => {
          console.warn(i);
        }) : (navigator.clipboard.writeText(t), Be("View only URL copied to clipboard")) : ge("Could not create view only URL");
      }, e.title = "Copy the view only URL: A page accessed by the view only URL can not be modified by visiting users.", e.textContent = "Share View URL", e.prepend(Et("visibility"));
    }
    this.context.menu.appendChild(this._viewOnlyButton);
  };
}
Mo([
  u()
], Yn.prototype, "roomName", 2);
Mo([
  u()
], Yn.prototype, "urlParameterName", 2);
Mo([
  u()
], Yn.prototype, "joinRandomRoom", 2);
Mo([
  u()
], Yn.prototype, "requireRoomParameter", 2);
Mo([
  u()
], Yn.prototype, "autoRejoin", 2);
Mo([
  u()
], Yn.prototype, "createJoinButton", 2);
Mo([
  u()
], Yn.prototype, "createViewOnlyButton", 2);
Mo([
  u()
], Yn.prototype, "roomPrefix", 1);
function hA() {
  const s = w("testwindowcount") || 0;
  s && s > 0 && dA(s);
}
function dA(s) {
  if (w("testwindow")) return null;
  const e = new URL(window.location.href);
  _y(e.searchParams, Xk, 1), _y(e.searchParams, "testwindow", 1);
  const t = e.toString(), i = [];
  window.onbeforeunload = () => {
    for (const l of i) l.close();
  };
  const n = 0.05, o = 128;
  let r = 0, a = 0;
  for (let l = 0; l < s; l++) {
    r * o + o * 0.01 >= window.innerWidth && (a += 1, r = 0);
    const c = r * (o * (1 + n)) + window.screenLeft, h = a * (o * (1 + n)) + window.screenTop + 90 + 60 * a;
    r += 1;
    const d = window.open(t, "test window " + l, `popup=yes width=${o} height=${o} top=${h} left=${c}`);
    if (!d) {
      console.warn("Failed to open window");
      continue;
    }
    i.push(d), d.onload = () => {
      d.onbeforeunload = () => {
        for (let f = 0; f < i.length; f++) {
          const p = i[f];
          p !== d && p.close();
        }
        i.length = 0;
      };
    };
  }
  return i;
}
class Bw extends R {
  awake() {
    hA();
  }
}
class Fw extends R {
  transformsPerFrame = 10;
  interval = 0;
  useFlatbuffers = !0;
  awake() {
    if (this.useFlatbuffers)
      this.context.connection.beginListenBinary(yc, (e) => {
      });
    else {
      this.models = [];
      for (let e = 0; e < this.transformsPerFrame; e++)
        this.models.push(new uA(this.context.connection.connectionId + "_simulatedTransform_" + e, this));
    }
  }
  builder = null;
  models = null;
  update() {
    if (this.context.connection.isConnected) {
      if (this.useFlatbuffers) {
        if (!this.context.connection.connectionId || this.context.time.frameCount % this.interval !== 0) return;
        this.builder === null && (this.builder = new Em(1024));
        const e = this.builder;
        for (let t = 0; t < this.transformsPerFrame; t++) {
          e.clear();
          const i = ov(this.context.connection.connectionId, this);
          this.context.connection.sendBinary(i);
        }
      } else if (this.models)
        for (let e = 0; e < this.models.length; e++) {
          const t = this.models[e];
          t.dontSave = !0, t.update(this, null), this.context.connection.send("TestSimulateUserData-" + e, t);
        }
    }
  }
}
class uA {
  guid;
  fast = !1;
  position;
  rotation;
  // scale : { x : number, y : number, z : number } | undefined = undefined;
  velocity = void 0;
  dontSave;
  isValid() {
    return this.fast !== void 0 || this.position !== void 0 || this.rotation !== void 0 || this.velocity !== void 0;
  }
  constructor(e, t) {
    this.guid = e, this.position = { x: 0, y: 0, z: 0 }, this.rotation = { x: 0, y: 0, z: 0, w: 0 }, this.update(t, null);
  }
  static temp = new y();
  update(e, t) {
    const i = e.worldPosition;
    this.position.x = i.x, this.position.y = i.y, this.position.z = i.z;
    const n = e.worldQuaternion;
    if (this.rotation.x = n.x, this.rotation.y = n.y, this.rotation.z = n.z, this.rotation.w = n.w, this.fast = !1, t) {
      const o = t.getVelocity();
      this.velocity === void 0 && (this.velocity = { x: 0, y: 0, z: 0 }), this.velocity.x = o.x, this.velocity.y = o.y, this.velocity.z = o.z;
    }
  }
}
var fA = Object.defineProperty, $u = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && fA(e, t, n), n;
};
const pA = w("debugsignals");
class Yg {
  guid;
}
$u([
  u()
], Yg.prototype, "guid");
class Wu {
  signal;
  reaction;
}
$u([
  u(Yg)
], Wu.prototype, "signal");
$u([
  u(ce)
], Wu.prototype, "reaction");
const zw = class rs extends R {
  static receivers = {};
  static invoke(e) {
    if (rs.receivers[e]) {
      const t = rs.receivers[e];
      if (!t) return;
      for (const i of t)
        i.invoke(e);
    }
  }
  events;
  /** @internal */
  awake() {
    pA && console.log("SignalReceiver awake", this);
  }
  /** @internal */
  onEnable() {
    if (this.events)
      for (const e of this.events)
        rs.receivers[e.signal.guid] || (rs.receivers[e.signal.guid] = []), rs.receivers[e.signal.guid].push(this);
  }
  /** @internal */
  onDisable() {
    if (this.events) {
      for (const e of this.events)
        if (rs.receivers[e.signal.guid]) {
          const t = rs.receivers[e.signal.guid].indexOf(this);
          t >= 0 && rs.receivers[e.signal.guid].splice(t, 1);
        }
    }
  }
  invoke(e) {
    if (!this.events || !Array.isArray(this.events)) return;
    const t = typeof e == "object" ? e.guid : e;
    for (const i of this.events)
      if (i.signal.guid === t)
        try {
          if (i.reaction) {
            if (!i.reaction.invoke) {
              console.warn("Missing invoke - possibly a serialization error", i, this);
              continue;
            }
          } else {
            console.warn("Missing reaction for signal", i, this);
            continue;
          }
          i.reaction.invoke();
        } catch (n) {
          console.error(n);
        }
  }
  // onDeserialize(key: string, value: any): any | void
  // {
  //     switch(key){
  //         case "events":
  //             console.log(value);
  //             const evt = eventListSerializer;
  //             for(const e in value){
  //             }
  //             break;
  //     }
  // }
};
$u([
  u(Wu)
], zw.prototype, "events");
let Vu = zw;
var Fi = /* @__PURE__ */ ((s) => (s.Activation = "ActivationTrack", s.Animation = "AnimationTrack", s.Audio = "AudioTrack", s.Control = "ControlTrack", s.Marker = "MarkerTrack", s.Signal = "SignalTrack", s))(Fi || {}), as = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Hold = 1] = "Hold", s[s.Loop = 2] = "Loop", s[s.PingPong = 3] = "PingPong", s[s.Continue = 4] = "Continue", s))(as || {}), Uw = /* @__PURE__ */ ((s) => (s.Signal = "SignalEmitter", s))(Uw || {});
const Tn = w("debugtimeline");
class Hu {
  director;
  track;
  get muted() {
    return this.track.muted;
  }
  set muted(e) {
    e !== this.track.muted && (this.track.muted = e, this.onMuteChanged?.call(this));
  }
  *forEachClip(e = !1) {
    if (this.track?.clips)
      if (e)
        for (let t = this.track.clips.length - 1; t >= 0; t--)
          yield this.track.clips[t];
      else
        for (const t of this.track.clips)
          yield t;
  }
  getClipTime(e, t) {
    return t.clipIn + (e - t.start) * t.timeScale;
  }
  getClipTimeNormalized(e, t) {
    return (e - t.start) / t.duration;
  }
  evaluateWeight(e, t, i, n = !0) {
    if (t < 0 || t >= i.length) return 0;
    const o = i[t];
    if (n || e >= o.start && e <= o.end) {
      let r = 1;
      if (o.easeInDuration > 0) {
        const a = Math.min((e - o.start) / o.easeInDuration, 1);
        r *= a;
      }
      if (o.easeOutDuration > 0) {
        const a = Math.min((o.end - e) / o.easeOutDuration, 1);
        r *= a;
      }
      return r;
    }
    return 0;
  }
}
class mA {
  clip;
  rootPositionOffset;
  rootQuaternionOffset;
  get hasOffsets() {
    return this.rootPositionOffset !== void 0 || this.rootQuaternionOffset !== void 0;
  }
  // not necessary
  rootStartPosition;
  rootEndPosition;
  rootStartQuaternion;
  rootEndQuaternion;
  constructor(e) {
    const t = e.getClip();
    this.clip = t;
    const i = e.getRoot(), n = i.name + ".position", o = i.name + ".quaternion";
    Tn && console.log(t.name, t.tracks, n);
    for (const r of t.tracks)
      if (!(r.times.length <= 0)) {
        if (r.name.endsWith(n))
          this.rootStartPosition = new y().fromArray(r.values, 0), this.rootEndPosition = new y().fromArray(r.values, r.values.length - 3), this.rootPositionOffset = this.rootEndPosition.clone().sub(this.rootStartPosition), Tn && console.log(this.rootPositionOffset);
        else if (r.name.endsWith(o) && (this.rootStartQuaternion = new U().fromArray(r.values, 0), this.rootEndQuaternion = new U().fromArray(r.values, r.values.length - 4), this.rootQuaternionOffset = this.rootEndQuaternion.clone().multiply(this.rootStartQuaternion), Tn)) {
          const a = new ot().setFromQuaternion(this.rootQuaternionOffset);
          console.log("ROT", a);
        }
      }
  }
}
class Kg extends Hu {
  /** @internal */
  models = [];
  /** @internal */
  trackOffset;
  /** The object that is being animated. */
  target;
  /** The AnimationMixer, should be shared with the animator if an animator is bound */
  mixer;
  clips = [];
  actions = [];
  /**
   * You can use the weight to blend the timeline animation tracks with multiple animation tracks on the same object.
   * @default 1
   */
  weight = 1;
  /** holds data/info about clips differences */
  _actionOffsets = [];
  _didBind = !1;
  _animator = null;
  onDisable() {
    this.mixer?.stopAllAction();
  }
  onDestroy() {
    this.director.context.animations.unregisterAnimationMixer(this.mixer);
  }
  // Using this callback instead of onEnable etc 
  // because we want to re-enable the animator when the director is at the end and wrap mode is set to none
  // in which case the director is stopped (but not disabled)
  // which means we want to notify the object that it's not animated anymore
  // and the animator can then take over
  onStateChanged() {
    this._animator && S_(this._animator.gameObject, this, this.director.isPlaying);
  }
  createHooks(e, t) {
    if (t.tracks?.length <= 0) {
      console.warn("No tracks in AnimationClip", t);
      return;
    }
    const i = t.tracks[0].name.split("."), n = i[i.length - 2], o = n + ".position", r = n + ".quaternion";
    let a = !1, l = !1;
    for (const c of t.tracks)
      c.name.endsWith(o) ? (a = !0, this.createPositionInterpolant(t, e, c)) : c.name.endsWith(r) && (l = !0, this.createRotationInterpolant(t, e, c));
    if (!a || !l) {
      const c = this.mixer?.getRoot(), h = t.tracks[0], d = h.name.lastIndexOf("."), f = h.name.substring(0, d), p = f.substring(f.lastIndexOf(".") + 1), g = c.getObjectByName(p);
      if (g)
        if (a) {
          if (!l) {
            const b = t.tracks[0].name.substring(0, d) + ".quaternion";
            Tn && console.warn("Create quaternion track", p, g);
            const m = g.quaternion, v = new _S(b, [0, t.duration], [m.x, m.y, m.z, m.w, m.x, m.y, m.z, m.w]);
            t.tracks.push(v), this.createRotationInterpolant(t, e, v);
          }
        } else {
          const b = f + ".position";
          Tn && console.warn("Create position track", p, g);
          const m = g.position, v = new yS(b, [0, t.duration], [m.x, m.y, m.z, m.x, m.y, m.z]);
          t.tracks.push(v), this.createPositionInterpolant(t, e, v);
        }
    }
  }
  bind() {
    if (!this._didBind) {
      this._didBind = !0, Tn && console.log(this.models), this.mixer ? this.target = this.mixer.getRoot() : console.warn("No mixer was assigned to animation track");
      for (const e of this.actions) {
        const t = new mA(e);
        this._actionOffsets.push(t);
      }
      this.target && (this._animator = S.getComponent(this.target, kt) ?? null, this._animator && S_(this._animator.gameObject, this, !0));
      for (const e of this.models) {
        const t = e.asset, i = t.position, n = t.rotation;
        i && i.x !== void 0 && (i.isVector3 || (t.position = new y(i.x, i.y, i.z)), n.isQuaternion || (t.rotation = new U(n.x, n.y, n.z, n.w)));
      }
      this.ensureTrackOffsets();
    }
  }
  ensureTrackOffsets() {
    if (this.trackOffset) {
      const e = this.trackOffset.position;
      e && (e.isVector3 || (this.trackOffset.position = new y(e.x, e.y, e.z)));
      const t = this.trackOffset.rotation;
      t && (t.isQuaternion || (this.trackOffset.rotation = new U(t.x, t.y, t.z, t.w)));
    }
  }
  _useclipOffsets = !0;
  _totalOffsetPosition = new y();
  _totalOffsetRotation = new U();
  _totalOffsetPosition2 = new y();
  _totalOffsetRotation2 = new U();
  _summedPos = new y();
  _tempPos = new y();
  _summedRot = new U();
  _tempRot = new U();
  _clipRotQuat = new U();
  evaluate(e) {
    if (this.track.muted || !this.mixer) return;
    this.bind(), this._totalOffsetPosition.set(0, 0, 0), this._totalOffsetRotation.set(0, 0, 0, 1), this._totalOffsetPosition2.set(0, 0, 0), this._totalOffsetRotation2.set(0, 0, 0, 1);
    let t = 0, i = 0, n = !1, o = !1, r = 0;
    for (let a = 0; a < this.clips.length; a++) {
      const l = this.models[a], c = this.actions[a], h = l.asset;
      c.weight = 0;
      const d = e >= l.start && e <= l.end, f = l.preExtrapolationMode, p = l.postExtrapolationMode, g = a < this.clips.length - 1 ? this.models[a + 1] : null;
      let b = d, m = !1;
      if (!b && !n && l.end < e && p !== as.None ? (!g || g.start > e) && (b = !0, n = !0) : a == 0 && !b && !o && l.start > e && f !== as.None && (!g || g.start < e) && (b = !0, m = !0, o = !0), b) {
        let v = this.weight;
        v *= this.evaluateWeight(e, a, this.models, b), v *= this.director.weight;
        let _ = d;
        if (m)
          switch (f) {
            case as.Hold:
              break;
            case as.Loop:
              e += l.start, _ = !0;
              break;
            default:
              e += l.start, _ = !0;
              break;
          }
        let x = this.getClipTime(e, l), I = 0;
        const O = h.duration;
        if (m && f === as.Hold && (x = 0), _) {
          if (h.loop)
            for (I += Math.floor(x / (O + 1e-6)); x > O; )
              x -= O;
        } else if (!d && n)
          switch (p) {
            case as.Hold:
              x = this.getClipTime(l.end, l);
              break;
            case as.Loop:
              x %= O;
              break;
            case as.PingPong:
              const B = Math.floor(x / O) % 2 !== 0;
              x %= O, B && (x = O - x);
              break;
          }
        l.reversed === !0 ? c.time = c.getClip().duration - x : c.time = x, c.timeScale = 0;
        const k = Math.max(0, v);
        if (c.weight = k, r += k, c.clampWhenFinished = !1, c.isRunning() || c.play(), this._useclipOffsets) {
          const E = t == 0 ? this._totalOffsetPosition : this._totalOffsetPosition2, B = t == 0 ? this._totalOffsetRotation : this._totalOffsetRotation2;
          t < 1 && (i = 1 - v), t += 1;
          const D = this._summedPos.set(0, 0, 0), W = this._tempPos.set(0, 0, 0), X = this._summedRot.identity(), A = this._tempRot.identity(), $ = h.rotation;
          $ && (this._clipRotQuat.identity(), this._clipRotQuat.slerp($, v));
          const V = this._actionOffsets[a];
          if (V.hasOffsets)
            for (let ne = 0; ne < I; ne++)
              V.rootPositionOffset ? W.copy(V.rootPositionOffset) : W.set(0, 0, 0), W.applyQuaternion(X), this._clipRotQuat && W.applyQuaternion(this._clipRotQuat), V.rootQuaternionOffset && (A.copy(V.rootQuaternionOffset), X.multiply(A)), D.add(W);
          this._clipRotQuat && B.multiply(this._clipRotQuat), B.multiply(X), h.position && D.add(h.position), E.add(D);
        }
      }
    }
    if (this._useclipOffsets && (this._totalOffsetPosition.lerp(this._totalOffsetPosition2, i), this._totalOffsetRotation.slerp(this._totalOffsetRotation2, i)), this.__mixerError === void 0 && (Tn || L()) && this._animator?.runtimeAnimatorController?.mixer && this.mixer !== this._animator?.runtimeAnimatorController?.mixer && (this.__mixerError = !0, console.error("AnimationTrack mixer is not shared with the animator controller - this might result in the timeline to not animate properly. Please report a bug to the Needle Engine team!", this)), this._animator?.runtimeAnimatorController) {
      const a = Math.max(0, 1 - r);
      this._animator?.runtimeAnimatorController?.update(a);
    } else
      this.mixer.update(e);
  }
  createRotationInterpolant(e, t, i) {
    const n = i.createInterpolant.bind(i), o = new U();
    this.ensureTrackOffsets();
    const r = this.trackOffset?.rotation;
    i.createInterpolant = () => {
      const a = n(), l = a.evaluate.bind(a);
      return a.evaluate = (c) => {
        const h = l(c);
        if (o.set(h[0], h[1], h[2], h[3]), o.premultiply(this._totalOffsetRotation), r && o.premultiply(r), this.director.animationCallbackReceivers)
          for (const d of this.director.animationCallbackReceivers)
            d?.onTimelineRotation?.call(d, this.director, this.target, c, o);
        return h[0] = o.x, h[1] = o.y, h[2] = o.z, h[3] = o.w, h;
      }, a;
    };
  }
  createPositionInterpolant(e, t, i) {
    const n = i.createInterpolant.bind(i), o = new y();
    this.ensureTrackOffsets();
    const r = this.trackOffset?.rotation, a = this.trackOffset?.position;
    let l;
    i.createInterpolant = () => {
      const c = n(), h = c.evaluate.bind(c);
      return c.evaluate = (d) => {
        const f = h(d);
        if (o.set(f[0], f[1], f[2]), t.removeStartOffset && (l === void 0 ? (l = null, l = this._actionOffsets.find((p) => p.clip === e)?.rootStartPosition?.clone()) : l?.isVector3 && o.sub(l)), o.applyQuaternion(this._totalOffsetRotation), o.add(this._totalOffsetPosition), r && o.applyQuaternion(r), a && (o.x -= a.x, o.y += a.y, o.z += a.z), this.director.animationCallbackReceivers)
          for (const p of this.director.animationCallbackReceivers)
            p?.onTimelinePosition?.call(p, this.director, this.target, d, o);
        return f[0] = o.x, f[1] = o.y, f[2] = o.z, f;
      }, c;
    };
  }
}
const gA = w("mutetimeline");
class no extends Hu {
  models = [];
  listener;
  audio = [];
  audioContextTimeOffset = [];
  lastTime = 0;
  audioSource;
  _audioLoader = null;
  getAudioFilePath(e) {
    const t = this.director.sourceId;
    return gr(t, e);
  }
  onAllowAudioChanged(e) {
    for (let t = 0; t < this.models.length; t++) {
      const i = this.models[t];
      this.audio[t].setVolume(e ? i.asset.volume : 0);
    }
  }
  addModel(e) {
    const t = new bS(this.listener);
    this.audio.push(t);
    const i = e;
    i._didTriggerPlay = !1, this.models.push(i);
  }
  onDisable() {
    for (const e of this.audio)
      e.isPlaying && e.stop();
    for (const e of this.models)
      e._didTriggerPlay = !1;
  }
  onDestroy() {
    for (const e of this.audio)
      e.source && e?.disconnect();
    this.audio.length = 0;
  }
  onMuteChanged() {
    if (this.muted)
      for (let e = 0; e < this.audio.length; e++) {
        const t = this.audio[e];
        t?.isPlaying && t.stop();
      }
  }
  stop() {
    for (let e = 0; e < this.audio.length; e++) {
      const t = this.audio[e];
      t?.isPlaying && t.stop();
    }
    for (const e of this.models)
      e._didTriggerPlay = !1;
  }
  _playableDirectorResumed = !1;
  onPauseChanged() {
    for (let e = 0; e < this.audio.length; e++) {
      const t = this.audio[e];
      t?.isPlaying && t.stop();
    }
    this._playableDirectorResumed = this.director.isPlaying;
  }
  evaluate(e) {
    if (gA || this.track.muted || this.director.speed < 0)
      return;
    const t = this.director.context.application.muted, i = this._playableDirectorResumed;
    this._playableDirectorResumed = !1;
    const n = t ? 0.1 : 0;
    for (let o = 0; o < this.models.length; o++) {
      const r = this.models[o], a = this.audio[o], l = r.asset;
      if ((!a || !a.buffer) && this.isInTimeRange(r, e - 1, e + 1) && this.handleAudioLoading(r, a), Xi.userInteractionRegistered !== !1 && !(a === null || !a.buffer))
        if (a.playbackRate = this.director.context.time.timeScale * this.director.speed, a.loop = l.loop, e >= r.start && e <= r.end && e < this.director.duration) {
          if (!a.isPlaying || !this.director.isPlaying)
            (i || !r._didTriggerPlay && this.lastTime < e) && (r.duration * r.timeScale > 0.3 ? a.offset = r.clipIn + (e - r.start) * r.timeScale : a.offset = 0, Tn && console.log("Timeline Audio (" + this.track.name + ") play with offset " + a.offset + " - " + r.asset.clip), a.play(n), r._didTriggerPlay = !0);
          else {
            const h = r.clipIn + (e - r.start) * r.timeScale, d = a.context.currentTime - a._startedAt + a.offset;
            Math.abs(h - d) > 0.3 && (a.offset = h, a.stop(), a.play(n));
          }
          let c = l.volume;
          if (this.track.volume !== void 0 && (c *= this.track.volume), t && (c = 0), r.easeInDuration > 0) {
            const h = Math.min((e - r.start) / r.easeInDuration, 1);
            c *= h;
          }
          if (r.easeOutDuration > 0) {
            const h = Math.min((r.end - e) / r.easeOutDuration, 1);
            c *= h;
          }
          a.setVolume(c * this.director.weight);
        } else
          r._didTriggerPlay = !1, this.director.isPlaying && a.isPlaying && a.stop();
    }
    this.lastTime = e;
  }
  /** Call to load audio buffer for a specific time in the track. Can be used to preload the timeline audio */
  loadAudio(e, t = 0, i = 0) {
    let n = null;
    const o = e - i, r = e + t;
    for (const a of this.models)
      if (this.isInTimeRange(a, o, r)) {
        const l = this.audio[this.models.indexOf(a)], c = this.handleAudioLoading(a, l);
        c !== null && (n === null && (n = []), n.push(c));
      }
    return n !== null ? Promise.all(n) : null;
  }
  isInTimeRange(e, t, i) {
    return t <= e.start && i >= e.end || t >= e.start && t <= e.end || i >= e.start && i <= e.end;
  }
  static _audioBuffers = /* @__PURE__ */ new Map();
  static dispose() {
    no._audioBuffers.clear();
  }
  handleAudioLoading(e, t) {
    this._audioLoader || (this._audioLoader = new mp());
    const i = this.getAudioFilePath(e.asset.clip);
    if (no._audioBuffers.get(i)) {
      const o = no._audioBuffers.get(i);
      return o.then((r) => {
        r && t.setBuffer(r);
      }), o;
    }
    Tn && console.warn("LOAD audio track", i, this.director.sourceId);
    const n = new Promise((o, r) => {
      this._audioLoader.load(
        i,
        (a) => {
          t.setBuffer(a), o(a);
        },
        void 0,
        (a) => {
          console.error("Error loading audio", a), o(null);
        }
      );
    });
    return no._audioBuffers.set(i, n), n;
  }
}
class Ld extends Hu {
  models = [];
  didTrigger = [];
  receivers = [];
  // TODO: test when timeline signals are being reset in Unity
  // onEnable() {
  //     for (let i = 0; i < this.didTrigger?.length; i++) {
  //         this.didTrigger[i] = false;
  //     }
  // }
  // private _lastTime: number = -1;
  evaluate(e) {
    if (this.track.muted) return;
    const t = this.director.context.time.deltaTime * 1.5;
    for (let i = 0; i < this.models.length; i++) {
      const n = this.models[i], o = this.didTrigger[i], r = n.time - e;
      let a = !1;
      if (n.retroActive)
        a = r <= 1e-6;
      else {
        const l = Math.abs(r);
        (l === 0 || l >= 1e-5 && l < t) && (a = !0);
      }
      if (a) {
        if (!o)
          if (Tn && console.log("Trigger signal", e, n.time, n), this.didTrigger[i] = !0, this.receivers?.length <= 0)
            Vu.invoke(n.asset);
          else
            for (const l of this.receivers)
              l && l.invoke(n.asset);
      } else
        n.emitOnce || (this.didTrigger[i] = !1);
    }
  }
}
class Zg extends Hu {
  models = [];
  timelines = [];
  resolveSourceObjects(e) {
    for (let t = this.models.length - 1; t >= 0; t--) {
      const n = this.models[t].asset;
      if (!n.sourceObject || typeof n.sourceObject != "object") {
        console.log("no source object, removing model", t, n), this.models.splice(t, 1);
        continue;
      } else {
        const o = S.getComponent(n.sourceObject, Ia);
        this.timelines.push(o), o && n.updateDirector && (o.playOnAwake = !1);
      }
    }
  }
  _previousActiveModel = null;
  evaluate(e) {
    this._previousActiveModel = null;
    for (let t = 0; t < this.models.length; t++) {
      const i = this.models[t], n = i.asset;
      if (e >= i.start && e <= i.end) {
        this._previousActiveModel = i;
        const o = this.getClipTime(e, i);
        if (n.controlActivation) {
          const r = n.sourceObject;
          r.visible = !0;
        }
        if (n.updateDirector) {
          const r = this.timelines[t];
          r && (r.isPlaying && r.pause(), r.time = o, r.evaluate());
        }
      } else {
        const o = this._previousActiveModel?.asset;
        if (n.controlActivation) {
          const r = n.sourceObject;
          o?.sourceObject !== r && (r.visible = !1);
        }
      }
    }
  }
}
var yA = Object.defineProperty, Nw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && yA(e, t, n), n;
};
const is = w("debugtimeline"), Jg = class fm extends R {
  static createTrackFunctions = {};
  static registerCreateTrack(e, t) {
    this.createTrackFunctions[e] = t;
  }
  playableAsset;
  playOnAwake;
  extrapolationMode = 1;
  /** @returns true if the timeline is currently playing */
  get isPlaying() {
    return this._isPlaying;
  }
  /** @returns true if the timeline is currently paused */
  get isPaused() {
    return this._isPaused;
  }
  /** the current time of the timeline */
  get time() {
    return this._time;
  }
  set time(e) {
    typeof e == "number" && !Number.isNaN(e) ? this._time = e : (is || hn()) && console.error("INVALID TIMELINE.TIME VALUE", e, this.name);
  }
  /** the duration of the timeline */
  get duration() {
    return this._duration;
  }
  set duration(e) {
    this._duration = e;
  }
  /** the weight of the timeline. Set to a value below 1 to blend with other timelines */
  get weight() {
    return this._weight;
  }
  set weight(e) {
    this._weight = e;
  }
  /** the playback speed of the timeline */
  get speed() {
    return this._speed;
  }
  set speed(e) {
    this._speed = e;
  }
  /** When enabled the timeline will wait for audio tracks to load at the current time before starting to play */
  waitForAudio = !0;
  _visibilityChangeEvt;
  _clonedPlayableAsset = !1;
  _speed = 1;
  /** @internal */
  awake() {
    is && console.log(this, this.playableAsset?.tracks), this.rebuildGraph(), !this.isValid() && (is || L()) && (is ? console.warn("PlayableDirector is not valid", "Asset?", this.playableAsset, "Tracks:", this.playableAsset?.tracks, "IsArray?", Array.isArray(this.playableAsset?.tracks), this) : this.playableAsset?.tracks?.length ? console.warn("PlayableDirector is not valid") : console.warn("PlayableDirector has no tracks"));
  }
  /** @internal */
  onEnable() {
    for (const e of this._audioTracks)
      e.onEnable?.();
    for (const e of this._customTracks)
      e.onEnable?.();
    for (const e of this._animationTracks)
      e.onEnable?.();
    this.playOnAwake && this.play(), this._visibilityChangeEvt || (this._visibilityChangeEvt = () => {
      switch (document.visibilityState) {
        case "hidden":
          this.setAudioTracksAllowPlaying(!1);
          break;
        case "visible":
          this.setAudioTracksAllowPlaying(!0);
          break;
      }
    }), window.addEventListener("visibilitychange", this._visibilityChangeEvt);
  }
  /** @internal */
  onDisable() {
    this.stop();
    for (const e of this._audioTracks)
      e.onDisable?.();
    for (const e of this._customTracks)
      e.onDisable?.();
    for (const e of this._animationTracks)
      e.onDisable?.();
    this._visibilityChangeEvt && window.removeEventListener("visibilitychange", this._visibilityChangeEvt);
  }
  /** @internal */
  onDestroy() {
    for (const e of this._allTracks)
      for (const t of e)
        t.onDestroy?.();
  }
  /** @internal */
  rebuildGraph() {
    this.isValid() && (this.resolveBindings(), this.updateTimelineDuration(), this.setupAndCreateTrackHandlers());
  }
  /**
   * Play the timeline from the current time.  
   * If the timeline is already playing this method does nothing.
   */
  async play() {
    if (!this.isValid()) return;
    const e = this._isPaused == !0;
    if (this._isPaused = !1, !this._isPlaying) {
      if (this._isPlaying = !0, e && this.invokePauseChangedMethodsOnTracks(), this.waitForAudio) {
        const t = [];
        for (const i of this._audioTracks) {
          const n = i.loadAudio(this._time, 1, 0);
          n && t.push(n);
        }
        if (t.length > 0 && (await Promise.all(t), !this._isPlaying))
          return;
        for (; this._audioTracks.length > 0 && this._isPlaying && !Xi.userInteractionRegistered && this.waitForAudio; )
          await Os(200);
      }
      this.invokeStateChangedMethodsOnTracks(), this._internalUpdateRoutine = this.startCoroutine(this.internalUpdate(), xe.LateUpdate);
    }
  }
  /**
   * Pause the timeline.
   */
  pause() {
    this.isValid() && (this._isPlaying = !1, !this._isPaused && (this._isPaused = !0, this.internalEvaluate(), this.invokePauseChangedMethodsOnTracks(), this.invokeStateChangedMethodsOnTracks()));
  }
  /**
   * Stop the timeline.
   */
  stop() {
    this._isStopping = !0;
    for (const i of this._audioTracks) i.stop();
    const e = this._isPaused == !0, t = this._isPlaying;
    this._isPlaying && (this._time = 0, this._isPlaying = !1, this._isPaused = !1, this.internalEvaluate(), e && this.invokePauseChangedMethodsOnTracks()), this._isPlaying = !1, this._isPaused = !1, e && !t && this.invokePauseChangedMethodsOnTracks(), t && this.invokeStateChangedMethodsOnTracks(), this._internalUpdateRoutine && this.stopCoroutine(this._internalUpdateRoutine), this._internalUpdateRoutine = null, this._isStopping = !1;
  }
  /**
   * Evaluate the timeline at the current time. This is useful when you want to manually update the timeline e.g. when the timeline is paused and you set `time` to a new value.
   */
  evaluate() {
    this.internalEvaluate(!0);
  }
  /**
   * @returns true if the timeline is valid and has tracks
   */
  isValid() {
    return this.playableAsset && this.playableAsset.tracks && Array.isArray(this.playableAsset.tracks);
  }
  /** Iterates over all tracks of the timeline
   * @returns all tracks of the timeline
   */
  *forEachTrack() {
    for (const e of this._allTracks)
      for (const t of e)
        yield t;
  }
  /**
   * @returns all animation tracks of the timeline
   */
  get animationTracks() {
    return this._animationTracks;
  }
  /**
   * @returns all audio tracks of the timeline
   */
  get audioTracks() {
    return this._audioTracks;
  }
  _guidsMap;
  /** @internal */
  resolveGuids(e) {
    this._guidsMap = e;
  }
  // INTERNALS
  _isPlaying = !1;
  _internalUpdateRoutine;
  _isPaused = !1;
  /** internal, true during the time stop() is being processed */
  _isStopping = !1;
  _time = 0;
  _duration = 0;
  _weight = 1;
  _animationTracks = [];
  _audioTracks = [];
  _signalTracks = [];
  _controlTracks = [];
  _customTracks = [];
  _allTracks = [
    this._animationTracks,
    this._audioTracks,
    this._signalTracks,
    this._controlTracks,
    this._customTracks
  ];
  /** should be called after evaluate if the director was playing */
  invokePauseChangedMethodsOnTracks() {
    for (const e of this.forEachTrack())
      e.onPauseChanged?.call(e);
  }
  invokeStateChangedMethodsOnTracks() {
    for (const e of this.forEachTrack())
      e.onStateChanged?.call(e, this._isPlaying);
  }
  *internalUpdate() {
    for (; this._isPlaying && this.activeAndEnabled; )
      !this._isPaused && this._isPlaying && (this._time += this.context.time.deltaTime * this.speed, this.internalEvaluate()), yield;
  }
  /**
   * PlayableDirector lifecycle should always call this instead of "evaluate"
   * @param called_by_user If true the evaluation is called by the user (e.g. via evaluate())
   */
  internalEvaluate(e = !1) {
    if (!this.isValid()) return;
    let t = this._time;
    switch (this.extrapolationMode) {
      case 0:
        this._speed > 0 ? t = Math.min(t, this._duration) : this._speed < 0 && (t = Math.max(t, 0)), this._time = t;
        break;
      case 1:
        t %= this._duration, this._time = t;
        break;
      case 2:
        if (t > this._duration) {
          this.stop();
          return;
        }
        break;
    }
    const i = this._time;
    for (const n of this.playableAsset.tracks)
      if (!n.muted)
        switch (n.type) {
          case Fi.Activation:
            if (!e && !this._isPlaying) continue;
            for (let o = 0; o < n.outputs.length; o++) {
              const r = n.outputs[o];
              if (typeof r == "object") {
                let a = !1;
                if (n.clips)
                  for (const c of n.clips)
                    c.start <= i && i <= c.end && (a = !0);
                const l = r;
                l.visible !== void 0 && l.visible !== a && (l.visible = a, is && console.warn(this.name, "set ActivationTrack-" + o, l.name, a, i));
              }
            }
            break;
        }
    if (!this._isStopping)
      for (const n of this._animationTracks)
        n.evaluate(i);
    for (const n of this._audioTracks)
      n.evaluate(i);
    for (const n of this._signalTracks)
      n.evaluate(i);
    for (const n of this._controlTracks)
      n.evaluate(i);
    for (const n of this._customTracks)
      n.evaluate(i);
  }
  resolveBindings() {
    if (this._clonedPlayableAsset || (this._clonedPlayableAsset = !0, this.playableAsset = Xd(this.playableAsset)), !this.playableAsset || !this.playableAsset.tracks) return;
    const e = this.findRoot(this.gameObject);
    for (const t of this.playableAsset.tracks) {
      for (let i = t.outputs.length - 1; i >= 0; i--) {
        let n = t.outputs[i];
        if (typeof n == "string") {
          this._guidsMap && this._guidsMap[n] && (n = this._guidsMap[n]);
          const o = S.findByGuid(n, e);
          o === null || typeof o != "object" ? (t.outputs.splice(i, 1), console.warn("Failed to resolve binding", n, t.name, t.type)) : (is && console.log("Resolved binding", n, "to", o), t.outputs[i] = o);
        } else if (n === null) {
          if (t.outputs.splice(i, 1), fm.createTrackFunctions[t.type])
            continue;
          t.type !== Fi.Audio && t.type !== Fi.Control && t.type !== Fi.Marker && t.type !== Fi.Signal && console.warn("Missing binding", n, t.name, t.type, this.name, this.playableAsset.name);
        }
      }
      if (t.type === Fi.Control && t.clips)
        for (let i = 0; i < t.clips.length; i++) {
          const n = t.clips[i];
          let o = n.asset.sourceObject;
          if (typeof o == "string") {
            this._guidsMap && this._guidsMap[o] && (o = this._guidsMap[o]);
            const r = S.findByGuid(o, e);
            r === null || typeof r != "object" ? console.warn("Failed to resolve sourceObject binding", o, t.name, n) : (is && console.log("Resolved binding", o, "to", r), n.asset.sourceObject = r);
          }
        }
    }
  }
  findRoot(e) {
    return e.parent ? this.findRoot(e.parent) : e;
  }
  updateTimelineDuration() {
    if (this._duration = 0, !(!this.playableAsset || !this.playableAsset.tracks)) {
      for (const e of this.playableAsset.tracks)
        if (e.muted !== !0) {
          if (e.clips)
            for (const t of e.clips)
              t.end > this._duration && (this._duration = t.end);
          if (e.markers)
            for (const t of e.markers)
              t.time > this._duration && (this._duration = t.time + 1e-3);
        }
    }
  }
  setupAndCreateTrackHandlers() {
    if (this._animationTracks.length = 0, this._audioTracks.length = 0, this._signalTracks.length = 0, !this.playableAsset) return;
    let e = S.findObjectOfType(to, this.context);
    for (const t of this.playableAsset.tracks) {
      const i = t.type, n = fm.createTrackFunctions[i];
      if (n != null) {
        const o = n(this, t);
        if (typeof o.evaluate == "function") {
          o.director = this, o.track = t, this._customTracks.push(o);
          continue;
        }
      }
      if (t.type === Fi.Animation) {
        if (!t.clips || t.clips.length <= 0) {
          is && console.warn("Animation track has no clips", t);
          continue;
        }
        for (let o = t.outputs.length - 1; o >= 0; o--) {
          let r = t.outputs[o];
          if (r instanceof M) {
            const l = S.getOrAddComponent(r, kt);
            l && (r = l);
          }
          const a = r?.gameObject?.animations;
          if (a) {
            const l = new Kg();
            l.trackOffset = t.trackOffset, l.director = this, l.track = t;
            for (let c = 0; c < t.clips.length; c++) {
              const h = t.clips[c], d = h.asset;
              if (!d) {
                console.error(`Timeline ${this.name}: clip #${c} on track "${t.name}" has no animation data`);
                continue;
              }
              const f = d.clip;
              let p = f;
              if ((typeof p == "string" || typeof p == "number") && (p = a.find((b) => b.name === f)), is && console.log(d, f, "→", p), !p) {
                console.warn("Could not find animationClip for model", h, t.name, this.name, this.playableAsset?.name, a, r);
                continue;
              }
              r instanceof kt && r.runtimeAnimatorController && (r.__internalDidAwakeAndStart || r.initializeRuntimeAnimatorController(), r.runtimeAnimatorController.mixer || r.runtimeAnimatorController.bind(r), l.mixer = r.runtimeAnimatorController.mixer), l.mixer || (l.mixer = new Cm(r.gameObject), this.context.animations.registerAnimationMixer(l.mixer)), l.clips.push(p), l.mixer.uncacheAction(p), l.createHooks(h.asset, p);
              const g = l.mixer.clipAction(p);
              l.actions.push(g), l.models.push(h);
            }
            this._animationTracks.push(l);
          }
        }
      } else if (t.type === Fi.Audio) {
        if (!t.clips || t.clips.length <= 0) continue;
        const o = new no();
        o.director = this, o.track = t, o.audioSource = t.outputs.find((r) => r instanceof Xi), this._audioTracks.push(o), e || (e = this.context.mainCameraComponent?.gameObject.addComponent(to)), o.listener = e.listener;
        for (let r = 0; r < t.clips.length; r++) {
          const a = t.clips[r];
          o.addModel(a);
        }
      } else if (t.type === Fi.Marker) {
        const o = new Ld();
        if (o.director = this, o.track = t, t.markers)
          for (const r of t.markers)
            switch (r.type) {
              case Uw.Signal:
                o.models.push(r), o.didTrigger.push(!1);
                break;
            }
        if (o !== null && o.models.length > 0) {
          const r = S.getComponent(this.gameObject, Vu);
          r && (o.receivers.push(r), this._signalTracks.push(o));
        }
      } else if (t.type === Fi.Signal) {
        const o = new Ld();
        if (o.director = this, o.track = t, t.markers)
          for (const r of t.markers)
            o.models.push(r), o.didTrigger.push(!1);
        for (const r of t.outputs)
          o.receivers.push(r);
        this._signalTracks.push(o);
      } else if (t.type === Fi.Control) {
        const o = new Zg();
        if (o.director = this, o.track = t, t.clips)
          for (const r of t.clips)
            o.models.push(r);
        o.resolveSourceObjects(this.context), this._controlTracks.push(o);
      }
    }
  }
  setAudioTracksAllowPlaying(e) {
    for (const t of this._audioTracks)
      t.onAllowAudioChanged(e);
  }
  /** Experimental support for overriding timeline animation data (position or rotation) */
  animationCallbackReceivers = [];
  /** Experimental: Receive callbacks for timeline animation. Allows modification of final value */
  registerAnimationCallback(e) {
    this.animationCallbackReceivers.push(e);
  }
  /** Experimental: Unregister callbacks for timeline animation. Allows modification of final value */
  unregisterAnimationCallback(e) {
    const t = this.animationCallbackReceivers.indexOf(e);
    t !== -1 && this.animationCallbackReceivers.splice(t, 1);
  }
};
Nw([
  u()
], Jg.prototype, "playOnAwake");
Nw([
  u()
], Jg.prototype, "extrapolationMode");
let Ia = Jg;
var _A = Object.defineProperty, Gu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && _A(e, t, n), n;
};
class il extends R {
  isGizmo = !1;
  translationSnap = 1;
  rotationSnapAngle = 15;
  scaleSnap = 0.25;
  /**
   * Gets the underlying three.js {@link TransformControls} instance.
   * @returns The TransformControls instance or undefined if not initialized.
   */
  get control() {
    return this._control;
  }
  _control;
  orbit;
  /** @internal */
  onEnable() {
    if (!(this.isGizmo && !Sc) && this.context.mainCamera && (this._control || (this._control = new NS(this.context.mainCamera, this.context.renderer.domElement), this._control.enabled = !0, this._control.getRaycaster().layers.set(2), this._control.size = 1, ("_root" in this._control ? this._control._root : this._control).traverse((t) => {
      const i = t;
      if (i.layers.set(2), i) {
        const n = i.material;
        n && (n.opacity = 0.3);
      }
    }), this.orbit = S.getComponentInParent(this.context.mainCamera, ye) ?? void 0), this._control)) {
      const e = this._control.getHelper();
      this.context.scene.add(e), this._control.attach(this.gameObject), this._control?.addEventListener("dragging-changed", this.onControlChangedEvent), window.addEventListener("keydown", this.windowKeyDownListener), window.addEventListener("keyup", this.windowKeyUpListener);
    }
  }
  /** @internal */
  onDisable() {
    this._control?.getHelper()?.removeFromParent(), this._control?.removeEventListener("dragging-changed", this.onControlChangedEvent), window.removeEventListener("keydown", this.windowKeyDownListener), window.removeEventListener("keyup", this.windowKeyUpListener);
  }
  /**
   * Enables grid snapping for transform operations according to set snap values.
   * This applies the translationSnap, rotationSnapAngle, and scaleSnap properties to the controls.
   */
  enableSnapping() {
    this._control && (this._control.setTranslationSnap(this.translationSnap), this._control.setRotationSnap(ys.degToRad(this.rotationSnapAngle)), this._control.setScaleSnap(this.scaleSnap));
  }
  /**
   * Disables grid snapping for transform operations.
   * Removes all snapping constraints from the transform controls.
   */
  disableSnapping() {
    this._control && (this._control.setTranslationSnap(null), this._control.setRotationSnap(null), this._control.setScaleSnap(null));
  }
  /**
   * Event handler for when dragging state changes.
   * Disables orbit controls during dragging and requests ownership of the transform if it's synchronized.
   * @param event The drag change event
   */
  onControlChangedEvent = (e) => {
    const t = this.orbit;
    if (t && (t.enabled = !e.value), e.value) {
      const i = this.gameObject.getComponentInParent(zn);
      i && (i.fastMode = !0, i.requestOwnership());
    } else {
      const i = this.gameObject.getComponentInParent(zn);
      i && (i.fastMode = !1);
    }
  };
  /**
   * Handles keyboard shortcuts for transform operations:
   * - Q: Toggle local/world space
   * - W: Translation mode
   * - E: Rotation mode
   * - R: Scale mode
   * - Shift: Enable snapping (while held)
   * - +/-: Adjust gizmo size
   * - X/Y/Z: Toggle visibility of respective axis
   * - Spacebar: Toggle controls enabled state
   * @param event The keyboard event
   */
  windowKeyDownListener = (e) => {
    if (this.enabled && this._control)
      switch (e.keyCode) {
        case 81:
          this._control.setSpace(this._control.space === "local" ? "world" : "local");
          break;
        case 16:
          this.enableSnapping();
          break;
        case 87:
          this._control.setMode("translate");
          break;
        case 69:
          this._control.setMode("rotate");
          break;
        case 82:
          this._control.setMode("scale");
          break;
        case 187:
        case 107:
          this._control.setSize(this._control.size + 0.1);
          break;
        case 189:
        case 109:
          this._control.setSize(Math.max(this._control.size - 0.1, 0.1));
          break;
        case 88:
          this._control.showX = !this._control.showX;
          break;
        case 89:
          this._control.showY = !this._control.showY;
          break;
        case 90:
          this._control.showZ = !this._control.showZ;
          break;
        case 32:
          this._control.enabled = !this._control.enabled;
          break;
      }
  };
  /**
   * Handles keyboard key release events.
   * Currently only handles releasing Shift key to disable snapping.
   * @param event The keyboard event
   */
  windowKeyUpListener = (e) => {
    if (this.enabled)
      switch (e.keyCode) {
        case 16:
          this.disableSnapping();
          break;
      }
  };
}
Gu([
  u()
], il.prototype, "isGizmo");
Gu([
  u()
], il.prototype, "translationSnap");
Gu([
  u()
], il.prototype, "rotationSnapAngle");
Gu([
  u()
], il.prototype, "scaleSnap");
var bA = Object.defineProperty, vA = Object.getOwnPropertyDescriptor, qu = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? vA(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && bA(e, t, n), n;
};
class ey {
  texture = null;
  rect;
}
qu([
  u(Te)
], ey.prototype, "texture", 2);
let Qc = class extends ku {
  set image(e) {
    this.sprite || (this.sprite = new ey()), this.sprite.texture = e, this.onAfterCreated();
  }
  get image() {
    return this.sprite ? this.sprite.texture : null;
  }
  get sprite() {
    return this._sprite;
  }
  set sprite(e) {
    this._sprite !== e && (this._sprite = e, this.onAfterCreated());
  }
  _sprite;
  pixelsPerUnitMultiplier = 1;
  isBuiltinSprite() {
    const e = this.sprite;
    switch (e?.texture?.name) {
      case "InputFieldBackground":
      case "UISprite":
      case "Background":
      case "Knob":
        return !0;
    }
    return !e?.texture?.name?.length && e?.texture?.image?.width === 32 && e?.texture?.image?.height === 32;
  }
  onBeforeCreate(e) {
    super.onBeforeCreate(e), this.isBuiltinSprite() && (e.borderRadius = 5 / this.pixelsPerUnitMultiplier, this.sprite?.texture?.name === "Knob" && (e.borderRadius = 999));
  }
  onAfterCreated() {
    this.__didAwake && (super.onAfterCreated(), !this.isBuiltinSprite() && this.setTexture(this.sprite?.texture));
  }
};
qu([
  u(ey)
], Qc.prototype, "sprite", 1);
qu([
  u()
], Qc.prototype, "pixelsPerUnitMultiplier", 2);
class ty extends ku {
  get mainTexture() {
    return this._mainTexture;
  }
  set mainTexture(e) {
    this._mainTexture !== e && (this._mainTexture = e, this.onAfterCreated());
  }
  _mainTexture;
  onAfterCreated() {
    this.__didAwake && (super.onAfterCreated(), this.setTexture(this.mainTexture));
  }
}
qu([
  u(Te)
], ty.prototype, "mainTexture", 1);
var wA = Object.defineProperty, xA = Object.getOwnPropertyDescriptor, Ti = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? xA(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && wA(e, t, n), n;
};
const No = w("debugbutton");
class Ro {
  colorMultiplier;
  disabledColor;
  fadeDuration;
  highlightedColor;
  normalColor;
  pressedColor;
  selectedColor;
}
Ti([
  u()
], Ro.prototype, "colorMultiplier", 2);
Ti([
  u(oe)
], Ro.prototype, "disabledColor", 2);
Ti([
  u()
], Ro.prototype, "fadeDuration", 2);
Ti([
  u(oe)
], Ro.prototype, "highlightedColor", 2);
Ti([
  u(oe)
], Ro.prototype, "normalColor", 2);
Ti([
  u(oe)
], Ro.prototype, "pressedColor", 2);
Ti([
  u(oe)
], Ro.prototype, "selectedColor", 2);
class SA {
  disabledTrigger;
  highlightedTrigger;
  normalTrigger;
  pressedTrigger;
  selectedTrigger;
}
class To extends R {
  /**
   * Invokes the onClick event
   */
  click() {
    this.onClick?.invoke();
  }
  onClick = new ce();
  _isHovered = 0;
  onPointerEnter(e) {
    const t = e.event.pointerType === "mouse" && e.button === 0;
    t && (this._isHovered += 1), No && console.warn("Button Enter", t, this._isHovered, this.animationTriggers?.highlightedTrigger, this.animator), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.highlightedTrigger) : this.transition === 1 && this.colors && this._image?.setState("hovered"), t && this.context.input.setCursor("pointer"));
  }
  onPointerExit() {
    this._isHovered -= 1, this._isHovered < 0 && (this._isHovered = 0), No && console.log("Button Exit", this._isHovered, this.animationTriggers?.highlightedTrigger, this.animator), this.interactable && (this._isHovered > 0 || (this._isHovered = 0, this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.normalTrigger) : this.transition === 1 && this.colors && this._image?.setState("normal"), this.context.input.unsetCursor("pointer")));
  }
  onPointerDown(e) {
    No && console.log("Button Down", this.animationTriggers?.highlightedTrigger, this.animator), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.pressedTrigger) : this.transition === 1 && this.colors && this._image?.setState("pressed"));
  }
  onPointerUp(e) {
    No && console.warn("Button Up", this.animationTriggers?.highlightedTrigger, this.animator, this._isHovered), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this._isHovered ? this.animationTriggers.highlightedTrigger : this.animationTriggers.normalTrigger) : this.transition === 1 && this.colors && this._image?.setState(this._isHovered ? "hovered" : "normal"));
  }
  onPointerClick(e) {
    if (this.interactable && !(e.button !== 0 && e.event.pointerType === Um.Mouse) && (No && (console.warn("Button Click", this.onClick), Be("CLICKED button " + this.name + " at " + this.context.time.frameCount)), this.onClick && this.onClick.listenerCount > 0 && (this.onClick.invoke(), e.use(), No))) {
      const t = this.gameObject.worldPosition;
      t.add(this.gameObject.worldUp.multiplyScalar(1 + Math.random() * 0.5)), z.DrawLabel(t, "CLICK:" + Date.now(), 0.1, 1 + Math.random() * 0.5);
    }
  }
  colors;
  transition;
  animationTriggers;
  animator;
  set interactable(e) {
    this._interactable = e, this._image && (this._image.setInteractable(e), e ? this._image.setState("normal") : this._image.setState("disabled"));
  }
  get interactable() {
    return this._interactable;
  }
  _interactable = !0;
  set_interactable(e) {
    this.interactable = e;
  }
  awake() {
    super.awake(), No && console.log(this), this._isInit = !1, this.init();
  }
  start() {
    this._image?.setInteractable(this.interactable), this.gameObject.getComponentInParent(Ta) || this.gameObject.addComponent(rg);
  }
  onEnable() {
    super.onEnable();
  }
  onDestroy() {
    this._isHovered && this.context.input.unsetCursor("pointer");
  }
  _requestedAnimatorTrigger;
  *setAnimatorTriggerAtEndOfFrame(e) {
    this._requestedAnimatorTrigger = e, yield, yield, this._requestedAnimatorTrigger == e && this.animator?.setTrigger(e);
  }
  _isInit = !1;
  _image;
  init() {
    this._isInit || (this._isInit = !0, this._image = S.getComponent(this.gameObject, Qc), this._image && (this.stateSetup(this._image), this.interactable ? this._image.setState("normal") : this._image.setState("disabled")));
  }
  stateSetup(e) {
    e.setInteractable(this.interactable);
    const t = this.getFinalColor(e.color, this.colors?.normalColor), i = {
      state: "normal",
      attributes: {
        backgroundColor: t,
        backgroundOpacity: t.alpha
      }
    };
    e.setupState(i);
    const n = this.getFinalColor(e.color, this.colors?.highlightedColor), o = {
      state: "hovered",
      attributes: {
        backgroundColor: n,
        backgroundOpacity: n.alpha
      }
    };
    e.setupState(o);
    const r = this.getFinalColor(e.color, this.colors?.pressedColor), a = {
      state: "pressed",
      attributes: {
        backgroundColor: r,
        backgroundOpacity: r.alpha
      }
    };
    e.setupState(a);
    const l = this.getFinalColor(e.color, this.colors?.selectedColor), c = {
      state: "selected",
      attributes: {
        backgroundColor: l,
        backgroundOpacity: l.alpha
      }
    };
    e.setupState(c);
    const h = this.getFinalColor(e.color, this.colors?.disabledColor), d = {
      state: "disabled",
      attributes: {
        backgroundColor: h,
        // @marwie, this disabled alpha property doesn't seem to have the opacity requested in unity
        backgroundOpacity: h.alpha
      }
    };
    e.setupState(d);
  }
  getFinalColor(e, t) {
    return t ? e.clone().multiply(t).convertLinearToSRGB() : e.clone().convertLinearToSRGB();
  }
}
Ti([
  u(ce)
], To.prototype, "onClick", 2);
Ti([
  u(Ro)
], To.prototype, "colors", 2);
Ti([
  u()
], To.prototype, "transition", 2);
Ti([
  u(SA)
], To.prototype, "animationTriggers", 2);
Ti([
  u(kt)
], To.prototype, "animator", 2);
Ti([
  u()
], To.prototype, "interactable", 1);
var CA = Object.defineProperty, Xu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && CA(e, t, n), n;
};
const Vs = w("debuginputfield"), Yc = class Q extends R {
  get text() {
    return this.textComponent?.text ?? "";
  }
  set text(e) {
    this.textComponent && (this.textComponent.text = e, this.placeholder && (e.length > 0 ? this.placeholder.gameObject.visible = !1 : this.placeholder.gameObject.visible = !0));
  }
  get isFocused() {
    return Q.active === this;
  }
  textComponent;
  placeholder;
  onValueChanged;
  onEndEdit;
  static active = null;
  static activeTime = -1;
  static htmlField = null;
  static htmlFieldFocused = !1;
  inputEventFn;
  _iosEventFn;
  start() {
    Vs && console.log(this.name, this);
  }
  onEnable() {
    Q.htmlField || (Q.htmlField = document.createElement("input"), Q.htmlField.style.width = "0px", Q.htmlField.style.height = "0px", Q.htmlField.style.padding = "0px", Q.htmlField.style.border = "none", Q.htmlField.style.overflow = "hidden", Q.htmlField.style.caretColor = "transparent", Q.htmlField.style.outline = "none", Q.htmlField.classList.add("ar"), Q.htmlField.onfocus = () => Q.htmlFieldFocused = !0, Q.htmlField.onblur = () => Q.htmlFieldFocused = !1, document.body.append(Q.htmlField)), this.inputEventFn || (this.inputEventFn = this.onInput.bind(this)), Q.htmlField.addEventListener("keyup", this.inputEventFn), this.placeholder && this.textComponent?.text.length && S.setActive(this.placeholder.gameObject, !1), q.isiOS() && (this._iosEventFn = this.processInputOniOS.bind(this), window.addEventListener("click", this._iosEventFn));
  }
  onDisable() {
    Q.htmlField?.removeEventListener("keyup", this.inputEventFn), this.onDeselected(), this._iosEventFn && window.removeEventListener("click", this._iosEventFn);
  }
  /** Clear the input field if it's currently active */
  clear() {
    Q.active === this && Q.htmlField ? (Q.htmlField.value = "", this.setTextFromInputField()) : (this.textComponent && (this.textComponent.text = ""), this.placeholder && S.setActive(this.placeholder.gameObject, !0));
  }
  /** Select the input field, set it active to receive keyboard input */
  select() {
    this.onSelected();
  }
  /** Deselect the input field, stop receiving keyboard input */
  deselect() {
    this.onDeselected();
  }
  onPointerEnter(e) {
    e.event.pointerType === "mouse" && e.button === 0 && this.context.input.setCursor("text");
  }
  onPointerExit(e) {
    this.context.input.unsetCursor("text");
  }
  onPointerClick(e) {
    Vs && console.log("CLICK", e, Q.active), Q.activeTime = this.context.time.time, Q.active !== this && this.startCoroutine(this.activeLoop(), xe.LateUpdate), this.selectInputField();
  }
  *activeLoop() {
    for (this.onSelected(); Q.active === this && !(this.context.input.getPointerClicked(0) && this.context.time.time - Q.activeTime > 0.2); )
      this.setTextFromInputField(), yield;
    this.onDeselected();
  }
  onSelected() {
    if (Q.active !== this && (Vs && console.log("Select", this.name, this, Q.htmlField, this.context.isInXR, this.context.arOverlayElement, this.textComponent?.text, Q.htmlField?.value), Q.active?.onDeselected(), Q.active = this, this.placeholder && S.setActive(this.placeholder.gameObject, !1), Q.htmlField)) {
      if (Q.htmlField.value = this.textComponent?.text || "", Vs && console.log("set input field value", Q.htmlField.value), this.context.isInXR) {
        const e = this.context.arOverlayElement;
        e && e.append(Q.htmlField);
      }
      this.selectInputField();
    }
  }
  onDeselected() {
    Q.active === this && (Q.active = null, Vs && console.log("Deselect", this.name, this), Q.htmlField && (Q.htmlField.blur(), document.body.append(Q.htmlField)), this.placeholder && (!this.textComponent || this.textComponent.text.length <= 0) && S.setActive(this.placeholder.gameObject, !0), Q.htmlField && this.onEndEdit?.invoke(Q.htmlField.value));
  }
  // @Marwie, I can provide this fix. But the issue seems to comes from Raycaster+EventSystem
  // As we rollout InputField, and no others elements is behind raycast,
  // ThreeMeshUI.update is not called.
  update() {
    Q.active === this && this.textComponent?.markDirty();
  }
  onInput(e) {
    if (Q.active === this) {
      if (Vs && console.log(e.code, e, Q.htmlField?.value, this.textComponent?.text), e.code === "Escape" || e.code === "Enter") {
        this.onDeselected();
        return;
      }
      Q.htmlField && (this.textComponent && (this.setTextFromInputField(), this.placeholder && S.setActive(this.placeholder.gameObject, this.textComponent.text.length <= 0)), this.selectInputField());
    }
  }
  setTextFromInputField() {
    if (this.textComponent && Q.htmlField) {
      const e = this.textComponent.text, t = Q.htmlField.value, i = this.textComponent.text !== Q.htmlField.value;
      this.textComponent.text = Q.htmlField.value, i && (Vs && console.log("[InputField] value changed:", t, e), this.onValueChanged?.invoke(t, e));
    }
  }
  selectInputField() {
    Q.htmlField && (Vs && console.log("Focus Inputfield", Q.htmlFieldFocused), Q.htmlField.setSelectionRange(Q.htmlField.value.length, Q.htmlField.value.length), q.isiOS() ? Q.htmlField.focus({ preventScroll: !0 }) : setTimeout(() => Q.htmlField?.focus(), 1));
  }
  processInputOniOS() {
    const e = this.context.physics.raycast();
    if (!e.length) return;
    const i = e[0].object, n = ag(i);
    (n?.gameObject === this.gameObject || n?.gameObject.parent === this.gameObject) && this.selectInputField();
  }
  // private static _lastDeletionTime: number = 0;
  // private static _lastKeyInputTime: number = 0;
  // TODO: support modifiers, refactor to not use backspace as string etc
  // private handleKey(key: string | null) {
  //     if (!this.textComponent) return;
  //     if (!key) return;
  //     InputField._lastKey = key || "";
  //     const text = this.textComponent.text;
  //     if (debug)
  //         console.log(key, text);
  //     switch (key) {
  //         case "Backspace":
  //             this.deleteLetter();
  //             break;
  //         default:
  //             this.appendLetter(key);
  //             break;
  //     }
  // }
  // private appendLetter(key: string | null) {
  //     if (this.textComponent && key) {
  //         const timeSinceLastInput = this.context.time.time - InputField._lastKeyInputTime;
  //         if (key.length === 1 && (this.context.input.getKeyDown() === key || timeSinceLastInput > .1)) {
  //             this.textComponent.text += key;
  //             InputField._lastKeyInputTime = this.context.time.time;
  //         }
  //     }
  // }
  // private deleteLetter() {
  //     if (this.textComponent) {
  //         const text = this.textComponent.text;
  //         if (text.length > 0 && this.context.time.time - InputField._lastDeletionTime > 0.05) {
  //             this.textComponent.text = text.slice(0, -1);
  //             InputField._lastDeletionTime = this.context.time.time;
  //         }
  //     }
  // }
};
Xu([
  u(Xt)
], Yc.prototype, "textComponent");
Xu([
  u(Xt)
], Yc.prototype, "placeholder");
Xu([
  u(ce)
], Yc.prototype, "onValueChanged");
Xu([
  u(ce)
], Yc.prototype, "onEndEdit");
let $w = Yc;
var PA = Object.defineProperty, Ww = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && PA(e, t, n), n;
};
class Qu extends R {
  id = null;
  keepAspect = !1;
  _object = null;
  onEnable() {
    if (this._object) {
      this.gameObject.add(this._object);
      return;
    }
    if (!this.id || !this.context.mainCamera) return;
    const e = document.getElementById(this.id);
    if (!e) {
      console.warn('Could not find element with id "' + this.id + '"');
      return;
    }
    e.style.display = "block", e.style.visibility = "hidden";
    const t = new $S();
    t.listenToPointerEvents(this.context.renderer, this.context.mainCamera), this.gameObject.add(t);
    const i = new WS(e);
    t.add(i), i.visible = !1;
    const n = i.material;
    n.transparent = !0, setTimeout(() => {
      i.visible = !0;
      const o = Dm(this.gameObject).clone();
      Kd(this.gameObject, 0, 0, 0), this.gameObject.updateMatrixWorld();
      const r = new bi();
      r.setFromObject(t), this.setWorldRotation(o.x, o.y, o.z);
      const a = r.max.x - r.min.x, l = r.max.y - r.min.y;
      if (this.keepAspect) {
        const h = a / l;
        a > l ? i.scale.set(1 / a, 1 / l / h, 1) : i.scale.set(1 / a * h, 1 / l, 1);
      } else
        i.scale.set(1 / a, 1 / l, 1);
      const c = this.gameObject.scale;
      i.scale.multiply(c);
    }, 1);
  }
  onDisable() {
    this._object?.removeFromParent();
  }
}
Ww([
  u()
], Qu.prototype, "id");
Ww([
  u()
], Qu.prototype, "keepAspect");
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OA = {
  topLight: {
    intensity: 500,
    position: [0.418, 16.199, 0.3]
  },
  room: {
    position: [-0.757, 13.219, 0.717],
    scale: [31.713, 28.305, 28.591]
  },
  boxes: [
    {
      position: [-10.906, 2.009, 1.846],
      rotation: -0.195,
      scale: [2.328, 7.905, 4.651]
    },
    {
      position: [-5.607, -0.754, -0.758],
      rotation: 0.994,
      scale: [1.97, 1.534, 3.955]
    },
    {
      position: [6.167, 0.857, 7.803],
      rotation: 0.561,
      scale: [3.927, 6.285, 3.687]
    },
    {
      position: [-2.017, 0.018, 6.124],
      rotation: 0.333,
      scale: [2.002, 4.566, 2.064]
    },
    {
      position: [2.291, -0.756, -2.621],
      rotation: -0.286,
      scale: [1.546, 1.552, 1.496]
    },
    {
      position: [-2.193, -0.369, -5.547],
      rotation: 0.516,
      scale: [3.875, 3.487, 2.986]
    }
  ],
  lights: [
    {
      intensity: 50,
      position: [-16.116, 14.37, 8.208],
      scale: [0.1, 2.428, 2.739]
    },
    {
      intensity: 50,
      position: [-16.109, 18.021, -8.207],
      scale: [0.1, 2.425, 2.751]
    },
    {
      intensity: 17,
      position: [14.904, 12.198, -1.832],
      scale: [0.15, 4.265, 6.331]
    },
    {
      intensity: 43,
      position: [-0.462, 8.89, 14.52],
      scale: [4.38, 5.441, 0.088]
    },
    {
      intensity: 20,
      position: [3.235, 11.486, -12.541],
      scale: [2.5, 2, 0.1]
    },
    {
      intensity: 100,
      position: [0, 20, 0],
      scale: [1, 0.1, 1]
    }
  ]
}, kA = {
  topLight: {
    intensity: 400,
    position: [0.5, 14, 0.5]
  },
  room: {
    position: [0, 13.2, 0],
    scale: [31.5, 28.5, 31.5]
  },
  boxes: [
    {
      position: [-10.906, -1, 1.846],
      rotation: -0.195,
      scale: [2.328, 7.905, 4.651]
    },
    {
      position: [-5.607, -0.754, -0.758],
      rotation: 0.994,
      scale: [1.97, 1.534, 3.955]
    },
    {
      position: [6.167, -0.16, 7.803],
      rotation: 0.561,
      scale: [3.927, 6.285, 3.687]
    },
    {
      position: [-2.017, 0.018, 6.124],
      rotation: 0.333,
      scale: [2.002, 4.566, 2.064]
    },
    {
      position: [2.291, -0.756, -2.621],
      rotation: -0.286,
      scale: [1.546, 1.552, 1.496]
    },
    {
      position: [-2.193, -0.369, -5.547],
      rotation: 0.516,
      scale: [3.875, 3.487, 2.986]
    }
  ],
  lights: [
    {
      intensity: 80,
      position: [-14, 10, 8],
      scale: [0.1, 2.5, 2.5]
    },
    {
      intensity: 80,
      position: [-14, 14, -4],
      scale: [0.1, 2.5, 2.5]
    },
    {
      intensity: 23,
      position: [14, 12, 0],
      scale: [0.1, 5, 5]
    },
    {
      intensity: 16,
      position: [0, 9, 14],
      scale: [5, 5, 0.1]
    },
    {
      intensity: 80,
      position: [7, 8, -14],
      scale: [2.5, 2.5, 0.1]
    },
    {
      intensity: 80,
      position: [-7, 16, -14],
      scale: [2.5, 2.5, 0.1]
    },
    {
      intensity: 1,
      position: [0, 20, 0],
      scale: [0.1, 0.1, 0.1]
    }
  ]
};
class iy extends wi {
  constructor(e) {
    super(), this.position.y = -3.5;
    const t = new pa();
    t.deleteAttribute("uv");
    const i = new ut({ metalness: 0, side: Gd }), n = new ut({ metalness: 0 }), o = e == "legacy" ? OA : kA, r = new vm(16777215, o.topLight.intensity, 28, 2);
    r.position.set(...o.topLight.position), this.add(r);
    const a = new G(t, i);
    a.position.set(...o.room.position), a.scale.set(...o.room.scale), this.add(a);
    for (const l of o.boxes) {
      const c = new G(t, n);
      c.position.set(...l.position), c.rotation.set(0, l.rotation, 0), c.scale.set(...l.scale), this.add(c);
    }
    for (const l of o.lights) {
      const c = new G(t, this.createAreaLightMaterial(l.intensity));
      c.position.set(...l.position), c.scale.set(...l.scale), this.add(c);
    }
  }
  createAreaLightMaterial(e) {
    const t = new we();
    return t.color.setScalar(e), t;
  }
}
var MA = Object.defineProperty, Yu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && MA(e, t, n), n;
};
const Kc = class Vw extends R {
  target;
  invertForward = !1;
  keepUpDirection = !0;
  copyTargetRotation = !1;
  static flipYQuat = new U().setFromAxisAngle(new y(0, 1, 0), Math.PI);
  /** @internal */
  onBeforeRender() {
    let e = this.target;
    if (e || (e = this.context.mainCamera), !e) return;
    let t = this.copyTargetRotation;
    (this.context.isInVR || this.context.isInPassThrough) && (t = !1), Yd(this.gameObject, e, this.keepUpDirection, t), this.invertForward && this.gameObject.quaternion.multiply(Vw.flipYQuat);
  }
  /** @internal */
  createBehaviours(e, t, i) {
    if (t.uuid === this.gameObject.uuid) {
      let n = t;
      if (this.keepUpDirection) {
        const r = st.createEmptyParent(t);
        n = r;
        const a = this.invertForward ? -1 : 1;
        r.setMatrix(r.getMatrix().multiply(new ee().makeRotationZ(Math.PI / 2 * a))), t.setMatrix(t.getMatrix().multiply(new ee().makeRotationZ(-Math.PI / 2 * a)));
      }
      const o = new It(
        "lookat " + this.name,
        Gt.sceneStartTrigger(),
        me.lookAtCameraAction(
          n,
          void 0,
          this.invertForward ? Ni.back : Ni.forward,
          this.keepUpDirection ? Ni.up : Ni.zero
        )
      );
      e.addBehavior(o);
    }
  }
};
Yu([
  u(M)
], Kc.prototype, "target");
Yu([
  u()
], Kc.prototype, "invertForward");
Yu([
  u()
], Kc.prototype, "keepUpDirection");
Yu([
  u()
], Kc.prototype, "copyTargetRotation");
let Hw = Kc;
var RA = Object.defineProperty, ny = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && RA(e, t, n), n;
};
class Zc extends R {
  url;
  mode = 0;
  clickable = !0;
  /**
   * Opens the URL in a new tab or window.
   */
  async open() {
    if (!this.url) {
      console.warn("OpenURL: URL is not set, can't open.", this);
      return;
    }
    this._validateUrl();
    let e = this.url;
    switch (!e.startsWith("mailto:") && e.includes("@") && (e = "mailto:" + e), L() && Be("Open URL: " + e), this.mode) {
      case 0:
        q.isSafari(), globalThis.open(e, "_blank");
        break;
      case 1:
        q.isSafari() && q.isiOS() ? globalThis.open(e, "_top") : globalThis.open(e, "_self");
        break;
      case 2:
        q.isSafari() ? globalThis.open(e, "_top") : globalThis.open(e, "_new");
        break;
    }
  }
  /** @internal */
  start() {
    this.gameObject.getComponentInParent(qi) || this.gameObject.addComponent(qi);
  }
  /** @internal */
  onPointerEnter(e) {
    !e.used && this.clickable && this.context.input.setCursor("pointer");
  }
  /** @internal */
  onPointerExit() {
    this.clickable && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerClick(e) {
    this.clickable && !e.used && this.url?.length && this.open();
  }
  _validateUrl() {
    this.url && this.url.startsWith("www.") && (L() && console.warn("URL is not valid, adding https:// to the start of the URL", this.url), this.url = "https://" + this.url);
  }
}
ny([
  u()
], Zc.prototype, "url");
ny([
  u()
], Zc.prototype, "mode");
ny([
  u()
], Zc.prototype, "clickable");
tg((s) => {
  const e = s.domElement.getAttribute("clickthrough");
  e !== null && e !== "0" && e !== "false" && s.scene.addComponent(sy);
});
class sy extends R {
  _previousPointerEvents = "all";
  onEnable() {
    this.context.input.addEventListener("pointerdown", this.onPointerEvent), this.context.input.addEventListener("pointermove", this.onPointerEvent, {
      queue: 100
    }), window.addEventListener("touchend", this.onTouchEnd, { passive: !0 }), this._previousPointerEvents = this.context.domElement.style.pointerEvents;
  }
  onDisable() {
    this.context.input.removeEventListener("pointerdown", this.onPointerEvent), this.context.input.removeEventListener("pointermove", this.onPointerEvent), window.removeEventListener("touchend", this.onTouchEnd), this.context.domElement.style.pointerEvents = this._previousPointerEvents;
  }
  onPointerEnter() {
  }
  onPointerEvent = (e) => {
    if (e.pointerId > 0) return;
    e.intersections?.length <= 0 ? this.context.domElement.style.pointerEvents = "none" : this.context.domElement.style.pointerEvents = "all";
  };
  onTouchEnd = (e) => {
    setTimeout(() => {
      this.context.domElement.style.pointerEvents = "all";
    }, 100);
  };
}
var TA = Object.defineProperty, Gw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && TA(e, t, n), n;
};
class Ku extends R {
  damping = 0;
  keepDistance = !0;
  awake() {
    this._distance = -1;
  }
  _distance = -1;
  updateDistance() {
    this.keepDistance && this._distance !== -1 || (this._distance = this.gameObject.worldPosition.distanceTo(this.context.mainCamera.worldPosition));
  }
  /** @internal */
  update() {
    this.updateDistance();
    const e = this.context.input.mousePositionRC, t = this.context.mainCamera, i = t.worldPosition, n = H(e.x, e.y, 1).unproject(t);
    n.sub(i).normalize();
    const o = n.multiplyScalar(this._distance).add(i);
    if (this.damping > 0) {
      const r = this.gameObject.worldPosition;
      r.lerp(o, this.context.time.deltaTime / this.damping), this.gameObject.worldPosition = r;
    } else
      this.gameObject.worldPosition = o;
  }
}
Gw([
  u()
], Ku.prototype, "damping");
Gw([
  u()
], Ku.prototype, "keepDistance");
var EA = Object.defineProperty, nl = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && EA(e, t, n), n;
};
const Er = class pm extends R {
  target = null;
  damping = 0;
  invert = !1;
  htmlSelector = null;
  mode = "window";
  changed = new ce();
  /**
   * Current scroll value in "pages" (0 = top of page, 1 = bottom of page)
   */
  get currentValue() {
    return this.current_value;
  }
  current_value = 0;
  target_value = 0;
  applied_value = -1;
  /** @internal */
  onEnable() {
    window.addEventListener("wheel", this.updateCurrentScrollValue, { passive: !0 }), this.applied_value = -1;
  }
  /** @internal */
  onDisable() {
    window.removeEventListener("wheel", this.updateCurrentScrollValue);
  }
  /** @internal */
  lateUpdate() {
    if (this.updateCurrentScrollValue(), this.damping > 0 ? this.current_value = j.lerp(this.current_value, this.target_value, this.context.time.deltaTime / this.damping) : this.current_value = this.target_value, this.current_value !== this.applied_value) {
      this.applied_value = this.current_value;
      let e = !1;
      if (this.changed.listenerCount > 0) {
        const t = {
          type: "change",
          value: this.current_value,
          component: this,
          preventDefault: () => {
            t.defaultPrevented = !0;
          },
          defaultPrevented: !1
        };
        this.changed.invoke(t), e = t.defaultPrevented;
      }
      if (!e) {
        const t = this.invert ? 1 - this.current_value : this.current_value;
        Array.isArray(this.target) ? this.target.forEach((i) => i && pm.applyScroll(i, t)) : this.target && pm.applyScroll(this.target, t);
      }
    }
  }
  _lastSelectorValue = null;
  _lastSelectorElement = null;
  updateCurrentScrollValue = () => {
    switch (this.mode) {
      case "window":
        if (this.htmlSelector?.length) {
          if (this.htmlSelector !== this._lastSelectorValue && (this._lastSelectorElement = document.querySelector(this.htmlSelector), this._lastSelectorValue = this.htmlSelector), this._lastSelectorElement) {
            const e = this._lastSelectorElement.getBoundingClientRect();
            this.target_value = -e.top / (e.height - window.innerHeight), (isNaN(this.target_value) || !isFinite(this.target_value)) && (this.target_value = 0);
            break;
          }
        } else
          this.target_value = window.scrollY / (document.body.scrollHeight - window.innerHeight);
        (isNaN(this.target_value) || !isFinite(this.target_value)) && (this.target_value = 0);
        break;
    }
  };
  static applyScroll(e, t) {
    if (e)
      if (e instanceof Ia)
        e.time = t * e.duration, e.isPlaying || e.evaluate();
      else if (e instanceof kt)
        e.setFloat("scroll", t);
      else if (e instanceof ni)
        e.time = t * e.duration;
      else if (e instanceof Xi) {
        if (!e.duration) return;
        e.time = t * e.duration;
      } else if (e instanceof Qn)
        e.position01 = t;
      else if (e instanceof ki)
        e.intensity = t;
      else if (e instanceof M) {
        e["needle:scrollbounds"] === void 0 && (e["needle:scrollbounds"] = ii(e) || null);
        const i = e["needle:scrollbounds"];
        i && (e.position.y = -i.min.y - t * (i.max.y - i.min.y));
      } else "scroll" in e && (typeof e.scroll == "number" ? e.scroll = t : typeof e.scroll == "function" && e.scroll(t));
  }
};
nl([
  u([R, M])
], Er.prototype, "target");
nl([
  u()
], Er.prototype, "damping");
nl([
  u()
], Er.prototype, "invert");
nl([
  u()
], Er.prototype, "htmlSelector");
nl([
  u()
], Er.prototype, "mode");
nl([
  u(ce)
], Er.prototype, "changed");
let qw = Er;
var AA = Object.defineProperty, sl = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && AA(e, t, n), n;
};
class Eo extends R {
  // override active and enabled here so that we always receive xr update events
  get activeAndEnabled() {
    return !0;
  }
  side = "none";
  controller = !0;
  hands = !1;
  controlVisibility = !0;
  useGripSpace = !1;
  resetTransformAfterXRSession = !0;
  _startPosition = new y();
  _startRotation = new U();
  _startScale = new y();
  /** @internal */
  onEnterXR(e) {
    this._startPosition.copy(this.gameObject.position), this._startRotation.copy(this.gameObject.quaternion), this._startScale.copy(this.gameObject.scale);
  }
  /** @internal */
  onUpdateXR(e) {
    if (!this.enabled) return;
    const t = e.xr.getController(this.side);
    if (t) {
      if (t.hand && !this.hands) {
        this.controlVisibility && (this.gameObject.visible = !1);
        return;
      } else if (!this.controller) {
        this.controlVisibility && (this.gameObject.visible = !1);
        return;
      }
      this.controlVisibility && (this.gameObject.visible = !0), this.useGripSpace || t.targetRayMode === "transient-pointer" ? (this.gameObject.worldPosition = t.gripWorldPosition, this.gameObject.worldQuaternion = t.gripWorldQuaternion, this.gameObject.worldScale = H(t.xr.rigScale, t.xr.rigScale, t.xr.rigScale).multiply(this._startScale)) : (this.gameObject.worldPosition = t.rayWorldPosition, this.gameObject.worldQuaternion = t.rayWorldQuaternion, this.gameObject.worldScale = H(t.xr.rigScale, t.xr.rigScale, t.xr.rigScale).multiply(this._startScale));
    }
  }
  /** @internal */
  onLeaveXR(e) {
    this.resetTransformAfterXRSession && (this.gameObject.position.copy(this._startPosition), this.gameObject.quaternion.copy(this._startRotation), this.gameObject.scale.copy(this._startScale));
  }
}
sl([
  u()
], Eo.prototype, "side");
sl([
  u()
], Eo.prototype, "controller");
sl([
  u()
], Eo.prototype, "hands");
sl([
  u()
], Eo.prototype, "controlVisibility");
sl([
  u()
], Eo.prototype, "useGripSpace");
sl([
  u()
], Eo.prototype, "resetTransformAfterXRSession");
function Xw(s, e) {
  const t = s.xr.getFrame();
  if (!t)
    return console.warn("No XRFrame available"), !1;
  const i = t.session.enabledFeatures;
  if (i && !i.some((o) => o === "camera-access"))
    return console.error(`No camera feed available - please request the 'camera-access' feature before starting WebXR or add the ARCameraBackground component to your scene.

Example to request camera-access in global scope:
NeedleXRSession.onSessionRequestStart(evt => {
    evt.init.optionalFeatures = evt.init.optionalFeatures || [];
    evt.init.optionalFeatures.push('camera-access');
});
`), L() && Zd("No camera feed available - please request the 'camera-access' feature before starting WebXR or add the ARCameraBackground component to your scene"), !1;
  const n = t.getViewerPose(s.xr.getReferenceSpace());
  if (n)
    for (const o of n.views)
      if ("camera" in o && o.camera) {
        let r = s.xr.getBinding();
        if (r || (r = new XRWebGLBinding(t.session, s.getContext())), r) {
          let a = null;
          if ("getCameraImage" in r) {
            IA(s, e);
            const l = s.properties.get(e);
            if (l)
              return a = r.getCameraImage(o.camera), l.__webglTexture = a, !0;
            console.warn("No texture properties found for target texture");
          }
        } else
          console.error(o.camera, s.xr);
      } else
        console.error("NO CAMERA IN VIEW");
  else
    console.error(s.xr.getReferenceSpace(), t);
  return !1;
}
const db = /* @__PURE__ */ new WeakMap();
function IA(s, e) {
  const t = db.get(e) || /* @__PURE__ */ new WeakSet();
  if (t.has(s))
    return;
  t.add(s), db.set(e, t), console.debug("Initialize texture for camera feed");
  const i = new we(), n = new Nn(), o = new wi();
  o.add(new G(n, i));
  const r = new de();
  i.map = e, s.render(o, r);
}
function UL(s, e, t, i = "image/webp", n) {
  return Qw({ context: s, width: e, height: t, mimeType: i, camera: n });
}
function Qw(s) {
  s || (s = {});
  const { transparent: e = !1 } = s;
  let { mimeType: t, context: i, width: n, height: o, camera: r } = s;
  if (!i && (i = ue.Current, !i))
    return console.error("Can not save screenshot: No needle-engine context found or provided."), null;
  if (!r && (r = i.mainCamera, !r))
    return console.error("No camera found"), null;
  const a = i.renderer, l = a.xr.enabled && a.xr.isPresenting;
  if (l && i.currentFrameEvent != xe.EarlyUpdate)
    return console.warn("Screenshot: defer to access XR frame"), new Promise((E) => {
      Ms((B) => {
        const D = Qw(s);
        E(D);
      }, xe.EarlyUpdate, { once: !0 });
    });
  const c = a.domElement, h = c.width, d = c.height;
  n || (n = h), o || (o = d);
  const f = n, p = o;
  let g = window.devicePixelRatio || 1, b = 1;
  i.devicePixelRatio === "auto" || i.devicePixelRatio === "manual" ? b = 1 : b = i.devicePixelRatio / window.devicePixelRatio, g *= b, n /= g, o /= g, n = Math.floor(n), o = Math.floor(o), a.xr.isPresenting && a.xr.getFrame();
  const m = a.xr.enabled;
  a.xr.enabled = !1, a.xr.isPresenting = !1, c.style.width = `${n}px`, c.style.height = `${o}px`;
  const v = a.getRenderTarget(), _ = a.getClearColor(new se()), x = a.getClearAlpha(), I = i.scene.background, O = "aspect" in r ? r.aspect : null;
  try {
    const k = s.render_events !== !1, E = new Array();
    k && (Cc(i.scene, Qi, E), E.forEach((A) => {
      if (A?.onBeforeRender(), A.isInstancingActive && A.instances)
        for (let $ = 0; $ < A.instances?.length; $++) {
          const V = A.instances[$];
          ds(V.object, !0);
        }
    })), e && (i.scene.background = null, a.setClearColor(0, 0)), s.background && (i.scene.background = null, a.setClearColor(s.background), s.background instanceof oe && a.setClearAlpha(s.background.a)), e && a.setClearAlpha(0), a.setSize(n, o, !1), "cam" in r && (r = r.threeCamera), r instanceof de && (r.aspect = n / o, r.updateProjectionMatrix());
    const B = "type" in s && s.type === "texture";
    let D = null;
    B && (D = new Dn(n, o, {
      wrapS: hy,
      wrapT: hy,
      format: 1023
    }), a.setRenderTarget(D));
    let W = c;
    if (l ? (D && console.error('Taking XR screenshots with { type: "texture" } is currently not supported.'), W = Dd.compositeWithCameraImage({
      width: f,
      height: p,
      scene: i.scene,
      camera: r,
      renderer: a
    })) : i.renderNow(r || null), r instanceof de && O != null && (r.aspect = O, r.updateProjectionMatrix()), k && E.forEach((A) => A.onAfterRender()), !t && "download_filename" in s && s.download_filename)
      switch (s.download_filename.split(".").pop()?.toLowerCase()) {
        case "png":
          t = "image/png";
          break;
        case "jpg":
        case "jpeg":
          t = "image/jpeg";
          break;
        case "webp":
          t = "image/webp";
          break;
      }
    if (e && s.trim === !0) {
      const A = LA(W);
      A && (W = A);
    }
    if ("type" in s) {
      if (s.type === "texture")
        return D ? (s.target && (s.target.image = D?.texture.image, s.target.needsUpdate = !0), D.texture.offset.set(0, -1), D.texture.needsUpdate = !0, D.texture) : (console.error("No target texture found"), null);
      if (s.type === "blob")
        return new Promise(($, V) => {
          W.toBlob((ne) => {
            $(ne);
          }, t);
        });
      if (s.type === "share")
        return new Promise(($, V) => {
          W.toBlob((ne) => {
            if (ne && "share" in navigator) {
              let re = "file_type" in s && s.file_type || t;
              t || (re = "image/png");
              const pe = re?.split("/")[1] || "png", Se = new File([ne], "filename" in s ? s.filename || `screenshot.${pe}` : `screenshot.${pe}`, { type: re });
              return navigator.share({
                title: "title" in s ? s.title : void 0,
                text: "text" in s ? s.text : void 0,
                url: "url" in s ? s.url : void 0,
                files: [Se]
              }).catch((Je) => {
                console.warn("User cancelled share", Je.message);
              }).finally(() => {
                $({ blob: ne, shared: !0 });
              });
            }
            return {
              blob: ne,
              shared: !1
            };
          }, t);
        });
    }
    const X = W.toDataURL(t);
    if ("download_filename" in s && s.download_filename) {
      let A = s.download_filename;
      if (q.isMobileDevice() && typeof window < "u") {
        const $ = A + "_screenshots", V = A.split("."), ne = V.pop()?.toLowerCase();
        let re = 0;
        localStorage.getItem($) && (re = parseInt(sessionStorage.getItem($) || "0")), re > 0 && (A = `${V.join()}-${re}.${ne}`), re += 1, sessionStorage.setItem($, re.toString());
      }
      DA(X, A);
    }
    return X;
  } finally {
    a.setRenderTarget(v), i.scene.background = I, a.setSize(h, d, !1), a.setClearColor(_, x), O != null && r instanceof de && (r.aspect = O, r.updateProjectionMatrix()), a.xr.enabled = m, a.xr.isPresenting = l, l || i.updateSize(!0);
  }
  return null;
}
function LA(s) {
  if (!("document" in globalThis)) return null;
  const e = document.createElement("canvas");
  e.width = s.width, e.height = s.height;
  const t = e.getContext("2d");
  if (!t) return null;
  t.drawImage(s, 0, 0);
  const i = e.width, n = e.height, r = t.getImageData(0, 0, i, n).data;
  let a = n, l = i, c = 0, h = 0;
  for (let b = 0; b < n; b++)
    for (let m = 0; m < i; m++) {
      const v = (b * i + m) * 4;
      r[v + 3] !== 0 && (m < l && (l = m), m > h && (h = m), b < a && (a = b), b > c && (c = b));
    }
  const d = h - l + 1, f = c - a + 1, p = document.createElement("canvas"), g = p.getContext("2d");
  return g ? (p.width = d, p.height = f, g.drawImage(e, l, a, d, f, 0, 0, d, f), p) : null;
}
let wl = null;
function DA(s, e) {
  if (s) {
    if (!s.startsWith("data:image")) {
      console.error("Can not save image: Data url is not an image", s);
      return;
    }
    wl || (wl = document.createElement("a")), wl.href = s, wl.download = e, wl.click();
  }
}
var Dd;
((s) => {
  let e = null, t = null, i = null, n = null, o = null;
  function r(c) {
    const { renderer: h, width: d, height: f } = c, p = h.xr.enabled, g = h.getRenderTarget(), b = h.autoClear, m = d, v = f, _ = d / f;
    (!i || i.width !== m || i.height !== v) && (i ??= new Dn(m, v, { colorSpace: Cs }), i.width = m, i.height = v, i.samples = 4, i.texture.repeat.y = -1, i.texture.offset.y = 1), (!o || o.width !== m || o.height !== v) && (o = document.createElement("canvas"), o.width = m, o.height = v, o.style.position = "fixed", o.style.top = "0px", o.style.right = "0px", o.style.width = "300px", o.style.height = `${300 / _}px`, o.style.zIndex = "1000", o.style.pointerEvents = "none", o.style.opacity = "1.0", o.style.willChange = "contents"), e || (e = l({
      defines: {
        DECODE_VIDEO_TEXTURE: !0
      }
    })), t || (t = l()), n || (n = new Te()), h.xr.updateCamera(c.camera), h.xr.enabled = !1, h.autoClear = !1, h.clear(), h.setSize(m, v), h.setRenderTarget(i), Xw(c.renderer, n) || console.error("Could not update texture from XR frame");
    const I = S.findObjectOfType(Zu);
    return I ? I.setTexture(n) : (e.setTexture(n), h.render(e, c.camera)), h.clearDepth(), h.setSize(m, v), h.render(c.scene, c.camera), h.setRenderTarget(null), t.setTexture(i.texture), h.render(t, c.camera), o.getContext("2d", { alpha: !1 }).drawImage(h.domElement, 0, 0, o.width, o.height), h.setRenderTarget(g), h.xr.enabled = p, h.autoClear = b, o;
  }
  s.compositeWithCameraImage = r;
  const a = (
    /* glsl */
    `
uniform sampler2D t2D;
varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );

    #ifdef DECODE_VIDEO_TEXTURE

        // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
        texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    #endif

    gl_FragColor = texColor;
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`
  );
  function l(c) {
    const h = c?.material || new Ln({
      name: "BackgroundMaterial",
      uniforms: Ib.clone(od.background.uniforms),
      vertexShader: od.background.vertexShader,
      fragmentShader: a,
      defines: c?.defines,
      side: fo,
      depthTest: !1,
      depthWrite: !1,
      fog: !1
    });
    Object.defineProperty(h, "map", {
      get: function() {
        return this.threeTexture;
      }
    });
    const d = new G(new Nn(2, 2), h);
    return vp(d, !1), d.geometry.deleteAttribute("normal"), d.renderOrder = -1e6, d.setTexture = function(f) {
      h.uniforms.t2D.value = f;
    }, d;
  }
  s.makeFullscreenPlane = l;
})(Dd || (Dd = {}));
var jA = Object.defineProperty, BA = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && jA(e, t, n), n;
};
const ub = w("debugarcamera");
class Zu extends R {
  /** @internal */
  onBeforeXR(e, t) {
    e === "immersive-ar" && (t.optionalFeatures = t.optionalFeatures || [], t.optionalFeatures.push("camera-access"), ub && console.warn("Requesting camera-access"));
  }
  /** @internal */
  onEnterXR(e) {
    e.xr.mode === "immersive-ar" && (this.backgroundPlane && (this.context.scene.add(this.backgroundPlane), this.backgroundPlane.visible = !1), this.backgroundPlane && this.context.scene.add(this.backgroundPlane), this.context.pre_render_callbacks.push(this.preRender));
  }
  /** @internal */
  onLeaveXR(e) {
    this.backgroundPlane && this.backgroundPlane.removeFromParent();
    const t = this.context.pre_render_callbacks.indexOf(this.preRender);
    t >= 0 && this.context.pre_render_callbacks.splice(t, 1);
  }
  backgroundTint = new oe(1, 1, 1, 1);
  get background() {
    return this.backgroundPlane;
  }
  backgroundPlane;
  threeTexture;
  forceTextureInitialization = (function() {
    const e = new we(), t = new Nn(), i = new wi();
    i.add(new G(t, e));
    const n = new de();
    return function(r, a) {
      e.map = a, r.render(i, n), ub && console.warn("Force texture initialization");
    };
  })();
  /** @internal */
  preRender = () => {
    if (!this || !this.gameObject) return;
    if (this.context.renderer.xr.getFrame()) {
      if (!this.threeTexture && this.context.renderer && (this.threeTexture = new Te(), this.forceTextureInitialization(this.context.renderer, this.threeTexture)), this.backgroundPlane === void 0) {
        const i = this.backgroundTint;
        this.backgroundPlane = Dd.makeFullscreenPlane({
          material: new Ln({
            name: "BackgroundMaterial",
            uniforms: {
              ...Ib.clone(od.background.uniforms),
              tint: { value: new fe(i.r, i.g, i.b, i.a) }
            },
            vertexShader: od.background.vertexShader,
            fragmentShader: FA,
            side: xi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          })
        });
      }
      this.backgroundPlane.parent !== this.scene && this.scene.add(this.backgroundPlane), this.backgroundPlane.material instanceof Ln && this.backgroundPlane.material.uniforms.tint.value.set(this.backgroundTint.r, this.backgroundTint.g, this.backgroundTint.b, this.backgroundTint.a), this.updateFromFrame();
    }
  };
  /** @internal */
  onBeforeRender(e) {
    this.updateFromFrame();
  }
  updateFromFrame() {
    this.threeTexture && this.context.xr?.mode === "immersive-ar" && (Xw(this.context.renderer, this.threeTexture), this.setTexture(this.threeTexture));
  }
  setTexture(e) {
    this.backgroundPlane && (this.threeTexture = e, this.backgroundPlane.setTexture(this.threeTexture), this.backgroundPlane.visible = !0);
  }
}
BA([
  u(oe)
], Zu.prototype, "backgroundTint");
const FA = (
  /* glsl */
  `
uniform sampler2D t2D;
uniform vec4 tint;

varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );
    texColor.w = 1.0;

    // inline sRGB decode
    texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    gl_FragColor = texColor * tint;

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`
);
var zA = Object.defineProperty, Ao = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && zA(e, t, n), n;
};
const jd = w("debugimagetracking");
class xc {
  get url() {
    return this._trackedImage.image ?? "";
  }
  get widthInMeters() {
    return this._trackedImage.widthInMeters ?? void 0;
  }
  get bitmap() {
    return this._bitmap;
  }
  get model() {
    return this._trackedImage;
  }
  measuredSize;
  state;
  /** Copy the image position to a vector */
  getPosition(e) {
    return this.ensureTransformData(), e.copy(this._position), e;
  }
  /** Copy the image rotation to a quaternion */
  getQuaternion(e) {
    return this.ensureTransformData(), e.copy(this._rotation), e;
  }
  applyToObject(e, t = void 0) {
    this.ensureTransformData();
    const i = e.position.distanceToSquared(this._position) / 0.05 + e.quaternion.angleTo(this._rotation) / 0.05;
    t && (t *= Math.max(1, i)), t === void 0 || t >= 1 ? (e.position.copy(this._position), e.quaternion.copy(this._rotation)) : (t = Math.max(0, Math.min(1, t)), e.position.lerp(this._position, t), e.quaternion.slerp(this._rotation, t));
  }
  static _positionBuffer = new Hi(() => new y(), 20);
  static _rotationBuffer = new Hi(() => new U(), 20);
  _position;
  _rotation;
  ensureTransformData() {
    if (!this._position) {
      this._position = xc._positionBuffer.get(), this._rotation = xc._rotationBuffer.get();
      const e = this._pose.transform, t = K.active.convertSpace(e);
      this._position.copy(t?.position), this._rotation.copy(t?.quaternion);
    }
  }
  _trackingComponent;
  _trackedImage;
  _bitmap;
  _pose;
  constructor(e, t, i, n, o, r) {
    this._trackingComponent = e, this._trackedImage = t, this._bitmap = i, this.measuredSize = n, this.state = o, this._pose = r;
  }
}
class Io {
  constructor(e) {
    this.image = e.url, this.widthInMeters = e.widthInMeters, e.object instanceof M ? this.object = new ie({ asset: e.object }) : this.object = e.object, e.createObjectInstance !== void 0 && (this.createObjectInstance = e.createObjectInstance), e.imageDoesNotMove !== void 0 && (this.imageDoesNotMove = e.imageDoesNotMove), e.hideWhenTrackingIsLost !== void 0 && (this.hideWhenTrackingIsLost = e.hideWhenTrackingIsLost);
  }
  image;
  widthInMeters = 0.25;
  object;
  createObjectInstance = !1;
  imageDoesNotMove = !1;
  hideWhenTrackingIsLost = !0;
  /**
   * Get the name of the image file from the url
   */
  getNameFromUrl() {
    if (this.image) {
      const e = this.image.split("/");
      return e[e.length - 1];
    }
    return null;
  }
}
Ao([
  u(URL)
], Io.prototype, "image");
Ao([
  u()
], Io.prototype, "widthInMeters");
Ao([
  u(ie)
], Io.prototype, "object");
Ao([
  u()
], Io.prototype, "createObjectInstance");
Ao([
  u()
], Io.prototype, "imageDoesNotMove");
Ao([
  u()
], Io.prototype, "hideWhenTrackingIsLost");
class UA {
  constructor(e, t) {
    this.exporter = e, this.component = t, jd && console.log(this), this.exporter.anchoringType = "image";
  }
  isImageTrackingExtension = !0;
  get extensionName() {
    return "image-tracking";
  }
  // set during export
  shouldExport = !0;
  filename = null;
  imageModel = null;
  onBeforeBuildDocument(e) {
    const t = this.exporter.extensions.filter((i) => {
      const n = i;
      return n.isImageTrackingExtension && n.component.activeAndEnabled && n.component.trackedImages?.length > 0;
    }).indexOf(this);
    this.shouldExport = t === 0, this.shouldExport && this.component.trackedImages?.length > 1 && (jd || L()) && (ge("USDZ: Only one tracked image is supported."), console.warn("USDZ: Only one tracked image is supported. Will choose the first one in the trackedImages list"));
  }
  onAfterHierarchy(e, t) {
    if (!this.shouldExport) return;
    const i = q.getiOSVersion(), r = (i ? parseInt(i.split(".")[0]) : 18) >= 18 ? 1 : 100;
    t.beginBlock('def Preliminary_ReferenceImage "AnchoringReferenceImage"'), t.appendLine("uniform asset image = @image_tracking/" + this.filename + "@"), t.appendLine("uniform double physicalWidth = " + (this.imageModel.widthInMeters * r).toFixed(8)), t.closeBlock();
  }
  async onAfterSerialize(e) {
    if (!this.shouldExport) return;
    const t = this.imageModel, i = sc.get(t.image), r = await (await (await dR(i)).convertToBlob({ type: "image/png" })).arrayBuffer();
    e.files["image_tracking/" + this.filename] = new Uint8Array(r);
  }
  onExportObject(e, t, i) {
    if (!this.shouldExport) return;
    const n = this.component;
    if (!n || !n.trackedImages?.length || !n.activeAndEnabled) return;
    const o = n.trackedImages[0];
    if (o.object?.asset === e) {
      this.imageModel = o, this.filename = o.getNameFromUrl() || "marker.png";
      const { scale: r, target: a } = this.exporter.getARScaleAndTarget();
      let l = e;
      const c = new ee();
      if (e !== a)
        for (; l && l.parent && l.parent !== a; )
          l = l.parent, c.premultiply(l.matrix);
      const h = c.clone().invert();
      t.setMatrix(h.scale(new y(r, r, r)));
    }
  }
}
class Ju extends R {
  /**
   * If you have multiple images in your application to track then this method is useful for iOS AR where only the first image can be tracked.   
   * Call this method will set the given image as the first one in the array so it will be used for tracking.
   */
  setPrimaryImage(e) {
    const t = this.trackedImages.indexOf(e);
    if (t >= 0) {
      const i = this.trackedImages[0];
      i !== e && (this.trackedImages[0] = e, this.trackedImages[t] = i);
    } else console.warn(`[WebXRImageTracking] Can not set primary: image not found in 'trackedImages' array ${e.image}`);
  }
  /**
   * Add an image to track. If the image is already in the trackedImages array it won't be added again.  
   * Note: that adding images at runtime *while* in AR is not supported.
   */
  addImage(e, t = !1) {
    this.trackedImages.includes(e) || (this.trackedImages.push(e), fb(e.image)), t && this.setPrimaryImage(e);
  }
  trackedImages = [];
  smooth = !0;
  trackedImageIndexMap = /* @__PURE__ */ new Map();
  /** @returns true if image tracking is supported on this device. This may return false at runtime if the user's browser did not enable webxr incubations */
  get supported() {
    return this._supported;
  }
  _supported = !0;
  awake() {
    if (jd && console.log(this), !!this.trackedImages)
      for (const e of this.trackedImages)
        e.image && fb(e.image);
  }
  onEnable() {
    ws.beforeExport.addEventListener(this.onBeforeUSDZExport);
  }
  onDisable() {
    ws.beforeExport.removeEventListener(this.onBeforeUSDZExport);
  }
  onBeforeUSDZExport = (e) => {
    this.activeAndEnabled && this.trackedImages?.length && e.exporter.extensions.push(new UA(e.exporter, this));
  };
  onBeforeXR(e, t) {
    if (this.trackedImages) {
      t.optionalFeatures = t.optionalFeatures || [], t.optionalFeatures.includes("image-tracking") || t.optionalFeatures.push("image-tracking"), t.trackedImages = [];
      for (const i of this.trackedImages)
        if (i.image?.length && i.widthInMeters > 0) {
          const n = sc.get(i.image);
          n && (this.trackedImageIndexMap.set(t.trackedImages.length, i), t.trackedImages.push({
            image: n,
            widthInMeters: i.widthInMeters
          }));
        }
    }
  }
  onEnterXR(e) {
    if (this.trackedImages) {
      for (const t of this.trackedImages)
        if (t.object?.asset) {
          const i = t.object.asset;
          i.userData || (i.userData = {});
          const n = {
            visible: i.visible,
            parent: i.parent,
            matrix: i.matrix.clone()
          };
          i.userData["image-tracking"] = n;
        }
    }
    for (const t of this.imageToObjectMap.values())
      t.frames = 0;
  }
  onLeaveXR(e) {
    if (!this.supported && q.isAndroidDevice() && ge(this.webXRIncubationsWarning), this.trackedImages) {
      for (const t of this.trackedImages)
        if (t.object?.asset) {
          const i = t.object.asset;
          if (i.userData) {
            const n = i.userData["image-tracking"];
            n && (i.visible = n.visible, n.parent?.add(i), i.matrix.copy(n.matrix), i.matrix.decompose(i.position, i.quaternion, i.scale)), delete i.userData["image-tracking"];
          }
        }
    }
  }
  imageToObjectMap = /* @__PURE__ */ new Map();
  currentImages = [];
  webXRIncubationsWarning = `Image tracking is currently not supported on this device. On Chrome for Android, you can enable the <a target="_blank" href="#" onclick="() => console.log('I')">chrome://flags/#webxr-incubations</a> flag.`;
  onUpdateXR(e) {
    this.currentImages.length = 0;
    const t = e.xr.frame;
    if (!t) return;
    if ("getImageTrackingResults" in t) {
      if (e.xr.session.enabledFeatures?.includes("image-tracking") === !1)
        return;
      if (t.session && typeof t.getImageTrackingResults == "function") {
        const n = t.getImageTrackingResults();
        if (n.length > 0) {
          const o = this.context.renderer.xr.getReferenceSpace();
          if (o) {
            for (const r of n) {
              const a = r.trackingState, l = r.index, c = this.trackedImageIndexMap.get(l);
              if (c) {
                const h = t.getPose(r.imageSpace, o), d = new xc(this, c, r.image, r.measuredSize, a, h);
                this.currentImages.push(d);
              } else
                jd && console.warn("No tracked image for index", l);
            }
            if (this.currentImages.length > 0)
              try {
                this.dispatchEvent(new CustomEvent("image-tracking", { detail: this.currentImages })), this.onImageTrackingUpdate(this.currentImages);
              } catch (r) {
                console.error(r);
              }
          }
        }
      }
    } else {
      this.didPrintWarning || (this.didPrintWarning = !0, console.log(this.webXRIncubationsWarning)), this._supported = !1, ge(this.webXRIncubationsWarning);
      return;
    }
    const i = 1e3;
    for (const [n, o] of this.imageToObjectMap) {
      if (!o.object || !n || n.hideWhenTrackingIsLost === !1) continue;
      let r = !1;
      for (const a of this.currentImages)
        if (a.model === n) {
          const l = Date.now() - o.lastTrackingTime;
          if (n.imageDoesNotMove || a.state === "tracked" || l <= i) {
            r = !0;
            break;
          }
        }
      r || S.setActive(o.object, !1);
    }
  }
  onImageTrackingUpdate = (e) => {
    const t = K.active;
    if (t)
      for (const i of e) {
        const n = i.model, o = i.state === "tracked";
        if (!n.object) continue;
        let r = this.imageToObjectMap.get(n);
        if (r === void 0)
          r = { object: null, frames: 0, lastTrackingTime: Date.now() }, this.imageToObjectMap.set(n, r), n.object.loadAssetAsync().then((a) => {
            if (n.createObjectInstance && a && (a = S.instantiate(a)), a) {
              r.object = a;
              for (const l of a.getComponentsInChildren(Qi))
                l.setInstancingEnabled(!1);
              t.rig ? (t.rig.gameObject.add(a), i.applyToObject(a), a.activeSelf || S.setActive(a, !0)) : console.warn("XRImageTracking: missing XRRig");
            }
          });
        else {
          if (r.frames++, o && (r.lastTrackingTime = Date.now()), n.imageDoesNotMove && r.frames > 10 || !r.object) continue;
          t.rig && (t.rig.gameObject.add(r.object), i.applyToObject(r.object, this.smooth ? this.context.time.deltaTimeUnscaled * 3 : void 0), r.object.activeSelf || S.setActive(r.object, !0));
        }
      }
  };
}
Ao([
  u(Io)
], Ju.prototype, "trackedImages");
Ao([
  u()
], Ju.prototype, "smooth");
const sc = /* @__PURE__ */ new Map(), Dh = /* @__PURE__ */ new Map();
async function fb(s) {
  if (sc.has(s))
    return Dh.has(s) ? Dh.get(s) : Promise.resolve(!0);
  const e = new Promise((t) => {
    sc.set(s, null);
    const i = document.createElement("img");
    i.src = s, i.addEventListener("load", async () => {
      const n = await createImageBitmap(i);
      sc.set(s, n), t(!0);
    });
  });
  return Dh.set(s, e), e.finally(() => {
    Dh.delete(s);
  }), e;
}
var NA = Object.defineProperty, ol = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && NA(e, t, n), n;
};
const $o = w("debugplanetracking");
class Lo extends R {
  dataTemplate;
  occluder = !0;
  initiateRoomCaptureIfNoData = !0;
  usePlaneData = !0;
  useMeshData = !0;
  runInVR = !0;
  /**
   * Returns all tracked planes
   */
  get trackedPlanes() {
    return this._allPlanes.values();
  }
  get trackedMeshes() {
    return this._allMeshes.values();
  }
  /** @internal */
  onBeforeXR(e, t) {
    e === "immersive-vr" && !this.runInVR || (t.optionalFeatures = t.optionalFeatures || [], this.usePlaneData && !t.optionalFeatures.includes("plane-detection") && t.optionalFeatures.push("plane-detection"), this.useMeshData && !t.optionalFeatures.includes("mesh-detection") && t.optionalFeatures.push("mesh-detection"));
  }
  /** @internal */
  onEnterXR(e) {
    for (const t of this._allPlanes.keys())
      this.removeData(t, this._allPlanes);
    for (const t of this._allMeshes.keys())
      this.removeData(t, this._allMeshes);
  }
  onLeaveXR(e) {
    for (const t of this._allPlanes.keys())
      this.removeData(t, this._allPlanes);
    for (const t of this._allMeshes.keys())
      this.removeData(t, this._allMeshes);
  }
  /** @internal */
  onUpdateXR(e) {
    if (!this.runInVR && e.xr.isVR) return;
    const t = e.xr.rig;
    if (!t) {
      console.warn("No XR rig found, cannot parent tracked planes to it");
      return;
    }
    const i = e.xr.frame;
    if (!this.context.renderer.xr.getReferenceSpace()) return;
    const r = i.detectedPlanes, a = i.detectedMeshes, l = r !== void 0 && r.size > 0, c = a !== void 0 && a.size > 0;
    if (this.initiateRoomCaptureIfNoData && (!l && !c && this.firstTimeNoPlanesDetected < -10 && (this.firstTimeNoPlanesDetected = Date.now()), (l || c) && (this.firstTimeNoPlanesDetected = -1), this.firstTimeNoPlanesDetected > 0 && Date.now() - this.firstTimeNoPlanesDetected > 2500 && "initiateRoomCapture" in i.session && (i.session.initiateRoomCapture(), this.firstTimeNoPlanesDetected = -1)), r !== void 0 && this.processFrameData(e.xr, t.gameObject, i, r, this._allPlanes), a !== void 0 && this.processFrameData(e.xr, t.gameObject, i, a, this._allMeshes), $o) {
      const h = this.context.mainCameraComponent.gameObject.worldPosition;
      for (const d of this._allPlanes.values())
        !d.mesh || !d.mesh.visible || (this.bounds.makeEmpty(), d.mesh.traverse((f) => {
          f instanceof G && this.bounds.expandByObject(f);
        }), this.bounds.getCenter(this.center), this.labelOffset.copy(h).sub(this.center).normalize().multiplyScalar(0.1), z.DrawLabel(
          this.center.add(this.labelOffset),
          (d.xrData.semanticLabel || "plane").toUpperCase() + `
` + d.xrData.lastChangedTime.toFixed(2),
          0.02
        ));
    }
  }
  bounds = new bi();
  center = new y();
  labelOffset = new y();
  removeData(e, t) {
    const i = t.get(e);
    if (!i) return;
    t.delete(e), $o && console.log("Plane no longer tracked, id=" + i.id), i.mesh && (i.mesh.removeFromParent(), i.mesh.traverse((o) => {
      const r = o.userData.normalsHelper;
      r ? (r.dispose(), r.removeFromParent()) : $o && console.warn("No normals helper found for mesh", i.mesh);
    }), Gi(i.mesh, !0, !0));
    const n = new CustomEvent("plane-tracking", {
      detail: {
        type: "plane-removed",
        context: i
      }
    });
    this.dispatchEvent(n);
  }
  _dataId = 1;
  _allPlanes = /* @__PURE__ */ new Map();
  _allMeshes = /* @__PURE__ */ new Map();
  firstTimeNoPlanesDetected = -100;
  makeOccluder = (e, t, i = !1) => {
    if (t) {
      if (t instanceof Array) {
        for (const n of t)
          this.makeOccluder(e, n, i);
        return;
      }
      !i && !t.name.toLowerCase().includes("occlu") || (t.colorWrite = !1, t.depthTest = !0, t.depthWrite = !0, t.transparent = !1, t.polygonOffset = !0, t.polygonOffsetFactor = 1, t.polygonOffsetUnits = 0.1, e.renderOrder = -1e3);
    }
  };
  processFrameData(e, t, i, n, o) {
    const a = this.context.renderer.xr.getReferenceSpace();
    if (a) {
      for (const l of o.keys())
        n.has(l) || this.removeData(l, o);
      for (const l of n) {
        const c = "planeSpace" in l ? l.planeSpace : "meshSpace" in l ? l.meshSpace : void 0;
        if (!c) continue;
        const h = i.getPose(c, a);
        let d;
        if (o.has(l)) {
          const f = o.get(l);
          if (d = f.mesh, f.timestamp < l.lastChangedTime) {
            if (f.timestamp = l.lastChangedTime, f.mesh) {
              const g = this.createGeometry(l);
              if (f.mesh instanceof G)
                f.mesh.geometry.dispose(), f.mesh.geometry = g, this.makeOccluder(f.mesh, f.mesh.material);
              else if (f.mesh instanceof so)
                for (const b of f.mesh.children)
                  b instanceof G && (b.geometry.dispose(), b.geometry = g, this.makeOccluder(b, b.material));
              if (f.collider) {
                const b = f.mesh;
                f.collider.sharedMesh = b, f.collider.convex = this.checkIfContextShouldBeConvex(b, f.xrData), f.collider.onDisable(), f.collider.onEnable();
              }
              $o && (console.log("Plane updated, id=" + f.id, f), f.mesh.traverse((b) => {
                if (!(b instanceof G)) return;
                const m = b.userData.normalsHelper;
                m && m.update();
              }));
            }
            const p = new CustomEvent("plane-tracking", {
              detail: {
                type: "plane-updated",
                context: f
              }
            });
            this.dispatchEvent(p);
          }
        } else {
          if (!this.dataTemplate) {
            const f = new G();
            $o ? f.material = new vS() : this.occluder ? (f.material = new we(), this.makeOccluder(f, f.material, !0)) : f.material = new we({ wireframe: !0, opacity: 0.5, transparent: !0, color: 3355443 }), this.dataTemplate = new ie("", "", f);
          }
          if (!this.dataTemplate.asset)
            this.dataTemplate.loadAssetAsync();
          else {
            const f = S.instantiate(this.dataTemplate.asset);
            if (f.name = "xr-tracked-plane", d = f, n0(f, !1), f instanceof G)
              Re(f.geometry), f.geometry = this.createGeometry(l), this.makeOccluder(f, f.material, this.occluder && !this.dataTemplate);
            else if (f instanceof so)
              for (const b of f.children)
                b instanceof G && (Re(b.geometry), b.geometry = this.createGeometry(l), this.makeOccluder(b, b.material, this.occluder && !this.dataTemplate));
            const p = f.getComponent(xr);
            if (p) {
              const b = f;
              p.sharedMesh = b, p.convex = this.checkIfContextShouldBeConvex(b, l), p.onDisable(), p.onEnable();
            }
            f.matrixAutoUpdate = !1, f.matrixWorldNeedsUpdate = !0, t.add(f);
            const g = {
              id: this._dataId++,
              xrData: l,
              timestamp: l.lastChangedTime,
              mesh: f,
              collider: p
            };
            o.set(l, g), $o && console.log("New plane detected, id=" + g.id, g, { hasCollider: !!p, isGroup: f instanceof so });
            try {
              const b = new CustomEvent("plane-tracking", {
                detail: {
                  type: "plane-added",
                  context: g
                }
              });
              this.dispatchEvent(b);
            } catch (b) {
              console.error(b);
            }
          }
        }
        d && (h ? (d.visible = !0, d.matrix.fromArray(h.transform.matrix), d.matrix.premultiply(this._flipForwardMatrix)) : d.visible = !1, $o && d.traverse((f) => {
          if (f instanceof G)
            if (f.userData.normalsHelper)
              f.userData.normalsHelper.update();
            else {
              const p = new VS(f, 0.05, 255);
              p.layers.disableAll(), p.layers.set(2), this.context.scene.add(p), f.userData.normalsHelper = p;
            }
        }));
      }
    }
  }
  _flipForwardMatrix = new ee().makeRotationY(Math.PI);
  // heuristic to determine if a collider should be convex or not - 
  // the "global mesh" should be non-convex, other meshes should be
  checkIfContextShouldBeConvex(e, t) {
    if (!e) return !0;
    if (e) {
      const i = new bi();
      i.expandByObject(e);
      const n = new y();
      i.getSize(n);
      let o = !0;
      return n.x > 2 && n.y > 2 && n.z > 1.5 && (o = !1), o && "semanticLabel" in t && t.semanticLabel === "wall" && (o = !0), o;
    }
    return !0;
  }
  createGeometry(e) {
    return "polygon" in e ? this.createPlaneGeometry(e.polygon) : "vertices" in e && "indices" in e ? this.createMeshGeometry(e.vertices, e.indices) : new an();
  }
  // we cache vertices-to-geometry, because it looks like when we get an update sometimes the geometry stays the same.
  // so we don't want to re-create the geometry every time.
  _verticesCache = /* @__PURE__ */ new Map();
  createMeshGeometry(e, t) {
    const i = e.toString() + "_" + t.toString();
    if (this._verticesCache.has(i))
      return this._verticesCache.get(i);
    const n = new an();
    n.setIndex(new ft(t, 1)), n.setAttribute("position", new ft(e, 3));
    const o = Array();
    for (let r = 0; r < e.length; r += 3)
      o.push(e[r], e[r + 2]);
    return n.setAttribute("uv", new ft(e, 3)), n.computeVertexNormals(), this._verticesCache.set(i, n), n;
  }
  createPlaneGeometry(e) {
    const t = new an(), i = [], n = [];
    e.forEach((f) => {
      i.push(f.x, f.y, f.z), n.push(f.x, f.z);
    });
    const o = new y(i[0], i[1], i[2]), r = new y(i[3], i[4], i[5]), a = new y(i[6], i[7], i[8]), l = new y(), c = new y();
    l.subVectors(r, o), c.subVectors(a, o), l.cross(c), l.normalize();
    const h = [];
    for (let f = 0; f < i.length / 3; f++)
      h.push(l.x, l.y, l.z);
    const d = [];
    for (let f = 2; f < e.length; ++f)
      d.push(0, f - 1, f);
    return t.setAttribute("position", new ft(new Float32Array(i), 3)), t.setAttribute("uv", new ft(new Float32Array(n), 2)), t.setAttribute("normal", new ft(new Float32Array(h), 3)), t.setIndex(d), t.computeBoundingBox(), t.computeBoundingSphere(), t;
  }
}
ol([
  u(ie)
], Lo.prototype, "dataTemplate");
ol([
  u()
], Lo.prototype, "occluder");
ol([
  u()
], Lo.prototype, "initiateRoomCaptureIfNoData");
ol([
  u()
], Lo.prototype, "usePlaneData");
ol([
  u()
], Lo.prototype, "useMeshData");
ol([
  u()
], Lo.prototype, "runInVR");
var $A = Object.defineProperty, WA = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && $A(e, t, n), n;
};
const pb = w("debugwebxr");
class oy extends R {
  priority = 0;
  get isActive() {
    return this.activeAndEnabled && this.gameObject.visible;
  }
  /** 
   * Sets this rig to be the active XR rig (needs to be called during an active XR session) 
   * Note that this might modify the priority of this rig to be the highest.
  */
  setAsActiveXRRig() {
    K.active?.setRigActive(this);
  }
  /** 
   * Sets the priority of the rig.
   */
  setPriority(e) {
    this.priority = e;
  }
  /** @internal */
  awake() {
    if (pb) {
      const e = new M();
      e.position.y += 0.5, this.gameObject.add(e);
      const t = e.addNewComponent(qa);
      t && (t.isGizmo = !1);
      const i = new vi(0.5);
      this.gameObject.add(i);
    }
  }
  isXRRig() {
    return !0;
  }
  supportsXR(e) {
    return !0;
  }
  _startScale;
  /** @internal */
  onEnterXR(e) {
    this._startScale = this.gameObject.scale.clone(), e.xr.addRig(this), pb && console.log("WebXR: add Rig", this.name, this.priority);
  }
  /** @internal */
  onLeaveXR(e) {
    e.xr.removeRig(this), this._startScale && this.gameObject && this.gameObject.scale.copy(this._startScale);
  }
}
WA([
  u()
], oy.prototype, "priority");
class VA extends R {
  toggleKey = "KeyP";
  update() {
    this.context.input.isKeyDown(this.toggleKey) && this.context.domElement.classList.toggle("presentation-mode");
  }
}
P.add("AlignmentConstraint", au);
P.add("Animation", ni);
P.add("Animator", kt);
P.add("AudioListener", to);
P.add("AudioSource", Xi);
P.add("Avatar_Brain_LookAt", Cd);
P.add("Avatar_MouthShapes", du);
P.add("Avatar_MustacheShake", cv);
P.add("AvatarBlink_Simple", Ba);
P.add("AvatarEyeLook_Rotation", fv);
P.add("AxesHelper", Mc);
P.add("BasicIKConstraint", pv);
P.add("BoxHelperComponent", Pt);
P.add("Camera", yi);
P.add("CharacterController", Fa);
P.add("CharacterControllerInput", _o);
P.add("Collider", Ci);
P.add("SphereCollider", Rc);
P.add("BoxCollider", fg);
P.add("MeshCollider", xr);
P.add("CapsuleCollider", po);
P.add("ContactShadows", pu);
P.add("LogStats", gv);
P.add("DeleteBox", nr);
P.add("Deletable", _v);
P.add("DeviceFlag", pg);
P.add("DragControls", Zr);
P.add("DropListener", vo);
P.add("Duplicatable", xv);
P.add("EventListEvent", og);
P.add("EventTrigger", _g);
P.add("GltfExportBox", Lv);
P.add("GltfExport", Dv);
P.add("VariantAction", Hv);
P.add("ChangeTransformOnClick", $a);
P.add("ChangeMaterialOnClick", Gv);
P.add("SetActiveOnClick", qv);
P.add("HideOnStart", on);
P.add("EmphasizeOnClick", Ac);
P.add("PlayAudioOnClick", cr);
P.add("PlayAnimationOnClick", Md);
P.add("PreliminaryAction", Ic);
P.add("PreliminaryTrigger", vu);
P.add("VisibilityAction", wu);
P.add("TapGestureTrigger", Xv);
P.add("USDZExporter", ws);
P.add("Fog", jc);
P.add("BoxGizmo", qa);
P.add("GridHelper", Bc);
P.add("GroundProjectedEnv", Rs);
P.add("UsageMarker", mu);
P.add("Interactable", yv);
P.add("FixedJoint", uw);
P.add("HingeJoint", Mu);
P.add("Light", ki);
P.add("LODGroup", Ru);
P.add("LookAtConstraint", ja);
P.add("NeedleMenu", As);
P.add("NestedGltf", Tu);
P.add("Networking", pw);
P.add("OffsetConstraint", Xa);
P.add("CameraTargetReachedEvent", Sd);
P.add("OrbitControls", ye);
P.add("ParticleSystemRenderer", mn);
P.add("ParticleSystem", Td);
P.add("Attractor", $c);
P.add("PlayerColor", wc);
P.add("Antialiasing", Lu);
P.add("BloomEffect", Wg);
P.add("ChromaticAberration", ju);
P.add("ColorAdjustments", Or);
P.add("DepthOfField", qn);
P.add("EffectWrapper", Ed);
P.add("PixelationEffect", Fu);
P.add("ScreenSpaceAmbientOcclusion", ko);
P.add("ScreenSpaceAmbientOcclusionN8", Xn);
P.add("SharpeningEffect", zu);
P.add("TiltShiftEffect", Ds);
P.add("ToneMappingEffect", fr);
P.add("Vignette", Ja);
P.add("Volume", Vc);
P.add("ReflectionProbe", kd);
P.add("Renderer", Qi);
P.add("MeshRenderer", yu);
P.add("SkinnedMeshRenderer", Av);
P.add("Rigidbody", rt);
P.add("SceneSwitcher", Ze);
P.add("ScreenCapture", Rr);
P.add("ShadowCatcher", Uu);
P.add("RemoteSkybox", Gg);
P.add("SmoothFollow", qg);
P.add("SpatialTriggerReceiver", xs);
P.add("SpatialTrigger", Xg);
P.add("SpectatorCamera", Qg);
P.add("SplineContainer", tl);
P.add("SplineWalker", Qn);
P.add("SpriteRenderer", Pi);
P.add("SyncedCamera", jw);
P.add("SyncedRoom", Yn);
P.add("SyncedTransform", zn);
P.add("TestRunner", Bw);
P.add("TestSimulateUserData", Fw);
P.add("PlayableDirector", Ia);
P.add("SignalReceiver", Vu);
P.add("AnimationTrackHandler", Kg);
P.add("AudioTrackHandler", no);
P.add("SignalTrackHandler", Ld);
P.add("ControlTrackHandler", Zg);
P.add("TransformGizmo", il);
P.add("BaseUIComponent", un);
P.add("UIRootComponent", Pu);
P.add("Button", To);
P.add("Canvas", bc);
P.add("CanvasGroup", ur);
P.add("EventSystem", ti);
P.add("Graphic", Ou);
P.add("MaskableGraphic", ku);
P.add("Image", Qc);
P.add("RawImage", ty);
P.add("InputField", $w);
P.add("VerticalLayoutGroup", rw);
P.add("HorizontalLayoutGroup", aw);
P.add("GridLayoutGroup", lw);
P.add("Outline", Dc);
P.add("ObjectRaycaster", qi);
P.add("GraphicRaycaster", rg);
P.add("SpatialGrabRaycaster", Ea);
P.add("RectTransform", Un);
P.add("SpatialHtml", Qu);
P.add("Text", Xt);
P.add("EnvironmentScene", iy);
P.add("LookAt", Hw);
P.add("OpenURL", Zc);
P.add("VideoPlayer", mt);
P.add("Voip", wr);
P.add("ClickThrough", sy);
P.add("CursorFollow", Ku);
P.add("ScrollFollow", qw);
P.add("Avatar", dr);
P.add("XRControllerFollow", Eo);
P.add("XRControllerModel", mo);
P.add("XRControllerMovement", Yi);
P.add("TeleportTarget", kg);
P.add("WebARCameraBackground", Zu);
P.add("WebARSessionRoot", Vi);
P.add("WebXR", Mg);
P.add("AvatarMarker", je);
P.add("WebXRImageTracking", Ju);
P.add("WebXRPlaneTracking", Lo);
P.add("XRRig", oy);
P.add("XRFlag", rn);
P.add("PlayerSync", Zv);
P.add("PlayerState", Rn);
P.add("PresentationMode", VA);
const oc = pt, HA = w("debugtypestore");
HA && console.log(P);
function GA(s, e) {
  const i = LP(s, e);
  return i !== void 0 ? i : null;
}
const qA = new IP(), cp = Symbol("deserialize-queue");
async function XA(s, e, t, i = null, n) {
  if (!t) {
    console.debug("Can not create component instances: gltf is null");
    return;
  }
  const o = [];
  let r = i;
  typeof r == "number" && (r = new At(i));
  const a = e.indexOf("?");
  e = a === -1 ? e : e.substring(0, a);
  const l = new j0(t.scene);
  l.gltfId = e, l.context = s, l.gltf = t, l.nodeToObject = n?.nodeToObjectMap, l.implementationInformation = qA;
  let c = s[cp];
  if (c || (c = s[cp] = []), t.scenes)
    for (const h of t.scenes)
      await ym(l, h, c, o, 0);
  if (t.children)
    for (const h of t.children)
      await ym(l, h, c, o, 0);
  s.new_scripts_pre_setup_callbacks.push(() => {
    const h = s[cp];
    if (h) {
      for (const d of h)
        QA(d, l);
      h.length = 0;
    }
    if (r) {
      const d = {}, f = [];
      gm(t, r, d, f);
      for (const p of t.scenes)
        gm(p, r, d, f);
      for (const p of f)
        p.resolveGuids(d);
    }
  });
}
const mm = Symbol("original-component-name"), Ur = /* @__PURE__ */ new Map();
function gm(s, e, t, i) {
  if (e === null || !s) return;
  const n = s.guid, o = s.guid;
  o?.length && (Ur.has(o) || (oc && console.log('Creating InstanceIdProvider with key "' + o + '" for object ' + s.name), Ur.set(o, new At(o))));
  const r = o && Ur.get(o) || e;
  if (s.guid = r.generateUUID(), n && n !== "invalid" && (t[n] = s.guid), s && s.userData && s.userData.components)
    for (const a of s.userData.components) {
      if (a === null) continue;
      const l = a.guid;
      l ? Ur.has(l) || (oc && console.log('Creating InstanceIdProvider with key "' + l + '" for component ' + a[mm]), Ur.set(l, new At(l))) : oc && console.warn("Can not create IdProvider: component " + a[mm] + " has no guid", a.guid);
      const c = Ur.get(l) || e, h = a.guid;
      a.guid = c.generateUUID(), h && h !== "invalid" && (t[h] = a.guid), a.resolveGuids && i.push(a);
    }
  if (s.children)
    for (const a of s.children)
      gm(a, e, t, i);
}
const xl = [];
async function ym(s, e, t, i, n) {
  if (!e) return;
  const o = e.userData;
  if (o) {
    const r = o.builtin_components;
    if (r && r.length > 0)
      for (const a of r)
        try {
          if (a === null) continue;
          const l = P.get(a.name);
          if (l != null) {
            const c = new l();
            c.sourceId = s.gltfId, Ca(c, a, s.implementationInformation), c.context = s.context, "guid" in a && (c[Fh] = a.guid), c[mm] = a.name, aa(e, c, !1), t.push({ instance: c, compData: a, obj: e }), c.isCamera && s.context && s.context.mainCamera === null && c.tag === "MainCamera" && s.context.setCurrentCamera(c), s.context?.physics?.engine?.isInitialized === !1 && (c.isCollider || c.isRigidbody) && s.context?.physics.engine?.initialize();
          } else
            oc && console.debug("unknown component: " + a.name), xl.includes(a.name) || xl.push(a.name);
        } catch (l) {
          console.error(a.name + " - " + l.message, l);
        }
  }
  if (e.children)
    for (const r of e.children)
      await ym(s, r, t, i, n + 1);
  if (xl.length > 0 && n === 0) {
    const r = xl.join(", ");
    console.warn(`Unknown components in scene: ${r}`), xl.length = 0, hn() && Be(`<strong>Unknown components in scene</strong>:

${r}

This could mean you forgot to add a npmdef to your ExportInfo
<a href="https://engine.needle.tools/docs/project_structure.html#creating-and-installing-a-npmdef" target="_blank">documentation</a>`, Wi.Warn);
  }
}
function QA(s, e) {
  const { instance: t, compData: i, obj: n } = s;
  e.object = n, e.target = t, Ip(t, i, e), oc && console.debug("add " + i.name, i, t);
}
class Yw {
  createBuiltinComponents(e, t, i, n, o) {
    return XA(e, t, i, n, o);
  }
  writeBuiltinComponentData(e, t) {
    return GA(e, t);
  }
  parseSync(e, t, i, n) {
    return KA(e, t, i, n);
  }
  loadSync(e, t, i, n, o) {
    return Jw(e, t, i, n, o);
  }
}
d0(Yw);
const Kw = w("printGltf") || w("printgltf"), YA = w("debugfileformat");
async function Zw(s, e) {
  const t = await mM(s, { useExtension: !0 }) || "unknown";
  YA && console.debug(`Determined file type: '${t}' for url '${s}'`, { registeredModelLoaderCallbacks: Jr });
  for (const i of Jr) {
    const { callback: n } = i, o = n({ context: e, url: s, mimetype: t });
    if (o instanceof Promise && await o, o)
      return console.debug(`Using custom loader (${i.name || "unnamed"}) for ${t} at '${s}'`), o;
  }
  switch (t) {
    case "unsupported":
      return null;
    default:
    case "unknown": {
      console.warn(`Unknown file type (${t}). Needle Engine will fallback to the GLTFLoader - To support more model formats please create a Needle loader plugin.
Use import { NeedleEngineModelLoader } from "@needle-tools/engine" namespace to register your loader.`, s);
      const i = new Ps();
      return await Qp(i, e, s), i;
    }
    case "model/fbx":
    case "model/vnd.autodesk.fbx":
      return new Ub();
    case "model/obj":
      return new Tm();
    case "model/vnd.usdz+zip":
    case "model/vnd.usd+zip":
    case "model/vnd.usda+zip":
      return console.warn(t.toUpperCase() + " files are not supported."), null;
    case "model/gltf+json":
    case "model/gltf-binary":
    case "model/vrm": {
      const i = new Ps();
      return await Qp(i, e, s), i;
    }
  }
}
function NL(s, e) {
  return Jw(e?.context || N.Current, s, s, e?.seed || null, e?.onprogress);
}
async function KA(s, e, t, i) {
  typeof t != "string" && (console.warn("Parse gltf binary without path, this might lead to errors in resolving extensions. Please provide the source path of the gltf/glb file", t, typeof t), t = ""), Kw && console.log("Parse glTF", t);
  const n = await Zw(t, s);
  if (!n)
    return;
  const { componentsExtension: o } = ex(n, s);
  if (n instanceof Tm) {
    typeof e != "string" && (e = new TextDecoder().decode(e));
    const a = n.parse(e);
    return await rc(n, s, t, a, i, o);
  }
  if (!(n instanceof Ps)) {
    if (n.parse === void 0) {
      console.error("Loader does not support parse");
      return;
    }
    const a = n.parse(e, t);
    return await rc(n, s, t, a, i, o);
  }
  return new Promise((a, l) => {
    try {
      let c = t.split("?")[0].trimEnd();
      const h = c.split("/");
      h.length > 0 && h[h.length - 1] !== "" && h.pop(), c = h.join("/"), c.endsWith("/") || (c += "/"), n.resourcePath = c, n.parse(e, "", async (d) => {
        const f = await rc(n, s, t, d, i, o);
        a(f);
      }, (d) => {
        console.error('Loading asset at "' + t + `" failed
`, d), a(void 0);
      });
    } catch (c) {
      console.error(c), l(c);
    }
  });
}
async function Jw(s, e, t, i, n) {
  JA(e);
  const o = await Zw(e, s);
  if (!o)
    return;
  const { componentsExtension: r } = ex(o, s);
  if (!(o instanceof Ps)) {
    const a = await o.loadAsync(e, n);
    return await rc(o, s, e, a, i, r);
  }
  return new Promise((a, l) => {
    try {
      o.load(e, async (c) => {
        const h = await rc(o, s, t, c, i, r);
        a(h);
      }, (c) => {
        n?.call(o, c);
      }, (c) => {
        console.error('Loading asset at "' + e + `" failed
`, c), a(void 0);
      });
    } catch (c) {
      console.error(c), l(c);
    }
  });
}
function ex(s, e) {
  const t = Mv(s);
  return s instanceof Ps && ig(s, e), { componentsExtension: t };
}
async function rc(s, e, t, i, n, o) {
  if (Kw && console.warn("Loaded", t, i), i == null)
    return console.error(`Loaded model is null '${t}' - please make sure the loader is registered correctly`), {
      scene: new M(),
      animations: [],
      scenes: []
    };
  if (typeof i != "object")
    return console.error(`Loaded model is not an object '${t}' - please make sure the loader is registered correctly`), {
      scene: new M(),
      animations: [],
      scenes: []
    };
  if (i instanceof M)
    i = {
      scene: i,
      animations: i.animations,
      scenes: [i]
    };
  else if (i instanceof an) {
    const r = new ut({
      color: new se(14540253)
    }), a = new G(i, r);
    i = {
      scene: a,
      animations: [],
      scenes: [a]
    };
  } else Array.isArray(i.scenes) === !1 && console.error(`[Needle Engine] The loaded model object does not have a scenes property '${t}' - please make sure the loader is registered correctly and three.js is not imported multiple times.`);
  return t.includes("?") && (t = t.split("?")[0]), eI(s, i), Fk(i) && (zM(t, i, e), await Bn().createBuiltinComponents(e, t, i, n, o || void 0)), await ZA(i.scene, e, e.mainCamera), i;
}
async function ZA(s, e, t) {
  t || (t = e.mainCamera);
  try {
    t ? await e.renderer.compileAsync(s, t, e.scene).catch((i) => {
      console.warn(i.message);
    }) : fP(s, e);
  } catch (i) {
    console.warn(i?.message || i);
  }
}
function JA(s) {
  if (new URL(s, window.location.href).href.startsWith("file://")) {
    const t = `Hi - it looks like you are trying to load a local file which will not work. You need to use a webserver to serve your files.
Please refer to the documentation on <a href="https://fwd.needle.tools/needle-engine/docs/local-server">https://docs.needle.tools</a> or ask for help in our <a href="https://discord.needle.tools">discord community</a>`;
    Be(t), console.warn(t);
  }
}
function eI(s, e) {
  if ("scenes" in e) {
    for (const t of e.scenes)
      if (t && !t.animations?.length)
        for (const i of e.animations)
          t.animations.includes(i) || t.animations.push(i);
  }
  if (s instanceof Ub || s instanceof Tm) {
    let t = e;
    t instanceof M || (t = e.scene || e.scenes.find((i) => i)), t.traverse((i) => {
      const n = i;
      n?.isMesh && s0(n, n.material);
    });
  }
}
const Sl = w("debugoverlay"), tx = "ar", tI = "quit-ar";
class iI {
  get ARContainer() {
    return this.arContainer;
  }
  arContainer = null;
  currentSession = null;
  _createdAROnlyElements = [];
  _reparentedObjects = [];
  contentElement = null;
  originalDomOverlayParent = null;
  requestEndAR = () => {
    this.onRequestedEndAR();
  };
  onBegin(e, t, i) {
    if (this.currentSession = i, this.arContainer = t, q.isMozillaXR()) {
      const n = e.domElement.children;
      for (let o = 0; o < n?.length; o++) {
        const r = n[o];
        if (!r || r === this.arContainer) return;
        this._reparentedObjects.push({ el: r, previousParent: r.parentElement }), this.arContainer?.appendChild(r);
      }
      t ? (this.originalDomOverlayParent = t.parentNode, this.originalDomOverlayParent && (console.log("Reparent DOM Overlay to body", t, t.style.display), t.style.display = "", t.style.visibility = "", document.body.appendChild(t))) : console.warn("WebXRViewer: No DOM Overlay found");
    }
    this.ensureQuitARButton(this.arContainer);
  }
  onEnd(e) {
    for (const t of this._createdAROnlyElements)
      t.remove && t.remove();
    for (const t of this._reparentedObjects) {
      const i = t.el;
      t.previousParent?.appendChild(i);
    }
    this._reparentedObjects.length = 0, q.isMozillaXR() && setTimeout(() => {
      const t = e.renderer.domElement;
      t && e.domElement.shadowRoot?.prepend(t);
      const i = document.querySelectorAll("*");
      for (var n = 0; n < i.length; n++) {
        const o = i[n];
        o && o._displayChanged !== void 0 && o._displayWas !== void 0 && (o.style.display = o._displayWas);
      }
    }, 10);
  }
  createOverlayContainer(e) {
    if (this.contentElement) return this.contentElement;
    Sl && console.log("Setup overlay container");
    const t = e.shadowRoot.querySelector(".content");
    this.contentElement = t;
    const i = e.shadowRoot.querySelector(".overlay-content");
    return i && t.appendChild(i), Sl && !q.isMobileDevice() && this.ensureQuitARButton(t), t;
  }
  onRequestedEndAR() {
    this.currentSession && (this.currentSession.end(), this.currentSession = null);
  }
  ensureQuitARButton(e) {
    const t = document.createElement("slot");
    t.setAttribute("name", "quit-ar"), this.appendElement(t, e), this._createdAROnlyElements.push(t), t.style.pointerEvents = "auto";
    const i = document.querySelector(`.${tI}`);
    if (i) {
      i.addEventListener("click", this.requestEndAR), Sl && i.addEventListener("click", () => console.log("Clicked quit-ar button"));
      return;
    }
    t.addEventListener("click", this.requestEndAR), Sl && t.addEventListener("click", () => console.log("Clicked fallback close button"));
    const n = document.createElement("div");
    n.style.cssText = `
            position: fixed;
            top: 0;
            right: 0;
            z-index: 600;
            pointer-events: all;
        `, this.appendElement(n, t);
    var o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o.classList.add("quit-ar-button"), o.setAttribute("width", "40px"), o.setAttribute("height", "40px"), o.style.cssText = `
            background: rgba(255, 255, 255, .4);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,.3);
            outline: 1px solid rgba(255, 255, 255, .6);
            display: flex;
            justify-content: center;
            align-items: center;
        `, n.appendChild(o);
    var r = document.createElementNS("http://www.w3.org/2000/svg", "path");
    r.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), r.setAttribute("stroke", "#000000"), r.setAttribute("stroke-width", "2px"), r.style.cssText = `
            /**filter: drop-shadow(0 0px 1.2px rgba(0,0,0,.7));**/
        `, o.appendChild(r), Sl && console.log("Created fallback close button", o, e);
  }
  appendElement(e, t) {
    return t.shadowRoot ? t.shadowRoot.appendChild(e) : t.appendChild(e);
  }
}
const Xo = w("debugloading"), Cl = w("debugloadingrendering"), mb = w("debuglicense");
class $L {
  className;
  additionalClasses;
}
let Pl = 0, gb;
function ix(s) {
  Xo && console.log(s.progress.loaded.toFixed(0) + "/" + s.progress.total.toFixed(0), s);
  const e = s.count, t = s.progress.total;
  t === 0 || t === void 0 ? (gb !== s.name && (Pl = 0), gb = s.name, Pl += (1 - Pl) * 1e-3, Xo && ge("Loading " + s.name + " did not report total size")) : Pl = s.progress.loaded / t;
  const i = s.index / e + Pl / e;
  return j.clamp01(i);
}
class Bd {
  static LoadingContainerClassName = "loading";
  // the raw progress
  loadingProgress = 0;
  /** Usually the NeedleEngineHTMLElement */
  _element;
  _progress = 0;
  _allowCustomLoadingElement = !0;
  _loadingElement;
  _loadingTextContainer = null;
  _loadingBar = null;
  _messageContainer = null;
  _loadingElementOptions;
  /**
   * Creates a new loading view
   * @param owner the element that will contain the loading view (should be the NeedleEngineHTMLElement)
   */
  constructor(e, t) {
    this._element = e, this._loadingElementOptions = t;
  }
  async onLoadingBegin(e) {
    const t = this._element.shadowRoot || this._element;
    if (Xo && console.warn("Begin Loading"), !this._loadingElement) {
      for (let i = 0; i < t.children.length; i++) {
        const n = t.children[i];
        if (n.classList.contains(Bd.LoadingContainerClassName)) {
          if (!this._allowCustomLoadingElement) {
            Xo && console.warn("Remove custom loading container"), t.removeChild(n);
            continue;
          }
          this._loadingElement = this.createLoadingElement(n);
        }
      }
      this._loadingElement || (this._loadingElement = this.createLoadingElement());
    }
    this._progress = 0, this.loadingProgress = 0, this._loadingElement.style.display = "flex", t.appendChild(this._loadingElement), this.smoothProgressLoop(), this.setMessage(e ?? "");
  }
  onLoadingUpdate(e, t) {
    if (!this._loadingElement?.parentNode)
      return;
    let i = 0;
    typeof e == "number" ? i = e : ("index" in e && (i = ix(e)), !t && "name" in e && this.setMessage("loading " + e.name)), this.loadingProgress = i, t && this.setMessage(t), this.updateDisplay();
  }
  onLoadingFinished() {
    Xo && console.warn("Finished Loading"), Cl || (this.loadingProgress = 1, this.onDoneLoading());
  }
  setMessage(e) {
    this._messageContainer && (this._messageContainer.innerText = e);
  }
  _progressLoop;
  smoothProgressLoop() {
    if (this._progressLoop) return;
    let e = 1 / 12;
    Cl && (e = 1 / 500, typeof Cl == "number" && (e *= Cl)), this._progressLoop = setInterval(() => {
      this.loadingProgress >= 0.95 && !Cl && (e = 0.9), this._progress = j.lerp(this._progress, this.loadingProgress, e * this.loadingProgress), this.updateDisplay();
    }, e);
  }
  onDoneLoading() {
    this._loadingElement && (Xo && console.log("Hiding loading element"), this._loadingElement.style.display = "none", this._loadingElement.remove()), this._progressLoop && clearInterval(this._progressLoop), this._progressLoop = null;
  }
  updateDisplay() {
    const e = this._progress, t = (e * 100).toFixed(0) + "%";
    this._loadingBar && (this._loadingBar.style.width = e * 100 + "%"), this._loadingTextContainer && (this._loadingTextContainer.textContent = t);
  }
  createLoadingElement(e) {
    Xo && !e && console.log("Creating loading element"), this._loadingElement = e || document.createElement("div");
    let t = this._element.getAttribute("loading-style");
    (!t || t === "auto") && (window.matchMedia("(prefers-color-scheme: dark)").matches ? t = "dark" : t = "light");
    const i = bs();
    if (!e) {
      this._loadingElement.style.position = "absolute", this._loadingElement.style.width = "100%", this._loadingElement.style.height = "100%", this._loadingElement.style.left = "0", this._loadingElement.style.top = "0";
      const f = this._element.getAttribute("loading-background");
      f ? this._loadingElement.style.background = f : this._loadingElement.style.backgroundColor = "transparent", this._loadingElement.style.display = "flex", this._loadingElement.style.alignItems = "center", this._loadingElement.style.justifyContent = "center", this._loadingElement.style.zIndex = "0", this._loadingElement.style.flexDirection = "column", this._loadingElement.style.pointerEvents = "none", this._loadingElement.style.color = "white", this._loadingElement.style.fontFamily = 'system-ui, Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', this._loadingElement.style.fontSize = "1rem", t === "light" ? this._loadingElement.style.color = "rgba(0,0,0,.6)" : this._loadingElement.style.color = "rgba(255,255,255,.3)";
    }
    const n = this._loadingElementOptions?.className ?? Bd.LoadingContainerClassName;
    if (this._loadingElement.classList.add(n), this._loadingElementOptions?.additionalClasses)
      for (const f of this._loadingElementOptions.additionalClasses)
        this._loadingElement.classList.add(f);
    const o = document.createElement("div");
    this._loadingElement.appendChild(o);
    const r = document.createElement("img"), a = 120;
    if (r.style.width = `${a}px`, r.style.height = `${a}px`, r.style.paddingTop = "20px", r.style.paddingBottom = "10px", r.style.margin = "0px", r.style.userSelect = "none", r.style.objectFit = "contain", r.style.transition = "transform 1.5s ease-out, opacity .3s ease-in-out", r.style.transform = "translateY(30px)", r.style.opacity = "0.05", setTimeout(() => {
      r.style.opacity = "1", r.style.transform = "translateY(0px)";
    }, 1), r.src = Vb, i && this._element) {
      const f = this._element.getAttribute("loading-logo-src");
      f && (r.src = f);
    }
    o.appendChild(r);
    const l = document.createElement("div");
    l.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        opacity: 0;
        transition: opacity 1s ease-in-out 4s;
        `, setTimeout(() => {
      l.style.opacity = "1";
    }, 1), this._loadingElement.appendChild(l);
    const c = document.createElement("div"), h = 100;
    c.style.display = "flex", c.style.width = h + "%", c.style.height = "3px", c.style.position = "absolute", c.style.left = "0", c.style.bottom = "0px", c.style.opacity = "0", c.style.transition = "opacity 1s ease-in-out 2s", setTimeout(() => {
      c.style.opacity = "1";
    }, 1), t === "light" ? c.style.backgroundColor = "rgba(0,0,0,.2)" : c.style.backgroundColor = "rgba(255,255,255,.2)", this._loadingElement.appendChild(c), this._loadingBar = document.createElement("div"), c.appendChild(this._loadingBar);
    const d = function(f) {
      return j.lerp(0, h, f) + "%";
    };
    if (this._loadingBar.style.background = "#66A22F", this._loadingBar.style.backgroundAttachment = "fixed", this._loadingBar.style.width = "0%", this._loadingBar.style.height = "100%", i && this._element) {
      const f = this._element.getAttribute("primary-color"), p = this._element.getAttribute("secondary-color");
      f && p ? this._loadingBar.style.background = `linear-gradient(90deg, ${f} ${d(0)}, ${p} ${d(1)})` : f ? this._loadingBar.style.background = f : p && (this._loadingBar.style.background = p);
    }
    return this.handleRuntimeLicense(this._loadingElement), this._loadingElement;
  }
  async handleRuntimeLicense(e) {
    let t = vs();
    if (t) return;
    mb && console.log("Loading UI has commercial license?", t);
    const i = document.createElement("div");
    i.style.paddingTop = ".6em", i.style.fontSize = ".8em", i.style.textTransform = "uppercase", i.innerText = `NEEDLE ENGINE NON COMMERCIAL VERSION
CLICK HERE TO GET A LICENSE`, i.style.cursor = "pointer", i.style.userSelect = "none", i.style.textAlign = "center", i.style.pointerEvents = "all", i.addEventListener("click", () => window.open("https://needle.tools/pricing", "_self")), i.style.opacity = "0", e.appendChild(i), !L() && Ra && (mb && console.log("Waiting for runtime license check"), await Ra, t = vs()), !t && (i.style.transition = "opacity .5s ease-in-out", i.style.opacity = "1");
  }
}
d0(Yw);
const Pe = w("debugwebcomponent"), yb = "needle-engine", nx = "vr", sx = "desktop", nI = [tx, nx, sx], Ol = "ar-session-active", kl = "desktop-session-active", sI = [
  "public-key",
  "version",
  "hash",
  "src",
  "camera-controls",
  "loadstart",
  "progress",
  "loadfinished",
  "dracoDecoderPath",
  "dracoDecoderType",
  "ktx2DecoderPath",
  "tone-mapping",
  "tone-mapping-exposure",
  "background-blurriness",
  "background-color",
  "environment-intensity"
];
class ox extends HTMLElement {
  static get observedAttributes() {
    return sI;
  }
  get loadingProgress01() {
    return this._loadingProgress01;
  }
  get loadingFinished() {
    return this.loadingProgress01 > 0.999;
  }
  /**
   * If set to false the camera controls are disabled. Default is true.  
   * @type {boolean | null}
   * @memberof NeedleEngineAttributes
   * @example
   * <needle-engine camera-controls="false"></needle-engine>
   * @example
   * <needle-engine camera-controls="true"></needle-engine>
   * @example
   * <needle-engine camera-controls></needle-engine>
   * @example
   * <needle-engine></needle-engine>
   * @returns {boolean | null} if the attribute is not set it returns null
   */
  get cameraControls() {
    const e = this.getAttribute("camera-controls");
    return e == null ? null : !(e === null || e === "False" || e === "false" || e === "0" || e === "none");
  }
  /**
   * Get the current context for this web component instance. The context is created when the src attribute is set and the loading has finished.  
   * The context is disposed when the needle engine is removed from the document (you can prevent this by setting the keep-alive attribute to true).  
   * @returns a promise that resolves to the context when the loading has finished
   */
  getContext() {
    return new Promise((e, t) => {
      if (this._context && this.loadingFinished)
        e(this._context);
      else {
        const i = () => {
          this.removeEventListener("loadfinished", i), this._context && this.loadingFinished && e(this._context);
        };
        this.addEventListener("loadfinished", i);
      }
    });
  }
  /**
   * Get the context that is created when the src attribute is set and the loading has finished.
   */
  get context() {
    return this._context;
  }
  _context;
  _overlay_ar;
  _loadingProgress01 = 0;
  _loadingView;
  _previousSrc = null;
  /** set to true after <needle-engine> did load completely at least once. Set to false when <needle-engine> is removed from the document */
  _didFullyLoad = !1;
  constructor() {
    super(), this._overlay_ar = new iI(), this.addEventListener("ready", this.onReady), Y0(), this.attachShadow({ mode: "open" });
    const e = document.createElement("template");
    e.innerHTML = `<style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

    :host {
        position: absolute;
        display: block;
        width: max(600px, 100%);
        height: max(300px, 100%);
        touch-action: none;

        -webkit-tap-highlight-color: transparent;
    }

    @media (max-width: 600px) {
        :host {
            width: 100%;
        }
    }
    @media (max-height: 300px) {
        :host {
            height: 100%;
        }
    }

    :host > div.canvas-wrapper {
        width: 100%;
        height: 100%;
    }

    :host canvas {   
        position: absolute;
        user-select: none;
        -webkit-user-select: none;

        /** allow touch panning but no pinch zoom **/
        /** but this doesnt work yet: 
         * touch-action: pan-x, pan-y;
         **/
        
        -webkit-touch-callout: none;
        -webkit-user-drag: none;
        -webkit-user-modify: none;

        left: 0;
        top: 0;
    }
    :host .content {
        position: absolute;
        top: 0;
        width: 100%;
        height: 100%;
        visibility: visible;
        z-index: 500; /* < must be less than the webxr buttons element */
        pointer-events: none;
    }
    :host .overlay-content {
        position: absolute;
        user-select: auto;
        pointer-events: all;
    }
    :host slot[name="quit-ar"]:hover {
        cursor: pointer;
    }
    :host .quit-ar-button {
        position: absolute;
        // top: env(titlebar-area-y); /** this doesnt work **/
        top: 60px; /** camera access needs a bit more space **/
        right: 20px;
        z-index: 9999;
    }
</style>
<div class="canvas-wrapper"> <!-- this wrapper is necessary for WebXR https://github.com/meta-quest/immersive-web-emulator/issues/55 -->
    <canvas></canvas>
</div>
<div class="content">
    <slot class="overlay-content"></slot>
</div>
`, this.shadowRoot && this.shadowRoot.appendChild(e.content.cloneNode(!0)), this._context = new N({ domElement: this }), this.addEventListener("error", this.onError);
  }
  /**
   * @internal
   */
  async connectedCallback() {
    if (Pe && console.log("<needle-engine> connected"), this.setPublicKey(), this.setVersion(), (this.getAttribute("tabindex") === null || this.getAttribute("tabindex") === void 0) && this.setAttribute("tabindex", "0"), this.addEventListener("xr-session-started", this.onXRSessionStarted), this.onSetupDesktop(), !this.getAttribute("src")) {
      const t = globalThis["needle:codegen_files"];
      Pe && console.log('src is null, trying to load from globalThis["needle:codegen_files"]', t), t && (Pe && console.log('globalThis["needle:codegen_files"]', t), this.setAttribute("src", t));
    }
    Pe && console.log("src", this.getAttribute("src"));
    const e = this._loadId;
    setTimeout(() => {
      this.isConnected !== !1 && e === this._loadId && this.onLoad();
    }, 1);
  }
  /**
   * @internal
   */
  disconnectedCallback() {
    this.removeEventListener("xr-session-started", this.onXRSessionStarted), this._didFullyLoad = !1;
    const e = this.getAttribute("keep-alive"), t = e == null || e?.length > 0 && e !== "true" && e !== "1";
    Pe && console.warn('<needle-engine> disconnected, keep-alive: "' + e + '"', typeof e, "Dispose=", t), t ? (Pe && console.warn("<needle-engine> dispose"), this._context?.dispose(), this._context = null, this._lastSourceFiles = null, this._loadId += 1) : Pe && console.warn("<needle-engine> is not disposed because keep-alive is set");
  }
  /**
   * @internal
   */
  attributeChangedCallback(e, t, i) {
    switch (Pe && console.log("attributeChangedCallback", e, t, i), e) {
      case "src":
        Pe && console.warn(`<needle-engine src>
changed from "`, t, '" to "', i, '"'), this.onLoad();
        break;
      case "hash":
        this._context && (this._context.hash = i);
        break;
      case "loadstart":
      case "progress":
      case "loadfinished":
        typeof i == "string" && i.length > 0 && (Pe && console.log(e + " attribute changed", i), this.registerEventFromAttribute(e, i));
        break;
      case "dracoDecoderPath":
        Pe && console.log("dracoDecoderPath", i), y_(i);
        break;
      case "dracoDecoderType":
        i === "wasm" || i === "js" ? (Pe && console.log("dracoDecoderType", i), __(i)) : console.error("Invalid dracoDecoderType", i, "expected js or wasm");
        break;
      case "ktx2DecoderPath":
        Pe && console.log("ktx2DecoderPath", i), b_(i);
        break;
      case "tonemapping":
      case "tone-mapping":
      case "tone-mapping-exposure":
      case "background-blurriness":
      case "background-color":
      case "environment-intensity": {
        this.applyAttributes();
        break;
      }
      case "public-key": {
        i != Rl && this.setPublicKey();
        break;
      }
      case "version": {
        i != En && this.setVersion();
        break;
      }
    }
  }
  /** The tonemapping setting configured as an attribute on the <needle-engine> component */
  get toneMapping() {
    return this.getAttribute("tonemapping") || this.getAttribute("tone-mapping");
  }
  _loadId = 0;
  _abortController = null;
  _lastSourceFiles = null;
  _createContextPromise = null;
  async onLoad() {
    if (!this.isConnected) return;
    if (this._context || (Pe && console.warn("Create new context"), this._context = new N({ domElement: this })), !this._context) {
      console.error("Needle Engine: Context not initialized");
      return;
    }
    const e = this.getSourceFiles();
    if (!this.checkIfSourceHasChanged(e, this._lastSourceFiles))
      return;
    this._abortController && (Pe && console.warn("Abort previous loading process"), this._abortController.abort(), this._abortController = null), this._lastSourceFiles = e;
    const t = ++this._loadId;
    if ((e == null || e.length <= 0) && (Pe && console.warn("Clear scene", e), this._context.clear(), t !== this._loadId))
      return;
    const i = this.getAttribute("alias");
    this.classList.add("loading");
    const n = vs();
    this.ensureLoadStartIsRegistered();
    let o = this.dispatchEvent(new CustomEvent("loadstart", {
      detail: {
        context: this._context,
        alias: i
      },
      cancelable: !0
    }));
    if (n) {
      const g = this.getAttribute("hide-loading-overlay");
      g != null && g !== "0" && (o = !1);
    }
    o === !1 && !n && (L() || (o = !0), console.warn("Needle Engine: You need a commercial license to override the default loading view. Visit https://needle.tools/pricing"), L() && ge('You need a <a target="_blank" href="https://needle.tools/pricing">commercial license</a> to override the default loading view. This will not work in production.')), !this._loadingView && o && (this._loadingView = new Bd(this)), o && (this._didFullyLoad !== !0 ? this._loadingView?.onLoadingBegin("begin load") : setTimeout(() => {
      this._loadingView && this._loadingProgress01 < 0.3 && this._loadId === t && this._loadingView.onLoadingBegin("begin load");
    }, 300)), Pe && console.warn(`--------------
Needle Engine: Begin loading ` + t + `
`, e), this.onBeforeBeginLoading();
    const r = [], a = {
      context: this._context,
      name: "",
      progress: {},
      index: 0,
      count: e.length,
      totalProgress01: this._loadingProgress01
    }, l = new CustomEvent("progress", { detail: a }), c = new Array(), h = new AbortController();
    this._abortController = h;
    const d = {
      files: e,
      abortSignal: h.signal,
      onLoadingProgress: (g) => {
        if (Pe && console.debug("Loading progress: ", g), h.signal.aborted) return;
        const b = g.index;
        !c[b] && g.name && (c[b] = oI(g.name)), g.name = c[b], o && this._loadingView?.onLoadingUpdate(g), a.name = g.name, a.progress = g.progress, this._loadingProgress01 = ix(g), a.totalProgress01 = this._loadingProgress01, this.dispatchEvent(l);
      },
      onLoadingFinished: (g, b, m) => {
        Pe && console.debug(`Finished loading "${b}" (aborted? ${h.signal.aborted})`), !h.signal.aborted && m && r.push({
          src: b,
          file: m
        });
      }
    };
    rI(this);
    const f = this.getAttribute("hash");
    f != null && (this._context.hash = f), this._context.alias = i, this._createContextPromise = this._context.create(d);
    const p = await this._createContextPromise;
    if (this.applyAttributes(), Pe && console.warn(`--------------
Needle Engine: finished loading ` + t + `
`, e, `Aborted? ${h.signal.aborted}`), h.signal.aborted) {
      console.log("Loading finished but aborted...");
      return;
    }
    if (this._loadId !== t) {
      console.log("Load id changed during loading process");
      return;
    }
    this._loadingProgress01 = 1, o && p && this._loadingView?.onLoadingUpdate(1, "creating scene"), this._didFullyLoad = !0, this.classList.remove("loading"), this.classList.add("loading-finished"), this.dispatchEvent(new CustomEvent("loadfinished", {
      detail: {
        context: this._context,
        src: i,
        loadedFiles: r
      }
    }));
  }
  applyAttributes() {
    if (this._context?.renderer) {
      const n = Q0(this.toneMapping);
      n !== void 0 && (this._context.renderer.toneMapping = n);
      const o = this.getAttribute("tone-mapping-exposure");
      if (o != null) {
        const r = parseFloat(o);
        isNaN(r) || (this._context.renderer.toneMappingExposure = r);
      }
    }
    const e = this.getAttribute("background-blurriness");
    if (e != null) {
      const n = parseFloat(e);
      !isNaN(n) && this._context && (this._context.scene.backgroundBlurriness = n);
    }
    const t = this.getAttribute("environment-intensity");
    if (t != null && this._context) {
      const n = parseFloat(t);
      !isNaN(n) && this._context && (this._context.scene.environmentIntensity = n);
    }
    const i = this.getAttribute("background-color");
    if (this._context?.renderer && typeof i == "string" && i.length > 0) {
      const n = oe.fromColorRepresentation(i);
      Pe && console.debug("<needle-engine> background-color changed, str:", i, "→", n), this._context.renderer.setClearColor(n, n.alpha), this.context.scene.background = null;
    }
  }
  onXRSessionStarted = () => {
    const e = this.context.xrSessionMode;
    e === "immersive-ar" ? this.onEnterAR(this.context.xrSession) : e === "immersive-vr" && this.onEnterVR(this.context.xrSession), this.context.xrSession?.addEventListener("end", () => {
      this.dispatchEvent(new CustomEvent("xr-session-ended", { detail: { session: this.context.xrSession, context: this._context, sessionMode: e } })), e === "immersive-ar" ? this.onExitAR(this.context.xrSession) : e === "immersive-vr" && this.onExitVR(this.context.xrSession);
    });
  };
  /** called by the context when the first frame has been rendered */
  onReady = () => this._loadingView?.onLoadingFinished();
  onError = () => this._loadingView?.setMessage("Loading failed!");
  getSourceFiles() {
    const e = this.getAttribute("src");
    if (!e) return [];
    let t;
    Array.isArray(e) ? t = e : e.startsWith("[") && e.endsWith("]") ? t = JSON.parse(e) : e.includes(",") ? t = e.split(",") : t = [e];
    for (let i = t.length - 1; i >= 0; i--) {
      const n = t[i];
      (n === "null" || n === "undefined" || n?.length <= 0) && t.splice(i, 1);
    }
    return t;
  }
  checkIfSourceHasChanged(e, t) {
    if (e?.length !== t?.length || e == null && t !== null || e !== null && t == null) return !0;
    if (e !== null && t !== null) {
      for (let i = 0; i < e?.length; i++)
        if (e[i] !== t[i]) return !0;
    }
    return !1;
  }
  _previouslyRegisteredMap = /* @__PURE__ */ new Map();
  ensureLoadStartIsRegistered() {
    const e = this.getAttribute("loadstart");
    e && this.registerEventFromAttribute("loadstart", e);
  }
  registerEventFromAttribute(e, t) {
    const i = this._previouslyRegisteredMap.get(e);
    if (i && (this._previouslyRegisteredMap.delete(e), this.removeEventListener(e, i)), typeof t == "string" && t.length > 0)
      try {
        const n = (0, eval)(t);
        typeof n == "function" && (this._previouslyRegisteredMap.set(e, n), this.addEventListener(e, (o) => n?.call(globalThis, this._context, o)));
      } catch (n) {
        console.error("Error registering event " + e + '="' + t + `" failed with the following error:
`, n);
      }
  }
  setPublicKey() {
    Rl && Rl.length > 0 && this.setAttribute("public-key", Rl);
  }
  setVersion() {
    En.length > 0 && this.setAttribute("version", En);
  }
  /**
   * @internal
   */
  getAROverlayContainer() {
    return this._overlay_ar.createOverlayContainer(this);
  }
  /**
   * @internal
   */
  getVROverlayContainer() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      if (t.classList.contains("vr"))
        return t;
    }
    return null;
  }
  /**
   * @internal
   */
  onEnterAR(e) {
    this.onSetupAR();
    const t = this.getAROverlayContainer();
    this._overlay_ar.onBegin(this._context, t, e), this.dispatchEvent(new CustomEvent("enter-ar", { detail: { session: e, context: this._context, htmlContainer: this._overlay_ar?.ARContainer } }));
  }
  /**
   * @internal
   */
  onExitAR(e) {
    this._overlay_ar.onEnd(this._context), this.onSetupDesktop(), this.dispatchEvent(new CustomEvent("exit-ar", { detail: { session: e, context: this._context, htmlContainer: this._overlay_ar?.ARContainer } }));
  }
  /**
   * @internal
   */
  onEnterVR(e) {
    this.onSetupVR(), this.dispatchEvent(new CustomEvent("enter-vr", { detail: { session: e, context: this._context } }));
  }
  /**
   * @internal
   */
  onExitVR(e) {
    this.onSetupDesktop(), this.dispatchEvent(new CustomEvent("exit-vr", { detail: { session: e, context: this._context } }));
  }
  onSetupAR() {
    this.classList.add(Ol), this.classList.remove(kl);
    const e = this.getAROverlayContainer();
    Pe && console.warn("onSetupAR:", e), e && (e.classList.add(Ol), e.classList.remove(kl)), this.foreachHtmlElement((t) => this.setupElementsForMode(t, tx));
  }
  onSetupVR() {
    this.classList.remove(Ol), this.classList.remove(kl), this.foreachHtmlElement((e) => this.setupElementsForMode(e, nx));
  }
  onSetupDesktop() {
    this.classList.remove(Ol), this.classList.add(kl);
    const e = this.getAROverlayContainer();
    e && (e.classList.remove(Ol), e.classList.add(kl)), this.foreachHtmlElement((t) => this.setupElementsForMode(t, sx));
  }
  setupElementsForMode(e, t, i = null) {
    if (e === this._context?.renderer?.domElement || e.id === "VRButton" || e.id === "ARButton") return;
    if (e.classList.contains(t))
      e.style.visibility = "visible", e.style.display === "none" && (e.style.display = "block");
    else
      for (const o of nI)
        e.classList.contains(o) && (e.style.visibility = "hidden", e.style.display = "none");
  }
  foreachHtmlElement(e) {
    for (let t = 0; t < this.children.length; t++) {
      const i = this.children[t];
      i.style && e(i);
    }
  }
  onBeforeBeginLoading() {
    const e = this.getAttribute("dracoDecoderPath");
    e && (Pe && console.log("using custom draco decoder path", e), y_(e));
    const t = this.getAttribute("dracoDecoderType");
    t && (Pe && console.log("using custom draco decoder type", t), __(t));
    const i = this.getAttribute("ktx2DecoderPath");
    i && (Pe && console.log("using custom ktx2 decoder path", i), b_(i));
  }
}
typeof window < "u" && !window.customElements.get(yb) && window.customElements.define(yb, ox);
function oI(s) {
  if (s.startsWith("blob:"))
    return "blob";
  const e = s.split("/");
  let t = e[e.length - 1];
  const i = t.indexOf("?");
  i > 0 && (t = t.substring(0, i));
  const n = t.indexOf("=");
  n > 0 && (t = t.substring(n));
  const o = t.split(".").pop(), a = o ? ["glb", "gltf", "usdz", "usd", "fbx", "obj", "mtl"].indexOf(o.toLowerCase()) : -1;
  if (o && a >= 0 && (t = t.substring(0, t.length - o.length - 1)), t = decodeURIComponent(t), t.length > 3) {
    let l = "", c = !1;
    const h = ["(", ")", "[", "]", "{", "}", ":", ";", ",", ".", "!", "?"];
    for (let d = 0; d < t.length; d++) {
      let f = t[d];
      (f === "_" || f === "-") && (f = " "), !(f === " " && l.length <= 0 || h.includes(f) || (l.length === 0 && (f = f.toUpperCase()), c && f === " ")) && (c && (f = f.toUpperCase()), c = !1, l += f, f === " " && (c = !0));
    }
    return L() && t !== l && console.debug('Generated display name: "' + t + '" → "' + l + '"'), l.trim();
  }
  return L() && console.debug("Loading: use default name", t), t;
}
function rI(s) {
  tg((e) => {
    const t = s.getAttribute("loading-blur");
    if (t !== null && t !== "0" && e.domElement === s) {
      const i = e.lodsManager.manager?.awaitLoading({
        frames: 5,
        signal: AbortSignal.timeout(1e4),
        // Limit how long the page can be blurred
        maxPromisesPerObject: 1
      }).catch((r) => {
      });
      let n = "20px";
      t.endsWith("px") && (n = t);
      const o = 170;
      if (e.scene.background === null) {
        const r = s, a = e.renderer.domElement, l = a.style.filter, c = a.style.overflow;
        a.style.filter += `blur(${n})`, r.style.overflow = "hidden", i?.then(() => {
          const h = a.animate([
            {
              filter: "blur(0px)"
            }
          ], { duration: o, easing: "ease-in" });
          h.onfinish = () => {
            a.style.filter = l, r.style.overflow = c;
          };
        });
      } else {
        const r = document.createElement("div");
        e.domElement.prepend(r), r.style.cssText = "position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none", r.style.backdropFilter = `blur(${n})`, i?.then(() => {
          const a = r.animate([
            {
              backdropFilter: "blur(0px)",
              opacity: 0
            }
          ], { duration: o, easing: "ease-in" });
          a.onfinish = () => {
            r.remove();
          };
        });
      }
    }
  }, { once: !0 });
}
const aI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NeedleEngineWebComponent: ox
}, Symbol.toStringTag, { value: "Module" }));
function lI() {
  Fn.registerWaitForInteraction(() => {
    const s = wS.getContext();
    s.addEventListener("statechange", () => {
      setTimeout(() => {
        const e = s.state;
        (e === "suspended" || e === "interrupted") && s.resume().then(() => {
          console.log("AudioContext resumed successfully");
        }).catch((t) => {
          console.log("Failed to resume AudioContext: " + t);
        });
      }, 500);
    });
  });
}
setTimeout(lI, 1e3);
const Xe = w("debugphysics"), hp = w("debugcolliderplacement"), dp = w("debugcollisions"), cI = w("showcolliders"), jh = w("debugraycasts"), Zt = Symbol("needle component"), Ut = Symbol("physics body"), _b = Symbol("rigidbody");
globalThis.NEEDLE_USE_RAPIER = globalThis.NEEDLE_USE_RAPIER !== void 0 ? globalThis.NEEDLE_USE_RAPIER : !0;
Xe && console.log("Use Rapier", !0, globalThis.NEEDLE_USE_RAPIER);
ue.registerCallback(he.ContextCreationStart, (s) => {
  Xe && console.log("Register rapier physics backend"), s.context.physics.engine = new ac(s.context);
});
class ac {
  debugRenderColliders = !1;
  debugRenderRaycasts = !1;
  removeBody(e) {
    if (!e) return;
    this.validate();
    const t = e[Ut];
    if (e[Ut] = null, t && this.world) {
      const i = this.objects.findIndex((n) => n === e);
      if (i >= 0) {
        const n = this.bodies[i];
        if (this.bodies.splice(i, 1), this.objects.splice(i, 1), n instanceof T.RAPIER_PHYSICS.MODULE.Collider) {
          const o = n;
          this.world?.removeCollider(o, !0);
          const r = o.parent();
          r && r.numColliders() <= 0 && (r[Zt] || this.world?.removeRigidBody(r));
        } else n instanceof T.RAPIER_PHYSICS.MODULE.RigidBody && (n.numColliders() <= 0 ? this.world?.removeRigidBody(n) : L() && (n.did_log_removing || setTimeout(() => {
          n.numColliders() > 0 && (n.did_log_removing = !0, console.warn("RapierPhysics: removing rigidbody with colliders from the physics world is not possible right now, please remove the colliders first"));
        }, 1)));
      }
    }
  }
  updateBody(e, t, i) {
    if (this.validate(), !!this.enabled && !(e.destroyed || !e.gameObject) && !(!t && !i))
      if (e.isCollider === !0)
        console.warn("TODO: implement updating collider position");
      else {
        const n = e, o = n[Ut];
        o && this.syncPhysicsBody(n.gameObject, o, t, i);
      }
  }
  updateProperties(e) {
    if (this.validate(), e.isCollider) {
      const t = e, i = t[Ut];
      i && (this.internalUpdateColliderProperties(t, i), t.sharedMaterial && this.updatePhysicsMaterial(t));
    } else {
      const t = e, i = this.internal_getRigidbody(t);
      i && this.internalUpdateRigidbodyProperties(t, i);
    }
  }
  addForce(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.addForce(t, i) : this._isInitialized && console.warn("Physics Body doesn't exist: can not apply force (does your object with the Rigidbody have a collider?)");
  }
  addImpulse(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.applyImpulse(t, i) : this._isInitialized && console.warn("Physics Body doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  getLinearVelocity(e) {
    this.validate();
    const t = this.internal_getRigidbody(e);
    return t ? t.linvel() : null;
  }
  getAngularVelocity(e) {
    this.validate();
    const t = this.internal_getRigidbody(e);
    return t ? t.angvel() : null;
  }
  resetForces(e, t) {
    this.validate(), this.internal_getRigidbody(e)?.resetForces(t);
  }
  resetTorques(e, t) {
    this.validate(), this.internal_getRigidbody(e)?.resetTorques(t);
  }
  applyImpulse(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.applyImpulse(t, i) : this._isInitialized && console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  wakeup(e) {
    this.validate();
    const t = this.internal_getRigidbody(e);
    t ? t.wakeUp() : this._isInitialized && console.warn("Rigidbody doesn't exist: can not wake up (does your object with the Rigidbody have a collider?)");
  }
  isSleeping(e) {
    return this.validate(), this.internal_getRigidbody(e)?.isSleeping();
  }
  setAngularVelocity(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.setAngvel(t, i) : this._isInitialized && console.warn("Rigidbody doesn't exist: can not set angular velocity (does your object with the Rigidbody have a collider?)");
  }
  setLinearVelocity(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.setLinvel(t, i) : this._isInitialized && console.warn("Rigidbody doesn't exist: can not set linear velocity (does your object with the Rigidbody have a collider?)");
  }
  context;
  _initializePromise;
  _isInitialized = !1;
  constructor(e) {
    this.context = e;
  }
  get isInitialized() {
    return this._isInitialized;
  }
  async initialize() {
    return this._initializePromise || (this._initializePromise = this.internalInitialization()), this._initializePromise;
  }
  async internalInitialization() {
    return w("__nophysics") ? (console.warn("Physics are disabled"), !1) : (Xe && console.log("Initialize rapier physics engine"), this._hasCreatedWorld ? (console.error("Invalid call to create physics world: world is already created"), !0) : (this._hasCreatedWorld = !0, T.RAPIER_PHYSICS.MAYBEMODULE == null && (Xe && console.trace("Loading rapier physics engine"), await (await T.RAPIER_PHYSICS.load()).init()), Xe && console.log("Physics engine initialized, creating world..."), this._world = new T.RAPIER_PHYSICS.MODULE.World(this._gravity), this.rapierRay = new T.RAPIER_PHYSICS.MODULE.Ray({ x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 }), this.enabled = !0, this._isInitialized = !0, Xe && console.log("Physics world created"), !0));
  }
  /** Check is the physics engine has been initialized and the call can be made */
  validate() {
    this._isInitialized || Xe && (this._lastWarnTime = this._lastWarnTime ?? 0, Date.now() - this._lastWarnTime > 1e3 && (this._lastWarnTime = Date.now(), console.warn("Physics engine is not initialized")));
  }
  rapierRay;
  raycastVectorsBuffer = new Hi(() => new y(), 10);
  raycast(e, t, i) {
    if (!this._isInitialized)
      return console.log("Physics engine is not initialized"), null;
    let n = i?.maxDistance, o = i?.solid;
    n === void 0 && (n = 1 / 0), o === void 0 && (o = !0);
    const r = this.getPhysicsRay(this.rapierRay, e, t);
    if (!r) return null;
    (this.debugRenderRaycasts || jh) && z.DrawRay(r.origin, r.dir, 255, 1);
    const a = this.world?.castRay(r, n, o, i?.queryFilterFlags, i?.filterGroups, void 0, void 0, (l) => {
      const c = l[Zt];
      return i?.filterPredicate ? i.filterPredicate(c) : i?.useIgnoreRaycastLayer !== !1 ? !c?.gameObject.layers.isEnabled(2) : !0;
    });
    if (a) {
      const l = r.pointAt(a.timeOfImpact), c = this.raycastVectorsBuffer.get();
      return c.set(l.x, l.y, l.z), { point: c, collider: a.collider[Zt] };
    }
    return null;
  }
  raycastAndGetNormal(e, t, i) {
    if (!this._isInitialized)
      return null;
    let n = i?.maxDistance, o = i?.solid;
    n === void 0 && (n = 1 / 0), o === void 0 && (o = !0);
    const r = this.getPhysicsRay(this.rapierRay, e, t);
    if (!r) return null;
    (this.debugRenderRaycasts || jh) && z.DrawRay(r.origin, r.dir, 255, 1);
    const a = this.world?.castRayAndGetNormal(r, n, o, i?.queryFilterFlags, i?.filterGroups, void 0, void 0, (l) => {
      const c = l[Zt];
      return i?.filterPredicate ? i.filterPredicate(c) : i?.useIgnoreRaycastLayer !== !1 ? !c?.gameObject.layers.isEnabled(2) : !0;
    });
    if (a) {
      const l = r.pointAt(a.timeOfImpact), c = a.normal, h = this.raycastVectorsBuffer.get(), d = this.raycastVectorsBuffer.get();
      return h.set(l.x, l.y, l.z), d.set(c.x, c.y, c.z), { point: h, normal: d, collider: a.collider[Zt] };
    }
    return null;
  }
  getPhysicsRay(e, t, i) {
    const n = this.context?.mainCamera;
    if (t === void 0) {
      const a = this.context?.input.getPointerPosition(0);
      if (a) t = a;
      else return null;
    }
    if (t.z === void 0) {
      if (!n)
        return console.error("Can not perform raycast from 2d point - no main camera found"), null;
      const a = this.raycastVectorsBuffer.get();
      a.x = t.x, a.y = t.y, a.z = 0, (a.x > 1 || a.y > 1 || a.y < -1 || a.x < -1) && (Xe && console.warn("Converting screenspace to raycast space", a), this.context?.input.convertScreenspaceToRaycastSpace(a)), a.unproject(n), t = a;
    }
    const o = t;
    e.origin.x = o.x, e.origin.y = o.y, e.origin.z = o.z;
    const r = this.raycastVectorsBuffer.get();
    if (i)
      r.set(i.x, i.y, i.z);
    else {
      if (!n)
        return console.error("Can not perform raycast - no camera found"), null;
      r.set(e.origin.x, e.origin.y, e.origin.z);
      const a = Z(n);
      r.sub(a);
    }
    return r.normalize(), e.dir.x = r.x, e.dir.y = r.y, e.dir.z = r.z, e;
  }
  rapierSphere = null;
  rapierBox = null;
  rapierColliderArray = [];
  rapierIdentityRotation = { x: 0, y: 0, z: 0, w: 1 };
  rapierForwardVector = { x: 0, y: 0, z: 1 };
  /** Precice sphere overlap detection using rapier against colliders
   * @param point center of the sphere in worldspace
   * @param radius radius of the sphere
   * @returns array of colliders that overlap with the sphere. Note: they currently only contain the collider and the gameobject
   */
  sphereOverlap(e, t) {
    return this.rapierSphere ??= new T.RAPIER_PHYSICS.MODULE.Ball(t), this.rapierSphere.radius = t, (this.debugRenderRaycasts || jh) && z.DrawWireSphere(e, t, 3359999, 1), this.shapeOverlap(e, this.rapierIdentityRotation, this.rapierSphere);
  }
  /** box overlap detection using rapier against colliders
   * @param point center of the box in worldspace
   * @param size size of the box
   * @param rotation quaternion representation of the rotation in world space
   * @returns array of colliders that overlap with the box. Note: they currently only contain the collider and the gameobject
   */
  boxOverlap(e, t, i = null) {
    return i === null && (i = this.rapierIdentityRotation), this.rapierBox ??= new T.RAPIER_PHYSICS.MODULE.Cuboid(1, 1, 1), this.rapierBox.halfExtents.x = t.x * 0.5, this.rapierBox.halfExtents.y = t.y * 0.5, this.rapierBox.halfExtents.z = t.z * 0.5, (this.debugRenderRaycasts || jh) && z.DrawWireBox(e, t, 3359999, 1, !0, i), this.shapeOverlap(e, i, this.rapierBox);
  }
  shapeOverlap(e, t, i) {
    return this.rapierColliderArray.length = 0, this._isInitialized ? this.world ? (this.world.intersectionsWithShape(
      e,
      t,
      i,
      (n) => {
        const o = n[Zt], r = new $k(o.gameObject, o);
        return this.rapierColliderArray.push(r), !0;
      },
      // TODO: it seems as QueryFilterFlags.EXCLUDE_SENSORS also excludes DYNAMIC Rigidbodies (only if they're set to kinematic)
      void 0,
      // QueryFilterFlags.EXCLUDE_SENSORS, 
      void 0,
      void 0,
      void 0,
      (n) => n.isSensor() ? !1 : n[Zt].gameObject.layers.isEnabled(2) == !1
    ), this.rapierColliderArray) : this.rapierColliderArray : this.rapierColliderArray;
  }
  // physics simulation
  enabled = !1;
  /** Get access to the rapier world */
  get world() {
    return this._world;
  }
  _tempPosition = new y();
  _tempQuaternion = new U();
  _tempScale = new y();
  _tempMatrix = new ee();
  static _didLoadPhysicsEngine = !1;
  _isUpdatingPhysicsWorld = !1;
  get isUpdating() {
    return this._isUpdatingPhysicsWorld;
  }
  _world;
  _hasCreatedWorld = !1;
  eventQueue;
  collisionHandler;
  objects = [];
  bodies = [];
  _meshCache = /* @__PURE__ */ new Map();
  _gravity = { x: 0, y: -9.81, z: 0 };
  get gravity() {
    return this.world?.gravity ?? this._gravity;
  }
  set gravity(e) {
    this.world ? this.world.gravity = e : this._gravity = e;
  }
  clearCaches() {
    this._meshCache.clear(), this.eventQueue?.raw && this.eventQueue?.free(), this.world?.bodies && this.world?.free();
  }
  async addBoxCollider(e, t) {
    if (this._isInitialized || await this.initialize(), !e.activeAndEnabled) return;
    if (!this.enabled) {
      Xe && console.warn("Physics are disabled");
      return;
    }
    const i = e.gameObject, n = Qe(i, this._tempPosition).multiply(t);
    n.multiplyScalar(0.5), n.x < 0 && (n.x = Math.abs(n.x)), n.y < 0 && (n.y = Math.abs(n.y)), n.z < 0 && (n.z = Math.abs(n.z));
    const o = 1e-7;
    n.x < o && (n.x = o), n.y < o && (n.y = o), n.z < o && (n.z = o);
    const r = T.RAPIER_PHYSICS.MODULE.ColliderDesc.cuboid(n.x, n.y, n.z);
    this.createCollider(e, r);
  }
  async addSphereCollider(e) {
    if (this._isInitialized || await this.initialize(), !e.activeAndEnabled) return;
    if (!this.enabled) {
      Xe && console.warn("Physics are disabled");
      return;
    }
    const t = T.RAPIER_PHYSICS.MODULE.ColliderDesc.ball(0.5);
    this.createCollider(e, t), this.updateProperties(e);
  }
  async addCapsuleCollider(e, t, i) {
    if (this._isInitialized || await this.initialize(), !e.activeAndEnabled) return;
    if (!this.enabled) {
      Xe && console.warn("Physics are disabled");
      return;
    }
    const o = e.gameObject.worldScale;
    o.x = Math.abs(o.x), o.y = Math.abs(o.y);
    const r = i * o.x;
    t = Math.max(t, r);
    const a = j.clamp(t * 0.5 * o.y - i * o.x, 0, Number.MAX_SAFE_INTEGER), l = T.RAPIER_PHYSICS.MODULE.ColliderDesc.capsule(a, r);
    this.createCollider(e, l);
  }
  async addMeshCollider(e, t, i, n) {
    let o = t.geometry;
    if (!o) {
      Xe && console.warn("Missing mesh geometry", t.name);
      return;
    }
    o.index?.array?.length || (console.warn(`Your MeshCollider is missing vertices or indices in the assined mesh "${t.name}". Consider providing an indexed geometry.`), o = HS(o));
    let r = null;
    const a = o.getAttribute("position");
    if (a instanceof Mb) {
      const d = a.count;
      r = new Float32Array(d * 3);
      for (let f = 0; f < d; f++) {
        const p = a.getX(f), g = a.getY(f), b = a.getZ(f);
        r[f * 3] = p, r[f * 3 + 1] = g, r[f * 3 + 2] = b;
      }
    } else
      r = a.array;
    if (await this.initialize(), !this.enabled) {
      Xe && console.warn("Physics are disabled");
      return;
    }
    if (!e.activeAndEnabled) return;
    const l = o.index?.array, c = e.gameObject.worldScale.clone();
    if (n && c.multiply(n), Math.abs(c.x - 1) > 1e-4 || Math.abs(c.y - 1) > 1e-4 || Math.abs(c.z - 1) > 1e-4) {
      const d = `${o.uuid}_${c.x}_${c.y}_${c.z}_${i}`;
      if (this._meshCache.has(d))
        Xe && console.warn("Use cached mesh collider"), r = this._meshCache.get(d);
      else {
        (Xe || L()) && console.debug(`[Performance] Your MeshCollider "${e.name}" is scaled: consider applying the scale to the collider mesh instead (${c.x}, ${c.y}, ${c.z})`);
        const f = new Float32Array(r.length);
        for (let p = 0; p < r.length; p += 3)
          f[p] = r[p] * c.x, f[p + 1] = r[p + 1] * c.y, f[p + 2] = r[p + 2] * c.z;
        r = f, this._meshCache.set(d, f);
      }
    }
    const h = i ? T.RAPIER_PHYSICS.MODULE.ColliderDesc.convexHull(r) : T.RAPIER_PHYSICS.MODULE.ColliderDesc.trimesh(r, l);
    h && this.createCollider(e, h);
  }
  updatePhysicsMaterial(e) {
    if (!e) return;
    const t = e.sharedMaterial, i = e[Ut];
    if (i && t) {
      if (t.bounciness !== void 0 && i.setRestitution(t.bounciness), t.bounceCombine !== void 0)
        switch (t.bounceCombine) {
          case xt.Average:
            i.setRestitutionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case xt.Maximum:
            i.setRestitutionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case xt.Minimum:
            i.setRestitutionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case xt.Multiply:
            i.setRestitutionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      if (t.dynamicFriction !== void 0 && i.setFriction(t.dynamicFriction), t.frictionCombine !== void 0)
        switch (t.frictionCombine) {
          case xt.Average:
            i.setFrictionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case xt.Maximum:
            i.setFrictionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case xt.Minimum:
            i.setFrictionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case xt.Multiply:
            i.setFrictionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
    }
  }
  /** Get the rapier body for a Needle component */
  getBody(e) {
    return e ? e[Ut] : null;
  }
  /** Get the Needle Engine component for a rapier object */
  getComponent(e) {
    return e ? e[Zt] : null;
  }
  createCollider(e, t) {
    if (!this.world) throw new Error("Physics world not initialized");
    const i = this._tempMatrix;
    let n;
    e.attachedRigidbody ? n = this.getRigidbody(e, this._tempMatrix) : (Xe && console.log("Create collider without rigidbody", e.name), i.makeRotationFromQuaternion(be(e.gameObject)), i.setPosition(Z(e.gameObject))), i.decompose(this._tempPosition, this._tempQuaternion, this._tempScale), this.tryApplyCenter(e, this._tempPosition), t.setTranslation(this._tempPosition.x, this._tempPosition.y, this._tempPosition.z), t.setRotation(this._tempQuaternion), t.setSensor(e.isTrigger);
    const o = e.sharedMaterial;
    if (o) {
      if (o.bounciness !== void 0 && t.setRestitution(o.bounciness), o.bounceCombine !== void 0)
        switch (o.bounceCombine) {
          case xt.Average:
            t.setRestitutionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case xt.Maximum:
            t.setRestitutionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case xt.Minimum:
            t.setRestitutionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case xt.Multiply:
            t.setRestitutionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      if (o.dynamicFriction !== void 0 && t.setFriction(o.dynamicFriction), o.frictionCombine !== void 0)
        switch (o.frictionCombine) {
          case xt.Average:
            t.setFrictionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case xt.Maximum:
            t.setFrictionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case xt.Minimum:
            t.setFrictionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case xt.Multiply:
            t.setFrictionCombineRule(T.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
    }
    e.attachedRigidbody?.autoMass === !1 && (t.setDensity(1e-6), t.setMass(1e-6));
    try {
      const r = this.world.createCollider(t, n);
      return r[Zt] = e, e[Ut] = r, r.setActiveEvents(T.RAPIER_PHYSICS.MODULE.ActiveEvents.COLLISION_EVENTS), r.setActiveCollisionTypes(T.RAPIER_PHYSICS.MODULE.ActiveCollisionTypes.ALL), this.objects.push(e), this.bodies.push(r), this.updateColliderCollisionGroups(e), r;
    } catch (r) {
      return console.error('Error creating collider "' + e.name + `"
Error:`, r), null;
    }
  }
  /**
   * Updates the collision groups of a collider.
   * 
   * @param collider - The collider to update.
   */
  updateColliderCollisionGroups(e) {
    const t = e[Ut], i = e.membership;
    let n = 0;
    if (i == null)
      n = 65535;
    else
      for (let a = 0; a < i.length; a++) {
        const l = i[a];
        l > 31 ? console.error(`Rapier only supports 32 layers, layer ${l} is not supported`) : n |= 1 << Math.floor(l);
      }
    const o = e.filter;
    let r = 0;
    if (o == null)
      r = 65535;
    else
      for (let a = 0; a < o.length; a++) {
        const l = o[a];
        l > 31 ? console.error(`Rapier only supports 32 layers, layer ${l} is not supported`) : r |= 1 << Math.floor(l);
      }
    t.setCollisionGroups(n << 16 | r);
  }
  getRigidbody(e, t) {
    if (!this.world) throw new Error("Physics world not initialized");
    let i = null;
    if (e.attachedRigidbody) {
      const n = e.attachedRigidbody;
      if (i = n[Ut], !i) {
        const o = n.isKinematic && !hp;
        Xe && console.log("Create rigidbody", o);
        const r = o ? T.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased() : T.RAPIER_PHYSICS.MODULE.RigidBodyDesc.dynamic(), a = Z(e.attachedRigidbody.gameObject);
        r.setTranslation(a.x, a.y, a.z), r.setRotation(be(e.attachedRigidbody.gameObject)), r.centerOfMass = new T.RAPIER_PHYSICS.MODULE.Vector3(n.centerOfMass.x, n.centerOfMass.y, n.centerOfMass.z), i = this.world.createRigidBody(r), this.bodies.push(i), this.objects.push(n);
      }
      i[Zt] = n, n[Ut] = i, this.internalUpdateRigidbodyProperties(n, i), this.getRigidbodyRelativeMatrix(e.gameObject, n.gameObject, t), e[_b] = i;
    } else {
      const n = T.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased(), o = Z(e.gameObject);
      n.setTranslation(o.x, o.y, o.z), n.setRotation(be(e.gameObject)), i = this.world.createRigidBody(n), t.identity(), i[Zt] = null;
    }
    return i;
  }
  internal_getRigidbody(e) {
    return e.isCollider === !0 ? e[_b] : e[Ut];
  }
  internalUpdateColliderProperties(e, t) {
    const i = t.shape;
    let n = !1;
    switch (i.type) {
      // Sphere Collider
      case T.RAPIER_PHYSICS.MODULE.ShapeType.Ball: {
        const f = i, p = e, g = e.gameObject, b = Qe(g, this._tempPosition), m = Math.abs(p.radius * b.x);
        n = f.radius !== m, f.radius = m, n && t.setShape(f);
        break;
      }
      case T.RAPIER_PHYSICS.MODULE.ShapeType.Cuboid:
        const o = i, r = e, a = e.gameObject, l = Qe(a, this._tempPosition), c = Math.abs(r.size.x * 0.5 * l.x), h = Math.abs(r.size.y * 0.5 * l.y), d = Math.abs(r.size.z * 0.5 * l.z);
        n = o.halfExtents.x !== c || o.halfExtents.y !== h || o.halfExtents.z !== d, o.halfExtents.x = c, o.halfExtents.y = h, o.halfExtents.z = d, n && t.setShape(o);
        break;
    }
    if (n) {
      const o = e.attachedRigidbody;
      o?.autoMass && this.getBody(o)?.recomputeMassPropertiesFromColliders();
    }
    this.updateColliderCollisionGroups(e), e.isTrigger !== t.isSensor() && t.setSensor(e.isTrigger);
  }
  internalUpdateRigidbodyProperties(e, t) {
    if (t.enableCcd(e.collisionDetectionMode !== sg.Discrete), t.setLinearDamping(e.drag), t.setAngularDamping(e.angularDrag), t.setGravityScale(e.useGravity ? e.gravityScale : 0, !0), e.dominanceGroup <= 127 && e.dominanceGroup >= -127 ? t.setDominanceGroup(Math.floor(e.dominanceGroup)) : t.setDominanceGroup(0), e.autoMass) {
      t.setAdditionalMass(0, !1);
      for (let i = 0; i < t.numColliders(); i++)
        t.collider(i).setDensity(1);
      t.recomputeMassPropertiesFromColliders();
    } else {
      t.setAdditionalMass(e.mass, !1);
      for (let i = 0; i < t.numColliders(); i++)
        t.collider(i).setDensity(1e-7);
      t.recomputeMassPropertiesFromColliders();
    }
    t.setEnabledRotations(!e.lockRotationX, !e.lockRotationY, !e.lockRotationZ, !1), t.setEnabledTranslations(!e.lockPositionX, !e.lockPositionY, !e.lockPositionZ, !1), e.isKinematic ? t.setBodyType(T.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased, !1) : t.setBodyType(T.RAPIER_PHYSICS.MODULE.RigidBodyType.Dynamic, !1);
  }
  // private _lastStepTime: number | undefined = 0;
  lines;
  step(e) {
    if (this.world && this.enabled) {
      if (this._isUpdatingPhysicsWorld = !0, this.eventQueue || (this.eventQueue = new T.RAPIER_PHYSICS.MODULE.EventQueue(!1)), e === void 0 || e <= 0) {
        this._isUpdatingPhysicsWorld = !1;
        return;
      } else if (e !== void 0) {
        const t = j.lerp(this.world.timestep, e, 0.8);
        this.world.timestep = t;
      }
      try {
        this.world.step(this.eventQueue);
      } catch (t) {
        console.warn("Error running physics step", { timestep: this.world.timestep }, t);
      }
      this._isUpdatingPhysicsWorld = !1;
    }
  }
  postStep() {
    this.world && this.enabled && (this._isUpdatingPhysicsWorld = !0, this.syncObjects(), this._isUpdatingPhysicsWorld = !1, this.eventQueue && !this.collisionHandler && (this.collisionHandler = new hI(this.world, this.eventQueue)), this.collisionHandler && (this.collisionHandler.handleCollisionEvents(), this.collisionHandler.update()), this.updateDebugRendering(this.world));
  }
  updateDebugRendering(e) {
    if (Xe || hp || cI || this.debugRenderColliders === !0) {
      if (!this.lines) {
        const i = new wm({
          color: 7855479,
          fog: !1
          // vertexColors: VertexColors
        }), n = new an();
        this.lines = new kb(n, i), this.lines.layers.disableAll(), this.lines.layers.enable(2);
      }
      this.lines.parent !== this.context?.scene && this.context?.scene.add(this.lines);
      const t = e.debugRender();
      this.lines.geometry.setAttribute("position", new ft(t.vertices, 3)), this.lines.geometry.setAttribute("color", new ft(t.colors, 4)), (this.context.time.frame % 30 === 0 || this.lines.geometry.boundingSphere?.radius === 0) && this.lines.geometry.computeBoundingSphere();
    } else
      this.lines && this.context?.scene.remove(this.lines);
  }
  /** sync rendered objects with physics world (except for colliders without rigidbody) */
  syncObjects() {
    if (!hp)
      for (let e = 0; e < this.bodies.length; e++) {
        const t = this.objects[e], i = this.bodies[e], n = t;
        if (n?.isCollider === !0 && !n.attachedRigidbody) {
          const l = i.parent();
          l ? this.syncPhysicsBody(t.gameObject, l, !0, !0) : this.syncPhysicsBody(t.gameObject, i, !0, !0);
          continue;
        }
        const o = i.translation(), r = i.rotation();
        if (Number.isNaN(o.x) || Number.isNaN(r.x)) {
          !n.__COLLIDER_NAN && L() && (console.warn("Collider has NaN values", n.name, n.gameObject, i), n.__COLLIDER_NAN = !0);
          continue;
        }
        const a = t.center;
        if (a && a.isVector3) {
          this._tempQuaternion.set(r.x, r.y, r.z, r.w);
          const l = this._tempPosition.copy(a).applyQuaternion(this._tempQuaternion), c = Qe(t.gameObject);
          l.multiply(c), o.x -= l.x, o.y -= l.y, o.z -= l.z;
        }
        ba(t.gameObject, o.x, o.y, o.z), e0(t.gameObject, r.x, r.y, r.z, r.w);
      }
  }
  syncPhysicsBody(e, t, i, n) {
    if (t instanceof T.RAPIER_PHYSICS.MODULE.RigidBody) {
      const o = Z(e, this._tempPosition), r = be(e, this._tempQuaternion);
      switch (t.bodyType()) {
        case T.RAPIER_PHYSICS.MODULE.RigidBodyType.Fixed:
        case T.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased:
        case T.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicVelocityBased:
          i && t.setNextKinematicTranslation(o), n && t.setNextKinematicRotation(r);
          break;
        default:
          i && t.setTranslation(o, !1), n && t.setRotation(r, !1);
          break;
      }
    } else if (t instanceof T.RAPIER_PHYSICS.MODULE.Collider) {
      e.matrixWorldNeedsUpdate && e.updateWorldMatrix(!0, !1), e.matrixWorld.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
      const o = this._tempPosition, r = this._tempQuaternion, a = t[Zt];
      if (this.tryApplyCenter(a, o), i) {
        const l = t.translation();
        (l.x !== o.x || l.y !== o.y || l.z !== o.z) && t.setTranslation(o);
      }
      if (n) {
        const l = t.rotation();
        (l.x !== r.x || l.y !== r.y || l.z !== r.z || l.w !== r.w) && t.setRotation(r);
      }
    }
  }
  _tempCenterPos = new y();
  _tempCenterVec = new y();
  _tempCenterQuaternion = new U();
  tryApplyCenter(e, t) {
    const i = e.center;
    i && e.gameObject && (i.x !== 0 || i.y !== 0 || i.z !== 0) && (this._tempCenterPos.x = i.x, this._tempCenterPos.y = i.y, this._tempCenterPos.z = i.z, Qe(e.gameObject, this._tempCenterVec), this._tempCenterPos.multiply(this._tempCenterVec), e.attachedRigidbody ? this._tempCenterPos.applyQuaternion(e.gameObject.quaternion) : (be(e.gameObject, this._tempCenterQuaternion), this._tempCenterPos.applyQuaternion(this._tempCenterQuaternion)), t.x += this._tempCenterPos.x, t.y += this._tempCenterPos.y, t.z += this._tempCenterPos.z);
  }
  static _matricesBuffer = [];
  getRigidbodyRelativeMatrix(e, t, i, n) {
    if (n === void 0 && (n = ac._matricesBuffer, n.length = 0), e === t) {
      const o = Qe(e, this._tempPosition);
      i.makeScale(o.x, o.y, o.z);
      for (let r = n.length - 1; r >= 0; r--)
        i.multiply(n[r]);
      return i;
    }
    return n.push(e.matrix), e.parent && this.getRigidbodyRelativeMatrix(e.parent, t, i, n), i;
  }
  static centerConnectionPos = { x: 0, y: 0, z: 0 };
  static centerConnectionRot = { x: 0, y: 0, z: 0, w: 1 };
  addFixedJoint(e, t) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const i = e[Ut], n = t[Ut];
    this.calculateJointRelativeMatrices(e.gameObject, t.gameObject, this._tempMatrix), this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const o = T.RAPIER_PHYSICS.MODULE.JointData.fixed(
      ac.centerConnectionPos,
      ac.centerConnectionRot,
      this._tempPosition,
      this._tempQuaternion
    ), r = this.world.createImpulseJoint(o, i, n, !0);
    Xe && console.log("ADD FIXED JOINT", r);
  }
  /** The joint prevents any relative movement between two rigid-bodies, except for relative rotations along one axis. This is typically used to simulate wheels, fans, etc. They are characterized by one local anchor as well as one local axis on each rigid-body. */
  addHingeJoint(e, t, i, n) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const o = e[Ut], r = t[Ut];
    this.calculateJointRelativeMatrices(e.gameObject, t.gameObject, this._tempMatrix), this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const a = T.RAPIER_PHYSICS.MODULE.JointData.revolute(i, this._tempPosition, n), l = this.world.createImpulseJoint(a, o, r, !0);
    Xe && console.log("ADD HINGE JOINT", l);
  }
  calculateJointRelativeMatrices(e, t, i) {
    e.updateWorldMatrix(!0, !1), t.updateWorldMatrix(!0, !1);
    const n = e.matrixWorld, o = t.matrixWorld;
    n.elements[0] = 1, n.elements[5] = 1, n.elements[10] = 1, o.elements[0] = 1, o.elements[5] = 1, o.elements[10] = 1, i.copy(o).premultiply(n.invert()).invert();
  }
}
class hI {
  world;
  eventQueue;
  constructor(e, t) {
    this.world = e, this.eventQueue = t;
  }
  activeCollisions = [];
  activeCollisionsStay = [];
  activeTriggers = [];
  handleCollisionEvents() {
    this.eventQueue && this.world && this.eventQueue.drainCollisionEvents((e, t, i) => {
      const n = this.world.getCollider(e), o = this.world.getCollider(t);
      if (!n || !o) return;
      const r = n[Zt], a = o[Zt];
      dp && console.log("EVT", r.name, a.name, i, n, o), r && a && (i ? (this.onCollisionStarted(r, n, a, o), this.onCollisionStarted(a, o, r, n)) : (this.onCollisionEnded(r, a), this.onCollisionEnded(a, r)));
    });
  }
  update() {
    this.onHandleCollisionStay();
  }
  onCollisionStarted(e, t, i, n) {
    let o = null;
    if (e.isTrigger || i.isTrigger)
      Oa(e.gameObject, (r) => {
        r.onTriggerEnter && !r.destroyed && r.onTriggerEnter(i), this.activeTriggers.push({ collider: e, component: r, otherCollider: i });
      });
    else {
      const r = e.gameObject;
      this.world.contactPair(t, n, (a, l) => {
        Oa(r, (c) => {
          if (c.destroyed) return;
          const h = c.onCollisionEnter || c.onCollisionStay || c.onCollisionExit;
          if (h || dp) {
            if (!o) {
              const d = [], f = a.normal();
              i instanceof xr && i.convex && (f.x = -f.x, f.y = -f.y, f.z = -f.z);
              for (let p = 0; p < a.numSolverContacts(); p++) {
                const g = a.solverContactPoint(p), b = a.contactImpulse(p);
                if (g) {
                  const m = a.contactDist(p), v = a.solverContactFriction(p), _ = a.solverContactTangentVelocity(p), x = new Uk(g, m, f, b, v, _);
                  d.push(x), dp && z.DrawDirection(g, f, 16711680, 3, !0);
                }
              }
              o = new Nk(r, i, d);
            }
            if (h) {
              const d = { collider: e, component: c, collision: o };
              this.activeCollisions.push(d), c.onCollisionStay && this.activeCollisionsStay.push(d), c.onCollisionEnter?.call(c, o);
            }
          }
        });
      });
    }
  }
  onHandleCollisionStay() {
    for (const e of this.activeCollisionsStay) {
      const t = e.component;
      if (!t.destroyed && t.activeAndEnabled && t.onCollisionStay) {
        if (e.collision.collider.destroyed) continue;
        const i = e.collision;
        t.onCollisionStay(i);
      }
    }
    for (const e of this.activeTriggers) {
      const t = e.component;
      if (!t.destroyed && t.activeAndEnabled && t.onTriggerStay) {
        const i = e.otherCollider;
        if (i.destroyed) continue;
        t.onTriggerStay(i);
      }
    }
  }
  onCollisionEnded(e, t) {
    if (!(e.destroyed || t.destroyed)) {
      for (let i = 0; i < this.activeCollisions.length; i++) {
        const n = this.activeCollisions[i], o = n.collider;
        if (o.destroyed || n.collision.collider.destroyed) {
          this.activeCollisions.splice(i, 1), i--;
          continue;
        }
        if (o === e && n.collision.collider === t) {
          const r = n.component;
          if (this.activeCollisions.splice(i, 1), i--, r.activeAndEnabled && r.onCollisionExit) {
            const a = n.collision;
            r.onCollisionExit(a);
          }
        }
      }
      for (let i = 0; i < this.activeCollisionsStay.length; i++) {
        const n = this.activeCollisionsStay[i], o = n.collider;
        if (o.destroyed || n.collision.collider.destroyed) {
          this.activeCollisionsStay.splice(i, 1), i--;
          continue;
        }
        if (o === e && n.collision.collider === t) {
          const r = n.component;
          if (this.activeCollisionsStay.splice(i, 1), i--, r.activeAndEnabled && r.onCollisionExit) {
            const a = n.collision;
            r.onCollisionExit(a);
          }
        }
      }
      for (let i = 0; i < this.activeTriggers.length; i++) {
        const n = this.activeTriggers[i], o = n.collider;
        if (o.destroyed || n.otherCollider.destroyed) {
          this.activeTriggers.splice(i, 1), i--;
          continue;
        }
        if (o === e && n.otherCollider === t) {
          const r = n.component;
          if (this.activeTriggers.splice(i, 1), i--, r.activeAndEnabled && r.onTriggerExit) {
            const a = n.otherCollider;
            r.onTriggerExit(a);
          }
        }
      }
    }
  }
}
class WL {
  /**
   * Use this method to quickly setup a scene to compare multiple models.  
   * @example
   * ```ts
   * const files = [
   *    "https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb",
   *   "https://threejs.org/examples/models/gltf/Lantern/glTF-Binary/Lantern.glb",
   * ];
   * const { scene, camera } = await TestUtils.createComparisonScene({ files });
   * // this could now be assigned to the Needle Engine Context
   * context.scene = scene;
   * context.mainCamera = camera;
   * ```
   */
  static async createComparisonScene(e) {
    const { files: t } = e, n = await Promise.all(t.map((m) => new ie(m).loadAssetAsync())), o = new wi();
    let r = 0;
    for (const m of n)
      if (m instanceof M) {
        m.position.y = r, o.add(m);
        const v = ii([m]);
        r += v.getSize(new y()).y, r += 0.1;
      }
    const a = new de(20);
    o.add(a);
    const l = e.environment || "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/studio_small_09_1k.exr";
    {
      let m = null;
      if (l.endsWith(".hdr")) {
        const v = (await import("./three-examples-BvMpKSun.js").then((_) => _.RGBELoader$1)).RGBELoader;
        m = new v();
      } else if (l.endsWith(".exr")) {
        const v = (await import("./three-examples-BvMpKSun.js").then((_) => _.EXRLoader$1)).EXRLoader;
        m = new v();
      }
      if (m) {
        const v = await m.loadAsync(l).catch((_) => (console.error(_), null));
        v && (v.mapping = _s, v.needsUpdate = !0, o.background = v, o.environment = v, o.backgroundBlurriness = 0.75);
      } else console.warn("Unsupported environment map format", l);
    }
    const c = ii(o.children), h = c.getCenter(new y()), d = c.getSize(new y()), p = Math.max(d.x, d.y, d.z) / (2 * Math.tan(Math.PI * a.fov / 360));
    a.position.set(h.x, h.y, p), a.lookAt(h);
    const g = new Bb(a, e.domElement || document.body);
    g.target = h, g.update();
    const b = (e.domElement || document.body).getBoundingClientRect();
    return a.aspect = b.width / b.height, a.updateProjectionMatrix(), {
      scene: o,
      camera: a
    };
  }
}
let _m = 0;
function bb(s) {
  s ? _m++ : _m--;
}
function VL() {
  return _m > 0;
}
const dI = {
  binary: !0,
  animations: !0
};
async function HL(s) {
  if (!s.context)
    throw new Error("No context provided to exportAsGLTF");
  s.scene || (s.scene = s.context.scene);
  const e = {
    ...dI,
    ...s
  }, { context: t } = e, i = new Fb();
  i.register((a) => new Tv(a)), i.register((a) => new SM(a)), i.register((a) => new Cv(a)), Rv(i, e.context);
  const n = {
    binary: e.binary,
    animations: fI(t, e.scene, [])
  }, o = new uI();
  console.debug("Exporting GLTF", n), o.onBeforeExport(e), bb(!0);
  const r = await i.parseAsync(e.scene, n).catch((a) => (console.error(a), null));
  if (bb(!1), o.onAfterExport(e), !r)
    throw new Error("Failed to export GLTF");
  if (e.downloadAs != null) {
    let a = null;
    if (r instanceof ArrayBuffer ? a = new Blob([r], { type: "application/octet-stream" }) : console.error("Can not download GLTF as a blob", r), a) {
      const l = URL.createObjectURL(a), c = document.createElement("a");
      c.href = l;
      let h = e.downloadAs;
      !h.endsWith(".glb") && !h.endsWith(".gltf") && (h += e.binary ? ".glb" : ".gltf"), c.download = h, c.click();
    }
  }
  return r;
}
const vb = Symbol("needle:weight");
class uI {
  _undo = [];
  onBeforeExport(e) {
    e.context.animations.mixers.forEach((t) => {
      const i = mc.tryGetActionsFromMixer(t);
      if (i)
        for (let n = 0; n < i.length; n++) {
          const o = i[n];
          o[vb] = o.weight, o.weight = 0, this._undo.push(() => {
            o.weight = o[vb];
          });
        }
      t.update(0);
    }), e.context.scene.traverse((t) => {
      if (!qp(t)) {
        const i = t.parent;
        i && (t.removeFromParent(), this._undo.push(() => i.add(t)));
      }
    });
  }
  onAfterExport(e) {
    this._undo.forEach((t) => t()), this._undo.length = 0;
  }
}
function fI(s, e, t) {
  s.animations.mixers.forEach((n) => {
    const o = mc.tryGetActionsFromMixer(n);
    if (o)
      for (let r = 0; r < o.length; r++) {
        const l = o[r].getClip();
        t.push(l);
      }
  }), Array.isArray(e) || (e = [e]);
  for (const n of e)
    mc.tryGetAnimationClipsFromObjectHierarchy(n, t);
  const i = new Set(t);
  return Array.from(i);
}
const wb = "needle-button", up = L();
class pI extends HTMLElement {
  static observedAttributes = ["ar", "vr", "quicklook"];
  constructor() {
    super(), this.removeEventListener("click", this.#r), this.addEventListener("click", this.#r);
  }
  attributeChangedCallback(e, t, i) {
    this.#a();
  }
  #t;
  #n;
  /** These are the default styles that can be overridden by the user from the outside by styling <needle-button> */
  #s;
  /** This is the button that was generated using one of the factories */
  #e;
  /** If AR or VR is requested we create and use the webxr button factory to create a button with default behaviour */
  #i;
  #o;
  #a() {
    if (this.#e?.remove(), this.getAttribute("ar") != null)
      this.#i ??= new or(), this.#e = this.#i.createARButton();
    else if (this.getAttribute("vr") != null)
      this.#i ??= new or(), this.#e = this.#i.createVRButton();
    else if (this.getAttribute("quicklook") != null)
      this.#i ??= new or(), this.#e = this.#i.createQuicklookButton();
    else {
      up ? console.warn("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.") : console.debug("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.");
      return;
    }
    this.#t ??= this.attachShadow({ mode: "open" }), this.#n ??= document.createElement("slot"), this.#s ??= document.createElement("style"), this.#s.innerHTML = `
            button {
                all: initial;
                cursor: inherit;
                color: inherit;
                font-family: inherit;
                gap: inherit;
                white-space: nowrap;
            }
        `, this.getAttribute("unstyled") != null || (this.#s.innerHTML += `
            :host {
                display: inline-block;
                background: rgba(255, 255, 255, .8);
                backdrop-filter: blur(10px);
                width: fit-content;
                transition: background .2s;

                cursor: pointer;
                padding: 0.4rem .5rem;
                border-radius: 0.8rem;
                color: black;
                background: rgba(245, 245, 245, .8);
                outline: rgba(0,0,0,.05) 1px solid;
            }
            :host(:hover) {
                background: rgba(255, 255, 255, 1);
                transition: background .2s;
            }
            slot {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: .5rem;
            }
`), this.#n.innerHTML = this.#e.innerHTML, this.#n.style.cssText = "display: flex; align-items: center; justify-content: center;", this.#e.innerHTML = this.#n.outerHTML, this.#t.innerHTML = this.#e.outerHTML, this.#t.prepend(this.#s), bd(Up, { element: this.#t }), this.#o?.disconnect(), this.#o ??= new MutationObserver(() => this.#l()), this.#o.observe(this.#e, { attributes: !0 }), up && console.log("Needle Button updated");
  }
  #l() {
    this.#e && (this.#e.style.display === "none" ? this.style.display = "none" : this.style.display === "none" && (this.style.display = ""));
  }
  #r = (e) => {
    up && console.log("Needle Button clicked"), !e.defaultPrevented && this.#e && this.#e.click();
  };
}
typeof window < "u" && !window.customElements.get(wb) && window.customElements.define(wb, pI);
const Ml = w("debugavatar");
class rx {
  /** The root object of the avatar model */
  root;
  /** The head object of the avatar model */
  head;
  /** The left hand object of the avatar model, if available */
  leftHand;
  /** The right hand object of the avatar model, if available */
  rigthHand;
  /**
   * Checks if the avatar model has a valid configuration.
   * An avatar is considered valid if it has a head.
   * @returns Whether the avatar has a valid setup
   */
  get isValid() {
    return this.head !== null && this.head !== void 0;
  }
  /**
   * Creates a new avatar model.
   * @param root The root object of the avatar
   * @param head The head object of the avatar
   * @param leftHand The left hand object of the avatar
   * @param rigthHand The right hand object of the avatar
   */
  constructor(e, t, i, n) {
    this.root = e, this.head = t, this.leftHand = i, this.rigthHand = n, this.root?.traverse((o) => o.layers.set(2));
  }
}
class mI {
  avatarRegistryUrl = null;
  // private loader: GLTFLoader | null;
  // private avatarModelCache: Map<string, AvatarModel | null> = new Map<string, AvatarModel | null>();
  /**
   * Retrieves or creates a new avatar instance from an ID or existing Object3D.
   * @param context The application context
   * @param avatarId Either a string ID to load an avatar or an existing Object3D to use as avatar
   * @returns Promise resolving to an AvatarModel if successful, or null if failed
   */
  async getOrCreateNewAvatarInstance(e, t) {
    if (!t)
      return console.error("Can not create avatar: failed to provide id or root object"), null;
    let i = null;
    if (typeof t == "string") {
      if (i = await this.loadAvatar(e, t), !i) {
        const o = new $n();
        i = S.instantiate(cc(t, e.scene), o);
      }
    } else i = t;
    if (!i)
      return null;
    const n = this.findAvatar(i);
    return n.isValid ? (Ml && console.log("[Custom Avatar] valid config", t, Ml ? n : ""), n) : (console.warn("[Custom Avatar] config isn't valid", t, Ml ? n : ""), null);
  }
  /**
   * Loads an avatar model from a file or registry using the provided ID.
   * @param context The engine context
   * @param avatarId The ID of the avatar to load
   * @returns Promise resolving to the loaded avatar's Object3D, or null if failed
   */
  async loadAvatar(e, t) {
    if (console.assert(t != null && typeof t == "string", "Avatar id must not be null"), t.length <= 0 || !t) return null;
    if (Ml && console.log("[Custom Avatar] " + t + ", loading..."), t.endsWith(".glb") || (t += ".glb"), this.avatarRegistryUrl === null) {
      const n = await fetch("./" + t);
      let o = null;
      if (n.ok) {
        const a = await n.blob();
        a && (o = await a.arrayBuffer());
      }
      return o ? (await Bn().parseSync(e, o, null, 0))?.scene ?? null : null;
    }
    const i = new Ps();
    return ig(i, e), new Promise((n, o) => {
      const r = this.avatarRegistryUrl + "/" + t;
      i.load(
        r,
        async (a) => {
          await Bn().createBuiltinComponents(e, r, a, null, void 0), n(a.scene);
        },
        (a) => {
          Ml && console.log("[Custom Avatar] " + a.loaded / a.total * 100 + "% loaded of " + a.total / 1024 + "kB");
        },
        (a) => {
          console.error("[Custom Avatar] Error when loading: " + a), n(null);
        }
      );
    });
  }
  /**
   * Caches an avatar model for reuse.
   * @param _id The ID to associate with the model
   * @param _model The avatar model to cache
   */
  cacheModel(e, t) {
  }
  /**
   * Analyzes an Object3D to find avatar parts (head, hands) based on naming conventions.
   * @param obj The Object3D to search for avatar parts
   * @returns A structured AvatarModel with references to found parts
   */
  findAvatar(e) {
    const t = e;
    let i = t;
    i.children.length == 1 && (i = e.children[0]);
    let n = this.findAvatarPart(i, ["head"]);
    const o = this.findAvatarPart(i, ["left", "hand"]), r = this.findAvatarPart(i, ["right", "hand"]);
    if (!n) {
      n = t;
      const l = new y();
      new bi().setFromObject(n).getSize(l);
      const c = Math.max(l.x, l.y, l.z);
      console.warn("[Custom Avatar] Normalizing head scale, it's too big: " + c + " meters! Should be < 0.3m"), c > 0.3 && n.scale.multiplyScalar(1 / c * 0.3);
    }
    return new rx(t, n, o, r);
  }
  /**
   * Recursively searches for an avatar part by name within an Object3D hierarchy.
   * @param obj The Object3D to search within
   * @param searchString Array of strings that should all be present in the object name
   * @returns The found Object3D part or null if not found
   */
  findAvatarPart(e, t) {
    const i = e.name.toLowerCase();
    let n = !0;
    for (const o of t) {
      if (!n) break;
      i.indexOf(o) === -1 && (n = !1);
    }
    if (n) return e;
    if (e.children)
      for (const o of e.children) {
        const r = this.findAvatarPart(o, t);
        if (r) return r;
      }
    return null;
  }
  /**
   * Handles HTTP response errors from avatar loading operations.
   * @param response The fetch API response to check
   * @returns The response if it was ok
   * @throws Error with status text if response was not ok
   */
  handleCustomAvatarErrors(e) {
    if (!e.ok)
      throw Error(e.statusText);
    return e;
  }
}
class gI {
  get extensionName() {
    return "DocumentExtension";
  }
  onAfterBuildDocument(e) {
  }
}
class yI {
}
const GL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionBuilder: me,
  ActionCollection: vR,
  ActionModel: di,
  AlignmentConstraint: au,
  Animation: ni,
  AnimationCurve: Iu,
  AnimationExtension: xg,
  AnimationTrackHandler: Kg,
  Animator: kt,
  AnimatorController: cn,
  Antialiasing: Lu,
  Attractor: $c,
  AudioExtension: Na,
  AudioListener: to,
  AudioSource: Xi,
  AudioTrackHandler: no,
  Avatar: dr,
  AvatarBlink_Simple: Ba,
  AvatarEyeLook_Rotation: fv,
  AvatarLoader: mI,
  AvatarMarker: je,
  AvatarModel: rx,
  Avatar_Brain_LookAt: Cd,
  Avatar_MouthShapes: du,
  Avatar_MustacheShake: cv,
  Avatar_POI: da,
  AxesHelper: Mc,
  BaseUIComponent: un,
  BasicIKConstraint: pv,
  BehaviorExtension: Jv,
  BehaviorModel: It,
  BloomEffect: Wg,
  BoxCollider: fg,
  BoxGizmo: qa,
  BoxHelperComponent: Pt,
  Button: To,
  CallInfo: Ks,
  Camera: yi,
  CameraTargetReachedEvent: Sd,
  Canvas: bc,
  CanvasGroup: ur,
  CapsuleCollider: po,
  ChangeMaterialOnClick: Gv,
  ChangeTransformOnClick: $a,
  CharacterController: Fa,
  CharacterControllerInput: _o,
  ChromaticAberration: ju,
  ClickThrough: sy,
  Collider: Ci,
  ColorAdjustments: Or,
  ColorBySpeedModule: Nc,
  ColorOverLifetimeModule: Fg,
  ContactShadows: pu,
  ControlTrackHandler: Zg,
  CursorFollow: Ku,
  CustomBranding: Ga,
  Deletable: _v,
  DeleteBox: nr,
  DepthOfField: qn,
  DeviceFlag: pg,
  DocumentExtension: gI,
  DragControls: Zr,
  DropListener: vo,
  Duplicatable: xv,
  EffectWrapper: Ed,
  EmissionModule: Oo,
  EmphasizeOnClick: Ac,
  EnvironmentScene: iy,
  EventList: ce,
  EventListEvent: og,
  EventSystem: ti,
  EventTrigger: _g,
  FieldWithDefault: VM,
  FixedJoint: uw,
  Fog: jc,
  GltfExport: Dv,
  GltfExportBox: Lv,
  Gradient: Qa,
  Graphic: Ou,
  GraphicRaycaster: rg,
  GridHelper: Bc,
  GridLayoutGroup: lw,
  GroundProjectedEnv: Rs,
  GroupActionModel: ea,
  HideOnStart: on,
  HingeJoint: Mu,
  HorizontalLayoutGroup: aw,
  Image: Qc,
  InheritVelocityModule: _w,
  InputField: $w,
  InstanceHandle: ua,
  InstancingHandler: Aa,
  Interactable: yv,
  Keyframe: _i,
  LODGroup: Ru,
  LODModel: zc,
  Light: ki,
  LimitVelocityOverLifetimeModule: _t,
  LogStats: gv,
  LookAt: Hw,
  LookAtConstraint: ja,
  MainModule: Qt,
  MaskableGraphic: ku,
  MeshCollider: xr,
  MeshRenderer: yu,
  MinMaxCurve: Y,
  MinMaxGradient: Ya,
  NeedleMenu: As,
  NestedGltf: Tu,
  Networking: pw,
  NoiseModule: ve,
  ObjectRaycaster: qi,
  OffsetConstraint: Xa,
  OpenURL: Zc,
  OrbitControls: ye,
  Outline: Dc,
  Padding: Ha,
  ParticleBurst: om,
  ParticleSubEmitter: bw,
  ParticleSystem: Td,
  ParticleSystemRenderer: mn,
  PhysicsExtension: ew,
  PixelationEffect: Fu,
  PlayAnimationOnClick: Md,
  PlayAudioOnClick: cr,
  PlayableDirector: Ia,
  PlayerColor: wc,
  PointerEventData: cu,
  PostProcessingHandler: Ow,
  PreliminaryAction: Ic,
  PreliminaryTrigger: vu,
  RawImage: ty,
  Rect: qR,
  RectTransform: Un,
  ReflectionProbe: kd,
  RegisteredAnimationInfo: Yo,
  RemoteSkybox: Gg,
  Renderer: Qi,
  RendererLightmap: Yp,
  Rigidbody: rt,
  RotationBySpeedModule: pn,
  RotationOverLifetimeModule: Gn,
  SceneSwitcher: Ze,
  ScreenCapture: Rr,
  ScreenSpaceAmbientOcclusion: ko,
  ScreenSpaceAmbientOcclusionN8: Xn,
  ScrollFollow: qw,
  SetActiveOnClick: qv,
  ShadowCatcher: Uu,
  ShapeModule: gw,
  SharpeningEffect: zu,
  SignalAsset: Yg,
  SignalReceiver: Vu,
  SignalReceiverEvent: Wu,
  SignalTrackHandler: Ld,
  Size: GR,
  SizeBySpeedModule: Mi,
  SizeOverLifetimeModule: Ka,
  SkinnedMeshRenderer: Av,
  SmoothFollow: qg,
  SpatialGrabRaycaster: Ea,
  SpatialHtml: Qu,
  SpatialTrigger: Xg,
  SpatialTriggerReceiver: xs,
  SpectatorCamera: Qg,
  SphereCollider: Rc,
  SplineContainer: tl,
  SplineData: ks,
  SplineWalker: Qn,
  Sprite: wo,
  SpriteData: tc,
  SpriteRenderer: Pi,
  SpriteSheet: _c,
  SubEmitterSystem: lm,
  SyncedCamera: jw,
  SyncedRoom: Yn,
  SyncedTransform: zn,
  TapGestureTrigger: Xv,
  TeleportTarget: kg,
  TestRunner: Bw,
  TestSimulateUserData: Fw,
  Text: Xt,
  TextBuilder: ow,
  TextExtension: Tg,
  TextureSheetAnimationModule: Yt,
  TiltShiftEffect: Ds,
  ToneMappingEffect: fr,
  TrailModule: Ne,
  TransformData: Ue,
  TransformGizmo: il,
  TriggerBuilder: Gt,
  TriggerModel: sr,
  UIRaycastUtils: rv,
  UIRootComponent: Pu,
  USDZExporter: ws,
  USDZText: Bl,
  USDZUIExtension: dw,
  UsageMarker: mu,
  VariantAction: Hv,
  VelocityOverLifetimeModule: Ve,
  VerticalLayoutGroup: rw,
  VideoPlayer: mt,
  Vignette: Ja,
  VisibilityAction: wu,
  Voip: wr,
  Volume: Vc,
  VolumeParameter: F,
  VolumeProfile: Ng,
  WebARCameraBackground: Zu,
  WebARSessionRoot: Vi,
  WebXR: Mg,
  WebXRImageTracking: Ju,
  WebXRImageTrackingModel: Io,
  WebXRPlaneTracking: Lo,
  WebXRTrackedImage: xc,
  XRControllerFollow: Eo,
  XRControllerModel: mo,
  XRControllerMovement: Yi,
  XRFlag: rn,
  XRRig: oy,
  XRState: ei,
  __Ignore: yI
}, Symbol.toStringTag, { value: "Module" })), Fd = w("debugmissingcamera");
ue.registerCallback(he.MissingCamera, (s) => {
  Fd && console.warn("Creating missing camera");
  const e = s.context.scene, t = new de();
  t.name = "Default Fallback Camera", e.add(t);
  const i = new yi();
  if (i.sourceId = s.files?.[0]?.src ?? "unknown", i.fieldOfView = 35, s.context.domElement.getAttribute("transparent") != null)
    i.clearFlags = ha.Uninitialized;
  else if (s.context.domElement.getAttribute("background-image")?.length || s.context.lightmaps.tryGetSkybox(i.sourceId))
    i.clearFlags = ha.Skybox;
  else {
    if (i.clearFlags = ha.SolidColor, !s.context.domElement.getAttribute("background-color")) {
      let a = "#efefef";
      typeof window !== void 0 && window.matchMedia("(prefers-color-scheme: dark)").matches && (a = "#1f1f1f"), e.background = new se(a);
    }
    if (!e.environment) {
      const a = new xS(s.context.renderer), l = new iy("neutral");
      e.environment = a.fromScene(l, 0.025).texture;
    }
  }
  const o = aa(t, i, !0);
  return t.position.x = 0, t.position.y = 1, t.position.z = 2, s.context.domElement?.cameraControls != !1 && ax(s.context, o), o;
});
ue.registerCallback(he.ContextCreated, (s) => {
  if (!s.context.mainCamera) {
    Fd && console.log("Will not auto-fit because a default camera exists");
    return;
  }
  if (s.context.domElement?.cameraControls == !0) {
    if (zC(s.context.mainCamera)?.isCameraController == !0) {
      Fd && console.log("Will not auto-fit because a camera controller exists");
      return;
    }
    ax(s.context);
  }
});
function ax(s, e) {
  e = e ?? s.mainCameraComponent;
  const t = e?.gameObject;
  if (Fd && console.log("Creating default camera controls", e?.name), t) {
    const i = tu(t, ye);
    i.sourceId = e?.sourceId ?? "unknown";
    const n = s.domElement.getAttribute("auto-rotate");
    if (i.autoRotate = n != null && n != "0" && n?.toLowerCase() != "false", i.autoRotateSpeed = 0.5, i.autoFit = !0, i.autoRotate && n) {
      const o = parseFloat(n);
      isNaN(o) || (i.autoRotateSpeed = o);
    }
  } else
    console.warn("Missing camera object, can not add orbit controls");
}
ue.registerCallback(he.ContextCreated, (s) => {
  const e = s.context.domElement.getAttribute("autoplay");
  if (e !== void 0 && (e === "" || e === "true" || e === "1") && s.files)
    for (const t of s.files)
      S.foreachComponent(t.file.scene, (n) => {
        if (n.enabled !== !1) {
          if (n instanceof ni && n.playAutomatically || n instanceof kt || n instanceof Ia && n.playOnAwake === !0)
            return !0;
          if (n instanceof ni)
            return n.playAutomatically = !0, !0;
          if (n instanceof Ia)
            return n.playOnAwake = !0, !0;
        }
      }, !0) !== !0 && mc.autoplayAnimations(t.file);
});
var xb;
((s) => {
  function e(t, i = !1, n = 0.75) {
    const o = new tl(), r = 1 - j.clamp(n, 0, 1);
    return t.forEach((a, l) => {
      const c = new y();
      l < t.length - 1 ? c.subVectors(t[l + 1], a).normalize().multiplyScalar(r) : i && t.length > 1 && c.subVectors(t[0], a).normalize().multiplyScalar(r);
      const h = new ks();
      h.position.copy(a), h.tangentIn.copy(c), h.tangentOut.copy(c), o.addKnot(h);
    }), o.closed = i, o;
  }
  s.createFromPoints = e;
})(xb || (xb = {}));
class _I extends tC {
  constructor() {
    super(new Worker(URL.createObjectURL(new Blob(["import '" + `${new URL('./generateMeshBVH.worker-2qGLkQjg.js', import.meta.url).toString()}` + "';"], { type: 'text/javascript' })), { type: "module" })), this.name = "GenerateMeshBVHWorker";
  }
  runTask(e, t, i = {}) {
    return new Promise((n, o) => {
      if (t.getAttribute("position").isInterleavedBufferAttribute || t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.");
      e.onerror = (c) => {
        o(new Error(`[GenerateMeshBVHWorker] ${c.message || "Unknown error. Please check the server console. If you're using vite try adding 'three-mesh-bvh' to 'optimizeDeps.exclude' in your vite.config.js"}`));
      }, e.onmessage = (c) => {
        const { data: h } = c;
        if (h.error)
          o(new Error(h.error)), e.onmessage = null;
        else if (h.serialized) {
          const { serialized: d, position: f } = h, p = iC.deserialize(d, t, { setIndex: !1 }), g = Object.assign({
            setBoundingBox: !0
          }, i);
          if (t.attributes.position.array = f, d.index)
            if (t.index)
              t.index.array = d.index;
            else {
              const b = new ft(d.index, 1, !1);
              t.setIndex(b);
            }
          g.setBoundingBox && (t.boundingBox = p.getBoundingBox(new bi())), i.onProgress && i.onProgress(h.progress), n(p), e.onmessage = null;
        } else i.onProgress && i.onProgress(h.progress);
      };
      const r = t.index ? t.index.array : null, a = t.attributes.position.array, l = [a];
      r && l.push(r), e.postMessage({
        index: r,
        position: a,
        options: {
          ...i,
          onProgress: null,
          includedProgressCallback: !!i.onProgress,
          groups: [...t.groups]
        }
      }, l.map((c) => c.buffer).filter((c) => typeof SharedArrayBuffer > "u" || !(c instanceof SharedArrayBuffer)));
    });
  }
}
const bI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GenerateMeshBVHWorker: _I
}, Symbol.toStringTag, { value: "Module" }));
export {
  EL as $physicsKey,
  me as ActionBuilder,
  vR as ActionCollection,
  di as ActionModel,
  oO as Addressables,
  au as AlignmentConstraint,
  Ql as AmbientMode,
  ni as Animation,
  Iu as AnimationCurve,
  xg as AnimationExtension,
  Kg as AnimationTrackHandler,
  mc as AnimationUtils,
  kt as Animator,
  Wo as AnimatorConditionMode,
  cn as AnimatorController,
  nv as AnimatorControllerParameterType,
  ph as AnimatorStateInfo,
  Lu as Antialiasing,
  Fn as Application,
  sP as AssetDatabase,
  ie as AssetReference,
  $c as Attractor,
  Na as AudioExtension,
  to as AudioListener,
  Xi as AudioSource,
  no as AudioTrackHandler,
  dr as Avatar,
  Ba as AvatarBlink_Simple,
  fv as AvatarEyeLook_Rotation,
  mI as AvatarLoader,
  je as AvatarMarker,
  rx as AvatarModel,
  Cd as Avatar_Brain_LookAt,
  du as Avatar_MouthShapes,
  cv as Avatar_MustacheShake,
  da as Avatar_POI,
  Al as Axes,
  Mc as AxesHelper,
  c0 as BUILD_TIME,
  un as BaseUIComponent,
  pv as BasicIKConstraint,
  Jv as BehaviorExtension,
  It as BehaviorModel,
  Ma as BlobStorage,
  Wg as BloomEffect,
  fg as BoxCollider,
  qa as BoxGizmo,
  Pt as BoxHelperComponent,
  To as Button,
  kn as ButtonsFactory,
  Hk as CallDirection,
  Ks as CallInfo,
  yi as Camera,
  Sd as CameraTargetReachedEvent,
  bc as Canvas,
  ur as CanvasGroup,
  po as CapsuleCollider,
  Gv as ChangeMaterialOnClick,
  $a as ChangeTransformOnClick,
  Fa as CharacterController,
  _o as CharacterControllerInput,
  ju as ChromaticAberration,
  Hi as CircularBuffer,
  ha as ClearFlags,
  sy as ClickThrough,
  as as ClipExtrapolation,
  Ci as Collider,
  Nk as Collision,
  sg as CollisionDetectionMode,
  Or as ColorAdjustments,
  Nc as ColorBySpeedModule,
  Fg as ColorOverLifetimeModule,
  SL as Component,
  R as Component$1,
  Vm as ComponentLifecycleEvents,
  GL as Components,
  z1 as ConnectionEvents,
  Uk as ContactPoint,
  pu as ContactShadows,
  N as Context,
  gL as ContextArgs,
  he as ContextEvent,
  ue as ContextRegistry,
  Zg as ControlTrackHandler,
  Ku as CursorFollow,
  Ga as CustomBranding,
  Me as CustomShader,
  Fp as DefaultReflectionMode,
  _v as Deletable,
  nr as DeleteBox,
  qn as DepthOfField,
  pg as DeviceFlag,
  q as DeviceUtilities,
  gI as DocumentExtension,
  Zr as DragControls,
  bv as DragMode,
  vo as DropListener,
  xv as Duplicatable,
  Ed as EffectWrapper,
  Oo as EmissionModule,
  Ac as EmphasizeOnClick,
  Bd as EngineLoadingView,
  iy as EnvironmentScene,
  ce as EventList,
  og as EventListEvent,
  ti as EventSystem,
  _g as EventTrigger,
  VM as FieldWithDefault,
  ca as FileReference,
  cO as FileReferenceSerializer,
  AL as FileSpawnModel,
  fM as File_Event,
  uw as FixedJoint,
  jc as Fog,
  xe as FrameEvent,
  jm as GENERATOR,
  S as GameObject,
  z as Gizmos,
  Dv as GltfExport,
  Lv as GltfExportBox,
  Qa as Gradient,
  Ou as Graphic,
  rg as GraphicRaycaster,
  ar as Graphics,
  Bc as GridHelper,
  lw as GridLayoutGroup,
  Rs as GroundProjectedEnv,
  ea as GroupActionModel,
  lg as HideFlags,
  on as HideOnStart,
  Mu as HingeJoint,
  aw as HorizontalLayoutGroup,
  dL as HostData,
  Qc as Image,
  la as ImageReference,
  lO as ImageReferenceSerializer,
  _w as InheritVelocityModule,
  O1 as Input,
  fi as InputEventQueue,
  De as InputEvents,
  $w as InputField,
  ua as InstanceHandle,
  Aa as InstancingHandler,
  ln as InstancingUtil,
  mP as InstantiateEvent,
  At as InstantiateIdProvider,
  $n as InstantiateOptions,
  yv as Interactable,
  Dd as InternalScreenshotUtils,
  sL as JoinedRoomResponse,
  tL as KeyEventArgs,
  _i as Keyframe,
  Ru as LODGroup,
  zc as LODModel,
  oL as LeftRoomResponse,
  ki as Light,
  PO as LightData,
  _t as LimitVelocityOverLifetimeModule,
  $L as LoadingElementOptions,
  gv as LogStats,
  Wi as LogType,
  Hw as LookAt,
  ja as LookAtConstraint,
  T as MODULES,
  Qt as MainModule,
  Uw as MarkerType,
  ku as MaskableGraphic,
  j as Mathf,
  xr as MeshCollider,
  yu as MeshRenderer,
  Y as MinMaxCurve,
  Ya as MinMaxGradient,
  fd as NEEDLE_ENGINE_FEATURE_FLAGS,
  ih as NEKeyboardEvent,
  Hs as NEPointerEvent,
  pI as NeedleButtonElement,
  A_ as NeedleEngineModelLoader,
  ox as NeedleEngineWebComponent,
  As as NeedleMenu,
  uf as NeedlePatchesKey,
  m0 as NeedleXRController,
  K as NeedleXRSession,
  $1 as NeedleXRSync,
  Z1 as NeedleXRUtils,
  Tu as NestedGltf,
  N1 as NetworkConnection,
  ms as NetworkedStreamEvents,
  hu as NetworkedStreams,
  pw as Networking,
  _P as NewInstanceModel,
  ve as NoiseModule,
  qi as ObjectRaycaster,
  La as ObjectUtils,
  Xa as OffsetConstraint,
  lf as OneEuroFilter,
  Zb as OneEuroFilterXYZ,
  Zc as OpenURL,
  ye as OrbitControls,
  Dc as Outline,
  U1 as OwnershipEvent,
  b0 as OwnershipModel,
  Rl as PUBLIC_KEY,
  Ha as Padding,
  om as ParticleBurst,
  bw as ParticleSubEmitter,
  Td as ParticleSystem,
  Pr as ParticleSystemBaseBehaviour,
  mn as ParticleSystemRenderer,
  nm as ParticleSystemShapeType,
  io as PeerHandle,
  j1 as PeerNetworking,
  uc as Physics,
  ew as PhysicsExtension,
  xt as PhysicsMaterialCombine,
  Fu as PixelationEffect,
  Md as PlayAnimationOnClick,
  cr as PlayAudioOnClick,
  Ia as PlayableDirector,
  wc as PlayerColor,
  Rn as PlayerState,
  DR as PlayerStateEvent,
  Zv as PlayerSync,
  gO as PlayerView,
  yO as PlayerViewManager,
  cu as PointerEventData,
  Um as PointerType,
  at as PostProcessingEffect,
  dt as PostProcessingEffectOrder,
  Ow as PostProcessingHandler,
  Ic as PreliminaryAction,
  vu as PreliminaryTrigger,
  Go as PreviewHelper,
  xa as PrimitiveType,
  le as Progress,
  qb as PromiseAllWithErrors,
  wy as PromiseErrorResult,
  oe as RGBAColor,
  ac as RapierPhysics,
  ty as RawImage,
  _r as RaycastOptions,
  qR as Rect,
  Un as RectTransform,
  kd as ReflectionProbe,
  Yo as RegisteredAnimationInfo,
  Gg as RemoteSkybox,
  ps as RenderTexture,
  xk as RenderTextureSerializer,
  Qi as Renderer,
  CO as RendererData,
  Yp as RendererLightmap,
  rt as Rigidbody,
  Ge as RigidbodyConstraints,
  te as RoomEvents,
  pn as RotationBySpeedModule,
  Gn as RotationOverLifetimeModule,
  Xp as SceneLightSettings,
  Ze as SceneSwitcher,
  Rr as ScreenCapture,
  ko as ScreenSpaceAmbientOcclusion,
  Xn as ScreenSpaceAmbientOcclusionN8,
  qw as ScrollFollow,
  wn as SendQueue,
  j0 as SerializationContext,
  qv as SetActiveOnClick,
  Uu as ShadowCatcher,
  gw as ShapeModule,
  $k as ShapeOverlapResult,
  zu as SharpeningEffect,
  Yg as SignalAsset,
  Vu as SignalReceiver,
  Wu as SignalReceiverEvent,
  Ld as SignalTrackHandler,
  GR as Size,
  Mi as SizeBySpeedModule,
  Ka as SizeOverLifetimeModule,
  Av as SkinnedMeshRenderer,
  qg as SmoothFollow,
  Ea as SpatialGrabRaycaster,
  Qu as SpatialHtml,
  Xg as SpatialTrigger,
  xs as SpatialTriggerReceiver,
  Qg as SpectatorCamera,
  Rc as SphereCollider,
  w0 as SphereIntersection,
  tl as SplineContainer,
  ks as SplineData,
  xb as SplineUtils,
  Qn as SplineWalker,
  wo as Sprite,
  tc as SpriteData,
  Pi as SpriteRenderer,
  _c as SpriteSheet,
  PL as StateMachineBehaviour,
  av as StreamEndedEvent,
  Wk as StreamReceivedEvent,
  lm as SubEmitterSystem,
  jw as SyncedCamera,
  Yn as SyncedRoom,
  zn as SyncedTransform,
  Xv as TapGestureTrigger,
  kg as TeleportTarget,
  Bw as TestRunner,
  WL as TestSceneUtils,
  Fw as TestSimulateUserData,
  Xt as Text,
  ow as TextBuilder,
  Tg as TextExtension,
  Yt as TextureSheetAnimationModule,
  Ds as TiltShiftEffect,
  OO as Time,
  fr as ToneMappingEffect,
  Hu as TrackHandler,
  Fi as TrackType,
  Ne as TrailModule,
  Ue as TransformData,
  il as TransformGizmo,
  Gt as TriggerBuilder,
  sr as TriggerModel,
  P as TypeStore,
  rv as UIRaycastUtils,
  Pu as UIRootComponent,
  zv as USDDocument,
  st as USDObject,
  sR as USDWriter,
  ws as USDZExporter,
  rR as USDZExporter$1,
  Bl as USDZText,
  dw as USDZUIExtension,
  Sk as UriSerializer,
  mu as UsageMarker,
  rL as UserJoinedOrLeftRoomModel,
  En as VERSION,
  Hv as VariantAction,
  Ve as VelocityOverLifetimeModule,
  rw as VerticalLayoutGroup,
  mt as VideoPlayer,
  tr as ViewDevice,
  Ja as Vignette,
  wu as VisibilityAction,
  wr as Voip,
  Vc as Volume,
  F as VolumeParameter,
  Ng as VolumeProfile,
  fL as WaitForFrames,
  dO as WaitForPromise,
  q0 as WaitForSeconds,
  ao as Watch,
  Zu as WebARCameraBackground,
  Vi as WebARSessionRoot,
  Mg as WebXR,
  or as WebXRButtonFactory,
  Ju as WebXRImageTracking,
  Io as WebXRImageTrackingModel,
  Lo as WebXRPlaneTracking,
  xc as WebXRTrackedImage,
  Eo as XRControllerFollow,
  mo as XRControllerModel,
  Yi as XRControllerMovement,
  rn as XRFlag,
  oy as XRRig,
  ei as XRState,
  fs as XRStateFlag,
  yI as __Ignore,
  cL as __internalNotifyObjectDestroyed,
  lo as activeInHierarchyFieldName,
  wC as addAttributeChangeCallback,
  An as addComponent,
  IL as addCustomExtensionPlugin,
  aa as addNewComponent,
  Bm as addPatch,
  Qm as apply,
  xL as applyHMRChanges,
  $P as applyPrototypeExtensions,
  yP as beginListenDestroy,
  vP as beginListenInstantiate,
  y0 as binaryIdentifierCasts,
  mL as build_scene_functions,
  $r as builtinComponentKeyName,
  ix as calculateProgress01,
  VI as clearMessages,
  ML as colorSerializer,
  MP as compareAssociation,
  Rf as componentSerializer,
  t1 as copyTexture,
  ek as createMotion,
  ci as debugNet,
  oh as debugOwner,
  lR as decompressGpuTexture,
  Xd as deepClone,
  Os as delay,
  Qd as delayForFrames,
  Ip as deserializeObject,
  Gi as destroy,
  XP as destroyComponentInstance,
  pM as determineMimeTypeFromExtension,
  Re as disposeObjectResources,
  gs as disposeStream,
  Fh as editorGuidKeyName,
  ia as enableSpatialConsole,
  RL as euler,
  TL as eventListSerializer,
  HL as exportAsGLTF,
  W0 as findByGuid,
  su as findObjectOfType,
  QP as findObjectsOfType,
  P0 as findResourceUsers,
  o1 as fitObjectIntoVolume,
  Oa as foreachComponent,
  Km as foreachComponentEnumerator,
  XI as forward,
  CC as generateQRCode,
  bP as generateSeed,
  ii as getBoundingBox,
  zC as getCameraController,
  Da as getComponent,
  nu as getComponentInChildren,
  yd as getComponentInParent,
  iu as getComponents,
  Cc as getComponentsInChildren,
  Xm as getComponentsInParent,
  XM as getFormattedDate,
  Et as getIconElement,
  f_ as getIconTexture,
  Bn as getLoader,
  tu as getOrAddComponent,
  w as getParam,
  QI as getParentHierarchyPath,
  EI as getPath,
  iL as getPeerOptions,
  D1 as getPeerjsInstance,
  hL as getResourceUserCount,
  HC as getTempColor,
  ui as getTempQuaternion,
  H as getTempVector,
  qd as getUrlParams,
  s1 as getVisibleInCustomShadowRendering,
  KC as getWorldDirection,
  t0 as getWorldEuler,
  Z as getWorldPosition,
  be as getWorldQuaternion,
  Dm as getWorldRotation,
  Qe as getWorldScale,
  vs as hasCommercialLicense,
  ru as hasIndieLicense,
  Hp as hasPointerEventComponent,
  bs as hasProLicense,
  f1 as hideDebugConsole,
  dR as imageToCanvas,
  ka as instantiate,
  zM as invokeLoadedImportPluginHooks,
  P1 as invokeXRSessionEnd,
  C1 as invokeXRSessionStart,
  JP as isActiveInHierarchy,
  Pc as isActiveSelf,
  jI as isAndroidDevice,
  e1 as isAnimationAction,
  zk as isComponent,
  kI as isDebugMode,
  AI as isDesktop,
  Pa as isDestroyed,
  L as isDevEnvironment,
  lL as isDisposed,
  VL as isExporting,
  Fk as isGLTFModel,
  rC as isHostedOnGlitch,
  w_ as isHotReloadEnabled,
  wL as isHotReloading,
  LI as isIPad,
  RO as isIconElement,
  hn as isLocalNetwork,
  FI as isMacOS,
  II as isMobileDevice,
  BI as isMozillaXR,
  NI as isQuest,
  oP as isResourceTrackingEnabled,
  UI as isSafari,
  Ym as isUsingInstancing,
  zI as isiOS,
  DI as isiPad,
  NL as loadAsset,
  zE as loadPMREM,
  Jw as loadSync,
  wp as logHierarchy,
  GI as lookAtInverse,
  Yd as lookAtObject,
  qI as lookAtScreenPoint,
  RI as makeId,
  yC as makeIdFromRandomWords,
  dn as makeNameSafe,
  eO as markAsInstancedRendered,
  $I as microphonePermissionsGranted,
  OI as nameof,
  mC as nameofFactory,
  _k as objectSerializer,
  eL as offXRSessionEnd,
  JI as offXRSessionStart,
  vL as onAfterRender,
  bL as onBeforeRender,
  yL as onClear,
  _L as onDestroy,
  WO as onInitialized,
  tg as onStart,
  VO as onUpdate,
  p0 as onXRSessionEnd,
  zm as onXRSessionStart,
  KA as parseSync,
  r1 as placeOnSurface,
  s0 as postprocessFBXMaterials,
  kL as prefix,
  gC as pushState,
  TI as randomNumber,
  _0 as registerBinaryType,
  Jm as registerComponent,
  Mv as registerComponentExtension,
  gn as registerCustomEffectType,
  Rv as registerExportExtensions,
  Qp as registerExtensions,
  GO as registerHotReloadType,
  d0 as registerLoader,
  xP as registerPrefabProvider,
  WP as registerPrototypeExtensions,
  uL as registerType,
  bC as relativePathPrefix,
  xC as removeAttributeChangeCallback,
  U0 as removeComponent,
  LL as removeCustomImportExtensionType,
  ZI as removePatch,
  gr as resolveUrl,
  _C as sanitizeString,
  DA as saveImage,
  UL as screenshot,
  Qw as screenshot2,
  E0 as sendDestroyed,
  u as serializable,
  LP as serializeObject,
  lt as serializeable,
  Wh as setActive,
  TC as setAllowBalloonMessages,
  WI as setAllowOverlayMessages,
  vp as setAutoFitEnabled,
  Cy as setCameraController,
  tO as setDestroyed,
  KI as setDevEnvironment,
  rP as setDisposable,
  hl as setDontDestroy,
  _y as setOrAddParamsToUrl,
  MI as setParam,
  rd as setParamWithoutReload,
  nL as setPeerOptions,
  aL as setResourceTrackingEnabled,
  Hb as setState,
  n0 as setVisibleInCustomShadowRendering,
  i0 as setWorldEuler,
  Ot as setWorldPosition,
  ba as setWorldPositionXYZ,
  jn as setWorldQuaternion,
  e0 as setWorldQuaternionXYZW,
  JC as setWorldRotation,
  Kd as setWorldRotationXYZ,
  hc as setWorldScale,
  Zd as showBalloonError,
  Be as showBalloonMessage,
  ge as showBalloonWarning,
  a0 as showDebugConsole,
  HI as slerp,
  eu as syncDestroy,
  Yv as syncField,
  A0 as syncInstantiate,
  YI as textureToCanvas,
  I1 as tryCastBinary,
  gM as tryDetermineMimetypeFromBinary,
  mM as tryDetermineMimetypeFromURL,
  cc as tryFindObject,
  L1 as tryGetGuid,
  qO as unregisterHotReloadType,
  Gb as unwatchWrite,
  UC as useForAutoFit,
  Lt as validate,
  Am as watchWrite
};
