import { Vector2 as J, Vector3 as b, Vector4 as de, Quaternion as $, PlaneGeometry as Un, WebGLRenderer as ur, PerspectiveCamera as pe, OrthographicCamera as Td, Scene as gi, Mesh as H, Texture as Te, Uniform$1 as zi, Color as se, ShaderMaterial as Ln, Box3 as pi, ShadowMaterial as ob, Euler as Rt, MeshStandardMaterial as ct, Box3Helper as Ww, GridHelper as am, Object3D as M, Material as _e, Matrix3 as rb, Matrix4 as te, Layers as ao, Ray as lo, MathUtils as gs, AxesHelper as mi, MeshBasicMaterial as we, DoubleSide as yi, BufferGeometry as Tn, Group as io, CylinderGeometry as ab, SphereGeometry as Ed, BoxGeometry as la, SpriteMaterial as Vw, Sprite as Hw, Shape as Gw, ExtrudeGeometry as qw, Fog as lb, DirectionalLight as ip, PointLight as lm, EdgesGeometry as Xw, LineSegments as cb, LineBasicMaterial as hb, Line as Zl, BufferAttribute as ht, Raycaster as Ad, Sphere as Id, ArrayCamera as Qw, Plane as nr, SkinnedMesh as ys, InterleavedBufferAttribute as db, Skeleton as Yw, Bone as Kw, Source as Zw, WebGLCubeRenderTarget as Jw, CubeCamera as ex, AnimationClip as no, FileLoader as cm, TextureLoader as Jl, PropertyBinding as ca, LinearSRGBColorSpace as Ss, ShaderChunk as Wt, UniformsLib as tx, DataTexture as hm, RGBAFormat as Ld, EquirectangularReflectionMapping as _s, SRGBColorSpace as Cs, Clock as ix, NeutralToneMapping as ha, AgXToneMapping as Dd, ACESFilmicToneMapping as jd, NoToneMapping as Gh, PCFSoftShadowMap$1 as nx, BasicNodeLibrary as sx, WebGLRenderTarget as Dn, DepthTexture as ub, NearestFilter as qh, LoopRepeat as ox, LoopOnce as np, AnimationMixer as dm, CompressedTexture as rx, FrontSide as co, Camera as ax, Frustum as Gg, AudioListener as lx, PositionalAudio as cx, AudioLoader as sp, EventDispatcher as um, BackSide as Bd, MeshDepthMaterial as hx, CustomBlending as dx, MaxEquation as ux, AmbientLight as fx, HemisphereLight as px, AlwaysStencilFunc as mx, GreaterEqualStencilFunc as gx, NotEqualStencilFunc as yx, GreaterStencilFunc as _x, LessEqualStencilFunc as bx, EqualStencilFunc as vx, LessStencilFunc as wx, NeverStencilFunc as qg, InvertStencilOp as xx, DecrementWrapStencilOp as Sx, IncrementWrapStencilOp as Cx, DecrementStencilOp as Px, IncrementStencilOp as Ox, ReplaceStencilOp as kx, ZeroStencilOp as Mx, KeepStencilOp as Rx, RawShaderMaterial as fb, GLSL3 as Tx, AlwaysDepth as Ex, GreaterEqualDepth as Ax, GreaterDepth as Ix, LessEqualDepth as Lx, LessDepth as Dx, NotEqualDepth as jx, EqualDepth as Bx, BatchedMesh as Xg, MeshPhysicalMaterial as op, LinearFilter as Xh, UnsignedByteType as Fx, RingGeometry as zx, Line3 as Ux, AdditiveBlending as pb, BoxHelper as Nx, SpotLight as $x, DirectionalLightHelper as Wx, CameraHelper as Vx, LOD as Hx, Triangle as Gx, NormalBlending as qx, ReinhardToneMapping as fm, LinearToneMapping as pm, HalfFloatType as Vu, VideoTexture as Xx, CubeUVReflectionMapping as mb, CubeTexture as Qx, CompressedCubeTexture as Yx, EquirectangularRefractionMapping as Kx, VectorKeyframeTrack as Zx, QuaternionKeyframeTrack as Jx, Audio as eS, ShaderLib as Qh, UniformsUtils as gb, MirroredRepeatWrapping as Qg, MeshNormalMaterial as tS, AudioContext as iS, PMREMGenerator$1 as nS } from "./three-BRSLmpyi.js";
import { createLoaders as mm, getRaycastMesh as yb, LODsManager as Ao, NEEDLE_progressive as We, addDracoAndKTX2Loaders as sS, configureLoader as oS, setKTX2TranscoderLocation as rS, setDracoDecoderLocation as aS } from "./gltf-progressive-BcHT3Nyo.js";
import { GroundedSkybox as da, Font as lS, TextGeometry as cS, FontLoader as hS, GLTFLoader as Ps, TransformControlsGizmo as _b, EXRLoader as gm, RGBELoader as bb, Stats as dS, nodeFrame as uS, OrbitControls as vb, PositionalAudioHelper as fS, HorizontalBlurShader as pS, VerticalBlurShader as mS, GLTFExporter as wb, strToU8 as xb, zipSync as gS, XRControllerModelFactory as yS, XRHandMeshModel as _S, Line2 as bS, LineGeometry as vS, LineMaterial as wS, TransformControls as xS, InteractiveGroup as SS, HTMLMesh as CS, VertexNormalsHelper as PS, OBJLoader as ym, FBXLoader as Sb, mergeVertices as OS } from "./three-examples-CNexix3E.js";
import { fetchProfile as kS, MotionController as MS, $70d766613f57b014$export$2e2bcd8739ae039 as Yg, ByteBuffer as RS, v5 as Kg, md5 as Zg, SIZE_PREFIX_LENGTH as Cb, Builder as _m, createNoise4D as TS, Matrix4 as Hu, BatchedParticleRenderer as ES, ParticleSystem as AS, RenderMode as as, ConstantColor as IS, Vector4 as LS, ConstantValue as DS, TrailParticle as Jg, WorkerBase as jS, MeshBVH as BS } from "./vendor-Z4SPrTcP.js";
import { __webpack_exports__default as Ce, __webpack_exports__Text as Pb, __webpack_exports__Block as Ob, __webpack_exports__update as FS, SimpleStateBehavior as zS, __webpack_exports__Inline as Gu, __webpack_exports__FontLibrary as ey, ThreeMeshUI as ty } from "./three-mesh-ui-gqAXlGNB.js";
import { EffectAttribute as US } from "./postprocessing-ORx-0eCx.js";
const qu = /* @__PURE__ */ new Map();
function rn(s = globalThis.location?.hostname) {
  if (qu.has(s)) return qu.get(s);
  const e = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|localhost/.test(s);
  return qu.set(s, e), e === !0;
}
function NS() {
  return window.location.hostname.includes("glitch.me");
}
const $S = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 160 187.74"><defs><linearGradient id="a" x1="89.64" y1="184.81" x2="90.48" y2="21.85" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#62d399"/><stop offset=".51" stop-color="#acd842"/><stop offset=".9" stop-color="#d7db0a"/></linearGradient><linearGradient id="b" x1="69.68" y1="178.9" x2="68.08" y2="16.77" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#0ba398"/><stop offset=".5" stop-color="#4ca352"/><stop offset="1" stop-color="#76a30a"/></linearGradient><linearGradient id="c" x1="36.6" y1="152.17" x2="34.7" y2="84.19" gradientUnits="userSpaceOnUse"><stop offset=".19" stop-color="#36a382"/><stop offset=".54" stop-color="#49a459"/><stop offset="1" stop-color="#76a30b"/></linearGradient><linearGradient id="d" x1="15.82" y1="153.24" x2="18" y2="90.86" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#267880"/><stop offset=".51" stop-color="#457a5c"/><stop offset="1" stop-color="#717516"/></linearGradient><linearGradient id="e" x1="135.08" y1="135.43" x2="148.93" y2="63.47" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#b0d939"/><stop offset="1" stop-color="#eadb04"/></linearGradient><linearGradient id="f" x1="-4163.25" y1="2285.12" x2="-4160.81" y2="2215.34" gradientTransform="rotate(20 4088.49 13316.712)" gradientUnits="userSpaceOnUse"><stop offset=".17" stop-color="#74af52"/><stop offset=".48" stop-color="#99be32"/><stop offset="1" stop-color="#c0c40a"/></linearGradient><symbol id="g" viewBox="0 0 160 187.74"><path style="fill:url(#a)" d="M79.32 36.98v150.76L95 174.54l6.59-156.31-22.27 18.75z"/><path style="fill:url(#b)" d="M79.32 36.98 57.05 18.23l6.59 156.31 15.68 13.2V36.98z"/><path style="fill:url(#c)" d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33z"/><path style="fill:url(#d)" d="M25.19 104.83 0 90.24l16.97 53.86 16.85 9.77-8.63-49.04z"/><path style="fill:#9c3" d="M43.86 82.5 18.69 67.98 0 90.24l25.18 14.59L43.86 82.5z"/><path style="fill:url(#e)" d="m134.82 78.69-9.97 56.5 15.58-9.04L160 64.1l-25.18 14.59z"/><path style="fill:url(#f)" d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5z"/><path style="fill:#ffe113" d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33L160 64.1z"/><path style="fill:#f3e600" d="M101.59 18.23 79.32 0 57.05 18.23l22.27 18.75 22.27-18.75z"/></symbol></defs><use width="160" height="187.74" xlink:href="#g"/></svg>', WS = btoa($S), VS = "data:image/svg+xml;base64," + WS, kb = VS, HS = `<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'> <svg clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" version="1.1" viewBox="0 0 1014 282" xml:space="preserve" xmlns="http://www.w3.org/2000/svg"> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m665.95 132.73v44.88l-10.56-8.4c-0.8-0.64-1.2-1.44-1.2-2.4v-32.4c0-6.48-4.12-9.72-12.36-9.72-2.16 0-4.18 0.4-6.06 1.2s-3.54 1.8-4.98 3-2.56 2.5-3.36 3.9-1.2 2.7-1.2 3.9v40.92l-10.68-8.4c-0.72-0.64-1.08-1.44-1.08-2.4v-53.76l10.92 8.52c0.32 0.24 0.56 0.44 0.72 0.6s0.36 0.32 0.6 0.48c0.96-1.2 2.14-2.28 3.54-3.24s2.92-1.76 4.56-2.4 3.34-1.14 5.1-1.5 3.44-0.54 5.04-0.54c1.44 0 2.92 0.04 4.44 0.12s2.84 0.28 3.96 0.6c4.56 1.12 7.8 3.12 9.72 6s2.88 6.56 2.88 11.04z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m732.38 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m795.93 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m858.57 97.21c0.64 0.48 0.96 1.16 0.96 2.04v74.88c-0.08 1.04-0.12 2.12-0.12 3.24-1.84-1.52-3.56-2.92-5.16-4.2-1.36-1.12-2.66-2.18-3.9-3.18s-2.06-1.66-2.46-1.98c-1.76 2.48-4.26 4.44-7.5 5.88s-7.02 2.16-11.34 2.16c-3.84 0-7.4-0.7-10.68-2.1s-6.14-3.44-8.58-6.12-4.34-5.94-5.7-9.78-2.04-8.16-2.04-12.96c0-4.32 0.78-8.34 2.34-12.06s3.6-6.92 6.12-9.6 5.38-4.78 8.58-6.3 6.48-2.28 9.84-2.28c2.56 0 4.82 0.22 6.78 0.66s3.68 1.06 5.16 1.86 2.78 1.74 3.9 2.82 2.16 2.22 3.12 3.42v-35.04l10.68 8.64zm-27.96 67.92c3.6 0 6.52-0.68 8.76-2.04s3.98-3.06 5.22-5.1 2.1-4.22 2.58-6.54 0.72-4.44 0.72-6.36v-1.2c0-1.12-0.22-2.7-0.66-4.74s-1.28-4.06-2.52-6.06-3-3.7-5.28-5.1-5.22-2.02-8.82-1.86c-3.44 0-6.26 0.74-8.46 2.22s-3.96 3.26-5.28 5.34-2.24 4.2-2.76 6.36-0.78 3.92-0.78 5.28c0 1.84 0.24 3.92 0.72 6.24s1.36 4.48 2.64 6.48 3.04 3.68 5.28 5.04 5.12 2.04 8.64 2.04z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m882.81 97.09c0.64 0.48 0.96 1.12 0.96 1.92l-0.12 41.04v37.08l-10.56-8.4c-0.72-0.64-1.08-1.44-1.08-2.4v-77.88l10.8 8.64z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m950.36 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.8559 0 0 .7642 45.348 36.475)"> <g transform="translate(2.7114)"> <path d="m3.935 173.02c-0.331 0-0.497-0.402-0.497-1.207v-51.002c0-0.738 0.138-1.107 0.414-1.107h1.781c0.277 0 0.415 0.335 0.415 1.006v5.935c0 0.336 0.027 0.553 0.083 0.654 0.055 0.101 0.151-0.017 0.289-0.352 0.912-1.744 1.754-3.236 2.527-4.477 0.773-1.24 1.554-2.179 2.341-2.816s1.65-0.956 2.588-0.956c1.685 0 3.011 0.922 3.977 2.766 0.967 1.845 1.602 3.84 1.905 5.986 0.056 0.268 0.139 0.369 0.249 0.302s0.221-0.235 0.331-0.503c0.939-1.811 1.802-3.353 2.589-4.628 0.787-1.274 1.581-2.246 2.382-2.917s1.671-1.006 2.61-1.006c2.016 0 3.569 1.392 4.66 4.175 1.09 2.783 1.636 6.421 1.636 10.915v37.925c0 0.871-0.18 1.307-0.539 1.307h-1.739c-0.138 0-0.249-0.1-0.332-0.301-0.083-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.338-6.321-1.015-8.3-0.676-1.978-1.76-2.967-3.251-2.967-0.884 0-1.726 0.386-2.527 1.157s-1.519 1.727-2.154 2.867-1.201 2.213-1.699 3.219c-0.248 0.469-0.421 0.905-0.517 1.308-0.097 0.402-0.145 0.972-0.145 1.71v37.221c0 0.871-0.166 1.307-0.497 1.307h-1.74c-0.166 0-0.29-0.1-0.373-0.301-0.083-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.332-6.321-0.994-8.3-0.663-1.978-1.754-2.967-3.273-2.967-1.242 0-2.375 0.704-3.396 2.112-1.022 1.409-2.223 3.555-3.604 6.439v39.031c0 0.805-0.18 1.207-0.539 1.207h-1.698z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m53.642 166.28c-1.077 2.549-2.237 4.477-3.479 5.785-1.243 1.307-2.61 1.961-4.101 1.961-2.154 0-3.853-1.324-5.095-3.973-1.243-2.649-1.864-6.187-1.864-10.613 0-3.488 0.4-6.489 1.201-9.004s1.988-4.51 3.562-5.985c1.574-1.476 3.521-2.414 5.841-2.817l3.686-0.704c0.221-0.067 0.394-0.218 0.518-0.453 0.124-0.234 0.187-0.587 0.187-1.056v-2.917c0-3.89-0.504-6.975-1.512-9.255s-2.354-3.42-4.039-3.42c-1.298 0-2.472 0.72-3.521 2.162s-2.002 3.572-2.858 6.388c-0.083 0.268-0.159 0.453-0.228 0.554-0.069 0.1-0.172 0.083-0.311-0.051l-1.698-1.71c-0.083-0.134-0.138-0.285-0.166-0.453-0.027-0.167 0.014-0.452 0.125-0.855 0.856-3.353 2.009-6.052 3.459-8.098 1.449-2.045 3.224-3.068 5.322-3.068 1.74 0 3.211 0.687 4.412 2.062s2.112 3.37 2.734 5.986c0.621 2.615 0.932 5.7 0.932 9.255v35.712c0 0.536-0.035 0.888-0.104 1.056s-0.2 0.251-0.393 0.251h-1.533c-0.166 0-0.29-0.117-0.373-0.352-0.083-0.234-0.124-0.553-0.124-0.955l-0.083-5.231c-0.055-0.939-0.221-1.006-0.497-0.202zm0.456-19.314c0-1.14-0.194-1.643-0.58-1.509l-3.107 0.603c-1.436 0.202-2.686 0.638-3.749 1.308-1.063 0.671-1.953 1.543-2.671 2.616s-1.257 2.33-1.616 3.772-0.538 3.102-0.538 4.98c0 3.152 0.455 5.616 1.367 7.393 0.911 1.778 2.14 2.666 3.686 2.666 0.939 0 1.85-0.419 2.734-1.257s1.671-1.895 2.361-3.169c0.663-1.408 1.181-2.85 1.553-4.326 0.373-1.475 0.56-2.883 0.56-4.225v-8.852z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m79.034 173.02c-0.166 0-0.297-0.117-0.394-0.352-0.096-0.234-0.145-0.553-0.145-0.955v-4.628c0-0.536-0.041-0.838-0.124-0.905s-0.207 0.1-0.373 0.503c-0.276 0.67-0.69 1.593-1.242 2.766-0.553 1.174-1.271 2.23-2.154 3.169-0.884 0.939-1.961 1.408-3.231 1.408-1.74 0-3.314-0.989-4.722-2.967-1.409-1.979-2.534-4.963-3.376-8.953-0.843-3.991-1.264-8.937-1.264-14.838 0-5.701 0.415-10.68 1.243-14.939s1.988-7.595 3.479-10.009c1.492-2.415 3.204-3.622 5.137-3.622 1.436 0 2.616 0.57 3.541 1.71 0.926 1.14 1.719 2.381 2.382 3.722 0.249 0.47 0.414 0.637 0.497 0.503s0.125-0.536 0.125-1.207v-23.841c0-0.805 0.151-1.208 0.455-1.208h1.864c0.276 0 0.414 0.369 0.414 1.107v72.128c0 0.537-0.041 0.905-0.124 1.107-0.083 0.201-0.235 0.301-0.455 0.301h-1.533zm-0.621-42.049c-0.939-2.213-1.885-3.94-2.838-5.181s-2.009-1.861-3.169-1.861c-1.463 0-2.768 0.889-3.914 2.666s-2.044 4.376-2.693 7.796-0.973 7.578-0.973 12.474c0 5.097 0.338 9.272 1.015 12.524 0.676 3.253 1.567 5.651 2.672 7.193 1.104 1.543 2.305 2.314 3.603 2.314 1.188 0 2.258-0.704 3.211-2.113 0.952-1.408 1.705-3.118 2.257-5.13s0.829-3.957 0.829-5.835v-24.847z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m89.514 149.38c0 3.42 0.345 6.606 1.035 9.557 0.691 2.951 1.609 5.315 2.755 7.092s2.437 2.666 3.873 2.666c1.519 0 2.837-0.738 3.956-2.213 1.118-1.476 2.064-3.655 2.837-6.539 0.083-0.336 0.166-0.52 0.249-0.554 0.083-0.033 0.179 0.017 0.29 0.151l1.408 1.912c0.221 0.268 0.235 0.67 0.041 1.207-0.69 2.548-1.47 4.661-2.34 6.337-0.87 1.677-1.857 2.935-2.962 3.773-1.104 0.838-2.319 1.257-3.645 1.257-2.043 0-3.838-1.14-5.385-3.42-1.546-2.28-2.761-5.482-3.645-9.607-0.884-4.124-1.325-8.836-1.325-14.134 0-5.901 0.455-10.931 1.367-15.089 0.911-4.158 2.14-7.377 3.686-9.658 1.547-2.28 3.3-3.42 5.261-3.42 1.988 0 3.714 1.073 5.178 3.219 1.463 2.146 2.595 5.231 3.396 9.255s1.201 8.886 1.201 14.587c0 0.469-0.02 0.939-0.062 1.408-0.041 0.469-0.214 0.704-0.517 0.704h-16.362c-0.083 0-0.152 0.151-0.207 0.453-0.056 0.302-0.083 0.654-0.083 1.056zm13.752-6.237c0.304 0 0.497-0.1 0.58-0.302 0.083-0.201 0.124-0.57 0.124-1.106 0-3.219-0.283-6.187-0.849-8.903s-1.367-4.896-2.402-6.539c-1.036-1.643-2.272-2.464-3.708-2.464-1.629 0-2.996 0.955-4.101 2.867-1.104 1.911-1.94 4.342-2.506 7.293s-0.849 6.002-0.849 9.154h13.711z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m148.54 119.7c0.165 0 0.283 0.117 0.352 0.352s0.076 0.52 0.02 0.855l-6.254 50.902c-0.028 0.47-0.104 0.788-0.228 0.956s-0.297 0.251-0.518 0.251h-1.615c-0.442 0-0.718-0.402-0.829-1.207l-5.26-40.138c-0.111-0.604-0.201-0.905-0.27-0.905s-0.131 0.301-0.186 0.905l-5.012 40.138c-0.028 0.47-0.097 0.788-0.207 0.956-0.111 0.168-0.277 0.251-0.497 0.251h-1.74c-0.442 0-0.718-0.402-0.829-1.207l-6.503-50.801c-0.055-0.403-0.048-0.721 0.021-0.956s0.2-0.352 0.393-0.352h1.823c0.166 0 0.297 0.067 0.393 0.201 0.097 0.134 0.159 0.403 0.187 0.805l5.302 41.848c0.083 0.671 0.179 0.989 0.29 0.956 0.11-0.034 0.207-0.386 0.29-1.056l5.219-41.949c0.055-0.268 0.124-0.47 0.207-0.604s0.193-0.201 0.331-0.201h1.533c0.138 0 0.262 0.067 0.373 0.201 0.11 0.134 0.179 0.403 0.207 0.805l5.468 41.848c0.083 0.671 0.179 0.989 0.29 0.956 0.11-0.034 0.207-0.386 0.29-1.056l5.053-41.849c0.055-0.335 0.138-0.57 0.249-0.704 0.11-0.134 0.234-0.201 0.373-0.201h1.284z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m156.49 171.51c0 0.604-0.042 1.006-0.125 1.208-0.082 0.201-0.262 0.301-0.538 0.301h-1.533c-0.221 0-0.366-0.083-0.435-0.251s-0.103-0.486-0.103-0.956v-50.902c0-0.805 0.152-1.207 0.456-1.207h1.822c0.304 0 0.456 0.402 0.456 1.207v50.6zm0.165-63.979c0 1.207-0.207 1.811-0.621 1.811h-1.905c-0.221 0-0.366-0.135-0.435-0.403s-0.104-0.67-0.104-1.207v-7.847c0-1.006 0.18-1.509 0.539-1.509h1.988c0.359 0 0.538 0.47 0.538 1.409v7.746z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m168.3 124.83c-0.221 0-0.331 0.269-0.331 0.805v33.801c0 3.42 0.221 5.667 0.663 6.74 0.441 1.073 1.09 1.609 1.946 1.609h3.024c0.138 0 0.242 0.084 0.311 0.252 0.069 0.167 0.103 0.419 0.103 0.754v2.716c0 0.537-0.138 0.906-0.414 1.107-0.248 0.067-0.614 0.134-1.098 0.201-0.483 0.067-0.959 0.118-1.429 0.151-0.469 0.034-0.828 0.05-1.077 0.05-1.712 0-2.934-0.955-3.665-2.867-0.732-1.911-1.098-5.013-1.098-9.305v-35.108c0-0.604-0.124-0.906-0.373-0.906h-3.521c-0.248 0-0.373-0.268-0.373-0.804v-3.521c0-0.537 0.111-0.805 0.332-0.805h3.686c0.166 0 0.263-0.268 0.29-0.805l0.415-16.095c0-0.805 0.124-1.207 0.372-1.207h1.492c0.303 0 0.455 0.436 0.455 1.307v15.995c0 0.537 0.097 0.805 0.29 0.805h5.468c0.221 0 0.331 0.268 0.331 0.805v3.521c0 0.536-0.124 0.804-0.373 0.804h-5.426z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m179.4 173.02c-0.331 0-0.497-0.402-0.497-1.207v-72.329c0-0.738 0.138-1.107 0.414-1.107h1.782c0.276 0 0.414 0.336 0.414 1.006v27.162c0 0.335 0.034 0.536 0.103 0.603s0.159-0.033 0.27-0.302c0.994-1.81 1.898-3.319 2.713-4.526 0.814-1.208 1.629-2.113 2.444-2.717 0.814-0.603 1.691-0.905 2.63-0.905 2.182 0 3.839 1.375 4.971 4.125 1.132 2.749 1.698 6.404 1.698 10.965v37.925c0 0.871-0.166 1.307-0.497 1.307h-1.74c-0.165 0-0.29-0.1-0.373-0.301-0.082-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.366-6.321-1.097-8.3-0.732-1.978-1.899-2.967-3.501-2.967-0.883 0-1.705 0.318-2.464 0.956-0.76 0.637-1.526 1.576-2.299 2.816-0.773 1.241-1.643 2.834-2.61 4.779v39.031c0 0.805-0.179 1.207-0.538 1.207h-1.699z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> </g> <g transform="matrix(.80638 0 0 .80638 452.53 65.421)" fill-rule="nonzero"> <path d="m79.32 36.98v150.76l15.68-13.2 6.59-156.31-22.27 18.75z" fill="url(#f)"/> <path d="m79.32 36.98-22.27-18.75 6.59 156.31 15.68 13.2v-150.76z" fill="url(#e)"/> <path d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33z" fill="url(#d)"/> <path d="m25.19 104.83-25.19-14.59 16.97 53.86 16.85 9.77-8.63-49.04z" fill="url(#c)"/> <path d="M43.86,82.5L18.69,67.98L0,90.24L25.18,104.83L43.86,82.5Z" fill="#9c3"/> <path d="m134.82 78.69-9.97 56.5 15.58-9.04 19.57-62.05-25.18 14.59z" fill="url(#b)"/> <path d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5z" fill="url(#a)"/> <path d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33 25.19-14.59z" fill="#ffe113"/> <path d="M101.59,18.23L79.32,0L57.05,18.23L79.32,36.98L101.59,18.23Z" fill="#f3e600"/> </g> <defs> <linearGradient id="f" x2="1" gradientTransform="matrix(.84 -162.96 162.96 .84 89.64 184.81)" gradientUnits="userSpaceOnUse"><stop stop-color="#62d399" offset="0"/><stop stop-color="#acd842" offset=".51"/><stop stop-color="#d7db0a" offset=".9"/><stop stop-color="#d7db0a" offset="1"/></linearGradient> <linearGradient id="e" x2="1" gradientTransform="matrix(-1.6,-162.13,162.13,-1.6,69.68,178.9)" gradientUnits="userSpaceOnUse"><stop stop-color="#0ba398" offset="0"/><stop stop-color="#4ca352" offset=".5"/><stop stop-color="#76a30a" offset="1"/></linearGradient> <linearGradient id="d" x2="1" gradientTransform="matrix(-1.9,-67.98,67.98,-1.9,36.6,152.17)" gradientUnits="userSpaceOnUse"><stop stop-color="#36a382" offset="0"/><stop stop-color="#36a382" offset=".19"/><stop stop-color="#49a459" offset=".54"/><stop stop-color="#76a30b" offset="1"/></linearGradient> <linearGradient id="c" x2="1" gradientTransform="matrix(2.18,-62.38,62.38,2.18,15.82,153.24)" gradientUnits="userSpaceOnUse"><stop stop-color="#267880" offset="0"/><stop stop-color="#457a5c" offset=".51"/><stop stop-color="#717516" offset="1"/></linearGradient> <linearGradient id="b" x2="1" gradientTransform="matrix(13.85,-71.96,71.96,13.85,135.08,135.43)" gradientUnits="userSpaceOnUse"><stop stop-color="#b0d939" offset="0"/><stop stop-color="#eadb04" offset="1"/></linearGradient> <linearGradient id="a" x2="1" gradientTransform="matrix(26.159 -64.737 64.737 26.159 107.42 128.14)" gradientUnits="userSpaceOnUse"><stop stop-color="#74af52" offset="0"/><stop stop-color="#74af52" offset=".17"/><stop stop-color="#99be32" offset=".48"/><stop stop-color="#c0c40a" offset="1"/></linearGradient> </defs> </svg>`;
btoa(HS);
const GS = '<svg viewBox="0 0 509 154" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M665.95 132.73v44.88l-10.56-8.4c-.8-.64-1.2-1.44-1.2-2.4v-32.4c0-6.48-4.12-9.72-12.36-9.72-2.16 0-4.18.4-6.06 1.2-1.88.8-3.54 1.8-4.98 3-1.44 1.2-2.56 2.5-3.36 3.9-.8 1.4-1.2 2.7-1.2 3.9v40.92l-10.68-8.4c-.72-.64-1.08-1.44-1.08-2.4v-53.76l10.92 8.52c.32.24.56.44.72.6.16.16.36.32.6.48.96-1.2 2.14-2.28 3.54-3.24 1.4-.96 2.92-1.76 4.56-2.4 1.64-.64 3.34-1.14 5.1-1.5 1.76-.36 3.44-.54 5.04-.54 1.44 0 2.92.04 4.44.12 1.52.08 2.84.28 3.96.6 4.56 1.12 7.8 3.12 9.72 6 1.92 2.88 2.88 6.56 2.88 11.04ZM732.38 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14ZM795.93 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14ZM858.57 97.21c.64.48.96 1.16.96 2.04v74.88c-.08 1.04-.12 2.12-.12 3.24-1.84-1.52-3.56-2.92-5.16-4.2-1.36-1.12-2.66-2.18-3.9-3.18-1.24-1-2.06-1.66-2.46-1.98-1.76 2.48-4.26 4.44-7.5 5.88-3.24 1.44-7.02 2.16-11.34 2.16-3.84 0-7.4-.7-10.68-2.1-3.28-1.4-6.14-3.44-8.58-6.12-2.44-2.68-4.34-5.94-5.7-9.78-1.36-3.84-2.04-8.16-2.04-12.96 0-4.32.78-8.34 2.34-12.06 1.56-3.72 3.6-6.92 6.12-9.6 2.52-2.68 5.38-4.78 8.58-6.3 3.2-1.52 6.48-2.28 9.84-2.28 2.56 0 4.82.22 6.78.66 1.96.44 3.68 1.06 5.16 1.86s2.78 1.74 3.9 2.82a35.92 35.92 0 0 1 3.12 3.42V88.57l10.68 8.64Zm-27.96 67.92c3.6 0 6.52-.68 8.76-2.04 2.24-1.36 3.98-3.06 5.22-5.1a20.5 20.5 0 0 0 2.58-6.54c.48-2.32.72-4.44.72-6.36v-1.2c0-1.12-.22-2.7-.66-4.74-.44-2.04-1.28-4.06-2.52-6.06s-3-3.7-5.28-5.1c-2.28-1.4-5.22-2.02-8.82-1.86-3.44 0-6.26.74-8.46 2.22-2.2 1.48-3.96 3.26-5.28 5.34-1.32 2.08-2.24 4.2-2.76 6.36-.52 2.16-.78 3.92-.78 5.28 0 1.84.24 3.92.72 6.24.48 2.32 1.36 4.48 2.64 6.48s3.04 3.68 5.28 5.04c2.24 1.36 5.12 2.04 8.64 2.04ZM882.81 97.09c.64.48.96 1.12.96 1.92l-.12 41.04v37.08l-10.56-8.4c-.72-.64-1.08-1.44-1.08-2.4V88.45l10.8 8.64ZM950.36 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14Z" style="fill-rule:nonzero" transform="translate(-452.406 -63.709) scale(1.00797)"/><path d="M79.32 36.98v150.76L95 174.54l6.59-156.31-22.27 18.75Z" style="fill:url(#a);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M79.32 36.98 57.05 18.23l6.59 156.31 15.68 13.2V36.98Z" style="fill:url(#b);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33Z" style="fill:url(#c);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M25.19 104.83 0 90.24l16.97 53.86 16.85 9.77-8.63-49.04Z" style="fill:url(#d);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M43.86 82.5 18.69 67.98 0 90.24l25.18 14.59L43.86 82.5Z" style="fill:#9c3;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m134.82 78.69-9.97 56.5 15.58-9.04L160 64.1l-25.18 14.59Z" style="fill:url(#e);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5Z" style="fill:url(#f);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33L160 64.1Z" style="fill:#ffe113;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M101.59 18.23 79.32 0 57.05 18.23l22.27 18.75 22.27-18.75Z" style="fill:#f3e600;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><defs><linearGradient id="a" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="matrix(.84 -162.96 162.96 .84 89.64 184.81)"><stop offset="0" style="stop-color:#62d399;stop-opacity:1"/><stop offset=".51" style="stop-color:#acd842;stop-opacity:1"/><stop offset=".9" style="stop-color:#d7db0a;stop-opacity:1"/><stop offset="1" style="stop-color:#d7db0a;stop-opacity:1"/></linearGradient><linearGradient id="b" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-90.565 123.412 54.953) scale(162.14)"><stop offset="0" style="stop-color:#0ba398;stop-opacity:1"/><stop offset=".5" style="stop-color:#4ca352;stop-opacity:1"/><stop offset="1" style="stop-color:#76a30a;stop-opacity:1"/></linearGradient><linearGradient id="c" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="scale(-68) rotate(88.4 .881 -1.396)"><stop offset="0" style="stop-color:#36a382;stop-opacity:1"/><stop offset=".19" style="stop-color:#36a382;stop-opacity:1"/><stop offset=".54" style="stop-color:#49a459;stop-opacity:1"/><stop offset="1" style="stop-color:#76a30b;stop-opacity:1"/></linearGradient><linearGradient id="d" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-88 87.255 68.431) scale(62.42)"><stop offset="0" style="stop-color:#267880;stop-opacity:1"/><stop offset=".51" style="stop-color:#457a5c;stop-opacity:1"/><stop offset="1" style="stop-color:#717516;stop-opacity:1"/></linearGradient><linearGradient id="e" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-79.1 149.53 -14.065) scale(73.28)"><stop offset="0" style="stop-color:#b0d939;stop-opacity:1"/><stop offset="1" style="stop-color:#eadb04;stop-opacity:1"/></linearGradient><linearGradient id="f" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-67.997 148.705 -15.558) scale(69.8226)"><stop offset="0" style="stop-color:#74af52;stop-opacity:1"/><stop offset=".17" style="stop-color:#74af52;stop-opacity:1"/><stop offset=".48" style="stop-color:#99be32;stop-opacity:1"/><stop offset="1" style="stop-color:#c0c40a;stop-opacity:1"/></linearGradient></defs></svg>', qS = btoa(GS), XS = "data:image/svg+xml;charset=utf-8;base64," + qS, QS = XS, iy = typeof window !== void 0 ? window.location.search.includes("debugcontext") : !1;
var ce = /* @__PURE__ */ ((s) => (s.ContextRegistered = "ContextRegistered", s.ContextCreationStart = "ContextCreationStart", s.ContextCreated = "ContextCreated", s.ContextFirstFrameRendered = "ContextFirstFrameRendered", s.ContextDestroying = "ContextDestroying", s.ContextDestroyed = "ContextDestroyed", s.MissingCamera = "MissingCamera", s.ContextClearing = "ContextClearing", s.ContextCleared = "ContextCleared", s))(ce || {});
class he {
  /** The currently active (rendering) Needle Engine context */
  static get Current() {
    return globalThis["NeedleEngine.Context.Current"];
  }
  /** @internal */
  static set Current(e) {
    globalThis["NeedleEngine.Context.Current"] = e;
  }
  /** Returns the array of all registered Needle Engine contexts. Do not modify */
  static get All() {
    return this.Registered;
  }
  /** All currently registered Needle Engine contexts. Do not modify */
  static Registered = [];
  /** @internal Internal use only */
  static register(e) {
    this.Registered.indexOf(e) === -1 && (iy && console.warn("Registering context"), this.Registered.push(e), this.dispatchCallback("ContextRegistered", e));
  }
  /** @internal Internal use only */
  static unregister(e) {
    const t = this.Registered.indexOf(e);
    t !== -1 && (iy && console.warn("Unregistering context"), this.Registered.splice(t, 1));
  }
  static _callbacks = {};
  /**
   * Register a callback to be called when the given event occurs
   */
  static registerCallback(e, t) {
    this._callbacks[e] || (this._callbacks[e] = []), this._callbacks[e].push(t);
  }
  /** Unregister a callback */
  static unregisterCallback(e, t) {
    if (!this._callbacks[e]) return;
    const i = this._callbacks[e].indexOf(t);
    i !== -1 && this._callbacks[e].splice(i, 1);
  }
  /** @internal */
  static dispatchCallback(e, t, i) {
    if (!this._callbacks[e]) return !0;
    const n = { event: e, context: t };
    if (i)
      for (const r in i)
        n[r] = i[r];
    const o = new Array();
    return this._callbacks[e].forEach((r) => {
      const a = r(n);
      a instanceof Promise && o.push(a);
    }), Promise.all(o);
  }
  /**
   * Register a callback to be called when a context is created
   */
  static addContextCreatedCallback(e) {
    this.registerCallback("ContextCreated", e);
  }
  /**
   * Register a callback to be called when a context is registered
   */
  static addContextDestroyedCallback(e) {
    this.registerCallback("ContextDestroyed", e);
  }
}
const YS = () => (s) => s;
function ZA(s) {
  return YS()(s);
}
function JA() {
  return !!w("debug");
}
class $i {
  _factory;
  _cache = [];
  _maxSize;
  _index = 0;
  constructor(e, t) {
    this._factory = e, this._maxSize = t;
  }
  get() {
    const e = this._index % this._maxSize;
    return this._index++, this._cache.length <= e && (this._cache[e] = this._factory()), this._cache[e];
  }
}
let No = !1;
const rp = new Array();
typeof window < "u" && setTimeout(() => {
  if (No) {
    const s = {}, e = new URL(window.location.href), t = new URL(e);
    t.searchParams.append("console", "");
    const i = t.toString().replace(/=$|=(?=&)/g, "");
    for (const o of rp) {
      const r = new URL(e);
      r.searchParams.append(o, ""), s[o] = r.toString().replace(/=$|=(?=&)/g, "");
    }
    console.log(
      `🌵 ?help: Debug Options for Needle Engine.
Append any of these parameters to the URL to enable specific debug options.
Example: ${i} will show an onscreen console window.`
    );
    const n = No === !0 ? "" : ` (containing "${No}")`;
    console.group("Available URL parameters:" + n);
    for (const o of Object.keys(s).sort())
      typeof No == "string" && !o.toLowerCase().includes(No.toLowerCase()) || (console.groupCollapsed(o), console.log("Reload with this flag enabled:"), console.log(s[o]), console.groupEnd());
    console.groupEnd();
  }
}, 100);
function Fd() {
  return new URLSearchParams(globalThis.location?.search);
}
function w(s) {
  No && !rp.includes(s) && rp.push(s);
  const e = Fd();
  if (e.has(s)) {
    const t = e.get(s);
    if (t) {
      const i = Number(t);
      return isNaN(i) ? t : i;
    } else return !0;
  }
  return !1;
}
No = w("help");
function eI(s, e) {
  const t = Fd();
  t.has(s) ? t.set(s, e) : t.append(s, e), document.location.search = t.toString();
}
function Yh(s, e, t = !0) {
  const i = Fd();
  i.has(s) ? e === null ? i.delete(s) : i.set(s, e) : e !== null && i.append(s, e), t ? KS(s, i) : Mb(s, i);
}
function ny(s, e, t) {
  s.has(e) ? s.set(e, t.toString()) : s.append(e, t.toString());
}
function KS(s, e, t) {
  window.history.pushState(t, s, "?" + e.toString());
}
function Mb(s, e, t) {
  window.history.replaceState(t, s, "?" + e.toString());
}
function tI(s) {
  for (var e = "", t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", i = t.length, n = 0; n < s; n++)
    e += t.charAt(Math.floor(Math.random() * i));
  return e;
}
function iI(s, e) {
  return Math.floor(Math.random() * (e - s + 1)) + s;
}
const sy = ["smol", "tiny", "giant", "interesting", "smart", "bright", "dull", "extreme", "beautiful", "pretty", "dark", "epic", "salty", "silly", "funny", "lame", "lazy", "loud", "lucky", "mad", "mean", "mighty", "mysterious", "nasty", "odd", "old", "powerful", "quiet", "rapid", "scary", "shiny", "shy", "silly", "smooth", "sour", "spicy", "stupid", "sweet", "tasty", "terrible", "ugly", "unusual", "vast", "wet", "wild", "witty", "wrong", "zany", "zealous", "zippy", "zombie", "zorro"], oy = ["cat", "dog", "mouse", "pig", "cow", "horse", "sheep", "chicken", "duck", "goat", "panda", "tiger", "lion", "elephant", "monkey", "bird", "fish", "snake", "frog", "turtle", "hamster", "penguin", "kangaroo", "whale", "dolphin", "crocodile", "snail", "ant", "bee", "beetle", "butterfly", "dragon", "eagle", "fish", "giraffe", "lizard", "panda", "penguin", "rabbit", "snake", "spider", "tiger", "zebra"];
function ZS() {
  const s = sy[Math.floor(Math.random() * sy.length)], e = oy[Math.floor(Math.random() * oy.length)];
  return s + "_" + e;
}
function JS(s) {
  return s = s.replace(/[^a-z0-9áéíóúñü \.,_-]/gim, ""), s.trim();
}
function ec(s, e, t = !0, i = !1) {
  if (e == null) return null;
  if (e.userData && e.userData.guid === s) return e;
  if (e.guid == s) return e;
  if (i && e.userData?.components) {
    for (const n of e.userData.components)
      if (n.guid === s) return n;
  }
  if (t) {
    if (e.scenes)
      for (const n in e.scenes) {
        const o = e.scenes[n], r = ec(s, o, t, i);
        if (r) return r;
      }
    if (e.children)
      for (const n in e.children) {
        const o = e.children[n], r = ec(s, o, t, i);
        if (r) return r;
      }
  }
}
function zd(s, e) {
  if (s != null && typeof s == "object") {
    let t;
    Array.isArray(s) ? t = [] : (t = Object.create(s), Object.assign(t, s));
    for (const i of Object.keys(s)) {
      const n = s[i];
      e && !e(s, i, n) ? t[i] = n : n?.clone !== void 0 && typeof n.clone == "function" ? t[i] = n.clone() : t[i] = zd(n, e);
    }
    return t;
  }
  return s;
}
function Os(s) {
  return new Promise((e, t) => {
    setTimeout(e, s);
  });
}
function Ud(s, e) {
  if (s <= 0) return Promise.resolve();
  if (e || (e = he.Current), !e) return Promise.reject("No context");
  const t = e.time.frameCount + s;
  return new Promise((i, n) => {
    if (!e) return n("No context");
    const o = () => {
      e.time.frameCount >= t && (e.pre_update_callbacks.splice(e.pre_update_callbacks.indexOf(o), 1), i());
    };
    e.pre_update_callbacks.push(o);
  });
}
const Hc = w("debugresolveurl"), eC = "rel:";
function nI(s, e) {
  return fr(s, e);
}
function fr(s, e) {
  if (e === void 0)
    return Hc && console.warn("getPath: uri is undefined, returning uri", e), e;
  if (e.startsWith("./"))
    return e;
  if (e.startsWith("http"))
    return Hc && console.warn("getPath: uri is absolute, returning uri", e), e;
  if (s === void 0)
    return Hc && console.warn("getPath: source is undefined, returning uri", e), e;
  e.startsWith(eC) && (e = e.substring(4));
  const t = s.lastIndexOf("/");
  if (t >= 0) {
    const i = s.substring(0, t + 1);
    for (; i.endsWith("/") && e.startsWith("/"); ) e = e.substring(1);
    const n = i + e;
    return Hc && console.log("source:", s, `changed uri 
from`, e, `
to `, n, `
basePath: ` + i), n;
  }
  return e;
}
class tC {
  subscribeWrite(e) {
    this.writeCallbacks.push(e);
  }
  unsubscribeWrite(e) {
    const t = this.writeCallbacks.indexOf(e);
    t !== -1 && this.writeCallbacks.splice(t, 1);
  }
  writeCallbacks = [];
  constructor(e, t) {
    this._object = e, this._prop = t, this._wrapperProp = Symbol("$" + t), this.apply();
  }
  _applied = !1;
  _object;
  _prop;
  _wrapperProp;
  apply() {
    if (this._applied || !this._object) return;
    const e = this._object, t = this._prop;
    if (e[t] === void 0) return;
    this._applied = !0, e[this._wrapperProp] !== void 0 && console.warn("Watcher is being applied to an object that already has a wrapper property. This is not (yet) supported");
    const i = e[t];
    e[this._wrapperProp] = i, Object.defineProperty(e, t, {
      get: () => e[this._wrapperProp],
      set: (r) => {
        e[this._wrapperProp] = r;
        for (const a of this.writeCallbacks)
          a(r, this._prop);
      }
    });
  }
  revoke() {
    if (!this._applied || !this._object) return;
    this._applied = !1;
    const e = this._object, t = this._prop;
    Reflect.deleteProperty(e, t);
    const i = e[this._wrapperProp];
    e[t] = i, Reflect.deleteProperty(e, this._wrapperProp);
  }
  dispose() {
    this.revoke(), this.writeCallbacks.length = 0, this._object = null;
  }
}
class so {
  _watches = [];
  constructor(e, t) {
    if (Array.isArray(t))
      for (const i of t)
        this._watches.push(new so(e, i));
    else
      this._watches.push(new tC(e, t));
  }
  subscribeWrite(e) {
    for (const t of this._watches)
      t.subscribeWrite(e);
  }
  unsubscribeWrite(e) {
    for (const t of this._watches)
      t.unsubscribeWrite(e);
  }
  apply() {
    for (const e of this._watches)
      e.apply();
  }
  revoke() {
    for (const e of this._watches)
      e.revoke();
  }
  dispose() {
    for (const e of this._watches)
      e.dispose();
    this._watches.length = 0;
  }
}
const jr = Symbol("needle:watches");
function bm(s, e) {
  if (!s[jr])
    if (s instanceof J)
      s[jr] = new so(s, ["x", "y"]);
    else if (s instanceof b)
      s[jr] = new so(s, ["x", "y", "z"]);
    else if (s instanceof de || s instanceof $)
      s[jr] = new so(s, ["x", "y", "z", "w"]);
    else
      return !1;
  return s[jr].subscribeWrite(e), !0;
}
function Rb(s, e) {
  if (!s) return;
  const t = s[jr];
  t && t.unsubscribeWrite(e);
}
var X;
((s) => {
  let e;
  function t() {
    if (e !== void 0) return e;
    const W = window.navigator.userAgent, ne = /Windows|MacOS|Mac OS/.test(W), re = /Windows NT/.test(W) && /Edg/.test(W) && !/Win64/.test(W);
    return e = ne && !re && !y();
  }
  s.isDesktop = t;
  let i;
  function n() {
    return i !== void 0 ? i : typeof window.orientation < "u" || navigator.userAgent.indexOf("IEMobile") !== -1 ? i = !0 : i = /iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent);
  }
  s.isMobileDevice = n;
  function o() {
    return a();
  }
  s.isIPad = o;
  let r;
  function a() {
    return r !== void 0 ? r : r = /iPad/.test(navigator.userAgent);
  }
  s.isiPad = a;
  let l;
  function c() {
    return l !== void 0 ? l : l = /Android/.test(navigator.userAgent);
  }
  s.isAndroidDevice = c;
  let h;
  function d() {
    return h !== void 0 ? h : h = /WebXRViewer\//i.test(navigator.userAgent);
  }
  s.isMozillaXR = d;
  let f;
  function p() {
    if (f !== void 0) return f;
    if (navigator.userAgentData)
      return f = navigator.userAgentData.platform === "macOS";
    {
      const W = navigator.userAgent.toLowerCase();
      return f = W.includes("mac os x") || W.includes("macintosh");
    }
  }
  s.isMacOS = p;
  let g;
  function _() {
    return g !== void 0 ? g : g = p() && "xr" in navigator;
  }
  s.isVisionOS = _;
  let m;
  const v = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"];
  function y() {
    return m !== void 0 ? m : m = v.includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  s.isiOS = y;
  let x;
  function I() {
    return x !== void 0 || (x = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), x;
  }
  s.isSafari = I;
  let O;
  function k() {
    return O !== void 0 ? O : O = navigator.userAgent.includes("OculusBrowser");
  }
  s.isQuest = k;
  let E;
  function z() {
    return E !== void 0 || (E = document.createElement("a").relList.supports("ar")), E;
  }
  s.supportsQuickLookAR = z;
  async function D() {
    try {
      return (await navigator.permissions.query({ name: "microphone" })).state !== "denied";
    } catch (W) {
      return console.error("Error querying `microphone` permissions.", W), !1;
    }
  }
  s.microphonePermissionsGranted = D;
  let V;
  function q() {
    if (V !== void 0) return V;
    const W = navigator.userAgent.match(/iPhone OS (\d+_\d+)/);
    if (W && (V = W[1].replace("_", ".")), !V) {
      const ne = navigator.userAgent.match(/(?:\(Macintosh;|iPhone;|iPad;).*Version\/(\d+\.\d+)/);
      ne && (V = ne[1]);
    }
    return V || (V = null), V;
  }
  s.getiOSVersion = q;
  let A;
  function U() {
    if (A !== void 0) return A;
    const W = navigator.userAgent.match(/(?:CriOS|Chrome)\/(\d+\.\d+\.\d+\.\d+)/);
    return W ? A = W[1].replace("_", ".") : A = null, A;
  }
  s.getChromeVersion = U;
})(X || (X = {}));
function sI() {
  return X.isDesktop();
}
function oI() {
  return X.isMobileDevice();
}
function rI() {
  return X.isiPad();
}
function aI() {
  return X.isiPad();
}
function lI() {
  return X.isAndroidDevice();
}
function cI() {
  return X.isMozillaXR();
}
function hI() {
  return X.isMacOS();
}
function dI() {
  return X.isiOS();
}
function uI() {
  return X.isSafari();
}
function fI() {
  return X.isQuest();
}
async function pI() {
  return X.microphonePermissionsGranted();
}
const Zs = /* @__PURE__ */ new WeakMap();
function iC(s, e, t) {
  if (!Zs.get(s)) {
    const n = new MutationObserver((o) => {
      sC(s, o);
    });
    Zs.set(s, {
      observer: n,
      attributeChangedListeners: /* @__PURE__ */ new Map()
    }), n.observe(s, { attributes: !0 });
  }
  const i = Zs.get(s).attributeChangedListeners;
  i.has(e) || i.set(e, []), i.get(e).push(t);
}
function nC(s, e, t) {
  if (!Zs.get(s)) return;
  const i = Zs.get(s).attributeChangedListeners;
  if (!i.has(e)) return;
  const n = i.get(e), o = n.indexOf(t);
  o !== -1 && (n.splice(o, 1), n.length <= 0 && (i.delete(e), Zs.get(s)?.observer.disconnect(), Zs.delete(s)));
}
function sC(s, e) {
  const t = Zs.get(s).attributeChangedListeners;
  for (const i of e)
    if (i.type === "attributes") {
      const n = i.attributeName, o = s.getAttribute(n);
      if (t.has(n))
        for (const r of t.get(n))
          r(o);
    }
}
class ry {
  reason;
  constructor(e) {
    this.reason = e;
  }
}
async function Tb(s) {
  const e = await Promise.allSettled(s).catch((n) => [
    new ry(n.message)
  ]);
  let t = !1;
  const i = e.map((n) => "value" in n ? n.value : (t = !0, new ry(n.reason)));
  return {
    anyFailed: t,
    results: i
  };
}
async function oC(s) {
  if (!globalThis.QRCode) {
    const l = "https://cdn.jsdelivr.net/gh/davidshimjs/qrcodejs@gh-pages/qrcode.min.js";
    let c = document.head.querySelector(`script[src="${l}"]`);
    c || (c = document.createElement("script"), c.src = l, document.head.appendChild(c)), await new Promise((h, d) => {
      c.addEventListener("load", () => {
        h(!0);
      });
    });
  }
  const e = globalThis.QRCode, t = s.domElement ?? document.createElement("div"), i = new e(t, {
    width: s.width ?? 256,
    height: s.height ?? 256,
    colorDark: "#000000",
    colorLight: "#ffffff",
    correctLevel: s.showLogo ? e.CorrectionLevel.H : e.CorrectLevel.M,
    ...s
  }), n = i?._oQRCode.moduleCount || 0, o = i?._oDrawing?._elCanvas;
  let r = 0.25;
  n < 40 ? r = Math.floor(n / 4) / n : r = Math.floor(n / 6) / n;
  const a = Math.floor(n / 20) / n;
  try {
    const l = await rC(o, { showLogo: s.showLogo, logoSize: r, logoPadding: a }).catch((c) => {
    });
    l && (t.innerHTML = "", t.append(l));
  } catch {
  }
  if (s.showUrl !== !1 && s.text) {
    const l = t.querySelector(".qr-code-link-label");
    let c = s.text.replace(/^(https?:\/\/)?(www\.)?/, "").replace(/\/+$/, "").replace(/\?+$/, "");
    if (c = "Scan to visit " + c, l)
      l.textContent = c;
    else {
      const h = document.createElement("div");
      h.classList.add("qr-code-link-label"), s.text = c, h.textContent = s.text, h.addEventListener("click", (d) => {
        d.stopImmediatePropagation();
      }), h.style.textAlign = "center", h.style.fontSize = "0.8em", h.style.marginTop = "0.1em", h.style.color = "#000000", h.style.fontFamily = "'Roboto Flex', sans-serif", h.style.opacity = "0.5", h.style.wordBreak = "break-all", h.style.wordWrap = "break-word", h.style.marginBottom = "0.3em", t.style.width = "calc(210px + 20px)", t.appendChild(h);
    }
  }
  return t;
}
async function rC(s, e) {
  if (!s) return;
  const t = 8, i = 20, n = e.logoPadding || 1 / 32, o = "transparent", r = 0, a = new Image(), c = document.querySelector("needle-engine")?.getAttribute("loading-logo-src") || kb;
  if (!c) return;
  let h = !1;
  e.showLogo !== !1 && (a.src = c, h = await new Promise((y, x) => {
    a.onload = () => y(!0), a.onerror = (I) => {
      console.error("Error loading favicon image for QR code", I), y(!1);
    };
  }));
  const d = document.createElement("canvas");
  d.width = s.width + t, d.height = s.height + t;
  const f = d.getContext("2d");
  if (!f)
    return;
  f.fillStyle = "#ffffff", f.fillRect(0, 0, d.width, d.height), f.drawImage(s, t / 2, t / 2), f.imageSmoothingEnabled = !0, f.imageSmoothingQuality = "high", f.mozImageSmoothingEnabled = !0, f.webkitImageSmoothingEnabled = !0, f.globalCompositeOperation = "lighten";
  const p = f.createLinearGradient(0, 0, 0, d.height);
  p.addColorStop(0, "rgb(45, 45, 45)"), p.addColorStop(1, "rgb(45, 45, 45)"), f.fillStyle = p, f.fillRect(0, 0, d.width, d.height), f.globalCompositeOperation = "source-over";
  let g = Math.min(s.width, s.height) * (e.logoSize || 0.25), _ = g;
  if (h) {
    const y = a.width / a.height;
    y > 1 ? _ = g / y : g = _ * y;
    const x = n * s.width, I = Math.max(g, _), O = Math.round(I + x), k = Math.round(I + x), E = (d.width - I) / 2, z = (d.height - I) / 2;
    f.shadowColor = o, f.shadowBlur = i;
    const D = r, V = Math.round(E - x / 2), q = Math.round(z - x / 2);
    f.beginPath(), f.moveTo(V + D, q), f.lineTo(V + O - D, q), f.quadraticCurveTo(V + O, q, V + O, q + D), f.lineTo(V + O, q + k - D), f.quadraticCurveTo(V + O, q + k, V + O - D, q + k), f.lineTo(V + D, q + k), f.quadraticCurveTo(V, q + k, V, q + k - D), f.lineTo(V, q + D), f.quadraticCurveTo(V, q, V + D, q), f.fillStyle = "#ffffff", f.closePath(), f.fill(), f.clip(), f.shadowColor = "transparent";
    const A = (d.width - g) / 2, U = (d.height - _) / 2;
    f.drawImage(a, A, U, g, _);
  }
  const m = d.toDataURL("image/png"), v = document.createElement("img");
  return v.src = m, v.style.width = "100%", v.style.height = "auto", v;
}
const aC = w("debugdebug");
let vm = !1;
(w("noerrors") || w("nooverlaymessages")) && (vm = !0);
const Xu = "needle_engine_global_error_container";
var Ui = /* @__PURE__ */ ((s) => (s[s.Log = 0] = "Log", s[s.Warn = 1] = "Warn", s[s.Error = 2] = "Error", s))(Ui || {});
function Eb() {
  return Ib;
}
const ap = new Array();
function lC(s) {
  ap.push(s);
}
let Qu = !1;
function cC(...s) {
  if (!Qu) {
    Qu = !0;
    try {
      for (let e = 0; e < ap.length; e++)
        ap[e](...s);
    } catch (e) {
      console.error(e);
    }
    Qu = !1;
  }
}
const Ab = console.error, hC = function(...s) {
  Ab.apply(console, s), fC(s), Go(2, s), uC(...s);
};
function dC(s) {
  vm = !s, s ? console.error = hC : console.error = Ab;
}
function mI(s) {
  return dC(s);
}
let Ib = 0;
function uC(...s) {
  Ib += 1, cC(...s);
}
function fC(s) {
  if (Array.isArray(s))
    for (let e = 0; e < s.length; e++) {
      const t = s[e];
      typeof t == "string" && t.startsWith("THREE.PropertyBinding: Trying to update node for track:") && (s[e] = "Some animated objects couldn't be found: see console for details");
    }
}
function Go(s, e, t, i) {
  if (vm) return;
  const o = he.Current?.domElement ?? document.querySelector("needle-engine");
  if (o) {
    if (Array.isArray(e)) {
      let r = "";
      for (let a = 0; a < e.length; a++) {
        let l = e[a];
        l instanceof Error && (l = l.message), typeof l != "object" && (a > 0 && (r += " "), r += l);
      }
      e = r;
    }
    !e || e.length <= 0 || pC(s, o, e);
  }
}
const jl = /* @__PURE__ */ new Map();
function pC(s, e, t) {
  if (t == null) return;
  const i = gC(e);
  if (i.childElementCount >= 20) {
    const a = i.lastElementChild;
    ay(a);
  }
  t.length > 400 && (t = t.substring(0, 400) + "...");
  const n = t;
  if (jl.has(n))
    return;
  const o = yC(s, t);
  i.prepend(o);
  const r = () => {
    jl.delete(n), ay(o);
  };
  jl.set(n, r), setTimeout(r, 1e4);
}
function gI() {
  aC && console.log("Clearing messages");
  for (const s of jl.values())
    s?.call(s);
  jl.clear();
}
const mC = `

@import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

div[data-needle_engine_debug_overlay] {
    font-family: 'Roboto Flex', sans-serif;
    font-weight: 400;
    font-size: 16px;
}

div[data-needle_engine_debug_overlay] strong {
    font-weight: 700;
}

div[data-needle_engine_debug_overlay] a {
    color: white;
    text-decoration: none;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

div[data-needle_engine_debug_overlay] a:hover {
    text-decoration: none;
    border: none;
}

div[data-needle_engine_debug_overlay] .log strong {
    color: rgba(200,200,200,.9);
}

div[data-needle_engine_debug_overlay] .warn strong {
    color: rgba(255,255,230, 1);
}

div[data-needle_engine_debug_overlay] .error strong {
    color: rgba(255,100,120, 1);
}
`;
function gC(s) {
  globalThis[Xu] || (globalThis[Xu] = /* @__PURE__ */ new Map());
  const e = globalThis[Xu];
  if (e.has(s))
    return e.get(s);
  {
    const t = document.createElement("div");
    e.set(s, t), t.setAttribute("data-needle_engine_debug_overlay", ""), t.classList.add("debug-container"), t.style.cssText = `
            position: absolute;
            top: 0;
            right: 5px;
            padding-top: 0px;
            max-width: 70%;
            max-height: calc(100% - 5px);
            z-index: 9999999999;
            pointer-events: scroll;
            display: flex;
            align-items: end;
            flex-direction: column;
            color: white;
            overflow: auto;
            word-break: break-word;
        `, s.shadowRoot ? s.shadowRoot.appendChild(t) : s.appendChild(t);
    const i = document.createElement("style");
    return i.innerHTML = mC, t.appendChild(i), t;
  }
}
const Lb = Symbol("logtype"), Kh = /* @__PURE__ */ new Map();
function ay(s) {
  s.remove();
  const e = s[Lb], t = Kh.get(e) ?? [];
  t.push(s), Kh.set(e, t);
}
function yC(s, e) {
  if (Kh.has(s)) {
    const i = Kh.get(s);
    if (i.length > 0) {
      const n = i.pop();
      return n.innerHTML = e, n;
    }
  }
  const t = document.createElement("div");
  switch (t.setAttribute("data-id", "__needle_engine_debug_overlay"), t.style.marginRight = "5px", t.style.padding = ".5em", t.style.backgroundColor = "rgba(0,0,0,.9)", t.style.marginTop = "5px", t.style.marginBottom = "3px", t.style.borderRadius = "8px", t.style.pointerEvents = "all", t.style.userSelect = "text", t.style.maxWidth = "250px", t.style.whiteSpace = "pre-wrap", t.style["backdrop-filter"] = "blur(10px)", t.style["-webkit-backdrop-filter"] = "blur(10px)", t.style.backgroundColor = "rgba(20,20,20,.8)", t.style.boxShadow = "inset 0 0 80px rgba(0,0,0,.2), 0 0 5px rgba(0,0,0,.2)", t.style.border = "1px solid rgba(160,160,160,.2)", t[Lb] = s, s) {
    case 0:
      t.classList.add("log"), t.style.color = "rgba(200,200,200,.7)", t.style.backgroundColor = "rgba(40,40,40,.7)";
      break;
    case 1:
      t.classList.add("warn"), t.style.color = "rgb(255, 255, 150)", t.style.backgroundColor = "rgba(50,50,20,.8)";
      break;
    case 2:
      t.classList.add("error"), t.style.color = "rgb(255, 50, 50", t.style.backgroundColor = "rgba(50,20,20,.8)";
      break;
  }
  return t.title = "Open the browser console (F12) for more information", t.innerHTML = e, t;
}
class _C {
  random(e, t) {
    return Array.isArray(e) ? e.length <= 0 ? null : e[Math.floor(Math.random() * e.length)] : e !== void 0 && t !== void 0 ? Math.random() * (t - e) + e : Math.random();
  }
  randomVector3(e, t = 0, i = 1) {
    e.x = this.random(t, i), e.y = this.random(t, i), e.z = this.random(t, i);
  }
  clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  clamp01(e) {
    return this.clamp(e, 0, 1);
  }
  /**
   * Linear interpolate
   */
  lerp(e, t, i) {
    return i = i < 0 ? 0 : i, i = i > 1 ? 1 : i, e + (t - e) * i;
  }
  /**
   * 
   */
  inverseLerp(e, t, i) {
    return (i - e) / (t - e);
  }
  /**
   * Remaps a value from one range to another.
   * @param value The value to remap.
   * @param min1 The minimum value of the current range.
   * @param max1 The maximum value of the current range.
   * @param min2 The minimum value of the target range.
   * @param max2 The maximum value of the target range.
   */
  remap(e, t, i, n, o) {
    return n + (o - n) * (e - t) / (i - t);
  }
  moveTowards(e, t, i) {
    return e += i, (i < 0 && e < t || i > 0 && e > t) && (e = t), e;
  }
  Rad2Deg = 180 / Math.PI;
  Deg2Rad = Math.PI / 180;
  Epsilon = 1e-5;
  /**
   * Converts radians to degrees
   */
  toDegrees(e) {
    return e * 180 / Math.PI;
  }
  /**
   * Converts degrees to radians
   */
  toRadians(e) {
    return e * Math.PI / 180;
  }
  tan(e) {
    return Math.tan(e);
  }
  gammaToLinear(e) {
    return Math.pow(e, 2.2);
  }
  linearToGamma(e) {
    return Math.pow(e, 1 / 2.2);
  }
  approximately(e, t, i = Number.EPSILON) {
    for (const n of bC) {
      const o = e[n], r = t[n];
      if (o === void 0 || r === void 0) break;
      if (Math.abs(o - r) > i)
        return !1;
    }
    return !0;
  }
  easeInOutCubic(e) {
    return e < 0.5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2;
  }
}
const bC = ["x", "y", "z", "w"], j = new _C();
class ly {
  y;
  s;
  alpha = 0;
  constructor(e) {
    this.setAlpha(e), this.y = null, this.s = null;
  }
  setAlpha(e) {
    if (e <= 0 || e > 1)
      throw new Error();
    this.alpha = e;
  }
  filter(e, t) {
    t && this.setAlpha(t);
    let i;
    return this.y ? i = this.alpha * e + (1 - this.alpha) * this.s : i = e, this.y = e, this.s = i, i;
  }
  lastValue() {
    return this.y;
  }
  reset(e) {
    this.y = e, this.s = e;
  }
}
class Yu {
  /**
   * An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   */
  freq;
  /**
   * Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   */
  minCutOff;
  /**
   * Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   */
  beta;
  /**
   * Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  dCutOff;
  /**
   * The low-pass filter for the signal.
   */
  x;
  /**
   * The low-pass filter for the derivates.
   */
  dx;
  /**
   * The last time the filter was called.
   */
  lasttime;
  /** Create a new OneEuroFilter
   * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  constructor(e, t = 1, i = 0, n = 1) {
    if (e <= 0 || t <= 0 || n <= 0)
      throw new Error();
    this.freq = e, this.minCutOff = t, this.beta = i, this.dCutOff = n, this.x = new ly(this.alpha(this.minCutOff)), this.dx = new ly(this.alpha(this.dCutOff)), this.lasttime = null;
  }
  alpha(e) {
    const t = 1 / this.freq;
    return 1 / (1 + 1 / (2 * Math.PI * e) / t);
  }
  /** Filter your value: call with your value and the current timestamp (e.g. from this.context.time.time) */
  filter(e, t = null) {
    this.lasttime && t && (this.freq = 1 / (t - this.lasttime)), this.lasttime = t;
    const i = this.x.lastValue(), n = i ? (e - i) * this.freq : 0, o = this.dx.filter(n, this.alpha(this.dCutOff)), r = this.minCutOff + this.beta * Math.abs(o);
    return this.x.filter(e, this.alpha(r));
  }
  reset(e) {
    e != null && this.x.reset(e), this.x.alpha = this.alpha(this.minCutOff), this.dx.alpha = this.alpha(this.dCutOff), this.lasttime = null;
  }
}
class Db {
  x;
  y;
  z;
  /** Create a new OneEuroFilter
   * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  constructor(e, t = 1, i = 0, n = 1) {
    this.x = new Yu(e, t, i, n), this.y = new Yu(e, t, i, n), this.z = new Yu(e, t, i, n);
  }
  filter(e, t, i = null) {
    t.x = this.x.filter(e.x, i), t.y = this.y.filter(e.y, i), t.z = this.z.filter(e.z, i);
  }
  reset(e) {
    this.x.reset(e?.x), this.y.reset(e?.y), this.z.reset(e?.z);
  }
}
const kh = "needle:cameraController";
function vC(s) {
  return s[kh];
}
function cy(s, e, t) {
  t ? s[kh] = e : s[kh] === e && (s[kh] = null);
}
const lp = "needle:autofit";
function wC(s) {
  return s[lp] === void 0 ? !0 : s[lp] !== !1;
}
function cp(s, e) {
  s[lp] = e;
}
let Qn;
const xC = { x: 0, y: 0, width: 0, height: 0 };
function SC(s, e, t, i) {
  s instanceof Element && (s = s.getBoundingClientRect()), Qn = i.domElement.getBoundingClientRect();
  const n = xC;
  n.x = s.x, n.y = s.y, n.width = s.width, n.height = s.height, n.x -= Qn.x, n.y -= Qn.y;
  const o = n.width / -2 - (n.x - Qn.width / 2), r = n.height / -2 - (n.y - Qn.height / 2), a = t.view;
  let l = a?.offsetX || 0, c = a?.offsetY || 0;
  l = j.lerp(l, o, e), c = j.lerp(c, r, e), t.setViewOffset(Qn.width, Qn.height, l, c, Qn.width, Qn.height), t.updateProjectionMatrix();
}
function yI(s, e, t) {
  const i = s.length(), n = e.length(), o = j.lerp(i, n, t);
  return s.lerp(e, t).normalize().multiplyScalar(o);
}
const Ku = new $(), jb = new $().setFromAxisAngle(new b(0, 1, 0), Math.PI);
function _I(s, e) {
  s.lookAt(e), s.quaternion.multiply(jb);
}
function Nd(s, e, t = !0, i = !1) {
  if (s === e) return;
  Ku.copy(s.quaternion);
  const n = Z(e), o = Z(s);
  if (i) {
    if (an(s, be(e)), t) {
      const r = o.y, a = o.sub(AC(s));
      a.y = r, s.lookAt(a), s.quaternion.multiply(jb);
    }
    Number.isNaN(s.quaternion.x) && s.quaternion.copy(Ku);
    return;
  }
  t && (n.y = o.y), s.lookAt(n), Number.isNaN(s.quaternion.x) && s.quaternion.copy(Ku);
}
function bI(s, e, t, i = 1) {
  if (t) {
    const n = G(0, 0, 0), o = e.x / window.innerWidth * 2 - 1, r = -(e.y / window.innerHeight) * 2 + 1;
    n.set(
      o,
      r,
      0
    ), n.unproject(t);
    const a = t.worldPosition, l = s.worldPosition.distanceTo(a), c = n.sub(a);
    c.multiplyScalar(i * 3.6 * l);
    const h = t.worldPosition.add(c);
    return s.lookAt(h), h;
  }
  return null;
}
const CC = new $i(() => new b(), 100);
function G(s, e, t) {
  const i = CC.get();
  return i.set(0, 0, 0), s instanceof b ? i.copy(s) : Array.isArray(s) ? i.set(s[0], s[1], s[2]) : s instanceof DOMPointReadOnly ? i.set(s.x, s.y, s.z) : typeof s == "number" ? (i.x = s, i.y = e !== void 0 ? e : i.x, i.z = t !== void 0 ? t : i.x) : typeof s == "object" && (i.x = s.x, i.y = s.y, i.z = s.z), i;
}
const PC = new $i(() => new se(), 30);
function OC(s) {
  const e = PC.get();
  return s ? e.copy(s) : e.set(0, 0, 0), e;
}
const kC = new $i(() => new $(), 100);
function bn(s) {
  const e = kC.get();
  return e.identity(), s instanceof $ ? e.copy(s) : s instanceof DOMPointReadOnly && e.set(s.x, s.y, s.z, s.w), e;
}
const wm = new $i(() => new b(), 100), hy = Symbol("lastMatrixWorldUpdateKey");
function Z(s, e = null, t = !0) {
  const i = e ?? wm.get();
  return s ? s.parent ? (t && s.updateWorldMatrix(!0, !1), s.matrixWorldNeedsUpdate && s[hy] !== Date.now() && (s[hy] = Date.now(), s.updateMatrixWorld()), i.setFromMatrixPosition(s.matrixWorld), i) : i.copy(s.position) : i.set(0, 0, 0);
}
function ut(s, e) {
  if (!s) return s;
  const t = wm.get();
  return e !== t && t.copy(e), (s?.parent ?? s).worldToLocal(t), s.position.set(t.x, t.y, t.z), s;
}
function ua(s, e, t, i) {
  const n = wm.get();
  return n.set(e, t, i), ut(s, n), s;
}
const Zh = new $i(() => new $(), 100), Xo = new $(), Zu = new $();
function be(s, e = null) {
  if (!s) return Zh.get().identity();
  const t = e ?? Zh.get();
  return s.parent ? (s.getWorldQuaternion(t), t) : t.copy(s.quaternion);
}
function an(s, e) {
  if (!s) return;
  e !== Xo && Xo.copy(e);
  const t = Xo;
  s?.parent?.getWorldQuaternion(Zu), Zu.invert();
  const n = Zu.multiply(t);
  s.quaternion.set(n.x, n.y, n.z, n.w);
}
function Bb(s, e, t, i, n) {
  Xo.set(e, t, i, n), an(s, Xo);
}
const MC = new $i(() => new b(), 100), RC = new b();
function $e(s, e = null) {
  return e || (e = MC.get()), s ? s.parent ? (s.getWorldScale(e), e) : e.copy(s.scale) : e.set(0, 0, 0);
}
function tc(s, e) {
  if (!s) return;
  if (!s.parent) {
    s.scale.copy(e);
    return;
  }
  const t = RC;
  s.parent.getWorldScale(t), s.scale.copy(e), s.scale.divide(t);
}
const TC = new b(), dy = new $();
function vI(s) {
  return be(s, dy), TC.set(0, 0, 1).applyQuaternion(dy);
}
const EC = new $i(() => new b(), 100), uy = new $();
function AC(s, e) {
  return e || (e = EC.get().set(0, 0, 1)), be(s, uy), e.applyQuaternion(uy);
}
const fy = new Rt(), py = new Rt(), IC = new b();
function Fb(s) {
  const e = Zh.get();
  return s.getWorldQuaternion(e), py.setFromQuaternion(e), py;
}
function zb(s, e) {
  const t = Zh.get();
  an(s, t.setFromEuler(e));
}
function xm(s) {
  const e = Fb(s), t = IC;
  return t.set(e.x, e.y, e.z), t.x = j.toDegrees(t.x), t.y = j.toDegrees(t.y), t.z = j.toDegrees(t.z), t;
}
function LC(s, e) {
  $d(s, e.x, e.y, e.z, !0);
}
function $d(s, e, t, i, n = !0) {
  n && (e = j.toRadians(e), t = j.toRadians(t), i = j.toRadians(i)), fy.set(e, t, i), Xo.setFromEuler(fy), an(s, Xo);
}
function hp(s, e = !0) {
  s && (e ? (function t(i) {
    console.groupCollapsed((i.name ? i.name : "(no name : " + i.type + ")") + " %o", i), i.children.forEach(t), console.groupEnd();
  })(s) : s.traverse(function(t) {
    for (var i = "|___", n = t; n.parent !== null; )
      i = "	" + i, n = n.parent;
    console.log(i + t.name + " <" + t.type + ">");
  }));
}
function wI(s) {
  let e = s?.name || "";
  if (!s) return e;
  let t = s.parent;
  for (; t; )
    e = t.name + "/" + e, t = t.parent;
  return e;
}
function DC(s) {
  if (s) {
    const e = s;
    return e.blendMode !== void 0 && e.clampWhenFinished !== void 0 && e.enabled !== void 0 && e.fadeIn !== void 0 && e.getClip !== void 0;
  }
  return !1;
}
class Jh extends Ln {
  static vertex = `
varying vec2 vUv;
void main(){
    vUv = uv;
    gl_Position = vec4(position.xy, 0., 1.0);
}`;
  constructor() {
    super({
      vertexShader: Jh.vertex,
      uniforms: {
        map: new zi(null),
        flipY: new zi(!0),
        writeDepth: new zi(!1),
        depthTexture: new zi(null)
      },
      fragmentShader: `
uniform sampler2D map;
uniform bool flipY;
uniform bool writeDepth;
uniform sampler2D depthTexture;

varying vec2 vUv;

void main(){ 
    vec2 uv = vUv;
    if (flipY) uv.y = 1.0 - uv.y;
    gl_FragColor = texture2D(map, uv);

    if (writeDepth) {
        float depth = texture2D(depthTexture, uv).r;
        gl_FragDepth = depth;

        // float linearDepth = (depth - 0.99) * 100.0; // Enhance near 1.0 values
        // gl_FragColor = vec4(linearDepth, linearDepth, linearDepth, 1.0);
    }
}`
    });
  }
  reset() {
    this.uniforms.map.value = null, this.uniforms.flipY.value = !0, this.uniforms.writeDepth.value = !1, this.uniforms.depthTexture.value = null, this.needsUpdate = !0, this.uniformsNeedUpdate = !0;
  }
}
class sr {
  static planeGeometry = new Un(2, 2, 1, 1);
  static renderer = new ur({ antialias: !1, alpha: !0 });
  static perspectiveCam = new pe();
  static orthographicCam = new Td();
  static scene = new gi();
  static blitMaterial = new Jh();
  static mesh = new H(sr.planeGeometry, sr.blitMaterial);
  /** 
   * Copy a texture to a new texture
   * @param texture the texture to copy
   * @param blitMaterial the material to use for copying (optional)
   * @returns the newly created, copied texture
  */
  static copyTexture(e, t) {
    t || (t = this.blitMaterial), this.blitMaterial.reset();
    const i = t || this.blitMaterial;
    i.uniforms.map.value = e, i.needsUpdate = !0, i.uniformsNeedUpdate = !0;
    const n = i.vertexShader;
    i.vertexShader = Jh.vertex;
    const o = this.mesh;
    o.material = i, o.frustumCulled = !1, this.scene.children.length = 0, this.scene.add(o), this.renderer.setSize(e.image.width, e.image.height), this.renderer.clear(), this.renderer.render(this.scene, this.perspectiveCam);
    const r = new Te(this.renderer.domElement);
    return r.name = "Copy", r.needsUpdate = !0, i.vertexShader = n, r;
  }
  static blit(e, t, i) {
    const {
      renderer: n = this.renderer,
      blitMaterial: o = this.blitMaterial,
      flipY: r = !1,
      depthTexture: a = null,
      depthTest: l = !0,
      depthWrite: c = !0
    } = i || {};
    this.blitMaterial.reset(), o.uniforms.map && (o.uniforms.map.value = e), o.uniforms.flipY && (o.uniforms.flipY.value = r), a ? (o.uniforms.writeDepth = new zi(!0), o.uniforms.depthTexture.value = a) : (o.uniforms.writeDepth = new zi(!1), o.uniforms.depthTexture.value = null), o.needsUpdate = !0, o.uniformsNeedUpdate = !0;
    const h = this.mesh;
    h.material = o, h.frustumCulled = !1, this.scene.children.length = 0, this.scene.add(h);
    const d = n.getRenderTarget(), f = n.getContext(), p = f.getParameter(f.DEPTH_TEST), g = f.getParameter(f.DEPTH_WRITEMASK), _ = f.getParameter(f.DEPTH_FUNC);
    l ? n.getContext().enable(n.getContext().DEPTH_TEST) : n.getContext().disable(n.getContext().DEPTH_TEST), n.state.buffers.depth.setMask(c), n.setClearColor(new se(0, 0, 0), 0), n.setPixelRatio(window.devicePixelRatio), n.setRenderTarget(t), n.clear(), n.render(this.scene, this.perspectiveCam), n.setRenderTarget(d);
    const m = n.state.buffers.depth;
    m.setTest(p), m.setMask(g), m.setFunc(_);
  }
  /**
   * Copy a texture to a HTMLCanvasElement
   * @param texture the texture convert
   * @param force if true the texture will be copied to a new texture before converting
   * @returns the HTMLCanvasElement with the texture or null if the texture could not be copied
   */
  static textureToCanvas(e, t = !1) {
    if (!e)
      return null;
    (t === !0 || e.isCompressedTexture === !0) && (e = jC(e));
    const i = e.image;
    if (BC(i)) {
      const n = document.createElement("canvas");
      n.width = i.width, n.height = i.height;
      const o = n.getContext("2d");
      return o ? (o.drawImage(i, 0, 0, i.width, i.height, 0, 0, n.width, n.height), n) : (console.error("Failed getting canvas 2d context"), null);
    }
    return null;
  }
}
function jC(s) {
  return sr.copyTexture(s);
}
function xI(s, e = !1) {
  return sr.textureToCanvas(s, e);
}
function BC(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas || typeof ImageBitmap < "u" && s instanceof ImageBitmap;
}
function FC(s) {
  const e = s.type;
  return e === "Mesh" || e === "SkinnedMesh";
}
function Ub(s, e) {
  e ? s["needle:rendercustomshadow"] = !0 : s["needle:rendercustomshadow"] = !1;
}
function zC(s) {
  if (s) {
    if (s["needle:rendercustomshadow"] === !0)
      return !0;
    if (s["needle:rendercustomshadow"] == null)
      return !0;
  }
  return !1;
}
function _i(s, e = void 0, t = void 0, i = void 0) {
  const n = i || new pi();
  n.makeEmpty();
  const o = [];
  function r(l) {
    let c = !0;
    if (l.visible && wC(l) !== !1 && !(l.type === "TransformControlsGizmo" || l.type === "TransformControlsPlane")) {
      if (l instanceof Ww && (c = !1), l instanceof am && (c = !1), l instanceof da && (c = !1), l.isGizmo === !0 && (c = !1), l.material instanceof ob && (c = !1), FC(l) || (c = !1), t && l.layers.test(t) === !1 && (c = !1), c) {
        if (e && Array.isArray(e) && e?.includes(l)) return;
        if (typeof e == "function" && e(l) === !0)
          return;
      }
      if (l.isUI !== !0) {
        if (c) {
          const h = l.children;
          l.children = o;
          const d = l.position, f = l.scale;
          if (Number.isNaN(d.x) || Number.isNaN(d.y) || Number.isNaN(d.z)) {
            console.warn(`Object "${l.name}" has NaN values in position or scale.... will ignore it`, d, f);
            return;
          }
          l.geometry === null && (l.geometry = void 0), n.expandByObject(l, !0), l.children = h;
        }
        for (const h of l.children)
          r(h);
      }
    }
  }
  let a = !1;
  Array.isArray(s) || (s = [s]);
  for (const l of s)
    l && (a = !0, l.updateMatrixWorld(), r(l));
  return a || console.warn("No objects to fit camera to..."), n;
}
function UC(s, e, t) {
  const i = _i([s], t?.ignore), n = new b();
  i.getSize(n);
  const o = new b();
  i.getCenter(o);
  const r = new b();
  e.getSize(r);
  const a = new b();
  e.getCenter(a);
  const l = new b();
  l.set(r.x / n.x, r.y / n.y, r.z / n.z);
  const c = Math.min(l.x, l.y, l.z), h = t?.scale !== !1;
  if (h && tc(s, $e(s).multiplyScalar(c)), t?.position !== !1) {
    const d = new b();
    i.getCenter(d), d.y = i.min.y;
    const f = new b();
    e.getCenter(f), f.y = e.min.y;
    const p = f.clone().sub(d);
    h && p.multiplyScalar(c), ut(s, Z(s).add(p));
  }
  return {
    boundsBefore: i,
    scale: l
  };
}
function NC(s, e) {
  const t = _i([s]), i = new b();
  t.getCenter(i), i.y = t.min.y;
  const n = e.clone().sub(i), o = Z(s);
  return ut(s, o.add(n)), {
    offset: n,
    bounds: t
  };
}
function Nb(s, e, t, i) {
  if (Array.isArray(e)) {
    let r = !0;
    for (let a = 0; a < e.length; a++)
      Nb(s, e[a], a, e) || (r = !1);
    return r;
  }
  if (e.type === "MeshStandardMaterial" || e.type === "MeshBasicMaterial")
    return !1;
  if (e["material:fbx"] != null)
    return !0;
  const n = new ct();
  n["material:fbx"] = e;
  const o = e;
  return o && (o.map ? n.color.set(1, 1, 1) : n.color.copyLinearToSRGB(o.color), n.emissive.copyLinearToSRGB(o.emissive), n.emissiveIntensity = o.emissiveIntensity, n.opacity = o.opacity, n.displacementScale = o.displacementScale, n.transparent = o.transparent, n.bumpMap = o.bumpMap, n.aoMap = o.aoMap, n.map = o.map, n.displacementMap = o.displacementMap, n.emissiveMap = o.emissiveMap, n.normalMap = o.normalMap, n.envMap = o.envMap, n.alphaMap = o.alphaMap, n.metalness = o.reflectivity, n.vertexColors = o.vertexColors, o.shininess && (n.roughness = 1 - Math.sqrt(o.shininess) / 10), n.needsUpdate = !0), t === void 0 ? s.material = n : i[t] = n, !0;
}
let Gc = !1;
lC((...s) => {
  L() && he.Current?.isInXR && (Yr(!0), $b("error", ...s));
});
function Yr(s) {
  if (s) {
    if (Gc) return;
    Gc = !0, WC();
  } else {
    if (!Gc) return;
    Gc = !1, VC();
  }
}
const Bl = {
  log: void 0,
  warn: void 0,
  error: void 0
};
class $C {
  familyName = "needle-xr";
  root = null;
  context = null;
  defaultFontSize = 0.06;
  constructor() {
    this.ensureFont();
  }
  onEnable() {
    this.context = he.Current || he.All[0], this.context.pre_render_callbacks.push(this.onBeforeRender);
  }
  onDisable() {
    this.context?.pre_render_callbacks.splice(this.context?.pre_render_callbacks.indexOf(this.onBeforeRender), 1), this.root?.removeFromParent();
  }
  targetObject = new M();
  /** this is a point in forward view of the user */
  userForwardViewPoint = new b();
  oneEuroFilter = new Db(90, 0.8);
  _lastElementRemoveTime = 0;
  onBeforeRender = () => {
    const e = this.context?.mainCamera;
    if (this.context && e instanceof pe) {
      const t = this.getRoot();
      Number.isNaN(t.position.x) && t.position.set(0, 0, 0), Number.isNaN(t.quaternion.x) && t.quaternion.set(0, 0, 0, 1), this.context.scene.add(this.targetObject);
      const i = this.context.xr?.rigScale ?? 1, n = 3.5 * i, o = e.worldForward;
      o.y = 0, o.normalize().multiplyScalar(n), this.userForwardViewPoint.copy(e.worldPosition).sub(o), this.targetObject.position.distanceTo(this.userForwardViewPoint) > 2 * i && (this.targetObject.position.copy(this.userForwardViewPoint), Nd(this.targetObject, e, !0, !0), this.targetObject.rotateY(Math.PI)), this.oneEuroFilter.filter(this.targetObject.position, t.position, this.context.time.time);
      const a = this.context.time.deltaTime;
      if (t.quaternion.slerp(this.targetObject.quaternion, a * 5), t.scale.setScalar(i), this.targetObject.removeFromParent(), this.context.scene.add(t), this.context.time.time - this._lastElementRemoveTime > 0.1) {
        this._lastElementRemoveTime = this.context.time.time;
        const l = Date.now();
        for (let c = 0; c < this._activeTexts.length; c++) {
          const h = this._activeTexts[c];
          if (h instanceof Ce.Text && l - h._activatedTime > 2e4) {
            h.removeFromParent(), this._textBuffer.push(h), this._activeTexts.splice(c, 1);
            break;
          }
        }
      }
    }
  };
  addLog(e, t) {
    const i = this.getRoot(), n = this.getText();
    let o = 16777215, r = 0;
    switch (e) {
      case "log":
        o = 16777215, r = 0;
        break;
      case "warn":
        o = 16772761, r = 4465152;
        break;
      case "error":
        o = 16755370, r = 7798784;
        break;
    }
    t.length > 1e3 && (t = t.substring(0, 1e3) + "...");
    const a = (/* @__PURE__ */ new Date()).toISOString().split("T")[1].split(".")[0];
    n.textContent = "[" + a + "] " + t, n.visible = !0, n._activatedTime = Date.now(), i.add(n), this._activeTexts.push(n), this.context && this.context.scene.add(i), n.set({
      backgroundColor: o,
      color: r
    }), Ce.update();
  }
  ensureFont() {
    let e = Ce.FontLibrary.getFontFamily(this.familyName);
    e || (e = Ce.FontLibrary.addFontFamily(this.familyName), e.addVariant("normal", "normal", "./include/needle/arial-msdf.json", "./include/needle/arial.png")?.addEventListener("ready", () => {
      Ce.update();
    }));
  }
  textOptions = {
    fontSize: this.defaultFontSize,
    fontFamily: this.familyName,
    padding: 0.03,
    margin: 5e-3,
    color: 0,
    backgroundColor: 16777215,
    backgroundOpacity: 0.4,
    borderRadius: 0.03,
    offset: 0.025
  };
  _textBuffer = [];
  _activeTexts = [];
  getText() {
    const e = this.getRoot();
    if (this._textBuffer.length > 0) {
      const i = this._textBuffer.pop();
      return i.visible = !0, setTimeout(() => this.disableDepthTestRecursive(i), 100), i;
    }
    if (e.children.length > 20 && this._activeTexts.length > 0)
      return this._activeTexts.shift();
    const t = new Ce.Text(this.textOptions);
    return setTimeout(() => this.disableDepthTestRecursive(t), 500), setTimeout(() => this.disableDepthTestRecursive(t), 1500), t;
  }
  disableDepthTestRecursive(e, t = 0) {
    for (let n = 0; n < e.children.length; n++) {
      const o = e.children[n];
      o instanceof M && this.disableDepthTestRecursive(o, t + 1);
    }
    e.renderOrder = 10 * t, e.layers.set(2);
    const i = e.material;
    i && (i.depthWrite = !1, i.depthTest = !1, i.transparent = !0), t === 0 && Ce.update();
  }
  getRoot() {
    if (this.root)
      return this.root;
    const e = this.defaultFontSize, t = {
      boxSizing: "border-box",
      fontFamily: this.familyName,
      width: "2.6",
      fontSize: e,
      color: 0,
      lineHeight: 1,
      backgroundColor: 16777215,
      backgroundOpacity: 0,
      // borderColor: 0xffffff,
      // borderOpacity: .5,
      // borderWidth: 0.01,
      // padding: 0.01,
      whiteSpace: "pre-wrap",
      flexDirection: "column-reverse"
    };
    return this.root = new Ce.Block(t), this.root;
  }
}
let Qo = null;
function WC() {
  Qo || (Qo = new $C()), Qo.onEnable();
  for (const s in Bl) {
    Bl[s] = console[s];
    let e = !1;
    console[s] = function() {
      if (Bl[s]?.apply(console, arguments), !e)
        try {
          e = !0, $b(s, ...arguments);
        } finally {
          e = !1;
        }
    };
  }
}
function VC() {
  Qo?.onDisable();
  for (const s in Bl)
    console[s] = Bl[s];
}
const Za = /* @__PURE__ */ new Map();
function $b(s, ...e) {
  try {
    switch (Za.clear(), s) {
      case "log":
        Qo?.addLog("log", t());
        break;
      case "warn":
        Qo?.addLog("warn", t());
        break;
      case "error":
        Qo?.addLog("error", t());
        break;
    }
  } catch (o) {
    console.error("Error in spatial console", o);
  } finally {
    Za.clear();
  }
  function t() {
    let o = "";
    for (let r = 0; r < e.length; r++) {
      const a = e[r];
      o += i(a), r < e.length - 1 && (o += ", ");
    }
    return o;
  }
  function i(o, r = 0) {
    if (typeof o == "string")
      return '"' + o + '"';
    if (typeof o == "number") {
      if (o % 1 !== 0) {
        const l = o.toFixed(5), c = l.indexOf(".");
        let h = l.length - 1;
        for (; h > c && l[h] === "0"; ) h--;
        return l.substring(0, h + 1);
      }
      return o.toString();
    } else if (Array.isArray(o)) {
      let a = "[";
      for (let l = 0; l < o.length; l++) {
        const c = o[l];
        a += i(c, r + 1), l < o.length - 1 && (a += ", ");
      }
      return a += "]", a;
    } else {
      if (o === null)
        return "null";
      if (o === void 0)
        return "undefined";
      if (typeof o == "function")
        return o.name + "()";
    }
    if (o instanceof J) return `(${i(o.x)}, ${i(o.y)})`;
    if (o instanceof b) return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)})`;
    if (o instanceof de) return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)}, ${i(o.w)})`;
    if (o instanceof $) return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)}, ${i(o.w)})`;
    if (o instanceof _e || o instanceof Te) return o.name;
    if (o instanceof rb) return `[${o.elements.join(", ")}]`;
    if (o instanceof te) return `[${o.elements.join(", ")}]`;
    if (o instanceof ao) return o.mask.toString();
    if (typeof o == "object") {
      if (Za.has(o)) return "*";
      let a = `{
`;
      a += n(r);
      const l = Object.keys(o);
      let c = "";
      for (let h = 0; h < l.length; h++) {
        const d = l[h], f = o[d];
        if (Za.has(f)) {
          c += "";
          continue;
        }
        Za.set(f, !0), c += d + ":" + i(f, r + 1), h < l.length - 1 && (c += ", "), c.length >= 60 && (c += `
`, c += n(r), a += c, c = "");
      }
      return a += c, a += `
}`, a;
    }
    return o;
  }
  function n(o) {
    let r = "";
    for (let a = 0; a < o; a++)
      r += " ";
    return r;
  }
}
const HC = w("nodevlogs");
function Be(s, e = Ui.Log) {
  Go(e, s);
}
function ge(s) {
  Be(s, Ui.Warn);
}
function Wd(s) {
  Be(s, Ui.Error);
}
let dp, Ju;
function L() {
  if (HC) return !1;
  if (dp !== void 0) return dp;
  if (Ju !== void 0) return Ju;
  let s = rn();
  return s || (s = window.location.hostname.endsWith(".local-credentialless.webcontainer.io")), Ju = s, s;
}
function SI(s) {
  dp = s;
}
let Bi, Io = null, Pn = null, Ja = !1, my = null;
const Wb = "terminal", GC = w("console");
GC && Vb();
const qC = Symbol("consoleParent");
function Vb() {
  if (Bi) {
    Bi.showSwitch();
    return;
  }
  JC();
}
function XC() {
  Bi && (Bi.hide(), Bi.hideSwitch());
}
function QC() {
  my || (my = setInterval(YC, 500));
}
let gy = 0;
function YC() {
  const s = Eb(), e = s !== gy;
  gy = s, e && KC();
}
function KC() {
  Vb(), Pn && (Pn.setAttribute("error", "true"), Pn.innerText = "🤬");
}
function ZC() {
  Pn && (Pn.removeAttribute("error"), Pn.innerText = Wb);
}
function JC(s = !1) {
  if (Bi !== void 0 || Ja) return;
  Ja = !0;
  const e = document.createElement("script");
  e.onload = () => {
    if (!globalThis.VConsole) {
      console.warn("🌵 Debug console failed to load."), Ja = !1, Bi = null;
      return;
    }
    Ja = !1, QC(), Bi = new VConsole({
      // defaultPlugins: ['system', 'network'],
      pluginOrder: ["default", "needle-console"]
    });
    const t = globalThis["needle:codegen_files"];
    if (t && t.length > 0 && Bi.addPlugin(e1()), Io = i1(), Io && (Io[qC] = Io.parentElement, Io.style.position = "absolute", Io.style.zIndex = Number.MAX_SAFE_INTEGER.toString()), Bi.setSwitchPosition(20, 30), Pn = t1(), Pn) {
      Pn.innerText = Wb, Pn.addEventListener("click", ZC);
      const i = document.createElement("style"), n = 40;
      i.innerHTML = `
                #__vconsole .vc-switch {
                    border: 1px solid rgba(255, 255, 255, .1);
                    border-radius: 50%;
                    width: ${n}px;
                    height: ${n}px;
                    padding: 0;
                    line-height: ${n}px;
                    font-size: ${n * 0.4}px;
                    text-align: center;
                    background: #ffffff5c;
                    backdrop-filter: blur(16px);
                    -webkit-backdrop-filter: blur(16px);
                    user-select: none;
                    pointer-events: auto;
                    transition: transform .2s ease-in-out;
                    box-shadow: 0px 7px 0.5rem 0px rgb(0 0 0 / 6%), inset 0px 0px 1.3rem rgba(0,0,0,.05);

                    font-family: 'Material Symbols Outlined';
                    color: black;
                    font-size: 2.3em;
                    font-weight: 100;
                }
                #__vconsole .vc-switch:hover {
                    cursor: pointer;
                    transform: scale(1.1);
                    transition: transform .1s ease-in-out, background .1s linear;
                    background: rgba(245, 245, 245, .8);
                    outline: rgba(0, 0, 0, .05) 1px solid;
                }
                #__vconsole .vc-switch[error] {
                    background: rgba(255,0,0,.2);
                    animation: vconsole-notify 1s ease-in-out;
                    line-height: 35px;
                }
                @keyframes vconsole-notify {
                    from {
                        transform: scale(1, 1);
                    }
                    10% {
                        transform: scale(1.3, 1.3);
                    }
                    70% {
                        transform: scale(1.4, 1.4);
                    }
                    to {
                        transform: scale(1, 1);
                    }
                }
                #__vconsole .vc-panel {
                    font-family: monospace;
                    font-size: 11px;
                }
                #__vconsole .vc-plugin-box.vc-actived {
                    height: 100%;
                }
                #__vconsole .vc-mask {
                    overflow: hidden;
                }
            `, Io?.prepend(i), s === !0 && Eb() <= 0 && XC(), console.log("🌵 Debug console has loaded");
    }
  }, e.onerror = () => {
    console.warn("🌵 Debug console failed to load." + (window.crossOriginIsolated ? "This page is using cross-origin isolation, so external scripts can't be loaded." : "")), Ja = !1, Bi = null;
  }, e.src = "https://cdn.jsdelivr.net/npm/vconsole@3.15.1/dist/vconsole.min.js", document.body.appendChild(e);
}
function e1() {
  if (!globalThis.VConsole) return;
  const s = new VConsole.VConsolePlugin("needle-console", "🌵 Inspect glTF"), e = () => document.querySelector("#__vc_plug_" + s._id + " iframe");
  return s.on("renderTab", function(t) {
    const i = globalThis["needle:codegen_files"];
    if (!i || i.length === 0) return;
    let n = globalThis["needle:codegen_files"][0];
    const o = n.indexOf("?");
    o > -1 && (n = n.substring(0, o));
    const a = location.protocol + "//" + location.host + location.pathname + "/" + n, l = encodeURIComponent(a);
    s.fullUrl = "https://viewer.needle.tools?inspect&file=" + l;
    var c = '<iframe src="" style="width: 100%; height: 99%; border: none;"></iframe>';
    t(c);
  }), s.on("show", function() {
    const t = e();
    t && t.src !== s.fullUrl && (t.src = s.fullUrl);
  }), s.on("hide", function() {
    const t = e();
    t && (t.src = "");
  }), s.on("addTopBar", function(t) {
    var i = new Array();
    i.push({
      name: "Open in new window ↗",
      onClick: function(n) {
        window.open(s.fullUrl, "_blank"), Bi?.hide();
      }
    }), i.push({
      name: "Reload",
      onClick: function(n) {
        const o = e();
        o && (o.src = s.fullUrl);
      }
    }), i.push({
      name: "Fullscreen",
      onClick: function(n) {
        const o = e();
        o.requestFullscreen ? o.requestFullscreen() : o.webkitRequestFullscreen instanceof Function && o.webkitRequestFullscreen();
      }
    }), t(i);
  }), s;
}
function t1() {
  const s = document.querySelector("#__vconsole .vc-switch");
  return s || null;
}
function i1() {
  const s = document.querySelector("#__vconsole");
  return s || null;
}
const Hb = w("debugdefines");
fo('if(!globalThis["NEEDLE_ENGINE_VERSION"]) globalThis["NEEDLE_ENGINE_VERSION"] = "0.0.0";');
fo('if(!globalThis["NEEDLE_ENGINE_GENERATOR"]) globalThis["NEEDLE_ENGINE_GENERATOR"] = "unknown";');
fo('if(!globalThis["NEEDLE_PROJECT_BUILD_TIME"]) globalThis["NEEDLE_PROJECT_BUILD_TIME"] = "unknown";');
fo('if(!globalThis["NEEDLE_PUBLIC_KEY"]) globalThis["NEEDLE_PUBLIC_KEY"] = "unknown";');
fo('globalThis["__NEEDLE_ENGINE_VERSION__"] = "4.8.8";');
fo('globalThis["__NEEDLE_ENGINE_GENERATOR__"] = "undefined";');
fo('globalThis["__NEEDLE_PROJECT_BUILD_TIME__"] = "Fri Aug 29 2025 17:31:49 GMT+0000 (Coordinated Universal Time)";');
fo('globalThis["__NEEDLE_PUBLIC_KEY__"] = "' + NEEDLE_PUBLIC_KEY + '";');
const En = "4.8.8", Sm = "undefined", Gb = "Fri Aug 29 2025 17:31:49 GMT+0000 (Coordinated Universal Time)";
Hb && console.log(`Engine version: ${En} (generator: ${Sm})
Project built at ${Gb}`);
const bl = NEEDLE_PUBLIC_KEY, oo = "needle_isActiveInHierarchy", Br = "builtin_components", Mh = "needle_editor_guid";
function fo(s) {
  try {
    (0, eval)(s);
  } catch (e) {
    Hb && console.error(e);
  }
}
let qb, yy = null;
function jn() {
  return qb;
}
function Xb(s) {
  if (s == null) {
    console.warn("Oh no: someone tried registering a non-existend gltf-loader. When you see this log it might mean that needle-engine is being imported multiple times. Please check your project setup.");
    return;
  }
  yy !== s && (yy = s, qb = new s());
}
const ci = Symbol("shadowDomOwner"), n1 = w("debugpatch");
function Cm(s, e, t, i) {
  const n = n1 === e;
  if (!t && !i)
    return;
  const o = e + "___needle";
  s1(s, e, t, i);
  const r = Object.getOwnPropertyDescriptor(s, e), a = s[e];
  n && console.log("Patch", s.constructor.name, e, r, a), r ? (n && console.log("Apply patch with existing descriptor", s.constructor.name, e, r), typeof r.value == "function" && (s[e] = by(r.value, s, e))) : (n && console.log("Create patch with new property", s.constructor.name, e, r), Object.defineProperty(s, e, {
    set: function(l) {
      if (typeof l == "function")
        this[o] = by(l, s, e);
      else {
        const c = this[o];
        Qb(s, e, this, c, l), this[o] = l, Yb(s, e, this, c, l);
      }
    },
    get: function() {
      const l = this[o];
      return typeof l == "function" && l[o] ? l[o] : l;
    }
  }));
}
function CI(s, e, t) {
  const i = Pm(s, e);
  if (i)
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      o.prefix === t && (o.prefix = null), o.postfix === t && (o.postfix = null), !o.prefix && !o.postfix && i.splice(n, 1);
    }
}
const _y = Symbol("Needle:Patches:WrappedFunction");
function by(s, e, t) {
  if (s[_y])
    return s;
  const i = function(...n) {
    Qb(e, t, this, ...n);
    const o = s.apply(this, n);
    return Yb(e, t, this, o, ...n), o;
  };
  return i[_y] = !0, i;
}
const ef = "Needle:Patches";
function up() {
  return globalThis[ef] || (globalThis[ef] = /* @__PURE__ */ new WeakMap()), globalThis[ef];
}
function Pm(s, e) {
  const t = up().get(s);
  return t ? t.get(e) : null;
}
function s1(s, e, t, i) {
  let n = up().get(s);
  n || (n = /* @__PURE__ */ new Map(), up().set(s, n));
  let o = n.get(e);
  o || (o = [], n.set(e, o)), o.push({
    prefix: t,
    postfix: i
  });
}
function Qb(s, e, t, ...i) {
  if (!t) return;
  const n = Pm(s, e);
  if (n)
    for (const o of n)
      o.prefix?.call(t, ...i);
}
function Yb(s, e, t, i, ...n) {
  if (!t) return;
  const o = Pm(s, e);
  if (o)
    for (const r of o)
      r.postfix?.call(t, i, ...n);
}
const fa = [];
function Om(s) {
  fa.indexOf(s) === -1 && fa.push(s);
}
function PI(s) {
  const e = fa.indexOf(s);
  e !== -1 && fa.splice(e, 1);
}
const pa = [];
function Kb(s) {
  pa.indexOf(s) === -1 && pa.push(s);
}
function OI(s) {
  const e = pa.indexOf(s);
  e !== -1 && pa.splice(e, 1);
}
function o1(s) {
  globalThis.dispatchEvent(new CustomEvent("needle-xrsession-start", { detail: s }));
  for (let e = 0; e < fa.length; e++)
    fa[e](s);
}
function r1(s) {
  globalThis.dispatchEvent(new CustomEvent("needle-xrsession-end", { detail: s }));
  for (let e = 0; e < pa.length; e++)
    pa[e](s);
}
const tt = w("debuginput");
var km = /* @__PURE__ */ ((s) => (s.Mouse = "mouse", s.Touch = "touch", s.Controller = "controller", s.Hand = "hand", s))(km || {}), De = /* @__PURE__ */ ((s) => (s.PointerDown = "pointerdown", s.PointerUp = "pointerup", s.PointerMove = "pointermove", s.KeyDown = "keydown", s.KeyUp = "keyup", s.KeyPressed = "keypress", s))(De || {});
class Ws extends PointerEvent {
  /**
   * Spatial input data
   */
  clientZ;
  /** the device index: mouse and touch are always 0, otherwise e.g. index of the connected Gamepad or XRController */
  deviceIndex;
  /** The origin of the event contains a reference to the creator of this event.   
   * This can be the Needle Engine input system or e.g. a XR controller.  
   * Implement `onPointerHits` to receive the intersections of this event.
   */
  origin;
  /** the browser event that triggered this event (if any) */
  source;
  /** Is the pointer event created via a touch on screen or a spatial device like a XR controller or hand tracking? */
  mode;
  /** Returns true if the input was emitted in 3D space (and not by e.g. clicking on a 2D screen). You can use {@link mode} if you need more information about the input source */
  get isSpatial() {
    return this.mode != "screen";
  }
  /** A ray in worldspace for the event.    
   * If the ray is undefined you can also use `space.worldForward` and `space.worldPosition` */
  get ray() {
    return this._ray || (this._ray = new lo(this.space.worldPosition.clone(), this.space.worldForward.clone())), this._ray;
  }
  set ray(e) {
    this._ray = e;
  }
  /**@returns true if this event has a ray. If you access the ray property a ray will automatically created */
  get hasRay() {
    return this._ray !== void 0;
  }
  _ray;
  /** The device space (this object is not necessarily rendered in the scene but you can access or copy the matrix)   
   * E.g. you can access the input world space source position with `space.worldPosition` or world direction with `space.worldForward`
  */
  space;
  /** true if this event is a click */
  isClick = !1;
  /** true if this event is a double click */
  isDoubleClick = !1;
  /** @returns `true` if the event is marked to be used (when `use()` has been called). Default: `false` */
  get used() {
    return this._used;
  }
  _used = !1;
  /** Call to mark an event to be used */
  use() {
    this._used = !0;
  }
  /** Unique identifier for this input: a combination of the deviceIndex + button to uniquely identify the exact input (e.g. LeftController:Button0 = 0, RightController:Button1 = 11) */
  get pointerId() {
    return this._pointerid;
  }
  _pointerid;
  // this is set via the init arguments (we override it here for intellisense to show the string options)
  /** What type of input created this event: touch, mouse, xr controller, xr hand tracking... */
  get pointerType() {
    return this._pointerType;
  }
  _pointerType;
  // this is set via the init arguments (we override it here for intellisense to show the string options)
  /** The input that raised this event like `pointerdown` */
  get type() {
    return this._type;
  }
  _type;
  /** metadata can be used to associate additional information with the event */
  metadata = {};
  /** intersections that were generated from this event (or are associated with this event in any way) */
  intersections = new Array();
  constructor(e, t, i) {
    super(e, i), this.clientZ = i.clientZ, this._pointerid = i.pointerId, this._pointerType = i.pointerType, this._type = e, this.deviceIndex = i.deviceIndex, this.origin = i.origin, this.source = t, this.mode = i.mode, this._ray = i.ray, this.space = i.device;
  }
  _immediatePropagationStopped = !1;
  get immediatePropagationStopped() {
    return this._immediatePropagationStopped;
  }
  _propagationStopped = !1;
  get propagationStopped() {
    return this._immediatePropagationStopped || this._propagationStopped;
  }
  stopImmediatePropagation() {
    this._immediatePropagationStopped = !0, super.stopImmediatePropagation(), this.source?.stopImmediatePropagation();
  }
  stopPropagation() {
    this._propagationStopped = !0, super.stopPropagation(), this.source?.stopPropagation(), tt && console.warn("Stop propagation...", this.pointerId, this.pointerType);
  }
}
class qc extends KeyboardEvent {
  source;
  constructor(e, t, i) {
    super(e, i), this.source = t;
  }
  stopImmediatePropagation() {
    super.stopImmediatePropagation(), this.source?.stopImmediatePropagation();
  }
}
class kI {
  key;
  keyType;
  source;
  constructor(e) {
    this.key = e.key, this.keyType = e.type, this.source = e;
  }
}
var li = /* @__PURE__ */ ((s) => (s[s.Early = -100] = "Early", s[s.Default = 0] = "Default", s[s.Late = 100] = "Late", s))(li || {});
class a1 {
  /** This is a list of event listeners per event type (e.g. pointerdown, pointerup, keydown...). Each entry contains a priority and list of listeners.  
   * That way users can control if they want to receive events before or after other listeners (e.g subscribe to pointer events before the EventSystem receives them) - this allows certain listeners to be always invoked first (or last) and stop propagation  
   * Listeners per event are sorted
   */
  _eventListeners = {};
  addEventListener(e, t, i) {
    if (this._eventListeners[e] || (this._eventListeners[e] = []), !t || typeof t != "function") {
      console.error("Invalid call to addEventListener: callback is required and must be a function!");
      return;
    }
    i ? i = { ...i } : i = {};
    let n = 0;
    i?.queue != null && (n = i.queue);
    const o = this._eventListeners[e], r = o.find((a) => a.priority === n);
    r ? r.listeners.push({ callback: t, options: i }) : (o.push({ priority: n, listeners: [{ callback: t, options: i }] }), o.sort((a, l) => a.priority - l.priority));
  }
  removeEventListener(e, t, i) {
    if (!this._eventListeners[e] || !t) return;
    const n = this._eventListeners[e];
    if (i?.queue != null) {
      const o = n.find((a) => a.priority === i.queue);
      if (!o) return;
      const r = o.listeners.findIndex((a) => a.callback === t);
      r >= 0 && o.listeners.splice(r, 1);
    } else
      for (const o of n) {
        const r = o.listeners.findIndex((a) => a.callback === t);
        r >= 0 && o.listeners.splice(r, 1);
      }
  }
  dispatchEvent(e) {
    let t = !1;
    if (e instanceof qc) {
      const i = this._eventListeners[e.type];
      if (i)
        for (const n of i)
          for (let o = 0; o < n.listeners.length; o++) {
            const r = n.listeners[o];
            if (r.options?.signal?.aborted) {
              n.listeners.splice(o, 1), o--;
              continue;
            }
            r.options.once && (n.listeners.splice(o, 1), o--), r.callback(e);
          }
    }
    if (e instanceof Ws) {
      const i = this._eventListeners[e.type];
      if (i)
        for (const n of i) {
          if (t) break;
          for (let o = 0; o < n.listeners.length; o++) {
            const r = n.listeners[o];
            if (r.options?.signal?.aborted) {
              n.listeners.splice(o, 1), o--;
              continue;
            }
            if (e.immediatePropagationStopped) {
              t = !0, tt && console.log("immediatePropagationStopped", e.type);
              break;
            } else e.propagationStopped && (t = !0, tt && console.log("propagationStopped", e.type));
            r.options.once && (n.listeners.splice(o, 1), o--), r.callback(e);
          }
        }
    }
  }
  _doubleClickTimeThreshold = 0.2;
  _longPressTimeThreshold = 1;
  get mousePosition() {
    return this._pointerPositions[0];
  }
  get mousePositionRC() {
    return this._pointerPositionsRC[0];
  }
  get mouseDown() {
    return this._pointerDown[0];
  }
  get mouseUp() {
    return this._pointerUp[0];
  }
  /** Is the primary pointer clicked (usually the left button). This is equivalent to `input.click` */
  get mouseClick() {
    return this._pointerClick[0];
  }
  /** Was a double click detected for the primary pointer? This is equivalent to `input.doubleClick` */
  get mouseDoubleClick() {
    return this._pointerDoubleClick[0];
  }
  get mousePressed() {
    return this._pointerPressed[0];
  }
  get mouseWheelChanged() {
    return this.getMouseWheelChanged(0);
  }
  /** Is the primary pointer double clicked (usually the left button). This is equivalent to `input.mouseDoubleClick` */
  get click() {
    return this._pointerClick[0];
  }
  /** Was a double click detected for the primary pointer? */
  get doubleClick() {
    return this._pointerDoubleClick[0];
  }
  /**
   * Get a connected Gamepad    
   * Note: For a gamepad to be available to the browser it must have received input before while the page was focused.  
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API
   * @returns The gamepad or null if no gamepad is connected
   */
  getGamepad(e = 0) {
    return typeof navigator < "u" && "getGamepads" in navigator && navigator.getGamepads()[e] || null;
  }
  _setCursorTypes = [];
  /** @deprecated use setCursor("pointer") */
  setCursorPointer() {
    this.setCursor("pointer");
  }
  /** @deprecated use unsetCursor() */
  setCursorNormal() {
    this.unsetCursor("pointer");
  }
  /**
   * Set a custom cursor. This will set the cursor type until unsetCursor is called
   */
  setCursor(e) {
    this._setCursorTypes.push(e), this._setCursorTypes.length > 10 && this._setCursorTypes.shift(), this.updateCursor();
  }
  /**
   * Unset a custom cursor. This will set the cursor type to the previous type or default
   */
  unsetCursor(e) {
    for (let t = this._setCursorTypes.length - 1; t >= 0; t--)
      if (this._setCursorTypes[t] === e) {
        this._setCursorTypes.splice(t, 1), this.updateCursor();
        break;
      }
  }
  updateCursor() {
    this._setCursorTypes?.length == 0 ? this.context.domElement.style.cursor = "default" : this.context.domElement.style.cursor = this._setCursorTypes[this._setCursorTypes.length - 1];
  }
  /**
   * Check if a pointer id is currently used.
   */
  getIsPointerIdInUse(e) {
    for (const t of this._pointerEventsPressed)
      if (t.pointerId === e && t.used)
        return !0;
    return !1;
  }
  /** how many pointers are currently pressed */
  getPointerPressedCount() {
    let e = 0;
    for (let t = 0; t < this._pointerPressed.length; t++)
      this._pointerPressed[t] && e++;
    return e;
  }
  /**
   * Gets the position of the given pointer index in pixel
   * @param i The pointer index
   * @returns The position of the pointer in pixel
   */
  getPointerPosition(e) {
    return e >= this._pointerPositions.length ? null : this._pointerPositions[e];
  }
  getPointerPositionLastFrame(e) {
    return e >= this._pointerPositionsLastFrame.length ? null : this._pointerPositionsLastFrame[e];
  }
  getPointerPositionDelta(e) {
    return e >= this._pointerPositionsDelta.length ? null : this._pointerPositionsDelta[e];
  }
  /**
   * The pointer position in screenspace coordinates (-1 to 1) where 0 is the center of the screen.  
   * This can be useful for e.g. raycasting (see https://threejs.org/docs/#api/en/core/Raycaster.setFromCamera)
   */
  getPointerPositionRC(e) {
    return e >= this._pointerPositionsRC.length ? null : this._pointerPositionsRC[e];
  }
  getPointerDown(e) {
    return e >= this._pointerDown.length ? !1 : this._pointerDown[e];
  }
  getPointerUp(e) {
    return e >= this._pointerUp.length ? !1 : this._pointerUp[e];
  }
  getPointerPressed(e) {
    return e >= this._pointerPressed.length ? !1 : this._pointerPressed[e];
  }
  getPointerClicked(e) {
    return e >= this._pointerClick.length ? !1 : this._pointerClick[e];
  }
  getPointerDoubleClicked(e) {
    return e >= this._pointerDoubleClick.length ? !1 : this._pointerDoubleClick[e];
  }
  getPointerDownTime(e) {
    return e >= this._pointerDownTime.length ? -1 : this._pointerDownTime[e];
  }
  getPointerUpTime(e) {
    return e >= this._pointerUpTime.length ? -1 : this._pointerUpTime[e];
  }
  getPointerLongPress(e) {
    return e >= this._pointerDownTime.length ? !1 : this.getPointerPressed(e) && this.context.time.time - this._pointerDownTime[e] > this._longPressTimeThreshold;
  }
  getIsMouse(e) {
    return e < 0 || e >= this._pointerTypes.length ? !1 : this._pointerTypes[e] === "mouse";
  }
  getIsTouch(e) {
    return e < 0 || e >= this._pointerTypes.length ? !1 : this._pointerTypes[e] === "touch";
  }
  getTouchesPressedCount() {
    let e = 0;
    for (let t = 0; t < this._pointerPressed.length; t++)
      this._pointerPressed[t] && this.getIsTouch(t) && e++;
    return e;
  }
  getMouseWheelChanged(e = 0) {
    return e >= this._mouseWheelChanged.length ? !1 : this._mouseWheelChanged[e];
  }
  getMouseWheelDeltaY(e = 0) {
    return e >= this._mouseWheelDeltaY.length ? 0 : this._mouseWheelDeltaY[e];
  }
  getPointerEvent(e) {
    if (!(e >= this._pointerEvent.length))
      return this._pointerEvent[e] ?? void 0;
  }
  *foreachPointerId(e) {
    for (let t = 0; t < this._pointerTypes.length; t++)
      if (this._pointerIsActive(t)) {
        if (e !== void 0) {
          const i = this._pointerTypes[t];
          if (Array.isArray(e)) {
            let n = !1;
            for (const o of e)
              if (i === o) {
                n = !0;
                break;
              }
            if (!n) continue;
          } else if (e !== i) continue;
        }
        yield t;
      }
  }
  *foreachTouchId() {
    for (let e = 0; e < this._pointerTypes.length; e++)
      this._pointerTypes[e] === "touch" && this._pointerIsActive[e] && (yield e);
  }
  _pointerIsActive(e) {
    return e < 0 ? !1 : this._pointerPressed[e] || this._pointerDown[e] || this._pointerUp[e];
  }
  context;
  _pointerDown = [!1];
  _pointerUp = [!1];
  _pointerClick = [!1];
  _pointerDoubleClick = [!1];
  _pointerPressed = [!1];
  _pointerPositions = [new J()];
  _pointerPositionsLastFrame = [new J()];
  _pointerPositionsDelta = [new J()];
  _pointerPositionsRC = [new J()];
  _pointerPositionDown = [new b()];
  _pointerDownTime = [];
  _pointerUpTime = [];
  _pointerUpTimestamp = [];
  _pointerIds = [];
  _pointerTypes = [""];
  _mouseWheelChanged = [!1];
  _mouseWheelDeltaY = [0];
  _pointerEvent = [];
  /** current pressed pointer events. Used to check if any of those events was used  */
  _pointerEventsPressed = [];
  /** This is added/updated for pointers. screenspace pointers set this to the camera near plane  */
  _pointerSpace = [];
  _pressedStack = /* @__PURE__ */ new Map();
  onDownButton(e, t) {
    let i = this._pressedStack.get(e);
    i || (i = [], this._pressedStack.set(e, i)), i.push(t);
  }
  onReleaseButton(e, t) {
    const i = this._pressedStack.get(e);
    if (!i) return;
    const n = i.indexOf(t);
    n >= 0 && i.splice(n, 1);
  }
  /** the first button that was down and is currently pressed */
  getFirstPressedButtonForPointer(e) {
    const t = this._pressedStack.get(e);
    if (t)
      return t[0];
  }
  /** the last (most recent) button that was down and is currently pressed */
  getLatestPressedButtonForPointer(e) {
    const t = this._pressedStack.get(e);
    if (t)
      return t[t.length - 1];
  }
  getKeyDown(e) {
    if (e !== void 0)
      return this.isKeyDown(e);
    for (const t in this.keysPressed) {
      const i = this.keysPressed[t];
      if (i.startFrame === this.context.time.frameCount) return i.key;
    }
    return null;
  }
  getKeyPressed(e) {
    if (e !== void 0)
      return this.isKeyPressed(e);
    for (const t in this.keysPressed) {
      const i = this.keysPressed[t];
      if (i.pressed)
        return i.key;
    }
    return null;
  }
  getKeyUp(e) {
    if (e !== void 0)
      return this.isKeyUp(e);
    for (const t in this.keysPressed) {
      const i = this.keysPressed[t];
      return i.pressed === !1 && i.frame === this.context.time.frameCount;
    }
    return null;
  }
  isKeyDown(e) {
    if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1;
    const t = this.getCodeForCommonKeyName(e);
    if (t !== null) {
      for (const n of t) if (this.isKeyDown(n)) return !0;
      return !1;
    }
    const i = this.keysPressed[e];
    return i ? i.startFrame === this.context.time.frameCount && i.pressed : !1;
  }
  isKeyUp(e) {
    if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1;
    const t = this.getCodeForCommonKeyName(e);
    if (t !== null) {
      for (const n of t) if (this.isKeyUp(n)) return !0;
      return !1;
    }
    const i = this.keysPressed[e];
    return i ? i.frame === this.context.time.frameCount && i.pressed === !1 : !1;
  }
  isKeyPressed(e) {
    if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1;
    const t = this.getCodeForCommonKeyName(e);
    if (t !== null) {
      for (const n of t) if (this.isKeyPressed(n)) return !0;
      return !1;
    }
    const i = this.keysPressed[e];
    return i && i.pressed || !1;
  }
  // utility helper for mapping common names to actual codes; e.g. "Shift" -> "ShiftLeft" and "ShiftRight" or "a" -> "KeyA"
  getCodeForCommonKeyName(e) {
    if (e.length === 1) {
      if (e >= "0" && e <= "9")
        return ["Digit" + e];
      if (e >= "a" && e <= "z")
        return ["Key" + e.toUpperCase()];
      if (e == " ")
        return ["Space"];
    }
    switch (e) {
      case "shift":
      case "Shift":
        return ["ShiftLeft", "ShiftRight"];
      case "control":
      case "Control":
        return ["ControlLeft", "ControlRight"];
      case "alt":
      case "Alt":
        return ["AltLeft", "AltRight"];
    }
    return null;
  }
  createInputEvent(e) {
    switch (e.type) {
      case "pointerdown":
        tt && Be("Create Pointer down"), this.onDownButton(e.deviceIndex, e.button), this.onDown(e);
        break;
      case "pointermove":
        tt && Be("Create Pointer move"), this.onMove(e);
        break;
      case "pointerup":
        tt && Be("Create Pointer up"), this.onUp(e), this.onReleaseButton(e.deviceIndex, e.button);
        break;
    }
  }
  convertScreenspaceToRaycastSpace(e) {
    return e.x = (e.x - this.context.domX) / this.context.domWidth * 2 - 1, e.y = -((e.y - this.context.domY) / this.context.domHeight) * 2 + 1, e;
  }
  /** @internal */
  constructor(e) {
    this.context = e, this.context.post_render_callbacks.push(this.onEndOfFrame);
  }
  /** this is the html element we subscribed to for events */
  _htmlEventSource;
  bindEvents() {
    this.unbindEvents(), this._htmlEventSource = this.context.renderer.domElement, window.addEventListener("contextmenu", this.onContextMenu), this._htmlEventSource.addEventListener("pointerdown", this.onPointerDown, { passive: !0 }), window.addEventListener("pointermove", this.onPointerMove, { passive: !0, capture: !0 }), window.addEventListener("pointerup", this.onPointerUp, { passive: !0 }), window.addEventListener("pointercancel", this.onPointerCancel, { passive: !0 }), window.addEventListener("touchstart", this.onTouchStart, { passive: !0 }), window.addEventListener("touchmove", this.onTouchMove, { passive: !0 }), window.addEventListener("touchend", this.onTouchEnd, { passive: !0 }), this._htmlEventSource.addEventListener("wheel", this.onMouseWheel, { passive: !0 }), window.addEventListener("wheel", this.onWheelWindow, { passive: !0 }), window.addEventListener("keydown", this.onKeyDown, !1), window.addEventListener("keypress", this.onKeyPressed, !1), window.addEventListener("keyup", this.onKeyUp, !1), window.addEventListener("blur", this.onLostFocus);
  }
  unbindEvents() {
    for (const e in this._eventListeners)
      this._eventListeners[e].length = 0;
    window.removeEventListener("contextmenu", this.onContextMenu), this._htmlEventSource?.removeEventListener("pointerdown", this.onPointerDown), window.removeEventListener("pointermove", this.onPointerMove), window.removeEventListener("pointerup", this.onPointerUp), window.removeEventListener("pointercancel", this.onPointerCancel), window.removeEventListener("touchstart", this.onTouchStart), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd), this._htmlEventSource?.removeEventListener("wheel", this.onMouseWheel, !1), window.removeEventListener("wheel", this.onWheelWindow, !1), window.removeEventListener("keydown", this.onKeyDown, !1), window.removeEventListener("keypress", this.onKeyPressed, !1), window.removeEventListener("keyup", this.onKeyUp, !1), window.removeEventListener("blur", this.onLostFocus);
  }
  dispose() {
    const e = this.context.post_render_callbacks.indexOf(this.onEndOfFrame);
    e >= 0 && this.context.post_render_callbacks.splice(e, 1), this.unbindEvents();
  }
  onLostFocus = () => {
    for (const e in this.keysPressed)
      this.keysPressed[e].pressed = !1;
  };
  _receivedPointerMoveEventsThisFrame = new Array();
  onEndOfFrame = () => {
    this._receivedPointerMoveEventsThisFrame.length = 0;
    for (let e = 0; e < this._pointerUp.length; e++)
      this._pointerUp[e] = !1;
    for (let e = 0; e < this._pointerDown.length; e++)
      this._pointerDown[e] = !1;
    for (let e = 0; e < this._pointerClick.length; e++)
      this._pointerClick[e] = !1;
    for (let e = 0; e < this._pointerDoubleClick.length; e++)
      this._pointerDoubleClick[e] = !1;
    for (const e of this._pointerPositionsDelta)
      e.set(0, 0);
    for (let e = 0; e < this._mouseWheelChanged.length; e++)
      this._mouseWheelChanged[e] = !1;
    for (let e = 0; e < this._mouseWheelDeltaY.length; e++)
      this._mouseWheelDeltaY[e] = 0;
  };
  canReceiveInput(e) {
    return e.target === this.context.renderer?.domElement || e.target === this.context.domElement || this.context.isInAR || this.context.isInAR && e.target === document.body && X.isMozillaXR() ? !0 : (tt && console.warn("CanReceiveInput:False for", e.target), !1);
  }
  onContextMenu = (e) => {
    this.canReceiveInput(e) !== !1 && e instanceof PointerEvent && e.pointerType;
  };
  keysPressed = {};
  onKeyDown = (e) => {
    if (tt && console.log(`key down ${e.code}, ${this.context.application.hasFocus}`, e), !this.context.application.hasFocus)
      return;
    const t = this.keysPressed[e.code];
    if (t && t.pressed) return;
    this.keysPressed[e.code] = { pressed: !0, frame: this.context.time.frameCount + 1, startFrame: this.context.time.frameCount + 1, key: e.key, code: e.code };
    const i = new qc("keydown", e, e);
    this.onDispatchEvent(i);
  };
  onKeyPressed = (e) => {
    if (!this.context.application.hasFocus)
      return;
    const t = this.keysPressed[e.code];
    if (!t) return;
    t.pressed = !0, t.frame = this.context.time.frameCount + 1;
    const i = new qc("keypress", e, e);
    this.onDispatchEvent(i);
  };
  onKeyUp = (e) => {
    if (!this.context.application.hasFocus)
      return;
    const t = this.keysPressed[e.code];
    if (!t) return;
    t.pressed = !1, t.frame = this.context.time.frameCount + 1;
    const i = new qc("keyup", e, e);
    this.onDispatchEvent(i);
  };
  onWheelWindow = (e) => {
    document.pointerLockElement && this.onMouseWheel(e);
  };
  onMouseWheel = (e) => {
    if (this.canReceiveInput(e) === !1) return;
    this._mouseWheelDeltaY.length <= 0 && this._mouseWheelDeltaY.push(0), this._mouseWheelChanged.length <= 0 && this._mouseWheelChanged.push(!1), this._mouseWheelChanged[0] = !0;
    const t = this._mouseWheelDeltaY[0];
    this._mouseWheelDeltaY[0] = t + e.deltaY;
  };
  onPointerDown = (e) => {
    if (this.context.isInAR || this.canReceiveInput(e) === !1) return;
    e.target instanceof HTMLElement && e.target.setPointerCapture(e.pointerId);
    const t = this.getPointerId(e);
    tt && Be(`pointer down #${t}, identifier:${e.pointerId}`);
    const i = this.getAndUpdateSpatialObjectForScreenPosition(t, e.clientX, e.clientY), n = new Ws("pointerdown", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: t, button: e.button, clientX: e.clientX, clientY: e.clientY, pointerType: e.pointerType, buttonName: this.getButtonName(e), device: i, pressure: e.pressure });
    this.onDown(n);
  };
  onPointerMove = (e) => {
    if (this.context.isInAR || this._receivedPointerMoveEventsThisFrame.includes(e.pointerId)) return;
    this._receivedPointerMoveEventsThisFrame.push(e.pointerId);
    let t = e.button;
    e.pointerType === "mouse" && (t = this.getFirstPressedButtonForPointer(0) ?? 0);
    const i = this.getPointerId(e, t);
    t === -1 && (t = i);
    const n = this.getAndUpdateSpatialObjectForScreenPosition(i, e.clientX, e.clientY), o = new Ws("pointermove", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: i, button: t, clientX: e.clientX, clientY: e.clientY, pointerType: e.pointerType, buttonName: this.getButtonName(e), device: n, pressure: e.pressure });
    this.onMove(o);
  };
  onPointerCancel = (e) => {
    this.context.isInAR || (tt && console.log("Pointer cancel", e), this.onPointerUp(e));
  };
  onPointerUp = (e) => {
    if (this.context.isInAR) return;
    e.target instanceof HTMLElement && e.target.releasePointerCapture(e.pointerId);
    const t = this.getPointerId(e), i = new Ws("pointerup", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: t, button: e.button, clientX: e.clientX, clientY: e.clientY, pointerType: e.pointerType, buttonName: this.getButtonName(e), device: this.getAndUpdateSpatialObjectForScreenPosition(t, e.clientX, e.clientY), pressure: e.pressure });
    this.onUp(i), this._pointerIds[t] = -1, tt && console.log("ID=" + t, "PointerId=" + e.pointerId, "ALL:", [...this._pointerIds]);
  };
  getPointerId(e, t) {
    return e.pointerType === "mouse" ? 0 + (t ?? e.button) : this.getPointerIndex(e.pointerId);
  }
  getButtonName(e) {
    const t = e.button;
    if (e.pointerType === "mouse")
      switch (t) {
        case 0:
          return "left";
        case 1:
          return "middle";
        case 2:
          return "right";
      }
    return "unknown";
  }
  // the touch events are currently only used for AR support on android
  onTouchStart = (e) => {
    if (this.context.isInAR)
      for (let t = 0; t < e.changedTouches.length; t++) {
        const i = e.changedTouches[t], n = this.getPointerIndex(i.identifier), o = this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), r = new Ws("pointerdown", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: o, pressure: i.force });
        this.onDown(r);
      }
  };
  onTouchMove = (e) => {
    if (this.context.isInAR)
      for (let t = 0; t < e.changedTouches.length; t++) {
        const i = e.changedTouches[t], n = this.getPointerIndex(i.identifier), o = this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), r = new Ws("pointermove", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: o, pressure: i.force });
        this.onMove(r);
      }
  };
  onTouchEnd = (e) => {
    if (this.context.isInAR)
      for (let t = 0; t < e.changedTouches.length; t++) {
        const i = e.changedTouches[t], n = this.getPointerIndex(i.identifier), o = new Ws("pointerup", e, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), pressure: i.force });
        this.onUp(o), this._pointerIds[n] = -1;
      }
  };
  tempNearPlaneVector = new b();
  tempFarPlaneVector = new b();
  tempLookMatrix = new te();
  getAndUpdateSpatialObjectForScreenPosition(e, t, i) {
    let n = this._pointerSpace[e];
    n || (n = new M(), this._pointerSpace[e] = n), this._pointerSpace[e] = n;
    const o = this.context.mainCamera;
    if (o) {
      const r = this.tempNearPlaneVector.set(t, i, -1);
      this.convertScreenspaceToRaycastSpace(r);
      const a = this.tempFarPlaneVector.set(r.x, r.y, 1);
      r.unproject(o), a.unproject(o);
      const l = o.worldUp || G(0, 1, 0).applyQuaternion(be(o));
      this.tempLookMatrix.lookAt(a, r, l), n.position.set(r.x, r.y, r.z), n.quaternion.setFromRotationMatrix(this.tempLookMatrix);
    }
    return n;
  }
  // Prevent the same event being handled twice (e.g. on touch we get a mouseUp and touchUp evt with the same timestamp)
  // private isNewEvent(timestamp: number, index: number, arr: number[]): boolean {
  //     while (arr.length <= index) arr.push(-1);
  //     if (timestamp === arr[index]) return false;
  //     arr[index] = timestamp;
  //     return true;
  // }
  isInRect(e) {
    if (this.context.isInXR) return !0;
    const t = this.context.domElement.getBoundingClientRect(), i = e.clientX, n = e.clientY, o = i >= t.x && i <= t.right && n >= t.y && n <= t.bottom;
    return tt && !o && console.log("Not in rect", t, i, n), o;
  }
  onDown(e) {
    const t = e.pointerId;
    if (this.getPointerPressed(t) && console.warn(`Received pointerDown for pointerId that is already pressed: ${t}`, tt ? e : ""), tt && console.log(e.pointerType, "DOWN", t), !!this.isInRect(e)) {
      for (this.setPointerState(t, this._pointerPressed, !0), this.setPointerState(t, this._pointerDown, !0), this.setPointerStateT(t, this._pointerEvent, e.source); t >= this._pointerTypes.length; ) this._pointerTypes.push(e.pointerType);
      for (this._pointerTypes[t] = e.pointerType; t >= this._pointerPositionDown.length; ) this._pointerPositionDown.push(new b());
      for (this._pointerPositionDown[t].set(e.clientX, e.clientY, e.clientZ ?? 0); t >= this._pointerPositions.length; ) this._pointerPositions.push(new J());
      this._pointerPositions[t].set(e.clientX, e.clientY), t >= this._pointerDownTime.length && this._pointerDownTime.push(0), this._pointerDownTime[t] = this.context.time.realtimeSinceStartup, this.updatePointerPosition(e), this._pointerEventsPressed.push(e), this.onDispatchEvent(e);
    }
  }
  // moveEvent?: Event;
  onMove(e) {
    const t = e.pointerId, i = this.getPointerPressed(t);
    i === !1 && !this.isInRect(e) || e.pointerType === "touch" && !i || (this.updatePointerPosition(e), this.setPointerStateT(t, this._pointerEvent, e.source), this.onDispatchEvent(e));
  }
  onUp(e) {
    const t = e.pointerId;
    if (!this.getPointerPressed(t)) {
      tt && console.log(e.pointerType, "UP", t, "was not down");
      return;
    }
    tt && console.log(e.pointerType, "UP", t), this.setPointerState(t, this._pointerPressed, !1), this.setPointerStateT(t, this._pointerEvent, e.source), this.setPointerState(t, this._pointerUp, !0), this.updatePointerPosition(e);
    for (let l = this._pointerEventsPressed.length - 1; l >= 0; l--)
      if (this._pointerEventsPressed[l].pointerId === t) {
        this._pointerEventsPressed.splice(l, 1);
        break;
      }
    if (!this._pointerPositionDown[t]) {
      tt && ge("Received pointer up event without matching down event for button: " + t), console.warn("Received pointer up event without matching down event for button: " + t);
      return;
    }
    const n = this._pointerUpTime[t], o = this._pointerDownTime[t], r = this.context.time.realtimeSinceStartup, a = r - o;
    if (t >= this._pointerUpTime.length && this._pointerUpTime.push(-99), this._pointerUpTime[t] = r, a < 1) {
      let l = e.clientX - this._pointerPositionDown[t].x, c = e.clientY - this._pointerPositionDown[t].y, h = 0;
      if (e.isSpatial && e.clientZ != null && (h = e.clientZ - this._pointerPositionDown[t].z, l *= 200, c *= 200, h *= 200), Math.abs(l) < 5 && Math.abs(c) < 5 && Math.abs(h) < 5) {
        this.setPointerState(t, this._pointerClick, !0), e.isClick = !0;
        const d = r - n;
        tt && console.log("CLICK", t, l, c, h, d), d < this._doubleClickTimeThreshold && d > 0 && (this.setPointerState(t, this._pointerDoubleClick, !0), e.isDoubleClick = !0);
      }
    }
    this.onDispatchEvent(e);
  }
  updatePointerPosition(e) {
    const t = e.pointerId;
    for (; t >= this._pointerPositions.length; ) this._pointerPositions.push(new J());
    for (; t >= this._pointerPositionsLastFrame.length; ) this._pointerPositionsLastFrame.push(new J());
    for (; t >= this._pointerPositionsDelta.length; ) this._pointerPositionsDelta.push(new J());
    const i = this._pointerPositionsLastFrame[t];
    i.copy(this._pointerPositions[t]);
    const n = this._pointerPositionsDelta[t];
    let o = e.clientX - i.x, r = e.clientY - i.y;
    if (e.source instanceof MouseEvent || e.source instanceof TouchEvent) {
      const h = e.source;
      o === 0 && h.movementX !== 0 && (o = h.movementX || 0), r === 0 && h.movementY !== 0 && (r = h.movementY || 0);
    }
    n.x += o, n.y += r, this._pointerPositions[t].x = e.clientX, this._pointerPositions[t].y = e.clientY;
    const a = e.clientX, l = e.clientY;
    for (; t >= this._pointerPositionsRC.length; ) this._pointerPositionsRC.push(new J());
    const c = this._pointerPositionsRC[t];
    c.set(a, l), this.convertScreenspaceToRaycastSpace(c);
  }
  /** get the next free id */
  getPointerIndex(e) {
    let t = -1;
    for (let i = 0; i < this._pointerIds.length; i++) {
      if (this._pointerIds[i] === e) return i;
      t === -1 && this._pointerIds[i] === -1 && (t = i);
    }
    return t !== -1 ? (this._pointerIds[t] = e, t) : (tt && console.log("PUSH pointerId:", e), this._pointerIds.push(e), this._pointerIds.length - 1);
  }
  setPointerState(e, t, i) {
    t[e] = i;
  }
  setPointerStateT(e, t, i) {
    return t[e] = i, i;
  }
  onDispatchEvent(e) {
    const t = N.Current;
    try {
      N.Current = this.context, this.dispatchEvent(e);
    } finally {
      N.Current = t;
    }
  }
}
const Kr = new te().makeRotationY(Math.PI), ji = new $().setFromAxisAngle(new b(0, 1, 0), Math.PI), l1 = w("debugwebxr");
class c1 {
  priority = -1e5;
  gameObject;
  isXRRig() {
    return !0;
  }
  get isActive() {
    return this.gameObject.visible;
  }
  constructor() {
    if (this.gameObject = new M(), this.gameObject.name = "Implicit XR Rig", l1) {
      const e = Tm(16733661);
      e.position.y += 0.5, this.gameObject.add(e);
    }
  }
}
const Yn = w("debugwebxr"), Xc = w("debugcustomgesture"), h1 = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", d1 = "generic-trigger", u1 = new $().setFromEuler(new Rt(gs.degToRad(0), gs.degToRad(-90), gs.degToRad(-90))), f1 = new b(0.04, -0.04, 0);
class Zb {
  /** the Needle XR Session */
  xr;
  get context() {
    return this.xr.context;
  }
  /**
   * https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource
   */
  inputSource;
  /** the input source index */
  index = 0;
  /** When enabled the controller will create input events in the Needle Engine input system (e.g. when a button is pressed or the controller is moved)   
   * You can disable this if you don't want inputs to go through the input system but be aware that this will result in `onPointerDown` component callbacks to not be invoked anymore for this XRController
  */
  emitEvents = !0;
  /** Is the controller still connected?  */
  get connected() {
    return this._connected;
  }
  _connected = !0;
  get isTracking() {
    return this._isTracking;
  }
  _isTracking = !1;
  /** the input source gamepad giving raw access to the gamepad values  
   * You should usually use the `getButton` and `getStick` methods instead to get access to named buttons and sticks   
   */
  get gamepad() {
    return this.__gamepad ??= this.inputSource.gamepad;
  }
  __gamepad;
  /** @returns true if this is a hand (otherwise this is a controller) */
  get isHand() {
    return this.hand != null;
  }
  /** 
   * If this is a hand then this is the hand info (XRHand)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRHand
   */
  get hand() {
    return this.__hand ??= this.inputSource.hand;
  }
  __hand;
  /** threejs XRHandSpace, shorthand for `context.renderer.xr.getHand(controllerIndex)` 
   * @link https://threejs.org/docs/#api/en/renderers/webxr/WebXRManager.getHand
  */
  get handObject() {
    return this.context.renderer.xr.getHand(this.index);
  }
  /** The input source profiles */
  get profiles() {
    return this.inputSource.profiles;
  }
  /** The device input layout */
  get layout() {
    return this._layout;
  }
  /** shorthand for `inputSource.targetRayMode` */
  get targetRayMode() {
    return this.inputSource.targetRayMode;
  }
  /** shorthand for `inputSource.targetRaySpace` */
  get targetRaySpace() {
    return this.inputSource.targetRaySpace;
  }
  /** shorthand for `inputSource.gripSpace` */
  get gripSpace() {
    return this.inputSource.gripSpace;
  }
  /** 
   * If the controller if held in the left or right hand (or if it's a left or right hand) 
   **/
  get side() {
    return this.__side ??= this.inputSource.handedness;
  }
  __side = void 0;
  /** is right side. shorthand for `side === 'right'` */
  get isRight() {
    return this.side === "right";
  }
  /** is left side. shorthand for `side === 'left'` */
  get isLeft() {
    return this.side === "left";
  }
  /** is XR stylus, e.g. Logitech MX Ink */
  get isStylus() {
    return this._isMxInk;
  }
  /** The XRTransientInputHitTestSource can be used to perform hit tests with the controller ray against the real world.   
   * see https://developer.mozilla.org/en-US/docs/Web/API/XRSession/requestHitTestSourceForTransientInput for more information
   * Requires the hit-test feature to be enabled in the XRSession   
   * 
   * NOTE: The hit test source should be cancelled once it's not needed anymore. Call `cancelHitTestSource` to do this
   */
  getHitTestSource() {
    return this._hitTestSource || this._requestHitTestSource(), this._hitTestSource;
  }
  get hasHitTestSource() {
    return this._hitTestSource;
  }
  /** Make sure to cancel the hittest source once it's not needed anymore */
  cancelHitTestSource() {
    this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0);
  }
  _hitTestSource = void 0;
  _hasSelectEvent = !1;
  get hasSelectEvent() {
    return this._hasSelectEvent;
  }
  _isMxInk = !1;
  _isMetaQuestTouchController = !1;
  /** Perform a hit test against the XR planes or meshes. shorthand for `xr.getHitTest(controller)`
   * @returns the hit test result (with position and rotation in worldspace) or null if no hit was found
   */
  getHitTest() {
    return this.xr.getHitTest(this);
  }
  /** This is cleared at the beginning of each frame */
  _handJointPoses = /* @__PURE__ */ new Map();
  /** Get the hand joint pose from the current XRFrame. Results are cached for a frame to avoid calling getJointPose multiple times */
  getHandJointPose(e, t) {
    if (t = t || this.xr.frame, !this.hand || !t?.getJointPose || !this.xr.referenceSpace) return null;
    let i = this._handJointPoses?.get(e);
    return i || (i = t.getJointPose(e, this.xr.referenceSpace), i && this._handJointPoses.set(e, i), i);
  }
  /** Grip matrix in grip space */
  _gripMatrix = new te();
  /** Grip position in grip space */
  _gripPosition = new b();
  /** Grip rotation in grip space */
  _gripQuaternion = new $();
  _linearVelocity = new b();
  _rayPositionRaw = new b();
  _rayRotationRaw = new $();
  /** ray matrix in grip space */
  _rayMatrix = new te();
  /** Ray position in rig space */
  _rayPosition = new b();
  /** Ray rotation in rig space */
  _rayQuaternion = new $();
  /** Grip position in rig space */
  get gripPosition() {
    return G(this._gripPosition);
  }
  /** Grip rotation in rig space */
  get gripQuaternion() {
    return bn(this._gripQuaternion);
  }
  get gripMatrix() {
    return this._gripMatrix;
  }
  /** Grip linear velocity in rig space
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRPose/linearVelocity
   */
  get gripLinearVelocity() {
    return G(this._linearVelocity).applyQuaternion(ji);
  }
  /** Ray position in rig space */
  get rayPosition() {
    return G(this._rayPosition);
  }
  /** Ray rotation in rig space */
  get rayQuaternion() {
    return bn(this._rayQuaternion);
  }
  /** Controller grip position in worldspace */
  get gripWorldPosition() {
    return G(this._gripWorldPosition);
  }
  _gripWorldPosition = new b();
  /** Controller grip rotation in wordspace */
  get gripWorldQuaternion() {
    return bn(this._gripWorldQuaternion);
  }
  _gripWorldQuaternion = new $();
  /** Controller ray position in worldspace (this value is calculated once per frame by default - call `updateRayWorldPosition` to force an update) */
  get rayWorldPosition() {
    return G(this._rayWorldPosition);
  }
  _rayWorldPosition = new b();
  /** Recalculates the ray world position */
  updateRayWorldPosition() {
    const e = this.xr.context.mainCamera?.parent;
    this._rayWorldPosition.copy(this._rayPositionRaw), e && this._rayWorldPosition.applyMatrix4(e.matrixWorld);
  }
  /** Controller ray rotation in wordspace (this value is calculated once per frame by default - call `updateRayWorldQuaternion` to force an update) */
  get rayWorldQuaternion() {
    return bn(this._rayWorldQuaternion);
  }
  _rayWorldQuaternion = new $();
  get pinchPosition() {
    return G(this._pinchPosition);
  }
  _pinchPosition = new b();
  /** Recalculates the ray world quaternion */
  updateRayWorldQuaternion() {
    const e = this.xr.context.mainCamera?.parent, t = e ? be(e) : void 0;
    this._rayWorldQuaternion.copy(this._rayRotationRaw).multiply(ji), t && this._rayWorldQuaternion.premultiply(t);
  }
  /** The controller ray in worldspace */
  get ray() {
    return this._ray.origin.copy(this.rayWorldPosition), this._ray.direction.copy(G(0, 0, 1).applyQuaternion(this.rayWorldQuaternion)), this._ray;
  }
  _ray;
  /** Recalculated once per update */
  _hand_wristDotUp = void 0;
  /**
   * The dot product of the hand palm with the up vector. 
   * This is a number between -1 and 1, where 1 means the palm is directly up and -1 means the palm is directly down (upside down).
   * This value is undefined if there's no hand
   */
  get handWristDotUp() {
    if (this._hand_wristDotUp !== void 0) return this._hand_wristDotUp;
    const e = this.handObject?.joints.wrist;
    if (e) {
      const t = G(0, 1, 0).applyQuaternion(e.quaternion), i = G(0, 1, 0).dot(t);
      return this._hand_wristDotUp = i;
    }
  }
  /**
   * @returns true if the hand is upside down
   */
  get isHandUpsideDown() {
    return this.handWristDotUp !== void 0 ? this.handWristDotUp < -0.7 : !1;
  }
  /**
   * @returns true if the hand is upside down and we got a pinch down event this frame.
   */
  get isTeleportGesture() {
    return this.isHandUpsideDown && this.getGesture("pinch")?.isDown;
  }
  /** The controller object space.  
   * You can use it to attach objects to the controller.   
   * Children will be automatically detached and put into the scene when the controller disconnects
   */
  get object() {
    return this._object;
  }
  _object;
  _gripSpaceObject;
  _raySpaceObject;
  /** Assigned the model that you use for rendering. This can be used as a hint for other components */
  model = null;
  _debugAxesHelper = new mi(0.15);
  _debugGripAxesHelper = new mi(0.07);
  _debugRayAxesHelper = new mi(0.07);
  /** returns the URL of the default controller model */
  async getModelUrl() {
    return this.getMotionController?.then((e) => e?.assetUrl || null);
  }
  constructor(e, t, i) {
    this.xr = e, this.inputSource = t, this.index = i, this._object = new M(), this._object.name = `NeedleXRController_${i}`, Yn && (this._object.add(this._debugAxesHelper), this._gripSpaceObject = new M(), this._raySpaceObject = new M(), this._gripSpaceObject.name = `NeedleXRController_${i}_gripSpace`, this._raySpaceObject.name = `NeedleXRController_${i}_raySpace`, this._gripSpaceObject.add(this._debugGripAxesHelper), this._raySpaceObject.add(this._debugRayAxesHelper), this.xr.context.scene.add(this._gripSpaceObject), this.xr.context.scene.add(this._raySpaceObject)), this.xr.context.scene.add(this._object), this._ray = new lo(), this.pointerInit = {
      origin: this,
      pointerType: this.hand ? "hand" : "controller",
      deviceIndex: this.index,
      pointerId: -1,
      // < this will be updated in the emitPointerEvent method
      mode: this.inputSource.targetRayMode,
      ray: this._ray,
      device: this._object,
      buttonName: "none"
    }, this.initialize(), this.subscribeEvents();
  }
  _hitTestSourcePromise = null;
  _requestHitTestSource() {
    return this._hitTestSourcePromise ? this._hitTestSourcePromise : this.xr.mode === "immersive-ar" && this.inputSource.targetRayMode === "tracked-pointer" && this.xr.session.requestHitTestSourceForTransientInput ? this._hitTestSourcePromise = this.xr.session.requestHitTestSourceForTransientInput({
      profile: this.inputSource.profiles[0],
      offsetRay: new XRRay()
    })?.then((e) => (this._hitTestSourcePromise = null, this.connected ? this._hitTestSource = e : (e.cancel(), null))) ?? null : null;
  }
  onPointerHits = (e) => {
  };
  onUpdate(e) {
    this.onUpdateFrame(e), this.updateInputEvents(), this.onUpdateMove();
  }
  onRenderDebug() {
    F.DrawSphere(this.rayWorldPosition, 3e-3), F.DrawDirection(this.rayWorldPosition, G(0, 0, 10).applyQuaternion(this.rayWorldQuaternion));
    const t = (this.inputSource.gripSpace ? this.gripWorldPosition : this.object.worldPosition).sub(this.object.worldForward.multiplyScalar(0.1)), i = this.inputSource.profiles.join(`
`);
    let n = `Controller[${this.index}] (${this.inputSource.targetRayMode}, ${this.side})
C:${this.connected ? "x" : "-"} T:${this.isTracking ? "x" : "-"} Hand:${this.inputSource.hand ? "x" : "-"} Pen: ${this._isMxInk ? "x" : "-"}`;
    if (this.inputSource.hand && (n += `
Pinch: ${this.getGesture("pinch")?.value.toFixed(3)}`), n += `
` + i, n += `
` + (this.inputSource.targetRaySpace ? "Ray: x" : "Ray: -") + (this.inputSource.gripSpace ? " Grip: x" : " Grip: -") + (this.inputSource.gamepad ? ` Gamepad: ${this.inputSource.gamepad.mapping}` : " Gamepad: -"), this.inputSource.gamepad) {
      const o = this.inputSource.gamepad;
      let r = "[btns " + o.buttons.length + "]: " + o.buttons.map((a) => a.value.toPrecision(1)).join(",");
      r += `
[axes ` + o.axes.length + "]: " + o.axes.map((a) => a.toPrecision(1)).join(","), n += `
` + r;
    }
    F.DrawLabel(t, n, 6e-3);
  }
  onUpdateFrame(e) {
    if (this._handJointPoses.clear(), this._hand_wristDotUp = void 0, !this.xr.referenceSpace) {
      this._isTracking = !1;
      return;
    }
    const t = e.getPose(this.inputSource.targetRaySpace, this.xr.referenceSpace);
    this._isTracking = t != null;
    let i = null, n = null, o = null, r = null;
    if (t) {
      const h = t.transform;
      this._rayMatrix.fromArray(h.matrix).premultiply(Kr), this._rayMatrix.decompose(this._rayPosition, this._rayQuaternion, G(1, 1, 1)), o = G(h.position), r = bn(h.orientation), this._rayPositionRaw.copy(o), this._rayRotationRaw.copy(r);
    }
    if (this.inputSource.gripSpace) {
      const h = e.getPose(this.inputSource.gripSpace, this.xr.referenceSpace);
      if (h) {
        const d = h.transform;
        if (i = G(d.position), n = bn(d.orientation), this._gripMatrix.fromArray(d.matrix).premultiply(Kr), this._gripMatrix.decompose(this._gripPosition, this._gripQuaternion, G(1, 1, 1)), "linearVelocity" in h && h.linearVelocity) {
          const f = h.linearVelocity;
          this._linearVelocity.set(f.x, f.y, f.z);
        }
      }
    }
    this.xr.context.mainCamera?.parent && (this._object.parent !== this.xr.context.mainCamera?.parent && this.xr.context.mainCamera.parent.add(this._object), this._gripSpaceObject !== void 0 && this._gripSpaceObject?.parent !== this.xr.context.mainCamera?.parent && this.xr.context.mainCamera.parent.add(this._gripSpaceObject), this._raySpaceObject !== void 0 && this._raySpaceObject?.parent !== this.xr.context.mainCamera?.parent && this.xr.context.mainCamera.parent.add(this._raySpaceObject));
    const a = this.hand;
    if (a) {
      let h = !1;
      const d = a.get("wrist"), f = d && this.getHandJointPose(d, e);
      if (f) {
        h = !0;
        const _ = f.transform.position, m = f.transform.orientation;
        this._object.position.set(_.x, _.y, _.z), this._object.quaternion.set(m.x, m.y, m.z, m.w).multiply(ji);
      }
      h || (this._object.position.copy(this._rayPosition), this._object.quaternion.copy(this._rayQuaternion).multiply(ji));
      const p = a.get("middle-finger-metacarpal"), g = p && this.getHandJointPose(p, e);
      g && (this._gripMatrix.fromArray(g.transform.matrix).premultiply(Kr), this._gripMatrix.decompose(this._gripPosition, this._gripQuaternion, G(1, 1, 1)), i = G().copy(g.transform.position), n = bn().copy(g.transform.orientation), n.multiply(u1), i.add(G(f1).applyQuaternion(n)));
    } else this.inputSource.gripSpace && this.targetRayMode === "transient-pointer" && i && n ? (this._object.position.copy(i), this._object.quaternion.copy(n).multiply(ji)) : o && r && (this._object.position.copy(o), this._object.quaternion.copy(r).multiply(ji));
    Yn && (o && r && (this._raySpaceObject?.position.copy(o), this._raySpaceObject?.quaternion.copy(r).multiply(ji)), i && n && (this._gripSpaceObject?.position.copy(i), this._gripSpaceObject?.quaternion.copy(n).multiply(ji)));
    const l = this.xr.context.mainCamera?.parent, c = l ? be(l) : void 0;
    i && n && (this._gripWorldPosition.copy(i), l && this._gripWorldPosition.applyMatrix4(l.matrixWorld), this._gripWorldQuaternion.copy(n), this._gripWorldQuaternion.multiply(ji), c && this._gripWorldQuaternion.premultiply(c)), this.updateRayWorldPosition(), this.updateRayWorldQuaternion();
  }
  /** Called when the input source disconnects */
  onDisconnected() {
    this._connected = !1, Yn && console.warn("Controller disconnected", this.index);
    for (const e of this._object.children)
      this.xr.context.scene.attach(e);
    this._object?.removeFromParent(), this._debugAxesHelper?.removeFromParent(), this._debugGripAxesHelper?.removeFromParent(), this._debugRayAxesHelper?.removeFromParent(), this._gripSpaceObject?.removeFromParent(), this._raySpaceObject?.removeFromParent(), this.unsubscribeEvents(), this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0);
  }
  /**
   * Get a gamepad button
   * @link https://github.com/immersive-web/webxr-gamepads-module/blob/main/gamepads-module-explainer.md
   * @param key the controller button name e.g. x-button
   * @returns the gamepad button if it exists on the controller - otherwise undefined
   */
  getButton(e) {
    if (!this._layout) return;
    switch (e) {
      case "primary-button":
        if (this.isLeft) e = "x-button";
        else if (this.isRight) e = "a-button";
        else return;
        break;
      case "primary":
        return this.hand ? this.getGesture("pinch") : this.toNeedleGamepadButton(0, e);
    }
    if (this._buttonMap.has(e))
      return this.toNeedleGamepadButton(this._buttonMap.get(e), e);
    const t = this._layout?.components[e];
    if (t?.gamepadIndices)
      switch (t.type) {
        case "button":
        case "squeeze":
          if (this.inputSource.gamepad) {
            const i = t.gamepadIndices.button;
            return this._buttonMap.set(e, i), this.toNeedleGamepadButton(i, e);
          }
          break;
        default:
          console.warn("Unsupported component type", t.type);
          break;
      }
    this._buttonMap.set(e, void 0);
  }
  /** Get a gesture state */
  getGesture(e) {
    const t = this.states[e];
    if (!t) return null;
    this.states[e] = t;
    const i = this._needleGamepadButtons[e] || new wy(void 0, e);
    return i.pressed = t.pressed, i.value = t.value, i.isDown = t.isDown, i.isUp = t.isUp, this._needleGamepadButtons[e] = i, i;
  }
  getPointerId(e) {
    if ((e === "primary" || e === "pinch") && (e = 0), typeof e != "number") {
      const t = this._buttonMap.get(e);
      if (t === void 0)
        return;
      e = t;
    }
    return this.index * 10 + e;
  }
  _needleGamepadButtons = {};
  /** combine the InputState information + the GamepadButton information (since GamepadButtons can not be extended) */
  toNeedleGamepadButton(e, t) {
    if (!this.inputSource.gamepad?.buttons) return;
    const i = this.inputSource.gamepad?.buttons[e], n = this.states[e], o = this._needleGamepadButtons[e] || new wy(e, t);
    return i && (o.pressed = i.pressed, o.value = i.value, o.touched = i.touched), n && (o.isDown = n.isDown, o.isUp = n.isUp), this._needleGamepadButtons[e] = o, o;
  }
  /**
   * Get the values of a controller joystick
   * @link https://github.com/immersive-web/webxr-gamepads-module/blob/main/gamepads-module-explainer.md
   * @returns the stick values where x is left/right, y is up/down and z is the button value
   */
  getStick(e) {
    if (!this._layout) return { x: 0, y: 0, z: 0 };
    if (e === "primary") {
      const i = this.inputSource.gamepad?.axes[0] || 0, n = this.inputSource.gamepad?.axes[1] || 0, o = this.inputSource.gamepad?.buttons[3]?.value || 0;
      return { x: i, y: n, z: o };
    }
    const t = this._layout?.components[e];
    if (t?.gamepadIndices)
      switch (t.type) {
        case "thumbstick":
          if (this.inputSource.gamepad) {
            const i = t.gamepadIndices.xAxis, n = t.gamepadIndices.yAxis;
            let o = this.inputSource.gamepad?.axes[i], r = this.inputSource.gamepad?.axes[n];
            o *= -1, r *= -1;
            const a = t.gamepadIndices.button, l = this.inputSource.gamepad?.buttons[a]?.value;
            return { x: o, y: r, z: l };
          }
      }
    return { x: 0, y: 0, z: 0 };
  }
  _buttonMap = /* @__PURE__ */ new Map();
  // the motion controller contains the controller scheme, we use this to simplify button access
  _motioncontroller;
  _layout;
  getMotionController;
  initialize() {
    if (this._hasSelectEvent = this.profiles.includes("generic-hand-select") || this.profiles.some((e) => e.startsWith("generic-trigger")), this._isMetaQuestTouchController = this.profiles.includes("meta-quest-touch-plus") || this.profiles.includes("oculus-touch-v3"), this._isMxInk = this.profiles.includes("logitech-mx-ink"), !this._layout) {
      if (this.inputSource.targetRayMode === "transient-pointer") return;
      const e = kS(this.inputSource, h1, d1);
      this.getMotionController = e.then((t) => {
        if (!this.connected) return null;
        this._motioncontroller = new MS(
          this.inputSource,
          t.profile,
          t.assetPath || ""
        );
        const n = t.profile.layouts[this.inputSource.handedness];
        if (this._layout = n, this._layout && !this._layout.gamepad?.length) {
          this._layout.gamepad = [];
          for (const o in this._layout.components) {
            const r = this._layout.components[o];
            this._layout.gamepad[r.gamepadIndices.button] = o;
          }
        }
        return this._motioncontroller;
      }).catch((t) => (this.inputSource && console.warn("Couldn't initialize motion controller profile for ", this.inputSource, t), null));
    }
  }
  /**
   * When enabled the controller will automatically emit pointer down events to the Needle Engine Input System.   
   * @default true
   */
  emitPointerDownEvent = !0;
  /**
   * When enabled the controller will automatically emit pointer up events to the Needle Engine Input System.   
   * @default true
   */
  emitPointerUpEvent = !0;
  /**
   * When enabled the controller will automatically emit pointer move events to the Needle Engine Input System.   
   * @default true
   */
  emitPointerMoveEvent = !0;
  /**
   * The distance threshold for pointer move events. This value is in units in rig space
   * @default 0.03
   */
  pointerMoveDistanceThreshold = 0.03;
  /**
   * The angle threshold for pointer move events. This value is in radians.
   * @default 0.05
   */
  pointerMoveAngleThreshold = 0.05;
  subscribeEvents() {
    this.xr.session.addEventListener("selectstart", this.onSelectStart), this.xr.session.addEventListener("selectend", this.onSelectEnd), this.xr.session.addEventListener("squeezestart", this.onSequeezeStart), this.xr.session.addEventListener("squeezeend", this.onSequeezeEnd);
  }
  unsubscribeEvents() {
    this.xr.session.removeEventListener("selectstart", this.onSelectStart), this.xr.session.removeEventListener("selectend", this.onSelectEnd), this.xr.session.removeEventListener("squeezestart", this.onSequeezeStart), this.xr.session.removeEventListener("squeezeend", this.onSequeezeEnd);
  }
  _selectButtonIndex = void 0;
  _squeezeButtonIndex = void 0;
  onSelectStart = (e) => {
    if (!this.emitPointerDownEvent || this.inputSource !== e.inputSource) return;
    this.onUpdateFrame(e.frame), this._hasSelectEvent = !0;
    const t = this._layout?.selectComponentId, i = this._layout?.components[t]?.gamepadIndices?.button;
    i !== void 0 && (this._selectButtonIndex = i), !Xc && (Yn && F.DrawDirection(this.rayWorldPosition, G(0, 0.01, 1).applyQuaternion(this.rayWorldQuaternion), 16711680, 10), this.emitPointerEvent(De.PointerDown, this._selectButtonIndex || 0, "xr-standard-trigger", !0, e));
  };
  onSelectEnd = (e) => {
    this.emitPointerUpEvent && (Xc || this.inputSource === e.inputSource && this.emitPointerEvent(De.PointerUp, this._selectButtonIndex || 0, "xr-standard-trigger", !0, e));
  };
  onSequeezeStart = (e) => {
    this.emitPointerDownEvent && this.inputSource === e.inputSource && (this._squeezeButtonIndex = this._layout?.components["xr-standard-squeeze"]?.gamepadIndices?.button, this._squeezeButtonIndex !== void 0 && (Yn && F.DrawDirection(this.rayWorldPosition, G(0, 0.01, 1).applyQuaternion(this.rayWorldQuaternion), 255, 10), this.emitPointerEvent(De.PointerDown, this._squeezeButtonIndex || 0, "xr-standard-squeeze", !0, e)));
  };
  onSequeezeEnd = (e) => {
    this.emitPointerUpEvent && this.inputSource === e.inputSource && this._squeezeButtonIndex !== void 0 && this.emitPointerEvent(De.PointerUp, this._squeezeButtonIndex || 0, "xr-standard-squeeze", !0, e);
  };
  /** Index = button index */
  states = {};
  // If we want to invoke button events for ALL buttons we need to keep track of the previous state
  // instead of using XR input select start events which is only raised for the primary button
  // we should probably do both but then we need to ignore the primary index in the following function (to not raise an event for the same button twice)
  // and start with index = 1
  updateInputEvents() {
    if (this.gamepad?.buttons) {
      for (let e = 0; e < this.gamepad.buttons.length; e++) {
        const t = this.gamepad.buttons[e], i = this.states[e] || new vy();
        let n = null;
        this._isMxInk && (e === 4 || e === 5) ? (t.value > 0 && !i.pressed ? (n = "pointerdown", i.isDown = !0, i.isUp = !1) : t.value === 0 && i.pressed ? (n = "pointerup", i.isDown = !1, i.isUp = !0) : i.pressed && (n = "pointermove", i.isDown = !1, i.isUp = !1), i.pressed = t.value > 0, i.value = t.value) : (t.pressed && !i.pressed ? (n = "pointerdown", i.isDown = !0, i.isUp = !1) : !t.pressed && i.pressed ? (n = "pointerup", i.isDown = !1, i.isUp = !0) : (i.isDown = !1, i.isUp = !1), i.pressed = t.pressed, i.value = t.value), this.states[e] = i;
        const o = e !== this._selectButtonIndex && e !== this._squeezeButtonIndex;
        if (n != null && o) {
          let r = this._layout?.gamepad[e];
          this._isMxInk && e === 4 && (r = "stylus-touch"), this._isMxInk && e === 5 && (r = "stylus-tip"), (Yn || Xc) && console.log("Emitting pointer event", n, e, r, t.value, this.gamepad, this._layout), this.emitPointerEvent(n, e, r ?? "none", !1, null, t.value);
        }
      }
      if (this._isMetaQuestTouchController) {
        const e = this.gamepad.buttons.length - 1, t = this.states[e];
        if (t && t.isDown) {
          const i = this.context.menu;
          i.spatialMenuIsVisible ? i.setSpatialMenuVisible(!1) : this.context.menu.setSpatialMenuVisible(!0);
        }
      }
    }
    if (this.hand) {
      const e = this.handObject;
      if (e) {
        const t = e.joints["index-finger-tip"], i = e.joints["thumb-tip"];
        if (t && i) {
          const n = t.position.distanceTo(i.position);
          this._pinchPosition.lerpVectors(t.position, i.position, 0.5);
          const o = this.xr.context.mainCamera?.parent;
          if (o && this._pinchPosition.applyMatrix4(o.matrixWorld), n !== 0) {
            const l = this.states.pinch || new vy(), c = (0.02 + 0.01) * 1.5;
            l.value = 1 - (n - 0.02) / c;
            const h = n < 0.02 - 0.01, d = n > 0.02 + 0.01;
            h && !l.pressed ? (Xc && console.log("pinch start", n), l.isDown = !0, l.isUp = !1, l.pressed = !0) : d && l.pressed ? (l.isDown = !1, l.isUp = !0, l.pressed = !1) : (l.isDown = !1, l.isUp = !1), this.states.pinch = l;
          }
        }
      }
    }
  }
  _didMoveLastFrame = !1;
  _lastPointerMovePosition = new b();
  _lastPointerMoveQuaternion = new $();
  onUpdateMove() {
    if (!this.emitPointerMoveEvent) return;
    let e = !1;
    if (this._lastPointerMovePosition.distanceTo(this.gripWorldPosition) > this.pointerMoveDistanceThreshold * this.xr.rigScale && (e = !0), e || this._lastPointerMoveQuaternion.angleTo(this.gripWorldQuaternion) > this.pointerMoveAngleThreshold && (e = !0), e) {
      this._didMoveLastFrame = !0, this._lastPointerMovePosition.copy(this.gripWorldPosition), this._lastPointerMoveQuaternion.copy(this.gripWorldQuaternion), Yn && F.DrawLabel(this.rayWorldPosition.add(this.object.worldForward.multiplyScalar(0.1)), "move", 0.01);
      let i = this.xr.context.input.getFirstPressedButtonForPointer(this.index);
      i === void 0 && (i = 0);
      const n = this.gamepad?.buttons[i]?.value;
      this.emitPointerEvent("pointermove", i, "none", !1, null, n);
    } else
      this._didMoveLastFrame = !1;
  }
  /** cached spatial pointer init object. We re-use it to not have */
  pointerInit;
  emitPointerEvent(e, t, i, n, o = null, r) {
    if (!this.emitEvents) {
      Yn && e !== De.PointerMove && console.warn("Pointer events are disabled for this controller", this.index, e, t);
      return;
    }
    if (this.xr.mode === "immersive-vr" || this.xr.isPassThrough) {
      this.pointerInit.origin = this, this.pointerInit.pointerId = this.getPointerId(t), this.pointerInit.pointerType = this.hand ? "hand" : "controller", this.pointerInit.button = t, this.pointerInit.buttonName = i, this.pointerInit.isPrimary = n, this.pointerInit.mode = this.inputSource.targetRayMode, this.pointerInit.ray = this.ray, this.pointerInit.device = this.object, this.pointerInit.pressure = r, this.pointerInit.clientX = this._rayPosition.x / this.xr.rigScale, this.pointerInit.clientY = this._rayPosition.y / this.xr.rigScale, this.pointerInit.clientZ = this._rayPosition.z / this.xr.rigScale;
      const a = N.Current;
      N.Current = this.xr.context, Yn && e !== "pointermove" && console.warn("Pointer event", e, t, i, { ...this.pointerInit }), this.xr.context.input.createInputEvent(new Ws(e, o, this.pointerInit)), N.Current = a;
    }
  }
}
class vy {
  /** if the button was pressed the last update */
  isDown = !1;
  /** if the button was released the last update */
  isUp = !1;
  pressed = !1;
  value = 0;
}
class wy {
  /** The index of the button in the input gamepad */
  index;
  name;
  touched = !1;
  pressed = !1;
  value = 0;
  /** was the button just pressed down the last update */
  isDown = !1;
  /** was the button just released the last update */
  isUp = !1;
  constructor(e, t) {
    this.index = e, this.name = t;
  }
}
var fp = /* @__PURE__ */ ((s) => (s.Visible = "application-visible", s.Hidden = "application-hidden", s.MuteChanged = "application-mutechanged", s))(fp || {});
let ed = !1;
const Vr = [];
function pr() {
  if (ed) return;
  L() && console.debug("User interaction registered: audio can now be played"), ed = !0;
  const s = [...Vr];
  Vr.length = 0, s.forEach((e) => e());
}
document.addEventListener("mousedown", pr);
document.addEventListener("pointerup", pr);
document.addEventListener("click", pr);
document.addEventListener("dragstart", pr);
document.addEventListener("touchend", pr);
document.addEventListener("keydown", pr);
class Bn extends EventTarget {
  static get userInteractionRegistered() {
    return ed;
  }
  /**  @deprecated use Application.registerWaitForInteraction instead */
  static registerWaitForAllowAudio = Bn.registerWaitForInteraction;
  /**
   * Register a callback that will be called when the user interacts with the page (click, touch, keypress, etc).  
   * If the user has already interacted with the page, the callback will be called immediately.  
   * This can be used to wait for user interaction before playing audio, for example.
   */
  static registerWaitForInteraction(e) {
    if (e !== null) {
      if (ed) {
        e();
        return;
      }
      Vr.indexOf(e) === -1 && Vr.push(e);
    }
  }
  /**
   * Unregister a callback that was previously registered with registerWaitForInteraction.
   */
  static unregisterWaitForInteraction(e) {
    const t = Vr.indexOf(e);
    t !== -1 && Vr.splice(t, 1);
  }
  _mute = !1;
  /** audio muted? */
  get muted() {
    return this._mute;
  }
  /** set global audio mute */
  set muted(e) {
    e !== this._mute && (this._mute = e, this.dispatchEvent(new Event(
      "application-mutechanged"
      /* MuteChanged */
    )));
  }
  context;
  /** @returns true if the document is focused */
  get hasFocus() {
    return document.hasFocus();
  }
  /**
   * @returns true if the application is currently visible (it's tab is active and not minimized)
   */
  get isVisible() {
    return this._isVisible;
  }
  _isVisible = !0;
  /** @internal */
  constructor(e) {
    super(), this.context = e, window.addEventListener("visibilitychange", this.onVisiblityChanged.bind(this), !1);
  }
  onVisiblityChanged(e) {
    switch (e.target.visibilityState) {
      case "hidden":
        this._isVisible = !1, this.dispatchEvent(new Event(
          "application-hidden"
          /* Hidden */
        ));
        break;
      case "visible":
        this._isVisible = !0, this.dispatchEvent(new Event(
          "application-visible"
          /* Visible */
        ));
        break;
    }
  }
}
const Zr = /* @__PURE__ */ new Map(), Hr = /* @__PURE__ */ new Map();
let xy = 0;
function ks(s, e, t) {
  if (Zr.has(e) || Zr.set(e, new Array()), Zr.get(e).push({
    method: s,
    options: { once: !1, ...t }
  }), xy < 30) {
    const i = Hr.get(e);
    i && i?.length > 100 && (xy += 1, console.warn(`You have ${i.length} methods registered for Event ${e}.

This might be a performance issue!
Consider unregistering the methods when they are not needed anymore!

To unregister you can call the function returned by your event hook (e.g.const unregister = onStart(...)) 

or by using the once option like onStart(()=>{}, { once:true }).

See https://engine.needle.tools/docs/scripting.html#special-lifecycle-hooks for more information.`));
  }
}
function po(s, e) {
  const t = Hr.get(e);
  if (t) {
    for (let n = 0; n < t.length; n++)
      if (t[n].method === s) {
        t.splice(n, 1);
        return;
      }
  }
  const i = Zr.get(e);
  if (i) {
    for (let n = 0; n < i.length; n++)
      if (i[n].method === s) {
        i.splice(n, 1);
        return;
      }
  }
}
function mn(s, e) {
  e === ce.ContextCreated && pp.delete(s), Jb(s, e);
}
function Jb(s, e) {
  e === xe.Start && Zr.get(ce.ContextCreated) && Jb(s, ce.ContextCreated);
  const t = e === xe.Start || e === ce.ContextCreated, i = Hr.get(e);
  i && i.length > 0 && Cy(s, i, t);
  const n = Zr.get(e);
  if (n && n.length > 0) {
    const o = [...n];
    n.length = 0, Cy(s, o, t), o.length > 0 && (Hr.has(e) || Hr.set(e, new Array()), Hr.get(e).push(...o));
  }
}
const Qc = new Array(), Sy = {
  context: null
};
function Cy(s, e, t) {
  Qc.length = 0;
  for (let n = 0; n < e.length; n++)
    Qc.push(e[n]);
  let i = pp.get(s);
  for (let n = 0; n < Qc.length; n++) {
    const o = Qc[n];
    let r = !0;
    if (i && i.has(o) && (r = !1), r)
      try {
        Sy.context = s, o.method?.call(Sy, s);
      } catch (a) {
        console.error("Error in lifecycle method", a);
      }
    if (o.options?.once) {
      for (let a = 0; a < e.length; a++)
        if (e[a] === o) {
          e.splice(a, 1);
          break;
        }
    } else t && (i || (i = /* @__PURE__ */ new Set(), pp.set(s, i)), i.add(o));
  }
}
const pp = /* @__PURE__ */ new WeakMap(), e0 = {};
function t0(s, e) {
  e0[s] = e;
}
function p1(s) {
  const e = s.getBufferIdentifier(), t = e0[e];
  return t(s);
}
function m1(s) {
  return typeof s.guid == "function" ? s.guid() : null;
}
let Mm;
function MI() {
  return Mm;
}
function RI(s) {
  Mm = s;
}
function g1(s, e) {
  return e || (e = {}), e = {
    ...Mm,
    ...e
  }, s ? new Yg(s, e) : new Yg(e);
}
async function Py() {
  const s = await import("./vendor-Z4SPrTcP.js").then((e) => e.bundler);
  return console.log(s), s.default === void 0 ? s : s.default;
}
class y1 {
  get isHost() {
    return this._host !== void 0;
  }
  _host;
  _client;
  _clientData;
  constructor() {
    this.onEnable();
  }
  onEnable() {
    this.trySetupHost("HOST-5980e65c-8438-453e-8b35-f13c736dcd81");
  }
  async trySetupHost(e) {
    const t = await Py(), i = new t(e);
    i.on("error", (n) => {
      console.error(n), this._host = void 0, this.trySetupClient(e);
    }), i.on("open", (n) => {
      this._host = new b1(i);
    });
  }
  async trySetupClient(e) {
    const t = await Py();
    this._client = new t(), this._client.on("error", (i) => {
      console.error("Client error", i);
    }), this._client.on("open", (i) => {
      console.log("client connected", i), this._clientData = this._client.connect(e, { metadata: { id: i } }), this._clientData.on("open", () => {
        console.log("Connected to host");
      }), this._clientData.on("data", (n) => {
        console.log("<<", n);
      });
    });
  }
}
class _1 {
  _peer;
  constructor(e) {
    this._peer = e;
  }
}
class b1 extends _1 {
  get isHost() {
    return !0;
  }
  _connections = [];
  constructor(e) {
    super(e), console.log("I AM THE HOST"), this._peer?.on("connection", this.onConnection.bind(this)), this._peer.on("close", () => {
      this.broadcast("BYE");
    }), setInterval(() => {
      this.broadcast("HELLO");
    }, 2e3);
  }
  onConnection(e) {
    console.log("host connection", e), e.on("open", () => {
      this._connections.push(e), this.broadcastConnection(e);
    });
  }
  broadcastConnection(e) {
    const t = this._connections.map((i) => i.metadata?.id).filter((i) => i !== void 0);
    this.broadcast({ type: "connection-list", connections: t });
  }
  broadcast(e) {
    if (e != null) {
      console.log(">>", e);
      for (const t in this._peer.connections) {
        const i = this._peer.connections[t];
        if (i)
          if (Array.isArray(i))
            for (const n of i)
              n && n.send(e);
          else
            console.warn(i);
      }
    }
  }
}
var vn = /* @__PURE__ */ ((s) => (s[s.OnConnection = 0] = "OnConnection", s[s.OnRoomJoin = 1] = "OnRoomJoin", s[s.Queued = 2] = "Queued", s[s.Immediate = 3] = "Immediate", s))(vn || {});
const Oy = "https://urls.needle.tools/default-networking-backend/index";
let Mi = "wss://networking.needle.tools/socket";
const oi = !!w("debugnet"), Yc = !!(oi || w("debugowner")), Kc = w("debugnetbin");
var v1 = /* @__PURE__ */ ((s) => (s.ConnectionInfo = "connection-start-info", s))(v1 || {}), ee = /* @__PURE__ */ ((s) => (s.Join = "join-room", s.Leave = "leave-room", s.JoinedRoom = "joined-room", s.LeftRoom = "left-room", s.UserJoinedRoom = "user-joined-room", s.UserLeftRoom = "user-left-room", s.RoomStateSent = "room-state-sent", s))(ee || {});
class TI {
  room;
  // room name
  viewId;
  allowEditing;
  inRoom;
  // connection ids
}
class EI {
  room;
  // room name
}
class AI {
  userId;
}
var w1 = /* @__PURE__ */ ((s) => (s.RequestHasOwner = "request-has-owner", s.ResponseHasOwner = "response-has-owner", s.RequestIsOwner = "request-is-owner", s.ResponseIsOwner = "response-is-owner", s.RequestOwnership = "request-ownership", s.GainedOwnership = "gained-ownership", s.RemoveOwnership = "remove-ownership", s.LostOwnership = "lost-ownership", s.GainedOwnershipBroadcast = "gained-ownership-broadcast", s.LostOwnershipBroadcast = "lost-ownership-broadcast", s))(w1 || {});
class i0 {
  guid;
  connection;
  get hasOwnership() {
    return this._hasOwnership;
  }
  // TODO: server should just send id to everyone
  /** @returns true of anyone has ownership */
  get isOwned() {
    return this._isOwned;
  }
  /** 
   * Checks if Needle Engine networking is connected to a websocket. Note that this is **not equal** to being connected to a *room*. If you want to check if Needle Engine is connected to a networking room use the `isInRoom` property.
   * @returns true if connected to the websocket. 
   */
  get isConnected() {
    return this.connection.isConnected;
  }
  _hasOwnership = !1;
  _isOwned = void 0;
  _gainSubscription;
  _lostSubscription;
  _hasOwnerResponse;
  constructor(e, t) {
    this.connection = e, this.guid = t, this._gainSubscription = this.onGainedOwnership.bind(this), this._lostSubscription = this.onLostOwnership.bind(this), e.beginListen("lost-ownership", this._lostSubscription), e.beginListen("gained-ownership-broadcast", this._gainSubscription), this._hasOwnerResponse = this.onHasOwnerResponse.bind(this), e.beginListen("response-has-owner", this._hasOwnerResponse);
  }
  _isWaitingForOwnershipResponseCallback = null;
  updateIsOwned() {
    this.connection.send("request-has-owner", { guid: this.guid });
  }
  onHasOwnerResponse(e) {
    e.guid === this.guid && (this._isOwned = e.value);
  }
  requestOwnershipIfNotOwned() {
    return this._isWaitingForOwnershipResponseCallback !== null ? this : (this._isWaitingForOwnershipResponseCallback = this.waitForHasOwnershipRequestResponse.bind(this), this.connection.beginListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this.connection.send("request-has-owner", { guid: this.guid }), this);
  }
  waitForHasOwnershipRequestResponse(e) {
    e.guid === this.guid && (this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null), this._isOwned = e.value, e.value || (Yc && console.log("request ownership", this.guid), this.requestOwnership()));
  }
  requestOwnershipAsync() {
    return new Promise((e, t) => {
      this.requestOwnership();
      let i = 0;
      const n = () => {
        if (i++ > 10) return t("Timeout");
        setTimeout(() => {
          this.hasOwnership ? e(this) : n();
        }, 100);
      };
      n();
    });
  }
  requestOwnership() {
    return Yc && console.log("Request ownership", this.guid), this.connection.send("request-ownership", { guid: this.guid }), this;
  }
  freeOwnership() {
    return this.connection.send("remove-ownership", { guid: this.guid }), this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null), this;
  }
  destroy() {
    this.connection.stopListen("gained-ownership", this._gainSubscription), this.connection.stopListen("lost-ownership", this._lostSubscription), this.connection.stopListen("response-has-owner", this._hasOwnerResponse), this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null);
  }
  onGainedOwnership(e) {
    e.guid === this.guid && (this._isOwned = !0, this.connection.connectionId === e.owner ? (Yc && console.log("GAINED OWNERSHIP", this.guid), this._hasOwnership = !0) : this._hasOwnership = !1);
  }
  onLostOwnership(e) {
    e === this.guid && (Yc && console.log("LOST OWNERSHIP", this.guid), this._hasOwnership = !1, this._isOwned = !1);
  }
}
class x1 {
  context;
  _peer = null;
  constructor(e) {
    this.context = e;
  }
  /** Experimental: networking via peerjs */
  get peer() {
    return this._peer || (this._peer = new y1()), this._peer;
  }
  /**
   * Returns the state of a given guid.
   */
  tryGetState(e) {
    return e === "invalid" ? null : this._state[e];
  }
  /** The connection id of the local user - it is given by the networking backend and can not be changed */
  get connectionId() {
    return this._connectionId;
  }
  /** Returns true if the networking backend is in debug mode.  
   * To see all networking messages in the console use `?debugnet` in the url
   */
  get isDebugEnabled() {
    return oi;
  }
  /** 
   * Checks if Needle Engine networking is connected to a websocket. Note that this is **not equal** to being connected to a *room*. If you want to check if Needle Engine is connected to a networking room use the `isInRoom` property.
   * @returns true if connected to the websocket. 
   */
  get isConnected() {
    return this.connected;
  }
  /** The name of the room the user is currently connected to */
  get currentRoomName() {
    return this._currentRoomName;
  }
  /** True when connected to a room via a regular url, otherwise (when using a view only url) false indicating that the user should not be able to modify the scene */
  get allowEditing() {
    return this._currentRoomAllowEditing;
  }
  /**
   * The view id of the room the user is currently connected to.
   */
  get currentRoomViewId() {
    return this._currentRoomViewId;
  }
  /**
   * Returns a url that can be shared with others to view the current room in view only mode.  
   * This is useful for sharing a room with others without allowing them to modify the scene.  
   * Use `connection.allowEditing` to check if the current room is in view only mode.  
   */
  getViewOnlyUrl() {
    if (this.currentRoomViewId === null) return null;
    const e = new URL(window.location.href);
    return e.searchParams.set("view", this.currentRoomViewId), e.href;
  }
  /** True if connected to a networked room. Use the joinRoom function or a `SyncedRoom` component */
  get isInRoom() {
    return this._isInRoom;
  }
  /** Latency to currently connected backend server */
  get currentLatency() {
    return this._currentDelay;
  }
  /**
   * The current server url that the networking backend is connected to (e.g. the url of the websocket server)
   */
  get currentServerUrl() {
    return this._ws?.url ?? null;
  }
  /** A ping is sent to the server at a regular interval while the browser tab is active. This method can be used to send additional ping messages when needed so that the user doesn't get disconnected from the networking backend */
  sendPing() {
    this.send("ping", { time: this.context.time.time });
  }
  /** Returns true if a user with the given connectionId is in the room */
  userIsInRoom(e) {
    return this._currentInRoom.indexOf(e) !== -1;
  }
  _usersInRoomCopy = [];
  /** Returns a list of all user ids in the current room */
  usersInRoom(e = null) {
    e || (e = this._usersInRoomCopy), e.length = 0;
    for (const t of this._currentInRoom)
      e.push(t);
    return e;
  }
  /** Joins a networked room. If you don't want to manage a connection yourself you can use a `SyncedRoom` component as well */
  joinRoom(e, t = !1) {
    return e ? e.length > 1024 ? (console.error('Room name too long, can not join: "' + e + '". Max length is 1024 characters.'), !1) : (this.isInRoom && this.currentRoomName !== e && console.warn("Needle Engine is already connected to a networking room. Connecting to multiple rooms is not supported"), this.connect(), oi && console.log("join: " + e), this.send("join-room", { room: e, viewOnly: t }, vn.OnConnection), !0) : (console.error('Missing room name, can not join: "' + e + '"'), !1);
  }
  /** Use to leave a room that you are currently connected to (use `leaveRoom()` to disconnect from the currently active room but you can also specify a room name) */
  leaveRoom(e = null) {
    return e || (e = this.currentRoomName), e ? (this.send("leave-room", { room: e }), !0) : (console.error('Missing room name, can not join: "' + e + '"'), !1);
  }
  /** Send a message to the networking backend - it will broadcasted to all connected users in the same room by default */
  send(e, t = null, i = vn.Queued) {
    if (t === null && (t = {}), i === vn.Queued) {
      this._defaultMessagesBuffer.push({ key: e, value: t });
      return;
    }
    return this.sendWithWebsocket(e, t, i);
  }
  /** Use to delete state for a given guid on the server */
  sendDeleteRemoteState(e) {
    this.send("delete-state", { guid: e, dontSave: !0 }), delete this._state[e];
  }
  /** Use to delete all state in the currently connected room on the server */
  sendDeleteRemoteStateAll() {
    this.send("delete-all-state"), this._state = {};
  }
  /** Send a binary message to the server (broadcasted to all connected users) */
  sendBinary(e) {
    Kc && console.log("<< send binary", this.context.time.frame, e.length / 1024 + " KB"), this._ws?.send(e);
  }
  _defaultMessagesBuffer = [];
  _defaultMessagesBufferArray = [];
  sendBufferedMessagesNow() {
    if (!this._ws) return;
    this._defaultMessagesBufferArray.length = 0;
    const e = Object.keys(this._defaultMessagesBuffer).length;
    for (const i in this._defaultMessagesBuffer) {
      const n = this._defaultMessagesBuffer[i];
      if (e <= 1) {
        this.sendWithWebsocket(n.key, n.value, vn.Immediate);
        break;
      }
      const o = this.toMessage(n.key, n.value);
      this._defaultMessagesBufferArray.push(o);
    }
    if (this._defaultMessagesBuffer.length = 0, this._defaultMessagesBufferArray.length > 0 && oi && console.log("SEND BUFFERED", this._defaultMessagesBufferArray.length), this._defaultMessagesBufferArray.length <= 0) return;
    const t = JSON.stringify(this._defaultMessagesBufferArray);
    this._ws?.send(t);
  }
  /** Use to start listening to networking events.   
   * To unsubscribe from events use the `stopListen` method.   
   * See the example below for typical usage:
   * 
   * ### Component Example
   * ```ts
   * // Make sure to unsubscribe from events when the component is disabled
   * export class MyComponent extends Behaviour {
   *   onEnable() {
   *     this.connection.beginListen("joined-room", this.onJoinedRoom)
   *   }
   *   onDisable() {
   *     this.connection.stopListen("joined-room", this.onJoinedRoom)
   *   }
   *   onJoinedRoom = () => {
   *      console.log("I joined a networked room")
   *   }
   * }
   * ```
   * @link https://engine.needle.tools/docs/networking.html
   * 
  */
  beginListen(e, t) {
    return this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t), t;
  }
  /**@deprecated please use stopListen instead (2.65.2-pre) */
  stopListening(e, t) {
    return this.stopListen(e, t);
  }
  /** Use to stop listening to networking events  
   * To subscribe to events use the `beginListen` method.   
   * See the example below for typical usage:
   * 
   * ### Component Example
   * ```ts
   * // Make sure to unsubscribe from events when the component is disabled
   * export class MyComponent extends Behaviour {
   *   onEnable() {
   *     this.connection.beginListen("joined-room", this.onJoinedRoom)
   *   }
   *   onDisable() {
   *     this.connection.stopListen("joined-room", this.onJoinedRoom)
   *   }
   *   onJoinedRoom = () => {
   *      console.log("I joined a networked room")
   *   }
   * }
   * ```
   */
  stopListen(e, t) {
    if (!t || !this._listeners[e]) return;
    const i = this._listeners[e].indexOf(t);
    i >= 0 && this._listeners[e].splice(i, 1);
  }
  /** Use to start listening to networking binary events */
  beginListenBinary(e, t) {
    return this._listenersBinary[e] || (this._listenersBinary[e] = []), this._listenersBinary[e].push(t), t;
  }
  /** Use to stop listening to networking binary events */
  stopListenBinary(e, t) {
    if (!this._listenersBinary[e]) return;
    const i = this._listenersBinary[e].indexOf(t);
    i >= 0 && this._listenersBinary[e].splice(i, 1);
  }
  netWebSocketUrlProvider;
  /** Use to override the networking server backend url. This is what the `Networking` component uses to modify the backend url */
  registerProvider(e) {
    this.netWebSocketUrlProvider = e;
  }
  /** Used to connect to the networking server */
  async connect(e) {
    if (this.connected && e && e !== Mi)
      return Promise.reject("Can not connect to different server url. Please disconnect first.");
    if (this.connected)
      return Promise.resolve(!0);
    e && console.debug("Connecting to user provided url " + e);
    const t = e || this.netWebSocketUrlProvider?.getWebsocketUrl();
    return t ? Mi = t : NS() && (Mi = "wss://" + window.location.host + "/socket"), this.connectWebsocket();
  }
  /** Disconnect from the networking backend + reset internal state */
  disconnect() {
    this._ws?.close(), this._ws = void 0, Mi = void 0, this._currentRoomAllowEditing = !0, this._currentRoomName = null, this._currentRoomViewId = null, this._isInRoom = !1, this._currentInRoom.length = 0, this._state = {}, this._currentDelay = -1;
  }
  _listeners = {};
  _listenersBinary = {};
  connected = !1;
  channelId;
  _connectionId = null;
  // Websocket ------------------------------------------------------------
  _ws;
  _waitingForSocket = {};
  _isInRoom = !1;
  _currentRoomName = null;
  _currentRoomViewId = null;
  _currentRoomAllowEditing = !0;
  _currentInRoom = [];
  _state = {};
  _currentDelay = -1;
  _connectingToWebsocketPromise = null;
  connectWebsocket() {
    return this._connectingToWebsocketPromise ? this._connectingToWebsocketPromise : this._connectingToWebsocketPromise = new Promise(async (e, t) => {
      let i = !1;
      const n = (c) => {
        i || (i = !0, e(c));
      };
      if (Mi === void 0 && (console.log("Fetch default backend url: " + Oy), Mi = await (await fetch(Oy)).text()), Mi === void 0) {
        n(!1);
        return;
      }
      console.debug(`⊡ Connecting to networking backend on
` + Mi);
      const o = await import("./vendor-Z4SPrTcP.js").then((c) => c.index), r = o.default?.WebsocketBuilder ?? o.WebsocketBuilder, a = o.default?.ExponentialBackoff ?? o.ExponentialBackoff, l = new r(Mi).withMaxRetries(10).withBackoff(new a(2e3, 4)).onOpen(() => {
        this._connectingToWebsocketPromise = null, this._ws = l, this.connected = !0, L() || oi ? console.log(`⊞ Connected to networking backend
` + Mi) : console.debug("⊞ Connected to networking backend", Mi), n(!0), this.onSendQueued(vn.OnConnection);
      }).onClose((c) => {
        this._connectingToWebsocketPromise = null, this.connected = !1, this._isInRoom = !1, n(!1);
        let h = "Websocket connection closed...";
        Mi?.includes("/socket") || (h += ' Do you perhaps mean to connect to "/socket"?'), console.error(h);
      }).onError((c) => {
        console.error("⊠ Websocket connection failed..."), n(!1);
      }).onRetry(() => {
        console.log("→ Retry connecting to networking websocket");
      }).build();
      l.addEventListener(o.WebsocketEvent.message, (c, h) => {
        this.onMessage(c, h);
      });
    });
  }
  onMessage(e, t) {
    const i = t.data;
    try {
      if (typeof i != "string") {
        i.size && this.handleIncomingBinaryMessage(i);
        return;
      }
      const n = JSON.parse(i);
      if (Array.isArray(n))
        for (const o of n)
          this.handleIncomingStringMessage(o);
      else this.handleIncomingStringMessage(n);
      return;
    } catch (n) {
      oi && i === "pong" ? console.log("<<", i) : L() && console.error("Failed to parse message", n);
    }
  }
  async handleIncomingBinaryMessage(e) {
    Kc && console.log("<< bin", this.context.time.frame);
    const t = await e.arrayBuffer();
    var i = new Uint8Array(t);
    const n = new RS(i), o = n.getBufferIdentifier(), r = this._listenersBinary[o], a = p1(n), l = m1(a);
    if (l && typeof l == "string" && (this._state[l] = a), !r) return;
    const c = a ?? n;
    for (const h of r)
      h(c);
  }
  handleIncomingStringMessage(e) {
    if (oi && console.log("<<", e.key ?? e), e.key)
      switch (e.key) {
        case "connection-start-info":
          if (e.data) {
            const r = e.data;
            r && (console.assert(
              r.id !== void 0 && r.id !== null && r.id.length > 0,
              "server did not send connection id",
              r.id
            ), console.debug("Your id is: " + r.id, this.context.alias ?? ""), this._connectionId = r.id);
          } else console.warn("Expected connection id in " + e.key);
          break;
        case "joined-room":
          if (oi && console.log(e), e) {
            this._isInRoom = !0;
            const r = e;
            this._currentRoomName = r.room, this._currentRoomViewId = r.viewId, this._currentRoomAllowEditing = r.allowEditing ?? !0, this._currentInRoom.length = 0, this._currentInRoom.push(...r.inRoom), (Kc || L()) && console.debug("Joined Needle Engine Room: " + r.room);
            const a = new URL(window.location.href);
            a.searchParams.has("room") && a.searchParams.delete("room"), a.searchParams.set("view", this._currentRoomViewId), console.debug(`Room view id: ${this._currentRoomViewId}
${a.href}`);
          }
          this.onSendQueued(vn.OnRoomJoin);
          break;
        case "left-room":
          const n = e;
          n.room === this.currentRoomName && (this._isInRoom = !1, this._currentRoomName = null, this._currentRoomAllowEditing = !0, this._currentInRoom.length = 0, (Kc || L()) && console.debug("Left Needle Engine Room: " + n.room));
          break;
        case "user-joined-room":
          if (e.data) {
            const r = e.data;
            this._currentInRoom.push(r.userId), oi && console.log(r.userId + " joined", "now in room:", this._currentInRoom);
          }
          break;
        case "user-left-room":
          if (e.data) {
            const r = e.data, a = this._currentInRoom.indexOf(r.userId);
            a >= 0 && (oi && console.log(r.userId + " left", "now in room:", this._currentInRoom), this._currentInRoom.splice(a, 1)), r.userId === this.connectionId && console.log("you left the room");
          }
          break;
        case "all-room-state-deleted":
          oi && console.log("RECEIVED all-room-state-deleted"), this._state = {};
          break;
        case "ping":
        case "pong":
          const o = e.data?.time;
          o && (this._currentDelay = this.context.time.time - o), oi && console.log(`Current latency: ${(this._currentDelay * 1e3).toFixed()} ms`, "Clients in room: " + this._currentInRoom?.length);
          break;
      }
    const t = e.data;
    t && (this._state[t.guid] = t);
    let i = this._listeners[e.key];
    if (i) {
      i = [...i];
      for (const n of i)
        try {
          n(e.data);
        } catch (o) {
          console.error('Error invoking callback for "' + e.key + '"', o);
        }
    }
  }
  toMessage(e, t) {
    return {
      key: e,
      data: t
    };
  }
  sendWithWebsocket(e, t, i = vn.OnRoomJoin) {
    if (!this._ws) {
      const o = this._waitingForSocket[i] || [];
      o.push(() => this.sendWithWebsocket(e, t, i)), this._waitingForSocket[i] = o;
      return;
    }
    const n = JSON.stringify(this.toMessage(e, t));
    oi && console.log(">>", e), this._ws.send(n);
  }
  onSendQueued(e) {
    const t = this._waitingForSocket[e];
    if (t) {
      for (const i of t)
        i();
      t.length = 0;
    }
  }
}
const Fl = w("debugwebxr");
class tf {
  controllerStates = [];
  userId;
  context;
  userStateEvtName;
  constructor(e, t) {
    this.userId = e, this.context = t, this.userStateEvtName = "xr-sync-user-state-" + e, this.context.connection.beginListen(this.userStateEvtName, this.onReceivedControllerState);
  }
  dispose() {
    this.context.connection.stopListen(this.userStateEvtName, this.onReceivedControllerState);
  }
  onReceivedControllerState = (e) => {
    Fl && console.log(`XRSync: Received change for ${this.userId}: ${e.type} ${e.handedness}; tracked=${e.isTracking}`);
    let t = !1;
    for (let i = 0; i < this.controllerStates.length; i++)
      if (this.controllerStates[i].index === e.index) {
        this.controllerStates[i] = e, t = !0;
        break;
      }
    t || this.controllerStates.push(e);
  };
  update(e) {
    if (this.context.connection.isConnected != !1) {
      for (let t = this.controllerStates.length - 1; t >= 0; t--) {
        const i = this.controllerStates[t];
        let n = !1;
        for (let o = 0; o < e.controllers.length; o++)
          e.controllers[o].index === i.index && (n = !0);
        n || (Fl && console.log(`XRSync: ${i.type} ${i.handedness} removed`, i.index), this.controllerStates.splice(t, 1), this.sendControllerRemoved(i));
      }
      for (const t of e.controllers)
        this.updateControllerStates(t);
    }
  }
  onExitXR(e) {
    for (const t of this.controllerStates)
      this.sendControllerRemoved(t);
    this.controllerStates.length = 0;
  }
  sendControllerRemoved(e) {
    e.isTracking = !1, e.guid = "", this.context.connection.send(this.userStateEvtName, e), this.context.connection.sendDeleteRemoteState(e.guid);
  }
  updateControllerStates(e) {
    const t = this.controllerStates.find((i) => i.index === e.index);
    if (t) {
      let i = !1;
      i ||= t.isTracking != e.isTracking, i && (t.isTracking = e.isTracking, this.context.connection.send(this.userStateEvtName, t));
    } else {
      const i = {
        guid: this.userId + "-" + e.index,
        isTracking: e.isTracking,
        handedness: e.side,
        index: e.index,
        type: e.hand ? "hand" : "controller"
      };
      this.controllerStates.push(i), this.context.connection.send(this.userStateEvtName, i), Fl && console.log(`XRSync: ${i.type} ${i.handedness} added`, i.index);
    }
  }
}
class S1 {
  hasState(e) {
    return e ? this._states.has(e) : !1;
  }
  /** Is the left controller or hand tracked */
  isTracking(e, t) {
    if (!e) return;
    const i = this._states.get(e);
    return i ? i.controllerStates.find((o) => o.handedness === t)?.isTracking || !1 : void 0;
  }
  /** Is it hand tracking or a controller */
  getDeviceType(e, t) {
    if (!e) return;
    const i = this._states.get(e);
    return i ? i.controllerStates.find((o) => o.handedness === t)?.type || "unknown" : void 0;
  }
  context;
  constructor(e) {
    this.context = e, this.context.connection.beginListen(ee.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ee.LeftRoom, this.onLeftRoom), this.context.connection.beginListen(ee.UserJoinedRoom, this.onOtherUserJoinedRoom), this.context.connection.beginListen(ee.UserLeftRoom, this.onOtherUserLeftRoom);
  }
  destroy() {
    this.context.connection.stopListen(ee.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ee.LeftRoom, this.onLeftRoom), this.context.connection.stopListen(ee.UserJoinedRoom, this.onOtherUserJoinedRoom), this.context.connection.stopListen(ee.UserLeftRoom, this.onOtherUserLeftRoom);
  }
  onJoinedRoom = () => {
    if (this.context.connection.connectionId) {
      this._states.has(this.context.connection.connectionId) || (Fl && console.log("XRSync: Local user joined room", this.context.connection.connectionId), this._states.set(this.context.connection.connectionId, new tf(this.context.connection.connectionId, this.context)));
      for (const e of this.context.connection.usersInRoom())
        this._states.has(e) || this._states.set(e, new tf(e, this.context));
    }
  };
  onLeftRoom = () => {
    this.context.connection.connectionId && (this._states.has(this.context.connection.connectionId) || (this._states.get(this.context.connection.connectionId)?.dispose(), this._states.delete(this.context.connection.connectionId)));
  };
  onOtherUserJoinedRoom = (e) => {
    const t = e.userId;
    this._states.has(t) || (Fl && console.log("XRSync: Remote user joined room", t), this._states.set(t, new tf(t, this.context)));
  };
  onOtherUserLeftRoom = (e) => {
    const t = e.userId;
    this._states.has(t) || (this._states.get(t)?.dispose(), this._states.delete(t));
  };
  _states = /* @__PURE__ */ new Map();
  onUpdate(e) {
    this.context.connection.isConnected && this.context.connection.connectionId && this._states.get(this.context.connection.connectionId)?.update(e);
  }
  onExitXR(e) {
    this.context.connection.isConnected && this.context.connection.connectionId && this._states.get(this.context.connection.connectionId)?.onExitXR(e);
  }
}
class ky {
  _fadeToColorQuad;
  _fadeToColorMaterial;
  constructor() {
    this._fadeToColorMaterial = new we({
      color: 0,
      transparent: !0,
      depthTest: !1,
      fog: !1,
      side: yi
    }), this._fadeToColorQuad = new H(new Un(10, 10), this._fadeToColorMaterial);
  }
  dispose() {
    this._fadeToColorQuad.geometry.dispose(), this._fadeToColorMaterial.dispose();
  }
  update(e, t) {
    const i = this._fadeToColorQuad, n = this._fadeToColorMaterial;
    i.parent !== e && n.opacity > 0 ? e.add(i) : n.opacity === 0 && i.removeFromParent(), i.layers.set(2), i.material = this._fadeToColorMaterial, i.position.z = -1, i.renderOrder = 1 / 0;
    const o = this._requestedFadeValue;
    n.opacity = j.lerp(n.opacity, o, t / 0.03), Math.abs(n.opacity - o) <= 0.01 && this._transitionResolve && (this._transitionResolve(), this._transitionResolve = null, this._transitionPromise = null, this._requestedFadeValue = 0);
  }
  remove() {
    this._fadeToColorQuad.removeFromParent();
  }
  /** Call to fade rendering to black for a short moment (the returned promise will be resolved when fully black)   
   * This can be used to mask scene transitions or teleportation
   * @returns a promise that is resolved when the screen is fully black
   * @example `fadeTransition().then(() => { <fully_black> })`
  */
  fadeTransition() {
    if (this._transitionPromise) return this._transitionPromise;
    this._requestedFadeValue = 1;
    const e = new Promise((t) => {
      this._transitionResolve = t;
    });
    return this._transitionPromise = e, e;
  }
  _requestedFadeValue = 0;
  _transitionPromise = null;
  _transitionResolve = null;
}
var ma = /* @__PURE__ */ ((s) => (s[s.Quad = 0] = "Quad", s[s.Cube = 1] = "Cube", s[s.Sphere = 2] = "Sphere", s[s.Cylinder = 3] = "Cylinder", s[s.RoundedCube = 10] = "RoundedCube", s))(ma || {});
class Oa {
  /**
   * Creates a 3D text object
   * @param text The text to display
   * @param opts Options to create the object
   */
  static createText(e, t) {
    let i = null;
    const n = t?.font || P1(t?.familyFamily || null);
    n instanceof lS ? i = this.#t(e, n, t) : i == null && (i = new Tn());
    const o = t?.color || 16777215, r = new H(i, t?.material ?? new ct({ color: o }));
    return this.applyDefaultObjectOptions(r, t), n instanceof Promise ? n.then((a) => {
      r.geometry = this.#t(e, a, t), t?.onGeometry && t.onGeometry(r);
    }) : t?.onGeometry && t.onGeometry(r), r;
  }
  static #t(e, t, i) {
    const n = i?.depth || 0.1;
    return new cS(e, {
      font: t,
      size: 1,
      depth: n,
      height: n,
      bevelEnabled: i?.bevel || !1,
      bevelThickness: 0.01,
      bevelOffset: 0.01,
      bevelSize: 0.01
    });
  }
  /**
   * Creates an occluder object that only render depth but not color
   * @param type The type of primitive to create
   * @returns The created object
   */
  static createOccluder(e) {
    const t = new we({ colorWrite: !1, depthWrite: !0, side: yi });
    return this.createPrimitive(e, { material: t });
  }
  static createPrimitive(e, t) {
    let i;
    const n = t?.color || 16777215;
    switch (e) {
      case "Quad":
      case 0:
        {
          const o = new Un(1, 1, 1, 1), r = t?.material ?? new ct({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new H(o, r), i.name = "Quad";
        }
        break;
      case "Cube":
      case 1:
        {
          const o = new la(1, 1, 1), r = t?.material ?? new ct({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new H(o, r), i.name = "Cube";
        }
        break;
      case 10:
      case "RoundedCube":
        {
          const o = C1(1, 1, 1, 0.1, 2), r = t?.material ?? new ct({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new H(o, r), i.name = "RoundedCube";
        }
        break;
      case "Sphere":
      case 2:
        {
          const o = new Ed(0.5, 16, 16), r = t?.material ?? new ct({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new H(o, r), i.name = "Sphere";
        }
        break;
      case "Cylinder":
      case 3:
        {
          const o = new ab(0.5, 0.5, 1, 32), r = t?.material ?? new ct({ color: n });
          t?.texture && "map" in r && (r.map = t.texture), i = new H(o, r), i.name = "Cylinder";
        }
        break;
      case "ShaderBall":
        i = new io(), i.name = "ShaderBall", O1(i, t);
        break;
    }
    return this.applyDefaultObjectOptions(i, t), i;
  }
  /**
   * Creates a Sprite object  
   * @param opts Options to create the object
   * @returns The created object
   */
  static createSprite(e) {
    const i = new Vw({ color: 16777215 });
    e?.texture && "map" in i && (i.map = e.texture);
    const n = new Hw(i);
    return this.applyDefaultObjectOptions(n, e), n;
  }
  static applyDefaultObjectOptions(e, t) {
    e.receiveShadow = !0, e.castShadow = !0, t?.name && (e.name = t.name), t?.position && (Array.isArray(t.position) ? e.position.set(t.position[0], t.position[1], t.position[2]) : e.position.set(t.position.x, t.position.y, t.position.z)), t?.rotation && (Array.isArray(t.rotation) ? e.rotation.set(t.rotation[0], t.rotation[1], t.rotation[2]) : e.rotation.set(t.rotation.x, t.rotation.y, t.rotation.z)), t?.scale && (typeof t.scale == "number" ? e.scale.set(t.scale, t.scale, t.scale) : Array.isArray(t.scale) ? e.scale.set(t.scale[0], t.scale[1], t.scale[2]) : e.scale.set(t.scale.x, t.scale.y, t.scale.z)), t?.receiveShadow != null && (e.receiveShadow = t.receiveShadow), t?.castShadow != null && (e.castShadow = t.castShadow), t?.parent && t.parent.add(e);
  }
}
function C1(s, e, t, i, n) {
  const o = new Gw(), r = 1e-5, a = i - r;
  o.absarc(r, r, r, -Math.PI / 2, -Math.PI, !0), o.absarc(r, e - a * 2, r, Math.PI, Math.PI / 2, !0), o.absarc(s - a * 2, e - a * 2, r, Math.PI / 2, 0, !0), o.absarc(s - a * 2, r, r, 0, -Math.PI / 2, !0);
  const l = new qw(o, {
    bevelEnabled: !0,
    bevelSegments: n * 2,
    steps: 1,
    bevelSize: a,
    bevelThickness: i,
    curveSegments: n,
    UVGenerator: {
      generateTopUV: (c, h) => {
        const d = [];
        for (let f = 0; f < h.length; f += 3)
          d.push(new J(h[f] / s, h[f + 1] / e));
        return d;
      },
      generateSideWallUV: (c, h, d, f, p, g) => {
        const _ = [];
        return _.push(new J(h[d] / s, h[d + 1] / e)), _.push(new J(h[f] / s, h[f + 1] / e)), _.push(new J(h[p] / s, h[p + 1] / e)), _.push(new J(h[g] / s, h[g + 1] / e)), _;
      }
    }
  });
  return l.scale(1, 1, 1 - i), l.center(), l.index || l.setIndex(Array.from({ length: l.attributes.position.count }, (c, h) => h)), l.computeVertexNormals(), l;
}
const Zc = /* @__PURE__ */ new Map();
function P1(s) {
  let e = "";
  switch (s) {
    default:
    case "OpenSans":
      e = "https://cdn.needle.tools/static/fonts/facetype/Open Sans_Regular_ascii.json";
      break;
    case "Helvetiker":
      e = "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json";
      break;
  }
  if (Zc.has(e)) {
    const n = Zc.get(e);
    if (n) return n;
  }
  const t = new hS(), i = new Promise((n, o) => {
    t.load(e, (r) => {
      Zc.set(e, r), n(r);
    }, void 0, o);
  });
  return Zc.set(e, i), i;
}
let nf = !1, sf = null;
function O1(s, e) {
  if (sf === null) {
    const t = "https://cdn.needle.tools/static/models/shaderball.glb", i = new Ps(), n = mm(null);
    i.setDRACOLoader(n.dracoLoader), i.setKTX2Loader(n.ktx2Loader), nf = !0, sf = i.loadAsync(t).then((o) => {
      const r = o.scene;
      return r.position.y -= 0.5, r;
    }).catch((o) => (console.warn("Failed to load shaderball mesh: " + o.message), Ry())).finally(() => {
      nf = !1;
    });
  }
  if (nf) {
    const t = Ry();
    t.name = "ShaderBall-Placeholder";
    const i = t.children[0];
    i?.type === "Mesh" && My(i, e), s.add(t);
  }
  sf.then((t) => {
    s.children.forEach((o) => {
      o.name === "ShaderBall-Placeholder" && s.remove(o);
    });
    const i = t.clone(), n = i.children[0];
    n?.type === "Mesh" && (n.geometry.attributes.tangent || n.geometry.computeTangents(), My(n, e)), s.add(i);
  });
}
function My(s, e) {
  if (e?.color || e?.material || e?.texture) {
    const i = e?.material ?? s.material?.clone() ?? new ct();
    e.color && "color" in i && i.color instanceof se && i.color.set(e.color), e?.texture && "map" in i && (i.map = e.texture), s.material = i;
  }
}
function Ry() {
  return new io().add(Oa.createPrimitive("Sphere", { material: new we({ transparent: !0, opacity: 0.1 }) }));
}
class ga {
  static _active = null;
  static get active() {
    return this._active;
  }
  static _requestInFlight = !1;
  static async start(e, t) {
    if (this._active)
      return console.error("Cannot start a new XR session while one is already active"), null;
    if (this._requestInFlight)
      return console.error("Cannot start a new XR session while a request is already in flight"), null;
    if ("xr" in navigator && navigator.xr) {
      if (!t)
        return console.error("XRSessionInit must be provided"), null;
      this._requestInFlight = !0;
      const i = await navigator.xr.requestSession(e, t);
      return i.addEventListener("end", () => {
        this._active = null;
      }), this._requestInFlight ? (this._requestInFlight = !1, this._active = new ga(e, t, i), this._active) : (i.end(), null);
    }
    return null;
  }
  static async handoff() {
    return this._active ? this._active.handoff() : null;
  }
  static async stop() {
    this._requestInFlight = !1, this._active && (await this._active.end(), await Os(100)), this._active = null;
  }
  _session;
  _mode;
  _init;
  get isAR() {
    return this._mode === "immersive-ar";
  }
  _renderer;
  _camera;
  _scene;
  constructor(e, t, i) {
    this._mode = e, this._init = t, this._session = i, this._session.addEventListener("end", this.onEnd), this._renderer = new ur({ alpha: !0 }), this._renderer.setAnimationLoop(this.onFrame), this._renderer.xr.setSession(i), this._renderer.xr.enabled = !0, this._camera = new pe(), this._scene = new gi(), this._scene.fog = new lb(4473924, 10, 250), this._scene.add(this._camera), this.setupScene();
  }
  end() {
    return this._session ? this._session.end() : Promise.resolve();
  }
  /** returns the session and session info and stops the temporary rendering */
  async handoff() {
    if (!this._session) throw new Error("Cannot handoff a session that has already ended");
    const e = {
      session: this._session,
      mode: this._mode,
      init: this._init
    };
    return await this.onBeforeHandoff(), this.onEnd(), this._session = null, e;
  }
  onEnd = () => {
    this._session?.removeEventListener("end", this.onEnd), this._renderer.setAnimationLoop(null), this._renderer.dispose(), this._scene.clear();
  };
  _lastTime = 0;
  onFrame = (e, t) => {
    const i = e - this._lastTime;
    this.update(e, i), this._camera.parent !== this._scene && this._scene.add(this._camera), this._renderer.render(this._scene, this._camera);
  };
  /** can be used to prepare the user or fade to black */
  async onBeforeHandoff() {
    await Os(1e3), this._scene.clear();
  }
  _objects = [];
  setupScene() {
    this._scene.background = new se(0), this._scene.add(new am(5, 10, 1118481, 1118481));
    const e = new ip(16777215, 1);
    e.position.set(0, 20, 0), e.castShadow = !1, this._scene.add(e);
    const t = new ip(16777215, 1);
    t.position.set(0, -1, 0), t.castShadow = !1, this._scene.add(t);
    const i = new lm(16777215, 1, 100, 1);
    i.position.set(0, 2, 0), i.castShadow = !1, i.distance = 200, this._scene.add(i);
    const n = 50;
    for (let o = 0; o < 100; o++) {
      const r = new ct({
        color: 2236962,
        metalness: 1,
        roughness: 0.8
      });
      this.isAR && (r.emissive = new se(Math.random(), Math.random(), Math.random()), r.emissiveIntensity = Math.random());
      const a = j.random(0, 1) > 0.5 ? ma.Sphere : ma.Cube, l = Oa.createPrimitive(a, {
        material: r
      });
      l.position.x = j.random(-n, n), l.position.y = j.random(-2, n), l.position.z = j.random(-n, n), l.rotation.x = j.random(0, Math.PI * 2), l.rotation.y = j.random(0, Math.PI * 2), l.rotation.z = j.random(0, Math.PI * 2), l.scale.multiplyScalar(0.5 + Math.random() * 10);
      const c = l.position.distanceTo(this._camera.position) - l.scale.x;
      c < 1 && l.position.multiplyScalar(1 + 1 / c), this._objects.push(l), this._scene.add(l);
    }
  }
  update(e, t) {
    const i = e * 4e-4;
    for (let n = 0; n < this._objects.length; n++) {
      const o = this._objects[n];
      o.position.y += Math.sin(i + n * 0.5) * 5e-3, o.rotateY(2e-3);
    }
  }
}
var ic;
((s) => {
  const e = [];
  function t() {
    if (!e?.length) return !1;
    for (const o of e)
      o.exportAndOpen();
    return !0;
  }
  s.exportAndOpen = t;
  function i(o) {
    e.push(o);
  }
  s.registerExporter = i;
  function n(o) {
    if (!e) return;
    const r = e.indexOf(o);
    r >= 0 && e.splice(r, 1);
  }
  s.unregisterExporter = n;
})(ic || (ic = {}));
const He = w("debugwebxr"), Ty = w("stats");
let of = 0;
function k1(s) {
  let e = null;
  const t = s;
  return t.getAROverlayContainer ? e = t.getAROverlayContainer() : e = s, e;
}
M1();
async function M1() {
  if (w("debugasap")) {
    let s = globalThis["needle:XRSession"];
    if (s instanceof Promise) {
      delete globalThis["needle:XRSession"], he.addContextCreatedCallback(async (e) => {
        if (!s) return;
        Yr(!0);
        const t = await s;
        if (t) {
          const i = K.getDefaultSessionInit("immersive-vr");
          K.setSession("immersive-vr", t, i, e.context);
        } else
          console.error("NeedleXRSession: ASAP session was rejected");
        s = void 0;
      });
      return;
    }
  }
  if ("xr" in navigator) {
    if (/WebXRViewer\//i.test(navigator.userAgent)) {
      console.warn("WebXRViewer does not support addEventListener");
      return;
    }
    navigator.xr?.addEventListener("sessiongranted", async () => {
      Yr(!0), console.log("Received Session Granted..."), await Os(100);
      const s = sessionStorage.getItem("needle_xr_session_mode"), e = sessionStorage.getItem("needle_xr_session_init") ?? null, t = e ? JSON.parse(e) : null;
      let i = null;
      if (n0() && (await ga.start(s || "immersive-vr", t || K.getDefaultSessionInit("immersive-vr")), await E1(), i = await ga.handoff()), i)
        K.setSession(i.mode, i.session, i.init, N.Current);
      else if (s && e) {
        console.log("Session Granted: Restore last session");
        const n = JSON.parse(e);
        K.start(s, n).catch((o) => console.warn(o));
      } else
        K.start("immersive-vr").catch((n) => console.warn("Session Granted failed:", n));
    }, { once: !0 });
  }
}
function R1(s, e) {
  sessionStorage.setItem("needle_xr_session_mode", s), sessionStorage.setItem("needle_xr_session_init", JSON.stringify(e));
}
function T1() {
  sessionStorage.removeItem("needle_xr_session_mode"), sessionStorage.removeItem("needle_xr_session_init");
}
const Rm = /* @__PURE__ */ new Set();
he.registerCallback(ce.ContextCreationStart, async (s) => {
  Rm.add(s.context);
});
he.registerCallback(ce.ContextCreated, async (s) => {
  Rm.delete(s.context);
  const e = s.context?.domElement.getAttribute("autostart") || null;
  A1(e);
});
function n0() {
  return Rm.size > 0;
}
function E1() {
  return new Promise((s) => {
    const e = Date.now(), t = setInterval(() => {
      (!n0() || Date.now() - e > 6e4) && (clearInterval(t), s());
    }, 100);
  });
}
X.isDesktop() && L() && window.addEventListener("keydown", (s) => {
  (s.key === "x" || s.key === "Escape") && K.active && K.stop();
});
function A1(s) {
  if (s)
    switch (s?.toLowerCase()) {
      case "ar":
        Bn.registerWaitForInteraction(() => {
          K.start("ar");
        });
        break;
    }
}
class K {
  static _sync = null;
  static getXRSync(e) {
    return this._sync || (this._sync = new S1(e)), this._sync;
  }
  static get currentSessionRequest() {
    return this._currentSessionRequestMode;
  }
  static _currentSessionRequestMode = null;
  /**
   * @returns the active @type {NeedleXRSession} (if any active) or null
   */
  static get active() {
    return this._activeSession;
  }
  /** The active xr session mode (if any xr session is active) 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSessionMode
  */
  static get activeMode() {
    return this._activeSession?.mode ?? null;
  }
  /** XRSystem via navigator.xr access
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem
   */
  static get xrSystem() {
    return "xr" in navigator ? navigator.xr : void 0;
  }
  /**
   * @returns true if the browser supports WebXR (`immersive-vr` or `immersive-ar`)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
   */
  static isXRSupported() {
    return Promise.all([this.isVRSupported(), this.isARSupported()]).then((e) => e.some((t) => t)).catch(() => !1);
  }
  /** 
   * @returns true if the browser supports immersive-vr (WebXR)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
   */
  static isVRSupported() {
    return this.isSessionSupported("immersive-vr");
  }
  /** 
   * @returns true if the browser supports immersive-ar (WebXR) 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
  */
  static isARSupported() {
    return this.isSessionSupported("immersive-ar");
  }
  /**
   * @param mode The XRSessionMode to check if it is supported
   * @returns true if the browser supports the given XRSessionMode
   */
  static isSessionSupported(e) {
    return this.xrSystem?.isSessionSupported(e).catch((t) => (He && console.error(t), !1)) ?? Promise.resolve(!1);
  }
  static _currentSessionRequest;
  static _activeSession;
  /** Register to listen to XRSession start events. Unsubscribe with `offXRSessionStart` */
  static onSessionRequestStart(e) {
    this._sessionRequestStartListeners.push(e);
  }
  /** Unsubscribe from request start evt. Register with `onSessionRequestStart` */
  static offSessionRequestStart(e) {
    const t = this._sessionRequestStartListeners.indexOf(e);
    t >= 0 && this._sessionRequestStartListeners.splice(t, 1);
  }
  static _sessionRequestStartListeners = [];
  /** Called after the session request has finished */
  static onSessionRequestEnd(e) {
    this._sessionRequestEndListeners.push(e);
  }
  /** Unsubscribe from request end evt */
  static offSessionRequestEnd(e) {
    const t = this._sessionRequestEndListeners.indexOf(e);
    t >= 0 && this._sessionRequestEndListeners.splice(t, 1);
  }
  static _sessionRequestEndListeners = [];
  /** Listen to XR session started. Unsubscribe with `offXRSessionStart` */
  static onXRSessionStart(e) {
    this._xrStartListeners.push(e);
  }
  /** Unsubscribe from XRSession started events */
  static offXRSessionStart(e) {
    const t = this._xrStartListeners.indexOf(e);
    t >= 0 && this._xrStartListeners.splice(t, 1);
  }
  static _xrStartListeners = [];
  /** Listen to XR session ended. Unsubscribe with `offXRSessionEnd` */
  static onXRSessionEnd(e) {
    this._xrEndListeners.push(e);
  }
  /** Unsubscribe from XRSession started events */
  static offXRSessionEnd(e) {
    const t = this._xrEndListeners.indexOf(e);
    t >= 0 && this._xrEndListeners.splice(t, 1);
  }
  static _xrEndListeners = [];
  /** Listen to controller added events. 
   * Events are cleared when starting a new session 
   **/
  static onControllerAdded(e) {
    this._controllerAddedListeners.push(e);
  }
  /** Unsubscribe from controller added evts */
  static offControllerAdded(e) {
    const t = this._controllerAddedListeners.indexOf(e);
    t >= 0 && this._controllerAddedListeners.splice(t, 1);
  }
  static _controllerAddedListeners = [];
  /** Listen to controller removed events 
   * Events are cleared when starting a new session 
   **/
  static onControllerRemoved(e) {
    this._controllerRemovedListeners.push(e);
  }
  /** Unsubscribe from controller removed events */
  static offControllerRemoved(e) {
    const t = this._controllerRemovedListeners.indexOf(e);
    t >= 0 && this._controllerRemovedListeners.splice(t, 1);
  }
  static _controllerRemovedListeners = [];
  /** If the browser supports offerSession - creating a VR or AR button in the browser navigation bar */
  static offerSession(e, t, i) {
    return "xr" in navigator && navigator.xr && "offerSession" in navigator.xr ? (typeof navigator.xr.offerSession == "function" && (console.log("WebXR offerSession is available - requesting mode: " + e), t == "default" && (t = this.getDefaultSessionInit(e)), navigator.xr.offerSession(e, {
      ...t
    }).then((n) => K.setSession(e, n, t, i)).catch((n) => {
      console.log("XRSession offer rejected (perhaps because another call to offerSession was made or a call to requestSession was made)");
    })), !0) : !1;
  }
  /** @returns a new XRSession init object with defaults */
  static getDefaultSessionInit(e) {
    switch (e) {
      case "immersive-ar":
        const t = ["anchors", "local-floor", "layers", "dom-overlay", "hit-test", "unbounded"];
        return X.isVisionOS() || t.push("hand-tracking"), {
          optionalFeatures: t
        };
      case "immersive-vr":
        const i = ["local-floor", "bounded-floor", "high-fixed-foveation-level", "layers"];
        return X.isVisionOS() || i.push("hand-tracking"), {
          optionalFeatures: i
        };
      default:
        return console.warn("No default session init for mode", e), {};
    }
  }
  /** start a new webXR session (make sure to stop already running sessions before calling this method)
   * @param mode The XRSessionMode to start (e.g. `immersive-vr` or `immersive-ar`) or `ar` to start `immersive-ar` on supported devices OR on iOS devices it will export an interactive USDZ and open in Quicklook.  
   * Get more information about WebXR modes: https://developer.mozilla.org/en-US/docs/Web/API/XRSessionMode
   * @param init The XRSessionInit to use (optional), docs: https://developer.mozilla.org/en-US/docs/Web/API/XRSessionInit
   * @param context The Needle Engine context to use
   */
  static async start(e, t, i) {
    if (X.isiOS()) {
      if (e === "ar")
        if (await this.isARSupported())
          e = "immersive-ar";
        else
          return ic.exportAndOpen(), null;
    } else e == "ar" && (e = "immersive-ar");
    if (L() && w("debugxrpreroom"))
      return console.warn("Debug: Starting temporary XR session"), await ga.start(e, t || K.getDefaultSessionInit(e)), null;
    if (this._currentSessionRequest)
      return console.warn("A XRSession is already being requested"), (He || L()) && ge("A XRSession is already being requested"), this._currentSessionRequest.then(() => this._activeSession);
    if (this._activeSession)
      return console.error("A XRSession is already running"), this._activeSession;
    if (i || (i = N.Current), i || (i = he.All[0]), !i) throw new Error("No Needle Engine Context found");
    switch (t || (t = {}), e) {
      // Setup VR initialization parameters
      case "immersive-ar":
        {
          if (await this.xrSystem?.isSessionSupported("immersive-ar") !== !0)
            return console.error(e + " is not supported by this browser."), null;
          const l = this.getDefaultSessionInit(e), c = k1(i.domElement);
          c && !X.isQuest() && (l.domOverlay = { root: c }, l.optionalFeatures.push("dom-overlay")), t = {
            ...l,
            ...t
          };
        }
        break;
      // Setup AR initialization parameters
      case "immersive-vr":
        {
          if (await this.xrSystem?.isSessionSupported("immersive-vr") !== !0)
            return console.error(e + " is not supported by this browser."), null;
          t = {
            ...this.getDefaultSessionInit(e),
            ...t
          };
        }
        break;
      default:
        console.warn("No default session init for mode", e);
        break;
    }
    t.optionalFeatures ??= [], t.requiredFeatures ??= [], await ga.stop();
    const n = e == "immersive-ar" ? i.scripts_immersive_ar : i.scripts_immersive_vr;
    He ? console.log(`%cRequesting ${e} session`, "font-weight:bold;", t, n) : console.log(`%cRequesting ${e} session`, "font-weight:bold;");
    for (const a of n)
      a.onBeforeXR && a.onBeforeXR(e, t);
    for (const a of this._sessionRequestStartListeners)
      a({ mode: e, init: t });
    He && Be("Requesting " + e + " session (" + Date.now() + ")"), this._currentSessionRequest = navigator.xr?.requestSession(e, t), this._currentSessionRequestMode = e;
    const o = await this._currentSessionRequest?.catch((a) => {
      console.error(a, "Code: " + a.code), a.code === 9 && ge("Make sure your device has the required permissions (e.g. camera access)"), console.log("If the specified XR configuration is not supported (e.g. entering AR doesnt work) - make sure you access the website on a secure connection (HTTPS) and your device has the required permissions (e.g. camera access)"), location.protocol === "http:" && ge("XR requires a secure connection (HTTPS)");
    });
    this._currentSessionRequest = void 0, this._currentSessionRequestMode = null;
    for (const a of this._sessionRequestEndListeners)
      a({ mode: e, init: t, newSession: o || null });
    return o ? this.setSession(e, o, t, i) : (console.warn("XR Session request was rejected"), null);
  }
  static setSession(e, t, i, n) {
    if (this._activeSession)
      return console.error("A XRSession is already running"), this._activeSession;
    const o = e == "immersive-ar" ? n.scripts_immersive_ar : n.scripts_immersive_vr;
    return this._activeSession = new K(e, t, n, {
      scripts: o,
      controller_added: this._controllerAddedListeners,
      controller_removed: this._controllerRemovedListeners,
      init: i
    }), t.addEventListener("end", this.onEnd), He ? console.log(`%cStarted ${e} session`, "font-weight:bold;", o) : console.log(`%cStarted ${e} session`, "font-weight:bold;"), this._activeSession;
  }
  static $_stop_request = Symbol();
  /** stops the active XR session */
  static stop() {
    const e = this._activeSession;
    e && (e[this.$_stop_request] === void 0 ? (He && console.log("[NeedleXRSession] Stopping XR Session... (new)"), e[this.$_stop_request] = setTimeout(() => {
      e.end();
    })) : He && console.warn("[NeedleXRSession] XR Session stop already requested"));
  }
  static onEnd = () => {
    He && console.log("XR Session ended"), this._activeSession = null;
  };
  /** The needle engine context this session was started from */
  context;
  get sync() {
    return K._sync;
  }
  /** Returns true if the xr session is still active */
  get running() {
    return !this._ended && this.session != null;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession
   */
  session;
  /** XR Session Mode: AR or VR */
  mode;
  /** 
   * The XRSession interface's read-only interactionMode property describes the best space (according to the user agent) for the application to draw an interactive UI for the current session.
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/interactionMode 
   */
  get interactionMode() {
    return this.session.interactionMode;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/visibilityState
   * @returns {XRVisibilityState} The visibility state of the XRSession
   */
  get visibilityState() {
    return this.session.visibilityState;
  }
  /**
   * Check if the session is `visible-blurred` - this means e.g. the keyboard is shown
   */
  get isVisibleBlurred() {
    return this.session.visibilityState === "visible-blurred";
  }
  /**
   * Check if the session has system keyboard support
   */
  get isSystemKeyboardSupported() {
    return this.session.isSystemKeyboardSupported;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/environmentBlendMode
   */
  get environmentBlendMode() {
    return this.session.environmentBlendMode;
  }
  /** 
   * The current XR frame 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRFrame
   */
  get frame() {
    return this.context.xrFrame;
  }
  /** The currently active/connected controllers */
  controllers = [];
  /** shorthand to query the left controller. Use `controllers` to get access to all connected controllers */
  get leftController() {
    return this.controllers.find((e) => e.side === "left");
  }
  /** shorthand to query the right controller. Use `controllers` to get access to all connected controllers */
  get rightController() {
    return this.controllers.find((e) => e.side === "right");
  }
  /** @returns the given controller if it is connected */
  getController(e) {
    return typeof e == "number" ? this.controllers[e] || null : this.controllers.find((t) => t.side === e) || null;
  }
  /** Returns true if running in pass through mode in immersive AR (e.g. user is wearing a headset while in AR) */
  get isPassThrough() {
    return !!(this.environmentBlendMode !== "opaque" && this.interactionMode === "world-space" || this.mode === "immersive-ar" && this.environmentBlendMode !== "opaque" && this.controllers.some((e) => e.inputSource.targetRayMode === "tracked-pointer") || L() && X.isDesktop() && this.mode === "immersive-ar");
  }
  get isAR() {
    return this.mode === "immersive-ar";
  }
  get isVR() {
    return this.mode === "immersive-vr";
  }
  /** If the AR mode is not immersive (meaning the user is e.g. holding a phone instead of wearing a AR passthrough headset) */
  get isScreenBasedAR() {
    return this.isAR && !this.isPassThrough;
  }
  get posePosition() {
    return this._transformPosition;
  }
  get poseOrientation() {
    return this._transformOrientation;
  }
  /** @returns the context.renderer.xr.getReferenceSpace() result */
  get referenceSpace() {
    return this.context.renderer.xr.getReferenceSpace();
  }
  /** @returns the XRFrame `viewerpose` using the xr `referenceSpace` */
  get viewerPose() {
    return this._viewerPose;
  }
  /** @returns `true` if any image is currently being tracked */
  /** returns true if images are currently being tracked */
  get isTrackingImages() {
    if (this.frame && "getImageTrackingResults" in this.frame && typeof this.frame.getImageTrackingResults == "function")
      try {
        const e = this.frame.getImageTrackingResults();
        for (const t of e)
          if (t.trackingState === "tracked") return !0;
      } catch {
        return !1;
      }
    return !1;
  }
  /** The currently active XR rig */
  get rig() {
    const e = this._rigs[0] ?? null;
    return e?.gameObject && _a(e.gameObject) || e?.isActive === !1 ? (this.updateActiveXRRig(), this._rigs[0] ?? null) : e;
  }
  _rigScale = 1;
  _lastRigScaleUpdate = -1;
  /** Get the XR Rig worldscale.   
   * 
   * **For AR**   
   * If you want to modify the scale in AR at runtime get the WebARSessionRoot component via `findObjectOfType(WebARSessionRoot)` and then set the `arScale` value. 
   * 
  */
  get rigScale() {
    return this._rigs[0] ? (this._lastRigScaleUpdate !== this.context.time.frame && (this._lastRigScaleUpdate = this.context.time.frame, this._rigScale = this._rigs[0].gameObject.worldScale.x), this._rigScale) : 1;
  }
  /** add a rig to the available XR rigs - if it's priority is higher than the currently active rig it will be enabled */
  addRig(e) {
    this._rigs.indexOf(e) >= 0 || (e.priority === void 0 && (e.priority = 0), this._rigs.push(e), this.updateActiveXRRig());
  }
  /** Remove a rig from the available XR Rigs */
  removeRig(e) {
    const t = this._rigs.indexOf(e);
    t !== -1 && (this._rigs.splice(t, 1), this.updateActiveXRRig());
  }
  /** Sets a XRRig to be active which will parent the camera to this rig */
  setRigActive(e) {
    const t = this._rigs.indexOf(e), i = this._rigs[0];
    this._rigs.splice(t, 1), this._rigs.unshift(e), e.priority = i?.priority ?? 0, this.updateActiveXRRig();
  }
  /**
   * @returns the user position in the rig space
   */
  getUserOffsetInRig() {
    const e = this.context.mainCamera?.position;
    if (!e || !this.rig) return G(0, 0, 0);
    const t = G(e);
    return t.x *= -1, t.z *= -1, t.applyQuaternion(bn(this.rig.gameObject.quaternion)), t;
  }
  updateActiveXRRig() {
    const e = this._rigs[0] ?? null;
    this._defaultRig.gameObject.parent !== this.context.scene && this.context.scene.add(this._defaultRig.gameObject), this._defaultRig.gameObject.visible = !0, this._rigs.includes(this._defaultRig) || this._rigs.push(this._defaultRig);
    let t = this._rigs[0];
    t && t.priority === void 0 && (t.priority = 0);
    for (let i = 1; i < this._rigs.length; i++) {
      const n = this._rigs[i];
      if (n.isActive) {
        if (_a(n.gameObject)) {
          this._rigs.splice(i, 1), i--;
          continue;
        }
        (!t || t.isActive === !1 || n.priority !== void 0 && n.priority > t.priority) && (t = n);
      }
    }
    if (e !== t) {
      const i = this._rigs.indexOf(t);
      i >= 0 && this._rigs.splice(i, 1), this._rigs.unshift(t);
    }
    He && (e === t ? console.log("Updated Active XR Rig:", t, "prev:", e) : console.log("Updated Active XRRig:", t, " (the same as before)"));
  }
  _rigs = [];
  _viewerHitTestSource = null;
  /** Returns a XR hit test result (if hit-testing is available) in rig space   
   * @param source If provided, the hit test will be performed for the given controller
  */
  getHitTest(e) {
    if (e)
      return this.getControllerHitTest(e);
    if (!this._viewerHitTestSource) return null;
    const t = this._viewerHitTestSource, i = this.frame.getHitTestResults(t);
    if (i.length > 0) {
      const n = i[0];
      return this.convertHitTestResult(n);
    }
    return null;
  }
  getControllerHitTest(e) {
    const t = e.getHitTestSource();
    if (!t) return null;
    const i = this.frame.getHitTestResultsForTransientInput(t);
    for (const n of i)
      if (n.inputSource === e.inputSource)
        for (const o of n.results)
          return this.convertHitTestResult(o);
    return null;
  }
  convertHitTestResult(e) {
    const t = this.context.renderer.xr.getReferenceSpace(), i = t && e.getPose(t);
    if (i) {
      const n = G(i.transform.position), o = bn(i.transform.orientation), r = this.context.mainCamera;
      if (r?.parent !== this._cameraRenderParent && n.applyMatrix4(Kr), r?.parent) {
        n.applyMatrix4(r.parent.matrixWorld), o.multiply(ji);
        const a = be(r.parent);
        a.premultiply(ji), o.premultiply(a);
      }
      return { hit: e, position: n, quaternion: o };
    }
    return null;
  }
  /** convert a XRRigidTransform from XR session space to threejs / Needle Engine XR space */
  convertSpace(e) {
    const t = G(e.position);
    t.applyMatrix4(Kr);
    const i = bn(e.orientation);
    return i.premultiply(ji), { position: t, quaternion: i };
  }
  /** this is the implictly created XR rig */
  _defaultRig;
  /** all scripts that receive some sort of XR update event */
  _xr_scripts;
  /** scripts that have onUpdateXR event methods */
  _xr_update_scripts = [];
  /** scripts that are in the scene but inactive (e.g. disabled parent gameObject) */
  _inactive_scripts = [];
  _controllerAdded;
  _controllerRemoved;
  _originalCameraWorldPosition;
  _originalCameraWorldRotation;
  _originalCameraWorldScale;
  _originalCameraParent;
  /** we store the main camera reference here each frame to make sure we have a rendering camera
   * this e.g. the case when the XR rig with the camera gets disabled (and thus this.context.mainCamera is unassigned)
   */
  _mainCamera = null;
  constructor(e, t, i, n) {
    R1(e, n.init), this.session = t, this.mode = e, this.context = i, (He || w("console")) && Yr(!0), this._xr_scripts = [...n.scripts], this._xr_update_scripts = this._xr_scripts.filter((o) => typeof o.onUpdateXR == "function"), this._controllerAdded = n.controller_added, this._controllerRemoved = n.controller_removed, ks(this.onBefore, xe.LateUpdate), this.context.pre_render_callbacks.push(this.onBeforeRender), this.context.post_render_callbacks.push(this.onAfterRender), (n.init.optionalFeatures?.includes("hit-test") || n.init.requiredFeatures?.includes("hit-test")) && t.requestReferenceSpace("viewer").then((o) => t.requestHitTestSource?.call(t, { space: o })?.then((r) => this._viewerHitTestSource = r).catch((r) => console.error(r))).catch((o) => console.error(o)), this.context.mainCamera && (this._originalCameraWorldPosition = Z(this.context.mainCamera, new b()), this._originalCameraWorldRotation = be(this.context.mainCamera, new $()), this._originalCameraWorldScale = $e(this.context.mainCamera, new b()), this._originalCameraParent = this.context.mainCamera.parent), this._defaultRig = new c1(), this.context.scene.add(this._defaultRig.gameObject), this.addRig(this._defaultRig);
    for (let o = 0; o < t.inputSources.length; o++) {
      const r = t.inputSources[o];
      if (!r.handedness) {
        console.warn("Input source in xr session has no handedness - ignoring", o);
        continue;
      }
      this.onInputSourceAdded(r);
    }
    this.session.addEventListener("end", this.onEnd), this.session.addEventListener(
      "inputsourceschange",
      /* @ts-ignore (ignore CI XRInputSourceChangeEvent mismatch) */
      (o) => {
        for (const r of o.removed)
          this.disconnectInputSource(r);
        for (const r of o.added)
          this.onInputSourceAdded(r);
      }
    ), this.context.xr = this, this.context.renderer.xr.setSession(this.session).then(this.onRendererSessionSet), "controllerAutoUpdate" in this.context.renderer.xr ? (console.debug("Disabling three.js controllerAutoUpdate"), this.context.renderer.xr.controllerAutoUpdate = !1) : He && console.warn("controllerAutoUpdate is not available in three.js - cannot disable it");
  }
  /** called when renderer.setSession is fulfilled */
  onRendererSessionSet = () => {
    this.running && (this.context.renderer.xr.enabled = !0, this.context.renderer.xr.updateCamera(this.context.mainCamera), this.context.mainCameraComponent?.applyClearFlags());
  };
  onInputSourceAdded = (e) => {
    if (e.targetRayMode === "screen")
      return;
    let t = 0;
    for (let n = 0; n < this.session.inputSources.length; n++)
      if (this.session.inputSources[n] === e) {
        t = n;
        break;
      }
    if (this.controllers.find((n) => n.inputSource === e)) {
      console.debug("Controller already exists for input source", t);
      return;
    } else if (this._newControllers.find((n) => n.inputSource === e)) {
      console.debug("Controller already registered for input source", t);
      return;
    }
    const i = new Zb(this, e, t);
    this._newControllers.push(i);
  };
  /** Disconnects the controller, invokes events and notifies previou controller (if any) */
  disconnectInputSource(e) {
    const t = (i, n, o) => {
      if (i.inputSource === e) {
        He && console.log("Disconnecting controller", i.index), this.controllers.splice(o, 1), this.invokeControllerEvent(i, this._controllerRemoved, "removed");
        const r = {
          xr: this,
          controller: i,
          change: "removed"
        };
        for (const a of this._xr_scripts)
          a.onXRControllerRemoved && a.onXRControllerRemoved(r);
        i.onDisconnected();
      }
    };
    for (let i = this.controllers.length - 1; i >= 0; i--) {
      const n = this.controllers[i];
      t(n, this.controllers, i);
    }
    for (let i = this._newControllers.length - 1; i >= 0; i--) {
      const n = this._newControllers[i];
      t(n, this._newControllers, i);
    }
  }
  /** End the XR Session */
  end() {
    this._ended || this.session.end().catch((e) => console.warn(e));
  }
  _ended = !1;
  _newControllers = [];
  onEnd = (e) => {
    if (this._ended) return;
    this._ended = !0, console.debug("XR Session ended"), T1(), this.onAfterRender(), this.revertCustomForward(), this._didStart = !1, this._previousCameraParent = null, po(this.onBefore, xe.LateUpdate);
    const t = this.context.pre_render_callbacks.indexOf(this.onBeforeRender);
    t >= 0 && this.context.pre_render_callbacks.splice(t, 1);
    const i = this.context.post_render_callbacks.indexOf(this.onAfterRender);
    i >= 0 && this.context.post_render_callbacks.splice(i, 1), this.context.xr = null, this.context.renderer.xr.enabled = !1, this.context.pre_update_oneshot_callbacks.push(() => {
      this.context.mainCameraComponent?.applyClearFlags(), this.context.mainCameraComponent?.applyClippingPlane();
    }), r1({ session: this });
    for (const o of K._xrEndListeners)
      o({ xr: this });
    const n = [...this.controllers];
    for (let o = 0; o < n.length; o++)
      this.disconnectInputSource(n[o].inputSource);
    this._newControllers.length = 0, this.controllers.length = 0;
    for (const o of this._xr_scripts)
      o?.onLeaveXR?.({ xr: this });
    this.sync?.onExitXR(this), this.context.mainCamera && (this._originalCameraParent?.add(this.context.mainCamera), this._originalCameraWorldPosition && ut(this.context.mainCamera, this._originalCameraWorldPosition), this._originalCameraWorldRotation && an(this.context.mainCamera, this._originalCameraWorldRotation), this._originalCameraWorldScale && tc(this.context.mainCamera, this._originalCameraWorldScale)), this.context.requestSizeUpdate(), this._defaultRig.gameObject.removeFromParent(), Yr(!1);
  };
  _didStart = !1;
  /** Called every frame by the engine */
  onBefore = (e) => {
    const t = e.xrFrame;
    if (!t) return;
    this.context.xr = this, this.context.mainCameraComponent && this.context.mainCameraComponent !== this._mainCamera && (this._mainCamera = this.context.mainCameraComponent), this.rig?.isActive == !1 && (He && console.warn("Latest rig is not active - trying to activate a different rig", this.rig), this.updateActiveXRRig()), this.rig && this._mainCamera?.gameObject && this._mainCamera?.gameObject?.parent !== this.rig.gameObject && this.rig.gameObject.add(this._mainCamera?.gameObject), this.internalUpdateState(), this.applyCustomForward();
    const i = { xr: this };
    if (this._didStart) {
      if (this.context.new_scripts_xr.length > 0) {
        const n = [...this.context.new_scripts_xr];
        for (let o = 0; o < n.length; o++) {
          const r = this.context.new_scripts_xr[o];
          if (!r || r.destroyed || r.supportsXR?.(this.mode) == !1) {
            this.context.new_scripts_xr.splice(o, 1);
            continue;
          }
          if (!r.activeAndEnabled) {
            this.context.new_scripts_xr.splice(o, 1), this.markInactive(r);
            continue;
          }
          if (this.addScript(r)) {
            this.invokeCallback_EnterXR(r);
            for (const a of this.controllers)
              this.invokeCallback_ControllerAdded(r, a);
          }
        }
      }
    } else {
      if (this._didStart = !0, this.mode === "immersive-vr") {
        const o = _i(this.context.scene.children);
        if (o) {
          const r = o.getSize(G());
          if (r.length() > 0) {
            const a = this._defaultRig.gameObject;
            a.position.set(o.min.x + r.x * 0.5, o.min.y, o.max.z + r.z * 0.5 + 1.5);
            const l = o.getCenter(G());
            l.y = a.position.y, a.lookAt(l);
          }
        }
      }
      o1({ session: this }), pr();
      for (const o of K._xrStartListeners)
        o(i);
      const n = [...this._xr_scripts];
      He && console.log("NeedleXRSession start, handle scripts:", n);
      for (const o of n) {
        if (o.destroyed) {
          this._script_to_remove.push(o);
          continue;
        }
        if (!o.activeAndEnabled) {
          this.markInactive(o);
          continue;
        }
        this.invokeCallback_EnterXR(o);
        for (const r of this.controllers)
          this.invokeCallback_ControllerAdded(o, r);
      }
    }
    this.syncCameraCullingMask();
    for (const n of this.controllers)
      n.onUpdate(t);
    if (this._newControllers.length > 0) {
      const n = [...this._newControllers];
      this._newControllers.length = 0;
      for (const o of n) {
        if (!o.connected) {
          console.warn("New controller is not connected", o);
          continue;
        }
        this.controllers.push(o);
        for (const r of this._xr_scripts) {
          if (r.destroyed) {
            this._script_to_remove.push(r);
            continue;
          }
          r.activeAndEnabled !== !1 && this.invokeCallback_ControllerAdded(r, o);
        }
      }
      this.controllers.sort((o, r) => o.index - r.index);
    }
    He && this.context.time.frame % 30 === 0 && this.controllers.length <= 0 && this.session.inputSources.length > 0 && (Yr(!0), console.error("XRControllers are not added but inputSources are present"));
    for (const n of this._xr_update_scripts) {
      if (n.destroyed === !0) {
        this._script_to_remove.push(n);
        continue;
      }
      if (n.activeAndEnabled === !1) {
        this.markInactive(n);
        continue;
      }
      n.onUpdateXR && n.onUpdateXR(i);
    }
    if (this.handleInactiveScripts(), this._script_to_remove.length > 0) {
      const n = [...new Set(this._script_to_remove)];
      this._script_to_remove.length = 0;
      for (const o of n)
        !o.destroyed && this.running && o.onLeaveXR?.(i), this.removeScript(o);
    }
    this.sync?.onUpdate(this), this.onRenderDebug();
  };
  onRenderDebug() {
    if (He)
      for (const e of this.controllers)
        e.onRenderDebug();
    if ((He || Ty) && this.rig && (of++, of >= 20)) {
      const e = this.rig.gameObject.worldPosition, t = this.rig.gameObject.worldForward;
      e.add(t.multiplyScalar(1.5));
      const i = this.rig.gameObject.worldUp;
      e.add(i.multiplyScalar(2.5));
      let n = "";
      if (n += `${this.context.time.smoothedFps.toFixed(0)} FPS`, n += `, calls: ${this.context.renderer.info.render.calls}, tris: ${this.context.renderer.info.render.triangles.toLocaleString()}`, He || Ty)
        for (const o of this.controllers)
          n += `
${o.hand ? "hand" : "ctrl"} ${o.inputSource.handedness}[${o.index}] con:${o.connected} tr:${o.isTracking} hts:${o.hasHitTestSource ? "yes" : "no"}`;
      of = 0, F.DrawLabel(e, n, void 0, 1 / 60 * 20);
    }
  }
  onBeforeRender = () => {
    this.context.mainCamera && this.updateFade(this.context.mainCamera);
  };
  onAfterRender = () => {
    if (this.onUpdateFade_PostRender(), X.isDesktop() || !this._renderOnceOnDevice) {
      const e = this.context.renderer;
      if (e.xr.isPresenting && this.context.mainCamera) {
        this._renderOnceOnDevice = !0;
        const t = e.xr.enabled, i = e.getRenderTarget(), n = this.context.scene.background;
        e.xr.enabled = !1, e.setRenderTarget(null), this.isPassThrough && (this.context.scene.background = null), this.context.composer ? this.context.composer.render(this.context.time.deltaTime) : e.render(this.context.scene, this.context.mainCamera), e.xr.enabled = t, e.setRenderTarget(i), this.context.scene.background = n;
      }
    }
  };
  /** register a new XR script if it hasnt added yet */
  addScript(e) {
    return this._xr_scripts.includes(e) ? !1 : (He && console.log("Register new XRScript", e), this._xr_scripts.push(e), typeof e.onUpdateXR == "function" && this._xr_update_scripts.push(e), !0);
  }
  /** mark a script as inactive and invokes callbacks */
  markInactive(e) {
    if (!(this._inactive_scripts.indexOf(e) >= 0)) {
      this.removeScript(e, !1), this._inactive_scripts.push(e);
      for (const t of this.controllers) this.invokeCallback_ControllerRemoved(e, t);
      this.invokeCallback_LeaveXR(e);
    }
  }
  handleInactiveScripts() {
    if (this._inactive_scripts.length > 0)
      for (let e = this._inactive_scripts.length - 1; e >= 0; e--) {
        const t = this._inactive_scripts[e];
        if (t.activeAndEnabled) {
          this._inactive_scripts.splice(e, 1), this.addScript(t), this.invokeCallback_EnterXR(t);
          for (const i of this.controllers) this.invokeCallback_ControllerAdded(t, i);
        }
      }
  }
  _script_to_remove = [];
  removeScript(e, t = !0) {
    He && console.log("Remove XRScript", e);
    const i = this._xr_scripts.indexOf(e);
    i >= 0 && this._xr_scripts.splice(i, 1);
    const n = this._xr_update_scripts.indexOf(e);
    if (n >= 0 && this._xr_update_scripts.splice(n, 1), t) {
      const o = this._inactive_scripts.indexOf(e);
      o >= 0 && this._inactive_scripts.splice(o, 1);
    }
  }
  invokeCallback_EnterXR(e) {
    e.onEnterXR && e.onEnterXR({ xr: this });
  }
  invokeCallback_ControllerAdded(e, t) {
    e.onXRControllerAdded && e.onXRControllerAdded({ xr: this, controller: t, change: "added" });
  }
  invokeCallback_ControllerRemoved(e, t) {
    e.onXRControllerRemoved && e.onXRControllerRemoved({ xr: this, controller: t, change: "removed" });
  }
  invokeCallback_LeaveXR(e) {
    e.onLeaveXR && !e.destroyed && e.onLeaveXR({ xr: this });
  }
  syncCameraCullingMask() {
    const e = this.context.xrCamera, t = this.context.mainCameraComponent?.cullingMask;
    if (e && t !== void 0) {
      for (const i of e.cameras)
        i.layers.mask = t;
      e.layers.mask = t;
    } else if (e) {
      for (const i of e.cameras)
        i.layers.enableAll();
      e.layers.enableAll();
    }
  }
  invokeControllerEvent(e, t, i) {
    for (let n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o)
        try {
          o({
            xr: this,
            controller: e,
            change: i
          });
        } catch (r) {
          console.error(r);
        }
    }
  }
  _camera;
  _cameraRenderParent = new M().rotateY(Math.PI);
  _previousCameraParent;
  _customforward = !0;
  originalCameraNearPlane;
  /** This is used to have the XR system camera look into threejs Z forward direction (instead of -z) */
  applyCustomForward() {
    if (this.context.mainCamera && this._customforward) {
      this._camera = this.context.mainCamera, this._camera.parent !== this._cameraRenderParent && (this._previousCameraParent = this._camera.parent, this._previousCameraParent?.add(this._cameraRenderParent)), this._cameraRenderParent.name = "XR Camera Render Parent", this._cameraRenderParent.add(this._camera);
      let e = 0.02;
      if (this.rig) {
        const t = $e(this.rig.gameObject);
        e *= t.x;
      }
      this._camera instanceof pe && this._camera.near > e && (this.originalCameraNearPlane = this._camera.near, this._camera.near = e);
    }
  }
  revertCustomForward() {
    this._camera && this._previousCameraParent && this._previousCameraParent.add(this._camera), this._previousCameraParent = null, this._camera instanceof pe && this.originalCameraNearPlane != null && (this._camera.near = this.originalCameraNearPlane);
  }
  _viewerPose;
  _transformOrientation = new $();
  _transformPosition = new b();
  internalUpdateState() {
    const e = this.context.renderer.xr.getReferenceSpace();
    if (!e) {
      this._viewerPose = void 0;
      return;
    }
    if (this._viewerPose = this.frame.getViewerPose(e), this._viewerPose) {
      const t = this._viewerPose.transform;
      this._transformPosition.set(t.position.x, t.position.y, t.position.z), this._transformOrientation.set(t.orientation.x, t.orientation.y, t.orientation.z, t.orientation.w);
    }
  }
  // TODO: for scene transitions (e.g. SceneSwitcher) where creating the scene might take a few moments we might want more control over when/how this fading occurs and how long the scene stays black
  _transition;
  get transition() {
    return this._transition || (this._transition = new ky()), this._transition;
  }
  /** Call to fade rendering to black for a short moment (the returned promise will be resolved when fully black)   
   * This can be used to mask scene transitions or teleportation
   * @returns a promise that is resolved when the screen is fully black
   * @example `fadeTransition().then(() => { <fully_black> })`
  */
  fadeTransition() {
    return this._transition || (this._transition = new ky()), this._transition.fadeTransition();
  }
  /** e.g. FadeToBlack */
  updateFade(e) {
    this._transition && e instanceof pe && this._transition.update(e, this.context.time.deltaTime);
  }
  onUpdateFade_PostRender() {
    this._transition?.remove();
  }
}
const rf = w("debugwebxr");
class I1 {
  /** Searches the hierarchy for objects following a specific naming scheme */
  static tryFindAvatarObjects(e, t, i) {
    if (i.head && i.leftHand && i.rightHand) return;
    const n = e.name.toLocaleLowerCase();
    !i.head && n.includes("head") && (rf && console.log("FOUND AVATAR HEAD", e.name), i.head = new ie("", t, e)), n.includes("hand") && (!i.leftHand && n.includes("left") && (rf && console.log("FOUND AVATAR LEFT HAND", e.name), i.leftHand = new ie("", t, e)), !i.rightHand && n.includes("right") && (rf && console.log("FOUND AVATAR RIGHT HAND", e.name), i.rightHand = new ie("", t, e)));
    for (let o = 0; o < e.children.length; o++) {
      if (i.head && i.leftHand && i.rightHand) return;
      const r = e.children[o];
      this.tryFindAvatarObjects(r, t, i);
    }
  }
}
const Ot = new b(), Ey = new b(), Ay = new $(), L1 = w("debuggizmos"), Zi = 8947848, af = 32;
class F {
  constructor() {
  }
  /**
   * Allow creating gizmos   
   * If disabled then no gizmos will be added to the scene anymore
   */
  static enabled = !0;
  /** 
   * Returns true if a given object is a gizmo
   */
  static isGizmo(e) {
    return e[mp] !== void 0;
  }
  /** Set visibility of all currently rendered gizmos */
  static setVisible(e) {
    for (const t of Ri.timedObjectsBuffer)
      t.visible = e;
  }
  /**
   * Draw a label in the scene or attached to an object (if a parent is provided)
   * @param position the position of the label in world space
   * @param text the text of the label
   * @param size the size of the label in world space
   * @param duration the duration in seconds the label will be rendered. If 0 it will be rendered for one frame
   * @param color the color of the label
   * @param backgroundColor the background color of the label
   * @param parent the parent object to attach the label to. If no parent is provided the label will be attached to the scene
   * @returns a handle to the label that can be used to update the text
   */
  static DrawLabel(e, t, i = 0.05, n = 0, o, r, a) {
    if (!F.enabled) return null;
    o || (o = Zi);
    const l = K.active?.rigScale ?? 1, c = Ri.getTextLabel(n, t, i * l, o, r);
    return a instanceof M && a.add(c), c.position.x = e.x, c.position.y = e.y, c.position.z = e.z, c;
  }
  /**
   * Draw a ray gizmo in the scene
   * @param origin the origin of the ray in world space
   * @param dir the direction of the ray in world space
   * @param color the color of the ray
   * @param duration the duration in seconds the ray will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the ray will be rendered with depth test
   */
  static DrawRay(e, t, i = Zi, n = 0, o = !0) {
    if (!F.enabled) return;
    const r = Ri.getLine(n), a = r.geometry.getAttribute("position");
    a.setXYZ(0, e.x, e.y, e.z), Ot.set(t.x, t.y, t.z).multiplyScalar(999999999), a.setXYZ(1, e.x + Ot.x, e.y + Ot.y, e.z + Ot.z), a.needsUpdate = !0, r.material.color.set(i), r.material.depthTest = o, r.material.depthWrite = !1;
  }
  /**
   * Draw a line gizmo in the scene
   * @param pt0 the start point of the line in world space
   * @param pt1 the end point of the line in world space
   * @param color the color of the line
   * @param duration the duration in seconds the line will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the line will be rendered with depth test
   * @param lengthFactor the length of the line. Default is 1
   */
  static DrawDirection(e, t, i = Zi, n = 0, o = !0, r = 1) {
    if (!F.enabled) return;
    const a = Ri.getLine(n), l = a.geometry.getAttribute("position");
    l.setXYZ(0, e.x, e.y, e.z), t.w !== void 0 ? (Ot.set(0, 0, -r), Ay.set(t.x, t.y, t.z, t.w), Ot.applyQuaternion(Ay)) : (Ot.set(t.x, t.y, t.z), Ot.multiplyScalar(r)), l.setXYZ(1, e.x + Ot.x, e.y + Ot.y, e.z + Ot.z), l.needsUpdate = !0, a.material.color.set(i), a.material.depthTest = o, a.material.depthWrite = !1;
  }
  /**
   * Draw a line gizmo in the scene
   * @param pt0 the start point of the line in world space
   * @param pt1 the end point of the line in world space
   * @param color the color of the line
   * @param duration the duration in seconds the line will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the line will be rendered with depth test
   */
  static DrawLine(e, t, i = Zi, n = 0, o = !0) {
    if (!F.enabled) return;
    const r = Ri.getLine(n), a = r.geometry.getAttribute("position");
    a.setXYZ(0, e.x, e.y, e.z), a.setXYZ(1, t.x, t.y, t.z), a.needsUpdate = !0, r.material.color.set(i), r.material.depthTest = o, r.material.depthWrite = !1, r.material.fog = !1;
  }
  /**
   * Draw a 2D circle gizmo in the scene
   * @param pt0 the center of the circle in world space
   * @param normal the normal of the circle in world space
   * @param radius the radius of the circle in world space
   * @param color the color of the circle
   * @param duration the duration in seconds the circle will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the circle will be rendered with depth test
   */
  static DrawCircle(e, t, i, n = Zi, o = 0, r = !0) {
    if (!F.enabled) return;
    const a = Ri.getCircle(o);
    a.position.set(e.x, e.y, e.z), a.scale.set(i, i, i), a.quaternion.setFromUnitVectors(this._up, Ot.set(t.x, t.y, t.z).normalize()), a.material.color.set(n), a.material.depthTest = r, a.material.depthWrite = !1, a.material.fog = !1;
  }
  /**
   * Draw a 3D wiremesh sphere gizmo in the scene
   * @param center the center of the sphere in world space
   * @param radius the radius of the sphere in world space
   * @param color the color of the sphere
   * @param duration the duration in seconds the sphere will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the sphere will be rendered with depth test
   */
  static DrawWireSphere(e, t, i = Zi, n = 0, o = !0) {
    if (!F.enabled) return;
    const r = Ri.getSphere(t, n, !0);
    ua(r, e.x, e.y, e.z), r.material.color.set(i), r.material.depthTest = o, r.material.depthWrite = !1, r.material.fog = !1;
  }
  /**
   * Draw a 3D sphere gizmo in the scene
   * @param center the center of the sphere in world space
   * @param radius the radius of the sphere in world space
   * @param color the color of the sphere
   * @param duration the duration in seconds the sphere will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the sphere will be rendered with depth test
   */
  static DrawSphere(e, t, i = Zi, n = 0, o = !0) {
    if (!F.enabled) return;
    const r = Ri.getSphere(t, n, !1);
    ua(r, e.x, e.y, e.z), r.material.color.set(i), r.material.depthTest = o, r.material.depthWrite = !1;
  }
  /**
   * Draw a 3D wiremesh box gizmo in the scene
   * @param center the center of the box in world space
   * @param size the size of the box in world space
   * @param rotation the rotation of the box in world space
   * @param color the color of the box
   * @param duration the duration in seconds the box will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the box will be rendered with depth test
   */
  static DrawWireBox(e, t, i = Zi, n = 0, o = !0, r = void 0) {
    if (!F.enabled) return;
    const a = Ri.getBox(n);
    a.position.set(e.x, e.y, e.z), a.scale.set(t.x, t.y, t.z), r ? a.quaternion.copy(r) : a.quaternion.identity(), a.material.color.set(i), a.material.depthTest = o, a.material.wireframe = !0, a.material.depthWrite = !1, a.material.fog = !1;
  }
  /**
   * Draw a 3D wiremesh box gizmo in the scene
   * @param box the box in world space
   * @param color the color of the box
   * @param duration the duration in seconds the box will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the box will be rendered with depth test
   */
  static DrawWireBox3(e, t = Zi, i = 0, n = !0) {
    if (!F.enabled) return;
    const o = Ri.getBox(i);
    o.position.copy(e.getCenter(Ot)), o.scale.copy(e.getSize(Ot)), o.material.color.set(t), o.material.depthTest = n, o.material.wireframe = !0, o.material.depthWrite = !1, o.material.fog = !1;
  }
  static _up = new b(0, 1, 0);
  /**
   * Draw an arrow gizmo in the scene
   * @param pt0 the start point of the arrow in world space
   * @param pt1 the end point of the arrow in world space
   * @param color the color of the arrow
   * @param duration the duration in seconds the arrow will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the arrow will be rendered with depth test
   * @param wireframe if true the arrow will be rendered as wireframe
   */
  static DrawArrow(e, t, i = Zi, n = 0, o = !0, r = !1) {
    if (!F.enabled) return;
    const a = Ri.getArrowHead(n);
    a.position.set(t.x, t.y, t.z), a.quaternion.setFromUnitVectors(this._up.set(0, 1, 0), Ot.set(t.x, t.y, t.z).sub(Ey.set(e.x, e.y, e.z)).normalize());
    const c = Ot.set(t.x, t.y, t.z).sub(Ey.set(e.x, e.y, e.z)).length() * 0.1;
    a.scale.set(c, c, c), a.material.color.set(i), a.material.depthTest = o, a.material.wireframe = r, this.DrawLine(e, t, i, n, o);
  }
  /**
   * Render a wireframe mesh in the scene. The mesh will be removed after the given duration (if duration is 0 it will be rendered for one frame).   
   * If a mesh object is provided then the mesh's matrixWorld and geometry will be used. Otherwise, the provided matrix and geometry will be used.
   * @param options the options for the wire mesh
   * @param options.duration the duration in seconds the mesh will be rendered. If 0 it will be rendered for one frame
   * @param options.color the color of the wire mesh
   * @param options.depthTest if true the wire mesh will be rendered with depth test
   * @param options.mesh the mesh object to render (if it is provided the matrix and geometry will be used)
   * @param options.matrix the matrix of the mesh to render
   * @param options.geometry the geometry of the mesh to render
   * @example
   * ```typescript
   * Gizmos.DrawWireMesh({ duration: 1, color: 0xff0000, mesh: myMesh });
   * ```
   */
  static DrawWireMesh(e) {
    const t = Ri.getMesh(e.duration ?? 0);
    "mesh" in e ? (t.geometry = e.mesh.geometry, t.matrix.copy(e.mesh.matrixWorld)) : (t.geometry = e.geometry, t.matrix.copy(e.matrix)), t.matrixAutoUpdate = !1, t.matrixWorldAutoUpdate = !1, t.material.color.set(e.color ?? Zi), t.material.depthTest = e.depthTest ?? !0, t.material.wireframe = !0;
  }
}
const D1 = new la(1, 1, 1);
function Tm(s = null) {
  const e = new se(s ?? 14540253), t = new Xw(D1);
  return new cb(t, new hb({ color: e }));
}
const mp = Symbol("GizmoCache");
class Ri {
  // private static createdLines: number = 0;
  static familyName = "needle-gizmos";
  static ensureFont() {
    let e = Ce.FontLibrary.getFontFamily(this.familyName);
    e || (e = Ce.FontLibrary.addFontFamily(this.familyName), e.addVariant("normal", "normal", "https://uploads.needle.tools/include/font-msdf.json", "https://uploads.needle.tools/include/font.png")?.addEventListener("ready", () => {
      Ce.update();
    }));
  }
  static getTextLabel(e, t, i, n, o) {
    this.ensureFont();
    let r = this.textLabelCache.pop(), a = 1;
    o && typeof o == "string" && o?.length >= 8 && o.startsWith("#") ? (a = parseInt(o.substring(7), 16) / 255, o = o.substring(0, 7), L1 && console.log(o, a)) : typeof o == "object" && o.a !== void 0 && (a = o.a);
    const l = {
      boxSizing: "border-box",
      fontFamily: this.familyName,
      width: "auto",
      fontSize: i,
      color: n,
      lineHeight: 1,
      backgroundColor: o ?? void 0,
      backgroundOpacity: a,
      textContent: t,
      borderRadius: 0.5 * i,
      padding: 0.8 * i,
      whiteSpace: "pre",
      offset: 0.05 * i
    };
    if (r)
      r.set(l);
    else {
      r = new Pb(l);
      const c = this, h = r;
      h.setText = function(d) {
        this.set({ textContent: d }), c.tmuiNeedsUpdate = !0;
      };
    }
    return this.tmuiNeedsUpdate = !0, this.registerTimedObject(N.Current, r, e, this.textLabelCache), r;
  }
  static getBox(e) {
    let t = this.boxesCache.pop();
    if (!t) {
      const i = new la(1, 1, 1);
      t = new H(i);
    }
    return this.registerTimedObject(N.Current, t, e, this.boxesCache), t;
  }
  static getLine(e) {
    let t = this.linesCache.pop();
    if (!t) {
      t = new Zl();
      let i = t.geometry.getAttribute("position");
      i || (i = new ht(new Float32Array(6), 3), t.geometry.setAttribute("position", i));
    }
    return t.frustumCulled = !1, this.registerTimedObject(N.Current, t, e, this.linesCache), t;
  }
  static getCircle(e) {
    let t = this.circlesCache.pop();
    if (!t) {
      t = new Zl();
      let i = t.geometry.getAttribute("position");
      if (!i) {
        i = new ht(new Float32Array(af * 3), 3), t.geometry.setAttribute("position", i);
        const n = G(0, 1, 0), o = G(0, 0, 1), r = G(o);
        r.cross(n).normalize();
        const a = G(r), l = Math.PI * 2 / (af - 1);
        for (let c = 0; c < af + 1; c++) {
          const h = l * c;
          n.copy(a).multiplyScalar(Math.cos(h) * 1), r.copy(o).multiplyScalar(Math.sin(h) * 1);
          const d = n.add(r);
          i.setXYZ(c, d.x, d.y, d.z);
        }
      }
    }
    return t.frustumCulled = !1, this.registerTimedObject(N.Current, t, e, this.circlesCache), t;
  }
  static getSphere(e, t, i) {
    let n = this.spheresCache.pop();
    return n || (n = new H(new Ed(1, 8, 8))), n.scale.set(e, e, e), n.material.wireframe = i, this.registerTimedObject(N.Current, n, t, this.spheresCache), n;
  }
  static getArrowHead(e) {
    let t = this.arrowHeadsCache.pop();
    return t || (t = new H(new ab(0, 0.5, 1, 8))), this.registerTimedObject(N.Current, t, e, this.arrowHeadsCache), t;
  }
  static getMesh(e) {
    let t = this.mesh.pop();
    return t || (t = new H(), t.material = new we()), this.registerTimedObject(N.Current, t, e, this.mesh), t;
  }
  static linesCache = [];
  static circlesCache = [];
  static spheresCache = [];
  static boxesCache = [];
  static arrowHeadsCache = [];
  static mesh = [];
  static textLabelCache = [];
  static registerTimedObject(e, t, i, n) {
    if (!e) {
      console.error("No Needle Engine context available. Did you call a Gizmos function in global scope?");
      return;
    }
    const o = this.contextBeforeRenderCallbacks.get(e), r = this.contextPostRenderCallbacks.get(e);
    if (o) {
      if (e.pre_render_callbacks[e.pre_render_callbacks.length - 1] !== o) {
        const a = e.pre_render_callbacks.indexOf(o);
        a >= 0 && e.pre_render_callbacks.splice(a, 1), e.pre_render_callbacks.push(o);
      }
    } else {
      const a = () => {
        this.onBeforeRender(e, this.timedObjectsBuffer);
      };
      this.contextBeforeRenderCallbacks.set(e, a), e.pre_render_callbacks.push(a);
    }
    if (r) {
      if (e.post_render_callbacks[e.post_render_callbacks.length - 1] !== r) {
        const a = e.post_render_callbacks.indexOf(r);
        a >= 0 && e.post_render_callbacks.splice(a, 1), e.post_render_callbacks.push(r);
      }
    } else {
      const a = () => {
        this.onPostRender(e, this.timedObjectsBuffer, this.timesBuffer);
      };
      this.contextPostRenderCallbacks.set(e, a), e.post_render_callbacks.push(a);
    }
    t.traverse((a) => {
      a.layers.disableAll(), a.layers.enable(2);
    }), t.renderOrder = 999999, t[mp] = n, t.castShadow = !1, t.receiveShadow = !1, t.isGizmo = !0, this.timedObjectsBuffer.push(t), this.timesBuffer.push(N.Current.time.realtimeSinceStartup + i), e.scene.add(t);
  }
  static timedObjectsBuffer = new Array();
  static timesBuffer = new Array();
  static contextPostRenderCallbacks = /* @__PURE__ */ new Map();
  static contextBeforeRenderCallbacks = /* @__PURE__ */ new Map();
  static tmuiNeedsUpdate = !1;
  static onBeforeRender(e, t) {
    this.tmuiNeedsUpdate && (this.tmuiNeedsUpdate = !1, Ce.update());
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      if (e.mainCamera && n instanceof Ce.MeshUIBaseElement) {
        if (_a(n))
          continue;
        const o = e.isInVR, r = !1, a = !o;
        Nd(n, e.mainCamera, r, a);
      }
    }
  }
  static onPostRender(e, t, i) {
    const n = e.time.realtimeSinceStartup;
    for (let o = t.length - 1; o >= 0; o--) {
      const r = t[o];
      n >= i[o] - 1e-6 && (t.splice(o, 1), i.splice(o, 1), r.removeFromParent(), _a(r) != !0 && r[mp].push(r));
    }
  }
}
const $t = w("debugphysics"), Iy = new ao();
class mr {
  static AllLayers = 4294967295;
  ray;
  cam;
  screenPoint;
  raycaster;
  results;
  targets;
  recursive = !0;
  minDistance;
  maxDistance;
  lineThreshold;
  layerMask;
  ignore;
  testObject;
  useAcceleratedRaycast;
  allowSlowRaycastFallback = !0;
  screenPointFromOffset(e, t) {
    this.screenPoint === void 0 && (this.screenPoint = new J()), this.screenPoint.x = e / window.innerWidth * 2 - 1, this.screenPoint.y = -(t / window.innerHeight) * 2 + 1;
  }
  /** sets one layer for raycasting (e.g. layer 4, only objects on layer 4 will then be hit) */
  setLayer(e) {
    Iy.set(e), this.layerMask = Iy;
  }
  /** sets the layer.mask value directly, use setLayer if you want to set e.g. an individual layer only active. See https://threejs.org/docs/#api/en/core/Layers for more information about layers */
  setMask(e) {
    this.layerMask || (this.layerMask = new ao());
    const t = this.layerMask;
    t ? t.mask = e : this.layerMask = e;
  }
}
class s0 {
  distance;
  point;
  object;
  constructor(e, t, i) {
    this.object = e, this.distance = t, this.point = i;
  }
}
class nc {
  static _raycasting = 0;
  /**
   * Returns true if raycasting is currently happening
   */
  static get raycasting() {
    return this._raycasting > 0;
  }
  /**@deprecated use `this.context.physics.engine.raycast` {@link IPhysicsEngine.raycast} */
  raycastPhysicsFast(e, t = void 0, i = 1 / 0, n = !0) {
    return this.context.physics.engine?.raycast(e, t, { maxDistance: i, solid: n }) ?? null;
  }
  /**@deprecated use `this.context.physics.engine.raycastAndGetNormal` {@link IPhysicsEngine.raycastAndGetNormal} */
  raycastPhysicsFastAndGetNormal(e, t = void 0, i = 1 / 0, n = !0) {
    return this.context.physics.engine?.raycastAndGetNormal(e, t, { maxDistance: i, solid: n }) ?? null;
  }
  /**@deprecated use this.context.physics.engine.sphereOverlap */
  sphereOverlapPhysics(e, t) {
    return this.context.physics.engine?.sphereOverlap(e, t) ?? null;
  }
  context;
  engine;
  constructor(e) {
    this.context = e;
  }
  // raycasting
  raycaster = new Ad();
  defaultRaycastOptions = new mr();
  targetBuffer = new Array(1);
  defaultThresholds = {
    Mesh: {},
    Line: { threshold: -1 },
    LOD: {},
    Points: { threshold: 0 },
    Sprite: {}
  };
  sphereResults = new Array();
  sphereMask = new ao();
  sphere = new Id();
  /** Test overlapping of a sphere with the threejs geometry. This does not use colliders. This does not return an exact intersection point (intersections returned contain the object and the world position of the object that is being hit)
   * For a more accurate test use the physics engine's collider overlap test (see sphereOverlapPhysics)
   * @param spherePos the center of the sphere in world space
   * @param radius the radius of the sphere
   * @param traverseChildsAfterHit if false it will stop after the first hit. If true it will continue to traverse and add all hits to the result array
   * @param bvh use MeshBVH for raycasting. This is faster than the default threejs raycaster but uses more memory.
   * @param shouldRaycast optional callback to filter objects. Return `false` to ignore the object completely or `"continue in children"` to skip the object but continue to traverse its children (if you do raycast with `recursive` enabled)
   */
  sphereOverlap(e, t, i = !0, n = !1, o = null) {
    if (this.sphereResults.length = 0, !this.context.scene) return this.sphereResults;
    const r = this.sphereMask;
    r.enableAll(), r.disable(2);
    for (const a of this.context.scene.children)
      this.intersectSphere(a, e, t, r, this.sphereResults, i, n, o);
    return this.sphereResults.sort((a, l) => a.distance - l.distance);
  }
  raycastFromRay(e, t = null) {
    const i = t ?? this.defaultRaycastOptions;
    i.ray = e;
    const n = this.raycast(i);
    return i === this.defaultRaycastOptions && (i.ray = void 0), n;
  }
  /** raycast against rendered three objects. This might be very slow depending on your scene complexity.
   * We recommend setting objects to IgnoreRaycast layer (2) when you don't need them to be raycasted.
   * Raycasting SkinnedMeshes is specially expensive.
   * Use raycastPhysics for raycasting against physic colliders only. Depending on your scenario this might be faster.
   * @param options raycast options. If null, default options will be used.
   */
  raycast(e = null) {
    $t && performance.mark("raycast.start"), e || (e = this.defaultRaycastOptions);
    const t = e.screenPoint ?? this.context.input.mousePositionRC, i = e.raycaster ?? this.raycaster;
    if (i.near = e.minDistance ?? 0, i.far = e.maxDistance ?? 1 / 0, i.params = this.defaultThresholds, e.lineThreshold === void 0 && (e.lineThreshold = -1), i.params.Line = { threshold: e.lineThreshold }, e.ray)
      i.ray.copy(e.ray);
    else {
      const a = e.cam ?? this.context.mainCamera;
      if (!a)
        return $t && console.error("Can not perform raycast - no main camera found"), this.defaultRaycastOptions.results && (this.defaultRaycastOptions.results.length = 0), this.defaultRaycastOptions.results ?? [];
      const l = this.context.xrCamera;
      this.context.isInXR && l instanceof Qw && l.cameras.length > 0 ? i.setFromCamera(t, l.cameras[0]) : i.setFromCamera(t, a);
    }
    let n = e.targets;
    n || (n = this.targetBuffer, n.length = 1, n[0] = this.context.scene);
    let o = e.results;
    this.defaultRaycastOptions.results && (this.defaultRaycastOptions.results.length = 0), o || (this.defaultRaycastOptions.results || (this.defaultRaycastOptions.results = new Array()), o = this.defaultRaycastOptions.results), e.layerMask !== void 0 ? e.layerMask instanceof ao ? i.layers.mask = e.layerMask.mask : i.layers.mask = e.layerMask : (i.layers.enableAll(), i.layers.disable(2)), $t && console.time("raycast"), o.length = 0, nc._raycasting++, this.intersect(this.raycaster, n, o, e), o.sort((a, l) => a.distance - l.distance);
    const r = e.ignore;
    return r !== void 0 && r.length > 0 && (o = o.filter((a) => !r.includes(a.object))), nc._raycasting--, $t && (console.timeEnd("raycast"), console.warn("#" + this.context.time.frame + ", hits:", o?.length ? [...o] : "nothing"), performance.mark("raycast.end"), performance.measure("raycast", "raycast.start", "raycast.end")), o;
  }
  intersect(e, t, i, n) {
    for (const o of t) {
      if (!o || o.visible === !1 || F.isGizmo(o) || n.lineThreshold !== void 0 && n.lineThreshold < 0 && o instanceof Zl)
        continue;
      let r = !0;
      const a = o, l = a.geometry;
      if (n.testObject) {
        const c = n.testObject?.(o);
        if (c === !1)
          continue;
        c === "continue in children" && (r = !1);
      }
      if (r && (l && Ly(l) || (r = !1)), r) {
        const c = yb(o);
        c && (a.geometry = c);
        const h = i.length;
        let d = !0;
        if (n.precise === !1 && (d = !1), d ||= l.getAttribute("position")?.array?.length < 64, a instanceof da && (d = !1), !d && B1(a, e, i) || (n.useAcceleratedRaycast !== !1 ? td.runMeshBVHRaycast(e, a, i, this.context, n) : e.intersectObject(a, !1, i)), $t && i.length != h) {
          const f = i[i.length - 1], p = c ? 8969557 : 7798784;
          F.DrawWireSphere(f.point, 0.1, p, 1, !1), F.DrawWireMesh({ mesh: o, depthTest: !1, duration: 0.2, color: p });
        }
        a.geometry = l;
      }
      n.recursive !== !1 && this.intersect(e, o.children, i, n);
    }
    return i;
  }
  tempBoundingBox = new pi();
  intersectSphere(e, t, i, n, o, r, a, l) {
    let c = e && e.isMesh && e.layers.test(n) && !F.isGizmo(e);
    c &&= e.visible, c &&= !(e instanceof Zl), c &&= !(e instanceof da);
    const h = e, d = h.geometry;
    if (c && l) {
      const f = l(e);
      if (f === !1)
        return;
      f === "continue in children" && (c = !1);
    }
    if (d && Ly(d) || (c = !1), c) {
      if (a) {
        const f = this.sphere;
        f.center.copy(t), f.radius = i;
        const p = o.length;
        if (td.runMeshBVHRaycast(this.sphere, h, o, this.context, {}), p != o.length && !r)
          return;
      } else if (d.boundingBox || d.computeBoundingBox(), d.boundingBox) {
        h.matrixWorldNeedsUpdate && h.updateWorldMatrix(!1, !1);
        const f = this.tempBoundingBox.copy(d.boundingBox).applyMatrix4(h.matrixWorld), p = this.sphere;
        if (p.center.copy(t), p.radius = i, p.intersectsBox(f)) {
          const g = Z(e), _ = g.distanceTo(p.center), m = new s0(e, _, g);
          if (o.push(m), !r) return;
        }
      }
    }
    if (e.children)
      for (const f of e.children) {
        const p = o.length;
        if (this.intersectSphere(f, t, i, n, o, r, a, l), p != o.length && !r) return;
      }
  }
}
function Ly(s) {
  return !(s.index && s.index.array.length < 3);
}
const Lo = new Id(), Jc = new nr(), j1 = new rb();
function B1(s, e, t) {
  const i = s._computeIntersections;
  if (!i)
    return !1;
  let n = s["_computeIntersections:Needle"];
  return n || (n = s["_computeIntersections:Needle"] = function(o, r, a) {
    const l = this, c = l.geometry.boundingSphere;
    if (c) {
      if (l instanceof da) {
        Jc.setFromNormalAndCoplanarPoint(G(0, 1, 0), G(0, -l.position.y, 0)), Jc.applyMatrix4(l.matrixWorld, j1);
        const d = o.ray.intersectPlane(Jc, G());
        if (d) {
          Lo.copy(c), Lo.applyMatrix4(l.matrixWorld);
          const p = G(d).sub(o.ray.origin).length(), g = Lo.radius * 0.5;
          p < g && r.push({ distance: p, point: d, object: l, normal: Jc.normal.clone() });
        }
        return;
      }
      Lo.copy(c), Lo.applyMatrix4(l.matrixWorld);
      const h = o.ray.intersectSphere(Lo, G());
      if (h) {
        const d = G(h).sub(o.ray.origin), f = d.length();
        if (f > Lo.radius) {
          const p = d.clone().normalize();
          r.push({ distance: f, point: h, object: l, normal: p });
        }
      }
    }
  }), s._computeIntersections = n, e.intersectObject(s, !1, t), s._computeIntersections = i, !0;
}
var td;
((s) => {
  function e(v, y, x, I, O) {
    if (!y.geometry || !y.geometry.hasAttribute("position"))
      return !1;
    const k = y.geometry;
    if (y?.isSkinnedMesh) {
      const E = y, z = E.bvhNeedsUpdate;
      if (!E.staticGenerator)
        a(), o && (E.staticGenerator = new o(y), E.staticGenerator.applyWorldTransforms = !1, E.staticGeometry = E.staticGenerator.generate(), k.boundsTree = r?.call(E.staticGeometry), E.staticGeometryLastUpdate = performance.now() + Math.random() * 200, E.bvhNeedsUpdate = !0);
      else if (k.boundsTree && (E.autoUpdateMeshBvhInterval !== void 0 && E.autoUpdateMeshBvhInterval >= 0 || z === !0)) {
        const D = performance.now(), V = D - E.staticGeometryLastUpdate, q = E.autoUpdateMeshBvhInterval ?? 100;
        (z || V > q) && ($t && console.warn(`Physics: updating skinned mesh bvh for ${y.name} after ${V.toFixed(2)}ms`), E.bvhNeedsUpdate = !1, E.staticGeometryLastUpdate = D, E.staticGenerator?.generate(E.staticGeometry), k.boundsTree.refit());
      }
    } else if (!k.boundsTree) {
      c || m();
      let E = !0;
      if ((I.xr || k[p] === !1 || k.getAttribute("position")?.isInterleavedBufferAttribute || k.index && k.index?.isInterleavedBufferAttribute) && (E = !1), E && d) {
        if (k[f] === void 0) {
          let z = null;
          if (_.length > 0) {
            const D = _.shift();
            D && !D.running && (z = D);
          }
          if (!z && g.length < 3 && (z = new d(), g.push(z)), z != null && !z.running) {
            const D = y.name;
            $t && console.log("<<<< worker start", D, z), k[f] = "queued", performance.mark("bvh.create.start");
            const V = k.clone();
            try {
              z.generate(V).then((q) => {
                k[f] = "done", k.boundsTree = q;
              }).catch((q) => {
                k[f] = "failed - " + q?.message, k[p] = !1, $t && console.error("Failed to generate mesh bvh on worker", q);
              }).finally(() => {
                $t && console.log(">>>>> worker done", D, { hasBoundsTre: k.boundsTree != null }), _.push(z), V.dispose(), performance.mark("bvh.create.end"), performance.measure("bvh.create (worker)", "bvh.create.start", "bvh.create.end");
              });
            } catch (q) {
              console.error("Failed to generate mesh bvh on worker", q);
            }
          } else
            $t && console.warn("No worker available");
        }
      } else (!h || !E) && (a(), n && (performance.mark("bvh.create.start"), k.boundsTree = new n(k), performance.mark("bvh.create.end"), performance.measure("bvh.create", "bvh.create.start", "bvh.create.end")));
    }
    if (v instanceof Ad) {
      const E = v, z = y.raycast;
      if (k.boundsTree)
        a(), i && (y.acceleratedRaycast || (y.acceleratedRaycast = i.bind(y), $t && console.debug(`Physics: bind acceleratedRaycast fn to "${y.name}"`)), y.raycast = y.acceleratedRaycast);
      else if ($t && console.warn("No bounds tree found for mesh", y.name, { workerTask: k[f], hasAcceleratedRaycast: i != null }), O.allowSlowRaycastFallback === !1)
        return $t && console.warn("Skipping raycast because no bounds tree is available and allowSlowRaycastFallback is false"), !1;
      const D = E.firstHitOnly;
      return E.firstHitOnly = !1, E.intersectObject(y, !1, x), E.firstHitOnly = D, y.raycast = z, !0;
    } else if (v instanceof Id) {
      const E = k.boundsTree;
      if (E) {
        const z = v;
        if (l.copy(y.matrixWorld).invert(), z.applyMatrix4(l), E.intersectsSphere(z)) {
          const V = Z(y), q = V.distanceTo(z.center), A = new s0(y, q, V);
          x.push(A);
        }
      }
      return !0;
    }
    return !1;
  }
  s.runMeshBVHRaycast = e;
  let t = !1, i = null, n = null, o = null, r = null;
  function a() {
    t || (t = !0, import("./vendor-Z4SPrTcP.js").then((v) => v.index$1).then((v) => {
      i = v.acceleratedRaycast, n = v.MeshBVH, o = v.StaticGeometryGenerator, r = v.computeBoundsTree;
    }).catch((v) => {
      ($t || L()) && console.error("Failed to load BVH library...", v.message);
    }));
  }
  const l = new te();
  let c = !1, h = !1, d = null;
  const f = Symbol("Needle:MeshBVH-Worker"), p = Symbol("Needle:MeshBVH-CanUseWorker"), g = [], _ = [];
  function m() {
    c = !0, h = !0, Promise.resolve().then(() => HA).then((v) => {
      d = v.GenerateMeshBVHWorker;
    }).catch((v) => {
      ($t || L()) && console.warn("Failed to setup mesh bvh worker");
    }).finally(() => {
      h = !1;
    });
  }
})(td || (td = {}));
const Dy = Symbol("gltf-loader-internal-usage-tracker"), F1 = w("debugusers");
class Jr {
  get name() {
    return "NEEDLE_internal_usage_tracker";
  }
  static isLoading(e) {
    return Jr._loadingProcesses > 0;
  }
  static _loadingProcesses = 0;
  parser;
  _getDependency;
  _loadingId;
  _loadedObjects = /* @__PURE__ */ new Set();
  constructor(e) {
    this.parser = e, this._getDependency = this.parser.getDependency, this._loadingId = Date.now().toString();
  }
  beforeRoot() {
    Jr._loadingProcesses++;
    const e = this, t = this._getDependency;
    return this.parser.getDependency = function(i, n) {
      const o = t.call(this, i, n);
      return o.then((r) => (r && (e._loadedObjects.add(r), r[Dy] = e._loadingId), r)), o;
    }, null;
  }
  afterRoot(e) {
    Jr._loadingProcesses--, this.parser.getDependency = this._getDependency;
    for (const t of this._loadedObjects)
      delete t[Dy], t instanceof M && (t.parent || t instanceof H && setTimeout(() => {
        F1 && console.warn("> GLTF LOADER: Mesh not used in scene!", t), t.material = null, t.geometry = null;
      }, 1e3));
    return null;
  }
  // private readonly _creatingNodeMesh: Map<number, CreateNodeMesh> = new Map();
  // createNodeMesh(_nodeIndex: number): CreateNodeMesh | null {
  //     // if (!this.parser) return null;
  //     // let process = this._creatingNodeMesh.get(nodeIndex);
  //     // if (process) return process;
  //     // process = this.parser.createNodeMesh(nodeIndex)?.then((mesh) => {
  //     //     console.log("createNodeMesh", nodeIndex, mesh);
  //     //     return mesh;
  //     // }) as CreateNodeMesh;
  //     // this._creatingNodeMesh.set(nodeIndex, process);
  //     // return process;
  // }
}
class z1 {
  constructor() {
    window.addEventListener("unhandledrejection", (e) => {
      if (e.defaultPrevented) return;
      const t = e?.reason?.path;
      if (t) {
        const i = t[0];
        i && i.tagName === "IMG" && (console.warn(`Could not load image:
` + i.src), e.preventDefault());
      }
    });
  }
}
const Vd = w("trackresources");
function o0() {
  return Vd === "dispose";
}
let gr = !0;
Vd === 0 && (gr = !1);
function II(s) {
  gr = s;
}
function U1() {
  return gr;
}
const r0 = Symbol("disposable");
function N1(s, e) {
  s && (s[r0] = e, Yo && console.warn("Set disposable", e, s));
}
const a0 = Symbol("disposed");
function LI(s) {
  return s[a0] === !0;
}
function Re(s) {
  if (s) {
    if (s[r0] === !1) {
      Yo && console.warn("Object is marked as not disposable", s);
      return;
    }
    if (typeof s == "object" && (s[a0] = !0), s instanceof gi)
      Re(s.environment), Re(s.background), Re(s.customDepthMaterial), Re(s.customDistanceMaterial);
    else if (s instanceof ys)
      Re(s.geometry), Re(s.material), Re(s.skeleton), Re(s.bindMatrix), Re(s.bindMatrixInverse), Re(s.customDepthMaterial), Re(s.customDistanceMaterial), s.geometry = null, s.material = null, s.visible = !1;
    else if (s instanceof H)
      Re(s.geometry), Re(s.material), Re(s.customDepthMaterial), Re(s.customDistanceMaterial), s.geometry = null, s.material = null, s.visible = !1;
    else if (s instanceof Tn) {
      Mr(s);
      for (const e of Object.keys(s.attributes)) {
        const t = s.attributes[e];
        Re(t);
      }
    } else if (s instanceof ht || s instanceof db)
      Yo && console.warn("BufferAttribute dispose not supported", s.count);
    else if (s instanceof Array)
      for (const e of s)
        e instanceof _e && Re(e);
    else if (s instanceof _e) {
      Mr(s);
      for (const t of Object.keys(s)) {
        const i = s[t];
        i instanceof Te && (Re(i), s[t] = null);
      }
      const e = s.uniforms;
      if (e)
        for (const t of Object.keys(e)) {
          const i = e[t];
          i instanceof Te ? (Re(i), e[t] = null) : i instanceof zi && (Re(i.value), i.value = null);
        }
    } else s instanceof Te ? (Mr(s), Mr(s.source), s.source?.data instanceof ImageBitmap && Mr(s.source.data)) : s instanceof Yw ? (Mr(s.boneTexture), s.boneTexture = null) : s instanceof Kw || !(s instanceof M) && Yo && console.warn("Unknown object type", s);
  }
}
function Mr(s) {
  s && ((Yo || o0() || Vd) && console.warn("🧨 FREE", s), s instanceof ImageBitmap ? s.close() : s instanceof Zw ? s.data = null : s.dispose());
}
function $1(s) {
  (s instanceof H || s instanceof ys) && (s.material = null, s.geometry = null);
}
const W1 = /* @__PURE__ */ new Set();
function l0(s, e, t = null, i) {
  if (i || (i = W1, i.clear()), !s) return i;
  const n = s[sc];
  if (n)
    for (const o of n)
      i.has(o) || t?.call(null, o) !== !1 && (i.add(o), e && l0(o, !0, t, i));
  return i;
}
function DI(s) {
  return s[vl];
}
const Yo = w("debugresourceusers") || w("debugmemory"), sc = Symbol("needle-resource-users"), vl = Symbol("needle-resource-users-count");
function jt(s, e) {
  Cm(s, e, function(t, i) {
    gr && !nc.raycasting && (id(sc, this, t, !1), id(sc, this, i, !0));
  });
}
gr && (jt(H.prototype, "material"), jt(H.prototype, "geometry"), jt(_e.prototype, "map"), jt(_e.prototype, "bumpMap"), jt(_e.prototype, "alphaMap"), jt(_e.prototype, "normalMap"), jt(_e.prototype, "displacementMap"), jt(_e.prototype, "roughnessMap"), jt(_e.prototype, "metalnessMap"), jt(_e.prototype, "emissiveMap"), jt(_e.prototype, "specularMap"), jt(_e.prototype, "envMap"), jt(_e.prototype, "lightMap"), jt(_e.prototype, "aoMap"), jt(_e.prototype, "gradientMap"));
function V1(s) {
  if (gr === !1) return;
  const e = s[sc];
  if (e)
    for (const t of e)
      id(sc, t, s, !1);
}
gr && Cm(_e.prototype, "dispose", function() {
  V1(this);
});
let gp = 0;
function id(s, e, t, i) {
  if (gp > 0) return;
  if (Array.isArray(t)) {
    for (const o of t)
      id(s, e, o, i);
    return;
  }
  if (!t) return;
  let n = t[s];
  if (n || (n = /* @__PURE__ */ new Set()), i) {
    if (e && !n.has(e)) {
      n.add(e);
      let o = t[vl] || 0;
      o += 1, t[vl] = o, Yo && console.warn(`🟢 Added user of "${t.type}"`, e, t, o, "users:", n);
    }
  } else if (e && n.has(e)) {
    n.delete(e);
    let o = t[vl] || 0;
    o > 0 && (o -= 1, t[vl] = o), Yo && console.warn(`🔴 Removed user of "${t.type}"`, e, t, o, "users:", n), o <= 0 && (Jr.isLoading(t) || (Vd && console.warn(`🔴 Removed all user of "${t.type}"`, t), o0() && Re(t)));
  }
  t[s] = n;
}
try {
  Cm(
    ur.prototype,
    "render",
    function() {
      gp++;
    },
    function() {
      gp--;
    }
  );
} catch (s) {
  console.warn("Could not wrap WebGLRenderer.render", s);
}
const jy = w("debugcomponentevents");
class Em {
  static eventListeners = /* @__PURE__ */ new Map();
  static addComponentLifecylceEventListener(e, t) {
    this.eventListeners.has(e) && this.eventListeners.set(e, []);
    let i = this.eventListeners.get(e);
    i || (i = []), i.push(t), this.eventListeners.set(e, i), jy && console.log("Added event listener for " + e, this.eventListeners);
  }
  static removeComponentLifecylceEventListener(e, t) {
    const i = this.eventListeners.get(e);
    if (!i) return;
    const n = i.indexOf(t);
    n < 0 || i.splice(n, 1);
  }
  static dispatchComponentLifecycleEvent(e, t) {
    const i = this.eventListeners.get(e);
    if (jy && console.log("Dispatching event " + e, i), !!i)
      for (const n of i)
        n(t);
  }
}
const oc = Symbol("NEEDLE_NEED_UPDATE_INSTANCE"), c0 = Symbol("isUsingInstancing"), h0 = Symbol("instancingRenderer"), wl = Symbol("instancingAutoUpdateBounds");
class sn {
  /** Is this object rendered using a InstancedMesh */
  static isUsingInstancing(e) {
    return e[c0] === !0;
  }
  /** Returns the instanced mesh IF the object is rendered by an instanced mesh
   * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
   */
  static getRenderer(e) {
    return e[h0] || null;
  }
  setAutoUpdateBounds(e, t) {
    const i = sn.getRenderer(e);
    i && (i[wl] = t);
  }
  // TODO: change this so it does not set matrix world directly but some flag that is only used by instancing
  /** Mark an instanced object dirty so the instance matrix will be updated */
  static markDirty(e, t = !0) {
    if (e && (this.isUsingInstancing(e) && (e[oc] = !0, e.matrixWorldNeedsUpdate = !0), t))
      for (const i of e.children)
        sn.markDirty(i, !0);
  }
}
var nd;
((s) => {
  s.experimentalSmartHierarchyUpdate = !1;
})(nd || (nd = {}));
function ea(s, e) {
  try {
    e || s();
  } catch (t) {
    return console.error(t), !1;
  }
  return !0;
}
const yp = w("debugnewscripts"), H1 = w("debughierarchy"), ke = [];
function G1() {
  return ke.length > 0;
}
function sd(s) {
  if (yp && console.log("Register new components", s.new_scripts.length, [...s.new_scripts], s.alias ? "element: " + s.alias : s.hash, s), s.new_scripts_pre_setup_callbacks.length > 0) {
    for (const e of s.new_scripts_pre_setup_callbacks)
      e && e();
    s.new_scripts_pre_setup_callbacks.length = 0;
  }
  if (!(s.new_scripts.length <= 0)) {
    ke.length = 0, s.new_scripts.length > 0 && ke.push(...s.new_scripts), s.new_scripts.length = 0;
    for (let e = 0; e < ke.length; e++)
      try {
        const t = ke[e];
        if (t.isComponent !== !0) {
          (L() || yp) && console.error(`Registered script is not a Needle Engine component. 
The script will be ignored. Please make sure your component extends "Behaviour" imported from "@needle-tools/engine"
`, t), ke.splice(e, 1), e--;
          continue;
        }
        if (t.destroyed) continue;
        if (!t.gameObject) {
          console.warn(`Component can not be initialized: no GameObject assigned.
Did you add and remove a component in the same frame?`), ke.splice(e, 1), e--;
          continue;
        }
        t.context = s, zl(t.gameObject), Am(t, s);
      } catch (t) {
        console.error(t), cs(ke[e], s), ke.splice(e, 1), e--;
      }
    for (let e = 0; e < ke.length; e++)
      try {
        const t = ke[e];
        if (t.destroyed) {
          cs(ke[e], s), ke.splice(e, 1), e--;
          continue;
        }
        if (t.registering)
          try {
            t.registering();
          } catch (i) {
            console.error(i);
          }
        t.__internalAwake !== void 0 && (t.gameObject || console.error("Calling awake for a component without a GameObject", t, t.gameObject), zl(t.gameObject), t.activeAndEnabled && ea(t.__internalAwake.bind(t)));
      } catch (t) {
        console.error(t), cs(ke[e], s), ke.splice(e, 1), e--;
      }
    for (let e = 0; e < ke.length; e++)
      try {
        const t = ke[e];
        if (t.destroyed || t.enabled === !1 || (zl(t.gameObject), t.activeAndEnabled === !1)) continue;
        t.__internalEnable !== void 0 && (t.enabled = !0, ea(t.__internalEnable.bind(t)));
      } catch (t) {
        console.error(t), cs(ke[e], s), ke.splice(e, 1), e--;
      }
    for (let e = 0; e < ke.length; e++)
      try {
        const t = ke[e];
        if (t.destroyed || !t.gameObject) continue;
        s.new_script_start.push(t);
      } catch (t) {
        console.error(t), cs(ke[e], s), ke.splice(e, 1), e--;
      }
    ke.length = 0;
    for (const e of s.new_scripts_post_setup_callbacks)
      e && e();
    s.new_scripts_post_setup_callbacks.length = 0;
  }
}
function q1(s) {
  s && (s.__internalDisable(!0), cs(s, s.context));
}
function d0(s, e) {
  for (let t = 0; t < s.new_script_start.length; t++)
    try {
      const i = s.new_script_start[t];
      if (e !== void 0 && i.gameObject !== e || i.destroyed || i.activeAndEnabled === !1)
        continue;
      ea(i.__internalAwake.bind(i)), i.enabled && (ea(i.__internalEnable.bind(i)), ea(i.__internalStart.bind(i)), s.new_script_start.splice(t, 1), t--);
    } catch (i) {
      console.error(i), cs(s.new_script_start[t], s), s.new_script_start.splice(t, 1), t--;
    }
}
function Am(s, e) {
  e.scripts.indexOf(s) === -1 && (e.scripts.push(s), s.earlyUpdate && e.scripts_earlyUpdate.push(s), s.update && e.scripts_update.push(s), s.lateUpdate && e.scripts_lateUpdate.push(s), s.onBeforeRender && e.scripts_onBeforeRender.push(s), s.onAfterRender && e.scripts_onAfterRender.push(s), s.onPausedChanged && e.scripts_pausedChanged.push(s), lf(s, null) && e.new_scripts_xr.push(s), lf(s, "immersive-vr") && e.scripts_immersive_vr.push(s), lf(s, "immersive-ar") && e.scripts_immersive_ar.push(s));
}
function cs(s, e) {
  Ti(s, e.new_scripts), Ti(s, e.new_script_start), Ti(s, e.scripts), Ti(s, e.scripts_earlyUpdate), Ti(s, e.scripts_update), Ti(s, e.scripts_lateUpdate), Ti(s, e.scripts_onBeforeRender), Ti(s, e.scripts_onAfterRender), Ti(s, e.scripts_pausedChanged), Ti(s, e.new_scripts_xr), Ti(s, e.scripts_immersive_vr), Ti(s, e.scripts_immersive_ar), e.stopAllCoroutinesFrom(s);
}
function Ti(s, e) {
  const t = e.indexOf(s);
  t >= 0 && e.splice(t, 1);
}
function lf(s, e) {
  if (s) {
    const t = s;
    if (t.onBeforeXR || t.onEnterXR || t.onUpdateXR || t.onLeaveXR || t.onXRControllerAdded || t.onXRControllerRemoved)
      return !(e != null && t.supportsXR?.(e) === !1);
  }
  return !1;
}
let _p = !0;
function cf() {
  _p = !0;
}
function Rh(s, e = !1) {
  if (nd.experimentalSmartHierarchyUpdate) {
    if (!e && !_p)
      return;
    _p = !1;
  }
  if (s || (s = he.Current.scene), !s) {
    console.trace("Invalid call - no current context.");
    return;
  }
  const t = yc(s);
  u0(s, t, !0) || (yp || L() ? console.error(`Error updating hierarchy
Do you have circular references in your project? <a target="_blank" href="https://docs.needle.tools/circular-reference"> Click here for more information.`, s) : console.error('Failed to update active state in hierarchy of "' + s.name + '"', s), console.warn(" ↑ this error might be caused by circular references. Please make sure you don't have files with circular references (e.g. one GLB 1 is loading GLB 2 which is then loading GLB 1 again)."));
}
function u0(s, e, t, i = 0) {
  if (i > 1e3)
    return console.warn("Hierarchy is too deep (> 1000 level) - will abort updating active state"), !1;
  const n = yc(s);
  if (e && (e = n, e && s.parent && i === 0)) {
    const l = s.parent;
    e = l[oo], e === void 0 && (l instanceof gi || (e = !0));
  }
  const r = s[oo] !== e;
  r && (s[oo] = e, H1 && console.warn("ACTIVE CHANGE", s.name, n, s.visible, e, "changed?" + r, s), X1(s, (l) => {
    e ? l.enabled && (ea(l.__internalAwake.bind(l)), l.enabled && l.__internalEnable()) : l.__didAwake && l.enabled && (l.__didEnable = !1, l.onDisable());
  }));
  let a = !0;
  if (s.children)
    for (const l of s.children)
      u0(l, e, t, i + 1) === !1 && (a = !1);
  return a;
}
function zl(s) {
  let e = !0, t = s, i = !1;
  for (; t && t; ) {
    if (t.type === "Scene" && (i = !0), !yc(t)) {
      e = !1;
      break;
    }
    t = t.parent;
  }
  if (!s) {
    console.error("GO is null");
    return;
  }
  s[oo] = e && i;
}
function X1(s, e) {
  if (s.userData?.components)
    for (const t of s.userData.components)
      e(t);
}
const Th = /* @__PURE__ */ new Map(), f0 = Symbol("prewarmFlag"), bp = Symbol("waitingForPrewarm"), vp = w("debugprewarm");
function Q1(s, e) {
  if (!s || s[f0] === !0 || s[bp] === !0) return;
  Th.has(e) || Th.set(e, []), s[bp] = !0, Th.get(e).push(s), vp && console.debug("register prewarm", s.name);
}
let By = null, Fy = null;
function Y1(s) {
  if (!s) return;
  const e = Th.get(s);
  if (!e?.length) return;
  const t = s.mainCamera;
  if (t) {
    vp && console.log("prewarm", e.length, "objects", [...e]);
    const i = s.renderer;
    if (i.compile) {
      const n = s.scene;
      i.compile(n, t), By ??= new Jw(64), Fy ??= new ex(1e-3, 9999999, By), Fy.update(i, n);
      for (const o of e)
        o[f0] = !0, o[bp] = !1;
      e.length = 0, vp && console.log("prewarm done");
    }
  }
}
he.registerCallback(ce.ContextCreated, (s) => {
  const e = s.context;
  iP(e), J1(e);
});
const od = w("debugcomponents"), zy = "eff8ba80-635d-11ec-90d6-0242ac120003";
class Tt {
  get seed() {
    return this._seed;
  }
  set seed(e) {
    this._seed = e;
  }
  _originalSeed;
  _seed;
  constructor(e) {
    typeof e == "string" && (e = Tt.hash(e)), this._originalSeed = e, this._seed = e;
  }
  reset() {
    this._seed = this._originalSeed;
  }
  generateUUID(e) {
    if (typeof e == "string")
      return Kg(e, zy);
    const t = this._seed;
    return this._seed -= 1, Kg(t.toString(), zy);
  }
  initialize(e) {
    typeof e == "string" ? this._seed = Tt.hash(e) : this._seed = e;
  }
  static createFromString(e) {
    return new Tt(this.hash(e));
  }
  static hash(e) {
    let t = 0;
    for (let i = 0; i < e.length; i++)
      t = e.charCodeAt(i) + ((t << 5) - t);
    return t;
  }
}
var K1 = /* @__PURE__ */ ((s) => (s.NewInstanceCreated = "new-instance-created", s.InstanceDestroyed = "instance-destroyed", s))(K1 || {});
class Z1 {
  guid;
  dontSave;
  constructor(e) {
    this.guid = e;
  }
}
function Hd(s, e, t = !0, i) {
  if (!s) return;
  const n = s;
  if (Wi(s, t), !e) {
    console.warn("Can not send destroy: No networking connection provided", s.guid);
    return;
  }
  if (!e.isConnected) {
    L() && console.debug("Can not send destroy: not connected", s.guid);
    return;
  }
  let o = s.guid;
  if (!o && n.uuid && (o = n.uuid), !o) {
    console.warn("Can not send destroy: failed to find guid", s);
    return;
  }
  p0(o, e, i);
}
function p0(s, e, t) {
  const i = new Z1(s);
  t?.saveInRoom === !1 && (i.dontSave = !0), e.send("instance-destroyed", i, vn.Queued);
}
function J1(s) {
  s.connection.beginListen("instance-destroyed", (e) => {
    od && console.log("[Remote] Destroyed", s.scene, e);
    const t = O0(e.guid, s.scene);
    t && Wi(t);
  });
}
class jI {
  /** File to download */
  filename;
  /** Checksum to verify its the correct file */
  hash;
  /** Expected size of the referenced file and its dependencies */
  size;
  constructor(e, t, i) {
    this.filename = e, this.hash = t, this.size = i;
  }
}
class eP {
  guid;
  originalGuid;
  seed;
  visible;
  hostData;
  dontSave;
  parent;
  position;
  rotation;
  scale;
  /** Set to true to prevent this model from being instantiated */
  preventCreation = void 0;
  /**
   * When set this will delete the server state when the user disconnects
   */
  deleteStateOnDisconnect;
  constructor(e, t) {
    this.originalGuid = e, this.guid = t;
  }
}
function m0(s, e, t, i) {
  const n = s;
  if (!n.guid)
    return console.warn("Can not instantiate: No guid", n), null;
  if (e.context || (e.context = N.Current), !e.context)
    return console.error("Missing network instantiate options / reference to network connection in sync instantiate"), null;
  const o = e ? { ...e } : null, { instance: r, seed: a } = nP(n, e);
  if (r) {
    const l = r;
    if (l.guid) {
      od && console.log("[Local] new instance", "gameobject:", r?.guid);
      const c = new eP(n.guid, l.guid);
      c.seed = a, e.deleteOnDisconnect === !0 && (c.deleteStateOnDisconnect = !0), o && (o.position && (c.position = { x: o.position.x, y: o.position.y, z: o.position.z }), o.rotation && (c.rotation = { x: o.rotation.x, y: o.rotation.y, z: o.rotation.z, w: o.rotation.w }), o.scale && (c.scale = { x: o.scale.x, y: o.scale.y, z: o.scale.z })), c.position || (c.position = { x: l.position.x, y: l.position.y, z: l.position.z }), c.rotation || (c.rotation = { x: l.quaternion.x, y: l.quaternion.y, z: l.quaternion.z, w: l.quaternion.w }), c.scale || (c.scale = { x: l.scale.x, y: l.scale.y, z: l.scale.z }), c.visible = n.visible, o?.parent && (typeof o.parent == "string" ? c.parent = o.parent : c.parent = o.parent.guid), c.hostData = t, i === !1 && (c.dontSave = !0), !e?.context?.connection && L() && console.debug("Object will be instantiated but it will not be synced: not connected", n.guid), e.context.connection.isInRoom && Fr.push(new WeakRef(l)), e?.context?.connection.send("new-instance-created", c);
    } else console.warn("Missing guid, can not send new instance event", l);
  }
  return r;
}
function tP() {
  return Math.random() * 9999999;
}
const Fr = new Array();
function iP(s) {
  s.connection.beginListen("new-instance-created", async (e) => {
    const t = await oP(e.originalGuid, s.scene);
    if (e.preventCreation === !0)
      return;
    if (!t) {
      console.warn("could not find object that was instantiated: " + e.guid);
      return;
    }
    const i = new Nn();
    e.position && (i.position = new b(e.position.x, e.position.y, e.position.z)), e.rotation && (i.rotation = new $(e.rotation.x, e.rotation.y, e.rotation.z, e.rotation.w)), e.scale && (i.scale = new b(e.scale.x, e.scale.y, e.scale.z)), i.parent = e.parent, e.seed && (i.idProvider = new Tt(e.seed)), i.visible = e.visible, i.context = s, od && s.alias && console.log("[Remote] instantiate in: " + s.alias);
    const n = va(t, i);
    Fr.push(new WeakRef(n)), n && (e.parent === "scene" && s.scene.add(n), od && console.log("[Remote] new instance", "gameobject:", n?.guid, t));
  }), s.connection.beginListen("left-room", () => {
    Fr.length > 0 && console.debug(`Left networking room, cleaning up ${Fr.length} instantiated objects`);
    for (const e of Fr) {
      const t = e.deref();
      t && t.destroy();
    }
    Fr.length = 0;
  });
}
function nP(s, e) {
  const t = tP(), i = e ?? new Nn();
  i.idProvider = new Tt(t);
  const n = va(s, i);
  return { seed: t, instance: n };
}
const g0 = {};
function sP(s, e) {
  g0[s] = e;
}
async function oP(s, e) {
  const t = g0[s];
  if (t != null) {
    const i = await t(s);
    if (i) return i;
  }
  return y0(s, e);
}
function y0(s, e) {
  if (e === null || !s) return null;
  if (e.guid === s)
    return e;
  if (e.children)
    for (const t of e.children) {
      const i = y0(s, t);
      if (i)
        return i;
    }
  return null;
}
const mc = w("gizmos"), dt = w("debugextension"), hf = w("debugtypes");
class rP {
  _types = /* @__PURE__ */ new Map();
  constructor() {
    hf && console.warn("TypeStore: Created", this);
  }
  /**
   * add a type to the store
   */
  add(e, t) {
    hf && console.warn("ADD TYPE", e);
    const i = this._types.get(e);
    i ? hf && i !== t && console.warn("Type name exists multiple times in your project and may lead to runtime errors:", e) : this._types.set(e, t);
  }
  /**
   * @returns the type for the given key if registered
   */
  get(e) {
    return this._types.get(e) || null;
  }
  /**
   * @returns the key/name for the given type if registered
   */
  getKey(e) {
    for (const [t, i] of this._types)
      if (i === e)
        return t;
    return null;
  }
}
const aP = Symbol("BuiltInType"), P = new rP(), BI = function(s) {
  P.get(s.name) || P.add(s.name, s);
}, Im = w("debugresolvedependencies"), lP = ["/extensions/", "extensions/"], cP = [
  { prefix: "/nodes/", dependencyName: "node" },
  { prefix: "/meshes/", dependencyName: "mesh" },
  { prefix: "/materials/", dependencyName: "material" },
  { prefix: "/textures/", dependencyName: "texture" },
  { prefix: "/animations/", dependencyName: "animation" },
  // legacy support
  { prefix: "nodes/", dependencyName: "node" },
  { prefix: "meshes/", dependencyName: "mesh" },
  { prefix: "materials/", dependencyName: "material" },
  { prefix: "textures/", dependencyName: "texture" },
  { prefix: "animations/", dependencyName: "animation" }
];
async function Lm(s, e) {
  Im && console.log(s, e);
  const t = [];
  wp(cP, s, e, t);
  const i = await Promise.all(t);
  return typeof e == "string" && i.length === 1 ? i[0] : i;
}
function hP(s, e) {
  return !s || !e ? !1 : s["needle:identifier"] != null && e["needle:identifier"] != null ? s["needle:identifier"] === e["needle:identifier"] : !1;
}
function dP(s, e) {
  s["needle:identifier"] = e;
}
function wp(s, e, t, i) {
  if (typeof t == "object" && t !== void 0 && t !== null)
    for (const n of Object.keys(t)) {
      const o = t[n];
      if (typeof o == "string") {
        const r = Uy(e, o);
        if (r != null)
          typeof r.then == "function" ? i.push(r.then((a) => t[n] = a)) : t[n] = r;
        else {
          const a = Ny(s, e, o);
          if (a) {
            i.push(a.then((l) => (t[n] = l, l)));
            continue;
          }
        }
      } else if (Array.isArray(o))
        for (let r = 0; r < o.length; r++) {
          const a = o[r], l = Uy(e, a);
          if (l !== null) {
            typeof l.then == "function" ? i.push(l.then((c) => o[r] = c)) : o[r] = l;
            continue;
          }
          for (const c of s) {
            const h = _0(c.prefix, a);
            if (h >= 0) {
              Im && console.log(c, h, c.dependencyName), i.push(e.getDependency(c.dependencyName, h).then((d) => o[r] = d));
              break;
            }
          }
          typeof a == "object" && wp(s, e, a, i);
        }
      else typeof o == "object" && wp(s, e, o, i);
    }
  else if (typeof t == "string") {
    const n = Ny(s, e, t);
    n && i.push(n);
  }
}
function Uy(s, e) {
  if (s && s.plugins && typeof e == "string") {
    for (const t of lP)
      if (e.startsWith(t)) {
        let i = e.substring(t.length);
        const n = i.indexOf("/");
        n >= 0 && (i = i.substring(0, n));
        const o = s.plugins[i];
        if (dt && console.log(i, o), typeof o?.resolve == "function") {
          const r = e.substring(t.length + i.length + 1);
          return o.resolve(s, r);
        }
        break;
      }
  }
  return null;
}
function Ny(s, e, t) {
  for (const i of s) {
    const n = _0(i.prefix, t);
    if (n >= 0)
      return Im && console.warn("GET DEPENDENCY", i, n, i.dependencyName), e.getDependency(i.dependencyName, n);
  }
  return null;
}
function _0(s, e) {
  if (typeof e == "string" && e.startsWith(s)) {
    const t = e.substring(s.length), i = Number.parseInt(t);
    if (i >= 0)
      return i;
  }
  return -1;
}
const df = "NEEDLE_persistent_assets";
function uP(s) {
  return s?.___persistentAsset === !0;
}
class fP {
  get name() {
    return df;
  }
  parser;
  constructor(e) {
    this.parser = e;
  }
  async afterRoot(e) {
    if (!this.parser?.json?.extensions) return;
    const t = this.parser.json.extensions[df];
    if (!t) return;
    dt && console.log(t);
    const i = new Array();
    for (const n of t?.assets) {
      const o = Lm(this.parser, n);
      o && i.push(o);
    }
    await Promise.all(i);
  }
  resolve(e, t) {
    const i = Number.parseInt(t);
    if (i >= 0) {
      dt && console.log(t);
      const n = e.json.extensions[df];
      if (n) {
        const o = n?.assets[i];
        if (o && typeof o == "object") {
          o.___persistentAsset = !0;
          const r = o.__type;
          r && P.get(r);
        }
        return o;
      }
    }
    return null;
  }
}
const wn = w("debugserializer");
class pP {
  register(e, t) {
    if (this.typeMap.has(e)) {
      const i = this.typeMap.get(e);
      if (i === t) return;
      wn && console.warn("Type: " + e + " is already registered", t, i);
    }
    wn && console.log("Register type serializer", t.name, t, e), this.typeMap.set(e, t);
  }
  /** type > serializer map */
  typeMap = /* @__PURE__ */ new Map();
  getSerializer(e) {
    if (e)
      return this.typeMap.get(e);
  }
  getSerializerForConstructor(e, t = 0) {
    if (t > 20) return;
    if (!e || !e.constructor) {
      wn && console.log("invalid type");
      return;
    }
    const i = e.name, n = this.getSerializer(e);
    if (n !== void 0)
      return wn && console.log("FOUND SERIALIZER", n?.name, e.name, e.constructor.name, "for type: " + i, n, e, this.typeMap), n;
    const o = Object.getPrototypeOf(e);
    if (o && o !== e) {
      const r = this.getSerializerForConstructor(o, ++t);
      if (r) {
        const a = o.constructor || o.prototype;
        wn && console.log("FOUND SERIALIZER(in constructor) " + a.constructor.name, a.name, a, r), this.register(a, r);
      }
      return r;
    }
    wn && console.warn("No serializer found for " + i, e, e.name, e.constructor.name);
  }
}
const rd = new pP();
class Xi {
  name;
  // register<T>(c: Constructor<T> | Constructor<T>[])
  // {
  //     if (Array.isArray(c)) {
  //         for (const t of c) {
  //             helper.register(t.name, this);
  //         }
  //     }
  //     else {
  //         helper.register(c.name, this);
  //     }
  // }
  constructor(e, t) {
    if (this.name = t, Array.isArray(e))
      for (const i of e)
        rd.register(i, this);
    else
      rd.register(e, this);
  }
}
class mP {
  isDevMode = rn();
  cache = {};
  /** only call when assigning values for the very first time */
  registerDefinedKeys(e, t) {
    if (this.isDevMode && this.cache[e] === void 0) {
      this.cache[e] = Object.keys(t);
      const i = t;
      i.$serializedTypes && Object.keys(i.$serializedTypes) && this.cache[e].push(...Object.keys(i.$serializedTypes)), wn && console.log("registerDefinedKeys for " + e, this.cache[e], t);
    }
  }
  getDefinedKey(e, t) {
    return this.cache[e] === void 0 ? !1 : this.cache[e].includes(t);
  }
}
class b0 {
  root;
  gltf;
  /** the url of the glb that is currently being loaded */
  gltfId;
  object;
  target;
  nodeId;
  nodeToObject;
  objectToNode;
  context;
  path;
  type;
  /** the serializable attribute for this field (target.path) */
  serializable;
  /** holds information if a field was undefined before serialization. This gives us info if we might want to warn the user about missing attributes */
  implementationInformation;
  constructor(e) {
    this.root = e;
  }
}
function gP(s, e) {
  const t = s.$serializedTypes;
  if (t === void 0) return null;
  const i = {};
  for (const o in t) {
    const r = s[o];
    if (r != null && typeof r == "object") {
      const a = rd.getSerializerForConstructor(r);
      if (a) {
        i[o] = a.onSerialize(r, e);
        continue;
      }
    }
    i[o] = r;
  }
  function n(o) {
    const r = P._types;
    for (const [a, l] of r)
      if (l === s.constructor)
        return a;
    return o.__name || o.constructor.name;
  }
  return i.name = n(s), typeof s.guid == "string" && (i.guid = s.guid), i;
}
const Eh = [];
function v0(s, e) {
  if (!s) return e;
  typeof s.$serializedTypes == "object" && (e || (e = {}), Object.assign(e, s.$serializedTypes));
  const t = Object.getPrototypeOf(s);
  return v0(t, e);
}
function xp(s, e, t) {
  if (!s) return !1;
  if (t.target = s, s.onBeforeDeserialize !== void 0) {
    const n = s.onBeforeDeserialize(e, t);
    if (typeof n == "boolean") return n;
  }
  const i = v0(s);
  if (e) {
    if (typeof e.guid == "string" && (s.guid = e.guid), i)
      for (const n in i) {
        let o = function(l) {
          const h = l.type;
          return h ? Sp(a, h, t, void 0, s[n]) : Sp(a, l, t, void 0, s[n]);
        };
        const r = i[n], a = e[n];
        if (wn && console.log(n, a, s, r), !(s[n] !== void 0 && a === void 0) && (t.type = void 0, t.path = n, t.serializable = r, !(s.onBeforeDeserializeMember !== void 0 && s.onBeforeDeserializeMember(n, a, t) === !0))) {
          if (r === null)
            s[n] = a;
          else {
            if (Array.isArray(r))
              for (let l = 0; l < r.length; l++) {
                const c = r[l], h = o(c);
                if (h !== void 0 || l === r.length - 1) {
                  s[n] = h;
                  break;
                }
              }
            else
              s[n] = o(r);
            Eh.length = 0;
          }
          s.onAfterDeserializeMember !== void 0 && s.onAfterDeserializeMember(n, a, t);
        }
      }
    bP(s, e);
  }
  return _P(s, e, t.implementationInformation), s.onAfterDeserialize !== void 0 && s.onAfterDeserialize(e, t), !0;
}
const yP = w("noerrors");
function _P(s, e, t) {
  if (yP || !e || !rn() || !s || s.constructor && s.constructor[aP] === !0) return;
  const i = s.constructor?.name, n = Object.getOwnPropertyNames(e);
  for (const o of n) {
    if (o === "sourceId") continue;
    const r = s[o];
    if (r == null) continue;
    const a = e[o];
    if (t?.getDefinedKey(i, o) === !1) {
      const l = o.charAt(0).toUpperCase() + o.slice(1);
      t.getDefinedKey(i, l) && (Go(Ui.Warn, '<strong>Please rename</strong> "' + l + '" to "' + o + '" in ' + i), console.warn('Please use lowercase for field: "' + l + '" in ' + i, a, s));
      continue;
    }
    if (a != null) {
      if (typeof a == "object" && (r === void 0 || !r.isObject3D)) {
        if (typeof a.node == "number" || typeof a.guid == "string") {
          if (a.could_not_resolve)
            continue;
          if (!(r !== void 0 && Object.keys(r).length > 1)) {
            Go(Ui.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(Object3D)
${o}? : Object3D;

in ${i}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">See documentation</a>`), console.warn(i, o, s[o], s);
            continue;
          }
        } else if (!Array.isArray(r)) {
          const l = r.constructor?.name;
          if (l === "Object" && !r.constructor["did_warn:missing_serializable"]) {
            r.constructor["did_warn:missing_serializable"] = !0;
            const c = 'You might be missing a @serializable(Type) decorator for field "' + o + '" in ' + i + ".ts";
            console.warn(c + `
${o}:`, a, l), Go(Ui.Warn, "Dev Warning: Are you missing a type in @serializable? Please check the browser console for details");
          }
        }
      }
      if (typeof r == "string" && typeof a == "string" && (a.endsWith(".gltf") || a.endsWith(".glb"))) {
        Go(Ui.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(AssetReference)
${o}? : AssetReference;

in script ${i}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">documentation</a>`), console.warn(i, o, s[o], s);
        continue;
      }
    }
  }
}
function bP(s, e) {
  for (const t of Object.keys(e)) {
    const i = e[t];
    if (typeof i == "object" && i !== null && i !== void 0) {
      const n = s[t];
      if (!n) {
        wn && console.log(t, "is undefined on", s);
        continue;
      }
      for (const o of Object.keys(i))
        if (n[o] === void 0 && $y(i[o]) && !$y(n)) {
          const a = vP(n, o);
          if (a && (a?.writable === void 0 || a?.writable === !1) && a.set === void 0) {
            wn && console.warn('Property is not writable "' + o + '"', n, a, i[o], n[o]);
            continue;
          }
          n[o] = i[o];
        }
    }
  }
}
function vP(s, e) {
  for (; s; ) {
    const t = Object.getOwnPropertyDescriptor(s, e);
    if (t) return t;
    s = Object.getPrototypeOf(s);
  }
}
function $y(s) {
  switch (typeof s) {
    case "number":
    case "string":
    case "boolean":
      return !0;
  }
  return !1;
}
function Sp(s, e, t, i, n) {
  let o = typeof e == "function" && e.prototype === void 0, r = e;
  if (o)
    try {
      if (r = e?.call(e, n), o = !1, r == null) return;
    } catch (h) {
      console.error("Error in callback", h, s);
    }
  if (t.type = r, !o && n && (n instanceof _e || n instanceof H || n instanceof Tn || n instanceof no))
    return n;
  if (i || (i = {
    serializer: rd.getSerializerForConstructor(r)
  }), n && typeof n == "object" && uP(n)) {
    if (n.__concreteInstance)
      return n.__concreteInstance;
    const h = n;
    if (!h.$serializedTypes && r.prototype.$serializedTypes && (h.$serializedTypes = r.prototype.$serializedTypes), h.$serializedTypes && xp(h, s, t), n && r !== void 0)
      try {
        let d = null;
        i.serializer && (d = i.serializer.onDeserialize(s, t)), d || (d = new r(), dt && console.log("Create concrete instance for persistent asset", n, "instance:", d), ya(d, n)), n.__concreteInstance = d, n = d;
      } catch (d) {
        console.error("Error creating instance or creating values on instance", d, n, r);
      }
    return n;
  }
  if (Array.isArray(s)) {
    const h = [];
    for (let d = 0; d < s.length; d++) {
      const f = s[d], p = Sp(f, e, t, i, f);
      h.push(p);
    }
    return h;
  }
  const a = i?.serializer;
  if (a)
    return a.onDeserialize(s, t);
  if (n instanceof Te) return n;
  let l;
  if (s && (s.isMaterial || s.isTexture || s.isObject3D || s instanceof no))
    l = s;
  else {
    if (s === void 0) return;
    if (s === null && (r === _e || r === Te || r === H || r === no))
      return null;
    try {
      l = new r(...wP(s));
    } catch (h) {
      console.error("Error creating " + t.path, t.target, h);
      return;
    }
  }
  const c = l;
  return c.$serializedTypes && xp(c, s, t), l;
}
function wP(s) {
  if (Eh.length = 0, typeof s == "object" && s !== null && s !== void 0)
    for (const e of Object.keys(s))
      Eh.push(s[e]);
  return Eh;
}
const Cp = Symbol("assigned component properties");
function ya(s, e, t, i) {
  if (e == null || s == null) return;
  s[Cp] = !0;
  const n = s.constructor?.name ?? "unknown";
  t?.registerDefinedKeys(n, s);
  for (const o of Object.keys(e)) {
    const r = xP(s, o);
    if (typeof r?.value != "function") {
      if (!r || r.writable === !0) {
        const a = i?.onAssign ? i.onAssign(e, o, e[o]) : e[o];
        s[o] = a;
      } else if (r?.set !== void 0) {
        const a = i?.onAssign ? i.onAssign(e, o, e[o]) : e[o];
        s[o] = a;
      }
    }
  }
  delete s[Cp];
}
function xP(s, e) {
  let t;
  do
    t = Object.getOwnPropertyDescriptor(s, e);
  while (!t && (s = Object.getPrototypeOf(s)));
  return t;
}
const w0 = Symbol("customVisibilityFlag");
function hs(s, e) {
  s.layers[w0] = e;
}
const Wy = Symbol("DidPatchLayers");
function SP() {
  const s = ao.prototype;
  if (s[Wy]) return;
  s[Wy] = !0;
  const e = s.test;
  s.test = function(t) {
    return this[w0] === !1 ? !1 : e.call(this, t);
  };
}
SP();
Object.defineProperty(pe.prototype, "fov", {
  get: function() {
    return this._fov;
  },
  set: function(s) {
    const e = s !== this._fov;
    this._fov = s, e && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
Object.defineProperty(pe.prototype, "near", {
  get: function() {
    return this._near;
  },
  set: function(s) {
    const e = s !== this._near;
    this._near = s, e && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
Object.defineProperty(pe.prototype, "far", {
  get: function() {
    return this._far;
  },
  set: function(s) {
    const e = s !== this._far;
    this._far = s, e && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
const x0 = /* @__PURE__ */ new Map();
function CP(s, e) {
  if (!s) return;
  if (!e) {
    console.warn("No prototype found", s, s.prototype, s.constructor);
    return;
  }
  const t = x0.get(e);
  t && t.apply(s);
}
function PP(s) {
  const e = OP(s.prototype);
  x0.set(s, e);
}
function OP(s) {
  return new kP(s);
}
class kP {
  $symbol;
  extensions;
  descriptors;
  constructor(e) {
    this.$symbol = Symbol("prototype-extension"), this.extensions = Object.keys(e), this.descriptors = new Array();
    for (let t = 0; t < this.extensions.length; t++) {
      const i = this.extensions[t], n = Object.getOwnPropertyDescriptor(e, i);
      n && this.descriptors.push(n);
    }
  }
  apply(e) {
    if (!e[this.$symbol]) {
      e[this.$symbol] = !0;
      for (let t = 0; t < this.extensions.length; t++) {
        const i = this.extensions[t], n = this.descriptors[t];
        n && Object.defineProperty(e, i, n);
      }
    }
  }
}
const MP = w("debuggetcomponent"), Vy = () => MP || globalThis.NEEDLE_DEBUG_GETCOMPONENT === !0;
function RP(s) {
  return s == null || s.isObject3D ? s : s.object && s.object.isObject3D ? s.object : s;
}
function S0(s, e) {
  if (!s || !s.userData.components) return e;
  const t = s.userData.components.indexOf(e);
  return t < 0 || (Em.dispatchComponentLifecycleEvent("removing-component", e), e.gameObject = null, s.userData.components.splice(t, 1)), e;
}
function Gd(s, e, t) {
  const i = ka(s, e);
  return i || An(s, e, t);
}
const C0 = new Tt("addComponentIdProvider");
function ta(s, e, t = !0) {
  s.userData || (s.userData = {}), s.userData.components || (s.userData.components = []), s.userData.components.push(e), e.gameObject = s, (e.guid === void 0 || e.guid === "invalid") && (e.guid = C0.generateUUID()), jm(s), Um(e, e.context);
  try {
    t && e.__internalAwake && (zl(s), e.activeAndEnabled && e.__internalAwake()), Em.dispatchComponentLifecycleEvent("component-added", e);
  } catch (i) {
    console.error(i);
  }
  return e;
}
function An(s, e, t, i) {
  if (typeof e == "function") {
    const n = new e();
    t && n.__internalNewInstanceCreated(t);
    let o = !0;
    return i?.callAwake != null && (o = i.callAwake), ta(s, n, o);
  }
  if (e.destroyed)
    return console.warn("Can not move/add a destroyed component", e), e;
  if (e.gameObject === s) return e;
  if (e.gameObject && e.gameObject.userData?.components) {
    const n = e.gameObject.userData.components.indexOf(e);
    e.gameObject.userData.components.splice(n, 1);
  }
  if (s.userData || (s.userData = {}), !s.userData.components) s.userData.components = [];
  else if (s.userData.components.includes(e)) return e;
  return s.userData.components.push(e), e.gameObject = s, (e.guid === void 0 || e.guid === "invalid") && (e.guid = C0.generateUUID()), t && e._internalInit(t), Um(e, e.context), e;
}
function TP(s) {
  if (s.gameObject && s.gameObject.userData.components) {
    const e = s.gameObject.userData.components.indexOf(s);
    s.gameObject.userData.components.splice(e, 1);
  }
  s.__internalDisable && s.__internalDisable(), cs(s, s.context ?? N.Current), s.destroy(), s.gameObject = null;
}
let Hy = !1;
function P0(s, e, t) {
  if (s == null) return null;
  if (!s.isObject3D)
    return console.error("Object is not object3D"), null;
  if (!s?.userData?.components || (typeof e == "string" && (Hy || (Hy = !0, console.warn(`Accessing components by name is not supported.
Please use the component type instead. This may keep working in local development but it will fail when bundling your application.

You can import other modules your main module to get access to types
or if you use npmdefs you can make types available globally using globalThis:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis`, e))), Vy() && console.log("[onGetComponent] FIND", e), e == null))
    return null;
  for (let i = 0; i < s.userData.components.length; i++) {
    const n = s.userData.components[i];
    let o = Object.getPrototypeOf(n);
    for (; o; ) {
      if (o === e.prototype)
        if (Vy() && console.log("[onGetComponent] MATCH BY PROTOYPE", o), t) t.push(n);
        else return n;
      o = Object.getPrototypeOf(o);
    }
  }
  return t || null;
}
function ka(s, e) {
  const t = P0(s, e);
  return t ? Array.isArray(t) ? t[0] : t : null;
}
function qd(s, e, t, i = !0) {
  return t || (t = []), i && (t.length = 0), P0(s, e, t), t;
}
function Xd(s, e, t) {
  if (t === !1 && s[oo] === !1) return null;
  const i = ka(s, e);
  if (t === !1 && i?.enabled === !1) return null;
  if (i) return i;
  for (let n = 0; n < s?.children?.length; n++) {
    const o = Xd(s.children[n], e);
    if (o) return o;
  }
  return null;
}
function gc(s, e, t, i = !0) {
  t || (t = []), i && (t.length = 0), qd(s, e, t, !1);
  for (let n = 0; n < s?.children?.length; n++)
    gc(s.children[n], e, t, !1);
  return t;
}
function ad(s, e) {
  if (!s) return null;
  if (Array.isArray(s)) {
    for (let i = 0; i < s.length; i++) {
      const n = RP(s[i]), o = ad(n, e);
      if (o) return o;
    }
    return null;
  }
  const t = ka(s, e);
  return t || (s.parent ? ad(s.parent, e) : null);
}
function Dm(s, e, t, i = !0) {
  return t || (t = []), i && (t.length = 0), s ? (qd(s, e, t, !1), s.parent ? Dm(s.parent, e, t, !1) : t) : t;
}
function Qd(s, e = void 0, t = !0) {
  if (!s) return null;
  if (!e && (e = N.Current, !e))
    return console.error("Can not search object without any needle context or scene!!!"), null;
  let i = e;
  if (i.isScene || (i = e?.scene), !i) return null;
  const n = Xd(i, s, t);
  return n || null;
}
function EP(s, e, t = void 0) {
  if (!s) return e ?? [];
  if (e || (e = []), e.length = 0, !t && (t = N.Current, !t))
    return console.error("Can not search object without any needle context or scene!!!"), e;
  "scene" in t && (t = t.scene);
  const i = t;
  return i && gc(i, s, e, !1), e;
}
function jm(s) {
  s && s.isObject3D === !0 && CP(s, M);
}
if (nd.experimentalSmartHierarchyUpdate) {
  const s = M.prototype.add;
  M.prototype.add = function(...i) {
    return cf(), s.apply(this, i);
  };
  const e = M.prototype.attach;
  M.prototype.attach = function(...i) {
    return cf(), e.apply(this, i);
  };
  const t = M.prototype.remove;
  M.prototype.remove = function(...i) {
    return cf(), t.apply(this, i);
  };
}
M.prototype.SetActive = function(s) {
  this.visible = s;
};
M.prototype.setActive = function(s) {
  this.visible = s;
};
M.prototype.destroy = function() {
  Wi(this);
};
M.prototype.addComponent = function(s, e) {
  return An(this, s, e);
};
M.prototype.addNewComponent = function(s, e) {
  return An(this, s, e);
};
M.prototype.removeComponent = function(s) {
  return S0(this, s);
};
M.prototype.getOrAddComponent = function(s, e) {
  return Gd(this, s, e);
};
M.prototype.getComponent = function(s) {
  return ka(this, s);
};
M.prototype.getComponents = function(s, e) {
  return qd(this, s, e);
};
M.prototype.getComponentInChildren = function(s) {
  return Xd(this, s);
};
M.prototype.getComponentsInChildren = function(s, e) {
  return gc(this, s, e);
};
M.prototype.getComponentInParent = function(s) {
  return ad(this, s);
};
M.prototype.getComponentsInParent = function(s, e) {
  return Dm(this, s, e);
};
Object.getOwnPropertyDescriptor(M.prototype, "activeSelf") || Object.defineProperty(M.prototype, "activeSelf", {
  get: function() {
    return yc(this);
  },
  set: function(s) {
    Ih(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldPosition") || Object.defineProperty(M.prototype, "worldPosition", {
  get: function() {
    return this instanceof _b ? Z(this.object) : Z(this);
  },
  set: function(s) {
    ut(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldQuaternion") || Object.defineProperty(M.prototype, "worldQuaternion", {
  get: function() {
    return this instanceof _b ? be(this.object) : be(this);
  },
  set: function(s) {
    an(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldRotation") || Object.defineProperty(M.prototype, "worldRotation", {
  get: function() {
    return xm(this);
  },
  set: function(s) {
    LC(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldScale") || Object.defineProperty(M.prototype, "worldScale", {
  get: function() {
    return $e(this);
  },
  set: function(s) {
    tc(this, s);
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldForward") || Object.defineProperty(M.prototype, "worldForward", {
  get: function() {
    return G().set(0, 0, 1).applyQuaternion(be(this));
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldRight") || Object.defineProperty(M.prototype, "worldRight", {
  get: function() {
    return G().set(1, 0, 0).applyQuaternion(be(this));
  }
});
Object.getOwnPropertyDescriptor(M.prototype, "worldUp") || Object.defineProperty(M.prototype, "worldUp", {
  get: function() {
    return G().set(0, 1, 0).applyQuaternion(be(this));
  }
});
PP(M);
class oe extends se {
  alpha = 1;
  get isRGBAColor() {
    return !0;
  }
  set a(e) {
    this.alpha = e;
  }
  get a() {
    return this.alpha;
  }
  constructor(e, t, i, n) {
    super(), typeof e == "number" && typeof t == "number" && typeof i == "number" ? (this.set(e, t, i), this.alpha = typeof n == "number" ? n : 1) : e !== void 0 && (this.set(e), this.alpha = 1);
  }
  clone() {
    const e = super.clone();
    return e.alpha = this.alpha, e;
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, "alpha" in e && typeof e.alpha == "number" ? this.alpha = e.alpha : typeof e.a == "number" && (this.alpha = e.a), this;
  }
  lerp(e, t) {
    const i = e;
    return i.alpha != null && (this.alpha = j.lerp(this.alpha, i.alpha, t)), super.lerp(e, t);
  }
  lerpColors(e, t, i) {
    const n = e, o = t;
    return n.alpha != null && o.alpha != null && (this.alpha = j.lerp(n.alpha, o.alpha, i)), super.lerpColors(e, t, i);
  }
  multiply(e) {
    const t = e;
    return t.alpha != null && (this.alpha = this.alpha * t.alpha), super.multiply(e);
  }
  fromArray(e, t = 0) {
    return this.alpha = e[t + 3], super.fromArray(e, t);
  }
  static fromColorRepresentation(e) {
    if (typeof e == "string") {
      if (e.trim() === "transparent")
        return new oe(0, 0, 0, 0);
      if (e.startsWith("#") && e.length === 9) {
        const t = parseInt(e.slice(1, 9), 16), i = t >> 24 & 255, n = t >> 16 & 255, o = t >> 8 & 255, r = t >> 0 & 255;
        return new oe(i / 255, n / 255, o / 255, r / 255);
      } else if (e.startsWith("#")) {
        const t = parseInt(e.slice(1), 16), i = t >> 16 & 255, n = t >> 8 & 255, o = t >> 0 & 255;
        return new oe(i / 255, n / 255, o / 255, 1);
      } else if (e.startsWith("rgba")) {
        const t = e.slice(5, -1).split(",").map(Number);
        return new oe(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
      } else if (e.startsWith("rgb")) {
        const t = e.slice(4, -1).split(",").map(Number);
        return new oe(t[0] / 255, t[1] / 255, t[2] / 255, 1);
      }
    } else if (Array.isArray(e)) {
      if (e.length === 4)
        return new oe(e[0], e[1], e[2], e[3]);
      if (e.length === 3)
        return new oe(e[0], e[1], e[2], 1);
      console.error("Invalid color array length. Expected 3 or 4, got " + e.length);
    }
    return new oe(e);
  }
}
const Ah = w("debuggetcomponent"), Ko = w("debuginstantiate");
class Nn {
  idProvider;
  parent;
  keepWorldPosition;
  position;
  rotation;
  scale;
  visible;
  context;
  components;
  clone() {
    const e = new Nn();
    return e.idProvider = this.idProvider, e.parent = this.parent, e.keepWorldPosition = this.keepWorldPosition, e.position = this.position?.clone(), e.rotation = this.rotation?.clone(), e.scale = this.scale?.clone(), e.visible = this.visible, e.context = this.context, e.components = this.components, e;
  }
  /** Copy fields from another object, clone field references */
  cloneAssign(e) {
    this.idProvider = e.idProvider, this.parent = e.parent, this.keepWorldPosition = e.keepWorldPosition, this.position = e.position?.clone(), this.rotation = e.rotation?.clone(), this.scale = e.scale?.clone(), this.visible = e.visible, this.context = e.context, this.components = e.components;
  }
}
function yc(s) {
  return s.visible;
}
function Ih(s, e) {
  return typeof e == "number" && (e = e > 0.5), s.visible = e, s.visible;
}
function AP(s) {
  return s[oo] || Bm(s);
}
function IP(s, e) {
  s[c0] = e;
}
function Bm(s) {
  return sn.isUsingInstancing(s);
}
function O0(s, e) {
  return ec(s, e, !0, !0);
}
const k0 = Symbol("isDestroyed");
function _a(s) {
  return s[k0];
}
function LP(s, e) {
  s[k0] = e;
}
const Pp = Symbol("isDontDestroy");
function el(s, e = !0) {
  s[Pp] = e;
}
const Lh = [], Dh = [];
function Wi(s, e = !0, t = !1) {
  Lh.length = 0, Dh.length = 0, Op(s, e, !0);
  for (const i of Lh)
    i.gameObject = null, i.context = null;
  for (const i of Dh)
    LP(i, !0), t && Re(i), $1(i);
  Dh.length = 0, Lh.length = 0;
}
function Op(s, e = !0, t = !0) {
  if (s == null)
    return;
  const i = s;
  if (i.isComponent) {
    if (i[Pp]) return;
    Lh.push(i);
    const r = i.gameObject;
    i.__internalDisable(), i.__internalDestroy(), i.gameObject = r;
    return;
  }
  if (s[Pp]) return;
  const n = s;
  Ah && console.log(n), Dh.push(n);
  const o = n.userData?.components;
  if (o != null && Array.isArray(o)) {
    let r = o.length;
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      Op(l, e, !1), o.length < r && (r = o.length, a--);
    }
  }
  if (e && n.children)
    for (const r of n.children)
      Op(r, e, !1);
  t && n.removeFromParent();
}
function ba(s, e, t = !0) {
  return M0(s, e, t);
}
function* Fm(s, e, t = !1, i = 999, n = 0) {
  if (s?.userData.components && !(n > i)) {
    for (const o of s.userData.components)
      e && o?.isComponent === !0 && o instanceof e ? yield o : yield o;
    if (t === !0)
      for (const o of s.children)
        yield* Fm(o, e, !0, i, n + 1);
  }
}
function M0(s, e, t, i = 0) {
  if (s) {
    if (s.isObject3D, i > 1e3) {
      console.warn("Failed to iterate components: too many levels");
      return;
    }
    if (s.userData?.components)
      for (let n = 0; n < s.userData.components.length; n++) {
        const o = s.userData.components[n];
        if (o?.isComponent === !0) {
          const r = e(o);
          if (r !== void 0) return r;
        }
      }
    if (t && s.children) {
      const n = i + 1;
      for (let o = 0; o < s.children.length; o++) {
        const r = s.children[o];
        if (!r) continue;
        const a = M0(r, e, t, n);
        if (a !== void 0) return a;
      }
    }
  }
}
function va(s, e) {
  if ("isAssetReference" in s)
    return s.instantiate(e ?? void 0);
  let t = null;
  e != null && (e.x !== void 0 ? (t = new Nn(), t.position = e) : t = e);
  let i = N.Current;
  t?.context && (i = t.context), Ah && i.alias && console.log("context", i.alias), t && !t.idProvider && (t.idProvider = new Tt(Date.now()));
  const n = [], o = {}, r = {}, a = R0(i, s, t, n, o, r);
  a && (jP(o), DP(r, o)), Ah && (hp(s, !0), hp(a, !0));
  const l = {};
  if (t?.components !== !1) {
    for (const c in n) {
      const h = n[c], d = h.guid;
      t && t.idProvider && (h.guid = t.idProvider.generateUUID(), l[d] = h.guid, Ah && console.log(h.name, h.guid)), Um(h, i), h.__internalNewInstanceCreated && h.__internalNewInstanceCreated();
    }
    for (const c in n) {
      const h = n[c];
      h.resolveGuids && h.resolveGuids(l), h.enabled !== !1 && (h.enabled = !0);
    }
    sd(i);
  }
  return a;
}
function R0(s, e, t, i, n, o) {
  if (!e || e[ci])
    return null;
  const r = e.userData;
  e.userData = {};
  const a = e.children;
  e.children = [];
  const l = e.clone(!1);
  if (jm(l), e.userData = r, e.children = a, n[e.uuid] = { original: e, clone: l }, Ko && console.log("ADD", e, l), e.type === "SkinnedMesh" && (o[e.uuid] = { original: e, clone: l }), t?.visible !== void 0 && (l.visible = t.visible), t?.idProvider) {
    l.uuid = t.idProvider.generateUUID();
    const h = l;
    h && (h.guid = l.uuid);
  }
  e.animations && e.animations.length > 0 && (l.animations = [...e.animations]);
  const c = e.parent;
  if (c && c.add(l), t?.position ? ut(l, t.position) : l.position.copy(e.position), t?.rotation ? an(l, t.rotation) : l.quaternion.copy(e.quaternion), t?.scale ? l.scale.copy(t.scale) : l.scale.copy(e.scale), t?.parent && t.parent !== "scene") {
    let h = null;
    if (typeof t.parent == "string" ? h = ec(t.parent, s.scene, !0) : h = t.parent, h) {
      const d = t.keepWorldPosition === !0 ? h.attach : h.add;
      d ? d.call(h, l) : console.error("Invalid parent object", h, "received when instantiating:", e);
    } else console.warn("could not find parent:", t.parent);
  }
  for (const [h, d] of Object.entries(e.userData))
    h !== "components" && (l.userData[h] = d);
  if (e.userData?.components) {
    const h = e.userData.components, d = [];
    l.userData.components = d;
    for (let f = 0; f < h.length; f++) {
      const p = h[f], g = new p.constructor();
      ya(g, p, void 0, {
        // onAssign: (source, key, value) => {
        //     if (typeof value === "object") {
        //         const serializable = source as ISerializable;
        //         if (serializable?.$serializedTypes?.[key]) {
        //             console.debug("TODO CLONE", key, value);
        //         }
        //     }
        //     return value;
        // }
      }), p[Mh] !== void 0 && (g[Mh] = p[Mh]), d.push(g), g.gameObject = l, i.push(g), n[p.guid] = { original: p, clone: g }, Em.dispatchComponentLifecycleEvent("component-added", g);
    }
  }
  t && (t.position = void 0, t.rotation = void 0, t.scale = void 0, t.parent = void 0, t.visible = void 0);
  for (const h in e.children) {
    const d = e.children[h], f = R0(s, d, t, i, n, o);
    f && (n[f.uuid] = { original: d, clone: f }, l.add(f));
  }
  return l;
}
function DP(s, e) {
  for (const t in s) {
    const i = s[t], n = i.original, o = n.skeleton, r = i.clone;
    if (!o) {
      console.warn("Skinned mesh has no skeleton?", i);
      continue;
    }
    const a = o.bones, l = r.skeleton.clone();
    r.skeleton = l, r.bindMatrix.clone().copy(n.bindMatrix), r.bindMatrixInverse.copy(n.bindMatrixInverse);
    const c = [];
    l.bones = c;
    for (let h = 0; h < a.length; h++) {
      const d = a[h], p = e[d.uuid].clone;
      c.push(p);
    }
  }
  for (const t in s) {
    const i = s[t].clone;
    i.skeleton.update(), i.bind(i.skeleton, i.bindMatrix), i.updateMatrixWorld(!0);
  }
}
function jP(s) {
  for (const e in s) {
    const i = s[e].clone;
    if (i?.isObject3D && i?.userData?.components)
      for (let n = 0; n < i.userData.components.length; n++) {
        const o = i.userData.components[n], r = Object.entries(o);
        for (const [a, l] of r)
          if (Array.isArray(l)) {
            const c = [];
            o[a] = c;
            for (let h = 0; h < l.length; h++) {
              const d = l[h];
              if (typeof d != "object") {
                c.push(d);
                continue;
              }
              const f = Gy(o, a, d, s);
              f !== void 0 ? (Ko && console.log("Found new instance for", a, d, "->", f), c.push(f)) : (Ko && console.warn("Could not find new instance for", a, d), c.push(d));
            }
          } else if (typeof l == "object") {
            const c = Gy(o, a, l, s);
            c !== void 0 ? o[a] = c : Ko && console.warn("Could not find new instance for", a, l);
          }
      }
  }
}
function Gy(s, e, t, i) {
  if (t != null)
    if (t.isComponent === !0) {
      const n = t.gameObject;
      if (n) {
        const o = n.uuid, r = i[o]?.clone;
        if (!r) {
          Ko && console.log("reference did not change", e, s, t);
          return;
        }
        const a = n.userData.components.indexOf(t);
        if (a >= 0 && r.isObject3D)
          return Ko && console.log(e, o), r.userData.components[a];
        console.warn("could not find component", e, t);
      }
    } else if (t.isObject3D === !0) {
      if (e === "gameObject") return;
      const n = t;
      if (n) {
        const o = n.uuid, r = i[o]?.clone;
        if (r)
          return Ko && console.log(e, "old", t, "new", r), r;
      }
    } else {
      if (t.isVector4 || t.isVector3 || t.isVector2 || t.isQuaternion || t.isEuler)
        return t.clone();
      if (t.isColor === !0)
        return t.clone();
      if (t.isEventList === !0)
        return t.__internalOnInstantiate(i);
    }
}
var wa;
((s) => {
  s.baseUrl = "https://networking.needle.tools";
  function i(h) {
    return Zg(new Uint8Array(h));
  }
  s.hashMD5 = i;
  function n(h) {
    const d = Zg(new Uint8Array(h), { encoding: "binary", asBytes: !0 });
    return btoa(String.fromCharCode(...d));
  }
  s.hashMD5_Base64 = n;
  function o(h) {
    const d = new Uint8Array(h);
    return crypto.subtle.digest("SHA-256", d).then((p) => btoa(String.fromCharCode(...new Uint8Array(p))));
  }
  s.hashSha256 = o;
  function r(h) {
    const d = h.filesize / 1024 / 1024;
    return vs() ? d < 50 : d < 5;
  }
  s.canUpload = r;
  async function a(h, d) {
    const f = s.baseUrl;
    if (f) {
      if (!h.name)
        return console.error("Upload: file name is missing"), null;
    } else return console.error("Blob storage base url is not set"), null;
    let p = null;
    h instanceof File ? p = await h.arrayBuffer() : p = h.data;
    const g = p.byteLength, _ = g / 1024 / 1024;
    if (_ > 50)
      return d?.silent !== !0 && ge(`File (${_.toFixed(1)}MB) is too large for uploading (see console for details)`), console.warn(`Your file is too large for uploading (${_.toFixed(1)}MB). Max allowed size is 50MB`), null;
    if (!vs() && _ > 5)
      return d?.silent !== !0 && ge('File is too large for uploading. Please get a <a href="https://needle.tools/pricing" target="_blank">commercial license</a> to upload files larger than 5MB'), console.warn(`Your file is too large for uploading (${_.toFixed(1)}MB). Max size is 5MB for non-commercial users. Please get a commercial license at https://needle.tools/pricing for larger files (up to 50MB)`), null;
    if (g < 1)
      return console.warn(`Your file is too small for uploading (${_.toFixed(1)}MB). Min size is 1 byte`), null;
    const m = n(p), v = {
      filename: h.name,
      "Content-Md5": m,
      // "x-amz-checksum-sha256": checksum,
      // "X-Amz-Content-Sha256": checksum,
      "Content-Type": h.type || "application/octet-stream",
      FileSize: g.toString(),
      // enforced by the server
      "Content-Disposition": `attachment; filename="${h.name}"`,
      // enforced by the server
      "x-amz-server-side-encryption": "AES256"
    }, y = await fetch(f + "/api/needle/blob", {
      method: "POST",
      headers: v,
      signal: d?.abort
    }).then((x) => x.json()).catch((x) => (console.error(x), null));
    if (y == null)
      return console.warn("Upload failed..."), null;
    if ("error" in y)
      return console.error(y.error), null;
    if ("upload" in y && y.upload) {
      let x = function(k) {
        return d?.onProgress?.call(null, { progress01: 0, state: "inprogress" }), fetch(k, {
          method: "PUT",
          headers: v,
          body: p,
          signal: d?.abort
        }).then((z) => (d?.onProgress?.call(null, { progress01: 1, state: "finished" }), z)).catch((z) => z);
      };
      console.debug("Uploading file", y.upload);
      let I = !1, O = null;
      for (let k = 0; k < 3; k++)
        try {
          if (I) break;
          if (d?.abort?.aborted)
            return console.debug("Aborted upload"), null;
          const E = await x(y.upload);
          E instanceof Error ? (O = E, await Os(1e3 * k)) : E.ok && (console.debug("File uploaded successfully"), I = !0);
        } catch (E) {
          console.error(E);
        }
      if (!I)
        return console.error(O?.message || "Failed to upload file"), null;
    }
    if ("download" in y) {
      const x = f + y.download;
      return console.debug("File found in blob storage", x), {
        key: y.key,
        success: !0,
        download_url: x
      };
    }
    return null;
  }
  s.upload = a;
  function l(h) {
    return `${s.baseUrl}/api/needle/blob/${h}`;
  }
  s.getBlobUrlForKey = l;
  async function c(h, d) {
    const f = new cm();
    f.setResponseType("arraybuffer");
    const p = await f.loadAsync(h, (g) => {
      d && d.call(null, g);
    });
    return p instanceof ArrayBuffer ? new Uint8Array(p) : (console.error("Download failed, no arraybuffer returned"), null);
  }
  s.download = c;
})(wa || (wa = {}));
const js = w("debugaddressables");
class BP {
  _context;
  _assetReferences = {};
  /** @internal */
  constructor(e) {
    this._context = e, this._context.pre_update_callbacks.push(this.preUpdate);
  }
  /** @internal */
  dispose() {
    const e = this._context.pre_update_callbacks.indexOf(this.preUpdate);
    e >= 0 && this._context.pre_update_callbacks.splice(e, 1);
    for (const t in this._assetReferences)
      this._assetReferences[t]?.unload();
    this._assetReferences = {};
  }
  preUpdate = () => {
  };
  /**
   * Find a registered AssetReference by its URL
   */
  findAssetReference(e) {
    return this._assetReferences[e] || null;
  }
  /** 
   * Register an asset reference
   * @internal
   */
  registerAssetReference(e) {
    return e.url && (this._assetReferences[e.url] ? console.warn("Asset reference already registered", e) : this._assetReferences[e.url] = e), e;
  }
  /** @internal */
  unregisterAssetReference(e) {
    e.url && delete this._assetReferences[e.url];
  }
}
const uf = Symbol("assetReference");
class ie {
  /**
   * Get an AssetReference for a URL to be easily loaded.  
   * AssetReferences are cached so calling this method multiple times with the same arguments will always return the same AssetReference.
   * @param url The URL of the asset to load. The url can be relative or absolute.
   * @param context The context to use for loading the asset  
   * @returns the AssetReference for the URL
   */
  static getOrCreateFromUrl(e, t) {
    if (!t && (t = N.Current, !t))
      throw new Error('Context is required when sourceId is a string. When you call this method from a component you can call it with "getOrCreate(this, url)" where "this" is the component.');
    const i = t.addressables, n = i.findAssetReference(e);
    if (n) return n;
    const o = new ie(e, t.hash);
    return i.registerAssetReference(o), o;
  }
  /** 
   * Get an AssetReference for a URL to be easily loaded.   
   * AssetReferences are cached so calling this method multiple times with the same arguments will always return the same AssetReference.
   */
  static getOrCreate(e, t, i) {
    if (typeof e == "string") {
      if (!i && (i = N.Current, !i))
        throw new Error('Context is required when sourceId is a string. When you call this method from a component you can call it with "getOrCreate(this, url)" where "this" is the component.');
    } else
      i = e.context, e = e.sourceId;
    const n = fr(e, t);
    js && console.log("GetOrCreate Addressable from", e, t, "FinalPath=", n);
    const o = i.addressables, r = o.findAssetReference(n);
    if (r) return r;
    const a = new ie(n, i.hash);
    return o.registerAssetReference(a), a;
  }
  isAssetReference = !0;
  /**  
   * This is the loaded asset root object. If the asset is a glb/gltf file this will be the {@link three#Scene} object.
   */
  get rawAsset() {
    return this._rawAsset;
  }
  /** The loaded asset root
   */
  get asset() {
    return this._glbRoot ?? (this._rawAsset?.scene || null);
  }
  set asset(e) {
    e ? this._rawAsset = {
      animations: e.animations,
      scene: e,
      scenes: [e]
    } : this._rawAsset = null;
  }
  /** The url of the loaded asset (or the asset to be loaded) 
   * @deprecated use url */
  get uri() {
    return this._url;
  }
  /** The url of the loaded asset (or the asset to be loaded) */
  get url() {
    return this._url;
  }
  /** The name of the assigned url. This name is deduced from the url and might not reflect the actual name of the asset */
  get urlName() {
    return this._urlName;
  }
  /**
   * @returns true if the uri is a valid URL (http, https, blob)
   */
  get hasUrl() {
    return this._url !== void 0 && (this._url.startsWith("http") || this._url.startsWith("blob:") || this._url.startsWith("www.") || this._url.includes("/"));
  }
  _rawAsset = null;
  _glbRoot;
  _url;
  _urlName;
  _progressListeners = [];
  _isLoadingRawBinary = !1;
  _rawBinary;
  /** @internal */
  constructor(e, t, i = null) {
    this._url = e;
    const n = e.lastIndexOf("/");
    if (n >= 0) {
      this._urlName = e.substring(n + 1);
      const o = this._urlName.lastIndexOf(".");
      o >= 0 && (this._urlName = this._urlName.substring(0, o));
    } else
      this._urlName = e;
    i !== null && (this.asset = i), sP(this._url, this.onResolvePrefab.bind(this));
  }
  async onResolvePrefab(e) {
    return e === this.url && (this.mustLoad && await this.loadAssetAsync(), this.asset) ? this.asset : null;
  }
  get mustLoad() {
    return !this.asset || this.asset.__destroyed === !0 || _a(this.asset) === !0;
  }
  _loadingPromise = null;
  /**
   * @returns `true` if the asset has been loaded (via preload) or if it exists already (assigned to `asset`) */
  isLoaded() {
    return this._rawBinary || this.asset !== void 0;
  }
  /** frees previously allocated memory and destroys the current `asset` instance (if any) */
  unload() {
    this.asset && (js && console.log("Unload", this.asset), "scene" in this.asset && this.asset.scene && Wi(this.asset.scene, !0, !0), Wi(this.asset, !0, !0)), this.asset = null, this._rawBinary = void 0, this._glbRoot = null, this._loadingPromise = null, N.Current && N.Current.addressables.unregisterAssetReference(this);
  }
  /** loads the asset binary without creating an instance */
  async preload() {
    if (!this.mustLoad || this._isLoadingRawBinary) return null;
    if (this._rawBinary !== void 0) return this._rawBinary;
    this._isLoadingRawBinary = !0, js && console.log("Preload", this.url);
    const e = await wa.download(this.url, (t) => {
      this.raiseProgressEvent(t);
    });
    return this._rawBinary = e?.buffer ?? null, this._isLoadingRawBinary = !1, this._rawBinary;
  }
  // TODO: we need a way to abort loading a resource
  /** Loads the asset and creates one instance (assigned to `asset`)
   * @returns the loaded asset
   */
  async loadAssetAsync(e) {
    if (js && console.log("[AssetReference] loadAssetAsync", this.url), !this.mustLoad) return this.asset;
    if (e && this._progressListeners.push(e), this._loadingPromise !== null)
      return this._loadingPromise.then((n) => this.asset);
    const t = N.Current;
    if (this._rawBinary) {
      if (!(this._rawBinary instanceof ArrayBuffer))
        return console.error("[AssetReference] Failed loading – Invalid data. Must be of type ArrayBuffer. " + typeof this._rawBinary), null;
      this._loadingPromise = jn().parseSync(t, this._rawBinary, this.url, null), this.raiseProgressEvent(new ProgressEvent("progress", { loaded: this._rawBinary.byteLength, total: this._rawBinary.byteLength }));
    } else
      js && console.log("Load async", this.url), this._loadingPromise = jn().loadSync(t, this.url, this.url, null, (n) => {
        this.raiseProgressEvent(n);
      });
    this._loadingPromise.finally(() => this._loadingPromise = null);
    const i = await this._loadingPromise;
    return this._progressListeners.length = 0, this._glbRoot = this.tryGetActualGameObjectRoot(i), i ? (i[uf] = this, this._glbRoot && (this._glbRoot[uf] = this), this.asset && (this.asset[uf] = this), sd(t), i.scene !== void 0 && (this._rawAsset = i), this.asset) : null;
  }
  /** loads and returns a new instance of `asset` */
  instantiate(e) {
    return this.onInstantiate(e, !1);
  }
  /** loads and returns a new instance of `asset` - this call is networked so an instance will be created on all connected users */
  instantiateSynced(e, t = !0) {
    return this.onInstantiate(e, !0, t);
  }
  beginListenDownload(e) {
    this._progressListeners.indexOf(e) < 0 && this._progressListeners.push(e);
  }
  endListenDownload(e) {
    const t = this._progressListeners.indexOf(e);
    t >= 0 && this._progressListeners.splice(t, 1);
  }
  raiseProgressEvent(e) {
    for (const t of this._progressListeners)
      t(this, e);
  }
  static currentlyInstantiating = /* @__PURE__ */ new Map();
  async onInstantiate(e, t = !1, i) {
    const n = N.Current, o = new Nn();
    if (e instanceof M ? o.parent = e : e && (Object.assign(o, e), o.cloneAssign(e)), o.parent === void 0 && (o.parent = n.scene), this.mustLoad && await this.loadAssetAsync(), js && console.log("Instantiate", this.url, "parent:", e), this.asset) {
      js && console.log("Add to scene", this.asset);
      let r = ie.currentlyInstantiating.get(this.url);
      if (r !== void 0 && r >= 1e4)
        return console.error("Recursive or too many instantiations of " + this.url + " in the same frame (" + r + ")"), null;
      try {
        if (r === void 0 && (r = 0), r += 1, ie.currentlyInstantiating.set(this.url, r), t) {
          o.context = n;
          const a = this.asset;
          a.guid = this.url;
          const l = m0(a, o, void 0, i);
          if (l)
            return l;
        } else {
          const a = va(this.asset, o);
          if (a)
            return a;
        }
      } finally {
        n.post_render_callbacks.push(() => {
          r === void 0 || r < 0 ? r = 0 : r -= 1, ie.currentlyInstantiating.set(this.url, r);
        });
      }
    } else js && console.warn("Failed to load asset", this.url);
    return null;
  }
  /**
   * try to ignore the intermediate created object
   * because it causes trouble if we instantiate an assetreference per player
   * and call destroy on the player marker root
   * @returns the scene root object if the asset was a glb/gltf
   */
  tryGetActualGameObjectRoot(e) {
    if (e && e.scene) {
      const t = e.scene;
      return t.isGroup && t.children.length === 1 && t.children[0].name + "glb" === t.name ? t.children[0] : t;
    }
    return null;
  }
}
class FP extends Xi {
  constructor() {
    super([ie], "AssetReferenceSerializer");
  }
  onSerialize(e, t) {
    if (e && e.uri !== void 0 && typeof e.uri == "string")
      return e.uri;
  }
  onDeserialize(e, t) {
    if (typeof e == "string")
      return t.context ? t.gltfId ? ie.getOrCreate(t.gltfId, e, t.context) : (console.error("Missing source id"), null) : (console.error("Missing context"), null);
    if (e instanceof M) {
      if (!t.context)
        return console.error("Missing context"), null;
      if (!t.gltfId)
        return console.error("Missing source id"), null;
      const i = e, n = t.context, o = i.guid ?? i.uuid, r = n.addressables.findAssetReference(o);
      if (r) return r;
      const a = new ie(o, void 0, i);
      return n.addressables.registerAssetReference(a), a;
    }
    return null;
  }
}
new FP();
const zP = Promise.resolve(null);
class ia {
  static imageReferences = /* @__PURE__ */ new Map();
  static getOrCreate(e) {
    let t = ia.imageReferences.get(e);
    return t || (t = new ia(e), ia.imageReferences.set(e, t)), t;
  }
  constructor(e) {
    this.url = e;
  }
  url;
  _bitmap;
  _bitmapObject;
  dispose() {
    this._bitmapObject && this._bitmapObject.close(), this._bitmap = void 0;
  }
  createHTMLImage() {
    const e = new Image();
    return e.src = this.url, e;
  }
  loader = null;
  createTexture() {
    return this.url ? (this.loader || (this.loader = new Jl()), this.loader.setCrossOrigin("anonymous"), this.loader.loadAsync(this.url).then((e) => (e && !e.name?.length && (e.name = this.url.split("/").pop() ?? this.url), e))) : (console.error("Can not load texture without url"), zP);
  }
  /** Loads the bitmap data of the image */
  getBitmap() {
    return this._bitmap ? this._bitmap : (this._bitmap = new Promise((e, t) => {
      const i = document.createElement("img");
      i.addEventListener("load", () => {
        this._bitmap = createImageBitmap(i).then((n) => (this._bitmapObject = n, e(n), n));
      }), i.addEventListener("error", (n) => {
        console.error("Failed to load image:" + this.url, n), e(null);
      }), i.src = this.url;
    }), this._bitmap);
  }
}
class UP extends Xi {
  constructor() {
    super([ia], "ImageReferenceSerializer");
  }
  onSerialize(e, t) {
    return null;
  }
  onDeserialize(e, t) {
    if (typeof e == "string") {
      const i = fr(t.gltfId, e);
      return ia.getOrCreate(i);
    }
  }
}
new UP();
class na {
  static cache = /* @__PURE__ */ new Map();
  static getOrCreate(e) {
    let t = na.cache.get(e);
    return t || (t = new na(e), na.cache.set(e, t)), t;
  }
  /** Load the file binary data
   * @returns a promise that resolves to the binary data of the file. Make sure to await this request or use `.then(res => {...})` to get the result.
   */
  async loadRaw() {
    return this.res || (this.res = fetch(this.url)), this.res.then((e) => e.blob());
  }
  /** Load the file as text (if the referenced file is a text file like a .txt or .json file)
   * @returns a promise that resolves to the text data of the file. Make sure to await this request or use `.then(res => {...})` to get the result. If the format is json you can use `JSON.parse(result)` to convert it to a json object
   */
  async loadText() {
    return this.res || (this.res = fetch(this.url)), this.res.then((e) => e.text());
  }
  /** The resolved url to the file */
  url;
  res;
  constructor(e) {
    this.url = e;
  }
}
class NP extends Xi {
  constructor() {
    super([na], "FileReferenceSerializer");
  }
  onSerialize(e, t) {
    return null;
  }
  onDeserialize(e, t) {
    if (typeof e == "string") {
      const i = fr(t.gltfId, e);
      return na.getOrCreate(i);
    }
  }
}
new NP();
class $P {
  context;
  mixers = [];
  constructor(e) {
    this.context = e;
  }
  /** @hidden @internal */
  onDestroy() {
    this.mixers.forEach((e) => e.stopAllAction()), this.mixers.length = 0;
  }
  /**
   * Register an animation mixer instance.
   */
  registerAnimationMixer(e) {
    if (!e) {
      console.warn("AnimationsRegistry.registerAnimationMixer called with null or undefined mixer");
      return;
    }
    this.mixers.includes(e) || this.mixers.push(e);
  }
  /**
   * Unregister an animation mixer instance.
   */
  unregisterAnimationMixer(e) {
    if (!e) {
      console.warn("AnimationsRegistry.unregisterAnimationMixer called with null or undefined mixer");
      return;
    }
    const t = this.mixers.indexOf(e);
    t !== -1 && this.mixers.splice(t, 1);
  }
}
class rc {
  /**
   * Tries to get the animation actions from an animation mixer.
   * @param mixer The animation mixer to get the actions from
   * @returns The actions or null if the mixer is invalid
   */
  static tryGetActionsFromMixer(e) {
    const t = e._actions;
    return t || null;
  }
  static tryGetAnimationClipsFromObjectHierarchy(e, t) {
    if (t || (t = new Array()), e)
      e.animations && t.push(...e.animations);
    else return t;
    if (e.children)
      for (const i of e.children)
        this.tryGetAnimationClipsFromObjectHierarchy(i, t);
    return t;
  }
  /**
   * Assigns animations from a GLTF file to the objects in the scene.  
   * This method will look for objects in the scene that have animations and assign them to the correct objects.  
   * @param file The GLTF file to assign the animations from
   */
  static autoplayAnimations(e) {
    if (!e || !e.animations)
      return console.debug("No animations found in file"), null;
    const t = "scene" in e ? e.scene : e, i = new Array();
    for (let o = 0; o < e.animations.length; o++) {
      const r = e.animations[o];
      if (!r.tracks || r.tracks.length <= 0) {
        console.warn("Animation has no tracks");
        continue;
      }
      for (const a in r.tracks) {
        const l = r.tracks[a], c = ca.parseTrackName(l.name);
        let h = ca.findNode(t, c.nodeName);
        if (!h) {
          const f = l.__objectName ?? l.name.substring(0, l.name.indexOf("."));
          if (h = t.getObjectByProperty("uuid", f), !h)
            continue;
        }
        let d = n(h) || n(t);
        if (!d) {
          const f = P.get("Animation");
          if (d = t.addComponent(f), !d) {
            console.error("Failed creating Animation component: No 'Animation' component found in TypeStore");
            break;
          }
        }
        i.push(d), d.addClip && d.addClip(r);
      }
    }
    return i;
    function n(o) {
      if (!o) return null;
      const r = o.userData?.components;
      if (r && r.length > 0) {
        for (let a = 0; a < r.length; a++)
          if (r[a].isAnimationComponent === !0)
            return o;
      }
      return n(o.parent);
    }
  }
}
function* T0(s, e = null) {
  const t = e ? e.time : N.Current.time, i = t.time;
  for (; t.time - i < s; )
    yield;
}
function* FI(s) {
  for (let e = 0; e < s; e++)
    yield;
}
function* WP(s) {
  let e = !0;
  for (s.then(() => e = !1), s.catch(() => e = !1); e; )
    yield;
}
const qy = "NEEDLE_lightmaps", tl = w("debuglightmapsextension") || w("debuglightmaps");
var xn = /* @__PURE__ */ ((s) => (s[s.Lightmap = 0] = "Lightmap", s[s.Skybox = 1] = "Skybox", s[s.Reflection = 2] = "Reflection", s))(xn || {});
class VP {
  get name() {
    return qy;
  }
  parser;
  registry;
  source;
  constructor(e, t, i) {
    this.parser = e, this.registry = t, this.source = i;
  }
  afterRoot(e) {
    const t = this.parser.json.extensions;
    if (t) {
      const i = t[qy];
      if (i) {
        const n = i.textures;
        return n?.length ? (tl && console.log(i), new Promise(async (o, r) => {
          const a = [];
          for (const c of n)
            if (c.pointer) {
              tl && console.log(c);
              let h = null;
              if (c.pointer.startsWith("/textures/"))
                tl && console.log("Load texture from gltf", c.pointer), h = Lm(this.parser, c.pointer).then((d) => this.resolveTexture(c, d));
              else if (typeof c.pointer == "string") {
                tl && console.log("Load texture from path", c.pointer);
                const d = fr(this.source, c.pointer);
                let f;
                d.endsWith(".exr") ? f = new gm(this.parser.options.manager) : d.endsWith(".hdr") ? f = new bb(this.parser.options.manager) : f = new Jl(this.parser.options.manager), h = f.loadAsync(d, void 0).then((p) => this.resolveTexture(c, p));
              } else c.pointer;
              h && a.push(h);
            }
          const l = await Tb(a);
          l?.anyFailed && L() && console.error("Failed to load lightmap extension", l), o();
        })) : null;
      }
    }
    return null;
  }
  resolveTexture(e, t) {
    const i = t;
    tl && console.log("Lightmap loaded:", i), i?.isTexture && (this.registry ? (i.colorSpace = Ss, this.registry.registerTexture(this.source, e.type, i, e.index)) : console.log(xn[e.type], e.pointer, i));
  }
}
const Rr = !!w("debuglightmaps");
class HP {
  _context;
  _lightmaps = /* @__PURE__ */ new Map();
  clear() {
    this._lightmaps.clear();
  }
  constructor(e) {
    this._context = e;
  }
  registerTexture(e, t, i, n) {
    Rr && console.log("Registering ", xn[t] + ' "' + e + '"', i), this._lightmaps.has(e) || this._lightmaps.set(e, /* @__PURE__ */ new Map());
    const o = this._lightmaps.get(e), r = o?.get(t) ?? [];
    r.length < n && (r.length = n + 1), N1(i, !1), r[n] = i, o?.set(t, r);
  }
  tryGetLightmap(e, t = 0) {
    return this.tryGet(e, xn.Lightmap, t);
  }
  tryGetSkybox(e) {
    return Rr && console.log("[Get Skybox]", e, this._lightmaps), this.tryGet(e, xn.Skybox, 0);
  }
  tryGetReflection(e) {
    return Rr && console.log("[Get Reflection]", e, this._lightmaps), this.tryGet(e, xn.Reflection, 0);
  }
  tryGet(e, t, i) {
    if (!e)
      return Rr && console.warn("Missing source id"), null;
    const n = this._lightmaps.get(e);
    if (!n)
      return Rr && console.warn(`[Lighting] No ${xn[t]} texture entry for`, e), null;
    const o = n.get(t);
    return o === void 0 ? (Rr && console.warn(`[Lighting] No ${xn[t]} texture for`, e, "index", i), null) : !o?.length || o.length <= i ? null : o[i];
  }
}
Wt.lights_fragment_maps = Wt.lights_fragment_maps.replace("vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );", `
    vec2 lUv = vLightMapUv.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
    vec4 lightMapTexel = texture2D( lightMap, lUv);
    // The range of RGBM lightmaps goes from 0 to 34.49 (5^2.2) in linear space, and from 0 to 5 in gamma space.
    lightMapTexel.rgb *= lightMapTexel.a * 8.; // no idea where that "8" comes from... heuristically derived
    lightMapTexel.a = 1.;
    lightMapTexel = conv_sRGBToLinear(lightMapTexel);
    `);
Wt.lightmap_pars_fragment = `
    #ifdef USE_LIGHTMAP
        uniform sampler2D lightMap;
        uniform float lightMapIntensity;
        uniform vec4 lightmapScaleOffset;
        
        // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
        vec4 conv_sRGBToLinear( in vec4 value ) {
            return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
        }
    #endif
    `;
Wt.lights_fragment_begin = Wt.lights_fragment_begin.replace(
  "irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );",
  `
#if defined(USE_LIGHTMAP)
irradiance += 0.;
#else
irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
#endif`
);
tx.lightmap.lightmapScaleOffset = { value: new de(1, 1, 0, 0) };
const ff = w("debugprogressive"), eh = new pi(), th = new Id();
class GP {
  /** The type of the @needle-tools/gltf-progressive LODsManager - can be used to set static settings */
  static GLTF_PROGRESSIVE_LODSMANAGER_TYPE = Ao;
  context;
  _lodsManager;
  _settings = {};
  /**
   * The internal LODs manager. See @needle-tools/gltf-progressive for more information.  
   * @link https://npmjs.com/package/@needle-tools/gltf-progressive
   */
  get manager() {
    return this._lodsManager;
  }
  get skinnedMeshAutoUpdateBoundsInterval() {
    return this._lodsManager?.skinnedMeshAutoUpdateBoundsInterval || this._settings.skinnedMeshAutoUpdateBoundsInterval || 0;
  }
  set skinnedMeshAutoUpdateBoundsInterval(e) {
    this._settings.skinnedMeshAutoUpdateBoundsInterval = e, this.applySettings();
  }
  /**
   * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.  
   * @default 200_000
   */
  get targetTriangleDensity() {
    return this._lodsManager?.targetTriangleDensity || this._settings.targetTriangleDensity || 2e5;
  }
  set targetTriangleDensity(e) {
    this._settings.targetTriangleDensity = e, this.applySettings();
  }
  constructor(e) {
    this.context = e;
  }
  applySettings() {
    if (this._lodsManager)
      for (const e in this._settings)
        this._lodsManager[e] = this._settings[e];
  }
  /** @internal */
  setRenderer(e) {
    this._lodsManager?.disable(), Ao.removePlugin(this), Ao.addPlugin(this), Ao.debugDrawLine = F.DrawLine, this._lodsManager = Ao.get(e, { engine: "needle-engine" }), this.applySettings(), this._lodsManager.enable();
  }
  disable() {
    this._lodsManager?.disable(), Ao.removePlugin(this);
  }
  /** @internal */
  onAfterUpdatedLOD(e, t, i, n, o) {
    ff && this.onRenderDebug(i, n, o);
  }
  onRenderDebug(e, t, i) {
    if (!t.geometry || !We.hasLODLevelAvailable(t.geometry) && !We.hasLODLevelAvailable(t.material)) return;
    const n = Ao.getObjectLODState(t);
    if (!n) return;
    let o = i.mesh_lod;
    const r = i.mesh_lod != n.lastLodLevel_Mesh || i.texture_lod != n.lastLodLevel_Texture;
    if (ff && t.geometry.boundingSphere) {
      const a = t.geometry.boundingSphere;
      th.copy(a), th.applyMatrix4(t.matrixWorld);
      const l = th.center, c = th.radius, h = ["#76c43e", "#bcc43e", "#c4ac3e", "#c4673e", "#ff3e3e"];
      if (r)
        F.DrawWireSphere(l, c, h[o], 0.1);
      else {
        const d = t.geometry.index?.count ?? 0, f = We.getMeshLODExtension(t.geometry)?.lods;
        o = f ? Math.min(f?.length - 1, o) : 0;
        let p = "";
        if (f && n.lastScreenCoverage > 0)
          for (let m = 0; m < f.length; m++) {
            const v = f[m].density, y = m == f.length - 1;
            p += v.toFixed(0) + ">" + (v / n.lastScreenCoverage).toFixed(0) + (y ? "" : ",");
          }
        const g = f ? f[o]?.density : -1;
        let _ = "LOD " + i.mesh_lod + `
TEX ` + i.texture_lod;
        if (ff == "density" && (_ += `
` + d + ` tris
` + (g / n.lastScreenCoverage).toFixed(0) + ` dens
` + (n.lastScreenCoverage * 100).toFixed(1) + `% cov
` + (n.lastCentrality * 100).toFixed(1) + `% centr
` + (eh.min.x.toFixed(2) + "-" + eh.max.x.toFixed(2) + "x" + eh.min.y.toFixed(2) + "-" + eh.max.y.toFixed(2)) + " scr"), n.lastScreenCoverage > 0.1) {
          const m = e, v = m.worldForward, y = m.worldPosition, I = G(v).multiplyScalar(c * 0.7).add(l), O = I.distanceTo(y), k = h[Math.min(h.length - 1, Math.max(0, o))] + "88", E = this.context.domHeight > 0 ? screen.height / this.context.domHeight : 1, z = e.isPerspectiveCamera ? Math.tan(e.fov * Math.PI / 180 / 2) : 1;
          F.DrawLabel(I, _, O * 0.012 * E * z, void 0, 16777215, k);
        }
      }
    }
  }
}
const qP = w("debugplayerview");
var Zo = /* @__PURE__ */ ((s) => (s.Browser = "browser", s.Headset = "headset", s.Handheld = "handheld", s))(Zo || {});
class XP {
  userId;
  context;
  viewDevice = "browser";
  get currentObject() {
    return this._object;
  }
  set currentObject(e) {
    this._object = e;
  }
  get isConnected() {
    return this.context.connection.userIsInRoom(this.userId);
  }
  removed = !1;
  _object;
  constructor(e, t) {
    this.userId = e, this.context = t;
  }
}
class QP {
  context;
  playerViews = /* @__PURE__ */ new Map();
  constructor(e) {
    this.context = e;
  }
  setPlayerView(e, t, i) {
    let n = this.playerViews.get(e);
    n || (n = new XP(e, this.context), this.playerViews.set(e, n)), n.viewDevice = i, n.currentObject = t, n.removed = !1;
  }
  getPlayerView(e) {
    if (!e) return;
    if (!this.context.connection.userIsInRoom(e)) {
      this.playerViews.delete(e);
      return;
    }
    return this.playerViews.get(e);
  }
  removePlayerView(e, t) {
    const i = this.playerViews.get(e);
    i?.viewDevice === t && (qP && console.log("REMOVE", e), i.removed = !0, this.playerViews.delete(e));
  }
}
new cm();
const _c = new Uint8Array(4);
_c[0] = 255;
_c[1] = 255;
_c[2] = 255;
_c[3] = 255;
const YP = new hm(_c, 1, 1, Ld);
function zm(s, e = 1) {
  const t = "alpha" in s, i = e * e, n = new Uint8Array(4 * i), o = Math.floor(s.r * 255), r = Math.floor(s.g * 255), a = Math.floor(s.b * 255);
  for (let c = 0; c < i; c++) {
    const h = c * 4;
    n[h + 0] = o, n[h + 1] = r, n[h + 2] = a, t ? n[h + 3] = Math.floor(s.alpha * 255) : n[h + 3] = 255;
  }
  const l = new hm(n, e, e);
  return l.needsUpdate = !0, l;
}
function KP(s, e, t, i = 1, n = 3) {
  const r = i * n, a = [s, e, t], l = a.length, c = new Uint8Array(4 * l * r), h = new se();
  for (let f = 0; f < n; f++) {
    const p = Math.floor(f / n * l), g = j.clamp(p + 1, 0, l - 1), _ = a[p], m = a[g], v = f / n * l % 1;
    h.lerpColors(_, m, v);
    const y = Math.floor(h.r * 255), x = Math.floor(h.g * 255), I = Math.floor(h.b * 255);
    for (let O = 0; O < i; O++) {
      const k = (f * i + O) * 4;
      c[k + 0] = y, c[k + 1] = x, c[k + 2] = I, c[k + 3] = 255;
    }
  }
  const d = new hm(c, i, n);
  return d.needsUpdate = !0, d;
}
function ld(s, e) {
  const t = s.elements;
  e || (e = []), e.length = 0;
  for (let i = 0; i < 16; i += 4) {
    const n = t[i], o = t[i + 1], r = t[i + 2], a = t[i + 3], l = new de(n, o, r, a);
    e.push(l);
  }
  return e;
}
const pf = [], Xy = [];
function ZP(s, e) {
  if (pf.length === 0)
    for (let t = 0; t < 27; t++) pf.push(0);
  e || (e = pf);
  for (let t = 0; t < 27; t++)
    Xy[t] = e[t];
  e = Xy, s.unity_SHAr = { value: new de(e[9], e[3], e[6], e[0]) }, s.unity_SHBr = { value: new de(e[12], e[15], e[18], e[21]) }, s.unity_SHAg = { value: new de(e[10], e[4], e[7], e[1]) }, s.unity_SHBg = { value: new de(e[13], e[16], e[19], e[22]) }, s.unity_SHAb = { value: new de(e[11], e[5], e[8], e[2]) }, s.unity_SHBb = { value: new de(e[14], e[17], e[20], e[23]) }, s.unity_SHC = { value: new de(e[24], e[25], e[26], 1) };
}
class JP {
  vertexShader;
  fragmentShader;
  technique;
  constructor(e, t, i) {
    this.vertexShader = e, this.fragmentShader = t, this.technique = i;
  }
}
async function eO(s, e) {
  if (!s)
    return console.error("Can not find technique: no shader data"), null;
  const t = s.programs[e], i = t.vertexShader, n = t.fragmentShader;
  if (i !== void 0 && n !== void 0) {
    const o = s.shaders[i], r = s.shaders[n];
    if (o.uri && r.uri || o.code && r.code) {
      if (!o.code && o.uri && await Qy(o), !r.code && r.uri && await Qy(r), !o.code || !r.code) return null;
      const a = s.techniques[e];
      return new JP(o.code, r.code, a);
    }
  }
  return console.error("Shader technique not found", e), null;
}
async function Qy(s) {
  const e = s.uri;
  if (e)
    if (e.endsWith(".glsl")) {
      const i = await new cm().loadAsync(e);
      s.code = i.toString();
    } else
      s.code = tO(s.uri);
}
function tO(s) {
  return decodeURIComponent(Array.prototype.map.call(atob(s), function(e) {
    return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}
const Ji = w("debugenvlight");
var Ul = /* @__PURE__ */ ((s) => (s[s.Skybox = 0] = "Skybox", s[s.Trilight = 1] = "Trilight", s[s.Flat = 3] = "Flat", s[s.Custom = 4] = "Custom", s))(Ul || {}), kp = /* @__PURE__ */ ((s) => (s[s.Skybox = 0] = "Skybox", s[s.Custom = 1] = "Custom", s))(kp || {});
class iO {
  context;
  constructor(e) {
    this.context = e, this.context.pre_update_callbacks.push(this.preUpdate.bind(this));
  }
  _currentLightSettingsId;
  _sceneLightSettings;
  preUpdate() {
    const e = this.context.time;
    this._timevec4.x = e.time, this._timevec4.y = Math.sin(e.time), this._timevec4.z = Math.cos(e.time), this._timevec4.w = e.deltaTime;
  }
  _timevec4 = new de();
  /** Time data used for custom shaders
   * x: time
   * y: sin(time)
   * z: cos(time)
   * w: deltaTime
   */
  get timeVec4() {
    return this._timevec4;
  }
  /** the current environment intensity */
  get environmentIntensity() {
    if (!this._sceneLightSettings || !this._currentLightSettingsId) return 1;
    const e = this._sceneLightSettings.get(this._currentLightSettingsId);
    return e ? e.ambientIntensity : 1;
  }
  /** Get all currently registered scene light settings */
  get sceneLightSettings() {
    return this._sceneLightSettings?.values();
  }
  /** set the scene lighting from a specific scene. Will disable any previously enabled lighting settings */
  enable(e) {
    e instanceof ie && (e = e.url);
    const t = this._sceneLightSettings?.get(e);
    return t ? (Ji && console.log("Enable scene light settings", e, t), e !== this._currentLightSettingsId && this._currentLightSettingsId && this.disable(this._currentLightSettingsId), this._currentLightSettingsId = e, t.enabled = !0, !0) : (Ji && console.warn("No light settings found for", e), !1);
  }
  /** disable the lighting of a specific scene, will only have any effect if it is currently active */
  disable(e) {
    if (e instanceof ie && (e = e.url), e == null) return !1;
    const t = this._sceneLightSettings?.get(e);
    return t ? (Ji && console.log("Disable scene light settings", e, t), t.enabled = !1, !0) : !1;
  }
  /** Disables the currently active scene lighting (if any), returns the id of the previously active lighting */
  disableCurrent() {
    if (this._currentLightSettingsId) {
      const e = this._currentLightSettingsId;
      return this.disable(this._currentLightSettingsId), e;
    }
    return null;
  }
  /** @internal */
  internalRegisterSceneLightSettings(e) {
    const t = e.sourceId;
    if (!t) {
      console.error("Missing source id for scene light settings, can not register:", e);
      return;
    }
    Ji && console.log("Register " + e?.sourceId + " lighting", e), this._sceneLightSettings || (this._sceneLightSettings = /* @__PURE__ */ new Map()), this._sceneLightSettings.set(t, e);
  }
  /** @internal */
  internalUnregisterSceneLightSettings(e) {
    const t = e.sourceId;
    if (!t) {
      console.error("Missing source id for scene light settings, can not unregister:", e);
      return;
    }
    Ji && console.log("Unregister " + e?.sourceId + " lighting", e), this._sceneLightSettings && this._sceneLightSettings.delete(t);
  }
  /** @internal */
  internalRegisterReflection(e, t) {
    Ji && console.log("Register reflection", e, t);
    const i = new nO(this.context, t, 1);
    this._lighting[e] = i;
  }
  /** @internal */
  internalGetReflection(e) {
    return this._lighting[e];
  }
  __currentReflectionId = null;
  /** @internal */
  internalEnableReflection(e) {
    this.__currentReflectionId = e;
    const t = this._sceneLightSettings?.get(e);
    switch (Ji && console.log("Enable reflection", e, t ? Ul[t.ambientMode] : "Unknown ambient mode", t), t?.ambientMode) {
      case 0:
      case 4:
        const i = this.internalGetReflection(e);
        if (i && i.Source) {
          Ji && console.log("Setting environment reflection", i);
          const n = this.context.scene, o = i.Source;
          o.mapping = _s, n.environment = o;
          return;
        } else Ji && console.warn("Could not find reflection for source", e);
        break;
    }
    if (t?.environmentReflectionSource === 1)
      switch (t?.ambientMode) {
        case 1:
          if (t.ambientTrilight) {
            const i = t.ambientTrilight, n = KP(i[0], i[1], i[2], 64, 64);
            n.colorSpace = Cs, n.mapping = _s, this.context.scene.environment = n;
          } else console.error("Missing ambient trilight", t.sourceId);
          return;
        case 3:
          if (t.ambientLight) {
            const i = zm(t.ambientLight, 64);
            i.colorSpace = Cs, i.mapping = _s, this.context.scene.environment = i;
          } else console.error("Missing ambientlight", t.sourceId);
          return;
        default:
          return;
      }
  }
  /** @internal */
  internalDisableReflection(e) {
    if (e && e !== this.__currentReflectionId) {
      Ji && console.log("Not disabling reflection for", e, "because it is not the current light settings id", this.__currentReflectionId);
      return;
    }
    Ji && console.log("Disable reflection", e);
    const t = this.context.scene;
    t.environment = null;
  }
  _lighting = {};
}
class nO {
  get Source() {
    return this._source;
  }
  // get Array(): number[] | undefined { return this._sphericalHarmonicsArray; }
  _source;
  // private _sphericalHarmonicsArray?: number[];
  // private _context: Context;
  // private _sphericalHarmonics: SphericalHarmonics3 | null = null;
  // private _ambientScale: number = 1;
  // private _lightProbe?: LightProbe;
  constructor(e, t, i = 1) {
    this._source = t, t.mapping = _s;
  }
  /* REMOVED, no LightProbe / custom shader lighting support for now
      getSphericalHarmonicsArray(intensityFactor: number = 1): SphericalHarmonicsData | null {
          if (this._sphericalHarmonicsArray?.length && this._source) {
              return { array: this._sphericalHarmonicsArray, texture: this._source, lightProbe: this._lightProbe };
          }
  
          try {
              const reflection = this._source;
              let rt: WebGLCubeRenderTarget | null = null;
              if (reflection) {
                  if (debug) console.log("GENERATING LIGHT PROBE", reflection, this.Source);
                  const size = Math.min(reflection.image.width, 512);
                  const target = new WebGLCubeRenderTarget(size);
                  rt = target.fromEquirectangularTexture(this._context.renderer, reflection);
                  // Not sure why we did assign the resulting texture here again but this causes rendering to break when toggling env lighting (e.g. on website) because this texture will then be set as the scene.environment
                  // this._source = rt.texture;
              }
  
              this._sphericalHarmonicsArray = [];
              if (rt) {
                  const sampledProbe = LightProbeGenerator.fromCubeRenderTarget(this._context.renderer, rt);
                  this._lightProbe = sampledProbe;
                  const lightFactor = (this._ambientScale * (intensityFactor * intensityFactor * Math.PI * .5)) - 1;
                  // console.log(intensityFactor, lightFactor);
                  this._sphericalHarmonics = sampledProbe.sh;
                  this._sphericalHarmonicsArray = this._sphericalHarmonics.toArray();
                  if (this._sphericalHarmonicsArray) {
                      const factor = ((intensityFactor) / (Math.PI * .5));
                      for (let i = 0; i < this._sphericalHarmonicsArray.length; i++) {
                          this._sphericalHarmonicsArray[i] *= factor;
                      }
                      sampledProbe.sh.scale(lightFactor);
                      if (this._source)
                          return { array: this._sphericalHarmonicsArray, texture: this._source, lightProbe: sampledProbe };
                  }
              }
          }
          catch (err) {
              console.error(err);
          }
  
          return null;
      }
      */
}
const Yy = w("timescale");
let Mp = 1;
typeof Yy == "number" && (Mp = Yy);
class sO {
  /** The time in seconds since the start of Needle Engine. */
  get time() {
    return this._time;
  }
  set time(e) {
    this._time = e;
  }
  _time = 0;
  /** The time in seconds it took to complete the last frame (Read Only). */
  get deltaTime() {
    return this._deltaTime;
  }
  set deltaTime(e) {
    this._deltaTime = e;
  }
  _deltaTime = 0;
  /** The time in seconds it took to complete the last frame (Read Only). Timescale is not applied. */
  get deltaTimeUnscaled() {
    return this._deltaTimeUnscaled;
  }
  _deltaTimeUnscaled = 0;
  /** The scale at which time passes. This can be used for slow motion effects or to speed up time. */
  timeScale = 1;
  /** same as frameCount */
  get frame() {
    return this._frame;
  }
  set frame(e) {
    this._frame = e;
  }
  _frame = 0;
  /** The total number of frames that have passed (Read Only). Same as frame */
  get frameCount() {
    return this.frame;
  }
  /** The time in seconds it took to complete the last frame (Read Only). */
  get realtimeSinceStartup() {
    return this.clock.elapsedTime;
  }
  /** 
   * @returns {Number} FPS for this frame.   
   * Note that this returns the raw value (e.g. 59.88023952362959) and will fluctuate a lot between frames.  
   * If you want a more stable FPS, use `smoothedFps` instead.
  */
  get fps() {
    return 1 / this.deltaTime;
  }
  /** 
   * Approximated frames per second   
   * @returns the smoothed FPS value over the last 60 frames with decimals.  
  */
  get smoothedFps() {
    return this._smoothedFps;
  }
  /** The smoothed time in seconds it took to complete the last frame (Read Only). */
  get smoothedDeltaTime() {
    return 1 / this._smoothedFps;
  }
  clock = new ix();
  _smoothedFps = 0;
  _smoothedDeltaTime = 0;
  _fpsSamples = [];
  _fpsSampleIndex = 0;
  constructor() {
    typeof Mp == "number" && (this.timeScale = Mp);
  }
  /** Step the time. This is called automatically by the Needle Engine Context.
   * @internal
   */
  update() {
    this.deltaTime = this.clock.getDelta(), this.deltaTime = Math.min(0.1, this.deltaTime), this._deltaTimeUnscaled = this.deltaTime, this.deltaTime <= 0 && (this.deltaTime = 1e-12), this.deltaTime *= this.timeScale, this.frame += 1, this.time += this.deltaTime, this._fpsSamples.length < 60 ? this._fpsSamples.push(this.deltaTime) : this._fpsSamples[this._fpsSampleIndex++ % 60] = this.deltaTime;
    let e = 0;
    for (let t = 0; t < this._fpsSamples.length; t++)
      e += this._fpsSamples[t];
    this._smoothedDeltaTime = e / this._fpsSamples.length, this._smoothedFps = 1 / this._smoothedDeltaTime;
  }
}
let Ky = !1;
function E0(s) {
  Ky || (Ky = !0, oO(), rO());
}
E0();
function oO() {
  const s = `
float startCompression = 0.8;
float desaturation = 0.5;
// Patched tonemapping function
vec3 NeutralToneMapping( vec3 color ) {
    color *= toneMappingExposure;
    
    float d = 1. - startCompression;
    // float peak = dot(color, vec3(0.299, 0.587, 0.114));
    float peak = max(color.r, max(color.g, color.b));
    if (peak < startCompression) return color;
    float newPeak = 1. - d * d / (peak + d - startCompression);
    float invPeak = 1. / peak;
    
    float extraBrightness = dot(color * (1. - startCompression * invPeak), vec3(1, 1, 1));
    
    color *= newPeak * invPeak;
    float g = 1. - 3. / (desaturation * extraBrightness + 3.);
    return mix(color, vec3(1, 1, 1), g);
}
`, e = "vec3 NeutralToneMapping( vec3 color ) {", t = `return mix( color, vec3( newPeak ), g );
}`, i = Wt.tonemapping_pars_fragment.indexOf(e), n = Wt.tonemapping_pars_fragment.indexOf(t, i);
  if (i >= 0 && n >= 0) {
    const o = Wt.tonemapping_pars_fragment.substring(i, n + t.length);
    Wt.tonemapping_pars_fragment = Wt.tonemapping_pars_fragment.replace(o, s);
  } else L() && console.error("Couldn't find NeutralToneMapping in ShaderChunk.tonemapping_pars_fragment");
}
function rO() {
  const s = `
// 0: Default, 1: Golden, 2: Punchy
#define AGX_LOOK 0        

vec3 userSlope = vec3(1.0);
vec3 userOffset = vec3(0.0);
vec3 userPower = vec3(1.0);
float userSaturation = 1.0;

// Mean error^2: 3.6705141e-06
vec3 _agxDefaultContrastApprox(vec3 x) {
    vec3 x2 = x * x;
    vec3 x4 = x2 * x2;
    
    return  + 15.5     * x4 * x2
            - 40.14    * x4 * x
            + 31.96    * x4
            - 6.868    * x2 * x
            + 0.4298   * x2
            + 0.1191   * x
            - 0.00232;
}

vec3 _agx(vec3 val) {
    const mat3 agx_mat = mat3(
        0.842479062253094, 0.0423282422610123, 0.0423756549057051,
        0.0784335999999992,  0.878468636469772,  0.0784336,
        0.0792237451477643, 0.0791661274605434, 0.879142973793104);
    
    const float min_ev = -12.47393;
    const float max_ev = 4.026069;

    // val = pow(val, vec3(2.2)); 

    // Input transform (inset)
    val = agx_mat * val;
    
    // Log2 space encoding
    val = clamp(log2(val), min_ev, max_ev);
    val = (val - min_ev) / (max_ev - min_ev);
    
    // Apply sigmoid function approximation
    val = _agxDefaultContrastApprox(val);

    return val;
}

vec3 _agxEotf(vec3 val) {
    const mat3 agx_mat_inv = mat3(
        1.19687900512017, -0.0528968517574562, -0.0529716355144438,
        -0.0980208811401368, 1.15190312990417, -0.0980434501171241,
        -0.0990297440797205, -0.0989611768448433, 1.15107367264116);
        
    // Inverse input transform (outset)
    val = agx_mat_inv * val;
    
    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display
    // NOTE: We're linearizing the output here. Comment/adjust when
    // *not* using a sRGB render target
    val = pow(val, vec3(2.2)); 

    return val;
}

vec3 _agxLook(vec3 val) {
    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(val, lw);
    
    // Default
    vec3 offset = vec3(0.0);
    vec3 slope = vec3(1.0);
    vec3 power = vec3(1.0);
    float sat = 1.0;
    
    #if AGX_LOOK == 1
    // Golden
    slope = vec3(1.0, 0.9, 0.5);
    power = vec3(0.8);
    sat = 0.8;
    #elif AGX_LOOK == 2
    // Punchy
    slope = vec3(1.0);
    power = vec3(1.35, 1.35, 1.35);
    sat = 1.4;
    #endif        
    
    // Needle
    slope = vec3(1.05);
    power = vec3(1.10, 1.10, 1.10);
    sat = 1.15;

    // User
    // slope = userSlope;
    // offset = userOffset;
    // power = userPower;
    // sat = userSaturation;
    
    // ASC CDL
    val = pow(val * slope + offset, power);
    return luma + sat * (val - luma);
}


vec3 AgXToneMapping( vec3 color ) {
    // apply AGX
    color *= toneMappingExposure;
    color = max(color, vec3(0.001)); // Prevent NaN
    color = _agx(color);
    color = _agxLook(color); // Optional
    color = _agxEotf(color);
    return color;
`, e = "vec3 AgXToneMapping( vec3 color ) {", t = "return color;", i = Wt.tonemapping_pars_fragment.indexOf(e), n = Wt.tonemapping_pars_fragment.indexOf(t, i);
  if (i >= 0 && n >= 0) {
    const o = Wt.tonemapping_pars_fragment.substring(i, n + t.length);
    Wt.tonemapping_pars_fragment = Wt.tonemapping_pars_fragment.replace(o, s);
  } else L() && console.error("Couldn't find AgXToneMapping in ShaderChunk.tonemapping_pars_fragment");
}
function A0(s) {
  if (typeof s == "string")
    switch (s = s.toLowerCase(), s) {
      case "none":
        return Gh;
      case "neutral":
        return ha;
      case "aces":
        return jd;
      case "agx":
        return Dd;
      case "khronos_neutral":
        return ha;
      default:
        console.warn("[PostProcessing] Unknown tone mapping mode", s);
        return;
    }
}
function Mt(s) {
  const e = document.createElement("span");
  return e.style.maxWidth = "48px", e.style.maxHeight = "48px", e.style.overflow = "hidden", e.classList.add("material-symbols-outlined", "notranslate"), e.setAttribute("translate", "no"), e.innerText = s, e;
}
function aO(s) {
  return s.classList?.contains("material-symbols-outlined") || !1;
}
const ih = /* @__PURE__ */ new Map();
async function Zy(s) {
  const e = "Material Symbols Outlined";
  if (document.fonts.check(`1em '${e}'`) || (console.log("Font not loaded yet"), await document.fonts.ready), ih.has(s))
    return ih.get(s);
  const t = document.createElement("canvas"), i = 48;
  t.width = i, t.height = i;
  const n = t.getContext("2d");
  if (n) {
    n.font = `${i}px '${e}'`, n.fillStyle = "black", n.fillText(s, 0, i);
    const o = t.toDataURL(), r = new Te();
    return r.name = s + " icon", r.image = new Image(), r.image.src = o, r.needsUpdate = !0, ih.set(s, r), r;
  }
  return ih.set(s, null), null;
}
class On {
  static _instance;
  /** 
   * Get access to the default HTML button factory.    
   * Use this to get or create default Needle Engine buttons that can be added to your HTML UI  
   * If you want to create a new factory and create new button instances instead of shared buttons, use `ButtonsFactory.create()` instead
   */
  static get instance() {
    return this.getOrCreate();
  }
  /** 
   * Get access to the default HTML button factory.    
   * Use this to get or create default Needle Engine buttons that can be added to your HTML UI  
   * If you want to create a new factory and create new button instances instead of shared buttons, use `ButtonsFactory.create()` instead
   */
  static getOrCreate() {
    return this._instance || (this._instance = new On()), this._instance;
  }
  /** create a new buttons factory */
  static create() {
    return new On();
  }
  _fullscreenButton;
  /**
   * Get the fullscreen button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createFullscreenButton} to get or create it
   */
  get fullscreenButton() {
    return this._fullscreenButton;
  }
  /** Create a fullscreen button (or return the existing one if it already exists) */
  createFullscreenButton(e) {
    if (this._fullscreenButton)
      return this._fullscreenButton;
    if (!document.fullscreenEnabled)
      return L() && console.warn("NeedleMenu: Fullscreen button could not be created, device doesn't support the Fullscreen API"), null;
    const t = document.createElement("button");
    this._fullscreenButton = t, t.classList.add("fullscreen-button"), t.title = "Click to enter fullscreen mode";
    const i = Mt("fullscreen"), n = Mt("fullscreen_exit");
    return t.appendChild(i), t.onclick = () => {
      document.fullscreenElement ? document.exitFullscreen() : "webkitRequestFullscreen" in e.domElement && typeof e.domElement.webkitRequestFullscreen == "function" ? e.domElement.webkitRequestFullscreen() : "requestFullscreen" in e.domElement && e.domElement.requestFullscreen();
    }, document.addEventListener("fullscreenchange", () => {
      document.fullscreenElement ? (i.remove(), t.appendChild(n), t.title = "Click to enter fullscreen mode") : (n.remove(), t.appendChild(i), t.title = "Click to exit fullscreen mode");
    }), globalThis.addEventListener("needle-xrsession-start", () => {
      t.style.display = "none";
    }), globalThis.addEventListener("needle-xrsession-end", () => {
      t.style.display = "";
    }), t;
  }
  _muteButton;
  /** Get the mute button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createMuteButton} to get or create it */
  get muteButton() {
    return this._muteButton;
  }
  /** Create a mute button (or return the existing one if it already exists) */
  createMuteButton(e) {
    if (this._muteButton)
      return this._muteButton;
    const t = document.createElement("button");
    this._muteButton = t, t.classList.add("mute-button"), t.title = "Click to mute/unmute";
    const i = Mt("volume_off"), n = Mt("volume_up");
    return e.application.muted ? t.appendChild(i) : t.appendChild(n), t.onclick = () => {
      e.application.muted ? (i.remove(), t.appendChild(n), e.application.muted = !1) : (n.remove(), t.appendChild(i), e.application.muted = !0);
    }, t;
  }
  _qrButton;
  /**
   * Get the QR code button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createQRCode} to get or create it
   */
  get qrButton() {
    return this._qrButton;
  }
  _customQRButtonUrl;
  /** Get or set the QR code button URL - this URL will open when scanning the QR code */
  set qrButtonUrl(e) {
    try {
      new URL(e), this._customQRButtonUrl = e;
    } catch {
      console.warn(`[Needle] QR code button URL is not a valid URL '${e}'`);
    }
  }
  get qrButtonUrl() {
    return this._customQRButtonUrl || window.location.href;
  }
  /** Create a QR code button (or return the existing one if it already exists)
   * The QR code button will show a QR code that can be scanned to open the current page on a phone  
   * The QR code will be generated with the current URL when the button is clicked
   * @returns the QR code button element
   */
  createQRCode() {
    if (this._qrButton) return this._qrButton;
    const e = this, t = document.createElement("button");
    this._qrButton = t, t.innerText = "QR Code", t.prepend(Mt("qr_code")), t.title = "Scan this QR code with your phone to open this page", this.hideElementDuringXRSession(t);
    const i = document.createElement("div");
    i.style.cssText = `
            position: fixed;
            display: inline-block;
            padding: 0.5rem;
            background-color: white;
            border-radius: 0.4rem;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.2);
        `;
    const n = document.createElement("div");
    n.classList.add("qr-code-container"), i.appendChild(n), t.addEventListener("click", () => {
      if (i.parentNode) return r();
      L() && window.location.href.includes("://localhost") && ge("To access your website from another device in the same local network you have to use the IP address instead of localhost. The IP address is logged in your development server console when you start the server."), o();
    });
    async function o() {
      await a();
      const c = document.body.querySelector("needle-engine") || document.body;
      c.appendChild(i);
      const h = n.getBoundingClientRect(), d = t.getBoundingClientRect();
      i.style.left = d.left + d.width * 0.5 - h.width * 0.5 + "px";
      const f = d.top < h.height, p = "1.3rem";
      f ? i.style.top = `calc(${d.bottom}px + ${i.style.padding} + 0.0rem)` : i.style.top = `calc(${d.top - h.height}px - ${i.style.padding} - ${p})`, i.style.opacity = "0", i.style.pointerEvents = "all", i.style.transition = "opacity 0.2s ease-in-out", setTimeout(() => {
        i.style.opacity = "1", window.addEventListener("click", r, { once: !0 });
      }), window.addEventListener("resize", r), window.addEventListener("scroll", r), document.fullscreenElement ? document.fullscreenElement.appendChild(i) : c.appendChild(i);
    }
    function r() {
      i.style.pointerEvents = "none", i.style.transition = "opacity 0.2s", i.style.opacity = "0", setTimeout(() => i.parentNode?.removeChild(i), 500), window.removeEventListener("click", r), window.removeEventListener("resize", r), window.removeEventListener("scroll", r);
    }
    async function a() {
      const c = await oC({
        text: e.qrButtonUrl,
        width: 200,
        height: 200
      });
      n.innerHTML = "", n.appendChild(c);
    }
    return t.addEventListener("pointerenter", () => {
      a();
    }, { once: !0 }), t;
  }
  hideElementDuringXRSession(e) {
    Om((t) => {
      e["previous-display"] = e.style.display, e.style.display = "none";
    }), Kb((t) => {
      e["previous-display"] != null && (e.style.display = e["previous-display"]);
    });
  }
}
function cd(s, e) {
  const t = e?.element || document.head, i = Array.from(t.querySelectorAll(`link[rel=stylesheet][href*='${s}']`));
  if (i.length <= 0) {
    const n = document.createElement("link");
    n.href = s, n.rel = "stylesheet", t.appendChild(n), i.push(n);
  }
  if (e?.loadedCallback)
    for (let n = 0; n < i.length; n++)
      e?.loadedCallback && i[n].addEventListener("load", e.loadedCallback);
}
function I0() {
  cd("https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap");
}
const Rp = "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&display=block", hd = "needle-logo-element";
class L0 extends HTMLElement {
  static get elementName() {
    return hd;
  }
  static create() {
    return document.createElement(hd);
  }
  constructor() {
    super(), this._root = this.attachShadow({ mode: "closed" });
    const e = document.createElement("template");
    e.innerHTML = `<style>
        :host {
            position: relative;
            min-width: fit-content;
            /* height: 100%; can not have height 100% because of align-items: stretch; in the parent */
            display: flex;
        }

        .wrapper {
            position: relative;
            display: grid;
            grid-template-columns: auto auto;
            padding: .1rem;
        }
        .wrapper:hover {
            cursor: pointer;
        }
        img {
            width: 95px;
            height: 100%;
            align-self: end;
            margin-left: 0.6rem;
        }
        span {
            font-size: 1rem;
            white-space: nowrap;
        }
        </style>
        <div class="wrapper">
            <img class="logo" src=${QS} />
        </div>
        `, this._root.appendChild(e.content.cloneNode(!0)), this.wrapper = this._root.querySelector(".wrapper"), this._root.appendChild(this.wrapper), this.addEventListener("click", () => {
      globalThis.open("https://needle.tools", "_blank");
    }), this.wrapper.setAttribute("title", "Made with Needle Engine");
  }
  _root;
  wrapper;
  logoElement = document.createElement("img");
  textElement = document.createElement("span");
  setLogoVisible(e) {
    this.logoElement.style.display = e ? "block" : "none";
  }
}
customElements.get(hd) || customElements.define(hd, L0);
const mf = w("debugspatialmenu");
class lO {
  _context;
  needleMenu;
  htmlButtonsMap = /* @__PURE__ */ new Map();
  enabled = !0;
  constructor(e, t) {
    this._context = e, this._context.pre_render_callbacks.push(this.preRender), this.needleMenu = t;
    const i = this.needleMenu.shadowRoot?.querySelector(".options");
    i ? new MutationObserver((o) => {
      if (this.enabled && !(this._context.isInXR == !1 && !mf))
        for (const r of o)
          r.type === "childList" && (r.addedNodes.forEach((a) => {
            this.createButtonFromHTMLNode(a);
          }), r.removedNodes.forEach((a) => {
            const l = a, c = this.htmlButtonsMap.get(l);
            c && (this.htmlButtonsMap.delete(l), c.remove(), Ce.update());
          }));
    }).observe(i, { childList: !0 }) : console.error("Could not find options container in needle menu");
  }
  setEnabled(e) {
    this.enabled = e, e || this.menu?.removeFromParent();
  }
  userRequestedMenu = !1;
  /** Bring up the spatial menu. This is typically invoked from a button click. 
   * The menu will show at a lower height to be easily accessible.
   * @returns true if the menu was shown, false if it can't be shown because the menu has been disabled.
   */
  setDisplay(e) {
    return this.enabled ? (this.userRequestedMenu = e, !0) : !1;
  }
  onDestroy() {
    const e = this._context.pre_render_callbacks.indexOf(this.preRender);
    e > -1 && this._context.pre_render_callbacks.splice(e, 1);
  }
  uiisDirty = !1;
  markDirty() {
    this.uiisDirty = !0;
  }
  _showNeedleLogo;
  showNeedleLogo(e) {
    this._showNeedleLogo = e;
  }
  _wasInXR = !1;
  preRender = () => {
    if (!this.enabled) {
      this.menu?.removeFromParent();
      return;
    }
    if (mf && X.isDesktop() && this.updateMenu(), !this._context.xr?.running) {
      this._wasInXR && (this._wasInXR = !1, this.onExitXR());
      return;
    }
    this._wasInXR || (this._wasInXR = !0, this.onEnterXR()), this.updateMenu();
  };
  onEnterXR() {
    const e = this.needleMenu.shadowRoot?.querySelector(".options");
    e && e.childNodes.forEach((t) => {
      this.createButtonFromHTMLNode(t);
    });
  }
  onExitXR() {
    this.menu?.removeFromParent();
  }
  createButtonFromHTMLNode(e) {
    const t = this.getMenu(), i = this.htmlButtonsMap.get(e);
    if (i) {
      i.add();
      return;
    }
    if (e instanceof HTMLButtonElement) {
      const n = this.createButton(t, e);
      this.htmlButtonsMap.set(e, n), n.add();
    } else e instanceof HTMLSlotElement && e.assignedNodes().forEach((n) => {
      this.createButtonFromHTMLNode(n);
    });
  }
  _menuTarget = new M();
  positionFilter = new Db(90, 0.5);
  updateMenu() {
    const e = this.getMenu();
    this.handleNeedleWatermark(), this._context.scene.add(e);
    const t = this._context.mainCamera, n = this._context.xr?.rigScale || 1;
    if (t) {
      const o = t.worldPosition, r = t.worldForward.multiplyScalar(-1), a = r.y > 0.6, l = r.y > 0.4, c = (e.visible ? l : a) || this.userRequestedMenu, h = !e.visible && c;
      e.visible = c || X.isDesktop() && mf, r.multiplyScalar(3 * n), o.add(r), (h || !1) && (e.position.copy(this._menuTarget.position), e.position.y += 0.25, this._menuTarget.position.copy(e.position), this.positionFilter.reset(e.position), e.quaternion.copy(this._menuTarget.quaternion), this.markDirty());
      const f = this._menuTarget.position.distanceTo(o);
      (h || f > 1.5 * n) && (this.ensureRenderOnTop(this.menu), this._menuTarget.position.copy(o), this._context.scene.add(this._menuTarget), Nd(this._menuTarget, this._context.mainCamera, !0, !0), this._menuTarget.removeFromParent()), this.positionFilter.filter(this._menuTarget.position, e.position, this._context.time.time), this.menu?.quaternion.slerp(this._menuTarget.quaternion, this._context.time.deltaTime * 5), this.menu?.scale.setScalar(n);
    }
    this.uiisDirty && (this.uiisDirty = !1, Ce.update());
  }
  ensureRenderOnTop(e, t = 0) {
    e instanceof H && (e.material.depthTest = !1, e.material.depthWrite = !1), e.renderOrder = 1e3 + t * 2;
    for (const i of e.children)
      this.ensureRenderOnTop(i, t + 1);
  }
  familyName = "Needle Spatial Menu";
  menu;
  get isVisible() {
    return this.menu?.visible;
  }
  getMenu() {
    if (this.menu)
      return this.menu;
    this.ensureFont(), this.menu = new Ce.Block({
      boxSizing: "border-box",
      fontFamily: this.familyName,
      height: "auto",
      fontSize: 0.1,
      color: 0,
      lineHeight: 1,
      backgroundColor: 16777215,
      backgroundOpacity: 0.55,
      borderRadius: 1,
      whiteSpace: "pre-wrap",
      flexDirection: "row",
      alignItems: "center",
      padding: new de(0, 0.05, 0, 0.05),
      borderColor: 0,
      borderOpacity: 0.05,
      borderWidth: 5e-3
    });
    const e = P.get("ObjectRaycaster");
    return e && ta(this.menu, new e()), this.menu;
  }
  _poweredByNeedleElement;
  handleNeedleWatermark() {
    if (!this._poweredByNeedleElement) {
      this._poweredByNeedleElement = new Ce.Block({
        width: "auto",
        height: "auto",
        fontSize: 0.05,
        whiteSpace: "pre-wrap",
        flexDirection: "row",
        flexWrap: "wrap",
        justifyContent: "center",
        margin: 0.02,
        borderRadius: 0.02,
        padding: 0.02,
        backgroundColor: 16777215,
        backgroundOpacity: 1
      }), this._poweredByNeedleElement["needle:use_eventsystem"] = !0;
      const e = new Jy(this._context, () => globalThis.open("https://needle.tools", "_self"));
      ta(this._poweredByNeedleElement, e);
      const t = new Ce.Text({
        textContent: "Powered by",
        width: "auto",
        height: "auto"
      }), i = new Ce.Text({
        textContent: "needle",
        width: "auto",
        height: "auto",
        fontSize: 0.07,
        margin: new de(0, 0, 0, 0.02)
      });
      this._poweredByNeedleElement.add(t), this._poweredByNeedleElement.add(i), this.menu?.add(this._poweredByNeedleElement), this.markDirty(), new Jl().load("./include/needle/poweredbyneedle.webp", (o) => {
        e.allowModifyUI = !1, t.removeFromParent(), i.removeFromParent();
        const r = o.image.width / o.image.height;
        this._poweredByNeedleElement?.set({
          backgroundImage: o,
          backgroundOpacity: 1,
          width: 0.1 * r,
          height: 0.1
        }), this.markDirty();
      });
    }
    if (this.menu) {
      const e = this.menu.children.indexOf(this._poweredByNeedleElement);
      if (!this._showNeedleLogo && bs())
        e >= 0 && (this._poweredByNeedleElement.removeFromParent(), this.markDirty());
      else {
        this._poweredByNeedleElement.visible = !0, this.menu.add(this._poweredByNeedleElement);
        const t = this.menu.children.indexOf(this._poweredByNeedleElement);
        e !== t && this.markDirty();
      }
    }
  }
  ensureFont() {
    let e = Ce.FontLibrary.getFontFamily(this.familyName);
    e || (e = Ce.FontLibrary.addFontFamily(this.familyName), e.addVariant("normal", "normal", "./include/needle/arial-msdf.json", "./include/needle/arial.png")?.addEventListener("ready", () => {
      this.markDirty();
    }));
  }
  createButton(e, t) {
    const i = new Ce.Block({
      width: "auto",
      height: "auto",
      whiteSpace: "pre-wrap",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "center",
      backgroundColor: 16777215,
      backgroundOpacity: 0,
      padding: 0.02,
      margin: 0.01,
      borderRadius: 0.02,
      cursor: "pointer",
      fontSize: 0.05
    }), n = new Ce.Text({
      textContent: "",
      width: "auto",
      justifyContent: "center",
      alignItems: "center",
      backgroundOpacity: 0,
      backgroundColor: 16777215,
      fontFamily: this.familyName,
      color: 0,
      borderRadius: 0.02,
      padding: 0.01
    });
    i.add(n), i["needle:use_eventsystem"] = !0;
    const o = new Jy(this._context, () => t.click());
    return ta(i, o), new cO(this, e, t, i, n);
  }
}
class cO {
  menu;
  root;
  htmlbutton;
  spatialContainer;
  spatialText;
  spatialIcon;
  constructor(e, t, i, n, o) {
    this.menu = e, this.root = t, this.htmlbutton = i, this.spatialContainer = n, this.spatialText = o, new MutationObserver((a) => {
      for (const l of a)
        l.type === "attributes" ? l.attributeName === "style" && this.updateVisible() : l.type === "childList" && this.updateText();
    }).observe(i, { attributes: !0, childList: !0 }), this.updateText();
  }
  add() {
    this.spatialContainer.parent != this.root && (this.root.add(this.spatialContainer), this.menu.markDirty(), this.updateVisible(), this.updateText());
  }
  remove() {
    this.spatialContainer.parent && (this.spatialContainer.removeFromParent(), this.menu.markDirty());
  }
  updateVisible() {
    const e = this.spatialContainer.visible;
    this.spatialContainer.visible = this.htmlbutton.style.display !== "none", e !== this.spatialContainer.visible && this.menu.markDirty();
  }
  _lastText = "";
  updateText() {
    let e = "", t = "";
    this.htmlbutton.childNodes.forEach((i) => {
      i.nodeType === Node.TEXT_NODE ? e += i.textContent : i instanceof HTMLElement && aO(i) && i.textContent && (t = i.textContent);
    }), this._lastText !== e && (this._lastText = e, this.spatialText.name = e, this.spatialText.set({ textContent: e }), this.menu.markDirty()), e.length <= 0 ? this.spatialText.parent && (this.spatialText.removeFromParent(), this.menu.markDirty()) : this.spatialText.parent || (this.spatialContainer.add(this.spatialText), this.menu.markDirty()), t && this.createIcon(t);
  }
  _lastTexture;
  async createIcon(e) {
    if (!this.spatialIcon) {
      const i = await Zy(e);
      if (i && !this.spatialIcon) {
        const o = new Ce.Block({
          width: 0.08,
          height: 0.08,
          backgroundColor: 16777215,
          backgroundImage: i,
          backgroundOpacity: 1,
          margin: new de(0, 5e-3, 0, 0)
        });
        this.spatialIcon = o, this.spatialContainer.add(o), this.menu.markDirty();
      }
    }
    if (e != this._lastTexture) {
      this._lastTexture = e;
      const i = await Zy(e);
      i && (this.spatialIcon?.set({ backgroundImage: i }), this.menu.markDirty());
    }
    const t = this.spatialContainer.children.indexOf(this.spatialIcon);
    t > 0 && (this.spatialContainer.children.splice(t, 1), this.spatialContainer.children.unshift(this.spatialIcon), this.menu.markDirty());
  }
}
class Jy {
  isComponent = !0;
  enabled = !0;
  get activeAndEnabled() {
    return !0;
  }
  __internalAwake() {
  }
  __internalEnable() {
  }
  __internalDisable() {
  }
  __internalStart() {
  }
  onEnable() {
  }
  onDisable() {
  }
  gameObject;
  allowModifyUI = !0;
  get element() {
    return this.gameObject;
  }
  context;
  onclick;
  constructor(e, t) {
    this.context = e, this.onclick = t;
  }
  onPointerEnter() {
    this.context.input.setCursor("pointer"), this.allowModifyUI && (this.element.set({ backgroundOpacity: 1 }), Ce.update());
  }
  onPointerExit() {
    this.context.input.unsetCursor("pointer"), this.allowModifyUI && (this.element.set({ backgroundOpacity: 0 }), Ce.update());
  }
  onPointerDown(e) {
    e.use();
  }
  onPointerUp(e) {
    e.use();
  }
  onPointerClick(e) {
    e.use(), this.onclick();
  }
}
const $o = "needle-menu", Nl = w("debugmenu"), e_ = w("debugnoncommercial");
let hO = class {
  _context;
  _menu;
  _spatialMenu;
  constructor(e) {
    this._menu = Yd.getOrCreate(e.domElement, e), this._context = e, this._spatialMenu = new lO(e, this._menu), window.addEventListener("message", this.onPostMessage), Om(this.onStartXR);
  }
  /** @ignore internal method */
  onDestroy() {
    window.removeEventListener("message", this.onPostMessage), this._menu.remove(), this._spatialMenu.onDestroy();
  }
  onPostMessage = (e) => {
    if (e.origin === globalThis.location.origin && typeof e.data == "object") {
      const t = e.data, i = t.type;
      if (i === "needle:menu") {
        const n = t.button;
        if (n) {
          if (!n.label) return console.error("NeedleMenu: buttoninfo.label is required");
          if (!n.onclick) return console.error("NeedleMenu: buttoninfo.onclick is required");
          const o = document.createElement("button");
          if (o.textContent = n.label, n.icon) {
            const r = Mt(n.icon);
            o.prepend(r);
          }
          n.priority && o.setAttribute("priority", n.priority.toString()), o.onclick = () => {
            if (n.onclick) {
              const r = n.onclick.startsWith("http") || n.onclick.startsWith("www."), a = n.target || "_blank";
              r ? globalThis.open(n.onclick, a) : console.error("NeedleMenu: onclick is not a valid link", n.onclick);
            }
          }, this._menu.appendChild(o);
        } else Nl && console.error("NeedleMenu: unknown postMessage event", t);
      } else Nl && console.warn("NeedleMenu: unknown postMessage type", i, t);
    }
  };
  onStartXR = (e) => {
    e.session.isScreenBasedAR && (this._menu.previousParent = this._menu.parentNode, this._context.arOverlayElement.appendChild(this._menu), e.session.session.addEventListener("end", this.onExitXR), this._menu.closeFoldout());
  };
  onExitXR = () => {
    this._menu.previousParent && (this._menu.previousParent.appendChild(this._menu), delete this._menu.previousParent);
  };
  /** Experimental: Change the menu position to be at the top or the bottom of the needle engine webcomponent
   * @param position "top" or "bottom"
   */
  setPosition(e) {
    this._menu.setPosition(e);
  }
  /**
   * Call to show or hide the menu.  
   * NOTE: Hiding the menu is a PRO feature and requires a needle engine license. Hiding the menu will not work in production without a license.
   */
  setVisible(e) {
    this._menu.setVisible(e);
  }
  /** When set to false, the Needle Engine logo will be hidden. Hiding the logo requires a needle engine license */
  showNeedleLogo(e) {
    this._menu.showNeedleLogo(e), this._spatialMenu?.showNeedleLogo(e);
  }
  /** @returns true if the logo is visible */
  get logoIsVisible() {
    return this._menu.logoIsVisible;
  }
  /** When enabled=true the menu will be visible in VR/AR sessions */
  showSpatialMenu(e) {
    this._spatialMenu.setEnabled(e);
  }
  setSpatialMenuVisible(e) {
    this._spatialMenu.setDisplay(e);
  }
  get spatialMenuIsVisible() {
    return this._spatialMenu.isVisible;
  }
  /**
   * Call to add or remove a button to the menu to show a QR code for the current page  
   * If enabled=true then a button will be added to the menu that will show a QR code for the current page when clicked.
   */
  showQRCodeButton(e) {
    if (e === "desktop-only" && (e = !X.isMobileDevice()), e) {
      const t = On.getOrCreate().createQRCode();
      return t.style.display = "", this._menu.appendChild(t), t;
    } else {
      const t = On.getOrCreate().qrButton;
      return t && (t.style.display = "none"), t ?? null;
    }
  }
  /** Call to add or remove a button to the menu to mute or unmute the application  
   * Clicking the button will mute or unmute the application
  */
  showAudioPlaybackOption(e) {
    if (!e) {
      this._muteButton?.remove();
      return;
    }
    this._muteButton = On.getOrCreate().createMuteButton(this._context), this._muteButton.setAttribute("priority", "100"), this._menu.appendChild(this._muteButton);
  }
  _muteButton;
  showFullscreenOption(e) {
    if (!e) {
      this._fullscreenButton?.remove();
      return;
    }
    this._fullscreenButton = On.getOrCreate().createFullscreenButton(this._context), this._fullscreenButton && (this._fullscreenButton.setAttribute("priority", "150"), this._menu.appendChild(this._fullscreenButton));
  }
  _fullscreenButton;
  appendChild(e) {
    return this._menu.appendChild(e);
  }
};
class Yd extends HTMLElement {
  static create() {
    return document.createElement($o, { is: $o });
  }
  static getOrCreate(e, t) {
    let i = e.querySelector($o);
    return !i && e.shadowRoot && (i = e.shadowRoot.querySelector($o)), i || (i = window.document.body.querySelector($o)), i || (i = Yd.create(), e.shadowRoot ? e.shadowRoot.appendChild(i) : e.appendChild(i)), i._domElement = e, i._context = t, i;
  }
  _domElement = null;
  _context = null;
  constructor() {
    super();
    const e = document.createElement("template");
    e.innerHTML = `<style>

        /** Styling attributes that ensure the nested menu z-index does not cause it to overlay elements outside of <needle-engine> */
        :host {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 0;
            top: 0;
            pointer-events: none;
        }

        #root {
            position: absolute;
            width: auto;
            max-width: 95%;
            left: 50%;
            transform: translateX(-50%);
            top: min(20px, 10vh);
            padding: 0.3rem;
            display: flex;
            visibility: visible;
            flex-direction: row-reverse; /* if we overflow this should be right aligned so the logo is always visible */
            pointer-events: all;
            z-index: 1000;
        }

        /** hide the menu if it's empty **/
        #root.has-no-options.logo-hidden {
            display: none; 
        }

        /** using a div here because then we can change the class for placement **/
        #root.bottom {
            top: auto;
            bottom: min(30px, 10vh);
        }
        #root.top {
            top: calc(.7rem + env(safe-area-inset-top));
        }
        
        .wrapper {
            position: relative;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: stretch;
            gap: 0px;
            padding: 0 0rem;
        }

        .wrapper > *, .options > button, .options > select, ::slotted(*) {
            position: relative;
            border: none;
            border-radius: 0;
            outline: 1px solid rgba(0,0,0,0);
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 2.3rem;
            max-width: 100%;

            /** basic font settings for all entries **/
            font-size: 1rem;
            font-family: 'Roboto Flex', sans-serif;
            font-optical-sizing: auto;
            font-weight: 500;
            font-weight: 200;
            font-variation-settings: "wdth" 100;
            color: rgb(20,20,20);
        }

        .options > select[multiple]:hover {
            max-height: 300px;
        }

        .floating-panel-style {
            background: rgba(255, 255, 255, .4);
            outline: rgb(0 0 0 / 5%) 1px solid;
            border: 1px solid rgba(255, 255, 255, .1);
            box-shadow: 0px 7px 0.5rem 0px rgb(0 0 0 / 6%), inset 0px 0px 1.3rem rgba(0,0,0,.05);
            border-radius: 1.5rem;
            /** 
             * to make nested background filter work 
             * https://stackoverflow.com/questions/60997948/backdrop-filter-not-working-for-nested-elements-in-chrome 
             **/
            &::before {
                content: '';
                position: absolute;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                z-index: -1;
                border-radius: 1.5rem;
                -webkit-backdrop-filter: blur(8px);
                backdrop-filter: blur(8px);
            }
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        .options {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .options > *, ::slotted(*) {
            max-height: 2.25rem;
            padding: .4rem .5rem;
        }
        
        :host .options > *, ::slotted(*) {
            background: transparent;
            border: none;
            white-space: nowrap;
            transition: all 0.1s linear .02s;
            border-radius: 1.5rem;
            user-select: none;
        }
        :host .options > *:hover, ::slotted(*:hover) {
            cursor: pointer;
            color: black;
            background: rgba(245, 245, 245, .8);
            box-shadow: inset 0 0 1rem rgba(0,0,30,.2);
            outline: rgba(0,0,0,.1) 1px solid;
        }
        :host .options > *:active, ::slotted(*:active) {
            background: rgba(255, 255, 255, .8);
            box-shadow: inset 0px 1px 1px rgba(255,255,255,.5), inset 0 0 2rem rgba(0,0,30,.2), inset 0px 2px 4px rgba(0,0,20,.5);
            transition: all 0.05s linear;
        }
        :host .options > *:focus, ::slotted(*:focus) {
            outline: rgba(255,255,255,.5) 1px solid;
        }
        :host .options > *:focus-visible, ::slotted(*:focus-visible) {
            outline: rgba(0,0,0,.5) 1px solid;
        }

        :host .options > *:disabled, ::slotted(*:disabled) {
            background: rgba(0,0,0,.05);
            color: rgba(60,60,60,.7);
            pointer-events: none;
        }

        button, ::slotted(button) {
            gap: 0.3rem;
        }

        /** XR button animation **/
        :host button.this-mode-is-requested {
            background: repeating-linear-gradient(to right, #fff 0%, #fff 40%, #aaffff 55%, #fff 80%);
            background-size: 200% auto;
            background-position: 0 100%;
            animation: AnimationName .7s ease infinite forwards;
        }
        :host button.other-mode-is-requested {
            opacity: .5;
        }
        
        @keyframes AnimationName {
            0% { background-position: 0% 0 }
            100% { background-position: -200% 0 }
        }




        .logo {
            cursor: pointer;
            padding-left: 0.6rem;
            padding-bottom: .02rem;
            margin-right: 0.5rem;
        }
        .logo-hidden {
            .logo {
                display: none;
            }
        }
        :host .has-options .logo {
            border-left: 1px solid rgba(40,40,40,.4);
            margin-left: 0.3rem;
            margin-right: 0.5rem;
        }

        .logo > span {
            white-space: nowrap;
        }



        /** COMPACT */

        /** Hide the menu button normally **/
        .compact-menu-button { display: none; }
        /** And show it when we're in compact mode **/
        .compact .compact-menu-button {
            position: relative;
            display: block;
            background: none;
            border: none;
            border-radius: 2rem;

            margin: 0;
            padding: 0 .3rem;
            padding-top: .2rem;

            z-index: 100;

            color: #000;

            &:hover {
                background: rgba(255,255,255,.2);
                cursor: pointer;
            }
            &:focus {
                outline: 1px solid rgba(255,255,255,.5);
            }
            &:focus-visible {
                outline: 1px solid rgba(0,0,0,.5);
            }
            & .expanded-click-area {
                position: absolute;
                left: 0;
                right: 0;
                top: 10%;
                bottom: 10%;
                transform: scale(1.8);
            }
        }  
        .has-no-options .compact-menu-button {
            display: none;
        }
        .open .compact-menu-button {
            background: rgba(255,255,255,.2);
        }
        .logo-visible .compact-menu-button { 
            margin-left: .2rem;
        }
        
        /** Open and hide menu **/
        .compact .foldout { 
            display: none;
        }
        .open .options, .open .foldout {
            display: flex;
            justify-content: center;
        }
        .compact .wrapper {
            padding: 0;
        }
        .compact .wrapper, .compact .options {
            height: auto;
            max-height: initial;
            flex-direction: row;
            gap: .12rem;
        }
        .compact .options { 
            flex-wrap: wrap;
            gap: .3rem;
        }
        .compact .top .options {
            height: auto;
            flex-direction: row;
        }
        .compact .bottom .wrapper {
            height: auto;
            flex-direction: column;
        }

        .compact .foldout {
            max-height: min(100ch, calc(100vh - 100px));
            overflow: auto;
            overflow-x: hidden;
            align-items: center;

            position: fixed;
            bottom: calc(100% + 5px);
            z-index: 100;
            width: auto;
            left: .2rem;
            right: .2rem;
            padding: .2rem;

        }
        .compact.logo-hidden .foldout {
            /** for when there's no logo we want to center the foldout **/
            min-width: 24ch;
            margin-left: 50%;
            transform: translateX(calc(-50% - .2rem));
        }
        
        .compact.top .foldout {
            top: calc(100% + 5px);
            bottom: auto;
        }

        ::-webkit-scrollbar {
            max-width: 7px;
            background: rgba(100,100,100,.2);
            border-radius: .2rem;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, .3);
            border-radius: .2rem;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgb(150,150,150);
        }

        .compact .options > *, .compact .options > ::slotted(*) {
            font-size: 1.2rem;
            padding: .6rem .5rem;
            width: 100%;
        }
        .compact.has-options .logo {
            border: none;
            padding-left: 0;
            margin-left: 1rem;
            margin-bottom: .02rem;
        }
        .compact .options {
            /** e.g. if we have a very wide menu item like a select with long option names we don't want to overflow **/
            max-width: 100%;

            & > button, & > select {
                display: flex;
                flex-basis: 100%;
                min-height: 3rem;
            }
            & > button.row2 {
                //border: 1px solid red !important;
                display: flex;
                flex: 1;
                flex-basis: 30%;
            }
        }

        /** If there's really not enough space then just hide all options **/
        @media (max-width: 100px) or (max-height: 100px){
            .foldout {
                display: none !important;
            }
            .compact-menu-button {
                display: none !important;
            }
        }
        
        /* dark mode */
        /*
        @media (prefers-color-scheme: dark) {
            :host {
                background: rgba(0,0,0, .6);
            }
            :host button {
                color: rgba(200,200,200);
            }
            :host button:hover {
                background: rgba(100,100,100, .8);
            }
        }
        */

        </style>
        
        <div id="root" class="logo-hidden floating-panel-style bottom">
            <div class="wrapper">
                <div class="foldout">
                    <div class="options" part="options">
                        <slot></slot>
                    </div>
                    <div class="options" part="options">
                        <slot name="end"></slot>
                    </div>
                </div>
                <div style="user-select:none" class="logo">
                    <span class="madewith notranslate">powered by</span>
                </div>
            </div>
            <button class="compact-menu-button">
                <div class="expanded-click-area"></div>
            </button>
        </div>
        `;
    const t = this.attachShadow({ mode: "open" });
    I0(), cd(Rp, { loadedCallback: () => {
      this.handleSizeChange();
    } }), cd(Rp, { element: t });
    const i = e.content.cloneNode(!0);
    t?.appendChild(i), this.root = t.querySelector("#root"), this.wrapper = this.root?.querySelector(".wrapper"), this.options = this.root?.querySelector(".options"), this.logoContainer = this.root?.querySelector(".logo"), this.compactMenuButton = this.root?.querySelector(".compact-menu-button"), this.compactMenuButton.append(Mt("more_vert")), this.foldout = this.root?.querySelector(".foldout"), this.root?.appendChild(this.wrapper), this.wrapper.classList.add("wrapper");
    const n = L0.create();
    n.style.minHeight = "1rem", this.logoContainer.append(n), this.logoContainer.addEventListener("click", () => {
      globalThis.open("https://needle.tools", "_blank");
    });
    try {
      window.requestAnimationFrame(() => mO((h) => {
        if (h == !0 && vs() && !e_) {
          let d = this._userRequestedLogoVisible;
          d === void 0 && (d = !1), this.___onSetLogoVisible(d);
        } else
          this.___onSetLogoVisible(!0);
      }));
    } catch (h) {
      console.error("[Needle Menu] License check failed.", h);
    }
    this.compactMenuButton.addEventListener("click", (h) => {
      h.preventDefault(), this.root.classList.toggle("open");
    });
    let o = this._context;
    setTimeout(() => o = this._context);
    let r = 0;
    const a = (h, d) => {
      Nl && console.log("Set menu visible", d), o?.isInAR && o.arOverlayElement ? h != o.arOverlayElement && o.arOverlayElement.appendChild(this) : this.parentNode != this._domElement?.shadowRoot && this._domElement?.shadowRoot?.appendChild(this), this.style.display = d ? "flex" : "none", this.style.visibility = "visible", this.style.opacity = "1";
    };
    let l = !1;
    new MutationObserver((h) => {
      if (!l)
        try {
          l = !0, this.onChangeDetected(h);
          const d = this?.parentNode;
          if ((this.style.display != "flex" || this.style.visibility != "visible" || this.style.opacity != "1" || d != this._domElement?.shadowRoot) && !vs()) {
            const f = r++;
            rn() && this._userRequestedMenuVisible === !1 ? (f === 0 && a(d, this._userRequestedMenuVisible), f === 1 && console.warn("Needle Menu Warning: You need a PRO license to hide the Needle Engine menu → The menu will be visible in your deployed website if you don't have a PRO license. See https://needle.tools/pricing for details.")) : f === 0 ? a(d, !0) : setTimeout(() => a(d, !0), 5);
          }
        } finally {
          l = !1;
        }
    }).observe(this.root, { childList: !0, subtree: !0, attributes: !0 }), Nl && this.___insertDebugOptions();
  }
  _sizeChangeInterval;
  connectedCallback() {
    window.addEventListener("resize", this.handleSizeChange), this.handleMenuVisible(), this._sizeChangeInterval = setInterval(() => this.handleSizeChange(void 0, !0), 5e3), setTimeout(() => {
      this._domElement?.addEventListener("resize", this.handleSizeChange), this._domElement?.addEventListener("click", this.#t);
    }, 1);
  }
  disconnectedCallback() {
    window.removeEventListener("resize", this.handleSizeChange), clearInterval(this._sizeChangeInterval), this._domElement?.removeEventListener("resize", this.handleSizeChange), this._context?.domElement.removeEventListener("click", this.#t);
  }
  #t = (e) => {
    if (!e.defaultPrevented && e.target == this._domElement && e instanceof PointerEvent && e.button === 0 && this.root.classList.contains("open")) {
      const t = this.foldout.getBoundingClientRect(), i = e;
      i.clientX > t.left && i.clientX < t.right && i.clientY > t.top && i.clientY < t.bottom || this.root.classList.toggle("open", !1);
    }
  };
  _userRequestedLogoVisible = void 0;
  showNeedleLogo(e) {
    this._userRequestedLogoVisible = e, !(!e && (!vs() || e_) && (console.warn("[Needle Engine] You need a PRO license to hide the Needle Engine logo in production."), !rn())) && this.___onSetLogoVisible(e);
  }
  /** @returns true if the logo is visible */
  get logoIsVisible() {
    return !this.root.classList.contains("logo-hidden");
  }
  ___onSetLogoVisible(e) {
    this.logoContainer.style.display = "", this.logoContainer.style.opacity = "1", this.logoContainer.style.visibility = "visible", e ? (this.root.classList.remove("logo-hidden"), this.root.classList.add("logo-visible")) : (this.root.classList.remove("logo-visible"), this.root.classList.add("logo-hidden"));
  }
  setPosition(e) {
    if (e !== "top" && e !== "bottom")
      return console.error("NeedleMenu.setPosition: invalid position", e);
    this.root.classList.remove("top", "bottom"), this.root.classList.add(e);
  }
  _userRequestedMenuVisible = void 0;
  setVisible(e) {
    this._userRequestedMenuVisible = e, this.style.display = e ? "flex" : "none";
  }
  /**
   * If the menu is in compact mode and the foldout is currently open (to show all menu options) then this will close the foldout
   */
  closeFoldout() {
    this.root.classList.remove("open");
  }
  // private _root: ShadowRoot | null = null;
  root;
  /** wraps the whole content */
  wrapper;
  /** contains the buttons and dynamic elements */
  options;
  /** contains the needle-logo html element */
  logoContainer;
  compactMenuButton;
  foldout;
  append(...e) {
    for (const t of e)
      if (typeof t == "string") {
        const i = document.createTextNode(t);
        this.options.appendChild(i);
      } else
        this.options.appendChild(t);
  }
  appendChild(e) {
    if (!(e instanceof Node)) {
      const i = document.createElement("button");
      if (i.textContent = e.label, i.onclick = e.onClick, i.setAttribute("priority", e.priority?.toString() ?? "0"), e.title && (i.title = e.title), e.icon) {
        const n = Mt(e.icon);
        e.iconSide === "right" ? i.appendChild(n) : i.prepend(n);
      }
      e.class && i.classList.add(e.class), e = i;
    }
    return this.options.appendChild(e);
  }
  prepend(...e) {
    for (const t of e)
      if (typeof t == "string") {
        const i = document.createTextNode(t);
        this.options.prepend(i);
      } else
        this.options.prepend(t);
  }
  _isHandlingChange = !1;
  /** Called when any change in the web component is detected (including in children and child attributes) */
  onChangeDetected(e) {
    if (!this._isHandlingChange) {
      this._isHandlingChange = !0;
      try {
        this.handleMenuVisible();
        for (const t of e)
          t.target == this.options && this.onOptionsChildrenChanged(t);
      } finally {
        this._isHandlingChange = !1;
      }
    }
  }
  onOptionsChildrenChanged(e) {
    if (this.root.classList.toggle("has-options", this.hasAnyVisibleOptions), this.root.classList.toggle("has-no-options", !this.hasAnyVisibleOptions), this.handleSizeChange(void 0, !0), e.type === "childList" && e.addedNodes.length > 0) {
      const t = Array.from(this.options.children);
      t.sort((n, o) => {
        const r = parseInt(n.getAttribute("priority") || "0"), a = parseInt(o.getAttribute("priority") || "0");
        return r - a;
      });
      let i = !1;
      for (let n = 0; n < t.length; n++) {
        const o = this.options.children[n], r = t[n];
        if (o !== r) {
          i = !0;
          break;
        }
      }
      if (i)
        for (const n of t)
          this.options.appendChild(n);
    }
  }
  _didSort = /* @__PURE__ */ new Map();
  /** checks if the menu has any content and should be rendered at all
   * if we dont have any content and logo then we hide the menu
   */
  handleMenuVisible() {
    Nl && console.log("Update VisibleState: Any Content?", this.hasAnyContent), this.hasAnyContent ? this.root.style.display = "" : this.root.style.display = "none", this.root.classList.toggle("has-options", this.hasAnyVisibleOptions), this.root.classList.toggle("has-no-options", !this.hasAnyVisibleOptions);
  }
  /** @returns true if we have any content OR a logo */
  get hasAnyContent() {
    return !!(this.logoContainer.style.display != "none" || this.hasAnyVisibleOptions);
  }
  get hasAnyVisibleOptions() {
    for (let e = 0; e < this.options.children.length; e++) {
      const t = this.options.children[e];
      if (t.tagName === "SLOT") {
        const n = t.assignedNodes();
        for (const o of n)
          if (o instanceof HTMLElement && o.style.display != "none")
            return !0;
      } else if (t.style.display != "none") return !0;
    }
    return !1;
  }
  _lastAvailableWidthChange = 0;
  _timeoutHandle = 0;
  handleSizeChange = (e, t) => {
    if (!this._domElement) return;
    const i = this._domElement.clientWidth;
    if (i < 100) {
      clearTimeout(this._timeoutHandle), this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style");
      return;
    }
    const o = i - 40;
    if (!t && Math.abs(o - this._lastAvailableWidthChange) < 1) return;
    this._lastAvailableWidthChange = o, clearTimeout(this._timeoutHandle), this._timeoutHandle = setTimeout(() => {
      const l = a();
      l < 0 ? (this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style")) : l > 0 && (this.root.classList.remove("compact"), this.foldout.classList.remove("floating-panel-style"), a() < 0 && (this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style")));
    }, 5);
    const r = () => this.options.clientWidth + this.logoContainer.clientWidth, a = () => o - r();
  };
  ___insertDebugOptions() {
    window.addEventListener("keydown", (i) => {
      i.key === "p" && this.setPosition(this.root.classList.contains("top") ? "bottom" : "top");
    });
    const e = document.createElement("button");
    e.textContent = "Hide Buttons", e.onclick = () => {
      const i = new Array(this.options.children.length);
      for (let n = 0; n < this.options.children.length; n++)
        i[n] = this.options.children[n];
      for (const n of i)
        this.options.removeChild(n);
      setTimeout(() => {
        for (const n of i)
          this.options.appendChild(n);
      }, 1e3);
    }, this.appendChild(e);
    const t = document.createElement("button");
    t.textContent = "Toggle Logo", t.addEventListener("click", () => {
      this.logoContainer.style.display = this.logoContainer.style.display === "none" ? "" : "none";
    }), this.appendChild(t);
  }
}
customElements.get($o) || customElements.define($o, Yd);
const Xe = w("debugcontext"), dO = w("stats"), uO = w("debugactive"), fO = w("debugframerate"), pO = w("debugcoroutine"), UI = {};
class NI {
  name;
  /** for debugging only */
  alias;
  /** the hash is used as a seed when initially loading the scene files */
  hash;
  /** when true the context will not check if it's visible in the viewport and always update and render */
  runInBackground;
  /** the DOM element the context belongs to or is inside of (this does not have to be the canvas. use renderer.domElement if you want to access the dom canvas) */
  domElement;
  /** externally owned renderer */
  renderer;
  /** externally owned camera */
  camera;
  /** externally owned scene */
  scene;
}
var xe = /* @__PURE__ */ ((s) => (s[s.Start = -1] = "Start", s[s.EarlyUpdate = 0] = "EarlyUpdate", s[s.Update = 1] = "Update", s[s.LateUpdate = 2] = "LateUpdate", s[s.OnBeforeRender = 3] = "OnBeforeRender", s[s.OnAfterRender = 4] = "OnAfterRender", s[s.PrePhysicsStep = 9] = "PrePhysicsStep", s[s.PostPhysicsStep = 10] = "PostPhysicsStep", s[s.Undefined = -1] = "Undefined", s))(xe || {});
function Um(s, e) {
  if (!s) return;
  if (!s.isComponent) {
    (L() || Xe) && console.error(`Registered script is not a Needle Engine component. 
The script will be ignored. Please make sure your component extends "Behaviour" imported from "@needle-tools/engine"
`, s);
    return;
  }
  e || (e = N.Current, Xe && console.warn("> Registering component without context"));
  const t = e?.new_scripts;
  t.includes(s) || t.push(s);
}
class N {
  static _defaultTargetFramerate = { value: 90, toString() {
    return this.value;
  } };
  /** When a new context is created this is the framerate that will be used by default */
  static get DefaultTargetFrameRate() {
    return N._defaultTargetFramerate.value;
  }
  /** When a new context is created this is the framerate that will be used by default */
  static set DefaultTargetFrameRate(e) {
    N._defaultTargetFramerate.value = e;
  }
  static _defaultWebglRendererParameters = {
    antialias: !0,
    alpha: !1,
    // Note: this is due to a bug on OSX devices. See NE-5370
    powerPreference: X.isiOS() || X.isMacOS() ? "default" : "high-performance",
    stencil: !0
    // logarithmicDepthBuffer: true,
    // reverseDepthBuffer: true, // https://github.com/mrdoob/three.js/issues/29770
  };
  /** The default parameters that will be used when creating a new WebGLRenderer.  
   * Modify in global context to change the default parameters for all new contexts.
   * @example
   * ```typescript
   * import { Context } from "@needle-tools/engine";
   * Context.DefaultWebGLRendererParameters.antialias = false;
   * ```
   */
  static get DefaultWebGLRendererParameters() {
    return N._defaultWebglRendererParameters;
  }
  /** The needle engine version */
  get version() {
    return En;
  }
  /** The currently active context. Only set during the update loops */
  static get Current() {
    return he.Current;
  }
  /** @internal this property should not be set by user code */
  static set Current(e) {
    he.Current = e;
  }
  static get All() {
    return he.All;
  }
  /** The name of the context */
  name;
  /** An alias for the context */
  alias;
  /** When the renderer or camera are managed by an external process (e.g. when running in r3f context). 
   * When this is false you are responsible to call update(timestamp, xframe.  
   * It is also currently assumed that rendering is handled performed by an external process
   * */
  isManagedExternally = !1;
  /** set to true to pause the update loop. You can receive an event for it in your components. 
   * Note that script updates will not be called when paused */
  isPaused = !1;
  /** When enabled the application will run while not visible on the page */
  runInBackground = !1;
  /** 
   * Set to the target framerate you want your application to run in (you can use ?stats to check the fps)
   * Set to undefined if you want to run at the maximum framerate
   */
  targetFrameRate;
  /** Use a higher number for more accurate physics simulation.   
   * When undefined physics steps will be 1 for mobile devices and 5 for desktop devices  
   * Set to 0 to disable physics updates
   * TODO: changing physics steps is currently not supported because then forces that we get from the character controller and rigidbody et al are not correct anymore - this needs to be properly tested before making this configureable
  */
  physicsSteps = 1;
  /** used to append to loaded assets */
  hash;
  /** The `<needle-engine>` web component */
  domElement;
  appendHTMLElement(e) {
    return this.domElement.shadowRoot ? this.domElement.shadowRoot.appendChild(e) : this.domElement.appendChild(e);
  }
  get resolutionScaleFactor() {
    return this._resolutionScaleFactor;
  }
  /** use to scale the resolution up or down of the renderer. default is 1 */
  set resolutionScaleFactor(e) {
    if (e !== this._resolutionScaleFactor && typeof e == "number") {
      if (e <= 0) {
        console.error("Invalid resolution scale factor", e);
        return;
      }
      this._resolutionScaleFactor = e, this.updateSize();
    }
  }
  _resolutionScaleFactor = 1;
  // domElement.clientLeft etc doesnt return absolute position
  _boundingClientRectFrame = -1;
  _boundingClientRect = null;
  _domX;
  _domY;
  /** update bounding rects + domX, domY */
  calculateBoundingClientRect() {
    if (this.xr) {
      this._domX = 0, this._domY = 0;
      return;
    }
    this._boundingClientRectFrame !== this.time.frame && (this._boundingClientRectFrame = this.time.frame, this._boundingClientRect = this.domElement.getBoundingClientRect(), this._domX = this._boundingClientRect.x, this._domY = this._boundingClientRect.y);
  }
  /** The width of the `<needle-engine>` element on the website */
  get domWidth() {
    return this.isInAR ? window.innerWidth : this.domElement.clientWidth;
  }
  /** The height of the `<needle-engine>` element on the website */
  get domHeight() {
    return this.isInAR ? window.innerHeight : this.domElement.clientHeight;
  }
  /** the X position of the `<needle-engine>` element on the website */
  get domX() {
    return this.calculateBoundingClientRect(), this._domX;
  }
  /** the Y position of the `<needle-engine>` element on the website */
  get domY() {
    return this.calculateBoundingClientRect(), this._domY;
  }
  /**
   * Is a XR session currently active and presenting?
   * @returns true if the xr renderer is currently presenting
   */
  get isInXR() {
    return this.renderer?.xr?.isPresenting || !1;
  }
  /** shorthand for `NeedleXRSession.active`  
   * Automatically set by NeedleXRSession when a XR session is active 
   * @returns the active XR session or null if no session is active
   * */
  xr = null;
  /**
   * Shorthand for `this.xr?.mode`. AR or VR
   * @returns the current XR session mode (immersive-vr or immersive-ar)
   */
  get xrSessionMode() {
    return this.xr?.mode;
  }
  /** Shorthand for `this.xrSessionMode === "immersive-vr"` 
   * @returns true if a webxr VR session is currently active. 
   */
  get isInVR() {
    return this.xrSessionMode === "immersive-vr";
  }
  /**
   * Shorthand for `this.xrSessionMode === "immersive-ar"`
   * @returns true if a webxr AR session is currently active.
   */
  get isInAR() {
    return this.xrSessionMode === "immersive-ar";
  }
  /** If a XR session is active and in pass through mode (immersive-ar on e.g. Quest) 
   * @returns true if the XR session is in pass through mode
   */
  get isInPassThrough() {
    return this.xr ? this.xr.isPassThrough : !1;
  }
  /** access the raw `XRSession` object (shorthand for `context.renderer.xr.getSession()`). For more control use `NeedleXRSession.active` */
  get xrSession() {
    return this.renderer?.xr?.getSession();
  }
  /** @returns the latest XRFrame (if a XRSession is currently active)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRFrame
   */
  get xrFrame() {
    return this._xrFrame;
  }
  /** @returns the current WebXR camera while the WebXRManager is active (shorthand for `context.renderer.xr.getCamera()`) */
  get xrCamera() {
    return this.renderer.xr.isPresenting ? this.renderer?.xr?.getCamera() : void 0;
  }
  _xrFrame = null;
  /**
   * The AR overlay element is used to display 2D HTML elements while a AR session is active.
   */
  get arOverlayElement() {
    const e = this.domElement;
    return typeof e.getAROverlayContainer == "function" ? e.getAROverlayContainer() : this.domElement;
  }
  /** 
   * Current event of the update cycle (e.g. `FrameEvent.EarlyUpdate` or `FrameEvent.OnBeforeRender`)
   */
  get currentFrameEvent() {
    return this._currentFrameEvent;
  }
  _currentFrameEvent = -1;
  /**
   * The scene contains all objects in the hierarchy and is automatically rendered by the context every frane.
   */
  scene;
  /**
   * The renderer is used to render the scene. It is automatically created when the context is created.
   */
  renderer;
  /**
   * The effect composer can be used to render postprocessing effects. If assigned then it will automatically render the scene every frame.
   */
  composer = null;
  /**
   * @internal All known components. Don't use directly
   */
  scripts = [];
  /**
   * @internal All paused components. Don't use directly
   */
  scripts_pausedChanged = [];
  /**
   * @internal All components that have a early update event. Don't use directly
   */
  scripts_earlyUpdate = [];
  /**
   * @internal All components that have a update event. Don't use directly
   */
  scripts_update = [];
  /**
   * @internal All components that have a late update event. Don't use directly
   */
  scripts_lateUpdate = [];
  /**
   * @internal All components that have a onBeforeRender event. Don't use directly
   */
  scripts_onBeforeRender = [];
  /**
   * @internal All components that have a onAfterRender event. Don't use directly
   */
  scripts_onAfterRender = [];
  /**
   * @internal All components that have coroutines. Don't use directly
   */
  scripts_WithCorroutines = [];
  /**
   * @internal Components with immersive-vr event methods. Don't use directly
   */
  scripts_immersive_vr = [];
  /**
   * @internal Components with immersive-ar event methods. Don't use directly
   */
  scripts_immersive_ar = [];
  /**
   * @internal Coroutine data
   */
  coroutines = {};
  /** callbacks called once after the context has been created */
  post_setup_callbacks = [];
  /** called every frame at the beginning of the frame (after component start events and before earlyUpdate) */
  pre_update_callbacks = [];
  /** called every frame before rendering (after all component events) */
  pre_render_callbacks = [];
  /** called every frame after rendering (after all component events) */
  post_render_callbacks = [];
  /** called every frame befroe update (this list is emptied every frame) */
  pre_update_oneshot_callbacks = [];
  /** @internal */
  new_scripts = [];
  /** @internal */
  new_script_start = [];
  /** @internal */
  new_scripts_pre_setup_callbacks = [];
  /** @internal */
  new_scripts_post_setup_callbacks = [];
  /** @internal */
  new_scripts_xr = [];
  /** 
   * The **main camera component** of the scene - this camera is used for rendering.  
   * Use `setCurrentCamera` for updating the main camera.
   */
  mainCameraComponent = void 0;
  /** 
   * The main camera of the scene - this camera is used for rendering   
   * Use `setCurrentCamera` for updating the main camera.
   */
  get mainCamera() {
    if (this._mainCamera)
      return this._mainCamera;
    if (this.mainCameraComponent) {
      const e = this.mainCameraComponent;
      return e.threeCamera || e.buildCamera(), e.threeCamera;
    }
    return this._fallbackCamera || (this._fallbackCamera = new pe(75, this.domWidth / this.domHeight, 0.1, 1e3)), this._fallbackCamera;
  }
  /** Set the main camera of the scene. If set to null the camera of the {@link mainCameraComponent} will be used - this camera is used for rendering */
  set mainCamera(e) {
    this._mainCamera = e;
  }
  _mainCamera = null;
  _fallbackCamera = null;
  /** access application state (e.g. if all audio should be muted) */
  application;
  /** access animation mixer used by components in the scene */
  animations;
  /** access timings (current frame number, deltaTime, timeScale, ...) */
  time;
  /** access input data (e.g. click or touch events) */
  input;
  /** access physics related methods (e.g. raycasting). To access the phyiscs engine use `context.physics.engine` */
  physics;
  /** access networking methods (use it to send or listen to messages or join a networking backend) */
  connection;
  /** 
   * @deprecated AssetDataBase is deprecated
   */
  assets;
  /** The main light in the scene */
  mainLight = null;
  /** @deprecated Use sceneLighting */
  get rendererData() {
    return this.sceneLighting;
  }
  sceneLighting;
  addressables;
  lightmaps;
  players;
  lodsManager;
  /** Access the needle menu to add or remove buttons to the menu element */
  menu;
  /** @returns true if the context is fully created and ready */
  get isCreated() {
    return this._isCreated;
  }
  _needsUpdateSize = !1;
  _isCreated = !1;
  _isCreating = !1;
  _isVisible = !1;
  _stats = dO ? new dS() : null;
  constructor(e) {
    this.name = e?.name || "", this.alias = e?.alias, this.domElement = e?.domElement || document.body, this.hash = e?.hash, e?.renderer && (this.renderer = e.renderer, this.isManagedExternally = !0), e?.runInBackground !== void 0 && (this.runInBackground = e.runInBackground), e?.scene ? this.scene = e.scene : this.scene = new gi(), e?.camera && (this._mainCamera = e.camera), this.application = new Bn(this), this.time = new sO(), this.input = new a1(this), this.physics = new nc(this), this.connection = new x1(this), this.assets = new z1(), this.sceneLighting = new iO(this), this.addressables = new BP(this), this.lightmaps = new HP(this), this.players = new QP(this), this.menu = new hO(this), this.lodsManager = new GP(this), this.animations = new $P(this);
    const t = () => this._needsUpdateSize = !0;
    window.addEventListener("resize", t), this._disposeCallbacks.push(() => window.removeEventListener("resize", t));
    const i = new ResizeObserver((n) => this._needsUpdateSize = !0);
    i.observe(this.domElement), this._disposeCallbacks.push(() => i.disconnect()), this._intersectionObserver = new IntersectionObserver((n) => {
      this._isVisible = n[0].isIntersecting;
    }), this._disposeCallbacks.push(() => this._intersectionObserver?.disconnect()), he.register(this);
  }
  /** 
   * Calling this function will dispose the current renderer and create a new one which will then be assigned to the context. It can be used to create a new renderer with custom WebGLRendererParameters.   
   * **Note**: Instead you can also modify the static `Context.DefaultWebGlRendererParameters` before the context is created.  
   * **Note**: This method is recommended because it re-uses an potentially already existing canvas element. This is necessary to keep input event handlers from working (e.g. components like OrbitControls subscribe to input events on the canvas)
   * @returns {WebGLRenderer} the newly created renderer
   */
  createNewRenderer(e) {
    if (this.renderer?.dispose(), e = { ...N.DefaultWebGLRendererParameters, ...e }, !e.canvas) {
      const t = this.domElement?.shadowRoot?.querySelector("canvas");
      t && (e.canvas = t, Xe && console.log("Using canvas from shadow root", t));
    }
    return Xe && console.log("Using Renderer Parameters:", e, this.domElement), this.renderer = new ur(e), this.renderer.debug.checkShaderErrors = L() || w("checkshadererrors") === !0, this.renderer.toneMappingExposure = 1, this.renderer.toneMapping = Gh, this.renderer.setClearColor(new se("lightgrey"), 0), this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = nx, this.renderer.setSize(this.domWidth, this.domHeight), this.renderer.outputColorSpace = Cs, this.renderer.nodes = {
      library: new sx(),
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    }, this.lodsManager.setRenderer(this.renderer), this.input.bindEvents(), this.renderer;
  }
  _intersectionObserver = null;
  internalOnUpdateVisible() {
    this._intersectionObserver?.disconnect(), this._intersectionObserver?.observe(this.domElement);
  }
  _disposeCallbacks = [];
  /** will request a renderer size update the next render call (will call updateSize the next update) */
  requestSizeUpdate() {
    this._needsUpdateSize = !0;
  }
  /** Clamps the renderer max resolution. If undefined the max resolution is not clamped. Default is undefined */
  maxRenderResolution;
  /** Control the renderer devicePixelRatio.  
   * **Options**   
   * - `auto` - Needle Engine automatically sets the pixel ratio to the current window.devicePixelRatio.
   * - `manual` - Needle Engine will not change the renderer pixel ratio. You can set it manually.
   * - `number` - Needle Engine will set the pixel ratio to the given number. The change will be applied to the renderer and the composer (if used) at the end of the current frame.
   */
  get devicePixelRatio() {
    return this._devicePixelRatio;
  }
  set devicePixelRatio(e) {
    e !== this._devicePixelRatio && (this._devicePixelRatio = e, this._needsUpdateSize = !0);
  }
  _devicePixelRatio = "auto";
  /** 
   * Update the renderer and canvas size. This is also automatically called when a DOM size change is detected.
   */
  updateSize(e = !1) {
    if (e || !this.isManagedExternally && this.renderer.xr?.isPresenting === !1) {
      this._needsUpdateSize = !1;
      const t = this.resolutionScaleFactor;
      let i = this.domWidth * t, n = this.domHeight * t;
      this.maxRenderResolution && (this.maxRenderResolution.x = Math.max(1, this.maxRenderResolution.x), i = Math.min(this.maxRenderResolution.x, i), this.maxRenderResolution.y = Math.max(1, this.maxRenderResolution.y), n = Math.min(this.maxRenderResolution.y, n));
      const o = this.mainCamera;
      this.updateAspect(o), this.renderer.setSize(i, n, !0), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%";
      const r = typeof this.devicePixelRatio == "number" ? this.devicePixelRatio : this.devicePixelRatio === "auto" ? Math.min(2, window.devicePixelRatio) : void 0;
      r !== void 0 && this.renderer.setPixelRatio(r), this.composer && (this.composer.setSize?.call(this.composer, i, n), r !== void 0 && "setPixelRatio" in this.composer && typeof this.composer.setPixelRatio == "function" && this.composer.setPixelRatio?.call(this.composer, window.devicePixelRatio));
    }
  }
  /**
   * Update the camera aspect ratio or orthorgraphic camera size. This is automatically called when a DOM size change is detected.
   */
  updateAspect(e, t, i) {
    if (!e) return;
    t === void 0 && (t = this.domWidth), i === void 0 && (i = this.domHeight);
    const n = t / i;
    if (e.isPerspectiveCamera) {
      const o = e, r = o.aspect;
      o.aspect = n, r !== o.aspect && e.updateProjectionMatrix();
    } else if (e.isOrthographicCamera) {
      const o = e, r = o.top - o.bottom, l = r * n / 2, c = r / 2;
      (o.left != -l || o.top != c) && (o.left = -l, o.right = l, o.top = c, o.bottom = -c, e.updateProjectionMatrix());
    }
  }
  /** This will recreate the whole needle engine context and dispose the whole scene content  
   * All content will be reloaded (loading times might be faster due to browser caches)   
   * All scripts will be recreated */
  recreate() {
    this.clear(), this.create(this._originalCreationArgs);
  }
  _originalCreationArgs;
  /** @deprecated use create. This method will be removed in a future version */
  async onCreate(e) {
    return this.create(e);
  }
  /** @internal */
  async create(e) {
    try {
      this._isCreating = !0, e !== this._originalCreationArgs && (this._originalCreationArgs = zd(e)), window.addEventListener("unhandledrejection", this.onUnhandledRejection);
      const t = await this.internalOnCreate(e);
      return this._isCreated = t, t;
    } finally {
      window.removeEventListener("unhandledrejection", this.onUnhandledRejection), this._isCreating = !1;
    }
  }
  onUnhandledRejection = (e) => {
    this.onError(e.reason);
  };
  /** Dispatches an error */
  onError(e) {
    this.domElement.dispatchEvent(new CustomEvent("error", { detail: e }));
  }
  /** 
   * Clears the context and destroys all scenes and objects in the scene.   
   * The ContextCleared event is called at the end.   
   * This is automatically called when e.g. the `src` attribute changes on `<needle-engine>`   
   * or when the web component is removed from the DOM
   */
  clear() {
    he.dispatchCallback(ce.ContextClearing, this), mn(this, ce.ContextClearing), Wi(this.scene, !0, !0), this.scene = new gi(), this.addressables?.dispose(), this.lightmaps?.clear(), this.physics?.engine?.clearCaches(), this.lodsManager.disable(), this._onBeforeRenderListeners.clear(), this._onAfterRenderListeners.clear(), this.isManagedExternally || this.renderer && (this.renderer.renderLists.dispose(), this.renderer.state.reset(), this.renderer.resetState()), he.dispatchCallback(ce.ContextCleared, this);
  }
  /**
   * Dispose all allocated resources and clears the scene. This is automatically called e.g. when the `<needle-engine>` component is removed from the DOM.
   */
  dispose() {
    this.internalOnDestroy();
  }
  /**@deprecated use dispose()  */
  onDestroy() {
    this.internalOnDestroy();
  }
  internalOnDestroy() {
    N.Current = this, he.dispatchCallback(ce.ContextDestroying, this), mn(this, ce.ContextDestroying), this.clear(), this.renderer?.setAnimationLoop(null), this.renderer && (this.renderer.setClearAlpha(0), this.renderer.clear(), this.isManagedExternally || (Xe && console.log("Disposing renderer"), this.renderer.dispose())), this.scene = null, this.renderer = null, this.input.dispose(), this.menu.onDestroy(), this.animations.onDestroy();
    for (const e of this._disposeCallbacks)
      try {
        e();
      } catch (t) {
        console.error("Error in on dispose callback:", t, e);
      }
    this.domElement?.parentElement && this.domElement.parentElement.removeChild(this.domElement), this._isCreated = !1, he.dispatchCallback(ce.ContextDestroyed, this), mn(this, ce.ContextDestroyed), he.unregister(this), N.Current === this && (N.Current = null);
  }
  /** @internal Automatically called by components when you call `startCoroutine`. Use `startCoroutine` instead  */
  registerCoroutineUpdate(e, t, i) {
    return typeof t?.next != "function" ? (console.error("Registered invalid coroutine function from " + e.name + `
Coroutine functions must be generators: "*myCoroutine() {...}"
Start a coroutine from a component by calling "this.startCoroutine(myCoroutine())"`), t) : (this.coroutines[i] || (this.coroutines[i] = []), this.coroutines[i].push({ comp: e, main: t }), t);
  }
  /** @internal Automatically called by components. */
  unregisterCoroutineUpdate(e, t) {
    if (!this.coroutines[t]) return;
    const i = this.coroutines[t].findIndex((n) => n.main === e);
    i >= 0 && this.coroutines[t].splice(i, 1);
  }
  /** @internal Automatically called */
  stopAllCoroutinesFrom(e) {
    for (const t in this.coroutines) {
      const i = this.coroutines[t];
      for (let n = i.length - 1; n >= 0; n--)
        i[n].comp === e && i.splice(n, 1);
    }
  }
  _cameraStack = [];
  /** Change the main camera */
  setCurrentCamera(e) {
    if (!e) return;
    if (e.threeCamera || e.buildCamera(), !e.threeCamera) {
      console.warn("Camera component is missing camera", e);
      return;
    }
    const t = this._cameraStack.indexOf(e);
    t >= 0 && this._cameraStack.splice(t, 1), this._cameraStack.push(e), this.mainCameraComponent = e;
    const i = e.threeCamera;
    i.isPerspectiveCamera && this.updateAspect(i), this.mainCameraComponent?.applyClearFlagsIfIsActiveCamera();
  }
  /**
   * Remove the camera from the mainCamera stack (if it has been set before with `setCurrentCamera`)
   */
  removeCamera(e) {
    if (!e) return;
    const t = this._cameraStack.indexOf(e);
    if (t >= 0 && this._cameraStack.splice(t, 1), this.mainCameraComponent === e && (this.mainCameraComponent = void 0, this._cameraStack.length > 0)) {
      const i = this._cameraStack[this._cameraStack.length - 1];
      this.setCurrentCamera(i);
    }
  }
  _onBeforeRenderListeners = /* @__PURE__ */ new Map();
  _onAfterRenderListeners = /* @__PURE__ */ new Map();
  /** Use to subscribe to onBeforeRender events on threejs objects.
   * @link https://threejs.org/docs/#api/en/core/Object3D.onBeforeRender
   */
  addBeforeRenderListener(e, t) {
    if (!this._onBeforeRenderListeners.has(e.uuid)) {
      const i = [];
      this._onBeforeRenderListeners.set(e.uuid, i), e.onBeforeRender = this._createRenderCallbackWrapper(i);
    }
    this._onBeforeRenderListeners.get(e.uuid).push(t);
  }
  /** Remove callback from three `onBeforeRender` event (if it has been added with `addBeforeRenderListener(...)`)
   * @link https://threejs.org/docs/#api/en/core/Object3D.onBeforeRender
  */
  removeBeforeRenderListener(e, t) {
    if (this._onBeforeRenderListeners.has(e.uuid)) {
      const i = this._onBeforeRenderListeners.get(e.uuid), n = i.indexOf(t);
      n >= 0 && i.splice(n, 1);
    }
  }
  /** 
   * Subscribe to onAfterRender events on threejs objects 
   * @link https://threejs.org/docs/#api/en/core/Object3D.onAfterRender
  */
  addAfterRenderListener(e, t) {
    if (!this._onAfterRenderListeners.has(e.uuid)) {
      const i = [];
      this._onAfterRenderListeners.set(e.uuid, i), e.onAfterRender = this._createRenderCallbackWrapper(i);
    }
    this._onAfterRenderListeners.get(e.uuid)?.push(t);
  }
  /** 
   * Remove from onAfterRender events on threejs objects 
   * @link https://threejs.org/docs/#api/en/core/Object3D.onAfterRender
  */
  removeAfterRenderListener(e, t) {
    if (this._onAfterRenderListeners.has(e.uuid)) {
      const i = this._onAfterRenderListeners.get(e.uuid), n = i.indexOf(t);
      n >= 0 && i.splice(n, 1);
    }
  }
  _createRenderCallbackWrapper(e) {
    return (t, i, n, o, r, a) => {
      for (let l = 0; l < e.length; l++) {
        const c = e[l];
        c(t, i, n, o, r, a);
      }
    };
  }
  _requireDepthTexture = !1;
  _requireColorTexture = !1;
  _renderTarget;
  _isRendering = !1;
  /** @returns true while the WebGL renderer is rendering (between onBeforeRender and onAfterRender events) */
  get isRendering() {
    return this._isRendering;
  }
  setRequireDepth(e) {
    this._requireDepthTexture = e;
  }
  setRequireColor(e) {
    this._requireColorTexture = e;
  }
  get depthTexture() {
    return this._renderTarget?.depthTexture || null;
  }
  get opaqueColorTexture() {
    return this._renderTarget?.texture || null;
  }
  /** @returns true if the `<needle-engine>` DOM element is visible on screen (`context.domElement`) */
  get isVisibleToUser() {
    if (this.isInXR) return !0;
    if (!this._isVisible) return !1;
    if (!this._needsVisibleUpdate && this._lastStyleComputedResult !== void 0) return this._lastStyleComputedResult;
    this._needsVisibleUpdate = !1;
    const e = getComputedStyle(this.domElement);
    return this._lastStyleComputedResult = e.visibility !== "hidden" && e.display !== "none" && e.opacity !== "0", this._lastStyleComputedResult;
  }
  _needsVisibleUpdate = !0;
  _lastStyleComputedResult = void 0;
  _createId = 0;
  async internalOnCreate(e) {
    const t = ++this._createId;
    Xe && console.log("Creating context", this.name, e);
    const i = globalThis["needle:dependencies:ready"];
    i instanceof Promise && (Xe && console.log("Waiting for dependencies to be ready"), await i.catch((c) => {
      if (Xe || L()) {
        if (Wd("Needle Engine dependencies failed to load. Please check the console for more details"), c instanceof ReferenceError) {
          let h = "YourComponentName";
          const d = c.message.indexOf("'");
          if (d > 0) {
            const f = c.message.indexOf("'", d + 1);
            if (f > 0) {
              const p = c.message.substring(d + 1, f);
              p.length > 3 && (h = p);
            }
          }
          console.error(`Needle Engine dependencies failed to load:

# Make sure you don't have circular imports in your scripts!

Possible solutions: 
→ Replace @serializable(${h}) in your script with @serializable(Behaviour)
→ If you only need type information try importing the type only, e.g: import { type ${h} }

---`, c);
          return;
        }
        console.error("Needle Engine dependencies failed to load", c);
      }
    }).then(() => {
      Xe && console.log("Needle Engine dependencies are ready");
    })), this.clear();
    const n = this.renderer, o = !n || n.isDisposed === !0;
    this.isManagedExternally === !1 && o ? this.createNewRenderer() : this.lodsManager.setRenderer(this.renderer), this.renderer?.setAnimationLoop(null), N.Current = this, await he.dispatchCallback(ce.ContextCreationStart, this);
    let r = !0, a;
    try {
      N.Current = this, e ? a = await this.internalLoadInitialContent(t, e) : a = [];
    } catch (c) {
      console.error(c), r = !1;
    }
    if (!r)
      return this.onError("Failed to load initial content"), !1;
    if (t !== this._createId || e?.abortSignal?.aborted)
      return !1;
    if (this.internalOnUpdateVisible(), !this.renderer)
      return Xe && console.warn("Context has no renderer (perhaps it was disconnected?", this.domElement.isConnected), !1;
    !this.isManagedExternally && !this.domElement.shadowRoot && this.domElement.prepend(this.renderer.domElement), N.Current = this, N.Current = this;
    for (let c = 0; c < this.new_scripts.length; c++) {
      const h = this.new_scripts[c];
      if (h.gameObject !== void 0 && h.gameObject !== null) {
        h.gameObject.userData === void 0 && (h.gameObject.userData = {}), h.gameObject.userData.components === void 0 && (h.gameObject.userData.components = []);
        const d = h.gameObject.userData.components;
        d.includes(h) || d.push(h);
      }
    }
    if (this.post_setup_callbacks)
      for (let c = 0; c < this.post_setup_callbacks.length; c++)
        N.Current = this, await this.post_setup_callbacks[c](this);
    if (!this._mainCamera) {
      N.Current = this;
      let c = null;
      ba(this.scene, (h) => {
        const d = h;
        if (d?.isCamera) {
          if (zl(d.gameObject), !d.activeAndEnabled) return;
          if (d.tag === "MainCamera")
            return c = d, !0;
          c = d;
        }
      }), c ? this.setCurrentCamera(c) : !he.dispatchCallback(ce.MissingCamera, this, { files: a }) && !this.mainCamera && !this.isManagedExternally && console.warn("Missing camera in main scene", this);
    }
    this.input.bindEvents(), N.Current = this, sd(this), this.physics.engine && (this.physics.engine?.step(0), this.physics.engine?.postStep()), !this.isManagedExternally && this.composer && this.mainCamera, this._needsUpdateSize = !0, this._stats && (this._stats.showPanel(0), this._stats.dom.style.position = "absolute", this.domElement.shadowRoot?.appendChild(this._stats.dom)), Xe && hp(this.scene, !0), this.targetFrameRate === void 0 ? (Xe && console.warn("No target framerate set, using default", N.DefaultTargetFrameRate), this.targetFrameRate = N._defaultTargetFramerate) : Xe && console.log("Target framerate set to", this.targetFrameRate), this._dispatchReadyAfterFrame = !0;
    const l = he.dispatchCallback(ce.ContextCreated, this, { files: a });
    if (l) {
      const c = this.domElement;
      "internalSetLoadingMessage" in c && typeof c.internalSetLoadingMessage == "function" && c?.internalSetLoadingMessage("finish loading"), await l;
    }
    return e?.abortSignal?.aborted ? !1 : (mn(this, ce.ContextCreated), Xe && console.log("Context Created...", this.renderer, this.renderer.domElement), this._isCreating = !1, !this.isManagedExternally && !e?.abortSignal?.aborted && this.restartRenderLoop(), !0);
  }
  async internalLoadInitialContent(e, t) {
    const i = new Array();
    if (t.files.length === 0) return i;
    const n = [...t.files], o = {
      name: "",
      progress: null,
      index: 0,
      count: n.length
    }, r = jn(), a = 0;
    for (let l = 0; l < n.length; l++) {
      if (t.abortSignal?.aborted) {
        Xe && console.log("Aborting loading because of abort signal");
        break;
      }
      if (e !== this._createId) {
        Xe && console.log("Aborting loading because create id changed", e, this._createId);
        break;
      }
      const c = n[l];
      t?.onLoadingStart?.call(this, l, c), Xe && console.log("Context Load " + c);
      const h = await r.loadSync(this, c, c, a, (d) => {
        t.abortSignal?.aborted || (o.name = c, o.progress = d, o.index = l, o.count = n.length, t.onLoadingProgress?.call(this, o));
      });
      t?.onLoadingFinished?.call(this, l, c, h ?? null), h ? i.push({
        src: c,
        file: h
      }) : console.warn("Could not load file: " + c);
    }
    if (e !== this._createId || t.abortSignal?.aborted) {
      Xe && console.log("Aborting loading because create id changed or abort signal was set", e, this._createId);
      for (const l of i)
        if (l && l.file)
          for (const c of l.file.scenes)
            Wi(c, !0, !0);
    } else {
      let l = !1;
      for (const c of i)
        c && c.file && (c.file.scene ? (l = !0, this.scene.add(c.file.scene)) : console.warn("No scene found in loaded file"));
      if (!l) {
        for (const c of i)
          if (c && c.file && "parser" in c.file) {
            let h = 0;
            if (!Array.isArray(c.file.parser.json.materials)) continue;
            for (let d = 0; d < c.file.parser.json.materials.length; d++) {
              const f = await c.file.parser.getDependency("material", d), p = new M();
              p.position.x = d * 1.1, p.position.y = h, this.scene.add(p), Oa.createPrimitive("ShaderBall", {
                parent: p,
                material: f
              });
            }
            h += 1;
          }
      }
    }
    return i;
  }
  /** Sets the animation loop.   
   * Can not be done while creating the context or when disposed 
   **/
  restartRenderLoop() {
    return this.renderer ? this._isCreating ? (console.warn("Can not start render loop while creating context"), !1) : (this.renderer.setAnimationLoop((e, t) => {
      this.isManagedExternally || this.update(e, t);
    }), !0) : (console.error("Can not start render loop without renderer"), !1);
  }
  _renderlooperrors = 0;
  /** Performs a full update step including script callbacks, rendering (unless isManagedExternally is set to false) and post render callbacks */
  update(e, t) {
    if (t === void 0 && (t = null), L() || Xe || G1())
      try {
        this.internalStep(e, t), this._renderlooperrors = 0;
      } catch (i) {
        this._renderlooperrors += 1, (L() || Xe) && (i instanceof Error || i instanceof TypeError) && Be("Caught unhandled exception during render-loop - see console for details.", Ui.Error), console.error("Frame #" + this.time.frame + `
`, i), this._renderlooperrors >= 3 && (console.warn("Stopping render loop due to error"), this.renderer.setAnimationLoop(null)), this.domElement.dispatchEvent(new CustomEvent("error", { detail: i }));
      }
    else
      this.internalStep(e, t);
  }
  /** Call to **manually** perform physics steps.   
   * By default the context uses the `physicsSteps` property to perform steps during the update loop   
   * If you just want to increase the accuracy of physics you can instead set the `physicsSteps` property to a higher value
   * */
  updatePhysics(e) {
    this.internalUpdatePhysics(e);
  }
  /**
   * Set a rect or dom element. The camera center will be moved to the center of the rect.  
   * This is useful if you have Needle Engine embedded in a HTML layout and while you want the webgl background to fill e.g. the whole screen you want to move the camera center to free space.  
   * For that you can simply pass in the rect or HMTL div that you want the camera to center on.
   */
  setCameraFocusRect(e) {
    this._focusRect = e;
  }
  get focusRect() {
    return this._focusRect;
  }
  _focusRect = null;
  _lastTimestamp = 0;
  _accumulatedTime = 0;
  _dispatchReadyAfterFrame = !1;
  // TODO: we need to skip after render callbacks if the render loop is managed externally. When changing this we also need to to update the r3f sample
  internalStep(e, t) {
    this.internalOnBeforeRender(e, t) !== !1 && (this.internalOnRender(), this.internalOnAfterRender());
  }
  internalOnBeforeRender(e, t) {
    this.renderer.info.autoReset = !!t, this.renderer.info.autoReset === !1 && this.renderer.info.reset(), this._needsVisibleUpdate = !0;
    const i = t !== null && this._xrFrame === null;
    if (this._xrFrame = t, i && this.domElement.dispatchEvent(new CustomEvent("xr-session-started", { detail: { context: this, session: this.xrSession, frame: t } })), this._currentFrameEvent = -1, this.isManagedExternally === !1 && this.isInXR === !1 && this.targetFrameRate !== void 0) {
      this._lastTimestamp === 0 && (this._lastTimestamp = e), this._accumulatedTime += (e - this._lastTimestamp) / 1e3, this._lastTimestamp = e;
      let n = this.targetFrameRate;
      if (typeof n == "object" && (n = n.value), this._accumulatedTime < 1 / (n + 1))
        return !1;
      this._accumulatedTime = 0;
    }
    if (this._stats?.begin(), N.Current = this, this.onHandlePaused()) return !1;
    for (N.Current = this, this.time.update(), fO && console.log("FPS", this.time.smoothedFps.toFixed(0)), sd(this), Rh(this.scene), d0(this), mn(
      this,
      -1
      /* Start */
    ); this._cameraStack.length > 0 && (!this.mainCameraComponent || this.mainCameraComponent.destroyed); ) {
      this._cameraStack.splice(this._cameraStack.length - 1, 1);
      const n = this._cameraStack[this._cameraStack.length - 1];
      this.setCurrentCamera(n);
    }
    if (this.pre_update_oneshot_callbacks) {
      for (const n in this.pre_update_oneshot_callbacks)
        this.pre_update_oneshot_callbacks[n]();
      this.pre_update_oneshot_callbacks.length = 0;
    }
    if (this.pre_update_callbacks)
      for (const n in this.pre_update_callbacks)
        this.pre_update_callbacks[n]();
    this._currentFrameEvent = 0;
    for (let n = 0; n < this.scripts_earlyUpdate.length; n++) {
      const o = this.scripts_earlyUpdate[n];
      o.activeAndEnabled && o.earlyUpdate !== void 0 && (N.Current = this, o.earlyUpdate());
    }
    this.executeCoroutines(
      0
      /* EarlyUpdate */
    ), mn(
      this,
      0
      /* EarlyUpdate */
    ), this._currentFrameEvent = 1;
    for (let n = 0; n < this.scripts_update.length; n++) {
      const o = this.scripts_update[n];
      o.activeAndEnabled && o.update !== void 0 && (N.Current = this, o.update());
    }
    this.executeCoroutines(
      1
      /* Update */
    ), mn(
      this,
      1
      /* Update */
    ), this._currentFrameEvent = 2;
    for (let n = 0; n < this.scripts_lateUpdate.length; n++) {
      const o = this.scripts_lateUpdate[n];
      o.activeAndEnabled && o.lateUpdate !== void 0 && (N.Current = this, o.lateUpdate());
    }
    if (this.executeCoroutines(
      2
      /* LateUpdate */
    ), mn(
      this,
      2
      /* LateUpdate */
    ), this.physicsSteps === void 0 && (this.physicsSteps = 1), this.physics.engine && this.physicsSteps > 0 && this.internalUpdatePhysics(this.physicsSteps), this.isVisibleToUser || this.runInBackground) {
      this._focusRect && this.mainCamera instanceof pe && SC(this._focusRect, this.time.deltaTime / 0.05, this.mainCamera, this.renderer), this._currentFrameEvent = 3;
      for (let n = 0; n < this.scripts_onBeforeRender.length; n++) {
        const o = this.scripts_onBeforeRender[n];
        o.activeAndEnabled && o.onBeforeRender !== void 0 && (N.Current = this, o.onBeforeRender(t));
      }
      if (this.executeCoroutines(
        3
        /* OnBeforeRender */
      ), mn(
        this,
        3
        /* OnBeforeRender */
      ), this._needsUpdateSize && this.updateSize(), this.pre_render_callbacks)
        for (const n in this.pre_render_callbacks)
          this.pre_render_callbacks[n](t);
    }
    return !0;
  }
  internalUpdatePhysics(e) {
    if (!this.physics.engine) return !1;
    const t = e, i = this.time.deltaTime / t;
    for (let n = 0; n < t; n++)
      this._currentFrameEvent = 9, this.executeCoroutines(
        9
        /* PrePhysicsStep */
      ), this.physics.engine.step(i), this._currentFrameEvent = 10, this.executeCoroutines(
        10
        /* PostPhysicsStep */
      );
    return this.physics.engine.postStep(), !0;
  }
  internalOnRender() {
    this.isManagedExternally || (Y1(this), this._currentFrameEvent = -1, uS.update(), this.renderNow(), this._currentFrameEvent = 4);
  }
  internalOnAfterRender() {
    if (this.isVisibleToUser || this.runInBackground) {
      for (let e = 0; e < this.scripts_onAfterRender.length; e++) {
        const t = this.scripts_onAfterRender[e];
        t.activeAndEnabled && t.onAfterRender !== void 0 && (N.Current = this, t.onAfterRender());
      }
      if (this.executeCoroutines(
        4
        /* OnAfterRender */
      ), mn(
        this,
        4
        /* OnAfterRender */
      ), this.post_render_callbacks)
        for (const e in this.post_render_callbacks)
          this.post_render_callbacks[e]();
    }
    this._currentFrameEvent = -1, this.connection.sendBufferedMessagesNow(), this._stats && (this._stats.end(), this.time.frameCount % 150 === 0 && console.log(this.renderer.info.render.calls + " DrawCalls", `
Render:`, { ...this.renderer.info.render }, `
Memory:`, { ...this.renderer.info.memory }, `
Target Framerate: ` + this.targetFrameRate)), this._dispatchReadyAfterFrame && (this._dispatchReadyAfterFrame = !1, this.domElement.dispatchEvent(new CustomEvent("ready")), he.dispatchCallback(ce.ContextFirstFrameRendered, this));
  }
  _tempClearColor = new se();
  _tempClearColor2 = new se();
  renderNow(e) {
    if (!e && (e = this.mainCamera, !e))
      return !1;
    if (this.handleRendererContextLost(), this._isRendering = !0, this.renderRequiredTextures(), this.renderer.toneMapping !== Gh && E0(), this.composer && !this.isInXR) {
      e && "setMainCamera" in this.composer && this.composer.passes[0]?.mainCamera != e && this.composer.setMainCamera(e);
      const t = this.renderer.getClearColor(this._tempClearColor), i = this.renderer.getClearAlpha();
      this._tempClearColor2.copy(t), this.renderer.setClearColor(t.convertSRGBToLinear(), this.renderer.getClearAlpha()), this.composer.render(this.time.deltaTime), this.renderer.setClearColor(this._tempClearColor2, i);
    } else e && (this.isInXR && X.isMacOS() && this.renderer.clearDepth(), this.renderer.render(this.scene, e));
    return this._isRendering = !1, !0;
  }
  _contextRestoreTries = 0;
  handleRendererContextLost() {
    this.time.frame % 10 && this.renderer.getContext().isContextLost() && this._contextRestoreTries++ < 100 && (console.warn("Attempting to recover WebGL context..."), this.renderer.forceContextRestore());
  }
  /** returns true if we should return out of the frame loop */
  _wasPaused = !1;
  onHandlePaused() {
    const e = this.evaluatePaused();
    if (this._wasPaused !== e) {
      uO && console.log("Paused?", e, "context:" + this.alias);
      for (let t = 0; t < this.scripts_pausedChanged.length; t++) {
        const i = this.scripts_pausedChanged[t];
        i.activeAndEnabled && i.onPausedChanged !== void 0 && (N.Current = this, i.onPausedChanged(e, this._wasPaused));
      }
    }
    return this._wasPaused = e, e;
  }
  evaluatePaused() {
    return this.isInXR ? !1 : this.isPaused ? !0 : this.runInBackground ? !1 : !this.isVisibleToUser;
  }
  renderRequiredTextures() {
    if (!this.mainCamera || !this._requireDepthTexture && !this._requireColorTexture) return;
    if (!this._renderTarget) {
      if (this._renderTarget = new Dn(this.domWidth, this.domHeight), this._requireDepthTexture) {
        const i = new ub(this.domWidth, this.domHeight);
        this._renderTarget.depthTexture = i;
      }
      this._requireColorTexture && (this._renderTarget.texture = new Te(), this._renderTarget.texture.generateMipmaps = !1, this._renderTarget.texture.minFilter = qh, this._renderTarget.texture.magFilter = qh, this._renderTarget.texture.format = Ld);
    }
    const e = this._renderTarget;
    e.texture && (e.texture.colorSpace = this.renderer.outputColorSpace);
    const t = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(e), this.renderer.render(this.scene, this.mainCamera), this.renderer.setRenderTarget(t);
  }
  executeCoroutines(e) {
    if (this.coroutines[e]) {
      const i = this.coroutines[e];
      for (let n = 0; n < i.length; n++)
        try {
          const o = i[n];
          if (!o.comp || o.comp.destroyed || !o.main || o.comp.enabled === !1) {
            pO && console.log("Removing coroutine", o.comp, o.comp.enabled), i.splice(n, 1), --n;
            continue;
          }
          const a = o.chained;
          if (a && a.length > 0) {
            const d = a[a.length - 1].next();
            if (d.done && a.pop(), t(d) && (o.chained || (o.chained = []), o.chained.push(d.value)), !d.done) continue;
          }
          const l = o.main.next();
          if (l.done === !0) {
            i.splice(n, 1), --n;
            continue;
          }
          const c = l.value;
          if (t(c)) {
            if (c.next().done) continue;
            o.chained || (o.chained = []), o.chained.push(c);
          } else if (c instanceof Promise) {
            const h = c;
            o.chained || (o.chained = []);
            const d = WP(h);
            o.chained?.push(d);
            continue;
          }
        } catch (o) {
          console.error(o);
        }
    }
    function t(i) {
      return !!(i && i.next && i.return);
    }
  }
}
const hi = w("debuglicense"), D0 = [];
let In = "basic";
hi && console.log("License Type: " + In);
function bs() {
  switch (In) {
    case "pro":
    case "enterprise":
      return !0;
  }
  return !1;
}
function Kd() {
  switch (In) {
    case "indie":
      return !0;
  }
  return !1;
}
function Nm() {
  switch (In) {
    case "edu":
      return !0;
  }
  return !1;
}
function vs() {
  return bs() || Kd() || Nm();
}
function mO(s) {
  if (bs() || Kd() || Nm())
    return s(!0);
  D0.push(s);
}
function nh(s) {
  for (const e of D0)
    try {
      e(s);
    } catch {
    }
}
he.registerCallback(ce.ContextRegistered, (s) => {
  _O(s.context), yO(s.context), setTimeout(() => vO(s.context), 2e3);
});
let xa, Tp = !1, Ep = "";
async function gO() {
  if (xa) return xa;
  if (In === "basic")
    try {
      const s = "https://engine.needle.tools/licensing/check?location=" + encodeURIComponent(window.location.href) + "&version=" + En + "&generator=" + encodeURIComponent(Sm), e = await fetch(s, {
        method: "GET"
      }).catch((t) => {
        hi && console.error("License check failed", t);
      });
      e?.status === 200 ? (Tp = !1, hi && console.log("License check succeeded"), In = "pro", nh(!0)) : e?.status === 403 ? (nh(!1), Tp = !0, Ep = await e.text()) : (nh(!1), hi && console.log("License check failed with status " + e?.status));
    } catch (s) {
      nh(!1), hi && console.error("License check failed", s);
    }
  else hi && console.log('Runtime license check is skipped because license is already applied as "' + In + '"');
}
xa = gO();
async function yO(s) {
  function e() {
    const n = document.createElement("div");
    n.className = "needle-forbidden", n.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: all;
        zIndex: 2147483647;
        line-height: 1.5;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        `;
    const o = n.style.cssText, r = document.createElement("div");
    n.appendChild(r), r.style.cssText = `
        position: absolute;
        left: 0;
        right: 0;
        top:0;
        bottom: 0;
        padding: 10%;
        color: white;
        font-size: 20px;
        font-family: sans-serif;
        text-align: center;
        pointer-events: all;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: rgba(0,0,0,.3);
        text-shadow: 0 0 2px black;
        `;
    const a = r.style.cssText, l = Ep?.length > 1 ? Ep : "This web application has been paused.<br/>You might be in violation of the Needle Engine terms of use.<br/>Please contact the Needle support if you think this is a mistake.";
    return r.innerHTML = l, setInterval(() => {
      r.innerHTML !== l && (r.innerHTML = l), r.parentNode !== n && n.appendChild(r), n.style.cssText !== o && (n.style.cssText = o), r.style.cssText !== a && (r.style.cssText = a);
    }, 500), n;
  }
  let t = e();
  const i = t.style.cssText;
  setInterval(() => {
    Tp === !0 && (t.style.cssText !== i && (t = e()), s.domElement.shadowRoot ? t.parentNode !== s.domElement.shadowRoot && s.domElement.shadowRoot?.appendChild(t) : t.parentNode != document.body && document.body.appendChild(t));
  }, 500);
}
async function _O(s) {
  try {
    if (!bs() && !Kd())
      return gf(s);
  } catch (e) {
    return hi && console.log("License check failed", e), gf(s);
  }
  hi && gf(s);
}
async function gf(s) {
  let e = !1;
  s.domElement.addEventListener("ready", () => e = !0), await xa?.catch(() => {
  }), !(bs() || Kd()) && (vs() === !1 && bO(), e ? Ap(s) : s.domElement.addEventListener("ready", () => {
    Ap(s);
  }));
}
function Ap(s) {
  const e = `
        position: relative;
        display: block;
        background-size: 20px;
        background-position: 10px 5px;
        background-repeat:no-repeat;
        background-image:url('${j0}');
        background-max-size: 40px;
        padding: 10px;
        padding-left: 30px;
    `;
  if (In === "edu")
    console.log("%c This project is supported by Needle for Education – https://needle.tools", e);
  else
    return;
  const t = document.createElement("div");
  t.className = "needle-non-commercial-use", t.innerHTML = "Made with Needle for Education", s.domElement.shadowRoot?.appendChild(t);
  let i = `
        position: absolute;
        font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
        font-size: 12px;
        color: rgb(100, 100, 100);
        /*mix-blend-mode: difference;*/
        background-color: transparent;
        z-index: 10000;

        cursor: pointer;
        user-select: none;
        opacity: 0;

        bottom: 6px;
        right: 12px;
        transform: translateY(0px);
        transition: all .5s ease-in-out 1s;
    `;
  t.style.cssText = i, t.addEventListener("click", () => {
    window.open("https://needle.tools", "_blank");
  });
  let n = t.style.cssText;
  setTimeout(() => {
    i = i.replace("opacity: 0", "opacity: 1"), i = i.replace("transform: translateY(10px)", "transform: translateY(0)"), t.style.cssText = i, n = t.style.cssText;
  }, 100);
  const o = setInterval(() => {
    const r = s.domElement.shadowRoot || s.domElement;
    t.parentNode !== r && r.appendChild(t), n != t.style.cssText && (t.style.cssText = i, n = t.style.cssText);
  }, 1e3);
  Nm() && setTimeout(() => {
    clearInterval(o), t?.remove(), setTimeout(() => {
      s.domElement.parentNode && Ap(s);
    }, 1e3 * 60 * 5);
  }, 2e4);
}
const j0 = "data:image/webp;base64,UklGRrABAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSKEAAAARN6CmbSM4WR7vdARON11EBDq3fLiNbVtVzpMCPlKAEzsx0Y/x+Ovuv4dn0EFE/ydAvz6YggXzgh5sVgXM/zOC/4sii7qgGvB5N7hmuQYwkvazWAu1JPW41FXSHq6pnaQWvqYH18Fc0j1hO/BFTtIeSBlJi5w6qIIO7IOrwhFsB2Yxukif0FTRLpXswHR8MxbslKe9VZsn/Ub5C7YFOpqSTABWUDgg6AAAAFAGAJ0BKiAAIAA+7VyoTqmkpCI3+qgBMB2JbACdMt69DwMIQBLhkTO6XwY00UEDK6cNIDnuNibPf0EgAP7Y1myuiQHLDsF/0h5unrGh6WAbv7aegg2ZMd3uRKfT/3SJztcaujYfTvMXspfCTmYcoO6a+vhC3ss4M8uM58t4siiu59I4aOl59e9Sr6xoxYlHf2v+NnBNpJYeJf8jABQAId/PXuBkLEFkiCucgSGEcfhvajql/j3reCGl0M5/9gQWy7ayNPs+wlvIxFnNfSlfuND4CZOCyxOHhRqOmHN4ULHo3tCSrUNvgAA=";
let t_ = 0;
async function bO(s) {
  const e = Date.now();
  if (e - t_ < 2e3) return;
  t_ = e;
  const t = `
        position: relative;
        display: block;
        font-size: 18px;
        background-size: 20px;
        background-position: 10px 5px;
        background-repeat:no-repeat;
        background-image:url('${j0}');
        background-max-size: 40px;
        margin-bottom: 5px;
        margin-top: .3em;
        margin-bottom: .5em;
        padding: .2em;
        padding-left: 25px;
        border-radius: .5em;
        border: 2px solid rgba(160,160,160,.3);
    `, n = `Needle Engine — No license active, commercial use is not allowed. Visit https://needle.tools/pricing for more information and licensing options! v${En}`;
  N.Current?.xr ? console.log(n) : console.log("%c " + n, t);
}
async function vO(s) {
  if (window.crossOriginIsolated) return;
  if (In === "pro") {
    const t = s?.domElement?.getAttribute("no-telemetry");
    if (t === "" || t === "true" || t === "1") {
      hi && console.debug("Telemetry is disabled");
      return;
    }
    hi && console.debug("Telemetry attribute: " + t);
  }
  try {
    const t = "https://needle-engine-analytics-v2-r26roub2hq-lz.a.run.app";
    if (t) {
      const i = window.location.href.split("?")[0];
      let n = "api/v2/new/request";
      t.endsWith("/") || (n = "/" + n);
      const o = In, r = `${t}${n}`;
      hi && console.debug("Sending beacon");
      const a = {
        license: o,
        url: i,
        hostname: window.location.hostname,
        pathname: window.location.pathname,
        // search: window.location.search,
        // hash: window.location.hash,
        version: En,
        generator: Sm,
        build_time: Gb,
        public_key: bl
      }, l = navigator.sendBeacon?.(r, JSON.stringify(a));
      hi && console.debug("Sent beacon: " + l);
    }
  } catch (t) {
    hi && console.log("Failed to send non-commercial usage message to analytics backend", t);
  }
}
function wO(s, e) {
  return ks(s, ce.ContextCreated, e), () => po(s, ce.ContextCreated);
}
function $I(s, e) {
  return ks(s, ce.ContextClearing, e), () => po(s, ce.ContextClearing);
}
function WI(s, e) {
  return ks(s, ce.ContextDestroying, e), () => po(s, ce.ContextDestroying);
}
function B0(s, e) {
  return ks(s, xe.Start, e), () => po(s, xe.Start);
}
function xO(s, e) {
  return ks(s, xe.Update, e), () => po(s, xe.Update);
}
function VI(s, e) {
  return ks(s, xe.OnBeforeRender, e), () => po(s, xe.OnBeforeRender);
}
function HI(s, e) {
  return ks(s, xe.OnAfterRender, e), () => po(s, xe.OnAfterRender);
}
const SO = w("debugdecoders");
let yf = null;
function F0() {
  if (!yf) {
    const s = mm(null);
    yf = { dracoLoader: s.dracoLoader, ktx2Loader: s.ktx2Loader, meshoptDecoder: s.meshoptDecoder };
  }
  return yf;
}
function i_(s) {
  s !== void 0 && typeof s == "string" && aS(s);
}
function n_(s) {
  if (s !== void 0 && typeof s == "string" && s !== "js") {
    const e = F0();
    SO && console.log("Setting draco decoder type to", s), e.dracoLoader.setDecoderConfig({ type: s });
  }
}
function s_(s) {
  s !== void 0 && typeof s == "string" && rS(s);
}
function $m(s, e) {
  const t = F0();
  return e.renderer ? t.ktx2Loader.detectSupport(e.renderer) : console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures will probably fail"), sS(s), s.dracoLoader || s.setDRACOLoader(t.dracoLoader), s.ktx2Loader || s.setKTX2Loader(t.ktx2Loader), s.meshoptDecoder || s.setMeshoptDecoder(t.meshoptDecoder), oS(s, {
    progressive: !0
  }), s;
}
const Ma = function(s) {
  return u(s);
}, u = function(s) {
  if (s === void 0 && (s = null), !Array.isArray(s))
    s = o_(s);
  else
    for (let e = 0; e < s.length; e++) {
      const t = s[e];
      s[e] = o_(t);
    }
  return function(e, t) {
    if (!e) {
      console.error("Found @serializable decorator without a target");
      return;
    }
    typeof t != "string" && (t = t.name), Object.getOwnPropertyDescriptor(e, "$serializedTypes") || (e.$serializedTypes = {});
    const i = e.$serializedTypes = e.$serializedTypes || {};
    i[t] = s;
  };
};
function o_(s) {
  switch (s?.prototype?.constructor?.name) {
    case "Number":
    case "String":
    case "Boolean":
      return null;
  }
  return s;
}
const ro = w("debughotreload");
let ac = !1;
const $l = /* @__PURE__ */ new Map();
function GI() {
  return ac;
}
function r_() {
  return globalThis.NEEDLE_HOT_RELOAD_ENABLED === !0;
}
function CO(s) {
  if (ac) {
    ro && console.warn("[Needle Engine] Hot reloading is in progress, not registering instance", s);
    return;
  }
  ro && console.log("[Needle Engine] Registering hot reload instance", s);
  const t = s.constructor.name;
  $l.has(t) ? $l.get(t)?.push(s) : $l.set(t, [s]);
}
function PO(s) {
  if (ac) {
    ro && console.warn("[Needle Engine] Hot reloading is in progress, not unregistering instance", s);
    return;
  }
  ro && console.log("[Needle Engine] Unregistering hot reload instance", s);
  const t = s.constructor.name, i = $l.get(t);
  if (!i) return;
  const n = i.indexOf(s);
  n !== -1 && i.splice(n, 1);
}
let a_ = !1;
function OO() {
  if (ro || a_) return;
  a_ = !0;
  const s = console.error;
  console.error = (...e) => {
    if (e.length) {
      const t = e[0];
      if (typeof t == "string" && t.includes("[hmr] Failed to reload ")) {
        console.log("[Needle Engine] Hot reloading failed"), window.location.reload();
        return;
      }
    }
    s.apply(console, e);
  };
}
function qI(s) {
  ro && console.log("[HMR] Apply changes", s, Object.keys(s)), OO();
  for (const e of Object.keys(s))
    try {
      ac = !0;
      const t = P.get(e);
      if (!t) {
        ro && console.log("[HMR] Type not found: " + e);
        continue;
      }
      const i = s[e], n = $l.get(i.name);
      let o = "[Needle Engine] Updating type: " + e;
      const r = n?.length ?? -1;
      r > 0 ? o += " x" + r : o += " (No instances registered)", console.log(o);
      const a = Object.getOwnPropertyNames(t.prototype), l = Object.getOwnPropertyDescriptors(i.prototype);
      for (const c in l)
        l[c].writable && (t.prototype[c] = s[e].prototype[c]);
      for (const c of a)
        l[c] || delete t.prototype[c];
      if (n) {
        const c = new i(), h = Object.getOwnPropertyDescriptors(c);
        for (const d of n) {
          const f = d, p = f.isComponent === !0, g = p ? f.activeAndEnabled : !0, _ = p ? f.context : void 0;
          try {
            if (p && _ && cs(f, _), p && g && (f.enabled = !1), d.onBeforeHotReloadFields && d.onBeforeHotReloadFields() === !1)
              continue;
            for (const m in h)
              if (h[m].writable) {
                if (d[m] === void 0)
                  d[m] = c[m];
                else if (typeof d[m] == "function" && !d[m].prototype) {
                  const y = d[m], x = y.name, I = "bound ";
                  if (x === I) continue;
                  const O = y.name.substring(I.length), k = i.prototype[O];
                  k && (d[m] = k.bind(d));
                }
              }
            d.onAfterHotReloadFields && d.onAfterHotReloadFields();
          } finally {
            p && _ && Am(f, _), p && g && (f.enabled = !0);
          }
        }
      }
    } catch (t) {
      if (ro) console.error(t);
      else return !1;
    } finally {
      ac = !1, Go(Ui.Log, "Script changes applied (HMR)");
    }
  return !0;
}
class S extends M {
  /**
   * Unique identifier for this GameObject
   */
  guid;
  /**
   * Checks if a GameObject has been destroyed
   * @param go The GameObject to check
   * @returns True if the GameObject has been destroyed
   */
  static isDestroyed(e) {
    return _a(e);
  }
  /**
   * Sets the active state of a GameObject
   * @param go The GameObject to modify
   * @param active Whether the GameObject should be active
   * @param processStart Whether to process the start callbacks if being activated
   */
  static setActive(e, t, i = !0) {
    e && (Ih(e, t), Rh(e), t && i && d0(N.Current, e));
  }
  /**
   * Checks if the GameObject itself is active (same as go.visible)
   * @param go The GameObject to check
   * @returns True if the GameObject is active
   */
  static isActiveSelf(e) {
    return yc(e);
  }
  /**
   * Checks if the GameObject is active in the hierarchy (e.g. if any parent is invisible or not in the scene it will be false)
   * @param go The GameObject to check
   * @returns True if the GameObject is active in the hierarchy
   */
  static isActiveInHierarchy(e) {
    return AP(e);
  }
  /**
   * Marks a GameObject to be rendered using instancing
   * @param go The GameObject to mark
   * @param instanced Whether the GameObject should use instanced rendering
   */
  static markAsInstancedRendered(e, t) {
    IP(e, t);
  }
  /**
   * Checks if a GameObject is using instanced rendering
   * @param instance The GameObject to check
   * @returns True if the GameObject is using instanced rendering
   */
  static isUsingInstancing(e) {
    return Bm(e);
  }
  /**
   * Executes a callback for all components of the provided type on the provided object and its children
   * @param instance Object to run the method on
   * @param cb Callback to run on each component, "return undefined;" to continue and "return <anything>;" to break the loop
   * @param recursive If true, the method will be run on all children as well
   * @returns The last return value of the callback
   */
  static foreachComponent(e, t, i = !0) {
    return ba(e, t, i);
  }
  /**
   * Creates a new instance of the provided object that will be replicated to all connected clients
   * @param instance Object to instantiate
   * @param opts Options for the instantiation
   * @returns The newly created instance or null if creation failed
   */
  static instantiateSynced(e, t) {
    return e ? m0(e, t) : null;
  }
  static instantiate(e, t = null) {
    return "isAssetReference" in e, va(e, t);
  }
  /**
   * Destroys an object on all connected clients (if in a networked session)
   * @param instance Object to destroy
   * @param context Optional context to use
   * @param recursive If true, all children will be destroyed as well
   */
  static destroySynced(e, t, i = !0) {
    if (!e) return;
    const n = e;
    t = t ?? N.Current, Hd(n, t.connection, i);
  }
  /**
   * Destroys an object
   * @param instance Object to destroy
   * @param recursive If true, all children will be destroyed as well. Default: true
   */
  static destroy(e, t = !0) {
    return Wi(e, t);
  }
  /**
   * Adds an object to parent and ensures all components are properly registered
   * @param instance Object to add
   * @param parent Parent to add the object to
   * @param context Optional context to use
   */
  static add(e, t, i) {
    if (!(!e || !t)) {
      if (e === t) {
        console.warn("Can not add object to self", e);
        return;
      }
      i || (i = N.Current), t.add(e), Ih(e, !0), Rh(e), i ? S.foreachComponent(e, (n) => {
        Am(n, i), !n.__internalDidAwakeAndStart && i.new_script_start.includes(n) === !1 && i.new_script_start.push(n);
      }, !0) : console.warn("Missing context");
    }
  }
  /**
   * Removes the object from its parent and deactivates all of its components
   * @param instance Object to remove
   */
  static remove(e) {
    e && (e.parent?.remove(e), Ih(e, !1), Rh(e), S.foreachComponent(e, (t) => {
      q1(t);
    }, !0));
  }
  /**
   * Invokes a method on all components including children (if a method with that name exists)
   * @param go GameObject to invoke the method on
   * @param functionName Name of the method to invoke
   * @param args Arguments to pass to the method
   */
  static invokeOnChildren(e, t, ...i) {
    this.invoke(e, t, !0, i);
  }
  /**
   * Invokes a method on all components that have a method matching the provided name
   * @param go GameObject to invoke the method on
   * @param functionName Name of the method to invoke
   * @param children Whether to invoke on children as well
   * @param args Arguments to pass to the method
   */
  static invoke(e, t, i = !1, ...n) {
    e && this.foreachComponent(e, (o) => {
      const r = o[t];
      r && typeof r == "function" && r?.call(o, ...n);
    }, i);
  }
  /** @deprecated use `addComponent` */
  // eslint-disable-next-line deprecation/deprecation
  static addNewComponent(e, t, i, n = !0) {
    return An(e, t, i, { callAwake: n });
  }
  /**
   * Adds a new component (or moves an existing component) to the provided object
   * @param go Object to add the component to
   * @param instanceOrType If an instance is provided it will be moved to the new object, if a type is provided a new instance will be created
   * @param init Optional init object to initialize the component with
   * @param opts Optional options for adding the component
   * @returns The added or moved component
   */
  static addComponent(e, t, i, n) {
    return An(e, t, i, n);
  }
  /**
   * Moves a component to a new object
   * @param go GameObject to move the component to
   * @param instance Component to move
   * @returns The moved component
   */
  static moveComponent(e, t) {
    return An(e, t);
  }
  /**
   * Removes a component from its object
   * @param instance Component to remove
   * @returns The removed component
   */
  static removeComponent(e) {
    return S0(e.gameObject, e), e;
  }
  /**
   * Gets or adds a component of the specified type
   * @param go GameObject to get or add the component to
   * @param typeName Constructor of the component type
   * @returns The existing or newly added component
   */
  static getOrAddComponent(e, t) {
    return Gd(e, t);
  }
  /**
   * Gets a component on the provided object
   * @param go GameObject to get the component from
   * @param typeName Constructor of the component type
   * @returns The component if found, otherwise null
   */
  static getComponent(e, t) {
    return e === null ? null : ka(e, t);
  }
  /**
   * Gets all components of the specified type on the provided object
   * @param go GameObject to get the components from
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponents(e, t, i = null) {
    return e === null ? i ?? [] : qd(e, t, i);
  }
  /**
   * Finds an object or component by its unique identifier
   * @param guid Unique identifier to search for
   * @param hierarchy Root object to search in
   * @returns The found GameObject or Component, or null/undefined if not found
   */
  static findByGuid(e, t) {
    return O0(e, t);
  }
  /**
   * Finds the first object of the specified component type in the scene
   * @param typeName Constructor of the component type
   * @param context Context or root object to search in
   * @param includeInactive Whether to include inactive objects in the search
   * @returns The first matching component if found, otherwise null
   */
  static findObjectOfType(e, t, i = !0) {
    return Qd(e, t ?? N.Current, i);
  }
  /**
   * Finds all objects of the specified component type in the scene
   * @param typeName Constructor of the component type
   * @param context Context or root object to search in
   * @returns Array of matching components
   */
  static findObjectsOfType(e, t) {
    const i = [];
    return EP(e, i, t), i;
  }
  /**
   * Gets a component of the specified type in the gameObject's children hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @returns The first matching component if found, otherwise null
   */
  static getComponentInChildren(e, t) {
    return Xd(e, t);
  }
  /**
   * Gets all components of the specified type in the gameObject's children hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponentsInChildren(e, t, i = null) {
    return gc(e, t, i ?? void 0);
  }
  /**
   * Gets a component of the specified type in the gameObject's parent hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @returns The first matching component if found, otherwise null
   */
  static getComponentInParent(e, t) {
    return ad(e, t);
  }
  /**
   * Gets all components of the specified type in the gameObject's parent hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponentsInParent(e, t, i = null) {
    return Dm(e, t, i);
  }
  /**
   * Gets all components on the gameObject
   * @param go GameObject to get components from
   * @returns Array of all components
   */
  static getAllComponents(e) {
    const t = e.userData?.components;
    return t ? [...t] : [];
  }
  /**
   * Iterates through all components on the gameObject
   * @param go GameObject to iterate components on
   * @returns Generator yielding each component
   */
  static *iterateComponents(e) {
    const t = e?.userData?.components;
    if (t && Array.isArray(t))
      for (let i = 0; i < t.length; i++)
        yield t[i];
  }
}
class T {
  /** 
   * Indicates whether this object is a component
   * @internal 
   */
  get isComponent() {
    return !0;
  }
  __context;
  /**
   * The context this component belongs to, providing access to the runtime environment
   * including physics, timing utilities, camera, and scene
   */
  get context() {
    return this.__context ?? N.Current;
  }
  set context(e) {
    this.__context = e;
  }
  /**
   * Shorthand accessor for the current scene from the context
   * @returns The scene this component belongs to
   */
  get scene() {
    return this.context.scene;
  }
  /**
   * The layer value of the GameObject this component is attached to
   * Used for visibility and physics filtering
   */
  get layer() {
    return this.gameObject?.userData?.layer;
  }
  /**
   * The name of the GameObject this component is attached to
   * Used for debugging and finding objects
   */
  get name() {
    return this.gameObject?.name ? this.gameObject.name : this.gameObject?.userData.name;
  }
  __name;
  set name(e) {
    this.gameObject ? (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.name = e, this.__name = e) : this.__name = e;
  }
  /**
   * The tag of the GameObject this component is attached to
   * Used for categorizing objects and efficient lookup
   */
  get tag() {
    return this.gameObject?.userData.tag;
  }
  set tag(e) {
    this.gameObject && (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.tag = e);
  }
  /**
   * Indicates whether the GameObject is marked as static
   * Static objects typically don't move and can be optimized by the engine
   */
  get static() {
    return this.gameObject?.userData.static;
  }
  set static(e) {
    this.gameObject && (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.static = e);
  }
  // get hideFlags(): HideFlags {
  //     return this.gameObject?.hideFlags;
  // }
  /**
   * Checks if this component is currently active (enabled and part of an active GameObject hierarchy)
   * Components that are inactive won't receive lifecycle method calls
   * @returns True if the component is enabled and all parent GameObjects are active
   */
  get activeAndEnabled() {
    return !(this.destroyed || this.__isEnabled === !1 || !this.__isActiveInHierarchy);
  }
  get __isActive() {
    return this.gameObject.visible;
  }
  get __isActiveInHierarchy() {
    if (!this.gameObject) return !1;
    const e = this.gameObject[oo];
    return e === void 0 ? !0 : e;
  }
  set __isActiveInHierarchy(e) {
    this.gameObject && (this.gameObject[oo] = e);
  }
  /**
   * Reference to the GameObject this component is attached to
   * This is a three.js Object3D with additional GameObject functionality
   */
  gameObject;
  /**
   * Unique identifier for this component instance,
   * used for finding and tracking components
   */
  guid = "invalid";
  /**
   * Identifier for the source asset that created this component.
   * For example, URL to the glTF file this component was loaded from
   */
  sourceId;
  /**
   * Called once when the component becomes active for the first time.
   * This is the first lifecycle callback to be invoked
   */
  awake() {
  }
  /**
   * Called every time the component becomes enabled or active in the hierarchy.
   * Invoked after {@link awake} and before {@link start}.
   */
  onEnable() {
  }
  /**
   * Called every time the component becomes disabled or inactive in the hierarchy.
   * Invoked when the component or any parent GameObject becomes invisible
   */
  onDisable() {
  }
  /**
   * Called when the component is destroyed.
   * Use for cleanup operations like removing event listeners
   */
  onDestroy() {
    this.__destroyed = !0;
  }
  /**
   * Starts a coroutine that can yield to wait for events.
   * Coroutines allow for time-based sequencing of operations without blocking.
   * Coroutines are based on generator functions, a JavaScript language feature. 
   * 
   * @param routine Generator function to start
   * @param evt Event to register the coroutine for (default: FrameEvent.Update)
   * @returns The generator function that can be used to stop the coroutine
   * @example
   * Time-based sequencing of operations
   * ```ts
   * *myCoroutine() {
   *   yield WaitForSeconds(1); // wait for 1 second
   *   yield WaitForFrames(10); // wait for 10 frames
   *   yield new Promise(resolve => setTimeout(resolve, 1000)); // wait for a promise to resolve
   * }
   * ```
   * @example
   * Coroutine that logs a message every 5 frames
   * ```ts
   * onEnable() {
   *   this.startCoroutine(this.myCoroutine());
   * }
   * private *myCoroutine() {
   *   while(this.activeAndEnabled) {
   *     console.log("Hello World", this.context.time.frame);
   *     // wait for 5 frames
   *     for(let i = 0; i < 5; i++) yield;
   *   }
   * }
   * ```
   */
  startCoroutine(e, t = xe.Update) {
    return this.context.registerCoroutineUpdate(this, e, t);
  }
  /**
   * Stops a coroutine that was previously started with startCoroutine
   * @param routine The routine to be stopped
   * @param evt The frame event the routine was registered with
   */
  stopCoroutine(e, t = xe.Update) {
    this.context.unregisterCoroutineUpdate(e, t);
  }
  /**
   * Checks if this component has been destroyed
   * @returns True if the component or its GameObject has been destroyed
   */
  get destroyed() {
    return this.__destroyed;
  }
  /**
   * Destroys this component and removes it from its GameObject
   * After destruction, the component will no longer receive lifecycle callbacks
   */
  destroy() {
    this.__destroyed || this.__internalDestroy();
  }
  /** @internal */
  __didAwake = !1;
  /** @internal */
  __didStart = !1;
  /** @internal */
  __didEnable = !1;
  /** @internal */
  __isEnabled = void 0;
  /** @internal */
  __destroyed = !1;
  /** @internal */
  get __internalDidAwakeAndStart() {
    return this.__didAwake && this.__didStart;
  }
  /** @internal */
  constructor(e) {
    this.__didAwake = !1, this.__didStart = !1, this.__didEnable = !1, this.__isEnabled = void 0, this.__destroyed = !1, this._internalInit(e), r_() && CO(this);
  }
  /** @internal */
  __internalNewInstanceCreated(e) {
    return this.__didAwake = !1, this.__didStart = !1, this.__didEnable = !1, this.__isEnabled = void 0, this.__destroyed = !1, this._internalInit(e), this;
  }
  /**
   * Initializes component properties from an initialization object
   * @param init Object with properties to copy to this component
   * @internal
   */
  _internalInit(e) {
    if (typeof e == "object")
      for (const t of Object.keys(e)) {
        const i = e[t];
        typeof i != "function" && (this[t] = i);
      }
  }
  /** @internal */
  __internalAwake() {
    this.__didAwake || (this.__didAwake = !0, this.awake());
  }
  /** @internal */
  __internalStart() {
    this.__didStart || (this.__didStart = !0, this.start && this.start());
  }
  /** @internal */
  __internalEnable(e) {
    return this.__destroyed ? (L() && console.warn("[Needle Engine Dev] Trying to enable destroyed component"), !1) : this.__didAwake ? this.__didEnable ? (e !== !0 && (this.__isEnabled = !0), !1) : (this.__didEnable = !0, this.__isEnabled = !0, this.onEnable(), !0) : !1;
  }
  /** @internal */
  __internalDisable(e) {
    if (this.__didAwake) {
      if (!this.__didEnable) {
        e !== !0 && (this.__isEnabled = !1);
        return;
      }
      this.__didEnable = !1, this.__isEnabled = !1, this.onDisable();
    }
  }
  /** @internal */
  __internalDestroy() {
    this.__destroyed || (this.__destroyed = !0, this.__didAwake && (this.onDestroy?.call(this), this.dispatchEvent(new CustomEvent("destroyed", { detail: this }))), TP(this), r_() && PO(this));
  }
  /**
   * Controls whether this component is enabled
   * Disabled components don't receive lifecycle callbacks
   */
  get enabled() {
    return typeof this.__isEnabled == "boolean" ? this.__isEnabled : !0;
  }
  set enabled(e) {
    if (this.__destroyed) {
      L() && console.warn(`[Needle Engine Dev] Trying to ${e ? "enable" : "disable"} destroyed component`);
      return;
    }
    if (typeof e == "number" && (e >= 0.5 ? e = !0 : e = !1), !this.__didAwake) {
      this.__isEnabled = e;
      return;
    }
    e ? this.__internalEnable() : this.__internalDisable();
  }
  /**
   * Gets the position of this component's GameObject in world space.    
   * Note: This is equivalent to calling `this.gameObject.worldPosition`
   */
  get worldPosition() {
    return Z(this.gameObject);
  }
  /**
   * Sets the position of this component's GameObject in world space
   * @param val The world position vector to set
   */
  set worldPosition(e) {
    ut(this.gameObject, e);
  }
  /**
   * Sets the position of this component's GameObject in world space using individual coordinates
   * @param x X-coordinate in world space
   * @param y Y-coordinate in world space
   * @param z Z-coordinate in world space
   */
  setWorldPosition(e, t, i) {
    ua(this.gameObject, e, t, i);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as a quaternion
   * Note: This is equivalent to calling `this.gameObject.worldQuaternion`
   */
  get worldQuaternion() {
    return be(this.gameObject);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using a quaternion
   * @param val The world rotation quaternion to set
   */
  set worldQuaternion(e) {
    an(this.gameObject, e);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using quaternion components
   * @param x X component of the quaternion
   * @param y Y component of the quaternion
   * @param z Z component of the quaternion
   * @param w W component of the quaternion
   */
  setWorldQuaternion(e, t, i, n) {
    Bb(this.gameObject, e, t, i, n);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as Euler angles (in radians)
   */
  get worldEuler() {
    return Fb(this.gameObject);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using Euler angles (in radians)
   * @param val The world rotation Euler angles to set
   */
  set worldEuler(e) {
    zb(this.gameObject, e);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as Euler angles (in degrees)  
   * Note: This is equivalent to calling `this.gameObject.worldRotation`
   */
  get worldRotation() {
    return this.gameObject.worldRotation;
  }
  /**
   * Sets the rotation of this component's GameObject in world space using Euler angles (in degrees)
   * @param val The world rotation vector to set (in degrees)
   */
  set worldRotation(e) {
    this.setWorldRotation(e.x, e.y, e.z, !0);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using individual Euler angles
   * @param x X-axis rotation
   * @param y Y-axis rotation
   * @param z Z-axis rotation
   * @param degrees Whether the values are in degrees (true) or radians (false)
   */
  setWorldRotation(e, t, i, n = !0) {
    $d(this.gameObject, e, t, i, n);
  }
  static _forward = new b();
  /**
   * Gets the forward direction vector (0,0,-1) of this component's GameObject in world space
   */
  get forward() {
    return T._forward.set(0, 0, -1).applyQuaternion(this.worldQuaternion);
  }
  static _right = new b();
  /**
   * Gets the right direction vector (1,0,0) of this component's GameObject in world space
   */
  get right() {
    return T._right.set(1, 0, 0).applyQuaternion(this.worldQuaternion);
  }
  static _up = new b();
  /**
   * Gets the up direction vector (0,1,0) of this component's GameObject in world space
   */
  get up() {
    return T._up.set(0, 1, 0).applyQuaternion(this.worldQuaternion);
  }
  // EventTarget implementation:
  /** 
   * Storage for event listeners registered to this component
   * @private
   */
  _eventListeners = /* @__PURE__ */ new Map();
  /**
   * Registers an event listener for the specified event type
   * @param type The event type to listen for
   * @param listener The callback function to execute when the event occurs
   */
  addEventListener(e, t) {
    this._eventListeners[e] = this._eventListeners[e] || [], this._eventListeners[e].push(t);
  }
  /**
   * Removes a previously registered event listener
   * @param type The event type the listener was registered for
   * @param listener The callback function to remove
   */
  removeEventListener(e, t) {
    if (!this._eventListeners[e]) return;
    const i = this._eventListeners[e].indexOf(t);
    i >= 0 && this._eventListeners[e].splice(i, 1);
  }
  /**
   * Dispatches an event to all registered listeners
   * @param evt The event object to dispatch
   * @returns Always returns false (standard implementation of EventTarget)
   */
  dispatchEvent(e) {
    if (!e || !this._eventListeners[e.type]) return !1;
    const t = this._eventListeners[e.type];
    for (let i = 0; i < t.length; i++)
      t[i](e);
    return !1;
  }
}
const XI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Behaviour: T,
  Component: T,
  GameObject: S
}, Symbol.toStringTag, { value: "Module" }));
var kO = Object.defineProperty, z0 = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && kO(e, t, n), n;
};
class Zd extends T {
  from;
  to;
  width = 0;
  centered = !0;
  _centerPos;
  awake() {
    this._centerPos = new b();
  }
  update() {
    if (!this.from || !this.to) return;
    const e = Z(this.from).clone(), t = Z(this.to).clone(), i = e.distanceTo(t);
    this._centerPos.copy(e), this._centerPos.add(t), this._centerPos.multiplyScalar(0.5), ut(this.gameObject, this.centered ? this._centerPos : e), this.gameObject.lookAt(Z(this.to).clone()), this.gameObject.scale.set(this.width, this.width, i);
  }
}
z0([
  u(S)
], Zd.prototype, "from");
z0([
  u(S)
], Zd.prototype, "to");
var MO = Object.defineProperty, RO = Object.getOwnPropertyDescriptor, yr = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? RO(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && MO(e, t, n), n;
};
const Bs = w("debuganimation");
let U0 = class {
  x;
  y;
};
class bi extends T {
  get isAnimationComponent() {
    return !0;
  }
  addClip(e) {
    this.animations || (this.animations = []), this.animations.includes(e) || this.animations.push(e);
  }
  playAutomatically = !0;
  randomStartTime = !0;
  minMaxSpeed;
  minMaxOffsetNormalized;
  loop = !0;
  clampWhenFinished = !1;
  /**
   * The time in seconds of the first running animation action
   * @default 0
   */
  get time() {
    if (this.actions) {
      for (const e of this.actions)
        if (e.isRunning()) return e.time;
    }
    return 0;
  }
  set time(e) {
    if (this.actions)
      for (const t of this.actions)
        t.time = e;
  }
  _tempAnimationClipBeforeGameObjectExisted = null;
  /**
   * Get the first animation clip in the animations array
   */
  get clip() {
    return this.animations?.length ? this.animations[0] : null;
  }
  /**
   * Set the first animation clip in the animations array
   */
  set clip(e) {
    if (!this.__didAwake) {
      Bs && console.warn("Assign clip during serialization", e), this._tempAnimationClipBeforeGameObjectExisted = e;
      return;
    }
    e && (this.gameObject.animations || (this.gameObject.animations = []), !this.animations.includes(e) && (this.animations.length > 0 ? this.animations.splice(0, 0, e) : this.animations.push(e)));
  }
  set clips(e) {
    this.animations = e;
  }
  _tempAnimationsArray;
  set animations(e) {
    e == null || !Array.isArray(e) || (this.gameObject ? this.gameObject.animations = e : this._tempAnimationsArray = e);
  }
  get animations() {
    return this.gameObject.animations || this._tempAnimationsArray || [];
  }
  mixer = void 0;
  /**
   * The animation actions
   */
  get actions() {
    return this._actions;
  }
  set actions(e) {
    this._actions = e;
  }
  _actions;
  _handles;
  /** @internal */
  awake() {
    this.mixer = void 0, Bs && console.log("Animation Awake", this.name, this), this._tempAnimationsArray && (this.animations = this._tempAnimationsArray, this._tempAnimationsArray = void 0), this._tempAnimationClipBeforeGameObjectExisted && (this.clip = this._tempAnimationClipBeforeGameObjectExisted, this._tempAnimationClipBeforeGameObjectExisted = null), this.actions = [], this._handles = [];
  }
  /** @internal */
  onEnable() {
    if (this.playAutomatically && this.animations?.length > 0) {
      const e = Math.floor(Math.random() * this.animations.length), t = this.animations[e];
      this.play(e, {
        exclusive: !0,
        fadeDuration: 0,
        startTime: this.randomStartTime ? Math.random() * t.duration : 0,
        loop: this.loop,
        clampWhenFinished: this.clampWhenFinished
      });
    }
  }
  /** @internal */
  update() {
    this.mixer && (this.mixer.update(this.context.time.deltaTime), this._handles.forEach((e) => e.update()));
  }
  /** @internal */
  onDisable() {
    this.mixer && this.mixer.stopAllAction();
  }
  /** @internal */
  onDestroy() {
    this.context.animations.unregisterAnimationMixer(this.mixer);
  }
  /** Get an animation action by the animation clip name */
  getAction(e) {
    return this.actions?.find((t) => t.getClip().name === e) || null;
  }
  /** Is any animation playing? */
  get isPlaying() {
    if (this.actions) {
      for (let e = 0; e < this.actions.length; e++)
        if (this.actions[e].isRunning())
          return !0;
    }
    return !1;
  }
  /** Stops all currently playing animations */
  stopAll(e) {
    if (this.actions)
      for (const t of this.actions)
        e?.fadeDuration ? t.fadeOut(e.fadeDuration) : t.stop();
  }
  /**
   * Stops a specific animation clip or index. If clip is undefined then all animations will be stopped
   */
  stop(e, t) {
    if (e === void 0) {
      this.stopAll();
      return;
    } else if (typeof e == "number") {
      if (e >= this.animations.length) {
        Bs && console.log("No animation at index", e);
        return;
      }
      e = this.animations[e];
    } else typeof e == "string" && (e = this.animations.find((n) => n.name === e));
    if (!e) {
      console.error("Could not find clip", e);
      return;
    }
    const i = this.actions.find((n) => n.getClip() === e);
    if (!i) {
      console.error("Could not find action", e);
      return;
    }
    t?.fadeDuration ? i.fadeOut(t.fadeDuration) : i.stop();
  }
  /**
   * Pause all animations or a specific animation clip or index
   * @param clip optional animation clip, index or name, if undefined all animations will be paused
   * @param unpause if true, the animation will be resumed
   */
  pause(e, t = !1) {
    if (e === void 0) {
      for (const n of this.actions)
        n.paused = !t;
      return;
    } else if (typeof e == "number") {
      if (e >= this.animations.length) {
        Bs && console.log("No animation at index", e);
        return;
      }
      e = this.animations[e];
    } else typeof e == "string" && (e = this.animations.find((n) => n.name === e));
    if (!e) {
      console.error("Could not find clip", e);
      return;
    }
    const i = this.actions.find((n) => n.getClip() === e);
    if (!i) {
      console.error("Could not find action", e);
      return;
    }
    i.paused = !t;
  }
  /**
   * Resume all paused animations.   
   * Note that this will not fade animations in or out and just unpause previous animations. If an animation was faded out which means it's not running anymore, it will not be resumed.
   */
  resume() {
    for (const e of this.actions)
      e.paused = !1;
  }
  /**
   * Play an animation clip or an clip at the specified index.
   * @param clipOrNumber the animation clip, index or name to play. If undefined, the first animation in the animations array will be played
   * @param options the play options. Use to set the fade duration, loop, speed, start time, end time, clampWhenFinished
   * @returns a promise that resolves when the animation is finished (note that it will not resolve if the animation is looping)
   */
  play(e = 0, t) {
    if (Bs && console.log("PLAY", e), this.ensureMixer(), !this.mixer) {
      Bs && console.warn("Missing mixer", this);
      return;
    }
    e === void 0 && (e = 0);
    let i = e;
    if (typeof e == "number") {
      if (e >= this.animations.length) {
        Bs && console.log("No animation at index", e);
        return;
      }
      i = this.animations[e];
    } else typeof e == "string" && (i = this.animations.find((o) => o.name === e));
    if (!i) {
      console.error("Could not find clip", e);
      return;
    }
    t || (t = {});
    for (const o of this.actions)
      if (o.getClip() === i)
        return this.internalOnPlay(o, t);
    if (!i.tracks) {
      console.warn("Clip is no AnimationClip", i);
      return;
    }
    const n = this.mixer.clipAction(i);
    return this.actions.push(n), this.internalOnPlay(n, t);
  }
  internalOnPlay(e, t) {
    var i = this.actions.find((r) => r === e);
    if (i === e && i.isRunning() && i.time < i.getClip().duration) {
      const r = this.tryFindHandle(e);
      if (i.paused && (i.paused = !1), r) return r.waitForFinish();
    }
    if (t.loop === void 0 && (t.loop = this.loop), t.clampWhenFinished === void 0 && (t.clampWhenFinished = this.clampWhenFinished), t.minMaxOffsetNormalized === void 0 && this.randomStartTime && (t.minMaxOffsetNormalized = this.minMaxOffsetNormalized), t.minMaxSpeed === void 0 && (t.minMaxSpeed = this.minMaxSpeed), t?.exclusive ?? !0)
      for (const r of this.actions)
        r != i && (t.fadeDuration ? r.fadeOut(t.fadeDuration) : r.stop());
    if (t?.fadeDuration && e.fadeIn(t.fadeDuration), e.enabled = !0, t?.startTime != null)
      e.time = t.startTime;
    else if (t?.minMaxOffsetNormalized && t.minMaxOffsetNormalized.x != 0 && t.minMaxOffsetNormalized.y != 0) {
      const r = e.getClip();
      e.time = j.lerp(t.minMaxOffsetNormalized.x, t.minMaxOffsetNormalized.y, Math.random()) * r.duration;
    } else e.time >= e.getClip().duration && (e.time = 0);
    t?.minMaxSpeed ? e.timeScale = j.lerp(t.minMaxSpeed.x, t.minMaxSpeed.y, Math.random()) : e.timeScale = t?.speed ?? 1, t?.loop != null ? e.loop = t.loop ? ox : np : e.loop = np, t?.clampWhenFinished && (e.clampWhenFinished = !0), e.paused = !1, e.play(), Bs && console.log("PLAY", e.getClip().name, e);
    const o = new TO(e, this.mixer, t, (r) => {
      this._handles.splice(this._handles.indexOf(o), 1);
    });
    return this._handles.push(o), o.waitForFinish();
  }
  tryFindHandle(e) {
    for (const t of this._handles)
      if (t.action === e)
        return t;
  }
  ensureMixer() {
    if (!this.mixer) {
      const e = "animationMixer";
      this.gameObject[e] && (this.mixer = this.gameObject[e]), (!this.mixer || !this.mixer.clipAction) && (this.mixer = new dm(this.gameObject), this.gameObject[e] = this.mixer);
    }
    this.context.animations.registerAnimationMixer(this.mixer);
  }
}
yr([
  u()
], bi.prototype, "playAutomatically", 2);
yr([
  u()
], bi.prototype, "randomStartTime", 2);
yr([
  u(U0)
], bi.prototype, "minMaxSpeed", 2);
yr([
  u(U0)
], bi.prototype, "minMaxOffsetNormalized", 2);
yr([
  u()
], bi.prototype, "loop", 2);
yr([
  u()
], bi.prototype, "clampWhenFinished", 2);
yr([
  u(no)
], bi.prototype, "clips", 1);
class TO {
  mixer;
  action;
  promise = null;
  _options;
  _resolveCallback = null;
  _resolvedOrRejectedCallback;
  constructor(e, t, i, n) {
    this.action = e, this.mixer = t, this._resolvedOrRejectedCallback = n, this._options = i;
  }
  waitForFinish() {
    return this.promise ? this.promise : (this.promise = new Promise((e) => {
      this._resolveCallback = e;
    }), this.mixer.addEventListener("finished", this.onFinished), this.promise);
  }
  update() {
    this._options && this._options.endTime !== void 0 && this.action.time > this._options.endTime && (this._options.loop === !0 ? this.action.time = this._options.startTime ?? 0 : (this.action.time = this._options.endTime, this.action.timeScale = 0, this.onResolve()));
  }
  onResolve() {
    this.dispose(), this._resolvedOrRejectedCallback?.call(this, this), this._resolveCallback?.call(this, this.action);
  }
  // private onLoop = (_evt: MixerEvent) => {
  // }
  onFinished = (e) => {
    e.action === this.action && this.onResolve();
  };
  dispose() {
    this.mixer.removeEventListener("finished", this.onFinished);
  }
}
const jh = Symbol("objectIsAnimatedData");
function l_(s, e, t) {
  if (!s) return;
  if (s[jh] === void 0) {
    if (!t) return;
    s[jh] = /* @__PURE__ */ new Set();
  }
  const i = s[jh];
  t ? i.add(e) : i.has(e) && i.delete(e);
}
function EO(s) {
  if (!s) return !1;
  const e = s[jh];
  return e !== void 0 && e.size > 0;
}
class YI {
  _context;
  get context() {
    return this._context ?? N.Current;
  }
  get isStateMachineBehaviour() {
    return !0;
  }
}
class sh {
  /** The name of the animation */
  name;
  /** The hash of the name */
  nameHash;
  /** The normalized time of the animation */
  normalizedTime;
  /** The length of the animation */
  length;
  /** The current speed of the animation */
  speed;
  /** The current action playing. It can be used to modify the action */
  action;
  /**
   * If the state has any transitions
   */
  hasTransitions;
  constructor(e, t, i, n) {
    this.name = e.name, this.nameHash = e.hash, this.normalizedTime = t, this.length = i, this.speed = n, this.action = e.motion.action || null, this.hasTransitions = e.transitions?.length > 0 || !1;
  }
}
function AO(s, e) {
  return {
    name: "Empty",
    isLooping: !1,
    guid: e?.generateUUID() ?? gs.generateUUID(),
    index: -1,
    clip: new no(s, 0, [])
  };
}
var Uo = /* @__PURE__ */ ((s) => (s[s.If = 1] = "If", s[s.IfNot = 2] = "IfNot", s[s.Greater = 3] = "Greater", s[s.Less = 4] = "Less", s[s.Equals = 6] = "Equals", s[s.NotEqual = 7] = "NotEqual", s))(Uo || {}), N0 = /* @__PURE__ */ ((s) => (s[s.Float = 1] = "Float", s[s.Int = 3] = "Int", s[s.Bool = 4] = "Bool", s[s.Trigger = 9] = "Trigger", s))(N0 || {});
const et = w("debuganimatorcontroller"), oh = w("debugrootmotion");
class on {
  /**
   * Creates an AnimatorController from a set of animation clips.
   * Each clip becomes a state in the controller's state machine.
   * 
   * @param clips - The animation clips to use for creating states
   * @param options - Configuration options for the controller including looping behavior and transitions
   * @returns A new AnimatorController instance
   */
  static createFromClips(e, t = { looping: !1, autoTransition: !0, transitionDuration: 0 }) {
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const a = e[r], l = [];
      if (t.autoTransition !== !1) {
        const h = t.transitionDuration ?? 0, d = h / a.duration;
        let f = r;
        (t.autoTransition === void 0 || t.autoTransition === !0) && (f = (r + 1) % e.length), l.push({
          exitTime: 1 - d,
          offset: 0,
          duration: h,
          hasExitTime: !0,
          destinationState: f,
          conditions: []
        });
      }
      const c = {
        name: a.name,
        hash: r,
        // by using the index it's easy for users to call play(2) to play the clip at index 2
        motion: {
          name: a.name,
          clip: a,
          isLooping: t?.looping ?? !1
        },
        transitions: l,
        behaviours: []
      };
      i.push(c);
    }
    const n = {
      name: "AnimatorController",
      guid: new Tt(Date.now()).generateUUID(),
      parameters: [],
      layers: [{
        name: "Base Layer",
        stateMachine: {
          defaultState: 0,
          states: i
        }
      }]
    };
    return new on(n);
  }
  /**
   * Plays an animation state by name or hash.
   * 
   * @param name - The name or hash identifier of the state to play
   * @param layerIndex - The layer index (defaults to 0)
   * @param normalizedTime - The normalized time to start the animation from (0-1)
   * @param durationInSec - Transition duration in seconds
   */
  play(e, t = -1, i = Number.NEGATIVE_INFINITY, n = 0) {
    if (t < 0) t = 0;
    else if (t >= this.model.layers.length) {
      console.warn("invalid layer");
      return;
    }
    const r = this.model.layers[t].stateMachine;
    for (const a of r.states)
      if (a.name === e || a.hash === e) {
        et && console.log("transition to ", a), this.transitionTo(a, n, i);
        return;
      }
    console.warn("Could not find " + e + " to play");
  }
  /**
   * Resets the controller to its initial state.
   */
  reset() {
    this.setStartTransition();
  }
  /**
   * Sets a boolean parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param value - The boolean value to set
   */
  setBool(e, t) {
    const i = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.filter((n) => n[i] === e).forEach((n) => n.value = t);
  }
  /**
   * Gets a boolean parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The boolean value of the parameter, or false if not found
   */
  getBool(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.find((i) => i[t] === e)?.value ?? !1;
  }
  /**
   * Sets a float parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param val - The float value to set
   * @returns True if the parameter was found and set, false otherwise
   */
  setFloat(e, t) {
    const i = typeof e == "string" ? "name" : "hash", n = this.model?.parameters?.filter((o) => o[i] === e);
    return n.forEach((o) => o.value = t), n?.length > 0;
  }
  /**
   * Gets a float parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The float value of the parameter, or 0 if not found
   */
  getFloat(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.find((i) => i[t] === e)?.value ?? 0;
  }
  /**
   * Sets an integer parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param val - The integer value to set
   */
  setInteger(e, t) {
    const i = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.filter((n) => n[i] === e).forEach((n) => n.value = t);
  }
  /**
   * Gets an integer parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The integer value of the parameter, or 0 if not found
   */
  getInteger(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.find((i) => i[t] === e)?.value ?? 0;
  }
  /**
   * Sets a trigger parameter to active (true).
   * Trigger parameters are automatically reset after they are consumed by a transition.
   * 
   * @param name - The name or hash identifier of the trigger parameter
   */
  setTrigger(e) {
    et && console.log("SET TRIGGER", e);
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.filter((i) => i[t] === e).forEach((i) => i.value = !0);
  }
  /**
   * Resets a trigger parameter to inactive (false).
   * 
   * @param name - The name or hash identifier of the trigger parameter
   */
  resetTrigger(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.filter((i) => i[t] === e).forEach((i) => i.value = !1);
  }
  /**
   * Gets the current state of a trigger parameter.
   * 
   * @param name - The name or hash identifier of the trigger parameter
   * @returns The boolean state of the trigger, or false if not found
   */
  getTrigger(e) {
    const t = typeof e == "string" ? "name" : "hash";
    return this.model?.parameters?.find((i) => i[t] === e)?.value ?? !1;
  }
  /**
   * Checks if the controller is currently in a transition between states.
   * 
   * @returns True if a transition is in progress, false otherwise
   */
  isInTransition() {
    return this._activeStates.length > 1;
  }
  /** Set the speed of the animator controller. Larger values will make the animation play faster. */
  setSpeed(e) {
    this._speed = e;
  }
  _speed = 1;
  /**
   * Finds an animation state by name or hash.
   * @deprecated Use findState instead
   * 
   * @param name - The name or hash identifier of the state to find
   * @returns The found state or null if not found
   */
  FindState(e) {
    return this.findState(e);
  }
  /**
   * Finds an animation state by name or hash.
   * 
   * @param name - The name or hash identifier of the state to find
   * @returns The found state or null if not found
   */
  findState(e) {
    if (!e) return null;
    if (Array.isArray(this.model.layers)) {
      for (const t of this.model.layers)
        for (const i of t.stateMachine.states)
          if (i.name === e || i.hash == e) return i;
    }
    return null;
  }
  /**
   * Gets information about the current playing animation state.
   * 
   * @returns An AnimatorStateInfo object with data about the current state, or null if no state is active
   */
  getCurrentStateInfo() {
    if (!this._activeState) return null;
    const e = this._activeState.motion.action;
    if (!e) return null;
    const t = this._activeState.motion.clip.duration, i = t <= 0 ? 0 : Math.abs(e.time / t);
    return new sh(this._activeState, i, t, this._speed);
  }
  /**
   * Gets the animation action currently playing.
   * 
   * @returns The current animation action, or null if no action is playing
   */
  get currentAction() {
    if (!this._activeState) return null;
    const e = this._activeState.motion.action;
    return e || null;
  }
  /**
   * The normalized time (0-1) to start playing the first state at.
   * This affects the initial state when the animator is first enabled.
   */
  normalizedStartOffset = 0;
  /**
   * The Animator component this controller is bound to.
   */
  animator;
  /**
   * The data model describing the animation states and transitions.
   */
  model;
  /**
   * Gets the engine context from the bound animator.
   */
  get context() {
    return this.animator?.context;
  }
  /**
   * Gets the animation mixer used by this controller.
   */
  get mixer() {
    return this._mixer;
  }
  /**
   * Cleans up resources used by this controller.
   * Stops all animations and unregisters the mixer from the animation system.
   */
  dispose() {
    if (this._mixer.stopAllAction(), this.animator) {
      this._mixer.uncacheRoot(this.animator.gameObject);
      for (const e of this._activeStates)
        e.motion.clip && this.mixer.uncacheAction(e.motion.clip, this.animator.gameObject);
    }
    this.context?.animations.unregisterAnimationMixer(this._mixer);
  }
  // applyRootMotion(obj: Object3D) {
  //     // this.internalApplyRootMotion(obj);
  // }
  /**
   * Binds this controller to an animator component.
   * Creates a new animation mixer and sets up animation actions.
   * 
   * @param animator - The animator to bind this controller to
   */
  bind(e) {
    e ? this.animator !== e && (this._mixer && (this._mixer.stopAllAction(), this.context?.animations.unregisterAnimationMixer(this._mixer)), this.animator = e, this._mixer = new dm(this.animator.gameObject), this.context?.animations.registerAnimationMixer(this._mixer), this.createActions(this.animator)) : console.error("AnimatorController.bind: animator is null");
  }
  /**
   * Creates a deep copy of this controller.
   * Clones the model data but does not copy runtime state.
   * 
   * @returns A new AnimatorController instance with the same configuration
   */
  clone() {
    if (typeof this.model == "string")
      return console.warn("AnimatorController has not been resolved, can not create model from string", this.model), null;
    et && console.warn("AnimatorController clone()", this.model);
    const e = zd(this.model, (i, n, o) => o == null ? !0 : !(o.type === "Object3D" || o.isObject3D === !0 || DC(o) || o.tracks !== void 0 || o instanceof on));
    return console.assert(e !== this.model), new on(e);
  }
  /**
   * Updates the controller's state machine and animations.
   * Called each frame by the animator component.
   * 
   * @param weight - The weight to apply to the animations (for blending)
   */
  update(e) {
    if (!this.animator) return;
    this.evaluateTransitions(), this.updateActiveStates(e);
    const t = this.animator.context.time.deltaTime;
    this.animator.applyRootMotion && this.rootMotionHandler?.onBeforeUpdate(e), this._mixer.update(t), this.animator.applyRootMotion && this.rootMotionHandler?.onAfterUpdate(e);
  }
  _mixer;
  _activeState;
  /**
   * Gets the currently active animation state.
   * 
   * @returns The active state or undefined if no state is active
   */
  get activeState() {
    return this._activeState;
  }
  constructor(e) {
    this.model = e, et && console.log(this);
  }
  _activeStates = [];
  updateActiveStates(e) {
    for (let t = 0; t < this._activeStates.length; t++) {
      const i = this._activeStates[t], n = i.motion;
      if (!n.action)
        this._activeStates.splice(t, 1), t--;
      else {
        const o = n.action;
        o.weight = e, o.getEffectiveWeight() <= 0 && !o.isRunning() && (et && console.debug("REMOVE", i.name, o.getEffectiveWeight(), o.isRunning(), o.isScheduled()), this._activeStates.splice(t, 1), t--);
      }
    }
  }
  setStartTransition() {
    this.model.layers.length > 1 && (et || L()) && console.warn("Multiple layers are not supported yet " + this.animator?.name);
    for (const e of this.model.layers) {
      const t = e.stateMachine;
      t.defaultState === void 0 && (et && console.warn("AnimatorController default state is undefined, will assign state 0 as default", e), t.defaultState = 0);
      const i = t.states[t.defaultState];
      this.transitionTo(i, 0, this.normalizedStartOffset);
      break;
    }
  }
  evaluateTransitions() {
    let e = !1;
    if (!this._activeState) {
      if (this.setStartTransition(), !this._activeState) return;
      e = !0;
    }
    const t = this._activeState, i = t.motion.action;
    for (const o of t.transitions) {
      if (!o.hasExitTime && o.conditions.length <= 0)
        continue;
      let r = !0;
      for (const a of o.conditions)
        if (!this.evaluateCondition(a)) {
          r = !1;
          break;
        }
      if (r)
        if (i) {
          const a = t.motion.clip.duration, l = a <= 0 ? 1 : Math.abs(i.time / a);
          let c = o.exitTime;
          i.timeScale < 0 && (c = 1 - c);
          let h = !1;
          if (o.hasExitTime ? i.timeScale > 0 ? h = l >= o.exitTime : i.timeScale < 0 && (h = 1 - l >= o.exitTime) : h = !0, h) {
            for (const d of o.conditions) {
              const f = this.model.parameters.find((p) => p.name === d.parameter);
              f?.type === N0.Trigger && f.value && (f.value = !1);
            }
            if (i.clampWhenFinished = !0, et) {
              const d = this.getState(o.destinationState, 0);
              console.log(`Transition to ${o.destinationState} / ${d?.name}`, o, `
Timescale: ` + i.timeScale, `
Normalized time: ` + l.toFixed(3), `
Exit Time: ` + c, o.hasExitTime);
            }
            this.transitionTo(o.destinationState, o.duration, o.offset);
            return;
          }
        } else {
          this.transitionTo(o.destinationState, o.duration, o.offset);
          return;
        }
    }
    i && this.setTimescale(i, t);
    let n = !1;
    if (t.motion.isLooping && i && (i.time >= i.getClip().duration ? (n = !0, i.reset(), i.time = 0, i.play()) : i.time <= 0 && i.timeScale < 0 && (n = !0, i.reset(), i.time = i.getClip().duration, i.play())), !n && t && !e && i && this.animator && t.behaviours) {
      const o = i?.getClip().duration, r = i.time / o, a = new sh(this._activeState, r, o, this._speed);
      for (const l of t.behaviours)
        l.instance && l.instance.onStateUpdate?.call(l.instance, this.animator, a, 0);
    }
  }
  setTimescale(e, t) {
    let i = t.speed ?? 1;
    t.speedParameter && (i *= this.getFloat(t.speedParameter)), i !== void 0 && (e.timeScale = i * this._speed);
  }
  getState(e, t) {
    return typeof e == "number" && (e == -1 && (e = this.model.layers[t].stateMachine.defaultState, e === void 0 && (et && console.warn("AnimatorController default state is undefined: ", this.model, "Layer: " + t), e = 0)), e = this.model.layers[t].stateMachine.states[e]), e;
  }
  /**
   * These actions have been active previously but not faded out because we entered a state that has no real animation - no duration. In which case we hold the previously active actions until they are faded out.
   */
  _heldActions = [];
  releaseHeldActions(e) {
    for (const t of this._heldActions)
      t.fadeOut(e);
    this._heldActions.length = 0;
  }
  transitionTo(e, t, i) {
    if (!this.animator) return;
    const n = 0;
    if (e = this.getState(e, n), !e?.motion || !e.motion.clip || !(e.motion.clip instanceof no))
      return;
    const o = this._activeState === e;
    if (o) {
      const h = e.motion;
      if (!h.action_loopback && h.clip) {
        const d = this.rootMotionHandler ? this.animator.gameObject.matrix.clone() : null;
        this._mixer.uncacheAction(h.clip, this.animator.gameObject), d && d.decompose(this.animator.gameObject.position, this.animator.gameObject.quaternion, this.animator.gameObject.scale), h.action_loopback = this.createAction(h.clip);
      }
    }
    if (this._activeState?.behaviours && this._activeState.motion.action) {
      const h = this._activeState?.motion.clip.duration, d = this._activeState.motion.action.time / h, f = new sh(this._activeState, d, h, this._speed);
      for (const p of this._activeState.behaviours)
        p.instance?.onStateExit?.call(p.instance, this.animator, f, n);
    }
    const r = this._activeState?.motion.action;
    o && (e.motion.action = e.motion.action_loopback, e.motion.action_loopback = r);
    const a = this._activeState;
    this._activeState = e;
    const l = e.motion?.action, c = e.motion.clip;
    if (c?.duration <= 0 && c.tracks.length <= 0 ? r && this._heldActions.push(r) : r && (r.fadeOut(t), this.releaseHeldActions(t)), l) {
      if (i = Math.max(0, Math.min(1, i)), e.cycleOffsetParameter) {
        let d = this.getFloat(e.cycleOffsetParameter);
        typeof d == "number" ? (d < 0 && (d += 1), i += d, i %= 1) : et && console.warn("AnimatorController cycle offset parameter is not a number", e.cycleOffsetParameter);
      } else typeof e.cycleOffset == "number" && (i += e.cycleOffset, i %= 1);
      l.isRunning() && l.stop(), l.reset(), l.enabled = !0, this.setTimescale(l, e);
      const h = e.motion.clip.duration;
      if (l.time = o ? 0 : i * h, l.timeScale < 0 && (l.time = h - l.time), l.clampWhenFinished = !0, l.setLoop(np, 0), t > 0 ? l.fadeIn(t) : l.weight = 1, l.play(), this.rootMotionHandler && this.rootMotionHandler.onStart(l), this._activeStates.includes(e) || this._activeStates.push(e), this._activeState.behaviours) {
        const d = new sh(e, i, h, this._speed);
        for (const f of this._activeState.behaviours)
          f.instance?.onStateEnter?.call(f.instance, this.animator, d, n);
      }
    } else et && (e.__warned_no_motion || (e.__warned_no_motion = !0, console.warn("No action", e.motion, this)));
    et && console.log("TRANSITION FROM " + a?.name + " TO " + e.name, t, r, l, l?.getEffectiveTimeScale(), l?.getEffectiveWeight(), l?.isRunning(), l?.isScheduled(), l?.paused);
  }
  createAction(e) {
    if (this._mixer.existingAction(e) && this._mixer.uncacheAction(e, this.animator?.gameObject), this.animator?.applyRootMotion) {
      this.rootMotionHandler || (this.rootMotionHandler = new IO(this));
      const i = this.animator.gameObject;
      return this.rootMotionHandler.createClip(this._mixer, i, e);
    } else
      return this._mixer.clipAction(e);
  }
  evaluateCondition(e) {
    const t = this.model.parameters.find((i) => i.name === e.parameter);
    if (!t) return !1;
    switch (e.mode) {
      case Uo.If:
        return t.value === !0;
      case Uo.IfNot:
        return t.value === !1;
      case Uo.Greater:
        return t.value > e.threshold;
      case Uo.Less:
        return t.value < e.threshold;
      case Uo.Equals:
        return t.value === e.threshold;
      case Uo.NotEqual:
        return t.value !== e.threshold;
    }
    return !1;
  }
  createActions(e) {
    et && console.log("AnimatorController createActions", this.model);
    for (const t of this.model.layers) {
      const i = t.stateMachine;
      for (let n = 0; n < i.states.length; n++) {
        const o = i.states[n];
        o.transitions || (o.transitions = []);
        for (const r of o.transitions)
          r.conditions || (r.conditions = []);
        if (o.motion || (et && console.warn("No motion", o), o.motion = AO(o.name)), this.animator && o.motion.clips) {
          const r = o.motion.clips?.find((a) => a.node.name === this.animator?.gameObject?.name);
          r ? o.motion.clip = r.clip : (et || L()) && console.warn('Could not find clip for animator "' + this.animator?.gameObject?.name + '"', o.motion.clips.map((a) => a.node.name));
        }
        if (!o.motion.clip) {
          et && console.warn("No clip assigned to state", o);
          const r = new no(void 0, void 0, []);
          o.motion.clip = r;
        }
        if (o.motion?.clip) {
          const r = o.motion.clip;
          if (r instanceof no) {
            const a = this.createAction(r);
            o.motion.action = a;
          } else
            (et || L()) && console.warn("No valid animationclip assigned", o);
        }
        if (o.behaviours && Array.isArray(o.behaviours))
          for (const r of o.behaviours) {
            if (!r?.typeName) continue;
            const a = P.get(r.typeName);
            if (a) {
              const l = new a();
              l.isStateMachineBehaviour && (l._context = this.context ?? void 0, ya(l, r.properties), r.instance = l), et && console.log("Created animator controller behaviour", o.name, r.typeName, r.properties, l);
            } else
              (et || L()) && console.warn("Could not find AnimatorBehaviour type: " + r.typeName);
          }
      }
    }
  }
  /**
   * Yields all animation actions managed by this controller.
   * Iterates through all states in all layers and returns their actions.
   */
  *enumerateActions() {
    if (this.model.layers)
      for (const e of this.model.layers) {
        const t = e.stateMachine;
        for (let i = 0; i < t.states.length; i++) {
          const n = t.states[i];
          n?.motion && (n.motion.action && (yield n.motion.action), n.motion.action_loopback && (yield n.motion.action_loopback));
        }
      }
  }
  // https://docs.unity3d.com/Manual/RootMotion.html
  rootMotionHandler;
  // private findRootBone(obj: Object3D): Object3D | null {
  //     if (this.animationRoot) return this.animationRoot;
  //     if (obj.type === "Bone") {
  //         this.animationRoot = obj as Bone;
  //         return this.animationRoot;
  //     }
  //     if (obj.children) {
  //         for (const ch of obj.children) {
  //             const res = this.findRootBone(ch);
  //             if (res) return res;
  //         }
  //     }
  //     return null;
  // }
}
class c_ {
  track;
  createdInterpolant;
  originalEvaluate;
  customEvaluate;
  constructor(e, t) {
    this.track = e;
    const i = e, n = i.createInterpolant.bind(e);
    i.createInterpolant = () => (i.createInterpolant = n, this.createdInterpolant = n(), this.originalEvaluate = this.createdInterpolant.evaluate.bind(this.createdInterpolant), this.customEvaluate = (o) => {
      if (!this.originalEvaluate) return;
      const r = this.originalEvaluate(o);
      return t(o, r);
    }, this.createdInterpolant.evaluate = this.customEvaluate, this.createdInterpolant);
  }
  dispose() {
    this.createdInterpolant && this.originalEvaluate && (this.createdInterpolant.evaluate = this.originalEvaluate), this.track = void 0, this.createdInterpolant = null, this.originalEvaluate = void 0, this.customEvaluate = void 0;
  }
}
class nt {
  static lastObjPosition = {};
  static lastObjRotation = {};
  // we remove the first keyframe rotation from the space rotation when updating
  static firstKeyframeRotation = {};
  // this is used to rotate the space on clip end / start (so the transform direction is correct)
  static spaceRotation = {};
  static effectiveSpaceRotation = {};
  static clipOffsetRotation = {};
  set action(e) {
    this._action = e;
  }
  get action() {
    return this._action;
  }
  get cacheId() {
    return this.root.uuid;
  }
  _action;
  root;
  clip;
  positionWrapper = null;
  rotationWrapper = null;
  context;
  positionChange = new b();
  rotationChange = new $();
  constructor(e, t, i, n, o) {
    if (this.context = e, this.root = t, this.clip = i, nt.firstKeyframeRotation[this.cacheId] || (nt.firstKeyframeRotation[this.cacheId] = new $()), o) {
      const r = o.values;
      nt.firstKeyframeRotation[this.cacheId].set(r[0], r[1], r[2], r[3]);
    }
    nt.spaceRotation[this.cacheId] || (nt.spaceRotation[this.cacheId] = new $()), nt.effectiveSpaceRotation[this.cacheId] || (nt.effectiveSpaceRotation[this.cacheId] = new $()), nt.clipOffsetRotation[this.cacheId] = new $(), o && nt.clipOffsetRotation[this.cacheId].set(o.values[0], o.values[1], o.values[2], o.values[3]).invert(), this.handlePosition(i, n), this.handleRotation(i, o);
  }
  onStart(e) {
    if (e.getClip() !== this.clip) return;
    nt.lastObjRotation[this.cacheId] || (nt.lastObjRotation[this.cacheId] = this.root.quaternion.clone());
    const t = nt.lastObjRotation[this.cacheId];
    if (nt.spaceRotation[this.cacheId].copy(t), oh) {
      const i = new Rt().setFromQuaternion(t);
      console.log("START", this.clip.name, j.toDegrees(i.y), this.root.position.z);
    }
  }
  getClipRotationOffset() {
    return nt.clipOffsetRotation[this.cacheId];
  }
  _prevTime = 0;
  handlePosition(e, t) {
    if (t) {
      const i = this.root;
      oh && i.add(new mi()), nt.lastObjPosition[this.cacheId] || (nt.lastObjPosition[this.cacheId] = this.root.position.clone());
      const n = new b(), o = new b();
      this.positionWrapper = new c_(t, (r, a) => {
        const l = this.action.getEffectiveWeight();
        return oh && i.position.length() > 8 && i.position.set(0, i.position.y, 0), r > this._prevTime && (n.set(a[0], a[1], a[2]), n.sub(o), n.multiplyScalar(l), n.applyQuaternion(this.getClipRotationOffset()), n.applyQuaternion(i.quaternion), this.positionChange.copy(n)), o.fromArray(a), this._prevTime = r, a[0] = 0, a[1] = 0, a[2] = 0, a;
      });
    }
  }
  static identityQuaternion = new $();
  handleRotation(e, t) {
    if (t) {
      if (oh) {
        const r = t.values, a = new Rt().setFromQuaternion(new $(r[0], r[1], r[2], r[3]));
        console.log(e.name, t.name, "FIRST ROTATION IN TRACK", j.toDegrees(a.y));
        const l = t.values.length - 4, c = new $().set(r[l], r[l + 1], r[l + 2], r[l + 3]), h = new Rt().setFromQuaternion(c);
        console.log(e.name, t.name, "LAST ROTATION IN TRACK", j.toDegrees(h.y));
      }
      let i = 0;
      const n = new $(), o = new $();
      this.rotationWrapper = new c_(t, (r, a) => (r > i && (o.set(a[0], a[1], a[2], a[3]), n.invert(), o.multiply(n), this.rotationChange.copy(o)), n.fromArray(a), i = r, a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a));
    }
  }
  // private lastPos: Vector3 = new Vector3();
  onBeforeUpdate(e) {
    this.positionChange.set(0, 0, 0), this.rotationChange.set(0, 0, 0, 1);
  }
  onAfterUpdate(e) {
    return !this.action || (e *= this.action.getEffectiveWeight(), e <= 0) ? !1 : (this.positionChange.multiplyScalar(e), this.rotationChange.slerp(nt.identityQuaternion, 1 - e), !0);
  }
}
class IO {
  controller;
  handler = [];
  root;
  basePosition = new b();
  baseQuaternion = new $();
  baseRotation = new Rt();
  constructor(e) {
    this.controller = e;
  }
  createClip(e, t, i) {
    this.root = t, t && "name" in t && t.name;
    const n = this.findRootTrack(i, ".position"), o = this.findRootTrack(i, ".quaternion"), r = new nt(this.controller.context, t, i, n, o);
    this.handler.push(r);
    const a = e.clipAction(i);
    return r.action = a, a;
  }
  onStart(e) {
    for (const t of this.handler)
      t.onStart(e);
  }
  onBeforeUpdate(e) {
    this.basePosition.copy(this.root.position), this.baseQuaternion.copy(this.root.quaternion);
    for (const t of this.handler)
      t.onBeforeUpdate(e);
  }
  summedPosition = new b();
  summedRotation = new $();
  onAfterUpdate(e) {
    if (!(e <= 0)) {
      this.root.position.copy(this.basePosition), this.root.quaternion.copy(this.baseQuaternion), this.summedPosition.set(0, 0, 0), this.summedRotation.set(0, 0, 0, 1);
      for (const t of this.handler)
        t.onAfterUpdate(e) && (this.summedPosition.add(t.positionChange), this.summedRotation.multiply(t.rotationChange));
      this.root.position.add(this.summedPosition), this.root.quaternion.multiply(this.summedRotation);
    }
  }
  findRootTrack(e, t) {
    const i = e.tracks;
    if (!i) return null;
    for (const n of i)
      if (n.name.endsWith(t))
        return n;
    return null;
  }
}
class LO extends Xi {
  onSerialize(e, t) {
  }
  onDeserialize(e, t) {
    if (t.type === on && e?.__type === "AnimatorController")
      return new on(e);
  }
}
new LO(on);
var DO = Object.defineProperty, jO = Object.getOwnPropertyDescriptor, Jd = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? jO(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && DO(e, t, n), n;
};
const Ei = w("debuganimator");
class At extends T {
  /** 
   * Identifies this component as an animation component in the engine
   */
  get isAnimationComponent() {
    return !0;
  }
  applyRootMotion = !1;
  hasRootMotion = !1;
  keepAnimatorControllerStateOnDisable = !1;
  set runtimeAnimatorController(e) {
    this._animatorController && this._animatorController.model === e || (e ? e instanceof on ? (e.animator && e.animator !== this && (console.warn("AnimatorController can not be bound to multiple animators", e.model?.name), e.model || console.error("AnimatorController has no model"), e = new on(e.model)), this._animatorController = e, this._animatorController.bind(this)) : (Ei && console.log("Assign animator controller", e, this), this._animatorController = new on(e), this.__didAwake && this._animatorController.bind(this)) : this._animatorController = null);
  }
  /**
   * Gets the current animator controller instance
   * @returns The current animator controller or null if none is assigned
   */
  get runtimeAnimatorController() {
    return this._animatorController;
  }
  /** 
   * Retrieves information about the current animation state
   * @returns The current state information, or undefined if no state is playing
   */
  getCurrentStateInfo() {
    return this.runtimeAnimatorController?.getCurrentStateInfo();
  }
  /** 
   * The currently playing animation action that can be used to modify animation properties
   * @returns The current animation action, or null if no animation is playing
   */
  get currentAction() {
    return this.runtimeAnimatorController?.currentAction || null;
  }
  /** 
   * Indicates whether animation parameters have been modified since the last update
   * @returns True if parameters have been changed
   */
  get parametersAreDirty() {
    return this._parametersAreDirty;
  }
  _parametersAreDirty = !1;
  /** 
   * Indicates whether the animator state has changed since the last update
   * @returns True if the animator has been changed
   */
  get isDirty() {
    return this._isDirty;
  }
  _isDirty = !1;
  /**@deprecated use play() */
  Play(e, t = -1, i = Number.NEGATIVE_INFINITY, n = 0) {
    this.play(e, t, i, n);
  }
  /** 
   * Plays an animation on the animator
   * @param name The name or hash of the animation to play
   * @param layer The layer to play the animation on (-1 for default layer)
   * @param normalizedTime The time position to start playing (0-1 range, NEGATIVE_INFINITY for current position)
   * @param transitionDurationInSec The duration of the blend transition in seconds
   */
  play(e, t = -1, i = Number.NEGATIVE_INFINITY, n = 0) {
    this.runtimeAnimatorController?.play(e, t, i, n), this._isDirty = !0;
  }
  /**@deprecated use reset */
  Reset() {
    this.reset();
  }
  /** 
   * Resets the animator controller to its initial state
   */
  reset() {
    this._animatorController?.reset(), this._isDirty = !0;
  }
  /**@deprecated use setBool */
  SetBool(e, t) {
    this.setBool(e, t);
  }
  /**
   * Sets a boolean parameter in the animator
   * @param name The name or hash of the parameter
   * @param value The boolean value to set
   */
  setBool(e, t) {
    Ei && console.log("setBool", e, t), this.runtimeAnimatorController?.getBool(e) !== t && (this._parametersAreDirty = !0), this.runtimeAnimatorController?.setBool(e, t);
  }
  /**@deprecated use getBool */
  GetBool(e) {
    return this.getBool(e);
  }
  /**
   * Gets a boolean parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the boolean parameter, or false if not found
   */
  getBool(e) {
    const t = this.runtimeAnimatorController?.getBool(e) ?? !1;
    return Ei && console.log("getBool", e, t), t;
  }
  /**
   * Toggles a boolean parameter between true and false
   * @param name The name or hash of the parameter
   */
  toggleBool(e) {
    this.setBool(e, !this.getBool(e));
  }
  /**@deprecated use setFloat */
  SetFloat(e, t) {
    this.setFloat(e, t);
  }
  /**
   * Sets a float parameter in the animator
   * @param name The name or hash of the parameter
   * @param val The float value to set
   */
  setFloat(e, t) {
    this.runtimeAnimatorController?.getFloat(e) !== t && (this._parametersAreDirty = !0), Ei && console.log("setFloat", e, t), this.runtimeAnimatorController?.setFloat(e, t);
  }
  /**@deprecated use getFloat */
  GetFloat(e) {
    return this.getFloat(e);
  }
  /**
   * Gets a float parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the float parameter, or -1 if not found
   */
  getFloat(e) {
    const t = this.runtimeAnimatorController?.getFloat(e) ?? -1;
    return Ei && console.log("getFloat", e, t), t;
  }
  /**@deprecated use setInteger */
  SetInteger(e, t) {
    this.setInteger(e, t);
  }
  /**
   * Sets an integer parameter in the animator
   * @param name The name or hash of the parameter
   * @param val The integer value to set
   */
  setInteger(e, t) {
    this.runtimeAnimatorController?.getInteger(e) !== t && (this._parametersAreDirty = !0), Ei && console.log("setInteger", e, t), this.runtimeAnimatorController?.setInteger(e, t);
  }
  /**@deprecated use getInteger */
  GetInteger(e) {
    return this.getInteger(e);
  }
  /**
   * Gets an integer parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the integer parameter, or -1 if not found
   */
  getInteger(e) {
    const t = this.runtimeAnimatorController?.getInteger(e) ?? -1;
    return Ei && console.log("getInteger", e, t), t;
  }
  /**@deprecated use setTrigger */
  SetTrigger(e) {
    this.setTrigger(e);
  }
  /**
   * Activates a trigger parameter in the animator
   * @param name The name or hash of the trigger parameter
   */
  setTrigger(e) {
    this._parametersAreDirty = !0, Ei && console.log("setTrigger", e), this.runtimeAnimatorController?.setTrigger(e);
  }
  /**@deprecated use resetTrigger */
  ResetTrigger(e) {
    this.resetTrigger(e);
  }
  /**
   * Resets a trigger parameter in the animator
   * @param name The name or hash of the trigger parameter
   */
  resetTrigger(e) {
    this._parametersAreDirty = !0, Ei && console.log("resetTrigger", e), this.runtimeAnimatorController?.resetTrigger(e);
  }
  /**@deprecated use getTrigger */
  GetTrigger(e) {
    this.getTrigger(e);
  }
  /**
   * Gets the state of a trigger parameter from the animator
   * @param name The name or hash of the trigger parameter
   * @returns The state of the trigger parameter
   */
  getTrigger(e) {
    const t = this.runtimeAnimatorController?.getTrigger(e);
    return Ei && console.log("getTrigger", e, t), t;
  }
  /**@deprecated use isInTransition */
  IsInTransition() {
    return this.isInTransition();
  }
  /** 
   * Checks if the animator is currently in a transition between states
   * @returns True if the animator is currently blending between animations
   */
  isInTransition() {
    return this.runtimeAnimatorController?.isInTransition() ?? !1;
  }
  /**@deprecated use setSpeed */
  SetSpeed(e) {
    return this.setSpeed(e);
  }
  /**
   * Sets the playback speed of the animator
   * @param speed The new playback speed multiplier
   */
  setSpeed(e) {
    e !== this._speed && (Ei && console.log("setSpeed", e), this._speed = e, this._animatorController?.animator == this && this._animatorController.setSpeed(e));
  }
  /** 
   * Sets a random playback speed between the min and max values
   * @param minMax Object with x (minimum) and y (maximum) speed values
   */
  set minMaxSpeed(e) {
    this._speed = j.lerp(e.x, e.y, Math.random()), this._animatorController?.animator == this && this._animatorController.setSpeed(this._speed);
  }
  /**
   * Sets a random normalized time offset for animations between min (x) and max (y) values
   * @param minMax Object with x (min) and y (max) values for the offset range
   */
  set minMaxOffsetNormalized(e) {
    this._normalizedStartOffset = j.lerp(e.x, e.y, Math.random()), this.runtimeAnimatorController?.animator == this && (this.runtimeAnimatorController.normalizedStartOffset = this._normalizedStartOffset);
  }
  _speed = 1;
  _normalizedStartOffset = 0;
  _animatorController = null;
  awake() {
    Ei && console.log("ANIMATOR", this.name, this), this.gameObject && this.initializeRuntimeAnimatorController();
  }
  // Why do we jump through hoops like this? It's because of the PlayableDirector and animation tracks
  // they NEED to use the same mixer when binding/creating the animation clips
  // so when the playable director runs it takes over updating the mixer for blending and then calls the runtimeAnimatorController.update
  // so they effectively share the same mixer. There might be cases still where not the same mixer is being used but then the animation track prints an error in dev
  _initializeWithRuntimeAnimatorController;
  initializeRuntimeAnimatorController(e = !1) {
    const t = e || this.runtimeAnimatorController !== this._initializeWithRuntimeAnimatorController;
    if (this.runtimeAnimatorController && t) {
      const i = this.runtimeAnimatorController.clone();
      this._initializeWithRuntimeAnimatorController = i, i ? (console.assert(this.runtimeAnimatorController !== i), this.runtimeAnimatorController = i, console.assert(this.runtimeAnimatorController === i), this.runtimeAnimatorController.bind(this), this.runtimeAnimatorController.setSpeed(this._speed), this.runtimeAnimatorController.normalizedStartOffset = this._normalizedStartOffset) : console.warn("Could not clone animator controller", this.runtimeAnimatorController);
    }
  }
  onDisable() {
    this.keepAnimatorControllerStateOnDisable || this._animatorController?.reset();
  }
  onBeforeRender() {
    this._isDirty = !1, this._parametersAreDirty = !1, !EO(this.gameObject) && this._animatorController && this._animatorController.update(1);
  }
}
Jd([
  u()
], At.prototype, "applyRootMotion", 2);
Jd([
  u()
], At.prototype, "hasRootMotion", 2);
Jd([
  u()
], At.prototype, "keepAnimatorControllerStateOnDisable", 2);
Jd([
  u()
], At.prototype, "runtimeAnimatorController", 1);
const h_ = Symbol("previous-visibility");
class fs extends Dn {
  /**
   * Render the scene to the texture
   * @param scene The scene to render
   * @param camera The camera to render from
   * @param renderer The renderer or effectcomposer to use
   */
  render(e, t, i) {
    if ("addPass" in i)
      this._unsupported_effectcomposer_warning || (console.warn("RenderTexture.render() does not yet support EffectComposer"), this._unsupported_effectcomposer_warning = !0);
    else if (i instanceof ur) {
      this.onBeforeRender();
      const o = i.getRenderTarget(), r = i.xr.enabled;
      i.xr.enabled = !1, i.setRenderTarget(this), i.clear(!0, !0, !0), i.render(e, t), i.setRenderTarget(o), i.xr.enabled = r, this.onAfterRender();
    }
  }
  static _userSet = /* @__PURE__ */ new Set();
  onBeforeRender() {
    fs._userSet.clear();
    const e = l0(this.texture, !0, null, fs._userSet);
    for (const t of e)
      t instanceof H && (t[h_] = t.visible, t.visible = !1);
  }
  onAfterRender() {
    for (const e of fs._userSet)
      e instanceof H && (e.visible = e[h_]);
    fs._userSet.clear();
  }
}
var BO = Object.defineProperty, FO = Object.getOwnPropertyDescriptor, bc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? FO(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && BO(e, t, n), n;
};
const rh = w("debuggroundprojection");
class Ms extends T {
  applyOnAwake = !1;
  autoFit = !0;
  set radius(e) {
    this._radius = e, this._projection && this.updateProjection();
  }
  get radius() {
    return this._radius;
  }
  _radius = 50;
  set height(e) {
    this._height = e, this._projection && this.updateProjection();
  }
  get height() {
    return this._height;
  }
  _height = 3;
  set arBlending(e) {
    this._arblending = e, this._needsTextureUpdate = !0;
  }
  get arBlending() {
    return this._arblending;
  }
  _arblending = 0;
  _lastBackground;
  _lastRadius;
  _lastHeight;
  _projection;
  _watcher;
  /** @internal */
  awake() {
    this.applyOnAwake && this.updateAndCreate();
  }
  /** @internal */
  onEnable() {
    this.context.time.frameCount > 0 && this.applyOnAwake && this.updateAndCreate(), this._watcher || (this._watcher = new so(this.context.scene, "background"), this._watcher.subscribeWrite((e) => {
      rh && console.log("Background changed", this.context.scene.background), this._needsTextureUpdate = !0;
    }));
  }
  /** @internal */
  onDisable() {
    this._watcher?.revoke(), this._projection?.removeFromParent();
  }
  /** @internal */
  onEnterXR() {
    this.activeAndEnabled && (this._needsTextureUpdate = !0, this.updateProjection());
  }
  /** @internal */
  async onLeaveXR() {
    this.activeAndEnabled && (await Ud(1), this.updateProjection());
  }
  /** @internal */
  onBeforeRender() {
    this._projection && this.scene.backgroundRotation && this._projection.rotation.copy(this.scene.backgroundRotation), this.context.scene.backgroundBlurriness !== void 0 && this._lastBlurriness != this.context.scene.backgroundBlurriness && this.context.scene.backgroundBlurriness > 1e-3 ? this.updateProjection() : this._needsTextureUpdate && this.context.scene.background instanceof Te && this.updateBlurriness(this.context.scene.background, this.context.scene.backgroundBlurriness);
  }
  updateAndCreate() {
    this.updateProjection(), this._watcher?.apply();
  }
  _needsTextureUpdate = !1;
  /**
   * Updates the ground projection. This is called automatically when the environment or settings change.
   */
  updateProjection() {
    if (!this.context.scene.background) {
      this._projection?.removeFromParent();
      return;
    }
    const e = this.context.scene.background;
    if (!(e instanceof Te)) {
      this._projection?.removeFromParent();
      return;
    }
    if ((this.context.xr?.isPassThrough || this.context.xr?.isAR) && this.arBlending === 0) {
      this._projection?.removeFromParent();
      return;
    }
    if (!this.gameObject || this.destroyed)
      return;
    let t = !0;
    const i = 0, n = e !== this._lastBackground || this._height !== this._lastHeight || this._radius !== this._lastRadius;
    if (!this._projection || n) {
      rh && console.log("Create/Update Ground Projection", e.name), this._projection?.removeFromParent();
      try {
        this._projection = new da(e, this._height, this._radius, 64);
      } catch (o) {
        console.error("Error creating three GroundProjection", o);
        return;
      }
      this._projection.position.y = this._height - i, this._projection.name = "GroundProjection", Ub(this._projection, !1);
    } else
      t = !1;
    if (this._projection.parent || this.gameObject.add(this._projection), this.autoFit && t) {
      this._projection.updateWorldMatrix(!0, !0);
      const o = _i(this.context.scene.children, [this._projection]), r = o.min.y;
      if (r < 1 / 0) {
        const a = G();
        a.x = o.min.x + (o.max.x - o.min.x) * 0.5;
        const l = $e(this.gameObject).x;
        a.y = r + this._height * l - i, a.z = o.min.z + (o.max.z - o.min.z) * 0.5, ut(this._projection, a);
      }
      rh && F.DrawWireBox3(o, 65280, 5);
    }
    this.context.scene.backgroundBlurriness > 1e-3 && this._needsTextureUpdate && this.updateBlurriness(e, this.context.scene.backgroundBlurriness), this._lastBackground = e, this._lastHeight = this._height, this._lastRadius = this._radius, this._needsTextureUpdate = !1;
  }
  _blurrynessShader = null;
  _lastBlurriness = -1;
  updateBlurriness(e, t) {
    if (this._projection) {
      if (!e)
        return;
    } else return;
    this._needsTextureUpdate = !1, rh && console.log("Update Blurriness", t), this._blurrynessShader ??= new Ln({
      name: "GroundProjectionBlurriness",
      uniforms: {
        map: { value: e },
        blurriness: { value: t },
        blending: { value: 0 },
        alphaFactor: { value: 1 }
      },
      vertexShader: zO,
      fragmentShader: UO
    }), this._blurrynessShader.depthWrite = !1, this._blurrynessShader.uniforms.map.value = e, this._blurrynessShader.uniforms.blurriness.value = t, this._lastBlurriness = t, e.needsUpdate = !0;
    const i = this._projection.material.transparent;
    this._projection.material.transparent = (this.context.xr?.isAR === !0 && this.arBlending > 1e-6) ?? !1, this._projection.material.transparent ? this._blurrynessShader.uniforms.blending.value = this.arBlending : this._blurrynessShader.uniforms.blending.value = 0, this.context.isInPassThrough ? this._blurrynessShader.uniforms.alphaFactor.value = 0.95 : this._blurrynessShader.uniforms.alphaFactor.value = 1, i !== this._projection.material.transparent && (this._projection.material.needsUpdate = !0), this._projection.material.map = sr.copyTexture(e, this._blurrynessShader), this._projection.material.depthTest = !0, this._projection.material.depthWrite = !1;
  }
}
bc([
  u()
], Ms.prototype, "applyOnAwake", 2);
bc([
  u()
], Ms.prototype, "autoFit", 2);
bc([
  u()
], Ms.prototype, "radius", 1);
bc([
  u()
], Ms.prototype, "height", 1);
bc([
  u()
], Ms.prototype, "arBlending", 1);
const zO = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`, UO = `
  uniform sampler2D map;
  uniform float blurriness;
  uniform float alphaFactor;
  uniform float blending;
  varying vec2 vUv;

  const float PI = 3.14159265359;

  // Gaussian function
  float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * PI) * sigma);
  }

  // Custom smoothstep function for desired falloff
  float customSmoothstep(float edge0, float edge1, float x) {
    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
  }

  void main() {
    vec2 center = vec2(0.0, 0.0);
    vec2 pos = vUv;
    pos.x = 0.0; // Only consider vertical distance
    float distance = length(pos - center);
    
    // Calculate blur amount based on custom falloff
    float blurAmount = customSmoothstep(0.5, 1.0, distance * 2.0);
    blurAmount = clamp(blurAmount, 0.0, 1.0); // Ensure blur amount is within valid range

    // Gaussian blur
    vec2 pixelSize = 1.0 / vec2(textureSize(map, 0));
    vec4 color = vec4(0.0);
    float totalWeight = 0.0;
    int blurSize = int(60.0 * min(1.0, blurriness) * blurAmount); // Adjust blur size based on distance and blurriness
    float lodLevel = log2(float(blurSize)) * 0.5; // Compute LOD level

    for (int x = -blurSize; x <= blurSize; x++) {
        for (int y = -blurSize; y <= blurSize; y++) {
            vec2 offset = vec2(float(x), float(y)) * pixelSize * blurAmount;
            float weight = gaussian(length(vec2(float(x), float(y))), 1000.0 * blurAmount); // Use a fixed sigma value
            color += textureLod(map, vUv + offset, lodLevel) * weight;
            totalWeight += weight;
        }
    }

    color = totalWeight > 0.0 ? color / totalWeight : texture2D(map, vUv);

    gl_FragColor = color;

    float brightness = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));
    float stepFactor = blending - brightness * .1;
    gl_FragColor.a = pow(1.0 - blending * customSmoothstep(0.35 * stepFactor, 0.45 * stepFactor, distance), 5.);
    gl_FragColor.a *= alphaFactor;
    // gl_FragColor.rgb = vec3(1.0);

    // #include <tonemapping_fragment>
    // #include <colorspace_fragment>
    
    // Uncomment to visualize blur amount
    // gl_FragColor = vec4(blurAmount, 0.0, 0.0, 1.0);
  }
`;
var NO = Object.defineProperty, Wm = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && NO(e, t, n), n;
};
class Ra extends T {
  constraintActive = !0;
  locked = !1;
  sources = [];
  /**
   * Set the position of the constraint.
   */
  setConstraintPosition(e) {
    const t = this.sources[0];
    t && (t.worldPosition = e);
  }
}
Wm([
  u()
], Ra.prototype, "constraintActive");
Wm([
  u()
], Ra.prototype, "locked");
Wm([
  u(M)
], Ra.prototype, "sources");
let Jo = class {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  x() {
    return this.bb.readFloat32(this.bb_pos);
  }
  y() {
    return this.bb.readFloat32(this.bb_pos + 4);
  }
  z() {
    return this.bb.readFloat32(this.bb_pos + 8);
  }
  static sizeOf() {
    return 12;
  }
  static createVec3(e, t, i, n) {
    return e.prep(4, 12), e.writeFloat32(n), e.writeFloat32(i), e.writeFloat32(t), e.offset();
  }
};
class $0 {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  position(e) {
    return (e || new Jo()).__init(this.bb_pos, this.bb);
  }
  rotation(e) {
    return (e || new Jo()).__init(this.bb_pos + 12, this.bb);
  }
  scale(e) {
    return (e || new Jo()).__init(this.bb_pos + 24, this.bb);
  }
  static sizeOf() {
    return 36;
  }
  static createTransform(e, t, i, n, o, r, a, l, c, h) {
    return e.prep(4, 36), e.prep(4, 12), e.writeFloat32(h), e.writeFloat32(c), e.writeFloat32(l), e.prep(4, 12), e.writeFloat32(a), e.writeFloat32(r), e.writeFloat32(o), e.prep(4, 12), e.writeFloat32(n), e.writeFloat32(i), e.writeFloat32(t), e.offset();
  }
}
class ds {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsSyncedTransformModel(e, t) {
    return (t || new ds()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsSyncedTransformModel(e, t) {
    return e.setPosition(e.position() + Cb), (t || new ds()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  guid(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  /**
   * if the transform interpolation should be fast, this is true when the send interval is low and we want to have snappy transforms
   */
  fast() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  transform(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? (e || new $0()).__init(this.bb_pos + t, this.bb) : null;
  }
  /**
   * if the server should not save this info
   */
  dontSave() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  static startSyncedTransformModel(e) {
    e.startObject(4);
  }
  static addGuid(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addFast(e, t) {
    e.addFieldInt8(1, +t, 0);
  }
  static addTransform(e, t) {
    e.addFieldStruct(2, t, 0);
  }
  static addDontSave(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static endSyncedTransformModel(e) {
    return e.endObject();
  }
  static finishSyncedTransformModelBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedSyncedTransformModelBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
var R;
((s) => {
  ((e) => {
    e.MAYBEMODULE = null;
    const t = [];
    function i() {
      return e.MODULE ? Promise.resolve(e.MODULE) : new Promise((o) => {
        t.push(o);
      });
    }
    e.ready = i;
    async function n() {
      if (e.MODULE) return e.MODULE;
      const o = await import("./rapier-B3xpyPtq.js");
      return e.MODULE = o, e.MAYBEMODULE = o, t.forEach((r) => r(o)), t.length = 0, o;
    }
    e.load = n;
  })(s.RAPIER_PHYSICS || (s.RAPIER_PHYSICS = {})), ((e) => {
    e.MAYBEMODULE = null;
    const t = [];
    function i() {
      return e.MODULE ? Promise.resolve(e.MODULE) : new Promise((o) => {
        t.push(o);
      });
    }
    e.ready = i;
    async function n() {
      if (e.MODULE) return e.MODULE;
      const o = await import("./postprocessing-ORx-0eCx.js").then((r) => r.index);
      return e.MODULE = o, e.MAYBEMODULE = o, t.forEach((r) => r(o)), t.length = 0, o;
    }
    e.load = n;
  })(s.POSTPROCESSING || (s.POSTPROCESSING = {})), ((e) => {
    e.MAYBEMODULE = null;
    const t = [];
    function i() {
      return e.MODULE ? Promise.resolve(e.MODULE) : new Promise((o) => {
        t.push(o);
      });
    }
    e.ready = i;
    async function n() {
      if (e.MODULE) return e.MODULE;
      const o = await import("./postprocessing-ORx-0eCx.js").then((r) => r.N8AO);
      return e.MODULE = o, e.MAYBEMODULE = o, t.forEach((r) => r(o)), t.length = 0, o;
    }
    e.load = n;
  })(s.POSTPROCESSING_AO || (s.POSTPROCESSING_AO = {}));
})(R || (R = {}));
var wt = /* @__PURE__ */ ((s) => (s[s.Average = 0] = "Average", s[s.Multiply = 1] = "Multiply", s[s.Minimum = 2] = "Minimum", s[s.Maximum = 3] = "Maximum", s))(wt || {}), Vm = /* @__PURE__ */ ((s) => (s[s.Discrete = 0] = "Discrete", s[s.Continuous = 1] = "Continuous", s))(Vm || {}), qe = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.FreezePositionX = 2] = "FreezePositionX", s[s.FreezePositionY = 4] = "FreezePositionY", s[s.FreezePositionZ = 8] = "FreezePositionZ", s[s.FreezePosition = 14] = "FreezePosition", s[s.FreezeRotationX = 16] = "FreezeRotationX", s[s.FreezeRotationY = 32] = "FreezeRotationY", s[s.FreezeRotationZ = 64] = "FreezeRotationZ", s[s.FreezeRotation = 112] = "FreezeRotation", s[s.FreezeAll = 126] = "FreezeAll", s))(qe || {}), xl = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.X = 2] = "X", s[s.Y = 4] = "Y", s[s.Z = 8] = "Z", s[s.All = -1] = "All", s))(xl || {});
const It = function(s, e) {
  return function(t, i, n) {
    $O(t, i, n, s, e);
  };
};
function $O(s, e, t, i, n) {
  if (!n && !i && !s.onValidate) return;
  if (t !== void 0) {
    console.error("Invalid usage of validate decorator. Only fields can be validated.", s, e, t), Be("Invalid usage of validate decorator. Only fields can be validated. Property: " + e, Ui.Error);
    return;
  }
  let o = "";
  if (typeof e == "string" ? o = e : o = e.name, s.__internalAwake) {
    const r = Symbol(o), a = s.__internalAwake;
    s.__internalAwake = function() {
      if (!this.onValidate) {
        L() && console.warn('Usage of @validate decorate detected but there is no onValidate method in your class: "' + s.constructor?.name + '"');
        return;
      }
      if (this[r] === void 0) {
        this[r] = this[o];
        const l = this[o];
        if (l instanceof J || l instanceof b || l instanceof de || l instanceof $) {
          const c = this[o];
          bm(c, () => {
            this.onValidate(o);
          });
        }
        Object.defineProperty(this, o, {
          set: function(c) {
            if (this[Cp] === !0)
              this[r] = c;
            else {
              i?.call(this, c);
              const h = this[r];
              this[r] = c, this.onValidate?.call(this, o, h);
            }
          },
          get: function() {
            return n?.call(this), this[r];
          }
        });
      }
      a.call(this);
    };
  }
}
const ZI = function(s) {
  return function(e, t, i) {
    let n = "";
    typeof t == "string" ? n = t : n = t.name;
    const o = s.prototype, r = Object.getOwnPropertyDescriptor(o, n);
    if (!r?.value) {
      console.warn("Can not apply prefix: type does not have method named", t, s);
      return;
    }
    const a = r.value, l = e[n];
    Object.defineProperty(o, n, {
      value: function(...c) {
        const h = l?.call(this, ...c);
        if (h instanceof Promise) {
          h.then((d) => {
            if (d !== !1)
              return a.call(this, ...c);
          });
          return;
        }
        if (h !== !1)
          return a.call(this, ...c);
      }
    });
  };
};
var WO = Object.defineProperty, VO = Object.getOwnPropertyDescriptor, vi = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? VO(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && WO(e, t, n), n;
};
class HO {
  get isDirty() {
    return this.positionChanged || this.rotationChanged;
  }
  positionChanged = !1;
  rotationChanged = !1;
  position;
  quaternion;
  _positionKeys = ["x", "y", "z"];
  _quaternionKeys = ["_x", "_y", "_z", "_w"];
  reset(e = !1) {
    if (this.positionChanged = !1, this.rotationChanged = !1, this.mute = !1, e) {
      if (this.position)
        for (const t of this._positionKeys)
          delete this.position[t];
      if (this.quaternion)
        for (const t of this._quaternionKeys)
          delete this.quaternion[t];
    }
  }
  syncValues() {
    for (const e of this._positionKeys)
      this.position[e] = this.obj.position[e];
    for (const e of this._quaternionKeys)
      this.quaternion[e] = this.obj.quaternion[e];
  }
  mute = !1;
  applyValues() {
    if (this.positionChanged && this.position)
      for (const e of this._positionKeys) {
        const t = this.position[e];
        t !== void 0 && (this.obj.position[e] = t);
      }
    if (this.rotationChanged && this.quaternion)
      for (const e of this._quaternionKeys) {
        const t = this.quaternion[e];
        t !== void 0 && (this.obj.quaternion[e] = t);
      }
  }
  context;
  obj;
  _positionWatch;
  _rotationWatch;
  constructor(e, t) {
    this.context = t, this.obj = e;
  }
  start(e, t) {
    this.reset(), e && (this._positionWatch || (this._positionWatch = new so(this.obj.position, ["x", "y", "z"])), this._positionWatch.apply(), this.position = {}, this._positionWatch.subscribeWrite((o, r) => {
      if (this.context.physics.engine?.isUpdating || this.mute) return;
      const a = this.position[r];
      Math.abs(a - o) < 1e-5 || (this.position[r] = o, this.positionChanged = !0);
    })), t && (this._rotationWatch || (this._rotationWatch = new so(this.obj.quaternion, ["_x", "_y", "_z", "_w"])), this._rotationWatch.apply(), this.quaternion = {}, this._rotationWatch.subscribeWrite((o, r) => {
      if (this.context.physics.engine?.isUpdating || this.mute) return;
      const a = this.quaternion[r];
      Math.abs(a - o) < 1e-5 || (this.quaternion[r] = o, this.rotationChanged = !0);
    }));
    const i = this.obj.matrixWorld.multiplyMatrices.bind(this.obj.matrixWorld), n = new te();
    this.obj.matrixWorld.multiplyMatrices = (o, r) => (this.context.physics.engine?.isUpdating || this.mute || n.equals(o) || (this.positionChanged = !0, this.rotationChanged = !0, n.copy(o)), i(o, r));
  }
  stop() {
    this._positionWatch?.revoke(), this._rotationWatch?.revoke();
  }
}
const ei = class Bh extends T {
  get isRigidbody() {
    return !0;
  }
  autoMass = !0;
  set mass(e) {
    e !== this._mass && (this._mass = e, this._propertiesChanged = !0, this.__didAwake && (this.autoMass = !1));
  }
  get mass() {
    return this.autoMass ? this.context.physics.engine?.getBody(this)?.mass() ?? -1 : this._mass;
  }
  _mass = 0;
  useGravity = !0;
  centerOfMass = new b(0, 0, 0);
  constraints = qe.None;
  isKinematic = !1;
  drag = 0;
  angularDrag = 1;
  detectCollisions = !0;
  sleepThreshold = 0.01;
  collisionDetectionMode = Vm.Discrete;
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionX() {
    return (this.constraints & qe.FreezePositionX) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionY() {
    return (this.constraints & qe.FreezePositionY) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionZ() {
    return (this.constraints & qe.FreezePositionZ) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationX() {
    return (this.constraints & qe.FreezeRotationX) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationY() {
    return (this.constraints & qe.FreezeRotationY) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationZ() {
    return (this.constraints & qe.FreezeRotationZ) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionX(e) {
    e ? this.constraints |= qe.FreezePositionX : this.constraints &= ~qe.FreezePositionX;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionY(e) {
    e ? this.constraints |= qe.FreezePositionY : this.constraints &= ~qe.FreezePositionY;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionZ(e) {
    e ? this.constraints |= qe.FreezePositionZ : this.constraints &= ~qe.FreezePositionZ;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationX(e) {
    e ? this.constraints |= qe.FreezeRotationX : this.constraints &= ~qe.FreezeRotationX;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationY(e) {
    e ? this.constraints |= qe.FreezeRotationY : this.constraints &= ~qe.FreezeRotationY;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationZ(e) {
    e ? this.constraints |= qe.FreezeRotationZ : this.constraints &= ~qe.FreezeRotationZ;
  }
  /** Gravity is such a common force that it is implemented as a special case (even if it could easily be implemented by the user using force application). Note however that a change of gravity won't automatically wake-up the sleeping bodies so keep in mind that you may want to wake them up manually before a gravity change.   
   * 
   * It is possible to change the way gravity affects a specific rigid-body by setting the rigid-body's gravity scale to a value other than 1.0. The magnitude of the gravity applied to this body will be multiplied by this scaling factor. Therefore, a gravity scale set to 0.0 will disable gravity for the rigid-body whereas a gravity scale set to 2.0 will make it twice as strong. A negative value will flip the direction of the gravity for this rigid-body.
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#gravity
   */
  set gravityScale(e) {
    this._gravityScale = e;
  }
  get gravityScale() {
    return this._gravityScale;
  }
  _gravityScale = 1;
  dominanceGroup = 0;
  static tempPosition = new b();
  _propertiesChanged = !1;
  _currentVelocity = new b();
  _smoothedVelocity = new b();
  _smoothedVelocityGetter = new b();
  _lastPosition = new b();
  _watch;
  awake() {
    this._watch = void 0, this._propertiesChanged = !1;
  }
  onEnable() {
    this._watch || (this._watch = new HO(this.gameObject, this.context)), this._watch.start(!0, !0), this.startCoroutine(this.beforePhysics(), xe.LateUpdate), L() && (globalThis.NEEDLE_USE_RAPIER ? R.RAPIER_PHYSICS.ready().then(async () => {
      await Ud(3), this.context.physics.engine?.getBody(this) || console.warn(`Rigidbody could not be created. Ensure "${this.name}" has a Collider component.`);
    }) : console.warn("Rigidbody could not be created: Rapier physics are explicitly disabled."));
  }
  onDisable() {
    this._watch?.stop(), this.context.physics.engine?.removeBody(this);
  }
  onDestroy() {
    this.context.physics.engine?.removeBody(this);
  }
  onValidate() {
    this._propertiesChanged = !0;
  }
  // need to do this right before updating physics to prevent rendered object glitching through physical bodies
  *beforePhysics() {
    for (; ; )
      this._propertiesChanged && (this._propertiesChanged = !1, this.context.physics.engine?.updateProperties(this)), this._watch?.isDirty ? (this._watch.mute = !0, this._watch.applyValues(), this.context.physics.engine?.updateBody(this, this._watch.positionChanged, this._watch.rotationChanged), this._watch.reset()) : this._watch?.syncValues(), this.captureVelocity(), yield;
  }
  /** Teleport the rigidbody to a new position in the world.   
   * Will reset forces before setting the object world position 
   * @param pt The new position to teleport the object to (world space)
   * @param localspace When true the object will be teleported in local space, otherwise in world space
   * */
  teleport(e, t = !0) {
    this._watch?.reset(!0), t ? this.gameObject.position.set(e.x, e.y, e.z) : this.setWorldPosition(e.x, e.y, e.z), this.resetForcesAndTorques(), this.resetVelocities();
  }
  resetForces(e = !0) {
    this.context.physics.engine?.resetForces(this, e);
  }
  resetTorques(e = !0) {
    this.context.physics.engine?.resetTorques(this, e);
  }
  resetVelocities() {
    this.setVelocity(0, 0, 0), this.setAngularVelocity(0, 0, 0);
  }
  resetForcesAndTorques() {
    this.resetForces(), this.resetTorques();
  }
  /** When a dynamic rigid-body doesn't move (or moves very slowly) during a few seconds, it will be marked as sleeping by the physics pipeline. Rigid-bodies marked as sleeping are no longer simulated by the physics engine until they are woken up. That way the physics engine doesn't waste any computational resources simulating objects that don't actually move. They are woken up automatically whenever another non-sleeping rigid-body starts interacting with them (either with a joint, or with one of its attached colliders generating contacts).  
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#sleeping */
  wakeUp() {
    this.context.physics.engine?.wakeup(this);
  }
  get isSleeping() {
    return this.context.physics.engine?.isSleeping(this);
  }
  /** Call to force an update of the rigidbody properties in the physics engine */
  updateProperties() {
    return this._propertiesChanged = !1, this.context.physics.engine?.updateProperties(this);
  }
  /** Forces affect the rigid-body's acceleration whereas impulses affect the rigid-body's velocity 
   * the acceleration change is equal to the force divided by the mass:
   * @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  applyForce(e, t, i = !0) {
    this._propertiesChanged && this.updateProperties(), this.context.physics.engine?.addForce(this, e, i);
  }
  /** Forces affect the rigid-body's acceleration whereas impulses affect the rigid-body's velocity 
   * the velocity change is equal to the impulse divided by the mass  
   * @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  applyImpulse(e, t = !0) {
    this._propertiesChanged && this.updateProperties(), this.context.physics.engine?.applyImpulse(this, e, t);
  }
  /** @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  setForce(e, t, i, n = !0) {
    this.context.physics.engine?.resetForces(this, n), typeof e == "number" ? (t ??= 0, i ??= 0, this.context.physics.engine?.addForce(this, { x: e, y: t, z: i }, n)) : this.context.physics.engine?.addForce(this, e, n);
  }
  /** The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the center-of-mass of the rigid-body. This method returns the current linear velocity of the rigid-body. 
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#velocity */
  getVelocity() {
    const e = this.context.physics.engine?.getLinearVelocity(this);
    return e ? (this._currentVelocity.x = e.x, this._currentVelocity.y = e.y, this._currentVelocity.z = e.z, this._currentVelocity) : this._currentVelocity.set(0, 0, 0);
  }
  setVelocity(e, t, i, n = !0) {
    if (e instanceof b) {
      const o = e;
      this.context.physics.engine?.setLinearVelocity(this, o, n);
      return;
    }
    t === void 0 || i === void 0 || this.context.physics.engine?.setLinearVelocity(this, { x: e, y: t, z: i }, n);
  }
  /** The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the center-of-mass of the rigid-body. This method returns the current angular velocity of the rigid-body. 
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#velocity */
  getAngularVelocity() {
    const e = this.context.physics.engine?.getAngularVelocity(this);
    return e ? (this._currentVelocity.x = e.x, this._currentVelocity.y = e.y, this._currentVelocity.z = e.z, this._currentVelocity) : this._currentVelocity.set(0, 0, 0);
  }
  setAngularVelocity(e, t, i, n = !0) {
    if (typeof e == "object") {
      const o = e;
      this.context.physics.engine?.setAngularVelocity(this, o, n);
      return;
    }
    if (t === void 0 || i === void 0 || typeof t == "boolean") {
      console.warn("setAngularVelocity expects either a Vec3 or 3 numbers");
      return;
    }
    this.context.physics.engine?.setAngularVelocity(this, { x: e, y: t, z: i }, n);
  }
  setTorque(e, t, i) {
    typeof e == "number" ? this.setAngularVelocity(e, t, i) : this.setAngularVelocity(e);
  }
  /** 
   * Returns the rigidbody velocity smoothed over ~ 10 frames
   */
  get smoothedVelocity() {
    return this._smoothedVelocityGetter.copy(this._smoothedVelocity), this._smoothedVelocityGetter.multiplyScalar(1 / this.context.time.deltaTime);
  }
  /**d
   * @deprecated not used anymore and will be removed in a future update
   */
  setBodyFromGameObject(e = null) {
  }
  captureVelocity() {
    const e = this.gameObject.matrixWorld;
    Bh.tempPosition.setFromMatrixPosition(e);
    const t = Bh.tempPosition.sub(this._lastPosition);
    this._lastPosition.copy(Bh.tempPosition), this._smoothedVelocity.lerp(t, this.context.time.deltaTime / 0.1);
  }
};
vi([
  It()
], ei.prototype, "autoMass", 2);
vi([
  u()
], ei.prototype, "mass", 1);
vi([
  It(),
  u()
], ei.prototype, "useGravity", 2);
vi([
  u(b)
], ei.prototype, "centerOfMass", 2);
vi([
  It(),
  u()
], ei.prototype, "constraints", 2);
vi([
  It(),
  u()
], ei.prototype, "isKinematic", 2);
vi([
  It(),
  u()
], ei.prototype, "drag", 2);
vi([
  It(),
  u()
], ei.prototype, "angularDrag", 2);
vi([
  It(),
  u()
], ei.prototype, "detectCollisions", 2);
vi([
  It(),
  u()
], ei.prototype, "sleepThreshold", 2);
vi([
  It(),
  u()
], ei.prototype, "collisionDetectionMode", 2);
vi([
  It()
], ei.prototype, "_gravityScale", 2);
vi([
  It()
], ei.prototype, "dominanceGroup", 2);
let ft = ei;
new b();
new b();
const Vs = w("debugsync"), lc = "STRS";
t0(lc, ds.getRootAsSyncedTransformModel);
const gn = new _m();
function W0(s, e, t = !0) {
  gn.clear();
  const i = gn.createString(s);
  ds.startSyncedTransformModel(gn), ds.addGuid(gn, i), ds.addFast(gn, t);
  const n = e.worldPosition, o = e.worldEuler, r = e.gameObject.scale;
  ds.addTransform(gn, $0.createTransform(gn, n.x, n.y, n.z, o.x, o.y, o.z, r.x, r.y, r.z));
  const a = ds.endSyncedTransformModel(gn);
  return gn.finish(a, lc), gn.asUint8Array();
}
let Ip = 0, Wl = 0;
xO((s) => {
  const t = s.connection.currentServerUrl?.includes("glitch") ? 10 : 40;
  Wl = Math.floor(Ip / t), Ip = 0, Vs && Wl > 0 && console.log("Sync Transform Fast Interval", Wl);
});
class Fn extends T {
  // public autoOwnership: boolean = true;
  /** When true, overrides physics behavior when this object is owned by the local user */
  overridePhysics = !0;
  /** Whether to smoothly interpolate position changes when receiving updates */
  interpolatePosition = !0;
  /** Whether to smoothly interpolate rotation changes when receiving updates */
  interpolateRotation = !0;
  /** When true, sends updates at a higher frequency, useful for fast-moving objects */
  fastMode = !1;
  /** When true, notifies other clients when this object is destroyed */
  syncDestroy = !1;
  // private _state!: SyncedTransformModel;
  _model = null;
  _needsUpdate = !0;
  rb = null;
  _wasKinematic = !1;
  _receivedDataBefore = !1;
  _targetPosition;
  _targetRotation;
  _receivedFastUpdate = !1;
  _shouldRequestOwnership = !1;
  /** 
   * Requests ownership of this object on the network.
   * You need to be connected to a room for this to work.
   */
  requestOwnership() {
    Vs && console.log("Request ownership"), this._model ? this._model.requestOwnership() : (this._shouldRequestOwnership = !0, this._needsUpdate = !0);
  }
  /**
   * Free ownership of this object on the network.  
   * You need to be connected to a room for this to work.  
   * This will also be called automatically when the component is disabled.
   */
  freeOwnership() {
    this._model?.freeOwnership();
  }
  /**
   * Checks if this client has ownership of the object
   * @returns true if this client has ownership, false if not, undefined if ownership state is unknown
   */
  hasOwnership() {
    return this._model?.hasOwnership ?? void 0;
  }
  /**
   * Checks if the object is owned by any client
   * @returns true if the object is owned, false if not, undefined if ownership state is unknown
   */
  isOwned() {
    return this._model?.isOwned;
  }
  joinedRoomCallback = null;
  receivedDataCallback = null;
  /** @internal */
  awake() {
    Vs && console.log("new instance", this.guid, this), this._receivedDataBefore = !1, this._targetPosition = new b(), this._targetRotation = new $(), this.lastPosition = new b(), this.lastRotation = new $(), this.lastScale = new b(), this.rb = S.getComponentInChildren(this.gameObject, ft), this.rb && (this._wasKinematic = this.rb.isKinematic), this.receivedUpdate = !0, this._model = new i0(this.context.connection, this.guid), this.context.connection.isConnected && this.tryGetLastState(), this.joinedRoomCallback = this.tryGetLastState.bind(this), this.context.connection.beginListen(ee.JoinedRoom, this.joinedRoomCallback), this.receivedDataCallback = this.onReceivedData.bind(this), this.context.connection.beginListenBinary(lc, this.receivedDataCallback);
  }
  /** @internal */
  onDestroy() {
    this.syncDestroy && p0(this.guid, this.context.connection), this._model = null, this.context.connection.stopListen(ee.JoinedRoom, this.joinedRoomCallback), this.context.connection.stopListenBinary(lc, this.receivedDataCallback);
  }
  /**
   * Attempts to retrieve and apply the last known network state for this transform
   */
  tryGetLastState() {
    const e = this.context.connection.tryGetState(this.guid);
    e && this.onReceivedData(e);
  }
  tempEuler = new Rt();
  /**
   * Handles incoming network data for this transform
   * @param data The model containing transform information
   */
  onReceivedData(e) {
    if (!this.destroyed && typeof e.guid == "function" && e.guid() === this.guid) {
      Vs && console.log("new data", this.context.connection.connectionId, this.context.time.frameCount, this.guid, e), this.receivedUpdate = !0, this._receivedFastUpdate = e.fast();
      const t = e.transform();
      if (t) {
        sn.markDirty(this.gameObject, !0);
        const i = t.position();
        i && (this.interpolatePosition && this._targetPosition?.set(i.x(), i.y(), i.z()), (!this.interpolatePosition || !this._receivedDataBefore) && this.setWorldPosition(i.x(), i.y(), i.z()));
        const n = t.rotation();
        n && (this.tempEuler.set(n.x(), n.y(), n.z()), this.interpolateRotation && this._targetRotation.setFromEuler(this.tempEuler), (!this.interpolateRotation || !this._receivedDataBefore) && zb(this.gameObject, this.tempEuler));
        const o = t.scale();
        o && this.gameObject.scale.set(o.x(), o.y(), o.z());
      }
      this._receivedDataBefore = !0;
    }
  }
  /** 
   * @internal 
   * Initializes tracking of position and rotation when component is enabled
   */
  onEnable() {
    this.lastPosition.copy(this.worldPosition), this.lastRotation.copy(this.worldQuaternion), this.lastScale.copy(this.gameObject.scale), this._needsUpdate = !0, this._model && this._model.updateIsOwned();
  }
  /** 
   * @internal 
   * Releases ownership when component is disabled
   */
  onDisable() {
    this._model && this._model.freeOwnership();
  }
  receivedUpdate = !1;
  lastPosition;
  lastRotation;
  lastScale;
  /** 
   * @internal 
   * Handles transform synchronization before each render frame
   * Sends updates when owner, receives and applies updates when not owner
   */
  onBeforeRender() {
    if (!this.activeAndEnabled || !this.context.connection.isConnected) return;
    if (!this.context.connection.isInRoom || !this._model) {
      Vs && console.log("no model or room", this.name, this.guid, this.context.connection.isInRoom);
      return;
    }
    this._shouldRequestOwnership && (this._shouldRequestOwnership = !1, this._model.requestOwnership());
    const e = this.worldPosition, t = this.worldQuaternion, i = this.gameObject.scale;
    if (this._model.isOwned && !this.receivedUpdate) {
      const r = this._model.hasOwnership || this.fastMode ? 1e-4 : 1e-3;
      (e.distanceTo(this.lastPosition) > r || t.angleTo(this.lastRotation) > r || i.distanceTo(this.lastScale) > r) && (this._model.hasOwnership ? this._needsUpdate = !0 : (Vs && console.log(this.guid, "reset because not owned but", this.gameObject.name, this.lastPosition), this.worldPosition = this.lastPosition, e.copy(this.lastPosition), this.worldQuaternion = this.lastRotation, t.copy(this.lastRotation), this.gameObject.scale.copy(this.lastScale), sn.markDirty(this.gameObject, !0), this._needsUpdate = !1));
    }
    if (this._model && !this._model.hasOwnership && this._model.isOwned && this._receivedDataBefore) {
      const r = this._receivedFastUpdate || this.fastMode ? 0.5 : 0.3;
      let a = !1;
      if (this.interpolatePosition && this._targetPosition) {
        const l = this.worldPosition;
        l.lerp(this._targetPosition, r), this.worldPosition = l, a = !0;
      }
      if (this.interpolateRotation && this._targetRotation) {
        const l = this.worldQuaternion;
        l.slerp(this._targetRotation, r), this.worldQuaternion = l, a = !0;
      }
      a && sn.markDirty(this.gameObject, !0);
    }
    if (this.receivedUpdate = !1, this.lastPosition.copy(e), this.lastRotation.copy(t), this.lastScale.copy(i), !this._model || !this._model || this._model.hasOwnership === void 0 || !this._model.hasOwnership)
      return;
    this.rb && this.overridePhysics && this._wasKinematic !== void 0 && (Vs && console.log("reset kinematic", this.rb.name, this._wasKinematic), this.rb.isKinematic = this._wasKinematic);
    const n = 10, o = this.rb || this.fastMode;
    if (this._needsUpdate && (this.context.time.frameCount % n === 0 || o)) {
      if (Ip++, o && Wl > 0 && this.context.time.frameCount % Wl !== 0) return;
      Vs && console.debug("[SyncedTransform] Send update", this.context.connection.connectionId, this.guid, this.gameObject.name, this.gameObject.guid), this._needsUpdate = !1;
      const r = W0(this.guid, this, !!o);
      this.context.connection.sendBinary(r);
    }
  }
}
class eu {
  /** the original event */
  event;
  /** the index of the used device   
   * mouse and touch are always 0, controller is the gamepad index or XRController index
  */
  get deviceIndex() {
    return this.event.deviceIndex;
  }
  /** a combination of the pointerId + button to uniquely identify the exact input (e.g. LeftController:Button0 = 0, RightController:Button1 = 101) */
  get pointerId() {
    return this.event.pointerId;
  }
  /** 
   * mouse button 0 === LEFT, 1 === MIDDLE, 2 === RIGHT 
   * */
  button;
  buttonName;
  get pressure() {
    return this.event.pressure;
  }
  /** @returns `true` when `use()` has been called. Default: false */
  get used() {
    return this._used;
  }
  _used = !1;
  /** mark this event to be used */
  use() {
    this._used || (this._used = !0, this.event.use());
  }
  _propagationStopped = !1;
  get propagationStopped() {
    return this._propagationStopped;
  }
  /** Call this method to stop immediate propagation on the `event` object.   
   * WARNING: this is currently equivalent to stopImmediatePropagation   
   */
  stopPropagation() {
    this._propagationStopped = !0, this.event.stopImmediatePropagation();
  }
  /** Call this method to stop immediate propagation on the `event` object.   
   */
  stopImmediatePropagation() {
    this._propagationStopped = !0, this.event.stopImmediatePropagation();
  }
  /**@ignore internal flag, pointer captured (we dont want to see it in intellisense) */
  z__pointer_ctured = !1;
  /** Call this method in `onPointerDown` or `onPointerMove` to receive onPointerMove events for this pointerId even when the pointer has left the object until you call `releasePointerCapture` or when the pointerUp event happens 
  */
  setPointerCapture() {
    this.z__pointer_ctured = !0;
  }
  /**@ignore internal flag, pointer capture released */
  z__pointer_cture_rleased = !1;
  /** call this method in `onPointerDown` or `onPointerMove` to stop receiving onPointerMove events */
  releasePointerCapture() {
    this.z__pointer_cture_rleased = !0;
  }
  /** Who initiated this event */
  inputSource;
  /** Returns the input target ray mode e.g. "screen" for 2D mouse and touch events */
  get mode() {
    return this.event.mode;
  }
  /** The object this event hit or interacted with */
  object;
  /** The world position of this event */
  point;
  /** The object-space normal of this event */
  normal;
  /** */
  face;
  /** The distance of the hit point from the origin */
  distance;
  /** The instance ID of an object hit by a raycast (if a instanced object was hit) */
  instanceId;
  /** The three intersection */
  intersection;
  isDown;
  isUp;
  isPressed;
  isClick;
  isDoubleClick;
  input;
  constructor(e, t) {
    this.event = t, this.input = e, this.button = t.button;
  }
  clone() {
    const e = new eu(this.input, this.event);
    return Object.assign(e, this), e;
  }
  /**@deprecated use use() */
  Use() {
    this.use();
  }
  /**@deprecated use stopPropagation() */
  StopPropagation() {
    this.event.stopImmediatePropagation();
  }
}
function Lp(s, e) {
  return S.foreachComponent(s, (i) => {
    if (!i.enabled) return;
    const n = i;
    if (e)
      switch (e) {
        case "pointerdown":
          if (n.onPointerDown) return !0;
          break;
        case "pointerup":
          if (n.onPointerUp || n.onPointerClick) return !0;
          break;
        case "pointermove":
          if (n.onPointerEnter || n.onPointerExit || n.onPointerMove) return !0;
          break;
      }
    else if (n.onPointerDown || n.onPointerUp || n.onPointerEnter || n.onPointerExit || n.onPointerClick)
      return !0;
  }, !1) === !0;
}
const Kn = new Array();
class Qs {
  /**
   * When the CallInfo is enabled it will be invoked when the EventList is invoked
   */
  enabled = !0;
  /**
   * The target object to invoke the method on OR the function to invoke
   */
  target;
  methodName;
  /**
   * The arguments to invoke this method with
   */
  arguments;
  get canClone() {
    return this.target instanceof Object;
  }
  constructor(e, t, i, n) {
    this.target = e, this.methodName = t || null, this.arguments = i, n != null && (this.enabled = n);
  }
  invoke(...e) {
    if (this.enabled !== !1) {
      if (typeof this.target == "function")
        this.arguments ? (Kn.length = 0, e !== void 0 && e.length > 0 && Kn.push(...e), Kn.push(...this.arguments), this.target(...this.arguments), Kn.length = 0) : this.target(...e);
      else if (this.methodName != null) {
        const t = this.target[this.methodName];
        typeof t == "function" ? this.arguments ? (Kn.length = 0, e !== void 0 && e.length > 0 && Kn.push(...e), Kn.push(...this.arguments), t.call(this.target, ...Kn), Kn.length = 0) : t.call(this.target, ...e) : this.arguments ? this.target[this.methodName] = this.arguments[0] || e[0] : this.target[this.methodName] = e[0];
      }
    }
  }
}
const GO = (s) => /^[A-Z]*$/.test(s);
class Hm extends Event {
  //implements ArrayLike<T> {
  args;
}
class me {
  /** checked during instantiate to create a new instance */
  isEventList = !0;
  /**
   * @internal Used by the Needle Engine instantiate call to remap the event listeners to the new instance
   */
  __internalOnInstantiate(e) {
    const t = new Array();
    for (let n = 0; n < this.methods.length; n++) {
      const o = this.methods[n];
      if (!(o.target instanceof Function)) {
        const r = o.target;
        let a = r?.uuid;
        if (r && (a = r.guid), a) {
          const l = e[a];
          if (l) {
            const c = o.arguments?.map((h) => h instanceof Object && h.uuid ? e[h.uuid] : h?.isComponent ? e[h.guid] : h);
            t.push(new Qs(l.clone, o.methodName, c, o.enabled));
          } else L() && console.warn("Could not find target for event listener");
        }
      }
    }
    return new me(t);
  }
  target;
  key;
  // TODO: serialization should not take care of the args but instead give them to the eventlist directly
  // so we can handle passing them on here instead of in the serializer
  // this would also allow us to pass them on to the component EventTarget
  /** set an event target to try invoke the EventTarget dispatchEvent when this EventList is invoked */
  setEventTarget(e, t) {
    if (this.key = e, this.target = t, this.key !== void 0) {
      let i = "", n = !1;
      for (const o of this.key)
        n && GO(o) && (i += "-"), n = !0, i += o.toLowerCase();
      this.key = i;
    }
  }
  /** How many callback methods are subscribed to this event */
  get listenerCount() {
    return this.methods?.length ?? 0;
  }
  /** If the event is currently being invoked */
  get isInvoking() {
    return this._isInvoking;
  }
  _isInvoking = !1;
  // TODO: can we make functions serializable?
  methods = [];
  _methodsCopy = [];
  static from(...e) {
    return new me(e);
  }
  constructor(e) {
    if (this.methods = [], Array.isArray(e))
      for (const t of e)
        t instanceof Qs ? this.methods.push(t) : typeof t == "function" && this.methods.push(new Qs(t));
    else
      typeof e == "function" && this.methods.push(new Qs(e));
  }
  /** Invoke all the methods that are subscribed to this event */
  invoke(...e) {
    if (this._isInvoking)
      return console.warn("Circular event invocation detected. Please check your event listeners for circular references.", this), !1;
    if (this.methods?.length <= 0) return !1;
    this._isInvoking = !0;
    try {
      this._methodsCopy.length = 0, this._methodsCopy.push(...this.methods);
      for (const t of this._methodsCopy)
        t.invoke(...e);
      if (typeof this.target == "object" && typeof this.key == "string") {
        const t = this.target.dispatchEvent;
        if (typeof t == "function") {
          const i = new Hm(this.key);
          i.args = e, t.call(this.target, i);
        }
      }
    } finally {
      this._isInvoking = !1, this._methodsCopy.length = 0;
    }
    return !0;
  }
  /** Add a new event listener to this event */
  addEventListener(e) {
    return this.methods.push(new Qs(e)), e;
  }
  removeEventListener(e) {
    if (e)
      for (let t = this.methods.length - 1; t >= 0; t--)
        this.methods[t].target === e && (this.methods[t].enabled = !1, this.methods.splice(t, 1));
  }
  removeAllEventListeners() {
    this.methods.length = 0;
  }
}
class qO extends Xi {
  constructor() {
    super([se, oe], "ColorSerializer");
  }
  onDeserialize(e) {
    if (e != null)
      return e.a !== void 0 ? new oe(e.r, e.g, e.b, e.a) : e.alpha !== void 0 ? new oe(e.r, e.g, e.b, e.alpha) : new se(e.r, e.g, e.b);
  }
  onSerialize(e) {
    if (e != null)
      return e.a !== void 0 ? { r: e.r, g: e.g, b: e.b, a: e.a } : { r: e.r, g: e.g, b: e.b };
  }
}
const JI = new qO();
class XO extends Xi {
  constructor() {
    super([Rt], "EulerSerializer");
  }
  onDeserialize(e, t) {
    if (e != null) {
      if (e.order)
        return new Rt(e.x, e.y, e.z, e.order);
      if (e.x != null)
        return new Rt(e.x, e.y, e.z);
    }
  }
  onSerialize(e, t) {
    return { x: e.x, y: e.y, z: e.z, order: e.order };
  }
}
const eL = new XO();
class QO extends Xi {
  constructor() {
    super(M, "ObjectSerializer");
  }
  onSerialize(e, t) {
    if (t.objectToNode !== void 0 && e.uuid) {
      const i = t.objectToNode[e.uuid];
      return dt && console.log(i, e.name, e.uuid), { node: i };
    }
  }
  onDeserialize(e, t) {
    if (typeof e == "string") {
      if (e.endsWith(".glb") || e.endsWith(".gltf")) {
        if (t.serializable instanceof Array && t.serializable.includes(ie))
          return;
        L() && ge("Detected wrong usage of @serializable with Object3D or GameObject. Instead you should use AssetReference here! Please see the console for details.");
        const i = t.target?.constructor?.name;
        console.warn(`Wrong usage of @serializable detected in your script "${i}"

It looks like you used @serializable(Object3D) or @serializable(GameObject) for a prefab or scene reference which is exported to a separate glTF file.

To fix this please change your code to:

@serializable(AssetReference)
${t.path}! : AssetReference;
\0`);
      }
      return;
    }
    if (e) {
      if (e.node !== void 0 && t.nodeToObject) {
        const i = t.nodeToObject[e.node];
        return dt && console.log("Deserialized object reference?", e, i, t?.nodeToObject), i || console.warn("Did not find node: " + e.node, t.nodeToObject, t.object), i;
      } else if (e.guid) {
        if (!t.context) {
          console.error("Missing context");
          return;
        }
        let i;
        const n = t.gltf?.scene;
        return n && (i = S.findByGuid(e.guid, n)), i || (i = S.findByGuid(e.guid, t.context.scene)), i ? (i && i.isComponent === !0 && (dt && console.warn("Deserialized object reference is a component"), i = i.gameObject), dt && console.log("Deserialized object reference?", e, i, t?.nodeToObject)) : ((L() || dt) && console.warn("Could not resolve object reference", t.path, e, t.target, t.context.scene), e.could_not_resolve = !0), i;
      }
    }
  }
}
const YO = new QO();
class KO extends Xi {
  constructor() {
    super([T, T], "ComponentSerializer");
  }
  onSerialize(e, t) {
    if (e?.guid)
      return { guid: e.guid };
  }
  onDeserialize(e, t) {
    if (e?.guid) {
      if (e.___persistentAsset) {
        dt && console.log("Skipping component deserialization because it's a persistent asset", e);
        return;
      }
      const i = t.path;
      dt && console.log(e.guid, t.root, t.object, t.target);
      let n = this.findObjectForGuid(e.guid, t.root);
      if (n || t.context && (n = this.findObjectForGuid(e.guid, t.context?.scene), n))
        return n;
      (L() || dt) && console.warn('Could not resolve component reference: "' + i + '" using guid ' + e.guid, t.target), e.could_not_resolve = !0;
      return;
    }
  }
  findObjectForGuid(e, t) {
    if (t.guid === e) return t;
    const i = S.foreachComponent(t, (n) => {
      if (n.guid === e) return n;
    }, !1);
    if (i !== void 0)
      return i;
    for (let n = 0; n < t.children.length; n++) {
      const o = t.children[n], r = this.findObjectForGuid(e, o);
      if (r) return r;
    }
  }
}
const _f = new KO();
class ZO extends Xi {
  constructor() {
    super([me]);
  }
  onSerialize(e, t) {
    console.log("TODO: SERIALIZE EVENT");
  }
  onDeserialize(e, t) {
    if (typeof e == "function")
      return new me([new Qs(e, null, [], !0)]);
    if (e && e.type === "EventList") {
      dt && console.log("DESERIALIZE EVENT", e);
      const i = new Array();
      if (e.calls && Array.isArray(e.calls))
        for (const r of e.calls) {
          let a = function(h) {
            if (typeof h == "object") {
              let d = YO.onDeserialize(h, t);
              if (d || (d = _f.onDeserialize(h, t)), d) return d;
            }
            return h;
          };
          dt && console.log(r);
          let l = _f.findObjectForGuid(r.target, t.root);
          !l && t.context?.scene && (l = _f.findObjectForGuid(r.target, t.context?.scene));
          const c = r.method?.length > 0;
          if (l && c) {
            const h = () => {
              const f = r.method[0].toUpperCase() + r.method.slice(1);
              if (typeof l[f] == "function") {
                console.warn(`EventList method:
Could not find method ${r.method} on object ${l.name}. Please rename ${r.method} to ${f}?
`, l[f], `
 in script: `, l), ge("EventList methods must start with lowercase letter, see console for details");
                return;
              } else
                console.warn(`EventList method:
Could not find method ${r.method} on object ${l.name}`, l, typeof l[r.method]);
            };
            if (typeof l[r.method] != "function") {
              let f = !1, p = l;
              for (; p; ) {
                const g = Object.getOwnPropertyDescriptor(p, r.method);
                if (g && (g.writable === !0 || g.set)) {
                  f = !0;
                  break;
                }
                p = Object.getPrototypeOf(p);
              }
              !f && (L() || dt) && h();
            }
          }
          if (l) {
            let h = r.argument;
            if (h !== void 0 ? h = a(h) : r.arguments !== void 0 && (h = r.arguments.map(a)), !l[r.method])
              console.warn(`EventList method not found: "${r.method}" on ${l?.name}`);
            else {
              h !== void 0 && !Array.isArray(h) && (h = [h]);
              const f = new Qs(l, r.method, h, r.enabled);
              i.push(f);
            }
          } else L() && console.warn(`[Dev] EventList: Could not find event listener in scene (${t.object?.name})`, r);
        }
      const n = new me(i);
      dt && console.log(n);
      const o = t.target;
      return o !== void 0 && t.path !== void 0 && n.setEventTarget(t.path, o), n;
    }
  }
  // private createEventMethod(target: object, methodName: string, args?: any): Function | undefined {
  //     return function (...forwardedArgs: any[]) {
  //         const method = target[methodName];
  //         if (typeof method === "function") {
  //             if (args !== undefined) {
  //                 // we now have support for creating event methods with multiple arguments
  //                 // an argument can not be an array right now - so if we receive an array we assume it's the array of arguments that we want to call the method with
  //                 // this means ["test", true] will invoke the method like this: myFunction("test", true) 
  //                 if (Array.isArray(args))
  //                     method?.call(target, ...args);
  //                 // in any other case (when we just have one argument) we just call the method with the argument
  //                 // we can not use ...args by default becaue that would break string arguments (it would then just use the first character)
  //                 else
  //                     method?.call(target, args);
  //             }
  //             else // support invoking EventList with any number of arguments (if none were declared in unity)
  //                 method?.call(target, ...forwardedArgs);
  //         }
  //         else // the target "method" can be a property too
  //         {
  //             target[methodName] = args;
  //         }
  //     };
  // }
}
const tL = new ZO(), dd = /* @__PURE__ */ new WeakMap(), JO = Te.prototype.clone;
Te.prototype.clone = function() {
  const s = JO.call(this);
  return dd.has(s) || dd.set(s, this), s;
};
class ek extends Xi {
  constructor() {
    super([fs, Dn]);
  }
  onSerialize(e, t) {
  }
  onDeserialize(e, t) {
    if (e instanceof Te && t.type === fs) {
      let i = e;
      dd.has(i) && (i = dd.get(i)), i.isRenderTargetTexture = !0, i.flipY = !0, i.offset.y = 1, i.repeat.y = -1, i.needsUpdate = !0, i.mipmaps = [], i instanceof rx && (i.isCompressedTexture = !1, i.format = Ld);
      const n = new fs(i.image.width, i.image.height, {
        colorSpace: Ss
      });
      return n.texture = i, n;
    }
  }
}
new ek();
class tk extends Xi {
  constructor() {
    super([URL]);
  }
  onSerialize(e, t) {
    return null;
  }
  onDeserialize(e, t) {
    if (typeof e == "string" && e.length > 0)
      return fr(t.gltfId, e);
  }
}
new tk();
var ik = Object.defineProperty, nk = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && ik(e, t, n), n;
};
class Sa extends T {
  awake() {
    Jt.createIfNoneExists(this.context);
  }
  onEnable() {
    Jt.get(this.context)?.register(this);
  }
  onDisable() {
    Jt.get(this.context)?.unregister(this);
  }
}
class Vi extends Sa {
  targets = null;
  raycastHits = [];
  ignoreSkinnedMeshes = !1;
  start() {
    this.targets = [this.gameObject];
  }
  performRaycast(e = null) {
    if (!this.targets) return null;
    e ??= new mr(), e.targets = this.targets, e.results = this.raycastHits, e.useAcceleratedRaycast = !0;
    const t = e.testObject;
    this.ignoreSkinnedMeshes && (e.testObject = (n) => n instanceof ys ? "continue in children" : t ? t(n) : !0);
    const i = this.context.physics.raycast(e);
    return e.testObject = t, i;
  }
}
nk([
  u()
], Vi.prototype, "ignoreSkinnedMeshes");
class Gm extends Vi {
  // eventCamera: Camera | null = null;
  // ignoreReversedGraphics: boolean = false;
  // rootRaycaster: GraphicRaycaster | null = null;
  constructor() {
    super(), this.ignoreSkinnedMeshes = !0;
  }
}
class Ca extends Sa {
  /**
   * Use to disable SpatialGrabRaycaster globally
   */
  static allow = !0;
  performRaycast(e) {
    if (!K.active || !Ca.allow || !e?.ray) return null;
    const t = e.ray.origin;
    return this.context.physics.sphereOverlap(t, 0.015, !1, !0);
  }
}
class V0 {
  /** returns the real object when dealing with shadow UI */
  static getObject(e) {
    const t = e[ci];
    return t && (t.isComponent === !0 ? e = t.gameObject : e = t), e;
  }
  static isInteractable(e, t) {
    if (t && (t.canvasGroup = void 0, t.graphic = void 0), e == null || !e.visible || (e = this.getObject(e), !e.visible)) return !1;
    const i = this.tryFindCanvasGroup(e);
    if (i?.isCanvasGroup === !0 && (t && (t.canvasGroup = i), i.blocksRaycasts === !1 || i.interactable === !1))
      return !1;
    const n = ba(e, (o) => {
      if (o.isGraphic === !0) return o;
    }, !1);
    return t && n?.isGraphic === !0 && (t.graphic = n), !(n?.raycastTarget === !1 || n?.layer === 2);
  }
  static tryFindCanvasGroup(e) {
    if (!e) return null;
    const t = ba(e, (i) => {
      const n = i;
      if (n.blocksRaycasts !== void 0 && n.interactable !== void 0) return n;
    }, !1);
    return t !== void 0 ? t : this.tryFindCanvasGroup(e.parent);
  }
}
function qm(s) {
  const e = s[ci];
  return e || (s.parent ? qm(s.parent) : null);
}
function sk(s) {
  return s.isUI === !0 || typeof s[ci] == "object";
}
function ud(s, e) {
  if (!s) return;
  const t = s.material;
  if (t?.isMaterial === !0) {
    const i = s.parent;
    i && i.isText, t.side = e.doubleSided ?? !0 ? yi : co, t.shadowSide = e.doubleSided ? yi : co, s.castShadow = e.castShadows ? e.castShadows : !1, s.receiveShadow = e.receiveShadows ? e.receiveShadows : !1;
  }
  for (const i of s.children)
    ud(i, e);
}
function zr(s, e, t) {
  s[e] === void 0 && console.warn("Field", e, "is undefined on", s);
  const i = Proxy.revocable(s[e], {
    // get(target, prop, receiver) {
    //     return Reflect.get(target, prop, receiver);
    // },
    set(r, a, l, c) {
      const h = r[a], d = Reflect.set(r, a, l, c);
      return t(l, h), d;
    }
  }), n = i.revoke, o = s[e];
  return i.revoke = () => {
    s[e] = o, n();
  }, s[e] = i.proxy, i;
}
const d_ = Symbol("Scheduled action");
function ok(s, e, t = xe.OnBeforeRender) {
  let i = s[d_];
  i || (i = s[d_] = {});
  const n = e.name;
  i[t] || (i[t] = {});
  const o = i[t];
  if (o[n]) return;
  function* a() {
    e?.call(s), o[n] = null;
  }
  const l = s.startCoroutine(a(), t);
  o[n] = l;
}
const Hs = w("debugeventsystem");
var Dp = /* @__PURE__ */ ((s) => (s.BeforeHandleInput = "BeforeHandleInput", s.AfterHandleInput = "AfterHandleInput", s))(Dp || {});
wO((s) => {
  Jt.createIfNoneExists(s);
});
class Jt extends T {
  //@ts-ignore
  static ensureUpdateMeshUI(e, t, i = !1) {
    il.update(e, t, i);
  }
  static markUIDirty(e) {
    il.markDirty();
  }
  static createIfNoneExists(e) {
    e.scene.getComponent(Jt) || e.scene.addComponent(Jt);
  }
  static get(e) {
    return this.createIfNoneExists(e), e.scene.getComponent(Jt);
  }
  /** Get the currently active event system */
  static get instance() {
    return this.get(N.Current);
  }
  raycaster = [];
  register(e) {
    e && this.raycaster && !this.raycaster.includes(e) && this.raycaster?.push(e);
  }
  unregister(e) {
    const t = this.raycaster?.indexOf(e);
    t !== void 0 && t !== -1 && this.raycaster?.splice(t, 1);
  }
  get hasActiveUI() {
    return this.currentActiveMeshUIComponents.length > 0;
  }
  get isHoveringObjects() {
    return this.hoveredByID.size > 0;
  }
  awake() {
    this.gameObject !== this.context.scene && (console.debug(`[Needle Engine] EventSystem is only allowed on the scene root. Disabling EventSystem on '${this.gameObject.name}'`), this.enabled = !1);
  }
  start() {
    this.context.scene.getComponent(Sa) || this.context.scene.addComponent(Vi);
  }
  onEnable() {
    this.context.input.addEventListener(De.PointerDown, this.onPointerEvent), this.context.input.addEventListener(De.PointerUp, this.onPointerEvent), this.context.input.addEventListener(De.PointerMove, this.onPointerEvent);
  }
  onDisable() {
    this.context.input.removeEventListener(De.PointerDown, this.onPointerEvent), this.context.input.removeEventListener(De.PointerUp, this.onPointerEvent), this.context.input.removeEventListener(De.PointerMove, this.onPointerEvent);
  }
  /**
   * all pointers that have pressed something
   * 
   * key: pointerId
   * value: object that was pressed, data of the pointer event, handlers that are releavant to the event
  */
  pressedByID = /* @__PURE__ */ new Map();
  /**
   * all hovered objects
   * 
   * key: pointerId
   * value: object that is hovered, data of the pointer event
   */
  hoveredByID = /* @__PURE__ */ new Map();
  onBeforeRender() {
    this.resetMeshUIStates();
  }
  /**
   * Handle an pointer event from the input system
   */
  onPointerEvent = (e) => {
    if (e === void 0 || e.propagationStopped || e.defaultPrevented || e.used) return;
    const t = new eu(this.context.input, e);
    this._currentPointerEventName = e.type, t.inputSource = this.context.input, t.isClick = e.isClick, t.isDoubleClick = e.isDoubleClick, t.isDown = e.type == De.PointerDown, t.isUp = e.type == De.PointerUp, t.isPressed = this.context.input.getPointerPressed(e.pointerId);
    const i = new mr();
    e.hasRay ? i.ray = e.ray : i.screenPoint = this.context.input.getPointerPositionRC(e.pointerId), i.allowSlowRaycastFallback = e.isClick || e.isDoubleClick;
    const n = this.performRaycast(i);
    if (Hs && (t.isDown ? console.log("DOWN", { id: t.pointerId, hits: n.length }) : t.isUp && console.log("UP", { id: t.pointerId, hits: n.length }), t.isClick && console.log("CLICK", { id: t.pointerId, hits: n.length })), n) {
      for (const r of n)
        r.event = e, e.intersections.push(r);
      e.origin.onPointerHits && e.origin.onPointerHits({
        sender: this,
        event: e,
        hits: n
      });
    }
    Hs && t.isClick && Be("EventSystem: " + t.pointerId + " - " + this.context.time.frame + " - Up:" + t.isUp + ", Down:" + t.isDown);
    const o = {
      sender: this,
      args: t,
      hasActiveUI: this.currentActiveMeshUIComponents.length > 0
    };
    this.dispatchEvent(new CustomEvent("BeforeHandleInput", { detail: o })), this.handleIntersections(n, t), this.dispatchEvent(new CustomEvent("AfterHandleInput", { detail: o }));
  };
  _sortedHits = [];
  /** 
   * cache for objects that we want to raycast against. It's cleared before each call to performRaycast invoking raycasters
   */
  _testObjectsCache = /* @__PURE__ */ new Map();
  /** that's the raycaster that is CURRENTLY being used for raycasting (the shouldRaycastObject method uses this) */
  _currentlyActiveRaycaster = null;
  _currentPointerEventName = null;
  /** 
   * Checks if an object that we encounter has an event component and if it does, we add it to our objects cache
   * If it doesnt we tell our raycasting system to ignore it and continue in the child hierarchy
   * We do this to avoid raycasts against objects that are not going to be used by the event system
   * Because there's no component callback to be invoked anyways. 
   * This is especially important to avoid expensive raycasts against SkinnedMeshes
   * 
   * Further optimizations would be to check what type of event we're dealing with
   * For example if an event component has only an onPointerClick method we don't need to raycast during movement events
   * */
  shouldRaycastObject = (e) => {
    const t = e && "getComponent" in e ? e.getComponent(Sa) : null;
    if (t && t != this._currentlyActiveRaycaster)
      return !1;
    let i = null;
    if (sk(e) && (i = e[ci]?.gameObject), this._testObjectsCache.has(e) || i && this._testObjectsCache.has(i))
      return this._testObjectsCache.get(e) === !1 ? "continue in children" : !0;
    {
      let o = Lp(e, this._currentPointerEventName);
      if (!o && i && (o = Lp(i, this._currentPointerEventName)), o) {
        this._testObjectsCache.set(e, !0);
        for (const r of e.children) this.shouldRaycastObject_AddToYesCache(r);
        return !0;
      }
      return this._testObjectsCache.set(e, !1), "continue in children";
    }
  };
  shouldRaycastObject_AddToYesCache(e) {
    this._testObjectsCache.set(e, !0);
    for (const t of e.children)
      this.shouldRaycastObject_AddToYesCache(t);
  }
  /** the raycast filter is always overriden */
  performRaycast(e) {
    if (!this.raycaster) return null;
    this._testObjectsCache.clear(), this._sortedHits.length = 0, e.testObject = this.shouldRaycastObject;
    for (const t of this.raycaster) {
      if (!t.activeAndEnabled) continue;
      this._currentlyActiveRaycaster = t;
      const i = t.performRaycast(e);
      this._currentlyActiveRaycaster = null, i && i.length > 0 && this._sortedHits.push(...i);
    }
    return this._sortedHits.sort((t, i) => t.distance - i.distance), this._sortedHits;
  }
  assignHitInformation(e, t) {
    t ? (e.intersection = t, e.point = t.point, e.normal = t.normal, e.face = t.face, e.distance = t.distance, e.instanceId = t.instanceId) : (e.intersection = void 0, e.point = void 0, e.normal = void 0, e.face = void 0, e.distance = void 0, e.instanceId = void 0);
  }
  handleIntersections(e, t) {
    if (e?.length) {
      e = this.sortCandidates(e);
      for (const n of e) {
        if (t.event.immediatePropagationStopped)
          return !1;
        if (this.assignHitInformation(t, n), this.handleEventOnObject(n.object, t))
          return !0;
      }
    }
    this.assignHitInformation(t, e?.[0]), this.invokePointerCapture(t);
    const i = this.hoveredByID.get(t.pointerId);
    return i && this.propagatePointerExit(i.obj, i.data, null), this.hoveredByID.delete(t.pointerId), t.isUp && (this.pressedByID.get(t.pointerId)?.handlers.forEach((n) => this.invokeOnPointerUp(t, n)), this.pressedByID.delete(t.pointerId)), !1;
  }
  _sortingBuffer = [];
  _noDepthTestingResults = [];
  sortCandidates(e) {
    this._sortingBuffer.length = 0, this._noDepthTestingResults.length = 0;
    for (let t = 0; t < e.length; t++) {
      const i = e[t], n = i.object;
      if (n.material && n.material.depthTest === !1) {
        this._noDepthTestingResults.push(i);
        continue;
      }
      this._sortingBuffer.push(i);
    }
    for (const t of this._sortingBuffer)
      this._noDepthTestingResults.push(t);
    return this._noDepthTestingResults;
  }
  out = {};
  /** 
   * Handle hit result by preparing all needed information before propagation.
   * Then calling propagate.
   */
  handleEventOnObject(e, t) {
    if (!this.testIsVisible(e))
      return t.isClick && Hs && console.log("not allowed", e), !1;
    if (t.pointerId === void 0)
      return Hs && console.error("Event without pointer can't be handled", t), !1;
    t.object = e;
    const i = e.parent, n = t.isClick ?? !1;
    let o = null;
    if (i && i.isUI) {
      const h = (t.isPressed || t.isClick) ?? !1;
      if (i[ci]) {
        const d = i[ci].gameObject;
        if (d) {
          if (!V0.isInteractable(d, this.out)) return !1;
          o = this.out.canvasGroup ?? null, this.handleMeshUIIntersection(e, h), e = d;
        }
      }
    }
    n && Hs && console.log(this.context.time.frame, e);
    const r = this.hoveredByID.get(t.pointerId), a = r?.obj;
    a !== e && a && this.propagatePointerExit(a, r.data, e);
    const c = this.hoveredByID.get(t.pointerId);
    if (c ? (c.obj = e, c.data = t) : this.hoveredByID.set(t.pointerId, { obj: e, data: t }), t.isDown) {
      const h = this.pressedByID.get(t.pointerId);
      h ? (h.obj = e, h.data = t) : this.pressedByID.set(t.pointerId, { obj: e, data: t, handlers: /* @__PURE__ */ new Set() });
    }
    return (o === null || o.interactable) && this.handleMainInteraction(e, t, a ?? null), !0;
  }
  /**
   * Propagate up in hiearchy and call the callback for each component that is possibly a handler
   */
  propagate(e, t) {
    for (; e; )
      S.foreachComponent(e, (i) => {
        t(i);
      }, !1), e = e.parent;
  }
  /**
   * Propagate up in hierarchy and call handlers based on the pointer event data
   */
  handleMainInteraction(e, t, i) {
    const n = this.pressedByID.get(t.pointerId), o = i !== e;
    let r = !0;
    switch (t.event.pointerType) {
      case "mouse":
      case "touch":
        const a = this.context.input.getPointerPositionLastFrame(t.pointerId), l = this.context.input.getPointerPosition(t.pointerId);
        r = a && !j.approximately(a, l);
        break;
    }
    this.propagate(e, (a) => {
      const l = a;
      l.interactable !== !1 && (!l.activeAndEnabled || !l.enabled || (l.onPointerEnter && o && this.handlePointerEnter(l, t), t.isDown && l.onPointerDown && (l.onPointerDown(t), n?.handlers.add(l), this.handlePointerCapture(t, l)), l.onPointerMove && (r && l.onPointerMove(t), this.handlePointerCapture(t, l)), t.isUp && (l.onPointerUp && (this.invokeOnPointerUp(t, l), n?.handlers.delete(l)), l.onPointerExit && t.event?.pointerType === km.Touch && (this.handlePointerExit(l, t), this.hoveredByID.delete(t.pointerId))), t.isClick && l.onPointerClick && l.onPointerClick(t)));
    }), t.isUp && (n?.handlers.forEach((a) => {
      this.invokeOnPointerUp(t, a);
    }), this.pressedByID.delete(t.pointerId));
  }
  /** Propagate up in hierarchy and call onPointerExit */
  propagatePointerExit(e, t, i) {
    this.propagate(e, (n) => {
      if (!n.gameObject || n.destroyed) return;
      const o = n;
      if (o.onPointerExit || o.onPointerEnter) {
        if (i && this.isChild(i, n.gameObject))
          return;
        this.handlePointerExit(o, t);
      }
    });
  }
  /** handles onPointerUp - this will also release the pointerCapture */
  invokeOnPointerUp(e, t) {
    t.onPointerUp?.call(t, e), this.releasePointerCapture(e, t);
  }
  /** Responsible for invoking onPointerEnter (and updating onPointerExit). We invoke onPointerEnter once per active pointerId */
  handlePointerEnter(e, t) {
    e.onPointerEnter && this.updatePointerState(e, t.pointerId, this.pointerEnterSymbol, !0) && e.onPointerEnter(t), this.updatePointerState(e, t.pointerId, this.pointerExitSymbol, !1);
  }
  /** Responsible for invoking onPointerExit (and updating onPointerEnter). We invoke onPointerExit once per active pointerId */
  handlePointerExit(e, t) {
    e.onPointerExit && this.updatePointerState(e, t.pointerId, this.pointerExitSymbol, !0) && e.onPointerExit(t), this.updatePointerState(e, t.pointerId, this.pointerEnterSymbol, !1);
  }
  /** updates the pointer state list for a component
   * @param comp the component to update
   * @param pointerId the pointerId to update
   * @param symbol the symbol to use for the state
   * @param add if true, the pointerId is added to the state list, if false the pointerId will be removed
   */
  updatePointerState(e, t, i, n) {
    let o = e[i];
    if (n)
      return o && o.includes(t) ? !1 : (o = o || [], o.push(t), e[i] = o, !0);
    {
      if (!o || !o.includes(t)) return !1;
      const r = o.indexOf(t);
      return r !== -1 && o.splice(r, 1), !0;
    }
  }
  /** the list of component handlers that requested pointerCapture for a specific pointerId */
  _capturedPointer = {};
  /** check if the event was marked to be captured: if yes add the current component to the captured list */
  handlePointerCapture(e, t) {
    if (e.z__pointer_ctured) {
      e.z__pointer_ctured = !1;
      const i = e.pointerId;
      if (t.onPointerMove) {
        const n = this._capturedPointer[i] || [];
        n.push(t), this._capturedPointer[i] = n;
      } else
        L() && !t.z__warned_no_pointermove && (t.z__warned_no_pointermove = !0, console.warn("PointerCapture was requested but the component doesn't implement onPointerMove. It will not receive any pointer events"));
    } else e.z__pointer_cture_rleased && (e.z__pointer_cture_rleased = !1, this.releasePointerCapture(e, t));
  }
  /** removes the component from the pointer capture list */
  releasePointerCapture(e, t) {
    const i = e.pointerId;
    if (this._capturedPointer[i]) {
      const n = this._capturedPointer[i].indexOf(t);
      n !== -1 && (this._capturedPointer[i].splice(n, 1), Hs && console.log("released pointer capture", i, t, this._capturedPointer));
    }
  }
  /** invoke the pointerMove event on all captured handlers */
  invokePointerCapture(e) {
    if (e.event.type === De.PointerMove) {
      const t = e.pointerId, i = this._capturedPointer[t];
      if (i) {
        Hs && console.log("Captured", t, i);
        for (let n = 0; n < i.length; n++) {
          const o = i[n];
          if (o.destroyed) {
            i.splice(n, 1), n--;
            continue;
          }
          o.onPointerMove?.call(o, e);
        }
      }
    }
  }
  pointerEnterSymbol = Symbol("pointerEnter");
  pointerExitSymbol = Symbol("pointerExit");
  isChild(e, t) {
    return !e || !t ? !1 : e === t ? !0 : e.parent ? this.isChild(e.parent, t) : !1;
  }
  handleMeshUiObjectWithoutShadowDom(e, t) {
    return !e || !e.isUI ? !0 : this.handleMeshUIIntersection(e, t);
  }
  currentActiveMeshUIComponents = [];
  handleMeshUIIntersection(e, t) {
    const i = il.updateState(e, t);
    return i && this.currentActiveMeshUIComponents.push(i), i !== null;
  }
  resetMeshUIStates() {
    if (this.context.input.getPointerPressedCount() > 0 && il.resetLastSelected(), !(!this.currentActiveMeshUIComponents || this.currentActiveMeshUIComponents.length <= 0)) {
      for (let e = 0; e < this.currentActiveMeshUIComponents.length; e++) {
        const t = this.currentActiveMeshUIComponents[e];
        il.resetState(t);
      }
      this.currentActiveMeshUIComponents.length = 0;
    }
  }
  testIsVisible(e) {
    return e ? S.isActiveSelf(e) ? this.testIsVisible(e.parent) : !1 : !0;
  }
}
class il {
  static lastSelected = null;
  static lastUpdateFrame = [];
  static needsUpdate = !1;
  static markDirty() {
    this.needsUpdate = !0;
  }
  static update(e, t, i = !1) {
    if (i) {
      e.update();
      return;
    }
    const n = t.time.frameCount;
    for (const o of this.lastUpdateFrame)
      if (o.context === t) {
        if (n === o.frame) return;
        o.frame = n;
        let r = this.needsUpdate || n < 1;
        o.nextUpdate <= n && (r = !0), r && (Hs && console.log("Update threemeshui"), this.needsUpdate = !1, o.nextUpdate = n + 60, e.update());
        return;
      }
    this.lastUpdateFrame = [{ context: t, frame: n, nextUpdate: n + 60 }], e.update(), this.needsUpdate = !1;
  }
  static updateState(e, t) {
    let i = null;
    if (e && (i = this.findBlockOrTextInParent(e), i && i !== this.lastSelected)) {
      if (i.interactable === !1) return null;
      this.needsUpdate = !0;
    }
    return i;
  }
  static resetLastSelected() {
    const e = this.lastSelected;
    e && (this.lastSelected = null, this.resetState(e));
  }
  static resetState(e) {
    e && (this.needsUpdate = !0);
  }
  static findBlockOrTextInParent(e) {
    return e ? e.isBlock || e.isText ? e : this.findBlockOrTextInParent(e.parent) : null;
  }
}
var rk = Object.defineProperty, Ee = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && rk(e, t, n), n;
};
const Ai = w("debugorbit"), bf = w("freecam"), nl = w("debugcamerafit"), ah = w("smoothcam"), ak = { LEFT: "", UP: "", RIGHT: "", BOTTOM: "" };
let vf;
class fd extends CustomEvent {
  constructor(e, t) {
    super("target-reached", {
      detail: {
        controls: e,
        type: t
      }
    });
  }
}
class ye extends T {
  /**
   * @inheritdoc
   */
  get isCameraController() {
    return !0;
  }
  /** The underlying three.js OrbitControls.   
   * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls}
   * @returns {@type ThreeOrbitControls | null}
  */
  get controls() {
    return this._controls;
  }
  /** The object being controlled by the OrbitControls (usually the camera)  
   * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls.object}
   * @returns {@type Object3D | null}
  */
  get controllerObject() {
    return this._cameraObject;
  }
  /** Register callback when user starts interacting with the orbit controls */
  onStartInteraction(e) {
    this.controls?.addEventListener("start", e);
  }
  autoTarget = !0;
  autoFit = !1;
  enableRotate = !0;
  autoRotate = !1;
  autoRotateSpeed = 1;
  minAzimuthAngle = 1 / 0;
  maxAzimuthAngle = 1 / 0;
  minPolarAngle = 0;
  maxPolarAngle = Math.PI;
  enableKeys = !1;
  enableDamping = !0;
  dampingFactor = 0.1;
  enableZoom = !0;
  minZoom = 0;
  maxZoom = 1 / 0;
  zoomSpeed = 1;
  /**
   * Set to true to enable zooming to the cursor position.  
   * @default false
   */
  zoomToCursor = !1;
  enablePan = !0;
  lookAtConstraint = null;
  lookAtConstraint01 = 1;
  allowInterrupt = !0;
  middleClickToFocus = !0;
  doubleClickToFocus = !0;
  clickBackgroundToFitScene = 2;
  /**
   * This is the DOM element that the OrbitControls will listen to for input events. By default this is the renderer's canvas element.  
   * Set this to a different element to make the OrbitControls listen to that element instead.  
   */
  get targetElement() {
    return this._controls?.domElement ?? this._targetElement;
  }
  set targetElement(e) {
    this._targetElement = e, this._controls && this._controls.domElement !== e && (this._controls.disconnect(), this._controls.domElement = e, this._controls.connect());
  }
  _targetElement = null;
  /** 
   * @internal If true debug information will be logged to the console
   * @default false
   */
  debugLog = !1;
  /** 
   * @deprecated use `targetLerpDuration` instead  
   * ~~The speed at which the camera target and the camera will be lerping to their destinations (if set via script or user input)~~ 
   * */
  get targetLerpSpeed() {
    return 5;
  }
  set targetLerpSpeed(e) {
    this.targetLerpDuration = 1 / e;
  }
  targetLerpDuration = 1;
  /**
   * Rotate the camera left (or right) by the specified angle in radians.   
   * For positive angles the camera will rotate to the left, for negative angles it will rotate to the right.  
   * Tip: Use Mathf to convert between degrees and radians.
   * @param angleInRadians The angle in radians to rotate the camera left
   * @example
   * ```typescript
   * // Rotate the camera left by 0.1 radians
   * orbitControls.rotateLeft(0.1);
   * ```
   */
  rotateLeft(e) {
    this._controls?._rotateLeft(e);
  }
  /**
   * Rotate the camera up (or down) by the specified angle in radians.  
   * For positive angles the camera will rotate up, for negative angles it will rotate down.
   * Tip: Use Mathf to convert between degrees and radians.
   * @param angleInRadians The angle in radians to rotate the camera up
   * @example
   * ```typescript
   * // Rotate the camera up by 0.1 radians
   * orbitControls.rotateUp(0.1);
   * ```
   */
  rotateUp(e) {
    this._controls?._rotateUp(e);
  }
  /**
   * Pan the camera by the specified amount in the x and y direction in pixels.
   * @param dx The amount to pan the camera in the x direction in pixels.
   * @param dy The amount to pan the camera in the y direction in pixels.
   */
  pan(e, t) {
    this._controls?._pan(e, t);
  }
  /**
   * Zoom the camera in or out by the specified scale factor. The factor is applied to the current zoom radius / distance.
   * If the scale is greater than 0 then the camera will zoom in, if it is less than 0 then the camera will zoom out. 
   * @param scale The scale factor to zoom the camera in or out. Expected range is between -1 and 1, where 0 means no zoom.
   * @example
   * ```typescript
   * // Zoom in by 0.1
   * orbitControls.zoomIn(0.1);
   * // Zoom out by 0.1
   * orbitControls.zoomIn(-0.1);
   * ```
   */
  zoomIn(e) {
    e > 0 ? this._controls?._dollyIn(1 - e) : e < 0 && this._controls?._dollyOut(1 + e);
  }
  _controls = null;
  _cameraObject = null;
  _lookTargetLerpActive = !1;
  _lookTargetStartPosition = new b();
  _lookTargetEndPosition = new b();
  _lookTargetLerp01 = 0;
  _lookTargetLerpDuration = 0;
  _cameraLerpActive = !1;
  _cameraStartPosition = new b();
  _cameraEndPosition = new b();
  _cameraLerp01 = 0;
  _cameraLerpDuration = 0;
  _fovLerpActive = !1;
  _fovLerpStartValue = 0;
  _fovLerpEndValue = 0;
  _fovLerp01 = 0;
  _fovLerpDuration = 0;
  _inputs = 0;
  _enableTime = 0;
  // use to disable double click when double clicking on UI
  _startedListeningToKeyEvents = !1;
  _eventSystem;
  _afterHandleInputFn;
  _camera = null;
  _syncedTransform;
  _didSetTarget = 0;
  /** @internal */
  awake() {
    Ai && console.debug("OrbitControls", this), this._didSetTarget = 0, this._startedListeningToKeyEvents = !1;
  }
  /** @internal */
  start() {
    this._eventSystem = Jt.get(this.context) ?? void 0, this._eventSystem && (this._afterHandleInputFn = this.afterHandleInput.bind(this), this._eventSystem.addEventListener(Dp.AfterHandleInput, this._afterHandleInputFn));
  }
  /** @internal */
  onDestroy() {
    this._controls?.dispose(), this._eventSystem?.removeEventListener(Dp.AfterHandleInput, this._afterHandleInputFn);
  }
  /** @internal */
  onEnable() {
    this._didSetTarget = 0, this._enableTime = this.context.time.time;
    const e = S.getComponent(this.gameObject, ui);
    this._camera = e;
    let t = e?.threeCamera;
    if (!t && this.gameObject instanceof pe && (t = this.gameObject), t && cy(t, this, !0), !this._controls && t instanceof M) {
      this._cameraObject = t;
      const i = this.targetElement ?? this.context.renderer.domElement, n = t?.quaternion.clone();
      this._controls = new vb(t, i), t?.quaternion.copy(n), vf === void 0 && (vf = { ...this._controls.keys });
      const o = Z(t), r = this.gameObject.worldForward, l = o.clone().sub(r.multiplyScalar(2.5));
      this._controls.target.copy(l);
    }
    if (this._controls)
      if (bf && (this.enablePan = !0, this.enableZoom = !0, this.middleClickToFocus = !0, X.isMobileDevice() && (this.doubleClickToFocus = !0)), this._controls.addEventListener("start", this.onControlsChangeStarted), this._controls.addEventListener("endMovement", this.onControlsChangeEnded), !this._startedListeningToKeyEvents && this.enableKeys)
        this._startedListeningToKeyEvents = !0, this._controls.listenToKeyEvents(this.context.domElement);
      else
        try {
          this._controls.stopListenToKeyEvents();
        } catch {
        }
    this._syncedTransform = S.getComponent(this.gameObject, Fn) ?? void 0, this.context.pre_render_callbacks.push(this.__onPreRender), this._activePointerEvents = [], this.context.input.addEventListener("pointerdown", this._onPointerDown, { queue: li.Early }), this.context.input.addEventListener("pointerdown", this._onPointerDownLate, { queue: li.Late }), this.context.input.addEventListener("pointerup", this._onPointerUp, { queue: li.Early }), this.context.input.addEventListener("pointerup", this._onPointerUpLate, { queue: li.Late });
  }
  /** @internal */
  onDisable() {
    if (this._camera?.threeCamera && cy(this._camera.threeCamera, this, !1), this._controls) {
      this._controls.enabled = !1, this._controls.autoRotate = !1, this._controls.removeEventListener("start", this.onControlsChangeStarted), this._controls.removeEventListener("endMovement", this.onControlsChangeEnded);
      try {
        this._controls.stopListenToKeyEvents();
      } catch {
      }
      this._startedListeningToKeyEvents = !1;
    }
    this._activePointerEvents.length = 0, this.context.input.removeEventListener("pointerdown", this._onPointerDown), this.context.input.removeEventListener("pointerdown", this._onPointerDownLate), this.context.input.removeEventListener("pointerup", this._onPointerUp), this.context.input.removeEventListener("pointerup", this._onPointerUpLate);
  }
  _activePointerEvents;
  _lastTimeClickOnBackground = -1;
  _clickOnBackgroundCount = 0;
  _onPointerDown = (e) => {
    this._activePointerEvents.push(e);
  };
  _onPointerDownLate = (e) => {
    e.used && this._controls && (this._controls.enabled = !1);
  };
  _onPointerUp = (e) => {
    for (let t = this._activePointerEvents.length - 1; t >= 0; t--) {
      const i = this._activePointerEvents[t];
      if (i.pointerId === e.pointerId && i.button === e.button) {
        this._activePointerEvents.splice(t, 1);
        break;
      }
    }
    if (this.clickBackgroundToFitScene > 0 && e.isClick && e.button === 0) {
      if (e.hasRay || e.intersections.push(...this.context.physics.raycast()), e.intersections.length <= 0) {
        const t = this.context.time.time - this._lastTimeClickOnBackground;
        this._lastTimeClickOnBackground = this.context.time.time, this.clickBackgroundToFitScene <= 1 || t < this.clickBackgroundToFitScene * 0.15 ? (this._clickOnBackgroundCount += 1, this._clickOnBackgroundCount >= this.clickBackgroundToFitScene - 1 && this.fitCamera(this.context.scene.children, {
          immediate: !1
        })) : this._clickOnBackgroundCount = 0;
      }
      Ai && console.log(this.clickBackgroundToFitScene, e.intersections.length, this._clickOnBackgroundCount);
    }
  };
  _onPointerUpLate = (e) => {
    this.doubleClickToFocus && e.isDoubleClick && !e.used && this.setTargetFromRaycast();
  };
  updateTargetNow(e) {
    const t = new lo(this._cameraObject?.worldPosition, this._cameraObject?.worldForward.multiplyScalar(-1)), i = this.context.physics.raycastFromRay(t, e), n = i.length > 0 ? i[0] : void 0;
    n && n.distance > this.minZoom && n.distance < this.maxZoom && (Ai && F.DrawWireSphere(n.point, 0.1, 16711680, 2), this._controls?.target.copy(i[0].point));
  }
  _orbitStartAngle = 0;
  _zoomStartDistance = 0;
  onControlsChangeStarted = () => {
    this._controls && (this._orbitStartAngle = this._controls.getAzimuthalAngle() + this._controls.getPolarAngle(), this._zoomStartDistance = this._controls.getDistance()), this._syncedTransform && this._syncedTransform.requestOwnership();
  };
  onControlsChangeEnded = () => {
    if (this._controls && this.autoTarget) {
      const t = this._controls.getAzimuthalAngle() + this._controls.getPolarAngle() - this._orbitStartAngle;
      Math.abs(t) < 0.01 ? (Ai && console.debug("OrbitControls: Update target", { deltaAngle: t }), this.updateTargetNow({ allowSlowRaycastFallback: !1 })) : Ai && console.debug("OrbitControls: No target update", { deltaAngle: t });
    }
  };
  _shouldDisable = !1;
  afterHandleInput(e) {
    e.detail.args.pointerId === 0 && (e.detail.args.isDown ? this._controls && this._eventSystem && (this._shouldDisable = this._eventSystem.hasActiveUI) : (!e.detail.args.isPressed || e.detail.args.isUp) && (this._shouldDisable = !1));
  }
  onPausedChanged(e) {
    this._controls && e && (this._controls.enabled = !1);
  }
  /** @internal */
  onBeforeRender() {
    if (!this._controls) return;
    if (this._cameraObject !== this.context.mainCamera) {
      this._controls.enabled = !1;
      return;
    }
    if (this._controls.enabled = !0, (this.context.input.getPointerDown(1) || this.context.input.getPointerDown(2) || this.context.input.mouseWheelChanged || this.context.input.getPointerPressed(0) && this.context.input.getPointerPositionDelta(0)?.length()) && (this._inputs += 1), this._inputs > 0 && this.allowInterrupt && (this.enableRotate && (this.autoRotate = !1), this._cameraLerpActive = !1, this._lookTargetLerpActive = !1), this._inputs = 0, this.autoTarget && this._didSetTarget++ === 0) {
      const t = S.getComponent(this.gameObject, ui);
      if (t && !this.setLookTargetFromConstraint()) {
        this.debugLog && console.log("NO TARGET");
        const i = Z(t.threeCamera), n = Math.max(0.01, i.length()), o = new b(0, 0, -n).applyMatrix4(t.threeCamera.matrixWorld);
        Ai && F.DrawLine(i, o, 5592575, 10), this.setLookTargetPosition(o, !0);
      }
      if (!this.setLookTargetFromConstraint()) {
        const i = new mr();
        i.screenPoint = new J(0, 0), i.lineThreshold = 0.1;
        const n = this.context.physics.raycast(i);
        n.length > 0 && this.setLookTargetPosition(n[0].point, !0), nl && console.log("OrbitControls hits", ...n);
      }
    }
    if (this.middleClickToFocus && this.context.input.getPointerClicked(1) && this.setTargetFromRaycast(), this._lookTargetLerpActive || this._cameraLerpActive || this._fovLerpActive) {
      if (this._cameraLerpActive && this._cameraObject)
        if (this._cameraLerp01 += this.context.time.deltaTime / this._cameraLerpDuration, this._cameraLerp01 >= 1)
          this._cameraObject.position.copy(this._cameraEndPosition), this._cameraLerpActive = !1, this.dispatchEvent(new fd(this, "camera"));
        else {
          const t = j.easeInOutCubic(this._cameraLerp01);
          this._cameraObject.position.lerpVectors(this._cameraStartPosition, this._cameraEndPosition, t);
        }
      if (this._lookTargetLerpActive)
        if (this._lookTargetLerp01 += this.context.time.deltaTime / this._lookTargetLerpDuration, this._lookTargetLerp01 >= 1)
          this.lerpLookTarget(this._lookTargetEndPosition, this._lookTargetEndPosition, 1), this._lookTargetLerpActive = !1, this.dispatchEvent(new fd(this, "lookat"));
        else {
          const t = j.easeInOutCubic(this._lookTargetLerp01);
          this.lerpLookTarget(this._lookTargetStartPosition, this._lookTargetEndPosition, t);
        }
      if (this._fovLerpActive && this._cameraObject) {
        const t = this._cameraObject;
        if (this._fovLerp01 += this.context.time.deltaTime / this._fovLerpDuration, this._fovLerp01 >= 1)
          t.fov = this._fovLerpEndValue, this._fovLerpActive = !1;
        else {
          const i = j.easeInOutCubic(this._fovLerp01);
          t.fov = j.lerp(this._fovLerpStartValue, this._fovLerpEndValue, i);
        }
        t.updateProjectionMatrix();
      }
    }
    if (this._controls) {
      if (this.debugLog && (this._controls.domElement = this.context.renderer.domElement), this._controls.enabled = !this._shouldDisable && this._camera === this.context.mainCameraComponent && !this.context.isInXR && !this._activePointerEvents.some((t) => t.used), this._controls.keys = this.enableKeys ? vf : ak, this._controls.autoRotate = this.autoRotate, this._controls.autoRotateSpeed = this.autoRotateSpeed, this._controls.enableZoom = this.enableZoom, this._controls.zoomSpeed = this.zoomSpeed, this._controls.zoomToCursor = this.zoomToCursor, this._controls.enableDamping = this.enableDamping, this._controls.dampingFactor = this.dampingFactor, this._controls.enablePan = this.enablePan, this._controls.enableRotate = this.enableRotate, this._controls.minAzimuthAngle = this.minAzimuthAngle, this._controls.maxAzimuthAngle = this.maxAzimuthAngle, this._controls.minPolarAngle = this.minPolarAngle, this._controls.maxPolarAngle = this.maxPolarAngle, bf || (this._camera?.threeCamera?.type === "PerspectiveCamera" ? (this._controls.minDistance = this.minZoom, this._controls.maxDistance = this.maxZoom, this._controls.minZoom = 0, this._controls.maxZoom = 1 / 0) : (this._controls.minDistance = 0, this._controls.maxDistance = 1 / 0, this._controls.minZoom = this.minZoom, this._controls.maxZoom = this.maxZoom)), typeof ah == "number" || ah === !0) {
        this._controls.enableDamping = !0;
        const t = typeof ah == "number" ? ah : 0.99;
        this._controls.dampingFactor = Math.max(1e-3, 1 - Math.min(1, t));
      }
      this.allowInterrupt || (this._lookTargetLerpActive && (this._controls.enablePan = !1), this._cameraLerpActive && (this._controls.enableRotate = !1, this._controls.autoRotate = !1), (this._lookTargetLerpActive || this._cameraLerpActive) && (this._controls.enableZoom = !1)), this.context.isInXR || (!bf && this.lookAtConstraint?.locked && !this._lookTargetLerpActive && this.setLookTargetFromConstraint(0, this.lookAtConstraint01), this._controls.update(this.context.time.deltaTime), Ai && F.DrawWireSphere(this._controls.target, 0.1, 65280));
    }
  }
  __onPreRender = () => {
    const e = this.context.pre_render_callbacks.indexOf(this.__onPreRender);
    e >= 0 && this.context.pre_render_callbacks.splice(e, 1), this.autoFit && (this.autoFit = !1, this.fitCamera({
      centerCamera: "y",
      immediate: !0,
      objects: this.scene.children
    }));
  };
  /** 
   * Sets camera target position and look direction using a raycast in forward direction of the object.  
   * 
   * @param source The object to raycast from. If a camera is passed in the camera position will be used as the source.
   * @param immediateOrDuration If true the camera target will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
   * 
   * This is useful for example if you want to align your camera with an object in your scene (or another camera). Simply pass in this other camera object
   * @returns true if the target was set successfully
   */
  setCameraAndLookTarget(e, t = !1) {
    if (!e)
      return (L() || Ai) && console.warn("[OrbitControls] setCameraAndLookTarget target is null"), !1;
    if (!(e instanceof M) && !(e instanceof ui))
      return (L() || Ai) && console.warn("[OrbitControls] setCameraAndLookTarget target is not an Object3D or Camera"), !1;
    e instanceof ui && (e = e.gameObject);
    const i = e.worldPosition, n = e.worldForward;
    e instanceof ax && (Ai && console.debug("[OrbitControls] setCameraAndLookTarget flip forward direction for camera"), n.multiplyScalar(-1));
    const o = new lo(i, n);
    return Ai && F.DrawRay(o.origin, o.direction, 16711680, 10), this.setTargetFromRaycast(o, t) || this.setLookTargetPosition(o.at(2, G()), t), this.setCameraTargetPosition(i, t), !0;
  }
  /** Moves the camera to position smoothly. 
   * @param position The position in local space of the controllerObject to move the camera to. If null the camera will stop lerping to the target.
   * @param immediateOrDuration If true the camera will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
  */
  setCameraTargetPosition(e, t = !1) {
    e && (e instanceof M && (e = Z(e)), this._cameraEndPosition || (this._cameraEndPosition = new b()), this._cameraEndPosition.copy(e), t === !0 ? (this._cameraLerpActive = !1, this._cameraObject && this._cameraObject.position.copy(this._cameraEndPosition)) : this._cameraObject && (this._cameraLerpActive = !0, this._cameraLerp01 = 0, this._cameraStartPosition.copy(this._cameraObject?.position), typeof t == "number" ? this._cameraLerpDuration = t : this._cameraLerpDuration = this.targetLerpDuration));
  }
  // public setCameraTargetRotation(rotation: Vector3 | Euler | Quaternion, immediateOrDuration: boolean | number = false): void {
  //     if (!this._cameraObject) return;
  //     if (typeof immediateOrDuration === "boolean") immediateOrDuration = immediateOrDuration ? 0 : this.targetLerpDuration;
  //     const ray = new Ray(this._cameraObject.worldPosition, getTempVector(0, 0, 1));
  //     // if the camera is in the middle of lerping we use the end position for the raycast
  //     if (immediateOrDuration > 0 && this._cameraEndPosition && this._cameraLerpActive) {
  //         ray.origin = getTempVector(this._cameraEndPosition)
  //     }
  //     if (rotation instanceof Vector3) {
  //         rotation = new Euler().setFromVector3(rotation);
  //     }
  //     if (rotation instanceof Euler) {
  //         rotation = new Quaternion().setFromEuler(rotation);
  //     }
  //     ray.direction.applyQuaternion(rotation);
  //     ray.direction.multiplyScalar(-1);
  //     const hits = this.context.physics.raycastFromRay(ray);
  //     if (hits.length > 0) {
  //         this.setCameraTargetPosition(hits[0].point, immediateOrDuration);
  //     }
  //     else {
  //         this.setLookTargetPosition(ray.at(2, getTempVector()));
  //     }
  // }
  /** True while the camera position is being lerped */
  get cameraLerpActive() {
    return this._cameraLerpActive;
  }
  /** Call to stop camera position lerping */
  stopCameraLerp() {
    this._cameraLerpActive = !1;
  }
  setFieldOfView(e, t = !1) {
    if (!this._controls || typeof e != "number") return;
    const i = this._camera?.threeCamera;
    i && (t === !0 ? i.fov = e : (this._fovLerpActive = !0, this._fovLerp01 = 0, this._fovLerpStartValue = i.fov, this._fovLerpEndValue = e, typeof t == "number" ? this._fovLerpDuration = t : this._fovLerpDuration = this.targetLerpDuration));
  }
  /** Moves the camera look-at target to a position smoothly. 
   * @param position The position in world space to move the camera target to. If null the camera will stop lerping to the target.
   * @param immediateOrDuration If true the camera target will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
  */
  setLookTargetPosition(e = null, t = !1) {
    this._controls && e && (e instanceof M && (e = Z(e)), this._lookTargetEndPosition.copy(e), this._didSetTarget++, Ai && (console.warn("OrbitControls: setLookTargetPosition", e, t), F.DrawWireSphere(this._lookTargetEndPosition, 0.2, 16711680, 2)), t === !0 ? this.lerpLookTarget(this._lookTargetEndPosition, this._lookTargetEndPosition, 1) : (this._lookTargetLerpActive = !0, this._lookTargetLerp01 = 0, this._lookTargetStartPosition.copy(this._controls.target), typeof t == "number" ? this._lookTargetLerpDuration = t : this._lookTargetLerpDuration = this.targetLerpDuration));
  }
  /** True while the camera look target is being lerped */
  get lookTargetLerpActive() {
    return this._lookTargetLerpActive;
  }
  /** Call to stop camera look target lerping */
  stopLookTargetLerp() {
    this._lookTargetLerpActive = !1;
  }
  /** Sets the look at target from an assigned lookAtConstraint source by index 
   * @param index The index of the source to use
   * @param t The interpolation factor between the current look at target and the new target
  */
  setLookTargetFromConstraint(e = 0, t = 1) {
    if (!this._controls || this.lookAtConstraint?.enabled === !1) return !1;
    const i = this.lookAtConstraint?.sources;
    if (i && i.length > 0) {
      const n = i[e];
      if (n)
        return n.getWorldPosition(this._lookTargetEndPosition), this.lerpLookTarget(this._controls.target, this._lookTargetEndPosition, t), !0;
    }
    return !1;
  }
  lerpLookTarget(e, t, i) {
    this._controls && (i >= 1 ? this._controls.target.copy(t) : this._controls.target.lerpVectors(e, t, i), this.lookAtConstraint && this.lookAtConstraint.setConstraintPosition(this._controls.target));
  }
  setTargetFromRaycast(e, t = !1) {
    if (!this.controls) return !1;
    const i = e ? this.context.physics.raycastFromRay(e) : this.context.physics.raycast();
    for (const n of i)
      if (n.distance > 0 && S.isActiveInHierarchy(n.object)) {
        const o = qm(n.object);
        if (o && o.canvas?.screenspace)
          break;
        return this.setLookTargetPosition(n.point, t), !0;
      }
    return !1;
  }
  fitCamera(e, t) {
    if (this.context.isInXR)
      return;
    let i;
    if (Array.isArray(e) ? i = e : e && "type" in e ? i = e.children : e && typeof e == "object" && !(e instanceof M) && !Array.isArray(e) && (t = e, i = t.objects), i && !Array.isArray(i) && (i = i.children), (!Array.isArray(i) || i && i.length <= 0) && (i = this.context.scene.children), !Array.isArray(i) || i.length <= 0) {
      console.warn("No objects to fit camera to...");
      return;
    }
    const n = this._cameraObject, o = this._controls;
    if (!n || !o) {
      console.warn("No camera or controls found to fit camera to objects...");
      return;
    }
    t || (t = {});
    const { immediate: r = !1, centerCamera: a = "y", cameraNearFar: l = "auto", fitOffset: c = 1.1, fov: h = n?.fov } = t, d = new b(), f = new b(), p = _i(i, void 0, this._camera?.threeCamera?.layers), g = p.clone();
    n.updateMatrixWorld(), n.updateProjectionMatrix(), p.getCenter(f);
    const _ = new b();
    if (p.getSize(_), p.applyMatrix4(n.matrixWorldInverse), p.getSize(d), p.setFromCenterAndSize(f, d), Number.isNaN(d.x) || Number.isNaN(d.y) || Number.isNaN(d.z)) {
      console.warn("Camera fit size resultet in NaN", n, p, [...i]);
      return;
    }
    if (d.length() <= 1e-10) {
      nl && console.warn("Camera fit size is zero", p, [...i]);
      return;
    }
    const m = h, v = 2 * Math.atan(Math.tan(m * Math.PI / 360 / 2) * n.aspect) / Math.PI * 360, y = d.y / (2 * Math.atan(Math.PI * m / 360)), x = d.x / (2 * Math.atan(Math.PI * v / 360)), I = c * Math.max(y, x) + d.z / 2;
    nl && console.log("Fit camera to objects", { fitHeightDistance: y, fitWidthDistance: x, distance: I, verticalFov: m, horizontalFov: v }), this.maxZoom = I * 10, this.minZoom = I * 0.01;
    const O = 0.05, k = f.clone();
    if (k.y -= d.y * O, this.setLookTargetPosition(k, r), this.setFieldOfView(t.fov, r), l == null || l == "auto") {
      const q = S.findObjectOfType(Ms), A = q ? q.radius : 0, U = Math.max(_.x, _.y, _.z, A);
      n.near = I / 100, n.far = U + I * 10, q && (this.maxZoom = Math.max(Math.min(this.maxZoom, A * 0.5), I));
    }
    const E = o.getDistance();
    E < this.minZoom && (this.minZoom = E * 0.9), E > this.maxZoom && (this.maxZoom = E * 1.1), n.updateMatrixWorld(), n.updateProjectionMatrix();
    const z = Z(n), D = f.clone();
    D.sub(z), a === "y" && (D.y = 0), D.normalize(), D.multiplyScalar(I), a === "y" && (D.y += -O * 4 * I);
    let V = f.clone().sub(D);
    n.parent && (V = n.parent.worldToLocal(V)), this.setCameraTargetPosition(V, r), (nl || t.debug) && (F.DrawWireBox3(p, 16777011, 10), F.DrawWireBox3(g, 65280, 10), !this._haveAttachedKeyboardEvents && nl && (this._haveAttachedKeyboardEvents = !0, document.body.addEventListener("keydown", (q) => {
      if (q.code === "KeyF") {
        let A;
        this._cameraObject instanceof pe && (A = Math.random() * Math.random() * 170 + 10), this.fitCamera({ objects: i, fitOffset: c, immediate: !1, fov: A });
      }
      q.code === "KeyV" && this._cameraObject instanceof pe && (this._cameraObject.fov = 60);
    }))), this.onBeforeRender();
  }
  _haveAttachedKeyboardEvents = !1;
}
Ee([
  u()
], ye.prototype, "autoTarget");
Ee([
  u()
], ye.prototype, "autoFit");
Ee([
  u()
], ye.prototype, "enableRotate");
Ee([
  u()
], ye.prototype, "autoRotate");
Ee([
  u()
], ye.prototype, "autoRotateSpeed");
Ee([
  u()
], ye.prototype, "minAzimuthAngle");
Ee([
  u()
], ye.prototype, "maxAzimuthAngle");
Ee([
  u()
], ye.prototype, "minPolarAngle");
Ee([
  u()
], ye.prototype, "maxPolarAngle");
Ee([
  u()
], ye.prototype, "enableKeys");
Ee([
  u()
], ye.prototype, "enableDamping");
Ee([
  u()
], ye.prototype, "dampingFactor");
Ee([
  u()
], ye.prototype, "enableZoom");
Ee([
  u()
], ye.prototype, "minZoom");
Ee([
  u()
], ye.prototype, "maxZoom");
Ee([
  u()
], ye.prototype, "zoomSpeed");
Ee([
  u()
], ye.prototype, "enablePan");
Ee([
  u(Ra)
], ye.prototype, "lookAtConstraint");
Ee([
  u()
], ye.prototype, "lookAtConstraint01");
Ee([
  u()
], ye.prototype, "allowInterrupt");
Ee([
  u()
], ye.prototype, "middleClickToFocus");
Ee([
  u()
], ye.prototype, "doubleClickToFocus");
Ee([
  u()
], ye.prototype, "clickBackgroundToFitScene");
Ee([
  u()
], ye.prototype, "targetLerpDuration");
var lk = Object.defineProperty, ck = Object.getOwnPropertyDescriptor, Ht = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? ck(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && lk(e, t, n), n;
}, sa = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Skybox = 1] = "Skybox", s[s.SolidColor = 2] = "SolidColor", s[s.Uninitialized = 4] = "Uninitialized", s))(sa || {});
const Gs = w("debugcam"), u_ = w("debugscreenpointtoray"), Lt = class Sl extends T {
  /**
   * Returns whether this component is a camera
   * @returns {boolean} Always returns true
   */
  get isCamera() {
    return !0;
  }
  /** 
   * Gets or sets the camera's aspect ratio (width divided by height).
   * For perspective cameras, this directly affects the camera's projection matrix.
   * When set, automatically updates the projection matrix.
   */
  get aspect() {
    return this._cam instanceof pe ? this._cam.aspect : this.context.domWidth / this.context.domHeight;
  }
  set aspect(e) {
    this._cam instanceof pe && this._cam.aspect !== e && (this._cam.aspect = e, this._cam.updateProjectionMatrix());
  }
  /**
   * Gets or sets the camera's field of view in degrees for perspective cameras.
   * When set, automatically updates the projection matrix.
   */
  get fieldOfView() {
    return this._cam instanceof pe ? this._cam.fov : this._fov;
  }
  set fieldOfView(e) {
    const t = this.fieldOfView != e;
    if (this._fov = e, t && this._cam && this._cam instanceof pe) {
      if (this._fov === void 0) {
        console.warn("Can not set undefined fov on PerspectiveCamera");
        return;
      }
      this._cam.fov = this._fov, this._cam.updateProjectionMatrix();
    }
  }
  /**
   * Gets or sets the camera's near clipping plane distance.
   * Objects closer than this distance won't be rendered.
   * When set, automatically updates the projection matrix.
   */
  get nearClipPlane() {
    return this._nearClipPlane;
  }
  set nearClipPlane(e) {
    const t = this._nearClipPlane != e;
    this._nearClipPlane = e, this._cam && (t || this._cam.near != e) && (this._cam.near = e, this._cam.updateProjectionMatrix());
  }
  _nearClipPlane = 0.1;
  /**
   * Gets or sets the camera's far clipping plane distance.
   * Objects farther than this distance won't be rendered.
   * When set, automatically updates the projection matrix.
   */
  get farClipPlane() {
    return this._farClipPlane;
  }
  set farClipPlane(e) {
    const t = this._farClipPlane != e;
    this._farClipPlane = e, this._cam && (t || this._cam.far != e) && (this._cam.far = e, this._cam.updateProjectionMatrix());
  }
  _farClipPlane = 1e3;
  /**
   * Applies both the camera's near and far clipping planes and updates the projection matrix.
   * This ensures rendering occurs only within the specified distance range.
   */
  applyClippingPlane() {
    this._cam && (this._cam.near = this._nearClipPlane, this._cam.far = this._farClipPlane, this._cam.updateProjectionMatrix());
  }
  get clearFlags() {
    return this._clearFlags;
  }
  set clearFlags(e) {
    if (typeof e == "string")
      switch (e) {
        case "skybox":
          e = 1;
          break;
        case "solidcolor":
          e = 2;
          break;
        default:
          e = 0;
          break;
      }
    e !== this._clearFlags && (this._clearFlags = e, this.applyClearFlagsIfIsActiveCamera());
  }
  orthographic = !1;
  orthographicSize = 5;
  ARBackgroundAlpha = 0;
  set cullingMask(e) {
    this._cullingMask = e, this._cam && (this._cam.layers.mask = e);
  }
  get cullingMask() {
    return this._cam ? this._cam.layers.mask : this._cullingMask;
  }
  _cullingMask = 4294967295;
  /**
   * Sets only a specific layer to be active for rendering by this camera.
   * This is equivalent to calling `layers.set(val)` on the three.js camera object.
   * @param val The layer index to set active
   */
  set cullingLayer(e) {
    this.cullingMask = (1 << e | 0) >>> 0;
  }
  set backgroundBlurriness(e) {
    e !== this._backgroundBlurriness && (e === void 0 ? this._backgroundBlurriness = void 0 : this._backgroundBlurriness = Math.min(Math.max(e, 0), 1), this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundBlurriness() {
    return this._backgroundBlurriness;
  }
  _backgroundBlurriness = void 0;
  set backgroundIntensity(e) {
    e !== this._backgroundIntensity && (e === void 0 ? this._backgroundIntensity = void 0 : this._backgroundIntensity = Math.min(Math.max(e, 0), 10), this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundIntensity() {
    return this._backgroundIntensity;
  }
  _backgroundIntensity = void 0;
  set backgroundRotation(e) {
    e !== this._backgroundRotation && (e === void 0 ? this._backgroundRotation = void 0 : this._backgroundRotation = e, this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundRotation() {
    return this._backgroundRotation;
  }
  _backgroundRotation = void 0;
  set environmentIntensity(e) {
    this._environmentIntensity = e;
  }
  get environmentIntensity() {
    return this._environmentIntensity;
  }
  _environmentIntensity = void 0;
  get backgroundColor() {
    return this._backgroundColor ?? null;
  }
  set backgroundColor(e) {
    e && (this._backgroundColor || (this._backgroundColor = new oe(1, 1, 1, 1)), this._backgroundColor.copy(e), (!("alpha" in e) || e.alpha === void 0) && (this._backgroundColor.alpha = 1), this.applyClearFlagsIfIsActiveCamera());
  }
  set targetTexture(e) {
    this._targetTexture = e;
  }
  get targetTexture() {
    return this._targetTexture;
  }
  _targetTexture = null;
  _backgroundColor;
  _fov;
  _cam = null;
  _clearFlags = 2;
  _skybox;
  /**
   * Gets the three.js camera object. Creates one if it doesn't exist yet.
   * @returns {PerspectiveCamera | OrthographicCamera} The three.js camera object
   * @deprecated Use {@link threeCamera} instead
   */
  get cam() {
    return this.threeCamera;
  }
  /**
   * Gets the three.js camera object. Creates one if it doesn't exist yet.
   * @returns {PerspectiveCamera | OrthographicCamera} The three.js camera object
   */
  get threeCamera() {
    return this.activeAndEnabled && this.buildCamera(), this._cam;
  }
  static _origin = new b();
  static _direction = new b();
  /**
   * Converts screen coordinates to a ray in world space.
   * Useful for implementing picking or raycasting from screen to world.
   * 
   * @param x The x screen coordinate
   * @param y The y screen coordinate
   * @param ray Optional ray object to reuse instead of creating a new one
   * @returns {Ray} A ray originating from the camera position pointing through the screen point
   */
  screenPointToRay(e, t, i) {
    const n = this.threeCamera, o = Sl._origin;
    o.set(e, t, -1), this.context.input.convertScreenspaceToRaycastSpace(o), u_ && console.log("screenPointToRay", e.toFixed(2), t.toFixed(2), "now:", o.x.toFixed(2), o.y.toFixed(2), "isInXR:" + this.context.isInXR), o.z = -1, o.unproject(n);
    const r = Sl._direction.set(o.x, o.y, o.z), a = Z(n);
    return r.sub(a), r.normalize(), i ? (i.set(a, r), i) : new lo(a.clone(), r.clone());
  }
  _frustum;
  /**
   * Gets the camera's view frustum for culling and visibility checks.
   * Creates the frustum if it doesn't exist and returns it.
   * 
   * @returns {Frustum} The camera's view frustum
   */
  getFrustum() {
    return this._frustum || (this._frustum = new Gg(), this.updateFrustum()), this._frustum;
  }
  /**
   * Forces an update of the camera's frustum.
   * This is automatically called every frame in onBeforeRender.
   */
  updateFrustum() {
    this._frustum || (this._frustum = new Gg()), this._frustum.setFromProjectionMatrix(this.getProjectionScreenMatrix(this._projScreenMatrix, !0), this.context.renderer.coordinateSystem);
  }
  /**
   * Gets this camera's projection-screen matrix.
   * 
   * @param target Matrix4 object to store the result in
   * @param forceUpdate Whether to force recalculation of the matrix
   * @returns {Matrix4} The requested projection screen matrix
   */
  getProjectionScreenMatrix(e, t) {
    return t && this._projScreenMatrix.multiplyMatrices(this.threeCamera.projectionMatrix, this.threeCamera.matrixWorldInverse), e === this._projScreenMatrix ? e : e.copy(this._projScreenMatrix);
  }
  _projScreenMatrix = new te();
  /** @internal */
  awake() {
    u_ && window.addEventListener("pointerdown", (e) => {
      const t = e.clientX, i = e.clientY;
      console.log("touch", t.toFixed(2), i.toFixed(2));
      const n = this.screenPointToRay(t, i), o = "#" + Math.floor(Math.random() * 16777215).toString(16);
      F.DrawRay(n.origin, n.direction, o, 10);
    });
  }
  /** @internal */
  onEnable() {
    Gs && console.log(`Camera enabled: "${this.name}". ClearFlags=${sa[this._clearFlags]}`, this), this.buildCamera(), (this.tag == "MainCamera" || !this.context.mainCameraComponent) && (this.context.setCurrentCamera(this), dk(this)), this.applyClearFlagsIfIsActiveCamera({ applySkybox: !0 });
  }
  /** @internal */
  onDisable() {
    this.context.removeCamera(this);
  }
  /** @internal */
  onBeforeRender() {
    if (this._cam && (this._frustum && this.updateFrustum(), this._clearFlags === 2 && this.applyClearFlagsIfIsActiveCamera(), this._targetTexture)) {
      this.context.isManagedExternally && (this._warnedAboutExternalRenderer || (this._warnedAboutExternalRenderer = !0, console.warn("Rendering with external renderer is not supported yet. This may not work or throw errors. Please remove the the target texture from your camera: " + this.name, this.targetTexture))), this.context.composer;
      const e = this.context.renderer;
      if (e) {
        const t = this.context.mainCameraComponent;
        this.applyClearFlags(), this._targetTexture.render(this.context.scene, this._cam, e), t?.applyClearFlags();
      }
    }
  }
  /** 
   * Creates a three.js camera object if it doesn't exist yet and sets its properties.
   * This is called internally when accessing the {@link threeCamera} property.
   */
  buildCamera() {
    if (this._cam) return;
    const e = this.gameObject.isCamera;
    let t = null;
    if (e ? (t = this.gameObject, t?.layers.enableAll(), t instanceof pe && (this._fov = t.fov)) : t = this.gameObject.children[0], t && t.isCamera)
      t instanceof pe && (this._fov && (t.fov = this._fov), t.near = this._nearClipPlane, t.far = this._farClipPlane, t.updateProjectionMatrix());
    else if (!this.orthographic)
      t = new pe(this.fieldOfView, window.innerWidth / window.innerHeight, this._nearClipPlane, this._farClipPlane), this.fieldOfView && (t.fov = this.fieldOfView), this.gameObject.add(t);
    else {
      const i = this.orthographicSize * 100;
      t = new Td(window.innerWidth / -i, window.innerWidth / i, window.innerHeight / i, window.innerHeight / -i, this._nearClipPlane, this._farClipPlane), this.gameObject.add(t);
    }
    this._cam = t, this._cam.layers.mask = this._cullingMask, this.tag == "MainCamera" && this.context.setCurrentCamera(this);
  }
  /**
   * Applies clear flags if this is the active main camera.
   * @param opts Options for applying clear flags
   */
  applyClearFlagsIfIsActiveCamera(e) {
    this.context.mainCameraComponent === this && this.applyClearFlags(e);
  }
  /**
   * Applies this camera's clear flags and related settings to the renderer.
   * This controls how the background is rendered (skybox, solid color, transparent).
   * @param opts Options for applying clear flags
   */
  applyClearFlags(e) {
    if (!this._cam) {
      Gs && console.log("Camera does not exist (apply clear flags)");
      return;
    }
    if (this.fieldOfView = this._fov, Gs) {
      const i = `[Camera] Apply ClearFlags: ${sa[this._clearFlags]} - "${this.name}"`;
      console.debug(i);
    }
    const t = this.context.domElement.getAttribute("background-image") || this.context.domElement.getAttribute("background-color");
    switch (this._clearFlags) {
      case 0:
        return;
      case 1:
        if (Sl.backgroundShouldBeTransparent(this.context) && (!this.ARBackgroundAlpha || this.ARBackgroundAlpha < 1e-3)) {
          this.context.scene.background = null, this.context.renderer.setClearColor(0, 0);
          return;
        }
        (!this.scene.background || !this._skybox || e?.applySkybox === !0) && this.applySceneSkybox(), this._backgroundBlurriness !== void 0 && !this.context.domElement.getAttribute("background-blurriness") ? this.context.scene.backgroundBlurriness = this._backgroundBlurriness : Gs && console.warn(`Camera "${this.name}" has no background blurriness`), this._backgroundIntensity !== void 0 && !this.context.domElement.getAttribute("background-intensity") && (this.context.scene.backgroundIntensity = this._backgroundIntensity), this._backgroundRotation !== void 0 && !this.context.domElement.getAttribute("background-rotation") ? this.context.scene.backgroundRotation = this._backgroundRotation : Gs && console.warn(`Camera "${this.name}" has no background intensity`);
        break;
      case 2:
        if (this._backgroundColor && !t) {
          let i = this._backgroundColor.alpha;
          Sl.backgroundShouldBeTransparent(this.context) && (i = this.ARBackgroundAlpha ?? 0), this.context.scene.background = null, this.context.xr?.isVR ? this.context.renderer.setClearColor(OC(this._backgroundColor).convertLinearToSRGB()) : this.context.renderer.setClearColor(this._backgroundColor, i);
        } else this._backgroundColor || Gs && console.warn(`[Camera] has no background color "${this.name}" `);
        break;
      case 4:
        t || (this.context.scene.background = null, this.context.renderer.setClearColor(0, 0));
        break;
    }
  }
  /**
   * Applies the skybox texture to the scene background.
   */
  applySceneSkybox() {
    this._skybox || (this._skybox = new hk(this)), this._skybox.apply();
  }
  /**
   * Determines if the background should be transparent when in passthrough AR mode.
   * 
   * @param context The current rendering context
   * @returns {boolean} True when in XR on a pass through device where the background should be invisible
   */
  static backgroundShouldBeTransparent(e) {
    const t = e.renderer.xr?.getSession();
    if (!t) return !1;
    if (typeof t._transparent == "boolean")
      return t._transparent;
    const i = t.environmentBlendMode;
    Gs && Be("Environment blend mode: " + i + " on " + navigator.userAgent);
    let n = i === "additive" || i === "alpha-blend";
    return e.isInAR && i === "opaque" && (navigator.userAgent?.includes("OculusBrowser") || navigator.userAgent?.includes("Mozilla") && navigator.userAgent?.includes("Mobile WebXRViewer/v2")) && (n = !0), t._transparent = n, n;
  }
};
Ht([
  u()
], Lt.prototype, "aspect", 1);
Ht([
  u()
], Lt.prototype, "fieldOfView", 1);
Ht([
  u()
], Lt.prototype, "nearClipPlane", 1);
Ht([
  u()
], Lt.prototype, "farClipPlane", 1);
Ht([
  u()
], Lt.prototype, "clearFlags", 1);
Ht([
  u()
], Lt.prototype, "orthographic", 2);
Ht([
  u()
], Lt.prototype, "orthographicSize", 2);
Ht([
  u()
], Lt.prototype, "ARBackgroundAlpha", 2);
Ht([
  u()
], Lt.prototype, "cullingMask", 1);
Ht([
  u()
], Lt.prototype, "backgroundBlurriness", 1);
Ht([
  u()
], Lt.prototype, "backgroundIntensity", 1);
Ht([
  u(Rt)
], Lt.prototype, "backgroundRotation", 1);
Ht([
  u()
], Lt.prototype, "environmentIntensity", 1);
Ht([
  u(oe)
], Lt.prototype, "backgroundColor", 1);
Ht([
  u(fs)
], Lt.prototype, "targetTexture", 1);
let ui = Lt;
class hk {
  _camera;
  _skybox;
  get context() {
    return this._camera?.context;
  }
  constructor(e) {
    this._camera = e;
  }
  /**
   * Applies the skybox texture to the scene background.
   * Retrieves the texture based on the camera's source ID.
   */
  apply() {
    if (this._skybox = this.context.lightmaps.tryGetSkybox(this._camera.sourceId), !this._skybox)
      this._did_log_failed_to_find_skybox || (this._did_log_failed_to_find_skybox = !0, console.warn(`Camera "${this._camera.name}" has no skybox texture. ${this._camera.sourceId}`));
    else if (this.context.scene.background !== this._skybox) {
      const e = this.context.domElement.getAttribute("background-image") || this.context.domElement.getAttribute("background-color");
      Gs && console.debug(`[Camera] Apply Skybox ${this._skybox?.name} ${e} - "${this._camera.name}"`), e?.length || (this._skybox.mapping = _s, this.context.scene.background = this._skybox);
    }
  }
}
function dk(s) {
  w("freecam") && s.context.mainCameraComponent === s && S.getOrAddComponent(s.gameObject, ye);
}
class Js extends T {
  /**
   * Gets the existing Three.js {@link three#AudioListener} instance or creates a new one if it doesn't exist.
   * This listener is responsible for capturing audio in the 3D scene.
   * @returns The {@link three#AudioListener} instance
   */
  get listener() {
    return this._listener == null && (this._listener = new lx()), this._listener;
  }
  _listener = null;
  /**
   * Registers for interaction events and initializes the audio listener
   * when this component is enabled.
   * @internal
   */
  onEnable() {
    Bn.registerWaitForInteraction(this.onInteraction), this.addListenerIfItExists();
  }
  /**
   * Cleans up event registrations and removes the audio listener
   * when this component is disabled.
   * @internal
   */
  onDisable() {
    Bn.unregisterWaitForInteraction(this.onInteraction), this.removeListenerIfItExists();
  }
  onInteraction = () => {
    this.destroyed || this.listener == null || this.addListenerIfItExists();
  };
  addListenerIfItExists() {
    const e = this._listener;
    if (!e || e?.parent) return;
    const t = this.context.mainCameraComponent || S.getComponentInParent(this.gameObject, ui);
    t?.threeCamera ? t.threeCamera.add(e) : this.gameObject.add(e), e.filter ? (e.gain.connect(e.filter), e.filter.connect(e.context.destination)) : e.gain.connect(e.context.destination);
  }
  removeListenerIfItExists() {
    const e = this._listener;
    e && (e.removeFromParent(), e.filter && e.filter.disconnect(), e.gain && e.gain.disconnect());
  }
}
var uk = Object.defineProperty, fk = Object.getOwnPropertyDescriptor, dn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? fk(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && uk(e, t, n), n;
};
const bt = w("debugaudio"), Qi = class qs extends T {
  /**
   * Checks if the user has interacted with the page to allow audio playback.
   * Audio playback often requires a user gesture first due to browser autoplay policies.
   * This is the same as calling {@link Application.userInteractionRegistered}.
   * 
   * @returns Whether user interaction has been registered to allow audio playback
   */
  static get userInteractionRegistered() {
    return Bn.userInteractionRegistered;
  }
  /**
   * Registers a callback that will be executed once the user has interacted with the page,
   * allowing audio playback to begin.
   * This is the same as calling {@link Application.registerWaitForInteraction}.
   * 
   * @param cb - The callback function to execute when user interaction is registered
   */
  static registerWaitForAllowAudio(e) {
    Bn.registerWaitForInteraction(e);
  }
  clip = "";
  playOnAwake = !1;
  preload = !0;
  playInBackground = !0;
  /**
   * Indicates whether the audio is currently playing.
   * 
   * @returns True if the audio is playing, false otherwise
   */
  get isPlaying() {
    return this.sound?.isPlaying ?? !1;
  }
  /**
   * The total duration of the current audio clip in seconds.
   * 
   * @returns Duration in seconds or undefined if no clip is loaded
   */
  get duration() {
    return this.sound?.buffer?.duration;
  }
  /**
   * The current playback position as a normalized value between 0 and 1.
   * Can be set to seek to a specific position in the audio.
   */
  get time01() {
    const e = this.duration;
    return e && this.sound ? this.sound?.context.currentTime / e : 0;
  }
  set time01(e) {
    const t = this.duration;
    t && this.sound && (this.time = e * t);
  }
  /**
   * The current playback position in seconds.
   * Can be set to seek to a specific time in the audio.
   */
  get time() {
    return this.sound?.source ? this.sound.source?.context.currentTime - this._lastContextTime + this.sound.offset : 0;
  }
  set time(e) {
    if (this.sound) {
      if (e === this.sound.offset) return;
      const t = this.isPlaying;
      this.stop(), this.sound.offset = e, t && this.play();
    }
  }
  get loop() {
    return this.sound && (this._loop = this.sound.getLoop()), this._loop;
  }
  set loop(e) {
    this._loop = e, this.sound && this.sound.setLoop(e);
  }
  get spatialBlend() {
    return this._spatialBlend;
  }
  set spatialBlend(e) {
    e !== this._spatialBlend && (this._spatialBlend = e, this._needUpdateSpatialDistanceSettings = !0);
  }
  get minDistance() {
    return this._minDistance;
  }
  set minDistance(e) {
    this._minDistance !== e && (this._minDistance = e, this._needUpdateSpatialDistanceSettings = !0);
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set maxDistance(e) {
    this._maxDistance !== e && (this._maxDistance = e, this._needUpdateSpatialDistanceSettings = !0);
  }
  _spatialBlend = 0;
  _minDistance = 1;
  _maxDistance = 100;
  get volume() {
    return this._volume;
  }
  set volume(e) {
    this._volume = e, this.sound && !this.context.application.muted && (bt && console.log(this.name, "audio set volume", e), this.sound.setVolume(e));
  }
  _volume = 1;
  set pitch(e) {
    this.sound && this.sound.setPlaybackRate(e);
  }
  get pitch() {
    return this.sound ? this.sound.getPlaybackRate() : 1;
  }
  rollOffMode = 0;
  _loop = !1;
  sound = null;
  helper = null;
  wasPlaying = !1;
  audioLoader = null;
  shouldPlay = !1;
  // set this from audio context time, used to set clip offset when setting "time" property
  // there is maybe a better way to set a audio clip current time?!
  _lastClipStartedLoading = null;
  _audioElement = null;
  /**
   * Returns the underlying {@link PositionalAudio} object, creating it if necessary.
   * The audio source needs a user interaction to be initialized due to browser autoplay policies.
   * 
   * @returns The three.js PositionalAudio object or null if unavailable
   */
  get Sound() {
    if (!this.sound && qs.userInteractionRegistered) {
      let e = this.gameObject.getComponent(Js) ?? this.context.mainCamera.getComponent(Js) ?? Qd(Js, this.context, !1);
      !e && this.context.mainCamera && (e = this.context.mainCamera.addComponent(Js)), e?.listener ? (this.sound = new cx(e.listener), this.gameObject?.add(this.sound)) : bt && console.warn("No audio listener found in scene - can not play audio");
    }
    return this.sound;
  }
  // This is a hacky workaround to get the PositionalAudio behave like a 2D audio source
  // private _listener: AudioListener | null = null;
  // private _originalSoundMatrixWorldFunction: Function | null = null;
  // private _onSoundMatrixWorld = (force: boolean) => {
  //     if (this._spatialBlend > .05) {
  //         if (this._originalSoundMatrixWorldFunction) {
  //             this._originalSoundMatrixWorldFunction.call(this.sound, force);
  //         }
  //     }
  //     else {
  //         // we use another object's matrix world function (but bound to the positional audio)
  //         // this is just a little trick to prevent calling the PositionalAudio's updateMatrixWorld function
  //         this.gameObject.updateMatrixWorld?.call(this.sound, force);
  //         if (this.sound && this._listener) {
  //             this.sound.gain.connect(this._listener.listener.getInput());
  //             // const pos = getTempVector().setFromMatrixPosition(this._listener.gameObject.matrixWorld);
  //             // const ctx = this.sound.context;
  //             // const delay = this._listener.listener.timeDelta;
  //             // const time = ctx.currentTime ;
  //             // this.sound.panner.positionX.setValueAtTime(pos.x, time);
  //             // this.sound.panner.positionY.setValueAtTime(pos.y, time);
  //             // this.sound.panner.positionZ.setValueAtTime(pos.z, time);
  //             // this.sound.panner.orientationX.setValueAtTime(0, time);
  //             // this.sound.panner.orientationY.setValueAtTime(0, time);
  //             // this.sound.panner.orientationZ.setValueAtTime(-1, time);
  //         }
  //     }
  // }
  /**
   * Indicates whether the audio source is queued to play when possible.
   * This may be true before user interaction has been registered.
   * 
   * @returns Whether the audio source intends to play
   */
  get ShouldPlay() {
    return this.shouldPlay;
  }
  /**
   * Returns the Web Audio API context associated with this audio source.
   * 
   * @returns The {@link AudioContext} or null if not available
   */
  get audioContext() {
    return this.sound?.context;
  }
  /** @internal */
  awake() {
    bt && console.log("[AudioSource]", this), this.audioLoader = new sp(), this.playOnAwake && (this.shouldPlay = !0), this.preload && typeof this.clip == "string" && this.audioLoader.load(this.clip, this.createAudio, () => {
    }, console.error);
  }
  /** @internal */
  onEnable() {
    this.sound && this.gameObject.add(this.sound), qs.userInteractionRegistered ? this.playOnAwake && this.context.application.isVisible && this.play() : qs.registerWaitForAllowAudio(() => {
      this.enabled && !this.destroyed && this.shouldPlay && this.onNewClip(this.clip);
    }), globalThis.addEventListener("visibilitychange", this.onVisibilityChanged), this.context.application.addEventListener(fp.MuteChanged, this.onApplicationMuteChanged);
  }
  /** @internal */
  onDisable() {
    globalThis.removeEventListener("visibilitychange", this.onVisibilityChanged), this.context.application.removeEventListener(fp.MuteChanged, this.onApplicationMuteChanged), this.pause();
  }
  onVisibilityChanged = () => {
    switch (document.visibilityState) {
      case "hidden":
        (this.playInBackground === !1 || X.isMobileDevice()) && (this.wasPlaying = this.isPlaying, this.isPlaying && this.pause());
        break;
      case "visible":
        bt && console.log("visible", this.enabled, this.playOnAwake, !this.isPlaying, qs.userInteractionRegistered, this.wasPlaying), this.enabled && this.playOnAwake && !this.isPlaying && qs.userInteractionRegistered && this.wasPlaying && this.play();
        break;
    }
  };
  onApplicationMuteChanged = () => {
    this.context.application.muted ? this.sound?.setVolume(0) : this.sound?.setVolume(this.volume);
  };
  createAudio = (e) => {
    if (this.destroyed) {
      bt && console.warn("AudioSource destroyed, not creating audio", this.name);
      return;
    }
    bt && console.log("AudioBuffer finished loading", e);
    const t = this.Sound;
    if (!t) {
      bt && console.warn("Failed getting sound?", this.name);
      return;
    }
    t.isPlaying && t.stop(), e && t.setBuffer(e), t.loop = this._loop, this.context.application.muted ? t.setVolume(0) : t.setVolume(this.volume), t.autoplay = this.shouldPlay && qs.userInteractionRegistered, this.applySpatialDistanceSettings(), t.isPlaying && t.stop(), qs.registerWaitForAllowAudio(this.__onAllowAudioCallback);
  };
  __onAllowAudioCallback = () => {
    this.shouldPlay && this.play();
  };
  applySpatialDistanceSettings() {
    const e = this.sound;
    if (!e) return;
    this._needUpdateSpatialDistanceSettings = !1;
    const t = j.lerp(10 * this._maxDistance / Math.max(1e-4, this.spatialBlend), this._minDistance, this.spatialBlend);
    switch (bt && console.log(this.name, this._minDistance, this._maxDistance, this.spatialBlend, "Ref distance=" + t), e.setRefDistance(t), e.setMaxDistance(Math.max(0.01, this._maxDistance)), this.rollOffMode) {
      case 0:
        e.setDistanceModel("exponential");
        break;
      case 1:
        e.setDistanceModel("linear");
        break;
      case 2:
        console.warn("Custom rolloff for AudioSource is not supported: " + this.name);
        break;
    }
    this.spatialBlend > 0 ? bt && !this.helper && (this.helper = new fS(e, e.getRefDistance()), e.add(this.helper)) : this.helper && this.helper.parent && this.helper.removeFromParent();
  }
  async onNewClip(e) {
    if (e && (this.clip = e), typeof e == "string")
      if (bt && console.log(e), e.endsWith(".mp3") || e.endsWith(".wav")) {
        if (this.audioLoader || (this.audioLoader = new sp()), this.shouldPlay = !0, this._lastClipStartedLoading === e) {
          bt && console.log("Is currently loading:", this._lastClipStartedLoading, this);
          return;
        }
        this._lastClipStartedLoading = e, bt && console.log("load audio", e);
        const t = await this.audioLoader.loadAsync(e).catch(console.error);
        if (this.destroyed) return;
        this._lastClipStartedLoading === e && (this._lastClipStartedLoading = null), t && this.createAudio(t);
      } else console.warn("Unsupported audio clip type", e);
    else
      this.shouldPlay = !0, this.createAudio();
  }
  /**
   * Plays the audio clip or media stream.
   * If no argument is provided, plays the currently assigned clip.
   * 
   * @param clip - Optional audio clip or {@link MediaStream} to play
   */
  play(e = void 0) {
    !e && this.clip && (e = this.clip), e !== void 0 && typeof e != "string" && !(e instanceof MediaStream) && (L() && console.warn("Called play on AudioSource with unknown argument type:", e + `
Using the assigned clip instead:`, this.clip), e = this.clip);
    let t = !this.sound || e && e !== this.clip;
    if (typeof e == "string" && !this.audioLoader && (t = !0), (e instanceof MediaStream || typeof e == "string") && (this.clip = e), t) {
      this.shouldPlay = !0, this.onNewClip(e);
      return;
    }
    if (this.shouldPlay = !0, this._hasEnded = !1, bt && console.log("play", this.sound?.getVolume(), this.sound), this.sound && !this.sound.isPlaying) {
      const i = this.context.application.muted;
      i && this.sound.setVolume(0), this.gameObject?.add(this.sound), this.clip instanceof MediaStream ? (this.sound.setMediaStreamSource(this.clip), this._audioElement || (this._audioElement = document.createElement("audio"), this._audioElement.style.display = "none"), this._audioElement.parentNode || this.context.domElement.shadowRoot?.append(this._audioElement), this._audioElement.srcObject = this.clip, this._audioElement.autoplay = !1) : (this._audioElement && this._audioElement.remove(), this.sound.play(i ? 0.1 : 0));
    }
  }
  /**
   * Pauses audio playback while maintaining the current position.
   * Use play() to resume from the paused position.
   */
  pause() {
    bt && console.log("Pause", this), this._hasEnded = !0, this.shouldPlay = !1, this.sound && this.sound.isPlaying && this.sound.source && (this._lastContextTime = this.sound?.context.currentTime, this.sound.pause()), this._audioElement?.remove();
  }
  /**
   * Stops audio playback completely and resets the playback position to the beginning.
   * Unlike pause(), calling play() after stop() will start from the beginning.
   */
  stop() {
    bt && console.log("Pause", this), this._hasEnded = !0, this.shouldPlay = !1, this.sound && this.sound.source && (this._lastContextTime = this.sound?.context.currentTime, bt && console.log(this._lastContextTime), this.sound.stop()), this._audioElement?.remove();
  }
  _lastContextTime = 0;
  _hasEnded = !0;
  _needUpdateSpatialDistanceSettings = !1;
  /** @internal */
  update() {
    this.helper && (this.isPlaying && this.helper.update(), this.helper.visible = this.isPlaying), this._needUpdateSpatialDistanceSettings && this.applySpatialDistanceSettings(), this.sound && !this.sound.isPlaying && this.shouldPlay && !this._hasEnded && (this._hasEnded = !0, bt && console.log("Audio clip ended", this.clip), this.dispatchEvent(new CustomEvent("ended", { detail: this })));
  }
};
dn([
  u(URL)
], Qi.prototype, "clip", 2);
dn([
  u()
], Qi.prototype, "playOnAwake", 2);
dn([
  u()
], Qi.prototype, "preload", 2);
dn([
  u()
], Qi.prototype, "playInBackground", 2);
dn([
  u()
], Qi.prototype, "loop", 1);
dn([
  u()
], Qi.prototype, "spatialBlend", 1);
dn([
  u()
], Qi.prototype, "minDistance", 1);
dn([
  u()
], Qi.prototype, "maxDistance", 1);
dn([
  u()
], Qi.prototype, "volume", 1);
dn([
  u()
], Qi.prototype, "pitch", 1);
dn([
  u()
], Qi.prototype, "rollOffMode", 2);
let ln = Qi;
const pk = w("debugavatar");
class je extends T {
  static getAvatar(e) {
    return e >= 0 && e < je.instances.length ? je.instances[e] : null;
  }
  static instances = [];
  static onAvatarMarkerCreated(e) {
    return je._onNewAvatarMarkerAdded.push(e), e;
  }
  static onAvatarMarkerDestroyed(e) {
    return je._onAvatarMarkerDestroyed.push(e), e;
  }
  static _onNewAvatarMarkerAdded = [];
  static _onAvatarMarkerDestroyed = [];
  connectionId;
  avatar;
  awake() {
    je.instances.push(this), pk && console.log(this);
    for (const e of je._onNewAvatarMarkerAdded)
      e({ avatarMarker: this, gameObject: this.gameObject });
  }
  onDestroy() {
    je.instances.splice(je.instances.indexOf(this), 1);
    for (const e of je._onAvatarMarkerDestroyed)
      e({ avatarMarker: this, gameObject: this.gameObject });
  }
  isLocalAvatar() {
    return this.connectionId === this.context.connection.connectionId;
  }
}
class oa {
  static Pois = [];
  static LastChangeTime = 0;
  static Add(e, t, i = null) {
    if (t) {
      for (const n of this.Pois)
        if (n.obj === t) return;
      this.Pois.push({ obj: t, avatar: i }), this.LastChangeTime = e.time.time;
    }
  }
  static Remove(e, t) {
    if (t) {
      for (const i of this.Pois)
        if (i.obj === t) {
          this.Pois.splice(this.Pois.indexOf(i), 1), this.LastChangeTime = e?.time.time ?? N.Current?.time.time;
          return;
        }
    }
  }
}
class mk {
  guid;
  position = new b();
}
class pd extends T {
  set controlledTarget(e) {
    this.target = e;
    const t = P.get("MoveRandom");
    if (t && this.target) {
      const i = S.getComponent(this.target, t);
      i && i.destroy();
    }
  }
  // that target to copy positions into
  target = null;
  avatar = null;
  _model = null;
  _targetModel = new mk();
  _currentTargetObject = null;
  _lastUpdateTime = 0;
  _lookDuration = 0;
  _lastPoiChangedTime = 0;
  awake() {
    if (this.avatar = S.getComponentInParent(this.gameObject, je), this.avatar) {
      const e = S.getComponentInParent(this.gameObject, je);
      this._model = new i0(this.context.connection, this.guid), e?.isLocalAvatar && this._model.requestOwnership();
    }
    this.context.connection.beginListen("avatar-look-target-changed", (e) => {
      this.target && e && e.guid === this.avatar?.guid && ut(this.target, e.position);
    });
  }
  update() {
    if ((!this.context.connection.isConnected || this._model?.hasOwnership) && (oa.LastChangeTime !== this._lastPoiChangedTime && (this._lastPoiChangedTime = oa.LastChangeTime, this._lookDuration = 0), this.selectTarget(), this._currentTargetObject && this.context.time.frameCount % 10 === 0 && this.target)) {
      const t = Z(this._currentTargetObject);
      ut(this.target, t), this.context.connection.isConnected && this.avatar && (this.context.connection.send("avatar-look-target-changed", this._targetModel), this._targetModel.guid = this.avatar.guid, this._targetModel.position.copy(t));
    }
  }
  selectTarget() {
    if (this.context.time.time - this._lastUpdateTime > this._lookDuration) {
      this._lastUpdateTime = this.context.time.time, this._lookDuration = Math.random() * 0.5 + 0.2;
      const t = oa.Pois;
      if (t.length > 0) {
        const i = t[Math.floor(Math.random() * t.length)];
        if (i && i.obj) {
          if (i.avatar && i.avatar === this.avatar) return;
          this._currentTargetObject = i.obj;
        }
      }
    }
  }
}
function gk(s) {
  const e = s;
  return !!(e.parser && e.parser.json);
}
var Xm = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.DontExport = 1] = "DontExport", s))(Xm || {});
function yk(s) {
  return s && s.isComponent;
}
const iL = Symbol("object"), wf = new $i(() => new b(), 20);
class _k {
  _point;
  _normal;
  _tangentVelocity;
  /** the distance of the collision point */
  distance;
  /** the impulse velocity */
  impulse;
  friction;
  /** worldspace point */
  get point() {
    return wf.get().set(this._point.x, this._point.y, this._point.z);
  }
  /** worldspace normal */
  get normal() {
    return wf.get().set(this._normal.x, this._normal.y, this._normal.z);
  }
  /** worldspace tangent */
  get tangentVelocity() {
    return wf.get().set(this._tangentVelocity.x, this._tangentVelocity.y, this._tangentVelocity.z);
  }
  /** @internal */
  constructor(e, t, i, n, o, r) {
    this._point = e, this.distance = t, this._normal = i, this.impulse = n, this.friction = o, this._tangentVelocity = r;
  }
}
class bk {
  /** The contact points of this collision. Contains information about positions, normals, distance, friction, impulse... */
  contacts;
  /** @internal */
  constructor(e, t, i) {
    this.me = e, this._collider = t, this._gameObject = t.gameObject, this.contacts = i;
  }
  /** the gameobject this collision event belongs to (e.g. if onCollisionEnter is called then `me` is the same as `this.gameObject`) */
  me;
  _collider;
  /** the other collider the collision happened with */
  get collider() {
    return this._collider;
  }
  _gameObject;
  /** the other object the collision happened with */
  get gameObject() {
    return this._gameObject;
  }
  /** the other rigidbody we hit, null if none attached */
  get rigidBody() {
    return this.collider?.attachedRigidbody;
  }
}
class vk {
  object;
  collider;
  constructor(e, t) {
    this.object = e, this.collider = t;
  }
}
const Le = w("debugnetworkingstreams");
var ps = /* @__PURE__ */ ((s) => (s.Connected = "peer-user-connected", s.StreamReceived = "receive-stream", s.StreamEnded = "call-ended", s.Disconnected = "peer-user-disconnected", s.UserJoined = "user-joined", s))(ps || {});
class H0 {
  type = "call-ended";
  userId;
  direction;
  constructor(e, t) {
    this.userId = e, this.direction = t;
  }
}
class wk {
  type = "receive-stream";
  userId;
  stream;
  target;
  constructor(e, t, i) {
    this.userId = e, this.stream = t, this.target = i;
  }
}
class xk {
  /** the peer handle id */
  guid;
  peerId;
  // internal so server doesnt save it to persistent storage
  dontSave = !0;
  constructor(e, t) {
    this.guid = e.id, this.peerId = t;
  }
}
var Sk = /* @__PURE__ */ ((s) => (s.Incoming = "incoming", s.Outgoing = "outgoing", s))(Sk || {});
class Ck extends um {
  peerId;
  userId;
  direction;
  call;
  get stream() {
    return this._stream;
  }
  _stream = null;
  _isDisposed = !1;
  close() {
    this._isDisposed || (this._isDisposed = !0, this.call.close(), ms(this._stream));
  }
  get isOpen() {
    return this.call.peerConnection?.connectionState === "connected";
  }
  get isOpening() {
    return this.call.peerConnection?.connectionState === "connecting";
  }
  get isClosed() {
    return !this.isOpen || this._isDisposed;
  }
  constructor(e, t, i, n = null) {
    super(), this.peerId = t.peer, this.userId = e, this.call = t, this.direction = i, this._stream = n, t.on("stream", (o) => {
      if (Le && console.log("Receive stream", `
Audio:`, o.getAudioTracks(), `
Video:`, o.getVideoTracks()), this._stream = o, i === "incoming") {
        const r = new wk(e, o, this);
        this.dispatchEvent(r);
      }
    }), t.on("close", () => {
      this.dispatchEvent(new H0(e, i));
    });
  }
}
function f_(s) {
  return s = s.replace("a=fmtp:111 minptime=10;useinbandfec=1", "a=fmtp:111 ptime=5;useinbandfec=1;stereo=1;maxplaybackrate=48000;maxaveragebitrat=128000;sprop-stereo=1"), s;
}
class eo extends um {
  static instances = /* @__PURE__ */ new Map();
  static getOrCreate(e, t) {
    if (eo.instances.has(t))
      return eo.instances.get(t);
    const i = new eo(e, t);
    return eo.instances.set(t, i), i;
  }
  getMyPeerId() {
    if (this.context.connection.connectionId)
      return this.getPeerIdFromUserId(this.context.connection.connectionId);
  }
  getPeerIdFromUserId(e) {
    return this.id + "-" + e;
  }
  getUserIdFromPeerId(e) {
    return e.substring(this.id.length + 1);
  }
  makeCall(e, t) {
    if (!t?.id) {
      Le ? console.warn("Can not make a call: mediastream has no id or is undefined") : console.debug("Can not make a call: mediastream has no id or is undefined");
      return;
    }
    const i = {
      metadata: {
        userId: this.context.connection.connectionId,
        streamId: t.id
      },
      sdpTransform: (o) => f_(o)
    }, n = this._peer?.call(e, t, i);
    if (n) {
      const o = this.registerCall(n, "outgoing", t);
      return Le && console.warn(`📞 CALL ${e}`, `
Outgoing:`, this._outgoingCalls, `
Incoming:`, this._incomingCalls), o;
    } else Le && console.error("Failed to make call", e, t, this._peer);
  }
  closeAll() {
    for (const e of this._incomingCalls)
      e.close();
    for (const e of this._outgoingCalls)
      e.close();
    this.updateCalls();
  }
  updateCalls = () => {
    for (let e = this._incomingCalls.length - 1; e >= 0; e--) {
      const t = this._incomingCalls[e];
      t.isClosed && !t.isOpening && this._incomingCalls.splice(e, 1);
    }
    for (let e = this._outgoingCalls.length - 1; e >= 0; e--) {
      const t = this._outgoingCalls[e];
      let i = !1;
      t.isClosed && !t.isOpening && (t.stream?.active ? Le && console.warn("!!! Stream is still active, don't remove call", t.userId, "Your id: " + this.context.connection.connectionId) : (Le && console.warn("!!! Remove closed call", t.userId), i = !0)), this.context.connection.userIsInRoom(t.userId) === !1 && (Le && console.warn("!!! User is not in room anymore, remove call", t.userId), i = !0), i && (t.close(), this._outgoingCalls.splice(e, 1));
    }
  };
  get peer() {
    return this._peer;
  }
  get incomingCalls() {
    return this._incomingCalls;
  }
  id;
  context;
  _incomingCalls = [];
  _outgoingCalls = [];
  _peer;
  constructor(e, t) {
    super(), this.context = e, this.id = t, this.setupPeer();
    const i = Object.getOwnPropertyDescriptor(navigator, "getUserMedia")?.writable;
    try {
      i ? navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia : Le && console.warn("[PeerJs] getUserMedia is not writable");
    } catch (n) {
      Le && console.error("[PeerJs] Error setting getUserMedia", n);
    }
  }
  _enabled = !1;
  _enabledPeer = !1;
  onConnectRoomFn = this.onConnectRoom.bind(this);
  // private onUserJoinedOrLeftRoomFn: Function = this.onUserJoinedOrLeftRoom.bind(this);
  // private onPeerConnectFn: (id) => void = this.onPeerConnect.bind(this);
  // private onPeerReceiveCallFn: (call) => void = this.onPeerReceivingCall.bind(this);
  // private _connectionPeerIdMap : Map<string, string> = new Map();
  enable() {
    this._enabled || (this._enabled = !0, this.context.connection.beginListen(ee.JoinedRoom, this.onConnectRoomFn), this.subscribePeerEvents());
  }
  disable() {
    this._enabled && (this._enabled = !1, this.context.connection.stopListen(ee.JoinedRoom, this.onConnectRoomFn), this.unsubscribePeerEvents());
  }
  onConnectRoom() {
    this.setupPeer();
  }
  // private onUserJoinedOrLeftRoom(_: UserJoinedOrLeftRoomModel): void {
  // };
  setupPeer() {
    if (this.context.connection.connectionId && !this._enabledPeer) {
      if (this._enabledPeer = !0, !this._peer) {
        const e = this.getMyPeerId();
        e ? this._peer = g1(e) : console.error("Failed to setup peerjs because we dont have a connection id", this.context.connection.connectionId);
      }
      this._enabled && this.subscribePeerEvents();
    }
  }
  subscribePeerEvents() {
    this._peer && (this._peer.on("open", this.onPeerConnect), this._peer.on("close", this.onPeerClose), this._peer.on("call", this.onPeerReceivingCall), this._peer.on("disconnected", this.onPeerDisconnected), this._peer.on("error", this.onPeerError));
  }
  unsubscribePeerEvents() {
    this._peer && (this._peer.off("open", this.onPeerConnect), this._peer.off("close", this.onPeerClose), this._peer.off("call", this.onPeerReceivingCall), this._peer.off("disconnected", this.onPeerDisconnected), this._peer.off("error", this.onPeerError));
  }
  /**
   * Emitted when a connection to the PeerServer is established. You may use the peer before this is emitted, but messages to the server will be queued. id is the brokering ID of the peer (which was either provided in the constructor or assigned by the server).
   * @param id ID of the peer 
  */
  onPeerConnect = (e) => {
    if (Le && console.log("PEER opened as", e), e === null) {
      console.error("Peer connection failed", e);
      return;
    }
    this.context.connection.send("peer-user-connected", new xk(this, e));
  };
  /** Emitted when the peer is destroyed and can no longer accept or create any new connections. At this time, the peer's connections will all be closed. */
  onPeerClose = () => {
    Le && console.log("PEER closed"), this.updateCalls();
  };
  /** Emitted when the peer is disconnected from the signalling server, either manually or because the connection to the signalling server was lost. */
  onPeerDisconnected = () => {
    Le && console.log("PEER disconnected"), this.updateCalls();
  };
  /**
   * Errors on the peer are almost always fatal and will destroy the peer. Errors from the underlying socket and PeerConnections are forwarded here.
   */
  onPeerError = (e) => {
    Le && console.error("PEER error", e);
  };
  onPeerReceivingCall = (e) => {
    e.answer(void 0, {
      sdpTransform: (t) => f_(t)
    }), this.registerCall(e, "incoming", null);
  };
  registerCall(e, t, i) {
    const n = e.metadata;
    (!n || !n.userId) && console.error("Missing call metadata", e);
    const o = n.userId;
    t === "incoming" && Le ? console.warn("← Receive call from", e.metadata, e.connectionId) : Le && console.warn("→ Make call to", e.metadata);
    const r = t === "incoming" ? this._incomingCalls : this._outgoingCalls, a = new Ck(o, e, t, i);
    return r.push(a), e.on("error", (l) => {
      console.error("Call error", l);
    }), e.on("close", () => {
      Le && console.log("Call ended", e.metadata);
      const l = r.indexOf(a);
      l !== -1 && r.splice(l, 1), a.close(), this.dispatchEvent(new H0(o, t));
    }), a.addEventListener("call-ended", (l) => {
      this.dispatchEvent(l);
    }), t === "incoming" && (a.addEventListener("receive-stream", (l) => {
      this.dispatchEvent(l);
    }), e.on("stream", () => {
      Le && console.log("Received stream for call", e.metadata);
      let l = 0;
      const c = setInterval(() => {
        const h = l === 0;
        !a.isOpen && h && (Le && console.warn("Close call because stream is not active", e.metadata), l += 1, clearInterval(c), a.close());
      }, 2e3);
    })), a;
  }
  // private onRemotePeerConnect(user: PeerUserConnectedModel) {
  //     console.log("other user connected", user);
  // }
}
class tu extends um {
  /**
   * Create a new NetworkedStreams instance
   */
  static create(e, t) {
    const i = eo.getOrCreate(e.context, t || e.context.connection.connectionId || e.guid);
    return new tu(e.context, i);
  }
  context;
  peer;
  // private _receiveVideoStreamListeners: Array<(info: IncomingStreamArgs) => void> = [];
  _sendingStreams = /* @__PURE__ */ new Map();
  /**
   * If true, will log debug information
   */
  debug = !1;
  constructor(e, t) {
    if (super(), yk(e)) {
      const i = e;
      e = i.context, t = eo.getOrCreate(i.context, i.guid);
    } else typeof t == "string" && (t = eo.getOrCreate(e, t));
    if (e) {
      if (!(e instanceof N)) throw new Error("Failed to create NetworkedStreams because context is not an instance of Context");
    } else throw new Error("Failed to create NetworkedStreams because context is undefined");
    if (!t) throw new Error("Failed to create NetworkedStreams because peer is undefined");
    this.context = e, this.peer = t, Le && (this.debug = !0);
  }
  startSendingStream(e) {
    this._sendingStreams.has(e) ? console.warn("Received start sending stream with stream that is already being sent") : (this._sendingStreams.set(e, []), this.updateSendingCalls());
  }
  stopSendingStream(e) {
    if (e) {
      const t = this._sendingStreams.get(e);
      if (t) {
        for (const i of t)
          i.close();
        t.length = 0;
      }
      this._sendingStreams.delete(e), t && this.debug && this.debugLogCurrentState();
    }
    this.updateSendingCalls();
  }
  // private onConnectRoomFn: Function = this.onConnectRoom.bind(this);
  // private onUserConnectedFn: Function = this.onUserConnected.bind(this);
  // private onUserLeftFn: Function = this.onUserLeft.bind(this);
  _enabled = !1;
  get enabled() {
    return this._enabled;
  }
  enable() {
    this._enabled || (this._enabled = !0, this.peer.enable(), this.peer.addEventListener("receive-stream", this.onCallStreamReceived), this.peer.addEventListener("call-ended", this.onCallEnded), this.context.connection.beginListen("peer-user-connected", this.onUserConnected), this.context.connection.beginListen(ee.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ee.UserJoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ee.UserLeftRoom, this.onUserLeft), this.context.connection.beginListen(ee.LeftRoom, this.onLeftRoom), this._tickIntervalId = setInterval(this.tick, 5e3));
  }
  disable() {
    this._enabled && (this._enabled = !1, this.peer.disable(), this.peer.removeEventListener("receive-stream", this.onCallStreamReceived), this.peer.removeEventListener("call-ended", this.onCallEnded), this.context.connection.stopListen("peer-user-connected", this.onUserConnected), this.context.connection.stopListen(ee.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ee.UserJoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ee.UserLeftRoom, this.onUserLeft), this.context.connection.stopListen(ee.LeftRoom, this.onLeftRoom), this._tickIntervalId != null && (clearInterval(this._tickIntervalId), this._tickIntervalId = void 0));
  }
  _tickIntervalId;
  /* for webpack */
  tick = () => {
    this.updateSendingCalls();
  };
  // private onUserJoinedPeer = (evt) => {
  //     if (!this.context.connection.isConnected && evt.userId) {
  //         this.startCallWithUserIfNotAlready(evt.userId);
  //     }
  // }
  // When either we ourselves OR someone else is joining the room we want to make sure to re-establish all calls
  // and if the user that joined is not yet receiving our video stream we want to start a stream with them
  // https://github.com/needle-tools/needle-tiny/issues/697#issuecomment-1510425539
  onJoinedRoom = (e) => {
    this._sendingStreams.size > 0 && (this.debug && console.warn(`${e?.userId ? `User ${e.userId}` : "You"} joined room`, e, this._sendingStreams.size), this.updateSendingCalls());
  };
  /** This is when the local user leaves the room */
  onLeftRoom = (e) => {
    this.debug && console.warn(`${e?.userId || "You"} left room`, e), this.stopCallsToUsersThatAreNotInTheRoomAnymore(), this.peer.closeAll();
  };
  onCallStreamReceived = (e) => {
    this.debug && console.log("Call with " + e.userId + " started"), this.dispatchEvent({ type: "receive-stream", target: this, stream: e.stream, userId: e.userId }), this.debug && this.debugLogCurrentState();
  };
  onCallEnded = (e) => {
    this.debug && console.log("Call with " + e.userId + " ended"), this.dispatchEvent(e), this.debug && this.debugLogCurrentState();
  };
  onUserConnected = (e) => {
    if (this.peer.id === e.guid) {
      this.debug && console.log("PEER USER CONNECTED", e.guid, e, this._sendingStreams.size);
      const t = this._sendingStreams.keys().next().value;
      this.peer.makeCall(e.peerId, t);
    } else
      Le && console.log("Unknown user connected", e.guid, e.peerId);
  };
  onUserLeft = (e) => {
    this.debug && console.log("User left room: " + e.userId), this.stopCallsToUsersThatAreNotInTheRoomAnymore();
  };
  updateSendingCalls() {
    const e = this.context.connection.connectionId;
    for (const t of this._sendingStreams.keys()) {
      const i = this._sendingStreams.get(t) || [];
      for (const n of this.context.connection.usersInRoom()) {
        if (n === e) continue;
        const o = this.peer.getPeerIdFromUserId(n);
        if (i.find((a) => a.peerId === o && a.direction === "outgoing" && !a.isClosed && a.stream?.active))
          Le && console.debug("Already have a call with user " + n + " / peer " + o);
        else {
          const a = this.peer.makeCall(o, t);
          a && i.push(a);
        }
      }
      this._sendingStreams.set(t, i);
    }
    this.stopCallsToUsersThatAreNotInTheRoomAnymore();
  }
  // private startCallWithUserIfNotAlready(userId: string) {
  //     for (const stream of this._sendingVideoStreams.keys()) {
  //         const calls = this._sendingVideoStreams.get(stream) || [];
  //         const existing = calls.find(c => c.userId === userId);
  //         if (!existing || existing.stream?.active === false) {
  //             if (this.debug) console.log("Starting call to", userId)
  //             const handle = this.peer.makeCall(this.peer.getPeerIdFromUserId(userId), stream);
  //             if (handle) {
  //                 calls.push(handle);
  //                 return true;
  //             }
  //         }
  //     }
  //     return false;
  // }
  stopCallsToUsersThatAreNotInTheRoomAnymore() {
    for (const e of this._sendingStreams.keys()) {
      const t = this._sendingStreams.get(e);
      if (t)
        for (let i = t.length - 1; i >= 0; i--) {
          const n = t[i];
          this.context.connection.userIsInRoom(n.userId) ? Le && (this.context.connection.connectionId === n.userId ? console.warn(`You are still in the room [${i}] ${n.userId}`) : console.log(`User is still in room [${i}] ${n.userId}`)) : (Le && console.log(`Remove call ${[i]} to user that is not in room anymore ${n.userId}`), n.close(), t.splice(i, 1));
        }
    }
    this.peer.updateCalls(), this.debug && this.debugLogCurrentState();
  }
  debugLogCurrentState() {
    console.warn(`You (${this.context.connection.connectionId}) are currently sending ${this._sendingStreams.size} and receiving ${this.peer.incomingCalls.length} calls (${this.peer.incomingCalls.map((e) => e.userId).join(", ")})`, this.peer.incomingCalls);
  }
  // const call = peer.call(peerId, stream);
}
function ms(s) {
  if (s && s instanceof MediaStream)
    for (const e of s.getTracks())
      e.stop();
}
var Pk = Object.defineProperty, Qm = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Pk(e, t, n), n;
};
const Ok = "noVoip", kk = w("debugvoip");
class _r extends T {
  autoConnect = !0;
  runInBackground = !0;
  createMenuButton = !0;
  /**
   * When enabled debug messages will be printed to the console. This is useful for debugging audio issues. You can also append ?debugvoip to the URL to enable this.
   */
  debug = !1;
  _net;
  _menubutton;
  /** @internal */
  awake() {
    kk && (this.debug = !0), this.debug && (console.log("VOIP debugging: press 'v' to toggle mute or 'c' to toggle connect/disconnect"), window.addEventListener("keydown", async (e) => {
      switch (e.key.toLowerCase()) {
        case "v":
          console.log("MUTE?", !this.isMuted), this.setMuted(!this.isMuted);
          break;
        case "c":
          this.isSending ? this.disconnect() : this.connect();
          break;
      }
    }), window.addEventListener("blur", () => {
      console.log("VOIP: MUTE ON BLUR"), this.setMuted(!0);
    }), window.addEventListener("focus", () => {
      console.log("VOIP: UNMUTE ON FOCUS"), this.setMuted(!1);
    }));
  }
  /** @internal */
  onEnable() {
    this._net || (this._net = tu.create(this)), this.debug && (this._net.debug = !0), this._net.addEventListener(ps.StreamReceived, this.onReceiveStream), this._net.addEventListener(ps.StreamEnded, this.onStreamEnded), this._net.enable(), this.autoConnect && this.context.connection.isConnected && this.connect(), this.context.connection.beginListen(ee.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ee.LeftRoom, this.onLeftRoom), this.onEnabledChanged(), this.updateButton(), window.addEventListener("visibilitychange", this.onVisibilityChanged);
  }
  /** @internal */
  onDisable() {
    this._net && (this._net.stopSendingStream(this._outputStream), this._net.removeEventListener(ps.StreamReceived, this.onReceiveStream), this._net.removeEventListener(ps.StreamEnded, this.onStreamEnded), this._net?.disable()), this.context.connection.stopListen(ee.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ee.LeftRoom, this.onLeftRoom), this.onEnabledChanged(), this.updateButton(), window.removeEventListener("visibilitychange", this.onVisibilityChanged);
  }
  /** @internal */
  onDestroy() {
    this._menubutton?.remove(), this._menubutton = void 0;
  }
  /** Set via the mic button (e.g. when the websocket connection closes and rejoins but the user was muted before we don't want to enable VOIP again automatically) */
  _allowSending = !0;
  _outputStream = null;
  /**
   * @returns true if the component is currently sending audio
   */
  get isSending() {
    return this._outputStream != null && this._outputStream.active;
  }
  /** Start sending audio. */
  async connect(e) {
    if (!this._net)
      return console.error("Cannot connect to voice chat - NetworkedStreams not initialized. Make sure the component is enabled before calling this method."), !1;
    if (this.context.connection.isConnected) {
      if (!await X.microphonePermissionsGranted())
        return console.error("Cannot connect to voice chat - microphone permissions not granted"), this.updateButton(), !1;
    } else return console.error("Cannot connect to voice chat - not connected to server"), this.updateButton(), !1;
    return this._allowSending = !0, this._net?.stopSendingStream(this._outputStream), ms(this._outputStream), this._outputStream = await this.getAudioStream(e), this._outputStream ? (this.debug && console.log("VOIP: Got audio stream"), this._net?.startSendingStream(this._outputStream), this.updateButton(), !0) : (this.updateButton(), await X.microphonePermissionsGranted() ? console.error("VOIP: Could not get audio stream - please make sure to connect an audio device and grant microphone permissions") : Wd("Microphone permissions not granted: Please grant microphone permissions to use voice chat"), (this.debug || L()) && console.log("VOIP: Failed to get audio stream"), !1);
  }
  /** Stop sending audio (muting your own microphone) */
  disconnect(e) {
    e?.remember && (this._allowSending = !1), this._net?.stopSendingStream(this._outputStream), ms(this._outputStream), this._outputStream = null, this.updateButton();
  }
  /**
   * Mute or unmute the audio stream (this will only mute incoming streams and not mute your own microphone. Use disconnect() to mute your own microphone)
   */
  setMuted(e) {
    const t = this._outputStream?.getAudioTracks();
    if (t)
      for (const i of t)
        i.enabled = !e;
  }
  /** Returns true if the audio stream is currently muted */
  get isMuted() {
    if (this._outputStream === null) return !1;
    const e = this._outputStream?.getAudioTracks();
    if (e) {
      for (const t of e)
        if (!t.enabled) return !0;
    }
    return !1;
  }
  async updateButton() {
    if (this.createMenuButton) {
      if (this._menubutton || (this._menubutton = document.createElement("button"), this._menubutton.addEventListener("click", () => {
        this.isSending ? this.disconnect({ remember: !0 }) : this.connect(), X.microphonePermissionsGranted().then((e) => {
          e || ge("<strong>Microphone permissions not granted</strong>. Please allow your browser to use the microphone to be able to talk. Click on the button on the left side of your browser's address bar to allow microphone permissions.");
        });
      })), this._menubutton) {
        this.context.menu.appendChild(this._menubutton), this.activeAndEnabled ? this._menubutton.style.display = "" : this._menubutton.style.display = "none", this._menubutton.title = this.isSending ? "Click to disable your microphone" : "Click to enable your microphone";
        let e = (this.isSending, ""), t = this.isSending ? "mic" : "mic_off";
        await X.microphonePermissionsGranted() || (e = "No Permission", t = "mic_off", this._menubutton.title = "Microphone permissions not granted. Please allow your browser to use the microphone to be able to talk. This can usually be done in the addressbar of the webpage."), this._menubutton.innerText = e, this._menubutton.prepend(Mt(t)), this.context.connection.isConnected == !1 ? this._menubutton.setAttribute("disabled", "") : this._menubutton.removeAttribute("disabled");
      }
    } else this.activeAndEnabled || this._menubutton?.remove();
  }
  // private _analyzer?: AudioAnalyser;
  /** @deprecated */
  getFrequency(e) {
    return this.unsupported_getfrequency || (this.unsupported_getfrequency = !0, L() && ge("VOIP: getFrequency is currently not supported"), console.warn("VOIP: getFrequency is currently not supported")), null;
  }
  async getAudioStream(e) {
    if (!navigator.mediaDevices.getUserMedia)
      return console.error("No getDisplayMedia support"), null;
    const t = async (n) => await navigator.mediaDevices.getUserMedia({ audio: n ?? !0, video: !1 }).catch((o) => (console.warn("VOIP failed getting audio stream", o), null)), i = await t(e);
    if (!i) return null;
    if (X.isiOS() && e?.deviceId === void 0) {
      const o = (await navigator.mediaDevices.enumerateDevices()).find((r) => (r.kind === "audioinput" || r.kind === "audiooutput") && !r.label.includes("iPhone"));
      if (o) {
        const r = Object.assign({}, e);
        return r.deviceId = o.deviceId, await t(r);
      }
    }
    return i;
  }
  // we have to wait for the user to connect to a room when "auto connect" is enabled
  onJoinedRoom = async () => {
    this.debug && console.log("VOIP: Joined room"), await Os(300), this.autoConnect && !this.isSending && this._allowSending && this.connect();
  };
  onLeftRoom = () => {
    this.debug && console.log("VOIP: Left room"), this.disconnect();
    for (const e of this._incomingStreams.values())
      ms(e.srcObject);
    this._incomingStreams.clear();
  };
  _incomingStreams = /* @__PURE__ */ new Map();
  onReceiveStream = (e) => {
    const t = e.target.userId, i = e.stream;
    let n = this._incomingStreams.get(t);
    n || (n = new Audio(), this._incomingStreams.set(t, n)), n.srcObject = i, n.setAttribute("autoplay", "true"), Bn.registerWaitForInteraction(() => {
      n?.play().catch((o) => {
        console.error("VOIP: Failed to play audio", o);
      });
    });
  };
  onStreamEnded = (e) => {
    const t = this._incomingStreams.get(e.userId);
    ms(t?.srcObject), this._incomingStreams.delete(e.userId);
  };
  onEnabledChanged = () => {
    for (const e of this._incomingStreams) {
      const t = e[1];
      t.muted = !this.enabled;
    }
  };
  onVisibilityChanged = () => {
    if (this.runInBackground) return;
    const t = !(document.visibilityState === "visible");
    this.setMuted(t);
    for (const i of this._incomingStreams) {
      const n = i[1];
      n.muted = t;
    }
  };
}
Qm([
  u()
], _r.prototype, "autoConnect");
Qm([
  u()
], _r.prototype, "runInBackground");
Qm([
  u()
], _r.prototype, "createMenuButton");
var Mk = Object.defineProperty, G0 = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Mk(e, t, n), n;
};
const Rk = w("debugmouth");
class iu extends T {
  idle = [];
  talking = [];
  marker = null;
  voip = null;
  lastMouthChangeTime = 0;
  mouthChangeLength = 0;
  awake() {
    setTimeout(() => {
      this.voip = S.findObjectOfType(_r, this.context), this.marker || (this.marker = S.getComponentInParent(this.gameObject, je));
    }, 3e3);
  }
  update() {
    if (!this.voip || this.context.time.frameCount % 10 !== 0) return;
    let e = this.marker?.connectionId ?? null;
    if (!e) {
      Rk && (e = null);
      return;
    }
    const t = this.voip.getFrequency(e) ?? 0;
    this.updateLips(t);
  }
  updateLips(e) {
    if (this.context.time.time - this.lastMouthChangeTime > this.mouthChangeLength) {
      if (this.mouthChangeLength = 0.05 + Math.random() * 0.1, this.talking && this.talking.length > 0 && e > 30) {
        this.lastMouthChangeTime = this.context.time.time;
        const t = Math.floor(Math.random() * this.talking.length);
        this.setMouthShapeActive(this.talking, t);
      } else if (this.idle.length > 0 && this.context.time.time - this.lastMouthChangeTime > 0.5) {
        this.lastMouthChangeTime = this.context.time.time;
        const t = Math.floor(Math.random() * this.idle.length);
        this.setMouthShapeActive(this.idle, t);
      }
    }
  }
  setMouthShapeActive(e, t) {
    if (e) {
      e != this.idle ? this.idle.map((i) => i.visible = !1) : this.talking.map((i) => i.visible = !1);
      for (let i = 0; i < e.length; i++) {
        const n = e[i];
        n && (n.visible = i === t);
      }
    }
  }
  // private tryFindMouthShapes() {
  //     if (this.mouthShapes) return;
  //     this.mouthShapes = [];
  //     this.head?.traverse(o => {
  //         if (o && o.type === "Mesh") {
  //             if (o.name.lastIndexOf("mouth") > 0) {
  //                 this.mouthShapes.push(o as Mesh);
  //             }
  //         }
  //     });
  // }
}
G0([
  u(M)
], iu.prototype, "idle");
G0([
  u(M)
], iu.prototype, "talking");
class q0 extends T {
  voip = null;
  marker = null;
  _startPosition = null;
  awake() {
    this.voip = S.findObjectOfType(_r, this.context), this.marker = S.getComponentInParent(this.gameObject, je);
  }
  update() {
    if (!this.voip || !this.marker || this.context.time.frameCount % 10 !== 0) return;
    const e = this.marker.connectionId, t = this.voip.getFrequency(e);
    if (t == null) return;
    this._startPosition || (this._startPosition = this.gameObject.position.clone());
    const i = t / 100;
    this.gameObject.position.y = this._startPosition.y + i * 0.07;
  }
}
var Tk = Object.defineProperty, Ek = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Tk(e, t, n), n;
};
const Ur = w("debugxrflags"), X0 = w("disablexrflags");
X0 && console.warn("XRFlags are disabled");
var us = /* @__PURE__ */ ((s) => (s[s.Never = 0] = "Never", s[s.Browser = 1] = "Browser", s[s.AR = 2] = "AR", s[s.VR = 4] = "VR", s[s.FirstPerson = 8] = "FirstPerson", s[s.ThirdPerson = 16] = "ThirdPerson", s[s.All = 4294967295] = "All", s))(us || {});
class Zt {
  static Global = new Zt();
  Mask = 17;
  Has(e) {
    return (this.Mask & e) !== 0;
  }
  Set(e) {
    Ur && console.warn("Set XR flag state to", e), this.Mask = e, nn.Apply();
  }
  Enable(e) {
    this.Mask |= e, nn.Apply();
  }
  Disable(e) {
    this.Mask &= ~e, nn.Apply();
  }
  Toggle(e) {
    this.Mask ^= e, nn.Apply();
  }
  EnableAll() {
    this.Mask = -1, nn.Apply();
  }
  DisableAll() {
    this.Mask = 0, nn.Apply();
  }
}
const Q0 = class is extends T {
  static registry = [];
  static Apply() {
    for (const e of this.registry) e.UpdateVisible(Zt.Global);
  }
  static firstApply;
  static buffer = new Zt();
  visibleIn;
  awake() {
    is.registry.push(this);
  }
  onEnable() {
    is.firstApply ? this.UpdateVisible(Zt.Global) : (is.firstApply = !0, is.Apply());
  }
  onDestroy() {
    const e = is.registry.indexOf(this);
    e >= 0 && is.registry.splice(e, 1);
  }
  get isOn() {
    return this.gameObject.visible;
  }
  UpdateVisible(e = null) {
    if (X0)
      return;
    let t;
    const i = e;
    if (i && typeof i == "number" && (console.assert(typeof i == "number", "XRFlag.UpdateVisible: state must be a number", i), Ur && console.log(i), is.buffer.Mask = i, e = is.buffer), e instanceof Zt ? (Ur && console.warn(this.name, "use passed in mask", e.Mask, this.visibleIn), t = e.Has(this.visibleIn)) : (Ur && console.log(this.name, "use global mask"), Zt.Global.Has(this.visibleIn)), t !== void 0)
      if (t)
        Ur && console.log(this.name, "is visible", this.gameObject.uuid), S.setActive(this.gameObject, !0);
      else {
        if (Ur && console.log(this.name, "is not visible", this.gameObject.uuid), !this.gameObject.visible) return;
        this.gameObject.visible = !1;
      }
  }
};
Ek([
  u()
], Q0.prototype, "visibleIn");
let nn = Q0;
var Ak = Object.defineProperty, nu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Ak(e, t, n), n;
};
class Ta extends T {
  eyes = [];
  lastBlinkTime = 0;
  blinkLength = 0;
  eyesOpen = !0;
  state = null;
  awake() {
    this.state = S.getComponentInParent(this.gameObject, nn);
  }
  update() {
    if (!this.gameObject || !this.gameObject.visible || !this.eyes || !Array.isArray(this.eyes) || this.eyes.length === 0) return;
    if (this.context.time.time - this.lastBlinkTime > this.blinkLength) {
      if (this.lastBlinkTime = this.context.time.time, this.state && !this.state.isOn || !this.activeAndEnabled) return;
      if (this.eyesOpen = !this.eyesOpen, this.blinkLength = Math.random(), this.eyesOpen ? (this.blinkLength *= 3, this.blinkLength += 0.5, Math.random() < 0.1 && (this.blinkLength = 0.1 + Math.random() * 0.2)) : (this.blinkLength *= Math.random() * 0.2, this.blinkLength += 0.1), Math.random() < 0.1 && (this.blinkLength *= 3), this.blinkLength = Math.max(0.2, this.blinkLength), this.blinkLength = Math.min(3, this.blinkLength), this.eyes)
        for (const t of this.eyes)
          t && (t.visible = this.eyesOpen);
    }
  }
}
nu([
  u(M)
], Ta.prototype, "eyes");
nu([
  u()
], Ta.prototype, "lastBlinkTime");
nu([
  u()
], Ta.prototype, "blinkLength");
nu([
  u()
], Ta.prototype, "eyesOpen");
var Ik = Object.defineProperty, Ym = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Ik(e, t, n), n;
};
const su = class Y0 extends T {
  head = null;
  eyes = null;
  target = null;
  brain = null;
  awake() {
    this.brain || (this.brain = S.getComponentInParent(this.gameObject, pd)), this.brain || (this.brain = S.addComponent(this.gameObject, pd)), this.brain && this.target && (this.brain.controlledTarget = this.target);
  }
  vec = new b();
  static forward = new b(0, 0, 1);
  currentTargetPoint = new b();
  update() {
    const e = this.target;
    if (e && this.head) {
      const t = this.eyes;
      if (t) {
        const i = Z(e);
        this.currentTargetPoint.lerp(i, this.context.time.deltaTime / 0.1);
        const n = Z(this.head), o = this.vec.copy(this.currentTargetPoint).sub(n).normalize();
        if (o.length() < 0.1) return;
        const r = Y0.forward;
        if (r.set(0, 0, 1), r.applyQuaternion(be(this.head)), r.dot(o) > 0.45)
          for (let l = 0; l < t.length; l++)
            t[l].lookAt(this.currentTargetPoint);
      }
    }
  }
};
Ym([
  u(M)
], su.prototype, "head");
Ym([
  u(M)
], su.prototype, "eyes");
Ym([
  u(M)
], su.prototype, "target");
let K0 = su;
var Lk = Object.defineProperty, Km = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Lk(e, t, n), n;
};
class vc extends T {
  length = 1;
  depthTest = !0;
  isGizmo = !1;
  _axes = null;
  /**
   * Creates and adds the axes visualization to the scene when the component is enabled.
   * If marked as a gizmo, it will only be shown when gizmos are enabled in the global parameters.
   */
  onEnable() {
    if (this.isGizmo && !mc) return;
    this._axes || (this._axes = new mi(this.length)), this._axes.layers.disableAll(), this._axes.layers.set(this.layer), this.gameObject.add(this._axes);
    const e = this._axes.material;
    e && e.depthTest !== void 0 && (e.depthTest = this.depthTest);
  }
  /**
   * Removes the axes visualization from the scene when the component is disabled.
   */
  onDisable() {
    this._axes && this.gameObject.remove(this._axes);
  }
}
Km([
  u()
], vc.prototype, "length");
Km([
  u()
], vc.prototype, "depthTest");
Km([
  u()
], vc.prototype, "isGizmo");
class Z0 extends T {
  from;
  to;
  hint;
  desiredDistance = 1;
  onEnable() {
  }
  update() {
    if (!this.from || !this.to || !this.hint) return;
    const e = Z(this.to).clone(), t = Z(this.from).clone(), i = e.distanceTo(t), n = e.clone();
    n.sub(t);
    const o = t.clone();
    o.add(e), o.multiplyScalar(0.5);
    const r = Z(this.hint).clone();
    r.sub(o);
    const a = new b();
    a.crossVectors(r, n), a.crossVectors(n, a), a.normalize();
    const l = i * 0.5, c = Math.max(this.desiredDistance, l), h = Math.sqrt(c * c - l * l), d = a.clone();
    d.multiplyScalar(h), d.add(o), ut(this.gameObject, d);
    const f = o.clone();
    f.sub(a), this.gameObject.lookAt(f);
  }
}
const Dk = w("gizmos"), jk = w("debugboxhelper");
class Ct extends T {
  /** The bounding box for this component */
  box = null;
  static testBox = new pi();
  _lastMatrixUpdateFrame = -1;
  static _position = new b();
  static _size = new b(0.01, 0.01, 0.01);
  static _emptyObjectSize = new b(0.01, 0.01, 0.01);
  /**
   * Tests if an object intersects with this helper's bounding box
   * @param obj The object to test for intersection
   * @returns True if objects intersect, false if not, undefined if the provided object is invalid
   */
  isInBox(e) {
    if (!e) return;
    if (this.box || (this.box = new pi()), _i([e], void 0, void 0, Ct.testBox), Ct.testBox.isEmpty()) {
      const i = Z(e, Ct._position);
      Ct.testBox.setFromCenterAndSize(i, Ct._emptyObjectSize);
    }
    this.updateBox();
    const t = this.box?.intersectsBox(Ct.testBox);
    return t && jk && F.DrawWireBox3(Ct.testBox, 16711680, 5), t;
  }
  /**
   * Tests if this helper's bounding box intersects with another box
   * @param box The {@link Box3} to test for intersection
   * @returns True if boxes intersect, false otherwise
   */
  intersects(e) {
    return e ? this.updateBox(!1).intersectsBox(e) : !1;
  }
  /**
   * Updates the helper's bounding box based on the gameObject's position and scale
   * @param force Whether to force an update regardless of frame count
   * @returns The updated {@link Box3}
   */
  updateBox(e = !1) {
    if (this.box || (this.box = new pi()), e || this.context.time.frameCount != this._lastMatrixUpdateFrame) {
      const t = this._lastMatrixUpdateFrame < 0;
      this._lastMatrixUpdateFrame = this.context.time.frameCount;
      const i = t, n = Z(this.gameObject, Ct._position, i), o = $e(this.gameObject, Ct._size);
      this.box.setFromCenterAndSize(n, o);
    }
    return this.box;
  }
  _helper = null;
  _color = null;
  awake() {
    this._helper = null, this._color = null, this.box = null;
  }
  /**
   * Creates and displays a visual wireframe representation of this box helper
   * @param col Optional color for the wireframe. If not provided, uses default color
   * @param force If true, shows the helper even if gizmos are disabled
   */
  showHelper(e = null, t = !1) {
    if (!(!Dk && !t)) {
      if (this._helper) {
        e && this._color?.set(e), this.gameObject.add(this._helper);
        return;
      }
      this._helper = Tm(e), this.gameObject.add(this._helper);
    }
  }
}
var Bk = Object.defineProperty, ti = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Bk(e, t, n), n;
};
class wi extends T {
  /**
   * Identifies this component as a collider.
   * @internal
   */
  get isCollider() {
    return !0;
  }
  attachedRigidbody = null;
  isTrigger = !1;
  sharedMaterial;
  membership = [0];
  filter;
  /** @internal */
  awake() {
    super.awake(), this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(ft));
  }
  /** @internal */
  start() {
    this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(ft));
  }
  /** @internal */
  onEnable() {
    this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(ft));
  }
  /** @internal */
  onDisable() {
    this.context.physics.engine?.removeBody(this);
  }
  /**
   * Returns the underlying physics body from the physics engine.
   * Only available if the component is enabled and active in the scene.
   */
  get body() {
    return this.context.physics.engine?.getBody(this);
  }
  /**
   * Updates the collider's properties in the physics engine.
   * Use this when you've changed collider properties and need to sync with the physics engine.
   */
  updateProperties = () => {
    this.context.physics.engine?.updateProperties(this);
  };
  /**
   * Updates the physics material in the physics engine.
   * Call this after changing the sharedMaterial property.
   */
  updatePhysicsMaterial() {
    this.context.physics.engine?.updatePhysicsMaterial(this);
  }
}
ti([
  u(ft)
], wi.prototype, "attachedRigidbody");
ti([
  u()
], wi.prototype, "isTrigger");
ti([
  u()
], wi.prototype, "sharedMaterial");
ti([
  u()
], wi.prototype, "membership");
ti([
  u()
], wi.prototype, "filter");
class wc extends wi {
  radius = 0.5;
  center = new b(0, 0, 0);
  /**
   * Registers the sphere collider with the physics engine and sets up scale change monitoring.
   */
  onEnable() {
    super.onEnable(), this.context.physics.engine?.addSphereCollider(this), bm(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Removes scale change monitoring when the collider is disabled.
   */
  onDisable() {
    super.onDisable(), Rb(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Updates collider properties when validated in the editor or inspector.
   */
  onValidate() {
    this.updateProperties();
  }
}
ti([
  It(),
  u()
], wc.prototype, "radius");
ti([
  u(b)
], wc.prototype, "center");
const Zm = class J0 extends wi {
  /**
   * Creates and adds a BoxCollider to the given object.
   * @param obj The object to add the collider to
   * @param opts Configuration options for the collider and optional rigidbody
   * @returns The newly created BoxCollider
   */
  static add(e, t) {
    const i = An(e, J0);
    return i.autoFit(), t?.rigidbody === !0 && An(e, ft, { isKinematic: !1 }), i;
  }
  size = new b(1, 1, 1);
  center = new b(0, 0, 0);
  /**
   * Registers the box collider with the physics engine and sets up scale change monitoring.
   * @internal
   */
  onEnable() {
    super.onEnable(), this.context.physics.engine?.addBoxCollider(this, this.size), bm(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Removes scale change monitoring when the collider is disabled.
   * @internal
   */
  onDisable() {
    super.onDisable(), Rb(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Updates collider properties when validated in the editor or inspector.
   * @internal
   */
  onValidate() {
    this.updateProperties();
  }
  /**
   * Automatically fits the collider to the geometry of the object.
   * Sets the size and center based on the object's bounding box.
   * @param opts Options object with a debug flag to visualize the bounding box
   */
  autoFit(e) {
    const t = this.gameObject, i = t.position.clone(), n = t.quaternion.clone(), o = t.scale.clone(), r = t.parent;
    t.position.set(0, 0, 0), t.quaternion.set(0, 0, 0, 1), t.scale.set(1, 1, 1), t.parent = null, t.updateMatrix();
    const a = _i([t]);
    t.position.copy(i), t.quaternion.copy(n), t.scale.copy(o), t.parent = r, e?.debug === !0 && F.DrawWireBox3(a, 16768256, 20), this.size = a.getSize(new b()) || new b(1, 1, 1), this.center = a.getCenter(new b()) || new b(0, 0, 0), this.size.length() <= 0 && this.size.set(0.01, 0.01, 0.01);
  }
};
ti([
  It(),
  u(b)
], Zm.prototype, "size");
ti([
  u(b)
], Zm.prototype, "center");
let Jm = Zm;
class br extends wi {
  sharedMesh;
  convex = !1;
  /**
   * Creates and registers the mesh collider with the physics engine.
   * Handles both individual meshes and mesh groups.
   */
  onEnable() {
    if (super.onEnable(), !this.context.physics.engine) return;
    this.sharedMesh?.isMesh || (this.gameObject instanceof H || this.gameObject instanceof io) && (this.sharedMesh = this.gameObject);
    const e = 0;
    if (this.sharedMesh?.isMesh)
      this.context.physics.engine.addMeshCollider(this, this.sharedMesh, this.convex), We.assignMeshLOD(this.sharedMesh, e).then((t) => {
        t && this.activeAndEnabled && this.context.physics.engine && this.sharedMesh && (this.context.physics.engine.removeBody(this), this.sharedMesh.geometry = t, this.context.physics.engine.addMeshCollider(this, this.sharedMesh, this.convex));
      });
    else {
      const t = this.sharedMesh;
      if (t?.isGroup) {
        console.warn(`MeshCollider mesh is a group "${this.sharedMesh?.name || this.gameObject.name}", adding all children as colliders. This is currently not fully supported (colliders can not be removed from world again)`, this);
        const i = new Array();
        for (const n in t.children) {
          const o = t.children[n];
          o.isMesh && (this.context.physics.engine.addMeshCollider(this, o, this.convex), i.push(We.assignMeshLOD(o, e)));
        }
        Promise.all(i).then((n) => {
          if (n.some((r) => r) == !1) return;
          this.context.physics.engine?.removeBody(this);
          const o = new H();
          for (const r of n)
            r && this.activeAndEnabled && (o.geometry = r, this.context.physics.engine?.addMeshCollider(this, o, this.convex));
        });
      } else
        (L() || w("showcolliders")) && console.warn(`[MeshCollider] A MeshCollider mesh is assigned to an unknown object on "${this.gameObject.name}", but it's neither a Mesh nor a Group. Please double check that you attached the collider component to the right object and report a bug otherwise!`, this);
    }
  }
}
ti([
  u(H)
], br.prototype, "sharedMesh");
ti([
  u()
], br.prototype, "convex");
class ho extends wi {
  center = new b(0, 0, 0);
  radius = 0.5;
  height = 2;
  /**
   * Registers the capsule collider with the physics engine.
   */
  onEnable() {
    super.onEnable(), this.context.physics.engine?.addCapsuleCollider(this, this.height, this.radius);
  }
}
ti([
  u(b)
], ho.prototype, "center");
ti([
  u()
], ho.prototype, "radius");
ti([
  u()
], ho.prototype, "height");
var Fk = Object.defineProperty, Rs = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Fk(e, t, n), n;
};
const p_ = w("debugcharactercontroller");
class Ea extends T {
  center = new b(0, 0, 0);
  radius = 0.5;
  height = 2;
  _rigidbody = null;
  get rigidbody() {
    return this._rigidbody ? this._rigidbody : (this._rigidbody = this.gameObject.getComponent(ft), this._rigidbody || (this._rigidbody = this.gameObject.addComponent(ft)), this.rigidbody);
  }
  _activeGroundCollisions;
  awake() {
    this._activeGroundCollisions = /* @__PURE__ */ new Set();
  }
  onEnable() {
    const e = this.rigidbody;
    let t = this.gameObject.getComponent(ho);
    t || (t = this.gameObject.addComponent(ho)), t.center.copy(this.center), t.radius = this.radius, t.height = this.height;
    const i = new b(0, 0, 1), n = new b(1, 0, 0), o = new b(0, 1, 0), r = this.gameObject.getWorldDirection(new b());
    r.y = 0;
    const a = n.dot(r) < 0 ? -1 : 1, l = i.angleTo(r) * a;
    this.gameObject.setRotationFromAxisAngle(o, l), e.lockRotationX = !0, e.lockRotationY = !0, e.lockRotationZ = !0;
  }
  move(e) {
    this.gameObject.position.add(e);
  }
  onCollisionEnter(e) {
    (e.contacts.length == 0 || e.contacts.some((t) => t.normal.y > 0.2)) && (this._activeGroundCollisions.add(e), p_ && console.log(`Collision(${this._activeGroundCollisions.size}): ${e.contacts.map((t) => t.normal.y.toFixed(2)).join(", ")} - ${this.isGrounded}`));
  }
  onCollisionExit(e) {
    this._activeGroundCollisions.delete(e), p_ && console.log(`Collision(${this._activeGroundCollisions.size}) - ${this.isGrounded}`);
  }
  get isGrounded() {
    return this._activeGroundCollisions.size > 0;
  }
  _contactVelocity = new b();
  get contactVelocity() {
    this._contactVelocity.set(0, 0, 0);
    for (const e of this._activeGroundCollisions) {
      const t = this.context.physics.engine?.getLinearVelocity(e.collider);
      t && (this._contactVelocity.x += t.x, this._contactVelocity.y += t.y, this._contactVelocity.z += t.z);
    }
    return this._contactVelocity;
  }
}
Rs([
  u(b)
], Ea.prototype, "center");
Rs([
  u()
], Ea.prototype, "radius");
Rs([
  u()
], Ea.prototype, "height");
class mo extends T {
  controller;
  movementSpeed = 2;
  rotationSpeed = 2;
  jumpForce = 1;
  doubleJumpForce = 2;
  animator;
  lookForward = !0;
  awake() {
    this._currentRotation = new $();
  }
  update() {
    const e = this.context.input;
    e.isKeyPressed("KeyW") ? this.moveInput.y += 1 : e.isKeyPressed("KeyS") && (this.moveInput.y -= 1), e.isKeyPressed("KeyD") ? this.lookInput.x += 1 : e.isKeyPressed("KeyA") && (this.lookInput.x -= 1), this.jumpInput ||= e.isKeyDown("Space");
  }
  move(e) {
    this.moveInput.add(e);
  }
  look(e) {
    this.lookInput.add(e);
  }
  jump() {
    this.jumpInput = !0;
  }
  lookInput = new J(0, 0);
  moveInput = new J(0, 0);
  jumpInput = !1;
  onBeforeRender() {
    this.handleInput(this.moveInput, this.lookInput, this.jumpInput), this.lookInput.set(0, 0), this.moveInput.set(0, 0), this.jumpInput = !1;
  }
  _currentSpeed = new b(0, 0, 0);
  _currentAngularSpeed = new b(0, 0, 0);
  _temp = new b(0, 0, 0);
  _jumpCount = 0;
  _currentRotation;
  handleInput(e, t, i) {
    if (this.controller?.isGrounded && (this._jumpCount = 0, this.doubleJumpForce > 0 && this.animator?.setBool("doubleJump", !1)), this._currentSpeed.z += e.y * this.movementSpeed * this.context.time.deltaTime, this.animator?.setBool("running", e.length() > 0.01), this.animator?.setBool("jumping", this.controller?.isGrounded === !0 && i), this._temp.copy(this._currentSpeed), this._temp.applyQuaternion(this.gameObject.quaternion), this.controller ? this.controller.move(this._temp) : this.gameObject.position.add(this._temp), this._currentAngularSpeed.y += j.toRadians(-t.x * this.rotationSpeed) * this.context.time.deltaTime, this.lookForward && Math.abs(this._currentAngularSpeed.y) < 0.01) {
      const n = this.context.mainCameraComponent.forward;
      n.y = 0, n.normalize(), this._currentRotation.setFromUnitVectors(new b(0, 0, 1), n), this.gameObject.quaternion.slerp(this._currentRotation, this.context.time.deltaTime * 10);
    }
    if (this.gameObject.rotateY(this._currentAngularSpeed.y), this._currentSpeed.multiplyScalar(1 - this.context.time.deltaTime * 10), this._currentAngularSpeed.y *= 1 - this.context.time.deltaTime * 10, this.controller && i && this.jumpForce > 0) {
      let n = this.controller?.isGrounded;
      if (this.doubleJumpForce > 0 && !this.controller?.isGrounded && this._jumpCount === 1 && (n = !0, this.animator?.setBool("doubleJump", !0)), n) {
        this._jumpCount += 1;
        const o = this.controller.rigidbody, r = this._jumpCount === 2 ? this.doubleJumpForce : this.jumpForce;
        o.applyImpulse(new b(0, 1, 0).multiplyScalar(r));
      }
    }
    if (this.controller) {
      const n = this.controller?.rigidbody.getVelocity().y;
      if (n < -1) {
        this._raycastOptions.ray || (this._raycastOptions.ray = new lo()), this._raycastOptions.ray.origin.copy(Z(this.gameObject)), this._raycastOptions.ray.direction.set(0, -1, 0);
        const o = this.layer;
        this.gameObject.layers.disableAll(), this.gameObject.layers.set(2);
        const r = this.context.physics.raycast(this._raycastOptions);
        this.gameObject.layers.set(o), (r.length && r[0].distance > 2 || n < -10) && this.animator?.setBool("falling", !0);
      } else this.animator?.setBool("falling", !1);
    }
  }
  _raycastOptions = new mr();
}
Rs([
  u(Ea)
], mo.prototype, "controller");
Rs([
  u()
], mo.prototype, "movementSpeed");
Rs([
  u()
], mo.prototype, "rotationSpeed");
Rs([
  u()
], mo.prototype, "jumpForce");
Rs([
  u()
], mo.prototype, "doubleJumpForce");
Rs([
  u(At)
], mo.prototype, "animator");
var zk = Object.defineProperty, Aa = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && zk(e, t, n), n;
};
const sl = w("debugcontactshadows");
B0((s) => {
  const e = s.domElement.getAttribute("contactshadows") || s.domElement.getAttribute("contact-shadows");
  if (e != null && e != "0" && e != "false") {
    console.debug("Auto-creating ContactShadows because of `contactshadows` attribute");
    const t = ou.auto(s), i = parseFloat(e);
    isNaN(i) || (t.opacity = i, t.darkness = i);
  }
});
const vr = class Cl extends T {
  static _instances = /* @__PURE__ */ new Map();
  /**
   * Create contact shadows for the scene. Automatically fits the shadows to the scene.  
   * The instance of contact shadows will be created only once.  
   * @param context The context to create the contact shadows in.
   * @returns The instance of the contact shadows.
   */
  static auto(e) {
    if (e || (e = N.Current), !e)
      throw new Error("No context provided and no current context set.");
    let t = this._instances.get(e);
    if (!t || t.destroyed) {
      const i = new M();
      t = An(i, Cl, {
        autoFit: !1,
        occludeBelowGround: !1
      }), this._instances.set(e, t);
    }
    return e.scene.add(t.gameObject), t.fitShadows(), t;
  }
  autoFit = !1;
  darkness = 0.5;
  opacity = 0.5;
  blur = 4;
  occludeBelowGround = !1;
  backfaceShadows = !0;
  /**
   * The minimum size of the shadows box
   */
  minSize;
  /**
   * When enabled the shadows will not be updated automatically. Use `needsUpdate()` to update the shadows manually.
   * This is useful when you want to update the shadows only when the scene changes.
   */
  manualUpdate = !1;
  /**
   * Call this method to update the shadows manually. The update will be done in the next frame.
   */
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  _needsUpdate = !1;
  /** All shadow objects are parented to this object. 
   * The gameObject itself should not be transformed because we want the ContactShadows object e.g. also have a GroundProjectedEnv component
   * in which case ContactShadows scale would affect the projection
   **/
  shadowsRoot = new M();
  shadowCamera;
  shadowGroup = new io();
  renderTarget;
  renderTargetBlur;
  plane;
  occluderMesh;
  blurPlane;
  depthMaterial;
  horizontalBlurMaterial;
  verticalBlurMaterial;
  textureSize = 512;
  /**
   * Call to fit the shadows to the scene.
   */
  fitShadows() {
    sl && console.warn("Fitting shadows to scene"), cp(this.shadowsRoot, !1);
    const e = _i(this.context.scene.children, [this.shadowsRoot]), t = Math.max(1, this.blur / 32), i = e.max.x - e.min.x, n = e.max.z - e.min.z;
    e.expandByVector(new b(t * i, 0, t * n)), sl && F.DrawWireBox3(e, 16776960, 60), this.gameObject.parent && e.applyMatrix4(this.gameObject.parent.matrixWorld.clone().invert());
    const o = e.min, r = Math.max(1e-5, (e.max.y - o.y) * 2e-3);
    e.max.y += r, this.shadowsRoot.position.set((o.x + e.max.x) / 2, o.y - r, (o.z + e.max.z) / 2), this.shadowsRoot.scale.set(e.max.x - o.x, e.max.y - o.y, e.max.z - o.z), this.applyMinSize(), this.shadowsRoot.matrixWorldNeedsUpdate = !0, sl && console.log("Fitted shadows to scene", this.shadowsRoot.scale.clone());
  }
  /** @internal */
  awake() {
    Cl._instances.set(this.context, this), this.shadowsRoot.hideFlags = Xm.DontExport, cp(this.shadowsRoot, !1);
  }
  /** @internal */
  start() {
    sl && console.log("Create ContactShadows on " + this.gameObject.name, this), this.gameObject.add(this.shadowsRoot), this.shadowsRoot.add(this.shadowGroup), this.renderTarget = new Dn(this.textureSize, this.textureSize), this.renderTarget.texture.generateMipmaps = !1, this.renderTargetBlur = new Dn(this.textureSize, this.textureSize), this.renderTargetBlur.texture.generateMipmaps = !1;
    const e = new Un(1, 1).rotateX(Math.PI / 2);
    this.gameObject instanceof H && (console.warn("ContactShadows can not be added to a Mesh. Please add it to a Group or an empty Object"), hs(this.gameObject, !1));
    const t = new we({
      map: this.renderTarget.texture,
      opacity: this.opacity,
      color: 0,
      transparent: !0,
      depthWrite: !1,
      side: co
    });
    this.plane = new H(e, t), this.plane.scale.y = -1, this.plane.layers.set(2), this.shadowsRoot.add(this.plane), this.plane && (this.plane.renderOrder = 1), this.occluderMesh = new H(this.plane.geometry, new we({
      depthWrite: !0,
      stencilWrite: !0,
      colorWrite: !1,
      side: Bd
    })).translateY(-1e-4), this.occluderMesh.renderOrder = -100, this.occluderMesh.layers.set(2), this.shadowsRoot.add(this.occluderMesh), this.blurPlane = new H(e), this.blurPlane.visible = !1, this.shadowGroup.add(this.blurPlane);
    const i = 0, n = 1;
    this.shadowCamera = new Td(-1 / 2, 1 / 2, 1 / 2, -1 / 2, i, n), this.shadowCamera.layers.enableAll(), this.shadowCamera.rotation.x = Math.PI / 2, this.shadowGroup.add(this.shadowCamera), this.depthMaterial = new hx(), this.depthMaterial.userData.darkness = { value: this.darkness }, this.depthMaterial.blending = dx, this.depthMaterial.blendEquation = ux, this.depthMaterial.onBeforeCompile = (o) => {
      this.depthMaterial && (o.uniforms.darkness = this.depthMaterial.userData.darkness, o.fragmentShader = /* glsl */
      `
                uniform float darkness;
                ${o.fragmentShader.replace(
        "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        // we're scaling the shadow value down a bit when it's a backface (looks better)
        "gl_FragColor = vec4( vec3( 1.0 ), ( 1.0 - fragCoordZ ) * darkness * opacity * (gl_FrontFacing ? 1.0 : 0.66) );"
      )}
            `);
    }, this.depthMaterial.depthTest = !1, this.depthMaterial.depthWrite = !1, this.horizontalBlurMaterial = new Ln(pS), this.horizontalBlurMaterial.depthTest = !1, this.verticalBlurMaterial = new Ln(mS), this.verticalBlurMaterial.depthTest = !1, this.shadowGroup.visible = !1, this.autoFit ? this.fitShadows() : this.applyMinSize();
  }
  onEnable() {
    this._needsUpdate = !0;
  }
  /** @internal */
  onDestroy() {
    Cl._instances.get(this.context) === this && Cl._instances.delete(this.context), this.renderTarget?.dispose(), this.renderTargetBlur?.dispose(), this.depthMaterial?.dispose(), this.horizontalBlurMaterial?.dispose(), this.verticalBlurMaterial?.dispose(), this.blurPlane?.geometry.dispose(), this.plane?.geometry.dispose(), this.occluderMesh?.geometry.dispose();
  }
  /** @internal */
  onBeforeRender(e) {
    if (this.manualUpdate && !this._needsUpdate)
      return;
    if (this._needsUpdate = !1, !this.renderTarget || !this.renderTargetBlur || !this.depthMaterial || !this.shadowCamera || !this.blurPlane || !this.shadowGroup || !this.plane || !this.horizontalBlurMaterial || !this.verticalBlurMaterial) {
      sl && console.error("ContactShadows: not initialized yet");
      return;
    }
    const t = this.context.scene, i = this.context.renderer, n = i.getRenderTarget();
    this.shadowGroup.visible = !0, this.occluderMesh && (this.occluderMesh.visible = !1);
    const o = this.plane.visible;
    this.plane.visible = !1, this.gameObject instanceof H && hs(this.gameObject, !1);
    const r = t.background;
    t.background = null, t.overrideMaterial = this.depthMaterial, this.backfaceShadows ? this.depthMaterial.side = yi : this.depthMaterial.side = co;
    const a = i.getClearAlpha();
    i.setClearAlpha(0);
    const l = i.xr.enabled;
    i.xr.enabled = !1;
    const c = this.context.scene.matrixWorldAutoUpdate;
    this.context.scene.matrixWorldAutoUpdate = !1;
    const h = i.renderLists.get(t, 0), d = h.transparent;
    m_.length = 0, h.transparent = m_, xf.length = 0;
    for (const p of h.opaque) {
      if (!p.object.visible) continue;
      const g = p.material;
      let _ = p.material.colorWrite == !1 || g.wireframe === !0 || zC(p.object) === !1;
      !_ && p.material.isLineMaterial && (_ = !0), !_ && p.material.isPointsMaterial && (_ = !0), _ && (xf.push(p.object), p.object["needle:visible"] = p.object.visible, p.object.visible = !1);
    }
    i.setRenderTarget(this.renderTarget), i.clear(), i.render(t, this.shadowCamera), h.transparent = d;
    for (const p of xf)
      p["needle:visible"] != null && (p.visible = p["needle:visible"]);
    t.overrideMaterial = null;
    const f = Math.max(this.blur, 0.05);
    this.blurShadow(f * 2), this.blurShadow(f * 0.5), this.shadowGroup.visible = !1, this.occluderMesh && (this.occluderMesh.visible = this.occludeBelowGround), this.plane.visible = o, i.setRenderTarget(n), i.setClearAlpha(a), t.background = r, i.xr.enabled = l, this.context.scene.matrixWorldAutoUpdate = c;
  }
  // renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget
  blurShadow(e) {
    if (!this.blurPlane || !this.shadowCamera || !this.renderTarget || !this.renderTargetBlur || !this.horizontalBlurMaterial || !this.verticalBlurMaterial)
      return;
    this.blurPlane.visible = !0;
    const t = this.shadowsRoot.worldScale, i = (t.x + t.z) / 2, n = t.z / i, o = t.x / i;
    this.blurPlane.material = this.horizontalBlurMaterial, this.blurPlane.material.uniforms.tDiffuse.value = this.renderTarget.texture, this.horizontalBlurMaterial.uniforms.h.value = e * 1 / this.textureSize * n;
    const r = this.context.renderer, a = r.getRenderTarget();
    r.setRenderTarget(this.renderTargetBlur), r.render(this.blurPlane, this.shadowCamera), this.blurPlane.material = this.verticalBlurMaterial, this.blurPlane.material.uniforms.tDiffuse.value = this.renderTargetBlur.texture, this.verticalBlurMaterial.uniforms.v.value = e * 1 / this.textureSize * o, r.setRenderTarget(this.renderTarget), r.render(this.blurPlane, this.shadowCamera), this.blurPlane.visible = !1, r.setRenderTarget(a);
  }
  applyMinSize() {
    this.minSize && this.shadowsRoot.scale.set(
      Math.max(this.minSize.x || 0, this.shadowsRoot.scale.x),
      Math.max(this.minSize.y || 0, this.shadowsRoot.scale.y),
      Math.max(this.minSize.z || 0, this.shadowsRoot.scale.z)
    );
  }
};
Aa([
  u()
], vr.prototype, "autoFit");
Aa([
  u()
], vr.prototype, "darkness");
Aa([
  u()
], vr.prototype, "opacity");
Aa([
  u()
], vr.prototype, "blur");
Aa([
  u()
], vr.prototype, "occludeBelowGround");
Aa([
  u()
], vr.prototype, "backfaceShadows");
let ou = vr;
const m_ = [], xf = new Array(), Uk = w("logstats");
class ev extends T {
  onEnable() {
    console.log(this), Uk && this.startCoroutine(this.run(), xe.OnAfterRender);
  }
  *run() {
    for (; this.enabled; ) {
      const e = this.context.renderer.info;
      console.log(e.memory, e.render, e.programs), yield;
    }
  }
}
class ru extends T {
  isUsed = !0;
  usedBy = null;
}
class tv extends T {
}
const g_ = w("debugdeletable");
class er extends Ct {
  static _instances = [];
  onEnable() {
    er._instances.push(this);
  }
  onDisable() {
    const e = er._instances.indexOf(this);
    e >= 0 && er._instances.splice(e, 1);
  }
}
class iv extends T {
  update() {
    for (const e of er._instances) {
      const t = this.gameObject;
      if (e.isInBox(t) === !0) {
        const n = S.getComponentInParent(this.gameObject, ru);
        if (n)
          g_ && console.warn("DeleteBox: Not deleting object with usage marker", this.guid, n);
        else {
          if (g_)
            try {
              if (e.box) {
                const o = e.box, r = Ct.testBox;
                F.DrawWireBox3(o, 16711680, 5), F.DrawWireBox3(r, 255, 5), console.log("DeleteBox: Destroying", this.gameObject, { deleteBoxArea: o, deletedObjectArea: r });
              } else
                console.log("DeleteBox: Destroying", this.gameObject);
            } catch {
            }
          Hd(this.gameObject, this.context.connection);
        }
      }
    }
  }
}
var Nk = Object.defineProperty, $k = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Nk(e, t, n), n;
};
class eg extends T {
  visibleOn;
  onEnable() {
    this.apply();
  }
  apply() {
    this.test() || S.setActive(this.gameObject, !1);
  }
  test() {
    return this.visibleOn < 0 ? !0 : X.isMobileDevice() ? (this.visibleOn & 2) !== 0 : (this.visibleOn & 1) !== 0;
  }
}
$k([
  u()
], eg.prototype, "visibleOn");
var Wk = Object.defineProperty, wr = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Wk(e, t, n), n;
};
const kn = w("debugdrag"), Sf = [];
var nv = /* @__PURE__ */ ((s) => (s[s.XZPlane = 0] = "XZPlane", s[s.Attached = 1] = "Attached", s[s.HitNormal = 2] = "HitNormal", s[s.DynamicViewAngle = 3] = "DynamicViewAngle", s[s.SnapToSurfaces = 4] = "SnapToSurfaces", s[s.None = 5] = "None", s))(nv || {});
const go = class Ii extends T {
  /**
   * Checks if any DragControls component is currently active with selected objects
   * @returns True if any DragControls component is currently active
   */
  static get HasAnySelected() {
    return this._active > 0;
  }
  static _active = 0;
  /** 
   * Retrieves a list of all DragControl components that are currently dragging objects.
   * @returns Array of currently active DragControls components
   */
  static get CurrentlySelected() {
    Sf.length = 0;
    for (const e of this._instances)
      e._isDragging && Sf.push(e);
    return Sf;
  }
  /** Registry of currently active and enabled DragControls components */
  static _instances = [];
  dragMode = 3;
  snapGridResolution = 0;
  keepRotation = !0;
  xrDragMode = 1;
  xrKeepRotation = !1;
  xrDistanceDragFactor = 1;
  showGizmo = !1;
  /** 
   * Returns the object currently being dragged by this DragControls component, if any.
   * @returns The object being dragged or null if no object is currently dragged
   */
  get draggedObject() {
    return this._targetObject;
  }
  /**
   * Updates the object that is being dragged by the DragControls.
   * This can be used to change the target during a drag operation.
   * @param obj The new object to drag, or null to stop dragging
   */
  setTargetObject(e) {
    this._targetObject = e;
    for (const i of this._dragHandlers.values())
      i.setTargetObject(e);
    const t = "_rigidbody-was-kinematic";
    this._rigidbody?.[t] === !1 && (this._rigidbody.isKinematic = !1, this._rigidbody[t] = void 0), this._rigidbody = null, e && (this._rigidbody = S.getComponentInChildren(e, ft), this._rigidbody?.isKinematic === !1 && (this._rigidbody.isKinematic = !0, this._rigidbody[t] = !1));
  }
  _rigidbody = null;
  // future:
  // constraints?
  /** The object to be dragged – we pass this to handlers when they are created */
  _targetObject = null;
  _dragHelper = null;
  static lastHovered;
  _draggingRigidbodies = [];
  _potentialDragStartEvt = null;
  _dragHandlers = /* @__PURE__ */ new Map();
  _totalMovement = new b();
  /** A marker is attached to components that are currently interacted with, to e.g. prevent them from being deleted. */
  _marker = null;
  _isDragging = !1;
  _didDrag = !1;
  /** @internal */
  awake() {
    this._potentialDragStartEvt = null, this._dragHandlers = /* @__PURE__ */ new Map(), this._totalMovement = new b(), this._marker = null, this._isDragging = !1, this._didDrag = !1, this._dragHelper = null, this._draggingRigidbodies = [];
  }
  /** @internal */
  start() {
    this.gameObject.getComponentInParent(Vi) || this.gameObject.addComponent(Vi);
  }
  /** @internal */
  onEnable() {
    Ii._instances.push(this);
  }
  /** @internal */
  onDisable() {
    Ii._instances = Ii._instances.filter((e) => e !== this);
  }
  /**
   * Checks if editing is allowed for the current networking connection.
   * @param _obj Optional object to check edit permissions for
   * @returns True if editing is allowed
   */
  allowEdit(e = null) {
    return this.context.connection.allowEditing;
  }
  /** 
   * Handles pointer enter events. Sets the cursor style and tracks the hovered object.
   * @param evt Pointer event data containing information about the interaction
   * @internal
   */
  onPointerEnter(e) {
    if (!this.allowEdit(this.gameObject) || e.mode !== "screen" || (e.event.mode === "tracked-pointer" || e.event.mode === "transient-pointer" ? this.xrDragMode : this.dragMode) === 5) return;
    const n = S.getComponentInParent(e.object, Ii);
    !n || n !== this || (Ii.lastHovered = e.object, this.context.domElement.style.cursor = "pointer");
  }
  /** 
   * Handles pointer movement events. Marks the event as used if dragging is active.
   * @param args Pointer event data containing information about the movement
   * @internal
   */
  onPointerMove(e) {
    (this._isDragging || this._potentialDragStartEvt !== null) && e.use();
  }
  /** 
   * Handles pointer exit events. Resets the cursor style when the pointer leaves a draggable object.
   * @param evt Pointer event data containing information about the interaction
   * @internal
   */
  onPointerExit(e) {
    this.allowEdit(this.gameObject) && e.mode === "screen" && Ii.lastHovered === e.object && (this.context.domElement.style.cursor = "auto");
  }
  /** 
   * Handles pointer down events. Initiates the potential drag operation if conditions are met.
   * @param args Pointer event data containing information about the interaction
   * @internal
   */
  onPointerDown(e) {
    if (!(!this.allowEdit(this.gameObject) || e.used || (e.mode === "tracked-pointer" || e.mode === "transient-pointer" ? this.xrDragMode : this.dragMode) === 5) && (Ii.lastHovered = e.object, e.button === 0)) {
      this._dragHandlers.size === 0 && (this._didDrag = !1, this._totalMovement.set(0, 0, 0), this._potentialDragStartEvt = e), this._targetObject || this.setTargetObject(this.gameObject), Ii._active += 1;
      const n = new Cf(this, this._targetObject);
      if (this._dragHandlers.set(e.event.space, n), n.onDragStart(e), this._dragHandlers.size === 2) {
        const o = this._dragHandlers.values(), r = o.next().value, a = o.next().value;
        if (r instanceof Cf && a instanceof Cf) {
          const l = new Vk(this, this._targetObject, r, a);
          this._dragHandlers.set(this.gameObject, l), l.onDragStart(e);
        } else
          console.error("Attempting to construct a MultiTouchDragHandler with invalid DragPointerHandlers. This is likely a bug.", { a: r, b: a });
      }
      e.use();
    }
  }
  /** 
   * Handles pointer up events. Finalizes or cancels the drag operation.
   * @param args Pointer event data containing information about the interaction
   * @internal
   */
  onPointerUp(e) {
    if (kn && F.DrawLabel(e.point ?? this.gameObject.worldPosition, "POINTERUP:" + e.pointerId + ", " + e.button, 0.03, 3), !this.allowEdit(this.gameObject) || e.button !== 0) return;
    this._potentialDragStartEvt = null;
    const t = this._dragHandlers.get(e.event.space), i = this._dragHandlers.get(this.gameObject);
    i && (i.handlerA === t || i.handlerB === t) && (this._dragHandlers.delete(this.gameObject), i.onDragEnd(e)), t && (Ii._active > 0 && (Ii._active -= 1), this.setTargetObject(null), t.onDragEnd && t.onDragEnd(e), this._dragHandlers.delete(e.event.space), this._dragHandlers.size === 0 && this.onLastDragEnd(e), e.use());
  }
  /**
   * Updates the drag operation every frame. Processes pointer movement, accumulates drag distance
   * and triggers drag start once there's enough movement.
   * @internal
   */
  update() {
    for (const e of this._dragHandlers.values())
      e.collectMovementInfo && e.collectMovementInfo(), e.getTotalMovement && this._totalMovement.add(e.getTotalMovement());
    if (this._potentialDragStartEvt) {
      if (!this._didDrag)
        if (this._totalMovement.length() > 3e-4)
          this._didDrag = !0;
        else return;
      const e = this._potentialDragStartEvt;
      this._potentialDragStartEvt = null, this.onFirstDragStart(e);
    }
    for (const e of this._dragHandlers.values())
      e.onDragUpdate && e.onDragUpdate(this._dragHandlers.size);
    this._dragHelper && this._dragHelper.hasSelected && this.onAnyDragUpdate();
  }
  /** 
   * Called when the first pointer starts dragging on this object. 
   * Sets up network synchronization and marks rigidbodies for dragging.
   * Not called for subsequent pointers on the same object.
   * @param evt Pointer event data that initiated the drag
   */
  onFirstDragStart(e) {
    if (!e || !e.object) return;
    const t = S.getComponentInParent(e.object, Ii);
    if (!t || t !== this && t._isDragging) return;
    const i = this._targetObject || this.gameObject;
    if (!i) return;
    this._isDragging = !0;
    const n = S.getComponentInChildren(i, Fn);
    kn && console.log("DRAG START", n, i), n && (n.fastMode = !0, n?.requestOwnership()), this._marker = S.addComponent(i, ru), this._draggingRigidbodies.length = 0;
    const o = S.getComponentsInChildren(i, ft);
    o && this._draggingRigidbodies.push(...o);
  }
  /** 
   * Called each frame as long as any pointer is dragging this object.
   * Updates visuals and keeps rigidbodies awake during the drag.
   */
  onAnyDragUpdate() {
    if (!this._dragHelper) return;
    this._dragHelper.showGizmo = this.showGizmo, this._dragHelper.onUpdate(this.context);
    for (const t of this._draggingRigidbodies)
      t.wakeUp(), t.resetVelocities(), t.resetForcesAndTorques();
    const e = this._targetObject || this.gameObject;
    sn.markDirty(e);
  }
  /** 
   * Called when the last pointer has been removed from this object.
   * Cleans up drag state and applies final velocities to rigidbodies.
   * @param evt Pointer event data for the last pointer that was lifted
   */
  onLastDragEnd(e) {
    if (!this || !this._isDragging) return;
    this._isDragging = !1;
    for (const i of this._draggingRigidbodies)
      i.setVelocity(i.smoothedVelocity);
    if (this._draggingRigidbodies.length = 0, this._targetObject = null, e?.object) {
      const i = S.getComponentInChildren(e.object, Fn);
      i && (i.fastMode = !1);
    }
    if (this._marker && this._marker.destroy(), !this._dragHelper) return;
    const t = this._dragHelper.selected;
    kn && console.log("DRAG END", t, t?.visible), this._dragHelper.setSelected(null, this.context);
  }
};
wr([
  u()
], go.prototype, "dragMode");
wr([
  u()
], go.prototype, "snapGridResolution");
wr([
  u()
], go.prototype, "keepRotation");
wr([
  u()
], go.prototype, "xrDragMode");
wr([
  u()
], go.prototype, "xrKeepRotation");
wr([
  u()
], go.prototype, "xrDistanceDragFactor");
wr([
  u()
], go.prototype, "showGizmo");
let Gr = go;
class Vk {
  handlerA;
  handlerB;
  context;
  settings;
  gameObject;
  _handlerAAttachmentPoint = new b();
  _handlerBAttachmentPoint = new b();
  _followObject;
  _manipulatorObject;
  _deviceMode;
  _followObjectStartWorldQuaternion = new $();
  constructor(e, t, i, n) {
    this.context = e.context, this.settings = e, this.gameObject = t, this.handlerA = i, this.handlerB = n, this._followObject = new M(), this._manipulatorObject = new M(), this.context.scene.add(this._manipulatorObject);
    const o = K.active?.rig?.gameObject;
    if (!this.handlerA || !this.handlerB || !this.handlerA.hitPointInLocalSpace || !this.handlerB.hitPointInLocalSpace) {
      console.error("Invalid: MultiTouchDragHandler needs two valid DragPointerHandlers with hitPointInLocalSpace set.");
      return;
    }
    if (this._tempVec1.copy(this.handlerA.hitPointInLocalSpace), this._tempVec2.copy(this.handlerB.hitPointInLocalSpace), this.gameObject.localToWorld(this._tempVec1), this.gameObject.localToWorld(this._tempVec2), o && (o.worldToLocal(this._tempVec1), o.worldToLocal(this._tempVec2)), this._initialDistance = this._tempVec1.distanceTo(this._tempVec2), this._initialDistance < 0.02 ? (kn && console.log("Finding alternative drag attachment points since initial distance is too low: " + this._initialDistance.toFixed(2)), this.handlerA.followObject.parent.getWorldPosition(this._tempVec1), this.handlerB.followObject.parent.getWorldPosition(this._tempVec2), this._handlerAAttachmentPoint.copy(this._tempVec1), this._handlerBAttachmentPoint.copy(this._tempVec2), this.gameObject.worldToLocal(this._handlerAAttachmentPoint), this.gameObject.worldToLocal(this._handlerBAttachmentPoint), this._initialDistance = this._tempVec1.distanceTo(this._tempVec2), this._initialDistance < 1e-3 && (console.warn("Not supported right now – controller drag points for multitouch are too close!"), this._initialDistance = 1)) : (this._handlerAAttachmentPoint.copy(this.handlerA.hitPointInLocalSpace), this._handlerBAttachmentPoint.copy(this.handlerB.hitPointInLocalSpace)), this._tempVec3.lerpVectors(this._tempVec1, this._tempVec2, 0.5), this._initialScale.copy(t.scale), kn) {
      this._followObject.add(new mi(2)), this._manipulatorObject.add(new mi(5));
      const r = (a) => `${a.x.toFixed(2)}, ${a.y.toFixed(2)}, ${a.z.toFixed(2)}`;
      F.DrawLine(this._tempVec1, this._tempVec2, 65535, 0, !1), F.DrawLabel(this._tempVec3, "A:B " + this._initialDistance.toFixed(2) + `
` + r(this._tempVec1) + `
` + r(this._tempVec2), 0.03, 5);
    }
  }
  onDragStart(e) {
    this.gameObject.add(this._followObject), this._followObject.matrixAutoUpdate = !1, this._followObject.matrix.identity(), this._deviceMode = e.mode, this._followObjectStartWorldQuaternion.copy(this._followObject.worldQuaternion), this.alignManipulator(), this._manipulatorObject.attach(this._followObject), this._manipulatorPosOffset.copy(this._followObject.position), this._manipulatorRotOffset.copy(this._followObject.quaternion), this._manipulatorScaleOffset.copy(this._followObject.scale);
  }
  onDragEnd(e) {
    if (!this.handlerA || !this.handlerB) {
      console.error("onDragEnd called on MultiTouchDragHandler without valid handlers. This is likely a bug.");
      return;
    }
    this.handlerA.recenter(), this.handlerB.recenter(), this._manipulatorObject.removeFromParent(), this._followObject.removeFromParent(), this._manipulatorObject.destroy(), this._followObject.destroy();
  }
  _manipulatorPosOffset = new b();
  _manipulatorRotOffset = new $();
  _manipulatorScaleOffset = new b();
  _tempVec1 = new b();
  _tempVec2 = new b();
  _tempVec3 = new b();
  tempLookMatrix = new te();
  _initialScale = new b();
  _initialDistance = 0;
  alignManipulator() {
    if (!this.handlerA || !this.handlerB) {
      console.error("alignManipulator called on MultiTouchDragHandler without valid handlers. This is likely a bug.", this);
      return;
    }
    if (!this.handlerA.followObject || !this.handlerB.followObject) {
      console.error("alignManipulator called on MultiTouchDragHandler without valid follow objects. This is likely a bug.", this.handlerA, this.handlerB);
      return;
    }
    this._tempVec1.copy(this._handlerAAttachmentPoint), this._tempVec2.copy(this._handlerBAttachmentPoint), this.handlerA.followObject.localToWorld(this._tempVec1), this.handlerB.followObject.localToWorld(this._tempVec2), this._tempVec3.lerpVectors(this._tempVec1, this._tempVec2, 0.5), this._manipulatorObject.position.copy(this._tempVec3);
    const e = this.context.mainCamera;
    this.tempLookMatrix.lookAt(this._tempVec3, this._tempVec2, e.worldUp), this._manipulatorObject.quaternion.setFromRotationMatrix(this.tempLookMatrix);
    const t = this._tempVec1.distanceTo(this._tempVec2);
    this._manipulatorObject.scale.copy(this._initialScale).multiplyScalar(t / this._initialDistance), this._manipulatorObject.updateMatrix(), this._manipulatorObject.updateMatrixWorld(!0), kn && (F.DrawLabel(this._tempVec3.clone().add(new b(0, 0.2, 0)), "A:B " + t.toFixed(2), 0.03), F.DrawLine(this._tempVec1, this._tempVec2, 65280, 0, !1));
  }
  onDragUpdate() {
    this.alignManipulator();
    const e = 30, t = 1;
    this._followObject.position.copy(this._manipulatorPosOffset), this._followObject.quaternion.copy(this._manipulatorRotOffset), this._followObject.scale.copy(this._manipulatorScaleOffset);
    const i = this.gameObject, n = this._followObject;
    if (!i) {
      console.error("MultiTouchDragHandler has no dragged object. This is likely a bug.");
      return;
    }
    n.updateMatrix(), n.updateMatrixWorld(!0);
    const r = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer" ? this.settings.xrKeepRotation : this.settings.keepRotation;
    if (this.settings.snapGridResolution > 0) {
      const d = this._followObject.worldPosition, f = this.settings.snapGridResolution;
      d.x = Math.round(d.x / f) * f, d.y = Math.round(d.y / f) * f, d.z = Math.round(d.z / f) * f, this._followObject.worldPosition = d, this._followObject.updateMatrix();
    }
    r && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion, this._followObject.updateMatrix());
    const a = j.clamp01(this.context.time.deltaTime * e * t), l = i.worldPosition;
    l.lerp(n.worldPosition, a), i.worldPosition = l;
    const c = i.worldQuaternion;
    c.slerp(n.worldQuaternion, a), i.worldQuaternion = c;
    const h = i.worldScale;
    h.lerp(n.worldScale, a), i.worldScale = h;
  }
  setTargetObject(e) {
    this.gameObject = e;
  }
}
class Cf {
  /** 
   * Returns the accumulated movement of the pointer in world units.
   * Used for determining if enough motion has occurred to start a drag.
   */
  getTotalMovement() {
    return this._totalMovement;
  }
  /** 
   * Returns the object that follows the pointer during dragging operations.
   */
  get followObject() {
    return this._followObject;
  }
  /**
   * Returns the point where the pointer initially hit the object in local space.
   */
  get hitPointInLocalSpace() {
    return this._hitPointInLocalSpace;
  }
  context;
  gameObject;
  settings;
  _lastRig = void 0;
  /** This object is placed at the pivot of the dragged object, and parented to the control space. */
  _followObject;
  _totalMovement = new b();
  /** Motion along the pointer ray. On screens this doesn't change. In XR it can be used to determine how much
   * effort someone is putting into moving an object closer or further away. */
  _totalMovementAlongRayDirection = 0;
  /** Distance between _followObject and its parent at grab start, in local space */
  _grabStartDistance = 0;
  _deviceMode;
  _followObjectStartPosition = new b();
  _followObjectStartQuaternion = new $();
  _followObjectStartWorldQuaternion = new $();
  _lastDragPosRigSpace;
  _tempVec = new b();
  _tempMat = new te();
  _hitPointInLocalSpace = new b();
  _hitNormalInLocalSpace = new b();
  _bottomCenter = new b();
  _backCenter = new b();
  _backBottomCenter = new b();
  _bounds = new pi();
  _dragPlane = new nr(new b(0, 1, 0));
  _draggedOverObject = null;
  _draggedOverObjectLastSetUp = null;
  _draggedOverObjectLastNormal = new b();
  _draggedOverObjectDuration = 0;
  /** Allows overriding which object is dragged while a drag is already ongoing. Used for example by Duplicatable */
  setTargetObject(e) {
    this.gameObject = e;
  }
  constructor(e, t) {
    this.settings = e, this.context = e.context, this.gameObject = t, this._followObject = new M();
  }
  recenter() {
    if (!this._followObject.parent) {
      console.warn("Error: space follow object doesn't have parent but recenter() is called. This is likely a bug");
      return;
    }
    if (!this.gameObject) {
      console.warn("Error: space follow object doesn't have a gameObject");
      return;
    }
    const e = this._followObject.parent;
    this.gameObject.add(this._followObject), this._followObject.matrixAutoUpdate = !1, this._followObject.position.set(0, 0, 0), this._followObject.quaternion.set(0, 0, 0, 1), this._followObject.scale.set(1, 1, 1), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0), e.attach(this._followObject), this._followObjectStartPosition.copy(this._followObject.position), this._followObjectStartQuaternion.copy(this._followObject.quaternion), this._followObjectStartWorldQuaternion.copy(this._followObject.worldQuaternion), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
    const t = this._hitPointInLocalSpace.clone();
    this.gameObject.localToWorld(t), this._grabStartDistance = t.distanceTo(e.worldPosition);
    const n = K.active?.rig?.gameObject?.worldScale.x || 1;
    this._grabStartDistance /= n, this._totalMovementAlongRayDirection = 0, this._lastDragPosRigSpace = void 0, kn && (F.DrawLine(t, e.worldPosition, 65280, 0.5, !1), F.DrawLabel(e.worldPosition.add(new b(0, 0.1, 0)), this._grabStartDistance.toFixed(2), 0.03, 0.5));
  }
  onDragStart(e) {
    if (!this.gameObject) {
      console.warn("Error: space follow object doesn't have a gameObject");
      return;
    }
    if (e.event.space.add(this._followObject), this._lastDragPosRigSpace = void 0, e.point && e.normal)
      this._hitPointInLocalSpace.copy(e.point), this.gameObject.worldToLocal(this._hitPointInLocalSpace), this._hitNormalInLocalSpace.copy(e.normal);
    else if (e) {
      const _ = e.event.space, m = _.worldPosition;
      this.gameObject.worldToLocal(m), this._hitPointInLocalSpace.copy(m);
      const v = _.worldUp;
      this._tempMat.copy(this.gameObject.matrixWorld).invert(), v.transformDirection(this._tempMat), this._hitNormalInLocalSpace.copy(v);
    }
    this.recenter(), this._totalMovement.set(0, 0, 0), this._deviceMode = e.mode;
    const i = this._followObject.parent.worldForward, o = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer" ? this.settings.xrDragMode : this.settings.dragMode, r = this._hitPointInLocalSpace.clone();
    switch (this.gameObject.localToWorld(r), o) {
      case 0:
        const _ = new b(0, 1, 0);
        this.gameObject.parent && _.transformDirection(this.gameObject.parent.matrixWorld.clone().invert()), this._dragPlane.setFromNormalAndCoplanarPoint(_, r);
        break;
      case 2:
        const m = this._hitNormalInLocalSpace.clone();
        m.transformDirection(this.gameObject.matrixWorld), this._dragPlane.setFromNormalAndCoplanarPoint(m, r);
        break;
      case 1:
        this._dragPlane.setFromNormalAndCoplanarPoint(i, r);
        break;
      case 3:
        this.setPlaneViewAligned(r, !0);
        break;
      case 4:
        this.setPlaneViewAligned(r, !1);
        break;
    }
    const a = this.gameObject.parent, l = this.gameObject.position.clone(), c = this.gameObject.quaternion.clone(), h = this.gameObject.scale.clone(), d = this.gameObject.matrixWorld.clone();
    a && a.remove(this.gameObject), this.gameObject.position.set(0, 0, 0), this.gameObject.quaternion.set(0, 0, 0, 1), this.gameObject.scale.set(1, 1, 1);
    const f = _i([this.gameObject]);
    f.expandByPoint(this.gameObject.worldPosition);
    const p = new b();
    f.getCenter(p);
    const g = new b();
    f.getSize(g), this._bottomCenter.copy(p.clone().add(new b(0, -g.y / 2, 0))), this._backCenter.copy(p.clone().add(new b(0, 0, g.z / 2))), this._backBottomCenter.copy(p.clone().add(new b(0, -g.y / 2, g.z / 2))), this._bounds.copy(f), a && a.add(this.gameObject), this.gameObject.position.copy(l), this.gameObject.quaternion.copy(c), this.gameObject.scale.copy(h), this.gameObject.matrixWorld.copy(d), this._draggedOverObject = null, this._draggedOverObjectLastSetUp = null, this._draggedOverObjectLastNormal.set(0, 1, 0), this._draggedOverObjectDuration = 0;
  }
  collectMovementInfo() {
    if (!this._followObject.parent) return;
    const e = this._followObject.parent;
    this._followObject.updateMatrix();
    const t = e.worldPosition, i = K.active?.rig?.gameObject;
    i && i.worldToLocal(t), (this._lastDragPosRigSpace === void 0 || i != this._lastRig) && (this._lastDragPosRigSpace = t.clone(), this._lastRig = i), this._tempVec.copy(t).sub(this._lastDragPosRigSpace);
    const n = e.worldForward;
    if (i && (this._tempMat.copy(i.matrixWorld).invert(), n.transformDirection(this._tempMat)), this._totalMovementAlongRayDirection += n.dot(this._tempVec), this._tempVec.x = Math.abs(this._tempVec.x), this._tempVec.y = Math.abs(this._tempVec.y), this._tempVec.z = Math.abs(this._tempVec.z), this._totalMovement.add(this._tempVec), this._lastDragPosRigSpace.copy(t), kn) {
      let o = t;
      i && (o = o.clone(), o.transformDirection(i.matrixWorld)), F.DrawRay(o, n, 255);
    }
  }
  onDragUpdate(e) {
    if (e > 1) return;
    const t = this.gameObject;
    if (!t || !this._followObject) {
      console.warn("Warning: DragPointerHandler doesn't have a dragged object. This is likely a bug.");
      return;
    }
    const i = this._followObject.parent;
    if (!i) {
      console.warn("Warning: DragPointerHandler doesn't have a drag source. This is likely a bug.");
      return;
    }
    this._followObject.updateMatrix();
    const n = i.worldPosition, o = i.worldForward, r = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer", a = r ? this.settings.xrKeepRotation : this.settings.keepRotation, l = r ? this.settings.xrDragMode : this.settings.dragMode;
    if (l === 5) return;
    const c = 10;
    a && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
    let h = 1, d = 2;
    if (r && this._grabStartDistance > 0.5) {
      const y = 1 + this._totalMovementAlongRayDirection * (2 * this.settings.xrDistanceDragFactor);
      h = Math.max(0, y), h = h * h * h;
    } else this._grabStartDistance <= 0.5 && (d = 3);
    this._followObject.position.copy(this._followObjectStartPosition), a || this._followObject.quaternion.copy(this._followObjectStartQuaternion), this._followObject.position.multiplyScalar(h), this._followObject.updateMatrix();
    const f = this._hasLastSurfaceHitPoint;
    this._hasLastSurfaceHitPoint = !1;
    const p = new lo(n, o);
    if (l == 4) {
      const y = this.context.physics.raycastFromRay(p, {
        testObject: (x) => x !== this.followObject && x !== i && x !== t
        // && !(o instanceof GroundedSkybox)
      });
      if (y.length > 0) {
        const x = y[0];
        if (this._draggedOverObject === x.object ? this._draggedOverObjectDuration += this.context.time.deltaTime : (this._draggedOverObject = x.object, this._draggedOverObjectDuration = 0), x.face) {
          this._hasLastSurfaceHitPoint = !0, this._lastSurfaceHitPoint.copy(x.point);
          const O = this._draggedOverObjectDuration >= 0.15, E = this._totalMovement.length() >= 1e-3, z = G(x.normal || x.face.normal).applyQuaternion(x.object.worldQuaternion);
          if ((O || E) && (this._draggedOverObjectLastSetUp !== this._draggedOverObject || this._draggedOverObjectLastNormal.dot(z) < 0.999999 || this.context.time.frame % 60 === 0)) {
            this._draggedOverObjectLastSetUp = this._draggedOverObject, this._draggedOverObjectLastNormal.copy(x.face.normal);
            const D = G(), V = G();
            this._bounds.getCenter(D), this._bounds.getSize(V), D.sub(V.multiplyScalar(0.5).multiply(z)), this._hitPointInLocalSpace.copy(D), this._hitNormalInLocalSpace.copy(x.face.normal), this._bounds.getCenter(D), this._bounds.getSize(V), D.add(V.multiplyScalar(0.5).multiply(x.face.normal));
            const q = G(this._hitPointInLocalSpace).add(D);
            this._followObject.localToWorld(q);
            const A = x.point;
            this._dragPlane.setFromNormalAndCoplanarPoint(z, A);
          } else if (!(O || E))
            return;
        }
      } else f && this.gameObject && this.setPlaneViewAligned(this.gameObject.worldPosition, !1);
    }
    if (l !== 1 && p.intersectPlane(this._dragPlane, this._tempVec)) {
      this._followObject.worldPosition = this._tempVec, this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
      const y = G(this._hitPointInLocalSpace);
      this._followObject.localToWorld(y), kn && F.DrawLine(y, this._tempVec, 65535, 0, !1), this._followObject.worldPosition = this._tempVec.multiplyScalar(2).sub(y), this._followObject.updateMatrix(), this._followObject.updateMatrix();
    }
    if (this.settings.snapGridResolution > 0) {
      const y = this._followObject.worldPosition, x = this.settings.snapGridResolution;
      y.x = Math.round(y.x / x) * x, y.y = Math.round(y.y / x) * x, y.z = Math.round(y.z / x) * x, this._followObject.worldPosition = y, this._followObject.updateMatrix();
    }
    a && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion, this._followObject.updateMatrix());
    const g = j.clamp01(this.context.time.deltaTime * c * d), _ = j.clamp01(this.context.time.deltaTime * c * 0.5 * d), m = t.worldPosition;
    m.lerp(this._followObject.worldPosition, g), t.worldPosition = m;
    const v = t.worldQuaternion;
    if (v.slerp(this._followObject.worldQuaternion, _), t.worldQuaternion = v, kn) {
      const y = this._hitPointInLocalSpace.clone();
      t.localToWorld(y), F.DrawSphere(y, 0.02, 16711680);
      const x = this._hitNormalInLocalSpace.clone();
      x.applyQuaternion(v), F.DrawRay(y, x, 16711680), F.DrawLabel(
        m.add(new b(0, 0.25, 0)),
        `Distance: ${this._totalMovement.length().toFixed(2)}

                Along Ray: ${this._totalMovementAlongRayDirection.toFixed(2)}

                Session: ${!!K.active}

                Device: ${this._deviceMode}

                `,
        0.03
      );
      const I = this._bottomCenter.clone(), O = this._backCenter.clone(), k = this._backBottomCenter.clone();
      t.localToWorld(I), t.localToWorld(O), t.localToWorld(k), F.DrawSphere(I, 0.01, 65280, 0, !1), F.DrawSphere(O, 0.01, 255, 0, !1), F.DrawSphere(k, 0.01, 16711935, 0, !1), F.DrawLine(I, k, 65535, 0, !1), F.DrawLine(k, O, 65535, 0, !1);
    }
  }
  onDragEnd(e) {
    console.assert(this._followObject.parent === e.event.space, "Drag end: _followObject is not parented to the space object"), this._followObject.removeFromParent(), this._followObject.destroy(), this._lastDragPosRigSpace = void 0;
  }
  _hasLastSurfaceHitPoint = !1;
  _lastSurfaceHitPoint = new b();
  setPlaneViewAligned(e, t) {
    if (!this._followObject.parent)
      return !1;
    const i = this._followObject.parent.worldForward, n = G(0, 1, 0), o = i, r = n.angleTo(o), a = 0.5;
    return t && (r > Math.PI / 2 + a || r < Math.PI / 2 - a) ? this._dragPlane.setFromNormalAndCoplanarPoint(n, e) : this._dragPlane.setFromNormalAndCoplanarPoint(i, e), !0;
  }
}
class sv {
  /** Controls whether visual helpers like lines and markers are displayed */
  showGizmo = !0;
  /** When true, drag plane alignment changes based on view angle */
  useViewAngle = !0;
  /**
   * Checks if there is a currently selected object being visualized
   */
  get hasSelected() {
    return this._selected !== null && this._selected !== void 0;
  }
  /**
   * Returns the currently selected object being visualized, if any
   */
  get selected() {
    return this._selected;
  }
  _selected = null;
  _context = null;
  _camera;
  _cameraPlane = new nr();
  _hasGroundPlane = !1;
  _groundPlane = new nr();
  _groundOffset = new b();
  _groundOffsetFactor = 0;
  _groundDistance = 0;
  _groundPlanePoint = new b();
  _raycaster = new Ad();
  _cameraPlaneOffset = new b();
  _intersection = new b();
  _worldPosition = new b();
  _inverseMatrix = new te();
  _rbs = [];
  _groundLine;
  _groundMarker;
  static geometry = new Tn().setFromPoints([new b(0, 0, 0), new b(0, -1, 0)]);
  constructor(e) {
    this._camera = e;
    const t = new Zl(sv.geometry), i = t.material;
    i.color = new se(0.4, 0.4, 0.4), t.layers.set(2), t.name = "line", t.scale.y = 1, this._groundLine = t;
    const n = new Ed(0.5, 22, 22), o = new we({ color: i.color }), r = new H(n, o);
    r.visible = !1, r.layers.set(2), this._groundMarker = r;
  }
  setSelected(e, t) {
    if (this._selected && t)
      for (const i of this._rbs)
        i.wakeUp(), i.setVelocity(0, 0, 0);
    if (this._selected && oa.Remove(t, this._selected), this._selected = e, this._context = t, this._rbs.length = 0, e ? (t.scene.add(this._groundLine), t.scene.add(this._groundMarker)) : (this._groundLine.removeFromParent(), this._groundMarker.removeFromParent()), this._selected) {
      if (!t) {
        console.error("DragHelper: no context");
        return;
      }
      oa.Add(t, this._selected, null), this._groundOffsetFactor = 0, this._hasGroundPlane = !0, this._groundOffset.set(0, 0, 0), this._requireUpdateGroundPlane = !0, this.onUpdateScreenSpacePlane();
    }
  }
  _groundOffsetVector = new b(0, 1, 0);
  _requireUpdateGroundPlane = !0;
  _didDragOnGroundPlaneLastFrame = !1;
  onUpdate(e) {
    this._selected;
  }
  onUpdateWorldPosition(e, t, i) {
    if (this._selected) {
      if (i) {
        const n = Z(this._selected);
        n.y = e.y, e = n;
      }
      if (ut(this._selected, e), ut(this._groundLine, e), this._hasGroundPlane ? this._groundLine.scale.y = this._groundDistance : this._groundLine.scale.y = 1e3, this._groundLine.visible = this.showGizmo, this._groundMarker.visible = t !== null && this.showGizmo, t) {
        const n = Z(this._camera).distanceTo(t) * 0.01;
        this._groundMarker.scale.set(n, n, n), ut(this._groundMarker, t);
      }
    }
  }
  onUpdateScreenSpacePlane() {
    if (!this._selected || !this._context) return;
    const e = this._context.input.getPointerPositionRC(0);
    e && (this._raycaster.setFromCamera(e, this._camera), this._cameraPlane.setFromNormalAndCoplanarPoint(this._camera.getWorldDirection(this._cameraPlane.normal), this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld)), this._raycaster.ray.intersectPlane(this._cameraPlane, this._intersection) && this._selected.parent && (this._inverseMatrix.copy(this._selected.parent.matrixWorld).invert(), this._cameraPlaneOffset.copy(this._intersection).sub(this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld))));
  }
  onUpdateGroundPlane() {
    if (!this._selected || !this._context) return;
    const e = Z(this._selected), t = new lo(G(0, 0.1, 0).add(e), G(0, -1, 0)), i = new mr();
    i.testObject = (o) => o !== this._selected;
    const n = this._context.physics.raycastFromRay(t, i);
    for (let o = 0; o < n.length; o++) {
      const r = n[o];
      if (!r.face || this.contains(this._selected, r.object))
        continue;
      const a = G(0, 1, 0);
      this._groundPlane.setFromNormalAndCoplanarPoint(a, r.point);
      break;
    }
    this._hasGroundPlane = !0, this._groundPlane.setFromNormalAndCoplanarPoint(t.direction.multiplyScalar(-1), t.origin), this._raycaster.ray.intersectPlane(this._groundPlane, this._intersection), this._groundDistance = this._intersection.distanceTo(e), this._groundOffset.copy(this._intersection).sub(e);
  }
  contains(e, t) {
    if (e === t) return !0;
    if (e.children) {
      for (const i of e.children)
        if (this.contains(i, t)) return !0;
    }
    return !1;
  }
}
var Hk = /* @__PURE__ */ ((s) => (s.File_Spawned = "file-spawned", s))(Hk || {});
class nL {
  guid;
  file_name;
  file_hash;
  file_size;
  position;
  scale;
  seed;
  sender;
  /** the url to download the file */
  downloadUrl;
  parentGuid;
  boundsSize;
  constructor(e, t, i, n, o, r, a, l, c) {
    this.seed = t, this.guid = i, this.file_name = n, this.file_hash = o, this.file_size = r, this.position = a, this.scale = l, this.sender = e, this.downloadUrl = c;
  }
}
var Wo;
((s) => {
  const e = /* @__PURE__ */ new Map();
  function t(n) {
    e.has(n.guid) && i(n.guid);
    const o = new M();
    e.set(n.guid, o);
    const r = new M();
    r.position.y = -0.5, o.add(r);
    const a = new H(new la(1, 1, 1, 1, 1, 1), new we(
      { color: 14540253, wireframe: !0, transparent: !0, opacity: 0.3 }
    ));
    a.position.y = 0.5, r.add(a);
    const l = new M();
    r.add(l);
    const c = new H(new la(1, 1, 1, 1, 1, 1), new we({
      color: 12307660,
      transparent: !0,
      opacity: 0.4
    }));
    c.position.y = 0.5, l.scale.y = 0.01, l.add(c);
    const h = new H(new Un(1, 1, 1, 1), new we({
      color: 34,
      transparent: !0,
      opacity: 0.05,
      depthTest: !1
    }));
    return h.rotateX(-Math.PI / 2), h.position.y = 0.51, c.add(h), n.parent.add(o), o.rotateY(Math.PI / 2), n.position && o.position?.copy(n.position), n.size && (o.worldScale = new b().copy(n.size)), o.position.y = o.scale.y / 2, {
      object: o,
      onProgress: (d) => {
        l instanceof M && l.scale.set(1, d, 1);
      }
    };
  }
  s.addPreview = t;
  function i(n) {
    const o = e.get(n);
    o && (e.delete(n), o.removeFromParent());
  }
  s.removePreview = i;
})(Wo || (Wo = {}));
const qr = [], Fh = [];
var y_;
((s) => {
  function e(i, n) {
    const o = { name: n?.name, priority: n?.priority ?? 0, callback: i };
    return qr.push(o), qr.sort((r, a) => r.priority === a.priority ? 0 : r.priority > a.priority ? -1 : 1), () => {
      const r = qr.indexOf(o);
      r >= 0 && qr.splice(r, 1);
    };
  }
  s.onCreateCustomModelLoader = e;
  function t(i) {
    return Fh.push(i), () => {
      const n = Fh.indexOf(i);
      n >= 0 && Fh.splice(n, 1);
    };
  }
  s.onDetermineModelMimetype = t;
})(y_ || (y_ = {}));
const Vl = w("debugfileformat");
function Gk(s) {
  switch ((s.split(".").pop() || s).toUpperCase()) {
    case "GLTF":
      return "model/gltf+json";
    case "VRM":
      return "model/vrm";
    case "GLB":
      return "model/gltf-binary";
    case "FBX":
      return "model/fbx";
    case "USD":
      return "model/vnd.usd+zip";
    case "USDA":
      return "model/vnd.usda+zip";
    case "USDZ":
      return "model/vnd.usdz+zip";
    case "OBJ":
      return "model/obj";
    default:
      return null;
  }
}
async function qk(s, e) {
  const { useExtension: t = !0 } = e;
  if (t) {
    const o = s, r = new URL(o, globalThis.location.href);
    let a = null;
    const l = r.searchParams.get("filetype");
    switch (l && (a = l.toUpperCase()), a?.length || (a = r.pathname.split(".").pop()?.toUpperCase()), Vl && console.warn(`[Needle Engine] Try to use file extension to determine type: '${a}'`), a) {
      case "GLTF":
        return "model/gltf+json";
      case "VRM":
        return "model/vrm";
      case "GLB":
        return "model/gltf-binary";
      case "FBX":
        return "model/fbx";
      case "USD":
        return "model/vnd.usd+zip";
      case "USDA":
        return "model/vnd.usda+zip";
      case "USDZ":
        return "model/vnd.usdz+zip";
      case "OBJ":
        return "model/obj";
    }
  }
  const i = s;
  if (!s.startsWith("blob:")) {
    const o = new URL(s, globalThis.location.href);
    o.searchParams.append("range", "true"), s = o.toString();
  }
  const n = await fetch(s, {
    method: "GET",
    headers: {
      range: "bytes=0-32"
    }
  }).catch((o) => null);
  if (n?.ok) {
    const o = await n.arrayBuffer(), r = Xk(i, o, n);
    return Vl && console.log("[Needle Engine] Determined file type from header: " + r), r;
  }
  return "unknown";
}
function Xk(s, e, t) {
  if (e.byteLength < 4)
    return "unknown";
  const i = new Uint8Array(e);
  Vl && console.warn(`[Needle Engine] Trying to determine file type from binary data
`, '"' + new TextDecoder().decode(e) + `"
`, i);
  const n = new TextDecoder().decode(e).replace(/\s/g, "");
  if (n[0] === "{" && n[1] === '"')
    return console.debug("GLTF detected"), "model/gltf+json";
  if (i[0] == 103 && i[1] == 108 && i[2] == 84 && i[3] == 70 && (i[4] == 10 || i[4] === 2))
    return console.debug("GLTF .bin detected"), "model/gltf+json";
  if (i[0] == 103 && i[1] == 108 && i[2] == 84 && i[3] == 70 && i[4] == 98)
    return console.debug("GLB detected"), "model/gltf-binary";
  if (i[0] == 80 && i[1] == 75 && i[2] == 3 && i[3] == 4)
    return console.debug("USDZ detected"), "model/vnd.usdz+zip";
  if (i[0] == 80 && i[1] == 88 && i[2] == 82 && i[3] == 45 && i[4] == 85 && i[5] == 83 && i[6] == 68 && i[7] == 67)
    return console.debug("Binary USD detected"), "model/vnd.usd";
  if (i[0] == 35 && i[1] == 117 && i[2] == 115 && i[3] == 100 && i[4] == 97)
    return console.debug("ASCII USD detected"), "model/vnd.usda";
  if (i[0] == 75 && i[1] == 97 && i[2] == 121 && i[3] == 100 && i[4] == 97 && i[5] == 114 && i[6] == 97 && i[7] == 32)
    return console.debug("Binary FBX detected"), "model/fbx";
  if (i[0] == 59 && i[1] == 32 && i[2] == 70 && i[3] == 66 && i[4] == 88 && i[5] == 32)
    return console.debug("ASCII FBX detected"), "model/fbx";
  if (i[0] == 35 && i[1] == 32 && i[2] == 66 && i[3] == 108 && i[4] == 101 && i[5] == 110 && i[6] == 100 && i[7] == 101 && i[8] == 114 && i[9] == 32)
    return console.debug("OBJ detected"), "model/obj";
  if (i[0] == 35 && i[1] == 32 && i[2] == 65 && i[3] == 108 && i[4] == 105 && i[5] == 97 && i[6] == 115 && i[7] == 32 && i[8] == 79 && i[9] == 66 && i[10] == 74)
    return console.debug("OBJ detected"), "model/obj";
  if (t.headers.has("content-type")) {
    const o = t.headers.get("content-type");
    if (o?.startsWith("image/"))
      return console.debug("Image detected, not a model file"), "unsupported";
    switch (console.debug("Content-Type: " + o), o) {
      case "model/gltf+json":
      case "model/gltf-binary":
      case "model/vrm":
      case "model/vnd.usdz+zip":
      case "model/vnd.usd+zip":
      case "model/vnd.usd":
      case "model/vnd.usda+zip":
      case "model/vnd.usda":
      case "model/vnd.usdc":
      case "model/fbx":
      case "model/vnd.autodesk.fbx":
      case "model/obj":
        return o;
    }
  }
  if (i[0] == 118 && i[1] == 32 || i[0] == 102 && i[1] == 32)
    return console.debug("OBJ detected (the file has no header and starts with vertex or face)"), "obj";
  if (i[0] == 35 && i[1] == 32 && i[2] == 70 && i[3] == 105 && i[4] == 108 && i[5] == 101 && i[6] == 32 && i[7] == 101 && i[8] == 120 && i[9] == 112 && i[10] == 111 && i[11] == 114 && i[12] == 116 && i[13] == 101 && i[14] == 100 && i[15] == 32 && i[16] == 98 && i[17] == 121 && i[18] == 32 && i[19] == 90 && i[20] == 66 && i[21] == 114 && i[22] == 117 && i[23] == 115 && i[24] == 104)
    return console.debug("OBJ detected (exported by ZBrush)"), "obj";
  if (i[0] == 109 && i[1] == 116 && i[2] == 108 && i[3] == 108 && i[4] == 105 && i[5] == 98)
    return console.debug("OBJ detected (mtllib)"), "obj";
  for (const o of Fh) {
    const r = o({
      url: s,
      response: t,
      contentType: t.headers.get("content-type"),
      bytes: i
    });
    if (r)
      return Vl && console.debug(`Mimetype callback returned: ${r}`), r;
  }
  if (L() || Vl) {
    const o = new TextDecoder().decode(e.slice(0, Math.min(e.byteLength, 32)));
    console.warn(`Could not determine file type.

Consider registering a custom loader via the 'onCreateCustomModelLoader' callback: 'NeedleEngineModelLoader.onCreateCustomModelLoader(args => { })'

Content-Type: "${t.headers.get("content-type")}
"Text: "${o}"
Binary:`, i);
  } else
    console.debug("Could not determine file type from binary data");
  return "unknown";
}
var Qk = Object.defineProperty, Ia = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Qk(e, t, n), n;
};
const ri = w("debugdroplistener");
class Yk extends CustomEvent {
  /**
   * Creates a new added event with the provided details
   * @param detail Information about the added object
   */
  constructor(e) {
    super("object-added", { detail: e });
  }
}
const Kk = "blob";
class yo extends T {
  dropArea;
  fitIntoVolume = !1;
  fitVolumeSize = new b(1, 1, 1);
  placeAtHitPosition = !0;
  useNetworking = !1;
  onDropped = new me();
  /**
   * Loads a file from the given URL and adds it to the scene.
   * @returns A promise that resolves to the loaded object or null if loading failed.
   */
  loadFromURL(e, t) {
    return this.addFromUrl(e, { screenposition: new J(), point: t?.point, size: t?.size }, !1);
  }
  /**
   * Forgets all previously added objects.     
   * The droplistener will then not be able to remove previously added objects.
   */
  forgetObjects() {
    this.removePreviouslyAddedObjects(!1);
  }
  // #region internals
  /** @internal */
  onEnable() {
    this.context.renderer.domElement.addEventListener("dragover", this.onDrag), this.context.renderer.domElement.addEventListener("drop", this.onDrop), window.addEventListener("paste", this.handlePaste), this.context.connection.beginListen("droplistener", this.onNetworkEvent);
  }
  /** @internal */
  onDisable() {
    this.context.renderer.domElement.removeEventListener("dragover", this.onDrag), this.context.renderer.domElement.removeEventListener("drop", this.onDrop), window.removeEventListener("paste", this.handlePaste), this.context.connection.stopListen("droplistener", this.onNetworkEvent);
  }
  /**
   * Handles network events received from other clients containing information about dropped objects
   * @param evt Network event data containing object information, position, and content URL
   */
  onNetworkEvent = (e) => {
    if (!this.useNetworking) {
      ri && console.debug("[DropListener] Ignoring networked event because networking is disabled", e);
      return;
    }
    if (e.guid?.startsWith(this.guid)) {
      const t = e.url;
      if (console.debug("[DropListener] Received networked event", e), t)
        if (Array.isArray(t))
          for (const i of t)
            this.addFromUrl(i, { screenposition: new J(), point: e.point, size: e.size }, !0);
        else
          this.addFromUrl(t, { screenposition: new J(), point: e.point, size: e.size }, !0);
    }
  };
  /**
   * Handles clipboard paste events and processes them as potential URL drops
   * Only URLs are processed by this handler, and only when editing is allowed
   * @param evt The paste event
   */
  handlePaste = (e) => {
    if (this.context.connection.allowEditing === !1 || e.defaultPrevented) return;
    navigator.clipboard.readText().then((i) => {
      if (i && (i.startsWith("http") || i.startsWith("https") || i.startsWith("blob"))) {
        const o = { screenposition: new J(this.context.input.mousePosition.x, this.context.input.mousePosition.y) };
        this.testIfIsInDropArea(o) && this.addFromUrl(i, o, !1);
      }
    }).catch(console.warn);
  };
  /**
   * Handles drag events over the renderer's canvas
   * Prevents default behavior to enable drop events
   * @param evt The drag event
   */
  onDrag = (e) => {
    this.context.connection.allowEditing !== !1 && e.preventDefault();
  };
  /**
   * Processes drop events to add files to the scene
   * Handles both file drops and text/URL drops
   * @param evt The drop event
   */
  onDrop = async (e) => {
    if (this.context.connection.allowEditing === !1 || (ri && console.log(e), !e?.dataTransfer) || e["droplistener:handled"]) return;
    e.preventDefault();
    const t = { screenposition: new J(e.offsetX, e.offsetY) };
    if (this.dropArea && this.testIfIsInDropArea(t) === !1)
      return;
    e["droplistener:handled"] = !0;
    const i = e.dataTransfer.items;
    if (!i) return;
    const n = [];
    for (const o in i) {
      const r = i[o];
      if (r.kind === "file") {
        const a = r.getAsFile();
        if (!a) continue;
        n.push(a);
      } else r.kind === "string" && r.type == "text/plain" && r.getAsString((a) => {
        this.addFromUrl(a, t, !1);
      });
    }
    n.length > 0 && await this.addFromFiles(n, t);
  };
  /**
   * Processes a dropped or pasted URL and tries to load it as a 3D model
   * Handles special cases like GitHub URLs and Polyhaven asset URLs
   * @param url The URL to process
   * @param ctx Context information about where the drop occurred
   * @param isRemote Whether this URL was shared from a remote client
   * @returns The added object or null if loading failed
   */
  async addFromUrl(e, t, i) {
    ri && console.log("dropped url", e);
    try {
      if (e.startsWith("https://github.com/")) {
        const r = e.split("/"), a = r[3], l = r[4], c = r[6], h = r.slice(7).join("/");
        e = `https://raw.githubusercontent.com/${a}/${l}/${c}/${h}`;
      } else e.startsWith("https://polyhaven.com/a") && (e = Zk(e));
      if (!e) return null;
      const n = e.toLowerCase();
      if (n.endsWith(".hdr") || n.endsWith(".hdri") || n.endsWith(".exr") || n.endsWith(".png") || n.endsWith(".jpg") || n.endsWith(".jpeg"))
        return console.warn(`Fileformat is not supported: ${n}`), null;
      this.removePreviouslyAddedObjects();
      const o = await md.loadFileFromURL(new URL(e), {
        guid: this.guid,
        context: this.context,
        parent: this.gameObject,
        point: t.point,
        size: t.size
      });
      if (o && this._addedObjects.length <= 0)
        return t.url = e, this.onObjectLoaded(o, t, i);
    } catch {
      console.warn("String is not a valid URL", e);
    }
    return null;
  }
  _abort = null;
  /**
   * Processes dropped files, loads them as 3D models, and handles networking if enabled
   * Creates an abort controller to cancel previous uploads if new files are dropped
   * @param fileList Array of dropped files
   * @param ctx Context information about where the drop occurred
   */
  async addFromFiles(e, t) {
    if (ri && console.log("Add files", e), !!Array.isArray(e) && e.length) {
      this.deleteDropEvent(), this.removePreviouslyAddedObjects(), Yh(Kk, null), this._abort?.abort("New files dropped"), this._abort = new AbortController();
      for (const i of e) {
        if (!i) continue;
        if (i.type.startsWith("image/")) {
          ri && console.warn("Ignoring dropped image file", i.name, i.type);
          continue;
        } else if (i.name.endsWith(".bin")) {
          ri && console.warn("Ignoring dropped binary file", i.name, i.type);
          continue;
        }
        console.debug("Load file " + i.name + " + " + i.type);
        const n = await md.loadFile(i, this.context, { guid: this.guid });
        if (n) {
          this.dispatchEvent(new CustomEvent("file-dropped", { detail: i })), t.file = i;
          const o = this.onObjectLoaded(n, t, !1);
          o && this.context.connection.isConnected && this.useNetworking && (console.debug("Uploading dropped file to blob storage"), wa.upload(i, { abort: this._abort?.signal }).then((r) => {
            r?.download_url && this._addedObjects.includes(o) && this.sendDropEvent(r.download_url, o, n.contentMD5);
          }).catch(console.warn));
          break;
        }
      }
    }
  }
  /** Previously added objects */
  _addedObjects = new Array();
  _addedModels = new Array();
  /**
   * Removes all previously added objects from the scene
   * @param doDestroy When true, destroys the objects; when false, just clears the references
   */
  removePreviouslyAddedObjects(e = !0) {
    if (e)
      for (const t of this._addedObjects)
        t.parent === this.gameObject && Wi(t, !0, !0);
    this._addedObjects.length = 0, this._addedModels.length = 0;
  }
  /**
   * Adds a loaded model to the scene with proper positioning and scaling.
   * Handles placement based on component settings and raycasting.
   * If {@link fitIntoVolume} is enabled, the object will be scaled to fit within the volume defined by {@link fitVolumeSize}.
   * @param data The loaded model data and content hash
   * @param ctx Context information about where the drop occurred
   * @param isRemote Whether this object was shared from a remote client
   * @returns The added object or null if adding failed
   */
  onObjectLoaded(e, t, i) {
    const { model: n, contentMD5: o } = e;
    if (ri && console.log(`Dropped ${this.gameObject.name}`, n), !n?.scene)
      return console.warn("No object specified to add to scene", n), null;
    this.removePreviouslyAddedObjects();
    const r = n.scene;
    this.gameObject.attach(r), r.position.set(0, 0, 0), r.quaternion.identity(), this._addedObjects.push(r), this._addedModels.push(n);
    const a = new pi().setFromCenterAndSize(new b(0, this.fitVolumeSize.y * 0.5, 0).add(this.gameObject.worldPosition), this.fitVolumeSize);
    if (ri && F.DrawWireBox3(a, 255, 5), this.fitIntoVolume && UC(r, a, {
      position: !this.placeAtHitPosition
    }), this.placeAtHitPosition && t && t.screenposition) {
      r.visible = !1;
      const c = this.context.physics.raycast({ screenPoint: this.context.input.convertScreenspaceToRaycastSpace(t.screenposition.clone()) });
      if (r.visible = !0, c && c.length > 0)
        for (const h of c) {
          const d = h.point.clone();
          ri && console.log("Place object at hit", h), NC(r, d);
          break;
        }
    }
    rc.autoplayAnimations(n);
    const l = new Yk({
      sender: this,
      gltf: n,
      model: n,
      object: r,
      contentMD5: o,
      dropped: t.file || (t.url ? new URL(t.url) : void 0)
    });
    return this.dispatchEvent(l), this.onDropped?.invoke(l.detail), !i && t.url?.startsWith("http") && this.context.connection.isConnected && r && this.sendDropEvent(t.url, r, o), r;
  }
  /**
   * Sends a network event to other clients about a dropped object
   * Only triggered when networking is enabled and the connection is established
   * @param url The URL to the content that was dropped
   * @param obj The object that was added to the scene
   * @param contentmd5 The content hash for verification
   */
  async sendDropEvent(e, t, i) {
    if (!this.useNetworking) {
      ri && console.debug("[DropListener] Ignoring networked event because networking is disabled", e);
      return;
    }
    if (this.context.connection.isConnected) {
      console.debug('Sending drop event "' + t.name + '"', e);
      const n = _i([t]), o = {
        name: t.name,
        guid: this.guid,
        url: e,
        point: t.worldPosition.clone(),
        size: n.getSize(new b()),
        contentMD5: i
      };
      this.context.connection.send("droplistener", o);
    }
  }
  /**
   * Deletes remote state for this DropListener's objects
   * Called when new files are dropped to clean up previous state
   */
  deleteDropEvent() {
    this.context.connection.sendDeleteRemoteState(this.guid);
  }
  /**
   * Tests if a drop event occurred within the designated drop area if one is specified
   * @param ctx The drop context containing screen position information
   * @returns True if the drop is valid (either no drop area is set or the drop occurred inside it)
   */
  testIfIsInDropArea(e) {
    if (this.dropArea) {
      const t = this.context.input.convertScreenspaceToRaycastSpace(e.screenposition.clone());
      if (!this.context.physics.raycast({
        targets: [this.dropArea],
        screenPoint: t,
        recursive: !0,
        testObject: (n) => !this._addedObjects.includes(n)
      }).length)
        return L() && console.log(`Dropped outside of drop area for DropListener "${this.name}".`), !1;
    }
    return !0;
  }
}
Ia([
  u(M)
], yo.prototype, "dropArea");
Ia([
  u()
], yo.prototype, "fitIntoVolume");
Ia([
  u(b)
], yo.prototype, "fitVolumeSize");
Ia([
  u()
], yo.prototype, "placeAtHitPosition");
Ia([
  u()
], yo.prototype, "useNetworking");
Ia([
  u(me)
], yo.prototype, "onDropped");
function Zk(s) {
  if (!s.startsWith("https://polyhaven.com/")) return s;
  const e = "https://dl.polyhaven.org/file/ph-assets/Models/gltf/4k/", n = new URL(s).pathname.split("/").pop(), o = `${e}${n}/${n}_4k.gltf`;
  return console.log("Resolved polyhaven asset url", s, "→", o), o;
}
var md;
((s) => {
  async function e(i, n, o) {
    const r = o.guid, a = new Tt(r), l = new Blob([i], { type: i.type || Gk(i.name) || void 0 }), c = URL.createObjectURL(l), h = await jn().loadSync(n, c, i.name, a).catch((d) => (console.error(`Failed to load file "${i.name}" (${i.type}):`, d), null));
    return URL.revokeObjectURL(c), h ? new Promise((d, f) => {
      const p = new FileReader();
      p.readAsArrayBuffer(i), p.onloadend = async (g) => {
        const _ = p.result, m = wa.hashMD5(_);
        return d({ model: h, contentMD5: m });
      };
    }) : (console.warn(`Failed to load "${i.name}" (${i.type})`), null);
  }
  s.loadFile = e;
  async function t(i, n) {
    return new Promise(async (o, r) => {
      const a = new Tt(n.guid), l = i.toString();
      ri && F.DrawWireSphere(n.point, 0.1, 16711680, 3);
      const c = Wo.addPreview({
        guid: n.guid,
        parent: n.parent,
        position: n?.point,
        size: n?.size
      }), h = await jn().loadSync(n.context, l, l, a, (d) => {
        c.onProgress(d.loaded / d.total);
      }).catch(console.warn);
      if (h) {
        const d = await fetch(l).then((p) => p.arrayBuffer()), f = wa.hashMD5(d);
        ri ? setTimeout(() => Wo.removePreview(n.guid), 3e3) : Wo.removePreview(n.guid), o({ model: h, contentMD5: f });
      } else
        ri ? setTimeout(() => Wo.removePreview(n.guid), 3e3) : Wo.removePreview(n.guid), console.warn("Unsupported file type: " + i.toString());
    });
  }
  s.loadFileFromURL = t;
})(md || (md = {}));
var Jk = Object.defineProperty, tg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && Jk(e, t, n), n;
};
const au = class ov extends T {
  parent = null;
  object = null;
  limitCount = 60;
  _currentCount = 0;
  _startPosition = null;
  _startQuaternion = null;
  start() {
    if (this._currentCount = 0, this._startPosition = null, this._startQuaternion = null, this.object || (this.object = this.gameObject), this.object) {
      if (this.object === this.gameObject) {
        const t = new Tt(this.guid);
        this.object = S.instantiate(this.object, { idProvider: t, keepWorldPosition: !1 }), S.getComponent(this.object, ov)?.destroy();
        let n = this.object.getComponentInChildren(Gr);
        n || (n = this.object.addComponent(Gr, {
          dragMode: nv.SnapToSurfaces
        }), n.guid = t.generateUUID());
        let o = S.getComponent(n.gameObject, Fn);
        o || (o = n.gameObject.addComponent(Fn), o.guid = t.generateUUID());
      }
      this.object.visible = !1;
      const e = this.gameObject.getComponent(Gr);
      e && (e.enabled = !1), this._startPosition = this.object.position?.clone() ?? new b(0, 0, 0), this._startQuaternion = this.object.quaternion?.clone() ?? new $(0, 0, 0, 1);
    }
    this.gameObject.getComponentInParent(Vi) || this.gameObject.addComponent(Vi);
  }
  onEnable() {
    this.startCoroutine(this.cloneLimitIntervalFn());
  }
  _forwardPointerEvents = /* @__PURE__ */ new Map();
  onPointerEnter(e) {
    e.used || this.object && this.context.connection.allowEditing && e.button === 0 && this.context.input.setCursor("pointer");
  }
  onPointerExit(e) {
    e.used || this.object && this.context.connection.allowEditing && e.button === 0 && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerDown(e) {
    if (e.used || !this.object || !this.context.connection.allowEditing || e.button !== 0) return;
    const t = this.handleDuplication();
    if (t) {
      const i = S.getComponent(t, Gr);
      i ? (i.onPointerDown(e), this._forwardPointerEvents.set(e.event.space, i)) : L() && console.warn(`Duplicated object (${t.name}) does not have DragControls`);
    } else
      this._currentCount >= this.limitCount ? console.warn(`[Duplicatable] Limit of ${this.limitCount} objects created within a few seconds reached. Please wait a moment before creating more objects.`) : console.warn("[Duplicatable] Could not duplicate object.");
  }
  /** @internal */
  onPointerUp(e) {
    if (e.used) return;
    const t = this._forwardPointerEvents.get(e.event.space);
    t && (t.onPointerUp(e), this._forwardPointerEvents.delete(e.event.space));
  }
  *cloneLimitIntervalFn() {
    for (; this.activeAndEnabled && !this.destroyed; )
      this._currentCount > 0 ? this._currentCount -= 1 : this._currentCount < 0 && (this._currentCount = 0), yield T0(1);
  }
  handleDuplication() {
    if (!this.object || this.limitCount > 0 && this._currentCount >= this.limitCount || this.object === this.gameObject) return null;
    if (S.isDestroyed(this.object))
      return this.object = null, null;
    this.object.visible = !0, this._startPosition && this.object.position.copy(this._startPosition), this._startQuaternion && this.object.quaternion.copy(this._startQuaternion);
    const e = new Nn();
    this.parent || (this.parent = this.gameObject.parent), this.parent && (e.parent = this.parent.guid ?? this.parent.userData?.guid, e.keepWorldPosition = !0), e.position = this.worldPosition, e.rotation = this.worldQuaternion, e.context = this.context, this._currentCount += 1;
    const t = S.instantiateSynced(this.object, e);
    return console.assert(t !== this.object, "Duplicated object is original"), this.object.visible = !1, this._startPosition && this.object.position.clone().copy(this._startPosition), this._startQuaternion && this.object.quaternion.clone().copy(this._startQuaternion), t;
  }
};
tg([
  u(M)
], au.prototype, "parent");
tg([
  u(M)
], au.prototype, "object");
tg([
  u()
], au.prototype, "limitCount");
let rv = au;
var ns = /* @__PURE__ */ ((s) => (s[s.PointerEnter = 0] = "PointerEnter", s[s.PointerExit = 1] = "PointerExit", s[s.PointerDown = 2] = "PointerDown", s[s.PointerUp = 3] = "PointerUp", s[s.PointerClick = 4] = "PointerClick", s[s.Drag = 5] = "Drag", s[s.Drop = 6] = "Drop", s[s.Scroll = 7] = "Scroll", s[s.UpdateSelected = 8] = "UpdateSelected", s[s.Select = 9] = "Select", s[s.Deselect = 10] = "Deselect", s[s.Move = 11] = "Move", s[s.InitializePotentialDrag = 12] = "InitializePotentialDrag", s[s.BeginDrag = 13] = "BeginDrag", s[s.EndDrag = 14] = "EndDrag", s[s.Submit = 15] = "Submit", s[s.Cancel = 16] = "Cancel", s))(ns || {}), eM = Object.defineProperty, ig = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && eM(e, t, n), n;
};
class ng {
  eventID;
  callback = new me();
}
ig([
  u()
], ng.prototype, "eventID");
ig([
  u(me)
], ng.prototype, "callback");
class sg extends T {
  triggers = [];
  /** @internal */
  invoke(e) {
    if (this.triggers)
      for (const t of this.triggers)
        t.eventID === e && t.callback?.invoke();
  }
  hasTrigger(e) {
    return this.triggers?.some((t) => t.eventID === e) ?? !1;
  }
  shouldChangeCursor() {
    return this.hasTrigger(ns.PointerClick) || this.hasTrigger(ns.PointerDown) || this.hasTrigger(ns.PointerUp);
  }
  /** @internal */
  onPointerClick(e) {
    this.invoke(ns.PointerClick);
  }
  /** @internal */
  onPointerEnter(e) {
    this.shouldChangeCursor() && this.context.input.setCursor("pointer"), this.invoke(ns.PointerEnter);
  }
  /** @internal */
  onPointerExit(e) {
    this.shouldChangeCursor() && this.context.input.unsetCursor("pointer"), this.invoke(ns.PointerExit);
  }
  /** @internal */
  onPointerDown(e) {
    this.invoke(ns.PointerDown);
  }
  /** @internal */
  onPointerUp(e) {
    this.invoke(ns.PointerUp);
  }
}
ig([
  u(ng)
], sg.prototype, "triggers");
class av {
  writer;
  constructor(e) {
    this.writer = e;
  }
  writeNode(e) {
  }
}
class tM extends av {
  beforeWriteNode(e, t) {
    F.isGizmo(e) && (t.keep = !1);
  }
}
class lv extends av {
  beforeWriteTexture(e, t) {
    e.isRenderTargetTexture && (t.newTexture = zm(new oe(1, 1, 1, 0)));
  }
}
function jp(s) {
  const e = Xm.DontExport;
  return !(s.hideFlags & e);
}
const Pf = w("debugexr");
class iM {
  get name() {
    return "EXT_texture_exr";
  }
  parser;
  constructor(e) {
    this.parser = e, Pf && console.log(e);
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, o = i.json.textures[e];
    if (Pf && console.log("EXT_texture_exr.loadTexture", e, o), !o.extensions || !o.extensions[t])
      return null;
    const r = o.extensions[t], a = new gm(i.options.manager);
    return Pf && console.log("EXT_texture_exr.loadTexture", r), i.loadTextureImage(e, r.source, a);
  }
}
typeof window < "u" && window.addEventListener("unhandledrejection", (s) => {
});
const Zn = dt, lh = "$___Export_Components", nM = "NEEDLE_components";
class sM {
  [Br];
}
class oM {
  node;
  nodeIndex;
  nodeDef;
  constructor(e, t, i) {
    this.node = e, this.nodeIndex = t, this.nodeDef = i;
  }
}
class cv {
  get name() {
    return nM;
  }
  // import
  parser;
  nodeToObjectMap = {};
  /** The loaded gltf */
  gltf = null;
  // export
  exportContext;
  objectToNodeMap = {};
  context;
  writer;
  registerExport(e) {
    e.register((t) => {
      if ("serializeUserData" in t) {
        const i = t.serializeUserData.bind(t);
        this.writer = t, t.serializeUserData = (n, o) => {
          try {
            this.serializeUserData(n, o) && (t.extensionsUsed[this.name] = !0), i(n, o);
          } finally {
            this.afterSerializeUserData(n, o);
          }
        };
      }
      return this;
    });
  }
  beforeParse() {
    this.exportContext = {}, this.objectToNodeMap = {};
  }
  // https://github.com/mrdoob/three.js/blob/efbfc67edc7f65cfcc61a389ffc5fd43ea702bc6/examples/jsm/exporters/GLTFExporter.js#L532
  serializeUserData(e, t) {
    const i = e.userData?.components;
    return !i || i.length <= 0 ? !1 : (delete e.userData.components, e[lh] = i, !0);
  }
  afterSerializeUserData(e, t) {
    if (e.type === "Scene" && Zn && console.log("DONE", JSON.stringify(t)), e[lh] === void 0) return;
    const i = e[lh];
    delete e[lh], i !== null && (e.userData.components = i);
  }
  writeNode(e, t) {
    const i = this.writer.json.nodes.length;
    Zn && console.log(e.name, i, e.uuid);
    const n = new oM(e, i, t);
    this.exportContext[i] = n, this.objectToNodeMap[e.uuid] = i;
  }
  afterParse(e) {
    Zn && console.log("AFTER", e);
    for (const t in this.exportContext) {
      const i = this.exportContext[t], n = i.node, o = i.nodeDef, r = i.nodeIndex, a = n.userData?.components;
      if (!a || a.length <= 0) continue;
      const l = new sM();
      o.extensions = o.extensions || {}, o.extensions[this.name] = l, this.context.object = n, this.context.nodeId = r, this.context.objectToNode = this.objectToNodeMap;
      const c = [];
      for (const h of a) {
        this.context.target = h;
        const d = jn().writeBuiltinComponentData(h, this.context);
        d !== null && c.push(d);
      }
      c.length > 0 && (l[Br] = c, Zn && console.log("DID WRITE", n, "nodeIndex", r, c));
    }
  }
  // -------------------------------------
  // LOADING 
  // called by GLTFLoader
  beforeRoot() {
    return Zn && console.log("BEGIN LOAD"), this.nodeToObjectMap = {}, null;
  }
  // called by GLTFLoader
  async afterRoot(e) {
    this.gltf = e;
    const t = e.parser, i = t?.extensions;
    if (!i) return;
    const n = i[this.name];
    Zn && console.log("After root", e, this.parser, i);
    const o = [];
    if (n === !0) {
      const r = t.json.nodes;
      if (r) {
        for (let a = 0; a < r.length; a++) {
          const l = await t.getDependency("node", a);
          this.nodeToObjectMap[a] = l;
        }
        for (let a = 0; a < r.length; a++) {
          const l = r[a], c = a, h = l.extensions;
          if (!h) continue;
          const d = h[this.name];
          if (!d) continue;
          Zn && console.log("NODE", l);
          const f = this.nodeToObjectMap[c];
          if (!f) {
            console.error("Could not find object for node index: " + c, l, t);
            continue;
          }
          jm(f), o.push(this.createComponents(f, d));
        }
      }
    }
    await Promise.all(o);
    for (const r of t.associations.keys()) {
      const a = t.associations.get(r);
      if (a?.materials != null) {
        const l = "/materials/" + a.materials;
        dP(r, l);
      }
    }
  }
  async createComponents(e, t) {
    if (!t) return;
    const i = t[Br];
    if (i) {
      const n = new Array();
      Zn && console.log(e.name, i);
      for (const o in i) {
        const r = i[o];
        Zn && console.log("Serialized data", JSON.parse(JSON.stringify(r))), r && this.parser && n.push(
          Lm(this.parser, r).catch((a) => console.error(`Error while resolving references (see console for details)
`, a, e, r))
        ), e.userData = e.userData || {}, e.userData[Br] = e.userData[Br] || [], e.userData[Br].push(r);
      }
      await Promise.all(n).catch((o) => {
        console.error("Error while loading components", o);
      });
    }
  }
  // parse function https://github.com/mrdoob/three.js/blob/efbfc67edc7f65cfcc61a389ffc5fd43ea702bc6/examples/jsm/loaders/GLTFLoader.js#L2290
  // createNodeAttachment(nodeIndex: number): null {
  //     // if(!this.parser){
  //     //     console.error("Parser not set, call registerLoad with on this");
  //     //     return null;
  //     // }
  //     // const node = this.parser.json.nodes[nodeIndex];
  //     // const extenstions = node.extensions;
  //     // const data = extenstions && extenstions[this.name];
  //     // if (!data) return null;
  //     // const components = data[builtinComponentKeyName];
  //     // if (!components) return null;
  //     // console.log(components);
  //     return null;
  // }
}
const __ = "NEEDLE_gameobject_data";
class rM {
  get name() {
    return __;
  }
  parser;
  constructor(e) {
    this.parser = e;
  }
  // private _lastIndex: number = -1;
  // createNodeAttachment(index): null {
  //     if (index === this._lastIndex) return null;
  //     this._lastIndex = index;
  //     const node = this.parser.json.nodes[index];
  //     if (node && node.extensions) {
  //         const ext = node.extensions[EXTENSION_NAME];
  //         if (ext)
  //             this.findAndApplyExtensionData(index, ext);
  //     }
  //     return null;
  // }
  // private lastIndex: number = -1;
  afterRoot(e) {
    const t = [];
    for (let i = 0; i < this.parser.json.nodes?.length; i++) {
      const n = this.parser.json.nodes[i];
      if (n && n.extensions) {
        const o = n.extensions[__];
        if (o) {
          const r = this.findAndApplyExtensionData(i, o);
          t.push(r);
        }
      }
    }
    return Promise.all(t).then(() => null);
  }
  async findAndApplyExtensionData(e, t) {
    const i = await this.parser.getDependency("node", e);
    i && this.applyExtensionData(i, t);
  }
  applyExtensionData(e, t) {
    t.layers === void 0 && (t.layers = 0), e.userData.layer = t.layers, e.layers.disableAll(), e.layers.set(t.layers), e.userData.tag = t.tag ?? "none", e.hideFlags = 0, e.userData.static = t.static ?? !1, e.visible = t.activeSelf ?? !0, e.guid = t.guid;
  }
}
const b_ = "NEEDLE_lighting_settings", Nr = w("debugenvlight");
class aM {
  get name() {
    return b_;
  }
  parser;
  sourceId;
  context;
  constructor(e, t, i) {
    this.parser = e, this.sourceId = t, this.context = i;
  }
  afterRoot(e) {
    const t = this.parser.json.extensions;
    if (t) {
      const i = t[b_];
      if (i) {
        Nr && console.log('Loaded "' + this.name + '", src: "' + this.sourceId + '"', i);
        let n;
        if (e.scene.children.length === 1) {
          const o = e.scene.children[0];
          n = S.addComponent(o, Bp, {}, { callAwake: !1 });
        } else {
          const o = new M();
          o.name = "LightSettings " + this.sourceId, e.scene.add(o), n = S.addComponent(o, Bp, {}, { callAwake: !1 });
        }
        n.sourceId = this.sourceId, n.ambientIntensity = i.ambientIntensity, n.ambientLight = new se().fromArray(i.ambientLight), Array.isArray(i.ambientTrilight) && (n.ambientTrilight = i.ambientTrilight.map((o) => new se().fromArray(o))), n.ambientMode = i.ambientMode, n.environmentReflectionSource = i.environmentReflectionSource;
      }
    }
    return null;
  }
}
he.registerCallback(ce.ContextCreated, (s) => {
  const e = s.context, t = S.findObjectOfType(Bp, e);
  t?.sourceId && (t.enabled = !0);
});
class Bp extends T {
  ambientMode = Ul.Skybox;
  ambientLight;
  ambientTrilight;
  ambientIntensity = 1;
  environmentReflectionSource = kp.Skybox;
  _hasReflection = !1;
  _ambientLightObj;
  _hemisphereLightObj;
  awake() {
    if (this.sourceId) {
      const t = this.environmentReflectionSource === kp.Skybox ? xn.Skybox : xn.Reflection, i = this.context.lightmaps.tryGet(this.sourceId, t, 0);
      this._hasReflection = i != null, i && this.context.sceneLighting.internalRegisterReflection(this.sourceId, i);
    }
    this.enabled = !1, this.context.sceneLighting.internalRegisterSceneLightSettings(this), Nr && window.addEventListener("keydown", (t) => {
      if (!this.destroyed)
        switch (t.key) {
          case "l":
            this.enabled = !this.enabled;
            break;
        }
    });
    const e = this.gameObject.userData?.components;
    if (e) {
      const t = e.indexOf(this);
      e.splice(t, 1), e.push(this);
    }
  }
  onDestroy() {
    this.context.sceneLighting.internalUnregisterSceneLightSettings(this);
  }
  calculateIntensityFactor(e) {
    const t = Math.max(e.r, e.g, e.b);
    return 2.2 * j.lerp(0, 1.33, t);
  }
  onEnable() {
    if (Nr && console.warn("💡🟡 >>> Enable lighting", this.sourceId, this.enabled, this), this.ambientMode == Ul.Flat) {
      if (this.ambientLight && !this._ambientLightObj) {
        const e = this.calculateIntensityFactor(this.ambientLight);
        this._ambientLightObj = new fx(this.ambientLight, this.ambientIntensity * e), Nr && console.log("Created ambient light", this.sourceId, this._ambientLightObj, this.ambientIntensity, e);
      }
      this._ambientLightObj && this.gameObject.add(this._ambientLightObj);
    } else if (this.ambientMode === Ul.Trilight) {
      if (this.ambientTrilight) {
        const e = this.ambientTrilight[0], t = this.ambientTrilight[this.ambientTrilight.length - 1], i = this.calculateIntensityFactor(t);
        this._hemisphereLightObj = new px(t, e, this.ambientIntensity * i), this.gameObject.add(this._hemisphereLightObj), Nr && console.log("Created hemisphere ambient light", this.sourceId, this._hemisphereLightObj, this.ambientIntensity, i);
      }
    } else
      this._ambientLightObj && this._ambientLightObj.removeFromParent(), this._hemisphereLightObj && this._hemisphereLightObj.removeFromParent();
    this.sourceId && this.context.sceneLighting.internalEnableReflection(this.sourceId);
  }
  onDisable() {
    Nr && console.warn("💡⚫ <<< Disable lighting:", this.sourceId, this), this._ambientLightObj && this._ambientLightObj.removeFromParent(), this._hemisphereLightObj && this._hemisphereLightObj.removeFromParent(), this.sourceId && this.context.sceneLighting.internalDisableReflection(this.sourceId);
  }
}
const Of = w("debugstencil");
function lM(s, e) {
  return (s & 1 << e.layer) != 0;
}
const cM = Symbol("stencils");
class Ys {
  get name() {
    return "NEEDLE_render_objects";
  }
  static stencils = {};
  static applyStencil(e) {
    if (!e) return;
    const t = e.sourceId;
    if (Of && console.log(t, Ys.stencils), !t) return;
    const i = Ys.stencils[t];
    if (i)
      for (let n = i.length - 1; n >= 0; n--) {
        const o = i[n];
        if (lM(o.layer, e)) {
          Of && console.log(o), setTimeout(() => {
            rn() && Bm(e.gameObject) && (ge("Stencil not supported on instanced objects"), console.warn("Stencil not supported on instanced objects", e));
          }, 500);
          for (let r = 0; r < e.sharedMaterials.length; r++) {
            let a = e.sharedMaterials[r];
            a && (a = a.clone(), a[cM] = !0, a.stencilWrite = !0, a.stencilWriteMask = 255, a.stencilFuncMask = 255, a.stencilRef = o.value, a.stencilFunc = o.compareFunc, a.stencilZPass = o.passOp, a.stencilFail = o.failOp, a.stencilZFail = o.zFailOp, e.sharedMaterials[r] = a);
          }
          e.gameObject.renderOrder = o.event * 1e3 + o.index * 50;
          break;
        }
      }
  }
  parser;
  source;
  constructor(e, t) {
    this.parser = e, this.source = t;
  }
  afterRoot(e) {
    const t = this.parser.json.extensions;
    if (t) {
      const i = t[dM];
      if (i) {
        Of && console.log(i);
        const n = i.stencil;
        if (n && Array.isArray(n))
          for (const o of n) {
            const r = { ...o };
            r.compareFunc = hM(r.compareFunc), r.passOp = kf(r.passOp), r.failOp = kf(r.failOp), r.zFailOp = kf(r.zFailOp), Ys.stencils[this.source] || (Ys.stencils[this.source] = []), Ys.stencils[this.source].push(r);
          }
      }
    }
    return null;
  }
}
function kf(s) {
  switch (s) {
    case 0:
      return Rx;
    case 1:
      return Mx;
    case 2:
      return kx;
    case 3:
      return Ox;
    case 4:
      return Px;
    case 6:
      return Cx;
    case 7:
      return Sx;
    case 5:
      return xx;
  }
  return 0;
}
function hM(s) {
  switch (s) {
    case 1:
      return qg;
    case 2:
      return wx;
    case 3:
      return vx;
    case 4:
      return bx;
    case 5:
      return _x;
    case 6:
      return yx;
    case 7:
      return gx;
    case 8:
      return mx;
  }
  return qg;
}
const dM = "NEEDLE_render_objects";
var hv = /* @__PURE__ */ ((s) => (s[s.INT = 5124] = "INT", s[s.FLOAT = 5126] = "FLOAT", s[s.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", s[s.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", s[s.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", s[s.INT_VEC2 = 35667] = "INT_VEC2", s[s.INT_VEC3 = 35668] = "INT_VEC3", s[s.INT_VEC4 = 35669] = "INT_VEC4", s[s.BOOL = 35670] = "BOOL", s[s.BOOL_VEC2 = 35671] = "BOOL_VEC2", s[s.BOOL_VEC3 = 35672] = "BOOL_VEC3", s[s.BOOL_VEC4 = 35673] = "BOOL_VEC4", s[s.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", s[s.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", s[s.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", s[s.SAMPLER_2D = 35678] = "SAMPLER_2D", s[s.SAMPLER_3D = 35680] = "SAMPLER_3D", s[s.SAMPLER_CUBE = 35681] = "SAMPLER_CUBE", s[s.UNKNOWN = 0] = "UNKNOWN", s))(hv || {});
const _n = w("debugcustomshader"), Tr = "NEEDLE_techniques_webgl";
class uM {
  objectToWorldMatrix = new te();
  worldToObjectMatrix = new te();
  objectToWorld = new Array();
  worldToObject = new Array();
  updateFrom(e) {
    this.objectToWorldMatrix.copy(e.matrixWorld), ld(this.objectToWorldMatrix, this.objectToWorld), this.worldToObjectMatrix.copy(e.matrixWorld).invert(), ld(this.worldToObjectMatrix, this.worldToObject);
  }
}
class Me extends fb {
  identifier;
  onBeforeRenderSceneCallback = this.onBeforeRenderScene.bind(this);
  clone() {
    const e = super.clone();
    return dv(e), e;
  }
  constructor(e, ...t) {
    super(...t), this.identifier = e, _n && console.log(this), this.type = "NEEDLE_CUSTOM_SHADER", this.uniforms[this._objToWorldName] || (this.uniforms[this._objToWorldName] = { value: [] }), this.uniforms[this._worldToObjectName] || (this.uniforms[this._worldToObjectName] = { value: [] }), this.uniforms[this._viewProjectionName] || (this.uniforms[this._viewProjectionName] = { value: [] }), this.uniforms[this._sphericalHarmonicsName], (this.depthTextureUniform || this.opaqueTextureUniform) && N.Current.pre_render_callbacks.push(this.onBeforeRenderSceneCallback);
  }
  dispose() {
    super.dispose();
    const e = N.Current.pre_render_callbacks.indexOf(this.onBeforeRenderSceneCallback);
    e >= 0 && N.Current.pre_render_callbacks.splice(e, 1);
  }
  /* REMOVED, we don't have Lit shader support for now
  async waitForLighting() {
      const context: Context = Context.Current;
      if (!context) {
          console.error("Missing context");
          return;
      }
      const data = await context.sceneLighting.internalGetSceneLightingData(this.identifier);
      if (!data || !data.array) {
          console.warn("Missing lighting data for custom shader, getSceneLightingData did not return anything");
          return;
      }
      if (debug)
          console.log(data);
      const array = data.array;
      const envTexture = data.texture;
      // console.log(envTexture);
      this.uniforms["unity_SpecCube0"] = { value: envTexture };
      SetUnitySphericalHarmonics(this.uniforms, array);
      const hdr = Math.sqrt(Math.PI * .5);
      this.uniforms["unity_SpecCube0_HDR"] = { value: new Vector4(hdr, hdr, hdr, hdr) };
      // this.needsUpdate = true;
      // this.uniformsNeedUpdate = true;
      if (debug) console.log("Set environment lighting", this.uniforms);
  }
  */
  _sphericalHarmonicsName = "unity_SpecCube0";
  _objToWorldName = "hlslcc_mtx4x4unity_ObjectToWorld";
  _worldToObjectName = "hlslcc_mtx4x4unity_WorldToObject";
  static viewProjection = new te();
  static _viewProjectionValues = [];
  _viewProjectionName = "hlslcc_mtx4x4unity_MatrixVP";
  static viewMatrix = new te();
  static _viewMatrixValues = [];
  _viewMatrixName = "hlslcc_mtx4x4unity_MatrixV";
  static _worldSpaceCameraPosName = "_WorldSpaceCameraPos";
  static _worldSpaceCameraPos = new b();
  static _mainLightColor = new de();
  static _mainLightPosition = new b();
  static _lightData = new de();
  _rendererData = new uM();
  get depthTextureUniform() {
    if (this.uniforms)
      return this.uniforms._CameraDepthTexture;
  }
  get opaqueTextureUniform() {
    if (this.uniforms)
      return this.uniforms._CameraOpaqueTexture;
  }
  onBeforeRenderScene() {
    this.opaqueTextureUniform && N.Current.setRequireColor(!0), this.depthTextureUniform && N.Current.setRequireDepth(!0);
  }
  onBeforeRender(e, t, i, n, o, r) {
    n.attributes.tangent || n.computeTangents(), this.onUpdateUniforms(i, o);
  }
  onUpdateUniforms(e, t) {
    const i = N.Current;
    if (e && (Me.viewProjection && this.uniforms[this._viewProjectionName] && (Me.viewProjection.copy(e.projectionMatrix).multiply(e.matrixWorldInverse), ld(Me.viewProjection, Me._viewProjectionValues)), Me.viewMatrix && this.uniforms[this._viewMatrixName] && (Me.viewMatrix.copy(e.matrixWorldInverse), ld(Me.viewMatrix, Me._viewMatrixValues)), this.uniforms[Me._worldSpaceCameraPosName] && Me._worldSpaceCameraPos.setFromMatrixPosition(e.matrixWorld)), this.uniforms._TimeParameters && (this.uniforms._TimeParameters.value = i.sceneLighting.timeVec4), this.uniforms._Time) {
      const a = this.uniforms._Time.value;
      a.x = i.sceneLighting.timeVec4.x / 20, a.y = i.sceneLighting.timeVec4.x, a.z = i.sceneLighting.timeVec4.x * 2, a.w = i.sceneLighting.timeVec4.x * 3;
    }
    if (this.uniforms._SinTime) {
      const a = this.uniforms._SinTime.value;
      a.x = Math.sin(i.sceneLighting.timeVec4.x / 8), a.y = Math.sin(i.sceneLighting.timeVec4.x / 4), a.z = Math.sin(i.sceneLighting.timeVec4.x / 2), a.w = Math.sin(i.sceneLighting.timeVec4.x);
    }
    if (this.uniforms._CosTime) {
      const a = this.uniforms._CosTime.value;
      a.x = Math.cos(i.sceneLighting.timeVec4.x / 8), a.y = Math.cos(i.sceneLighting.timeVec4.x / 4), a.z = Math.cos(i.sceneLighting.timeVec4.x / 2), a.w = Math.cos(i.sceneLighting.timeVec4.x);
    }
    if (this.uniforms.unity_DeltaTime) {
      const a = this.uniforms.unity_DeltaTime.value;
      a.x = i.time.deltaTime, a.y = 1 / i.time.deltaTime, a.z = i.time.smoothedDeltaTime, a.w = 1 / i.time.smoothedDeltaTime;
    }
    const n = i.mainLight;
    if (n) {
      const a = Z(n.gameObject, Me._mainLightPosition);
      this.uniforms._MainLightPosition = { value: a.normalize() }, Me._mainLightColor.set(n.color.r, n.color.g, n.color.b, 0), this.uniforms._MainLightColor = { value: Me._mainLightColor };
      const l = n.intensity;
      Me._lightData.z = l, this.uniforms.unity_LightData = { value: Me._lightData };
    }
    if (e && (Me.viewProjection && this.uniforms[this._viewProjectionName] && (this.uniforms[this._viewProjectionName].value = Me._viewProjectionValues), Me.viewMatrix && this.uniforms[this._viewMatrixName] && (this.uniforms[this._viewMatrixName].value = Me._viewMatrixValues), this.uniforms[Me._worldSpaceCameraPosName] && (this.uniforms[Me._worldSpaceCameraPosName] = { value: Me._worldSpaceCameraPos }), i.mainCameraComponent)) {
      if (this.uniforms._ProjectionParams) {
        const a = this.uniforms._ProjectionParams.value;
        a.x = 1, a.y = i.mainCameraComponent.nearClipPlane, a.z = i.mainCameraComponent.farClipPlane, a.w = 1 / a.z, this.uniforms._ProjectionParams.value = a;
      }
      if (this.uniforms._ZBufferParams) {
        const a = this.uniforms._ZBufferParams.value, l = i.mainCameraComponent;
        a.x = 1 - l.farClipPlane / l.nearClipPlane, a.y = l.farClipPlane / l.nearClipPlane, a.z = a.x / l.farClipPlane, a.w = a.y / l.farClipPlane, this.uniforms._ZBufferParams.value = a;
      }
      if (this.uniforms._ScreenParams) {
        const a = this.uniforms._ScreenParams.value;
        a.x = i.domWidth, a.y = i.domHeight, a.z = 1 + 1 / a.x, a.w = 1 + 1 / a.y, this.uniforms._ScreenParams.value = a;
      }
      if (this.uniforms._ScaledScreenParams) {
        const a = this.uniforms._ScaledScreenParams.value;
        a.x = i.domWidth, a.y = i.domHeight, a.z = 1 + 1 / a.x, a.w = 1 + 1 / a.y, this.uniforms._ScaledScreenParams.value = a;
      }
    }
    const o = this.depthTextureUniform;
    o && (o.value = i.depthTexture);
    const r = this.opaqueTextureUniform;
    if (r && (r.value = i.opaqueColorTexture), t) {
      const a = this._rendererData;
      a.updateFrom(t), this.uniforms[this._worldToObjectName].value = a.worldToObject, this.uniforms[this._objToWorldName].value = a.objectToWorld;
    }
    this.uniformsNeedUpdate = !0;
  }
}
class fM {
  get name() {
    return Tr;
  }
  parser;
  identifier;
  constructor(e, t) {
    this.parser = e, this.identifier = t;
  }
  loadMaterial(e) {
    const t = this.parser.json.materials[e];
    if (!t)
      return _n && console.log(e, this.parser.json.materials), null;
    if (!t.extensions || !t.extensions[Tr])
      return _n && console.log(`Material ${e} does not use NEEDLE_techniques_webgl`), null;
    _n && console.log(`Material ${e} uses NEEDLE_techniques_webgl`, t);
    const i = t.extensions[Tr].technique;
    if (i < 0)
      return console.debug(`Material ${e} does not have a valid technique index`), null;
    const n = this.parser.json.extensions[Tr];
    if (!n)
      return _n ? console.error("Missing shader data", this.parser.json.extensions) : console.debug("Missing custom shader data in parser.json.extensions"), null;
    _n && console.log(n);
    const o = n.techniques[i];
    return o ? new Promise(async (r, a) => {
      const l = await eO(n, o.program), c = l?.fragmentShader, h = l?.vertexShader;
      if (!c || !h) return a();
      _n && console.log("loadMaterial", t, l);
      const d = {}, f = o.uniforms;
      (h.includes("_Time") || c.includes("_Time")) && (d._Time = { value: new de(0, 0, 0, 0) }), (h.includes("_SinTime") || c.includes("_SinTime")) && (d._SinTime = { value: new de(0, 0, 0, 0) }), (h.includes("_CosTime") || c.includes("_CosTime")) && (d._CosTime = { value: new de(0, 0, 0, 0) }), (h.includes("unity_DeltaTime") || c.includes("unity_DeltaTime")) && (d.unity_DeltaTime = { value: new de(0, 0, 0, 0) });
      for (const v in f) {
        const y = v;
        switch (y) {
          case "_TimeParameters":
            const x = new de();
            d[y] = { value: x };
            break;
          case "hlslcc_mtx4x4unity_MatrixV":
          case "hlslcc_mtx4x4unity_MatrixVP":
            d[y] = { value: [] };
            break;
          case "_MainLightPosition":
          case "_MainLightColor":
          case "_WorldSpaceCameraPos":
            d[y] = { value: [0, 0, 0, 1] };
            break;
          case "unity_OrthoParams":
            break;
          case "unity_SpecCube0":
            d[y] = { value: null };
            break;
          default:
          case "_ScreenParams":
          case "_ZBufferParams":
          case "_ProjectionParams":
            d[y] = { value: [0, 0, 0, 0] };
            break;
          case "_CameraOpaqueTexture":
          case "_CameraDepthTexture":
            d[y] = { value: null };
            break;
        }
      }
      let p = !1;
      if (t.extensions && t.extensions[Tr]) {
        const v = t.extensions[Tr];
        if (v.technique === i) {
          _n && console.log(t.name, "Material Properties", v);
          for (const y in v.values) {
            const x = v.values[y];
            if (typeof x == "string") {
              if (x.startsWith("/textures/")) {
                const I = x.substring(10), O = Number.parseInt(I);
                if (O >= 0) {
                  const k = await this.parser.getDependency("texture", O);
                  k instanceof Te && (k.colorSpace = Ss, k.needsUpdate = !0), d[y] = { value: k };
                  continue;
                }
              }
              switch (y) {
                case "alphaMode":
                  x === "BLEND" && (p = !0);
                  continue;
              }
            }
            if (Array.isArray(x) && x.length === 4) {
              d[y] = { value: new de(x[0], x[1], x[2], x[3]) };
              continue;
            }
            d[y] = { value: x };
          }
        }
      }
      const g = new Me(
        this.identifier,
        {
          name: t.name ?? "",
          uniforms: d,
          vertexShader: h,
          fragmentShader: c,
          lights: !1
          // defines: {
          //     "USE_SHADOWMAP" : true
          // },
        }
      );
      switch (g.glslVersion = Tx, g.vertexShader = g.vertexShader.replace("#version 300 es", ""), g.fragmentShader = g.fragmentShader.replace("#version 300 es", ""), d._Cull?.value) {
        case 0:
          g.side = yi;
          break;
        case 1:
          g.side = Bd;
          break;
        case 2:
          g.side = co;
          break;
        default:
          g.side = co;
          break;
      }
      switch (d._ZTest?.value) {
        case 3:
          g.depthTest = !0, g.depthFunc = Bx;
          break;
        case 6:
          g.depthTest = !0, g.depthFunc = jx;
          break;
        case 2:
          g.depthTest = !0, g.depthFunc = Dx;
          break;
        case 4:
          g.depthTest = !0, g.depthFunc = Lx;
          break;
        case 5:
          g.depthTest = !0, g.depthFunc = Ix;
          break;
        case 7:
          g.depthTest = !0, g.depthFunc = Ax;
          break;
        case 8:
          g.depthTest = !1, g.depthFunc = Ex;
          break;
      }
      g.transparent = p, p && (g.depthWrite = !1), ZP(d), g.onUpdateUniforms();
      for (const v in f) {
        const y = v, x = f[v].type;
        if (d[y]?.value === void 0)
          switch (x) {
            case hv.SAMPLER_2D:
              d[y] = { value: YP }, console.warn("Missing/unassigned texture, fallback to white: " + y);
              break;
            default:
              y === "unity_OrthoParams" || console.warn("TODO: EXPECTED UNIFORM / fallback NOT SET: " + y, f[v]);
              break;
          }
      }
      _n && console.log(g.uuid, d), dv(g), r(g);
    }) : null;
  }
}
function dv(s) {
  if (s.uniforms) {
    _n && console.log("Uniforms:", s.uniforms);
    for (const t in s.uniforms)
      switch (e(t, t), t) {
        case "_Color":
          e("color", t);
          break;
      }
  }
  function e(t, i) {
    Object.getOwnPropertyDescriptor(s, t) || Object.defineProperty(s, t, {
      get: () => s.uniforms[i].value,
      set: (n) => {
        s.uniforms[i].value = n, s.needsUpdate = !0;
      }
    });
  }
}
const pM = w("debugextensions");
let gd;
const mM = import("./vendor-Z4SPrTcP.js").then((s) => s.index$2).then(async (s) => (gd = s.GLTFAnimationPointerExtension, gd)).catch((s) => {
  console.warn("Failed to import GLTFLoaderAnimationPointer. Please use @needle-tools/three-animationpointer for full KHR_animation support", s);
}), or = new Array();
function sL(s) {
  or.includes(s) || or.push(s);
}
function oL(s) {
  const e = or.indexOf(s);
  e >= 0 && or.splice(e, 1);
}
function uv(s) {
  if (s instanceof Ps) {
    const e = new cv();
    return s.register((t) => (e.parser = t, e)), e;
  }
  return null;
}
class gM {
  resolvePath(e) {
    return e.includes("/extensions/builtin_components/") ? e.replace("/extensions/builtin_components/", "/userData/components/") : e.includes("extensions/builtin_components/") ? e.replace("extensions/builtin_components/", "/userData/components/") : e;
  }
}
async function Fp(s, e, t) {
  const i = t.indexOf("?");
  i >= 0 && (t = t.substring(0, i)), s.register((n) => new rM(n)), s.register((n) => new fP(n)), s.register((n) => new VP(n, e.lightmaps, t)), s.register((n) => new aM(n, t, e)), s.register((n) => new fM(n, t)), s.register((n) => new Ys(n, t)), s.register((n) => new We(n)), s.register((n) => new iM(n)), U1() && s.register((n) => new Jr(n)), await mM.catch((n) => {
  }), s.register((n) => {
    if (gd) {
      const o = new gd(n);
      return o.setAnimationPointerResolver.bind(o)(new gM()), o;
    } else
      return (pM || L()) && console.error("Missing KHR_animation_pointer extension..."), {
        name: "KHR_animation_pointer_NOT_AVAILABLE"
      };
  });
  for (const n of or)
    n.onImport && n.onImport(s, t, e);
}
function fv(s, e) {
  for (const t of or)
    t.onExport && t.onExport(s, e);
}
function yM(s, e, t) {
  for (const i of or)
    i.onLoaded && i.onLoaded(s, e, t);
}
class pv {
  constructor(e) {
    this.writer = e, this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(e, t) {
    if (e.constructor.name !== "InstancedMesh") return;
    const i = this.writer, n = i.extensionsUsed, o = {};
    t.extensions = t.extensions || {}, t.extensions[this.name] = o;
    let r = new te();
    const a = new Array(), l = new Array(), c = new Array();
    for (let p = 0; p < e.count; p++) {
      e.getMatrixAt(p, r);
      let g = new b(), _ = new $(), m = new b();
      r.decompose(g, _, m), a.push(g.x, g.y, g.z), l.push(_.x, _.y, _.z, _.w), c.push(m.x, m.y, m.z);
    }
    const h = new Float32Array(a), d = new Float32Array(l), f = new Float32Array(c);
    o.attributes = {
      TRANSLATION: i.processAccessor(new ht(h, 3)),
      ROTATION: i.processAccessor(new ht(d, 4)),
      SCALE: i.processAccessor(new ht(f, 3))
    }, n[this.name] = !0;
  }
}
var _M = Object.defineProperty, mv = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && _M(e, t, n), n;
};
const ol = w("debugreflectionprobe"), v_ = w("noreflectionprobe"), Mf = Symbol("reflectionProbeKey"), w_ = Symbol("original material"), og = class ss extends T {
  static _probes = /* @__PURE__ */ new Map();
  static isUsingReflectionProbe(e) {
    return !!(e[Mf] || e[w_]?.[Mf]);
  }
  static get(e, t, i, n) {
    if (!e || e.isObject3D !== !0 || v_) return null;
    const o = ss._probes.get(t);
    if (o) {
      for (const r of o)
        if (r.__didAwake || r.__internalAwake(), r.activeAndEnabled) {
          if (n) {
            if (r.gameObject === n)
              return r;
          } else if (r.isInBox(e))
            return ol && console.log("Found reflection probe", e.name, r.name), r;
        }
    }
    return ol && console.debug("Did not find reflection probe", e.name, i, e), null;
  }
  _texture;
  // @serializable(Texture)
  set texture(e) {
    if (e && !(e instanceof Te)) {
      console.error("ReflectionProbe.texture must be a Texture", e);
      return;
    }
    this._texture = e, e && (e.mapping = _s, e.colorSpace = Ss, e.needsUpdate = !0);
  }
  get texture() {
    return this._texture;
  }
  center;
  size;
  _boxHelper;
  isInBox(e) {
    return this._boxHelper?.isInBox(e);
  }
  constructor() {
    super(), ss._probes.has(this.context) || ss._probes.set(this.context, []), ss._probes.get(this.context)?.push(this);
  }
  awake() {
    this._boxHelper = this.gameObject.addComponent(Ct), this._boxHelper.updateBox(!0), ol && this._boxHelper.showHelper(5592320, !0), this._texture && (this._texture.mapping = _s, this._texture.colorSpace = Ss, this._texture.needsUpdate = !0);
  }
  start() {
    !this._texture && L() && (console.warn(`[ReflectionProbe] Missing texture. Please assign a custom cubemap texture. To use reflection probes assign them to your renderer's "anchor" property.`), ge("ReflectionProbe configuration hint: See browser console for details"));
  }
  onDestroy() {
    const e = ss._probes.get(this.context);
    if (e) {
      const t = e.indexOf(this);
      t >= 0 && e.splice(t, 1);
    }
  }
  // when objects are rendered and they share material
  // and some need reflection probe and some don't
  // we need to make sure we don't override the material but use a copy
  static _rendererMaterialsCache = /* @__PURE__ */ new Map();
  onSet(e) {
    if (v_ || !this.enabled || e.sharedMaterials?.length <= 0 || !this.texture) return;
    let t = ss._rendererMaterialsCache.get(e);
    t || (t = [], ss._rendererMaterialsCache.set(e, t));
    for (let i = 0; i < e.sharedMaterials.length; i++) {
      const n = e.sharedMaterials[i];
      if (!n || n.envMap === void 0 || n instanceof we)
        continue;
      let o = t[i];
      const r = n === o?.copy, a = !o || o.material.uuid !== n.uuid || o.copy.version !== n.version;
      if (!r && a) {
        if (ol) {
          let h = "";
          o ? o.material !== n ? h = "reference changed; cached instance?: " + r : o.copy.version !== n.version && (h = "version changed") : h = "not cached", console.warn("Cloning material", n.name, n.version, "Reason:", h, `
`, n.uuid, `
`, o?.copy.uuid, `
`, e.name);
        }
        const c = n.clone();
        c.version = n.version, o ? (o.copy = c, o.material = n) : (o = {
          material: n,
          copy: c
        }, t.push(o)), c[Mf] = this, c[w_] = n, ol && console.log("Set reflection", e.name, e.guid);
      }
      o && o.copy && (o.copy.onBeforeCompile = n.onBeforeCompile);
      const l = o?.copy;
      l.envMap = this.texture, e.sharedMaterials[i] = l;
    }
  }
  onUnset(e) {
    const t = ss._rendererMaterialsCache.get(e);
    if (t)
      for (let i = 0; i < t.length; i++) {
        const n = t[i];
        e.sharedMaterials[i] = n.material;
      }
  }
};
mv([
  u(b)
], og.prototype, "center");
mv([
  u(b)
], og.prototype, "size");
let yd = og;
const Qt = w("debuginstancing");
class Pa {
  static instance = new Pa();
  /** This is the initial instance count when creating a new instancing structure.    
   * Override this and the number of max instances that you expect for a given object.
   * The larger the value the more objects can be added without having to resize but it will also consume more memory.    
   * (The instancing mesh renderer will grow x2 if the max instance count is reached)
   * @default 4
   * @returns The initial instance count
   * */
  static getStartInstanceCount = (e) => 4;
  objs = [];
  setup(e, t, i, n, o, r = 0) {
    e.applySettings(t);
    const a = this.tryCreateOrAddInstance(t, i, o);
    if (a) {
      n === null && (n = []), n.push(a), We.assignTextureLOD(a.renderer.material, 0);
      for (let l = 0; l < e.sharedMeshes.length; l++) {
        const c = e.sharedMeshes[l], h = c.geometry;
        We.assignMeshLOD(c, 0).then((d) => {
          d && e.activeAndEnabled && h != d && a.setGeometry(d);
        });
      }
    } else if (r <= 0 && t.type !== "Mesh") {
      const l = r + 1;
      for (const c of t.children)
        n = this.setup(e, c, i, n, o, l);
    }
    return r === 0 && o.useMatrixWorldAutoUpdate && n && n.length >= 0 && this.autoUpdateInstanceMatrix(t), n;
  }
  tryCreateOrAddInstance(e, t, i) {
    if (e.type === "Mesh") {
      const n = i.foundMeshes;
      if (i.foundMeshes += 1, !i.rend.enableInstancing) return null;
      if (i.rend.enableInstancing !== !0) {
        if (n >= i.rend.enableInstancing.length)
          return Qt && console.error("Something is wrong with instance setup", e, i.rend.enableInstancing, n), null;
        if (!i.rend.enableInstancing[n])
          return null;
      }
      const o = e, r = o.material;
      for (const d of this.objs) {
        if (!d.canAdd(o.geometry, r)) continue;
        return d.addInstance(o);
      }
      let a = Pa.getStartInstanceCount(e);
      (!a || a < 0) && (a = 4);
      let l = e.name;
      l?.length || (l = ZS());
      const c = new bM(l, o.geometry, r, a, t);
      return this.objs.push(c), c.addInstance(o);
    }
    return null;
  }
  autoUpdateInstanceMatrix(e) {
    const t = e.matrixWorld.multiplyMatrices.bind(e.matrixWorld), i = e.matrixWorld.clone(), n = (o, r) => {
      const a = t(o, r);
      return (e[oc] || i.equals(a) === !1) && (i.copy(a), e[oc] = !0), a;
    };
    e.matrixWorld.multiplyMatrices = n;
  }
}
class ra {
  static all = [];
  /** The name of the object */
  get name() {
    return this.object.name;
  }
  get isActive() {
    return this.__instanceIndex >= 0;
  }
  get vertexCount() {
    return this.object.geometry.attributes.position.count;
  }
  get maxVertexCount() {
    return Math.max(this.meshInformation.vertexCount, this.vertexCount);
  }
  get reservedVertexCount() {
    return this.__reservedVertexRange;
  }
  get indexCount() {
    return this.object.geometry.index ? this.object.geometry.index.count : 0;
  }
  get maxIndexCount() {
    return Math.max(this.meshInformation.indexCount, this.indexCount);
  }
  get reservedIndexCount() {
    return this.__reservedIndexRange;
  }
  /** The object that is being instanced */
  object;
  /** The instancer/BatchedMesh that is rendering this object*/
  renderer;
  /** @internal */
  __instanceIndex = -1;
  /** @internal */
  __reservedVertexRange = 0;
  /** @internal */
  __reservedIndexRange = 0;
  __geometryIndex = -1;
  /** The mesh information of the object - this tries to also calculate the LOD info */
  meshInformation;
  constructor(e, t) {
    this.__instanceIndex = -1, this.object = e, this.renderer = t, e[h0] = t, this.meshInformation = Vo(e.geometry), ra.all.push(this);
  }
  /** Calculates the mesh information again
   * @returns true if the vertex count or index count has changed
   */
  updateMeshInformation() {
    const e = Vo(this.object.geometry), t = this.meshInformation.vertexCount, i = this.meshInformation.indexCount;
    return Object.assign(this.meshInformation, e), t !== this.meshInformation.vertexCount || i !== this.meshInformation.indexCount;
  }
  /** Updates the matrix from the rendered object. Will also call updateWorldMatrix internally */
  updateInstanceMatrix(e = !1, t = !0) {
    this.__instanceIndex < 0 || (t && this.object.updateWorldMatrix(!0, e), this.renderer.updateInstance(this.object.matrixWorld, this.__instanceIndex));
  }
  /** Updates the matrix of the instance */
  setMatrix(e) {
    this.__instanceIndex < 0 || this.renderer.updateInstance(e, this.__instanceIndex);
  }
  /** Can be used to change the geometry of this instance */
  setGeometry(e) {
    if (this.__geometryIndex < 0) return !1;
    const t = this;
    if (this.vertexCount > this.__reservedVertexRange)
      return i(`Instancing: Can not update geometry (${this.name}), reserved vertex range is too small: ${this.__reservedVertexRange.toLocaleString()} < ${this.vertexCount.toLocaleString()} vertices for ${this.name}`);
    if (this.indexCount > this.__reservedIndexRange)
      return i(`Instancing: Can not update geometry (${this.name}), reserved index range is too small: ${this.__reservedIndexRange.toLocaleString()} < ${this.indexCount.toLocaleString()} indices for ${this.name}`);
    return this.renderer.updateGeometry(e, this.__geometryIndex);
    function i(n) {
      return t.updateMeshInformation() && (t.renderer.remove(t, !0), t.renderer.add(t)) ? !0 : ((L() || Qt) && console.error(n), !1);
    }
  }
  /** Adds this object to the instancing renderer (effectively activating instancing) */
  add() {
    this.__instanceIndex >= 0 || (this.renderer.add(this), S.markAsInstancedRendered(this.object, !0));
  }
  /** Removes this object from the instancing renderer 
   * @param delete_ If true, the instance handle will be removed from the global list
  */
  remove(e) {
    if (!(this.__instanceIndex < 0) && (this.renderer.remove(this, e), S.markAsInstancedRendered(this.object, !1), e)) {
      const t = ra.all.indexOf(this);
      t >= 0 && ra.all.splice(t, 1);
    }
  }
}
class bM {
  /** The three instanced mesh
   * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
   */
  get batchedMesh() {
    return this._batchedMesh;
  }
  get visible() {
    return this._batchedMesh.visible;
  }
  set visible(e) {
    this._batchedMesh.visible = e;
  }
  get castShadow() {
    return this._batchedMesh.castShadow;
  }
  set castShadow(e) {
    this._batchedMesh.castShadow = e;
  }
  set receiveShadow(e) {
    this._batchedMesh.receiveShadow = e;
  }
  /** If true, the instancer is allowed to grow when the max instance count is reached */
  allowResize = !0;
  /** The name of the instancer */
  name = "";
  /** The added geometry */
  geometry;
  /** The material used for the instanced mesh */
  material;
  /** The current number of instances */
  get count() {
    return this._currentInstanceCount;
  }
  /** Update the bounding box and sphere of the instanced mesh 
   * @param box If true, update the bounding box
   * @param sphere If true, update the bounding sphere
  */
  updateBounds(e = !0, t = !0) {
    if (this._needUpdateBounds = !1, e && this._batchedMesh.computeBoundingBox(), t && this._batchedMesh.computeBoundingSphere(), Qt && this._batchedMesh.boundingSphere) {
      const i = this._batchedMesh.boundingSphere;
      F.DrawWireSphere(i.center, i.radius, 65280);
    }
  }
  _context;
  _batchedMesh;
  _handles = [];
  _geometryIds = /* @__PURE__ */ new Map();
  _maxInstanceCount;
  _currentInstanceCount = 0;
  _currentVertexCount = 0;
  _currentIndexCount = 0;
  _maxVertexCount;
  _maxIndexCount;
  static nullMatrix = new te();
  /** Check if the geometry can be added to this instancer
   * @param geometry The geometry to check
   * @param material The material of the geometry
   * @returns true if the geometry can be added
   */
  canAdd(e, t) {
    return this._maxVertexCount > 1e7 || t !== this.material || !this.validateGeometry(e) ? !1 : !!(!this.mustGrow(e) || this.allowResize);
  }
  _needUpdateBounds = !1;
  _debugMaterial = null;
  constructor(e, t, i, n, o) {
    this.name = e, this.geometry = t, this.material = i, this._context = o, this._maxInstanceCount = Math.max(2, n), Qt && (this._debugMaterial = x_());
    const r = this.tryEstimateVertexCountSize(this._maxInstanceCount, [t], n);
    this._maxVertexCount = r.vertexCount, this._maxIndexCount = r.indexCount, this._batchedMesh = new Xg(this._maxInstanceCount, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material), this._batchedMesh[wl] = !0, this._batchedMesh.visible = !0, this._context.scene.add(this._batchedMesh), i instanceof fb && (i.defines.USE_INSTANCING = !0, i.needsUpdate = !0), o.pre_render_callbacks.push(this.onBeforeRender), o.post_render_callbacks.push(this.onAfterRender), Qt && console.log(`Instanced renderer created with ${this._maxInstanceCount} instances, ${this._maxVertexCount} max vertices and ${this._maxIndexCount} max indices for "${e}"`);
  }
  dispose() {
    Qt && console.warn("Dispose instanced renderer", this.name), this._context.scene.remove(this._batchedMesh), this._batchedMesh.dispose(), this._batchedMesh = null, this._handles = [];
  }
  addInstance(e) {
    const t = new ra(e, this);
    e.castShadow === !0 && this._batchedMesh.castShadow === !1 && (this._batchedMesh.castShadow = !0), e.receiveShadow === !0 && this._batchedMesh.receiveShadow === !1 && (this._batchedMesh.receiveShadow = !0);
    try {
      this.add(t);
    } catch (i) {
      if (console.error(`Failed adding mesh to instancing (object name: "${e.name}", instances: ${this._currentInstanceCount.toLocaleString()}/${this._maxInstanceCount.toLocaleString()}, vertices: ${this._currentVertexCount.toLocaleString()}/${this._maxVertexCount.toLocaleString()}, indices: ${this._currentIndexCount.toLocaleString()}/${this._maxIndexCount.toLocaleString()})
`, i), L()) {
        Wd("Failed instancing mesh. See the browser console for details.");
        debugger;
      }
      return null;
    }
    return t;
  }
  add(e) {
    const t = e.object.geometry;
    if (!t || !t.attributes)
      return console.error("Cannot add object to instancing without geometry", e.name), !1;
    if (this.mustGrow(t))
      if (this.allowResize)
        this.grow(t);
      else
        return console.error("Cannot add instance, max count reached", this.name, this.count, this._maxInstanceCount), !1;
    return e.object.updateWorldMatrix(!0, !0), this.addGeometry(e), this._handles[e.__instanceIndex] = e, this._currentInstanceCount += 1, this.markNeedsUpdate(), this._currentInstanceCount > 0 && (this._batchedMesh.visible = !0), !0;
  }
  remove(e, t) {
    e && (e.__instanceIndex < 0 || this._handles[e.__instanceIndex] != e || this._currentInstanceCount <= 0 || (this.removeGeometry(e, t), this._handles[e.__instanceIndex] = null, e.__instanceIndex = -1, this._currentInstanceCount > 0 && (this._currentInstanceCount -= 1), this._currentInstanceCount <= 0 && (this._batchedMesh.visible = !1), this.markNeedsUpdate()));
  }
  updateInstance(e, t) {
    this._batchedMesh.setMatrixAt(t, e), this.markNeedsUpdate();
  }
  updateGeometry(e, t) {
    return this.validateGeometry(e) ? (this.mustGrow() && this.grow(e), Qt && console.debug("[Instancing] UPDATE GEOMETRY at " + t, this._batchedMesh._geometryCount, e.name, Vo(e), e.attributes.position.count, e.index ? e.index.count : 0), this._batchedMesh.setGeometryAt(t, e), this._geometryIds.set(e, t), this.markNeedsUpdate(), !0) : !1;
  }
  onBeforeRender = () => {
    this._batchedMesh.layers.enableAll(), this._needUpdateBounds && this._batchedMesh[wl] === !0 && (Qt === "verbose" && console.log("Update instancing bounds", this.name, this._batchedMesh.matrixWorldNeedsUpdate), this.updateBounds());
  };
  onAfterRender = () => {
    this._batchedMesh.layers.disableAll();
  };
  validateGeometry(e) {
    const t = this.geometry;
    for (const i in t.attributes)
      if (i !== "batchId" && !e.hasAttribute(i))
        return L() && console.warn(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`), !1;
    return !0;
  }
  markNeedsUpdate() {
    Qt === "verbose" && console.warn("Marking instanced mesh dirty", this.name), this._needUpdateBounds = !0;
  }
  /**
   * @param geo The geometry to add (if none is provided it means the geometry is already added and just updated)
   */
  mustGrow(e) {
    if (this.count >= this._maxInstanceCount) return !0;
    if (!e || !e.attributes) return !1;
    const t = Vo(e), i = t.vertexCount, n = t.indexCount;
    return this._currentVertexCount + i > this._maxVertexCount || this._currentIndexCount + n > this._maxIndexCount;
  }
  grow(e) {
    const i = Math.ceil(this._maxInstanceCount * 2), n = this.tryEstimateVertexCountSize(i, [e]), o = Math.max(this._maxVertexCount, n.vertexCount), r = Math.max(this._maxIndexCount, n.indexCount, Math.ceil(this._maxVertexCount * 2));
    if (Qt) {
      const c = Vo(e);
      console.warn(`[Instancing] Growing Buffer
Mesh: "${this.name}${e.name?.length ? "/" + e.name : ""}"
${c.vertexCount} vertices, ${c.indexCount} indices
Max count ${this._maxInstanceCount} → ${i}
Max vertex count ${this._maxVertexCount} -> ${o}
Max index count ${this._maxIndexCount} -> ${r}`), this._debugMaterial = x_();
    } else L() && console.debug(`[Instancing] Growing Buffer
Mesh: "${this.name}${e.name?.length ? "/" + e.name : ""}"
Max count ${this._maxInstanceCount} → ${i}
Max vertex count ${this._maxVertexCount} -> ${o}
Max index count ${this._maxIndexCount} -> ${r}`);
    this._maxVertexCount = o, this._maxIndexCount = r;
    const a = new Xg(i, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material);
    a.layers = this._batchedMesh.layers, a.castShadow = this._batchedMesh.castShadow, a.receiveShadow = this._batchedMesh.receiveShadow, a.visible = this._batchedMesh.visible, a[wl] = this._batchedMesh[wl], a.matrixAutoUpdate = this._batchedMesh.matrixAutoUpdate, a.matrixWorldNeedsUpdate = this._batchedMesh.matrixWorldNeedsUpdate, a.matrixAutoUpdate = this._batchedMesh.matrixAutoUpdate, a.matrixWorld.copy(this._batchedMesh.matrixWorld), a.matrix.copy(this._batchedMesh.matrix), this._batchedMesh.dispose(), this._batchedMesh.removeFromParent(), this._geometryIds.clear(), this._batchedMesh = a, this._maxInstanceCount = i;
    const l = [...this._handles];
    this._handles = [];
    for (const c of l)
      c && c.__instanceIndex >= 0 && (this.addGeometry(c), this._handles[c.__instanceIndex] = c);
    this._context.scene.add(a);
  }
  tryEstimateVertexCountSize(e, t, i = 1) {
    const n = /* @__PURE__ */ new Map();
    for (const d of this._handles)
      if (d && d.__instanceIndex >= 0 && d.object.geometry)
        if (n.has(d.object.geometry)) {
          const f = n.get(d.object.geometry);
          f.count += 1;
        } else {
          const p = { count: 1, ...Vo(d.object.geometry) };
          n.set(d.object.geometry, p);
        }
    let o = 0, r = 0;
    for (const [d, f] of n)
      o += f.vertexCount * f.count, r += f.indexCount * f.count;
    let l = Math.ceil(o / Math.max(1, this._currentInstanceCount)) * e, h = Math.ceil(r / Math.max(1, this._currentInstanceCount)) * e * 2;
    if (t)
      for (const d of t) {
        const f = Vo(d);
        f != null && (l += f.vertexCount * i, h += f.indexCount * i);
      }
    return { vertexCount: l, indexCount: h };
  }
  addGeometry(e) {
    const i = e.object.geometry;
    if (!i)
      return;
    let n = this._geometryIds.get(i);
    n == null ? (Qt && console.debug(`[Instancing] > ADD NEW GEOMETRY "${e.name} (${i.name}; ${i.uuid})"
${this._currentInstanceCount} instances, ${e.maxVertexCount} max vertices, ${e.maxIndexCount} max indices`), n = this._batchedMesh.addGeometry(i, e.maxVertexCount, e.maxIndexCount), this._geometryIds.set(i, n)) : Qt === "verbose" && console.log(`[Instancing] > ADD INSTANCE "${e.name}"
GEOMETRY_ID=${n}
${this._currentInstanceCount} instances`), this._currentVertexCount += e.maxVertexCount, this._currentIndexCount += e.maxIndexCount;
    const o = this._batchedMesh.addInstance(n);
    e.__geometryIndex = n, e.__instanceIndex = o, e.__reservedVertexRange = e.maxVertexCount, e.__reservedIndexRange = e.maxIndexCount, this._batchedMesh.setMatrixAt(o, e.object.matrixWorld), Qt && console.debug(`[Instancing] > ADDED INSTANCE "${e.name}"
GEOMETRY_ID=${n}
${this._currentInstanceCount} instances
Index: ${e.__instanceIndex}`);
  }
  removeGeometry(e, t) {
    if (e.__instanceIndex < 0) {
      console.warn("Cannot remove geometry, instance index is invalid", e.name);
      return;
    }
    Qt && console.debug(`[Instancing] < REMOVE INSTANCE "${e.name}" at [${e.__instanceIndex}]
GEOMETRY_ID=${e.__geometryIndex}
${this._currentInstanceCount} instances
Index: ${e.__instanceIndex}`), this._batchedMesh.deleteInstance(e.__instanceIndex);
  }
}
function Vo(s) {
  if (!s)
    return L() && console.error("Cannot get mesh information from null geometry"), { vertexCount: 0, indexCount: 0 };
  let e = s.attributes?.position?.count || 0, t = s.index ? s.index.count : 0;
  const i = We.getMeshLODExtension(s);
  if (i) {
    const n = i.lods[0];
    let o = n.vertexCount, r = n.indexCount;
    const a = Math.min(200, Math.ceil(o * 0.05));
    o += a, r += 20, e = Math.max(e, o), t = Math.max(t, r);
  }
  return e = Math.ceil(e), t = Math.ceil(t), { vertexCount: e, indexCount: t };
}
function x_() {
  const s = new ct({ color: new se(Math.random(), Math.random(), Math.random()) });
  return s.emissive = s.color, s.emissiveIntensity = 0.3, w("wireframe") && (s.wireframe = !0), s;
}
const Er = w("debuglightmaps");
class zp {
  get lightmap() {
    return this.lightmapTexture;
  }
  set lightmap(e) {
    e !== this.lightmapTexture && (this.lightmapTexture = e, this.applyLightmap(), this.lightmapTexture && We.assignTextureLOD(this.lightmapTexture, 0).then((t) => {
      t?.isTexture && (this.lightmapTexture = t);
    }));
  }
  lightmapIndex = -1;
  lightmapScaleOffset = new de(1, 1, 0, 0);
  context;
  gameObject;
  lightmapTexture = null;
  lightmapScaleOffsetUniform = { value: new de(1, 1, 0, 0) };
  lightmapUniform = { value: null };
  constructor(e, t) {
    this.gameObject = e, this.context = t;
  }
  init(e, t, i) {
    console.assert(this.gameObject !== void 0 && this.gameObject !== null, "Missing gameobject", this), this.lightmapIndex = e, !(this.lightmapIndex < 0) && (this.lightmapScaleOffset = t, this.lightmapTexture = i, We.assignTextureLOD(i, 0).then((n) => {
      n?.isTexture && (this.lightmapTexture = n);
    }), Er == "show" ? (console.log("Lightmap:", this.gameObject.name, e, `
ScaleOffset:`, t, `
Texture:`, i), this.setLightmapDebugMaterial()) : Er && console.log("Use debuglightmaps=show to render lightmaps only in the scene."), this.applyLightmap());
  }
  updateLightmapUniforms(e) {
    const t = e.uniforms;
    t && t.lightmap && (this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset, t.lightmapScaleOffset = this.lightmapScaleOffsetUniform);
  }
  /**
   * Apply the lightmap to the object. This will clone the material and set the lightmap texture and scale/offset
   */
  applyLightmap() {
    if (this.gameObject.type === "Object3D") {
      Er && console.warn("Can not add lightmap. Is this object missing a renderer?", this.gameObject.name);
      return;
    }
    if (this.gameObject.type === "Group") {
      this.gameObject["Needle:Multimaterial-LightmapWarning"] === void 0 && (this.gameObject["Needle:Multimaterial-LightmapWarning"] = !0, console.warn("Lightmap on multimaterial object is not supported yet... please open a feature request on https://github.com/needle-tools/needle-engine-support if your project requires it"));
      return;
    }
    console.assert(this.gameObject.type === "Mesh", "Lightmap only works on meshes", this);
    const e = this.gameObject;
    if (e.geometry.getAttribute("uv1") || e.geometry.setAttribute("uv1", e.geometry.getAttribute("uv")), Array.isArray(this.gameObject.material)) {
      const t = this.gameObject.material;
      for (let i = 0; i < t.length; i++)
        t[i] = this.ensureLightmapMaterial(t[i]);
    } else
      this.gameObject.material = this.ensureLightmapMaterial(this.gameObject.material);
    if (this.lightmapIndex >= 0 && this.lightmapTexture) {
      this.lightmapTexture.channel = 1;
      const t = this.gameObject.material;
      if (Array.isArray(t))
        for (const i of t)
          this.assignLightmapTexture(i);
      else t && this.assignLightmapTexture(t);
    }
  }
  ensureLightmapMaterial(e) {
    return e.userData || (e.userData = {}), e["NEEDLE:lightmap-material-version"] != e.version && e["NEEDLE:lightmap-material-version"] == null && (Er && console.warn("Cloning material for lightmap " + e.name), e = e.clone(), e.onBeforeCompile = this.onBeforeCompile), e;
  }
  assignLightmapTexture(e) {
    !e || e instanceof op && e.transmission > 0 || !(e.lightMap !== this.lightmapTexture || e["NEEDLE:lightmap-material-version"] !== e.version) || (Er && console.log("Assigning lightmap", e.name, e.version), e.lightMap = this.lightmapTexture, e["NEEDLE:lightmap-material-version"] = e.version);
  }
  onBeforeCompile = (e, t) => {
    Er && console.log(`Lightmaps, before compile
`, e), this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset, this.lightmapUniform.value = this.lightmapTexture, e.uniforms.lightmapScaleOffset = this.lightmapScaleOffsetUniform;
  };
  setLightmapDebugMaterial() {
    this.gameObject.material = new Ln({
      vertexShader: `
                varying vec2 vUv1;
                void main()
                {
                    vUv1 = uv1;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
                `,
      fragmentShader: `
                uniform sampler2D lightMap;
                uniform float lightMapIntensity;
                uniform vec4 lightmapScaleOffset;
                varying vec2 vUv1;

                // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
                vec4 conv_sRGBToLinear( in vec4 value ) {
                    return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
                }

                void main() {
                    vec2 lUv = vUv1.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
                    
                    vec4 lightMapTexel = texture2D( lightMap, lUv);
                    gl_FragColor = lightMapTexel;
                    gl_FragColor.a = 1.;
                }
                `,
      defines: { USE_LIGHTMAP: "" }
    });
  }
}
var vM = Object.defineProperty, Ts = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && vM(e, t, n), n;
};
const Pl = w("debugrenderer"), S_ = w("debugskinnedmesh"), C_ = w("noinstancing"), wM = w("wireframe");
class xM {
  path = null;
  asset = null;
  default;
}
class SM {
  _renderer;
  _targets = [];
  _indexMapMaxIndex;
  _indexMap;
  _changed = !1;
  get changed() {
    return this._changed;
  }
  set changed(e) {
    e === !0 && Pl && console.warn("SharedMaterials have changed: " + this._renderer.name, this), this._changed = e;
  }
  is(e) {
    return this._renderer === e;
  }
  constructor(e, t) {
    this._renderer = e;
    const i = this.setMaterial.bind(this), n = this.getMaterial.bind(this), o = e.gameObject;
    if (this._targets = [], o)
      switch (o.type) {
        case "Group":
          this._targets = [...o.children];
          break;
        case "SkinnedMesh":
        case "Mesh":
          this._targets.push(o);
          break;
      }
    let r = !1, a, l = 0;
    for (let c = 0; c < this._targets.length; c++) {
      const h = this._targets[c];
      if (!h) continue;
      const d = h.material;
      if (d) {
        d.shadowSide = d.side;
        for (let f = 0; f < t.length; f++) {
          const p = t[f];
          if (!p) {
            r = !0;
            continue;
          }
          if (d.name === p.name) {
            a === void 0 && (a = /* @__PURE__ */ new Map()), a.set(f, c), l = Math.max(l, f);
            break;
          }
        }
      }
    }
    if (r) {
      this._indexMapMaxIndex = l, this._indexMap = a;
      const c = `Renderer ${e.name} was initialized with missing materials - this may lead to unexpected behaviour when trying to access sharedMaterials by index.`;
      console.warn(c), rn() && ge("Found renderer with missing materials: please check the console for details.");
    }
    return new Proxy(this, {
      get(c, h) {
        if (typeof h == "string") {
          const d = parseInt(h);
          if (!isNaN(d))
            return n(d);
        }
        return c[h];
      },
      set(c, h, d) {
        return typeof h == "string" && i(d, Number.parseInt(h)), Reflect.set(c, h, d) ? (d instanceof _e && (c.changed = !0), !0) : !1;
      }
    });
  }
  get length() {
    return this._indexMapMaxIndex !== void 0 ? this._indexMapMaxIndex + 1 : this._targets.length;
  }
  // iterator to support: for(const mat of sharedMaterials)
  *[Symbol.iterator]() {
    for (let e = 0; e < this.length; e++)
      yield this.getMaterial(e);
  }
  resolveIndex(e) {
    const t = this._indexMap;
    return t && t.has(e) ? t.get(e) : e;
  }
  setMaterial(e, t) {
    if (t = this.resolveIndex(t), t < 0 || t >= this._targets.length) return;
    const i = this._targets[t];
    !i || i.material === void 0 || (i.material = e, this.changed = !0);
  }
  getMaterial(e) {
    if (e = this.resolveIndex(e), e < 0) return null;
    const t = this._targets;
    if (e >= t.length) return null;
    const i = t[e];
    return i ? i.material : null;
  }
}
const $n = class zh extends T {
  /** Enable or disable instancing for an object. This will create a Renderer component if it does not exist yet.
   * @returns the Renderer component that was created or already existed on the object
   */
  static setInstanced(e, t) {
    const i = Gd(e, zh);
    return i.setInstancingEnabled(t), i;
  }
  /** Check if an object is currently rendered using instancing
   * @returns true if the object is rendered using instancing
   */
  static isInstanced(e) {
    const t = ka(e, zh);
    return t ? t.isInstancingActive : sn.isUsingInstancing(e);
  }
  /** Set the rendering state only of an object (makes it visible or invisible) without affecting component state or child hierarchy visibility! You can also just enable/disable the Renderer component on that object for the same effect!
   * 
   * If you want to activate or deactivate a complete object you can use obj.visible as usual (it acts the same as setActive in Unity) */
  static setVisible(e, t) {
    hs(e, t);
  }
  receiveShadows = !1;
  shadowCastingMode = 0;
  lightmapIndex = -1;
  lightmapScaleOffset = new de(1, 1, 0, 0);
  enableInstancing = void 0;
  renderOrder = void 0;
  allowOcclusionWhenDynamic = !0;
  probeAnchor;
  reflectionProbeUsage = 0;
  // custom shader
  // get materialProperties(): Array<MaterialProperties> | undefined {
  //     return this._materialProperties;
  // }
  // set materialProperties(value: Array<MaterialProperties> | undefined) {
  //     this._materialProperties = value;
  // }
  // private customShaderHandler: RendererCustomShader | undefined = undefined;
  // private _materialProperties: Array<MaterialProperties> | undefined = undefined;
  _lightmaps;
  /** Get the mesh Object3D for this renderer  
   * Warn: if this is a multimaterial object it will return the first mesh only 
   * @returns a mesh object3D.
   * */
  get sharedMesh() {
    if (this.gameObject.type === "Mesh")
      return this.gameObject;
    if (this.gameObject.type === "SkinnesMesh")
      return this.gameObject;
    if (this.gameObject.type === "Group")
      return this.gameObject.children[0];
  }
  _sharedMeshes = [];
  /** Get all the mesh Object3D for this renderer 
   * @returns an array of mesh object3D.
   */
  get sharedMeshes() {
    if (this.destroyed || !this.gameObject) return this._sharedMeshes;
    if (this._sharedMeshes.length = 0, this.gameObject.type === "Group")
      for (const e of this.gameObject.children)
        (e.type === "Mesh" || e.type === "SkinnedMesh") && this._sharedMeshes.push(e);
    else (this.gameObject.type === "Mesh" || this.gameObject.type === "SkinnedMesh") && this._sharedMeshes.push(this.gameObject);
    return this._sharedMeshes;
  }
  get sharedMaterial() {
    return this.sharedMaterials[0];
  }
  set sharedMaterial(e) {
    this.sharedMaterials[0] !== e && (this.sharedMaterials[0] = e, this.applyLightmapping());
  }
  /**@deprecated please use sharedMaterial */
  get material() {
    return this.sharedMaterials[0];
  }
  /**@deprecated please use sharedMaterial */
  set material(e) {
    this.sharedMaterial = e;
  }
  _sharedMaterials;
  _originalMaterials;
  _probeAnchorLastFrame;
  // this is just available during deserialization
  set sharedMaterials(e) {
    if (!this._originalMaterials)
      this._originalMaterials = e;
    else if (e) {
      let t = !1;
      for (let i = 0; i < this._sharedMaterials.length; i++) {
        const n = i < e.length ? e[i] : null;
        n && n instanceof _e ? this.sharedMaterials[i] = n : t || (t = !0, console.warn("Can not assign null as material: " + this.name, n));
      }
    }
  }
  //@ts-ignore
  get sharedMaterials() {
    return (!this._sharedMaterials || !this._sharedMaterials.is(this)) && (this._originalMaterials || (this._originalMaterials = []), this._sharedMaterials = new SM(this, this._originalMaterials)), this._sharedMaterials;
  }
  static get shouldSuppressInstancing() {
    return C_;
  }
  _lightmapTextureOverride = void 0;
  get lightmap() {
    return this._lightmaps?.length ? this._lightmaps[0].lightmap : null;
  }
  /** set undefined to return to default lightmap */
  set lightmap(e) {
    if (this._lightmapTextureOverride = e, e === void 0 && (e = this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex)), this._lightmaps?.length)
      for (const t of this._lightmaps)
        t.lightmap = e;
  }
  get hasLightmap() {
    const e = this.lightmap;
    return e != null;
  }
  allowProgressiveLoading = !0;
  _firstFrame = -1;
  registering() {
    this.enabled || this.setVisibility(!1);
  }
  awake() {
    if (this._firstFrame = this.context.time.frame, Pl && console.log("Renderer ", this.name, this), this.clearInstancingState(), this.probeAnchor && Pl && this.probeAnchor.add(new mi(0.2)), this._reflectionProbe = null, this.isMultiMaterialObject(this.gameObject)) {
      for (const e of this.gameObject.children)
        this.context.addBeforeRenderListener(e, this.onBeforeRenderThree), e.layers.mask = this.gameObject.layers.mask;
      if (this.renderOrder !== void 0) {
        let e = 0;
        for (let t = 0; t < this.gameObject.children.length; t++) {
          const i = this.gameObject.children[t];
          if (!(!this.isMeshOrSkinnedMesh(i) || S.getComponent(i, zh))) {
            if (this.renderOrder.length <= e) {
              console.warn("Incorrect renderOrder element count", this, this.renderOrder.length + " but expected " + this.gameObject.children.length, "Index: " + e, "ChildElement:", i);
              continue;
            }
            i.renderOrder = this.renderOrder[e], e += 1;
          }
        }
      }
    } else this.isMeshOrSkinnedMesh(this.gameObject) ? (this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree), this.renderOrder !== void 0 && this.renderOrder.length > 0 && (this.gameObject.renderOrder = this.renderOrder[0])) : this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
    if (this.applyLightmapping(), wM)
      for (let e = 0; e < this.sharedMaterials.length; e++) {
        const t = this.sharedMaterials[e];
        t && (t.wireframe = !0);
      }
  }
  applyLightmapping() {
    if (this.lightmapIndex >= 0) {
      const e = this.gameObject.type, t = this._lightmapTextureOverride !== void 0 ? this._lightmapTextureOverride : this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex);
      if (t) {
        if (this._lightmaps || (this._lightmaps = []), e === "Mesh") {
          const i = this.gameObject.material;
          if (i?.isMeshBasicMaterial)
            i && console.warn("Lightmapping is not supported on MeshBasicMaterial", i.name);
          else {
            if (this._lightmaps.length <= 0) {
              const o = new zp(this.gameObject, this.context);
              this._lightmaps.push(o);
            }
            this._lightmaps[0].init(this.lightmapIndex, this.lightmapScaleOffset, t);
          }
        } else if (this.isMultiMaterialObject(this.gameObject) && this.sharedMaterials.length > 0)
          for (let i = 0; i < this.gameObject.children.length; i++) {
            const n = this.gameObject.children[i];
            if (!n.material?.isMeshBasicMaterial) {
              let o;
              i >= this._lightmaps.length ? (o = new zp(n, this.context), this._lightmaps.push(o)) : o = this._lightmaps[i], o.init(this.lightmapIndex, this.lightmapScaleOffset, t);
            }
          }
      } else
        Pl && console.warn("Lightmap not found", this.sourceId, this.lightmapIndex);
    }
  }
  _isInstancingEnabled = !1;
  _handles = void 0;
  /** 
   * @returns true if this renderer has instanced objects
   */
  get isInstancingActive() {
    return this._handles != null && this._handles.length > 0 && this._isInstancingEnabled;
  }
  /** @returns the instancing handles */
  get instances() {
    if (!this._handles || this._handles.length <= 0)
      return null;
    if (this._handlesTempArray.length = 0, this._handles)
      for (const e of this._handles)
        this._handlesTempArray.push(e);
    return this._handlesTempArray;
  }
  _handlesTempArray = [];
  /** Enable or disable instancing for this renderer.
   * @param enabled true to enable instancing, false to disable it
   */
  setInstancingEnabled(e) {
    if (this._isInstancingEnabled === e) return e && (this._handles === void 0 || this._handles != null && this._handles.length > 0);
    if (this._isInstancingEnabled = e, e) {
      if (this.enableInstancing === void 0 && (this.enableInstancing = !0), this._handles === void 0) {
        if (this._handles = Pa.instance.setup(this, this.gameObject, this.context, null, { rend: this, foundMeshes: 0, useMatrixWorldAutoUpdate: this.useInstanceMatrixWorldAutoUpdate() }), this._handles)
          return S.markAsInstancedRendered(this.gameObject, !0), !0;
      } else if (this._handles !== null) {
        for (const t of this._handles)
          t.updateInstanceMatrix(!0), t.add();
        return S.markAsInstancedRendered(this.gameObject, !0), !0;
      }
    } else {
      if (this._handles)
        for (const t of this._handles)
          t.remove(this.destroyed);
      return !0;
    }
    return !1;
  }
  clearInstancingState() {
    this._isInstancingEnabled = !1, this._handles = void 0;
  }
  /** Return true to wrap matrix update events for instanced rendering to update instance matrices automatically when matrixWorld changes
   * This is a separate method to be overrideable from user code
   */
  useInstanceMatrixWorldAutoUpdate() {
    return !0;
  }
  start() {
    if (this.enableInstancing && !C_ && (this.setInstancingEnabled(!0), sn.markDirty(this.gameObject)), this.gameObject.frustumCulled = this.allowOcclusionWhenDynamic, this.isMultiMaterialObject(this.gameObject))
      for (let e = 0; e < this.gameObject.children.length; e++) {
        const t = this.gameObject.children[e];
        t.frustumCulled = this.allowOcclusionWhenDynamic;
      }
  }
  onEnable() {
    this.sharedMeshes, this.setVisibility(!0), this._isInstancingEnabled || this.enableInstancing == !0 || Array.isArray(this.enableInstancing) && this.enableInstancing.some((t) => t) ? this.__internalDidAwakeAndStart && this.setInstancingEnabled(!0) : this.enabled && this.applyStencil(), this.updateReflectionProbe();
  }
  onDisable() {
    this.setVisibility(!1), this._handles && this._handles.length > 0 && this.setInstancingEnabled(!1);
  }
  onDestroy() {
    if (this._handles = null, this.isMultiMaterialObject(this.gameObject))
      for (const e of this.gameObject.children)
        this.context.removeBeforeRenderListener(e, this.onBeforeRenderThree);
    else
      this.context.removeBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
  }
  onBeforeRender() {
    if (this.gameObject) {
      if (this._probeAnchorLastFrame !== this.probeAnchor && (this._reflectionProbe?.onUnset(this), this.updateReflectionProbe()), Pl == this.name && this.gameObject instanceof H) {
        this.gameObject.geometry.computeBoundingSphere();
        const e = G(this.gameObject.geometry.boundingSphere.center).applyMatrix4(this.gameObject.matrixWorld);
        F.DrawWireSphere(e, this.gameObject.geometry.boundingSphere.radius, 56831);
      }
      if (this.isMultiMaterialObject(this.gameObject) && this.gameObject.children?.length > 0)
        for (const e of this.gameObject.children)
          this.applySettings(e);
      else
        this.applySettings(this.gameObject);
      if (this.sharedMaterials.changed && (this.sharedMaterials.changed = !1, this.applyLightmapping()), this._handles?.length && this.gameObject[oc] === !0) {
        this.gameObject[oc] = !1;
        for (let t = this._handles.length - 1; t >= 0; t--)
          this._handles[t].updateInstanceMatrix();
        this.gameObject.matrixWorldNeedsUpdate = !1;
      }
      if (this._handles && this._handles.length <= 0 && S.markAsInstancedRendered(this.gameObject, !1), this._isInstancingEnabled && this._handles)
        for (let e = 0; e < this._handles.length; e++) {
          const t = this._handles[e];
          hs(t.object, !1);
        }
      this.reflectionProbeUsage !== 0 && this._reflectionProbe && this._reflectionProbe.onSet(this);
      for (const e of this._sharedMaterials)
        e && "envMap" in e && "envMapIntensity" in e && !yd.isUsingReflectionProbe(e) && (e.envMap = this.context.scene.environment);
    }
  }
  onBeforeRenderThree = (e, t, i, n, o, r) => {
    if (o.envMapIntensity !== void 0) {
      const a = this.hasLightmap ? Math.PI : 1, l = this.context.mainCameraComponent?.environmentIntensity ?? 1;
      o.envMapIntensity = Math.max(0, l * this.context.sceneLighting.environmentIntensity / a);
    }
    if (this._lightmaps)
      for (const a of this._lightmaps)
        a.updateLightmapUniforms(o), a.applyLightmap();
  };
  onAfterRender() {
    if (this._isInstancingEnabled && this._handles)
      for (let e = 0; e < this._handles.length; e++) {
        const t = this._handles[e];
        hs(t.object, !0);
      }
    this.reflectionProbeUsage !== 0 && this._reflectionProbe && this._reflectionProbe.onUnset(this), this.static && this.gameObject.matrixAutoUpdate && (this.gameObject.matrixAutoUpdate = !1);
  }
  /** Applies stencil settings for this renderer's objects (if stencil settings are available) */
  applyStencil() {
    Ys.applyStencil(this);
  }
  /** Apply the settings of this renderer to the given object
   * Settings include shadow casting and receiving (e.g. this.receiveShadows, this.shadowCastingMode)
   */
  applySettings(e) {
    e.receiveShadow = this.receiveShadows, this.shadowCastingMode == 1 ? e.castShadow = !0 : e.castShadow = !1;
  }
  _reflectionProbe = null;
  updateReflectionProbe() {
    this._reflectionProbe = null, this.reflectionProbeUsage !== 0 && (this.startCoroutine(this._updateReflectionProbe(), xe.LateUpdate), this._probeAnchorLastFrame = this.probeAnchor);
  }
  *_updateReflectionProbe() {
    const e = this.probeAnchor || this.gameObject, t = !!this.probeAnchor;
    this._reflectionProbe = yd.get(e, this.context, t, this.probeAnchor);
  }
  setVisibility(e) {
    if (!this.isMultiMaterialObject(this.gameObject))
      hs(this.gameObject, e);
    else
      for (const t of this.gameObject.children)
        this.isMeshOrSkinnedMesh(t) && hs(t, e);
  }
  isMultiMaterialObject(e) {
    return e.type === "Group";
  }
  isMeshOrSkinnedMesh(e) {
    return e.type === "Mesh" || e.type === "SkinnedMesh";
  }
};
Ts([
  u()
], $n.prototype, "receiveShadows");
Ts([
  u()
], $n.prototype, "shadowCastingMode");
Ts([
  u()
], $n.prototype, "lightmapIndex");
Ts([
  u(de)
], $n.prototype, "lightmapScaleOffset");
Ts([
  u()
], $n.prototype, "enableInstancing");
Ts([
  u()
], $n.prototype, "renderOrder");
Ts([
  u()
], $n.prototype, "allowOcclusionWhenDynamic");
Ts([
  u(M)
], $n.prototype, "probeAnchor");
Ts([
  u()
], $n.prototype, "reflectionProbeUsage");
let Hi = $n;
class lu extends Hi {
}
class gv extends lu {
  _needUpdateBoundingSphere = !1;
  // private _lastWorldPosition = new Vector3();
  awake() {
    super.awake(), S_ && console.log('SkinnedMeshRenderer for "' + this.name + '"', this), this.allowOcclusionWhenDynamic = !1;
    for (const e of this.sharedMeshes)
      e.parent?.updateWorldMatrix(!1, !0), this.markBoundsDirty();
  }
  onAfterRender() {
    if (super.onAfterRender(), this._needUpdateBoundingSphere) {
      for (const e of this.sharedMeshes)
        if (e instanceof ys) {
          this._needUpdateBoundingSphere = !1;
          try {
            const t = e.geometry, i = yb(e);
            i && (e.geometry = i), e.computeBoundingSphere(), e.geometry = t;
          } catch (t) {
            console.error(`Error updating bounding sphere for ${e.name}`, t);
          }
        }
    }
    if (S_) {
      for (const e of this.sharedMeshes)
        if (e instanceof ys && e.boundingSphere) {
          const t = G(e.boundingSphere.center).applyMatrix4(e.matrixWorld);
          F.DrawWireSphere(t, e.boundingSphere.radius, "red");
        }
    }
  }
  markBoundsDirty() {
    this._needUpdateBoundingSphere = !0;
  }
}
var CM = Object.defineProperty, yv = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && CM(e, t, n), n;
};
const ch = w("debuggltfexport");
class _v extends Ct {
  sceneRoot;
}
const rg = class $r extends T {
  binary = !0;
  objects = [];
  ext;
  async exportNow(e, t) {
    ch && console.log("Exporting objects as glTF", this.objects), e || (e = "scene"), (!this.objects || this.objects.length <= 0) && (this.objects = [this.context.scene]);
    const i = {
      binary: this.binary,
      pivot: $r.calculateCenter(this.objects),
      ...t
    }, n = await this.export(this.objects, i).catch((o) => (console.error(o), !1));
    return n === !1 ? !1 : (this.binary ? e.endsWith(".glb") || (e += ".glb") : e.endsWith(".gltf") || (e += ".gltf"), this.binary ? $r.saveArrayBuffer(n, e) : $r.saveJson(n, e), !0);
  }
  async export(e, t) {
    if (!e || e.length <= 0) {
      console.warn("No objects set to export");
      return;
    }
    const i = new wb();
    i.register((c) => new pv(c)), i.register((c) => new lv(c)), fv(i, this.context), $r.filterTopmostParent(e);
    const n = {
      trs: !1,
      onlyVisible: !0,
      truncateDrawRange: !1,
      binary: !0,
      maxTextureSize: 1 / 0,
      // To prevent NaN value,
      embedImages: !0,
      includeCustomExtensions: !0,
      animations: t?.animations || $r.collectAnimations(e),
      ...t
    }, o = new Array(), r = new M();
    t?.pivot && r.position.sub(t.pivot), ch && console.log("EXPORT", e), e.forEach((c) => {
      c && jp(c) && (r.children.push(c), c.matrixAutoUpdate = !1, c.matrix.copy(c.matrixWorld), S.getComponentsInChildren(c, Hi).forEach((h) => {
        S.isActiveInHierarchy(h.gameObject) && h.setInstancingEnabled(!1);
      }), c.traverse((h) => {
        if (!jp(h)) {
          const d = h.parent;
          h.removeFromParent(), o.push(() => {
            d && d.add(h);
          });
        }
      }));
    });
    const a = new b0(r);
    return t?.needleComponents && (this.ext = new cv()), this.ext && (this.ext.registerExport(i), this.ext.context = a), new Promise((c, h) => {
      ch && console.log("Starting glTF export.");
      try {
        i?.parse(
          r,
          // called when the gltf has been generated
          (d) => {
            l(), c(d);
          },
          // called when there is an error in the generation
          (d) => {
            l(), h(d);
          },
          n
        );
      } catch (d) {
        console.error(d), h(d);
      } finally {
        o.forEach((d) => d()), ch && console.log("Finished glTF export.");
      }
    });
    function l() {
      e.forEach((c) => {
        c && (c.matrixAutoUpdate = !0, S.getComponentsInChildren(c, Hi).forEach((h) => {
          S.isActiveInHierarchy(h.gameObject) && h.setInstancingEnabled(!1);
        }));
      });
    }
  }
  static saveArrayBuffer(e, t) {
    this.save(new Blob([e], { type: "application/octet-stream" }), t);
  }
  static saveJson(e, t) {
    this.save("data: text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(e)), t);
  }
  static save(e, t) {
    const i = document.createElement("a");
    i.style.display = "none", document.body.appendChild(i), typeof e == "string" ? i.href = e : i.href = URL.createObjectURL(e), i.download = t, i.click(), i.remove();
  }
  static collectAnimations(e, t) {
    t = t || [];
    for (const i of e)
      i && i.traverseVisible((n) => {
        n.animations && n.animations.length > 0 && t.push(...n.animations);
      });
    return t;
  }
  static calculateCenter(e, t) {
    const i = t || new b();
    return i.set(0, 0, 0), e.forEach((n) => {
      i.add(Z(n));
    }), i.divideScalar(e.length), i;
  }
  static filterTopmostParent(e) {
    if (!(e.length <= 0))
      for (let t = 0; t < e.length; t++) {
        let i = e[t];
        if (!i) {
          e.splice(t, 1), t--;
          continue;
        }
        for (; i.parent; ) {
          if (e.includes(i.parent)) {
            e.splice(t, 1), t--;
            break;
          }
          i = i.parent;
        }
      }
  }
};
yv([
  u()
], rg.prototype, "binary");
yv([
  u(M)
], rg.prototype, "objects");
let bv = rg;
typeof globalThis !== void 0 && !("OffscreenCanvas" in globalThis) && (globalThis.OffscreenCanvas = class {
  canvas;
  constructor(e, t) {
    return this.canvas = document.createElement("canvas"), this.canvas.width = e, this.canvas.height = t, this.canvas.convertToBlob = (i, n) => new Promise((o) => {
      this.canvas.toBlob(o, i, n);
    }), this.canvas;
  }
});
const PM = w("debugprogress");
function OM(s) {
  s = s || /* @__PURE__ */ new Date();
  const e = s.getMonth() + 1, t = s.getDate(), i = s.getHours(), n = s.getMinutes(), o = s.getSeconds(), r = (e < 10 ? "0" : "") + e, a = (t < 10 ? "0" : "") + t, l = (i < 10 ? "0" : "") + i, c = (n < 10 ? "0" : "") + n, h = (o < 10 ? "0" : "") + o;
  return s.getFullYear() + r + a + "-" + l + c + h;
}
class le {
  /** Start a new progress reporting scope. Make sure to close it with Progress.end.
   * @param scope The scope to start progress reporting for.
   * @param options Parent scope, onProgress callback and logging. If only a string is provided, it's used as parentScope.
   * @example
   * // Manual usage:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting object 1", currentStep: 1, totalSteps: 3 });
   * Progress.report("export-usdz", { message: "Exporting object 2", currentStep: 2, totalSteps: 3 });
   * Progress.report("export-usdz", { message: "Exporting object 3", currentStep: 3, totalSteps: 3 });
   * 
   * // Auto step usage:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting objects", autoStep: true, totalSteps: 3 });
   * Progress.report("export-usdz", "Exporting object 1");
   * Progress.report("export-usdz", "Exporting object 2");
   * Progress.report("export-usdz", "Exporting object 3");
   * Progress.end("export-usdz");
   * 
   * // Auto step with weights:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting objects", autoStep: true, totalSteps: 10 });
   * Progress.report("export-usdz", { message: "Exporting object 1", autoStep: 8 }); // will advance to 80% progress
   * Progress.report("export-usdz", "Exporting object 2"); // 90%
   * Progress.report("export-usdz", "Exporting object 3"); // 100%
   * 
   * // Child scopes:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Overall export", autoStep: true, totalSteps: 2 });
   * Progress.start("export-usdz-objects", "export-usdz");
   * Progress.report("export-usdz-objects", { message: "Exporting objects", autoStep: true, totalSteps: 3 });
   * Progress.report("export-usdz-objects", "Exporting object 1");
   * Progress.report("export-usdz-objects", "Exporting object 2");
   * Progress.report("export-usdz-objects", "Exporting object 3");
   * Progress.end("export-usdz-objects");
   * Progress.report("export-usdz", "Exporting materials");
   * Progress.end("export-usdz");
   * 
   * // Enable console logging:
   * Progress.start("export-usdz", { logTimings: true });
   */
  static start(e, t) {
    typeof t == "string" && (t = { parentScope: t });
    const i = new kM(e, t);
    Ol.set(e, i);
  }
  /** Report progress for a formerly started scope.
   * @param scope The scope to report progress for.
   * @param options Options for the progress report. If a string is passed, it will be used as the message.
   * @example
   * // auto step and show a message
   * Progress.report("export-usdz", "Exporting object 1");
   * // same as above
   * Progress.report("export-usdz", { message: "Exporting object 1", autoStep: true });
   * // show the current step and total steps and implicitly calculate progress as 10%
   * Progress.report("export-usdz", { currentStep: 1, totalSteps: 10 });
   * // enable auto step mode, following calls that have autoStep true will increase currentStep automatically.
   * Progress.report("export-usdz", { totalSteps: 20, autoStep: true });
   * // show the progress as 50%
   * Progress.report("export-usdz", { progress: 0.5 });
   * // give this step a weight of 20, which changes how progress is calculated. Useful for steps that take longer and/or have child scopes.
   * Progress.report("export-usdz", { message. "Long process", autoStep: 20 });
   * // show the current step and total steps and implicitly calculate progress as 10%
   * Progress.report("export-usdz", { currentStep: 1, totalSteps: 10 });
   */
  static report(e, t) {
    const i = Ol.get(e);
    if (!i) {
      console.warn("Reporting progress for non-existing scope", e);
      return;
    }
    typeof t == "string" && (t = { message: t, autoStep: !0 }), i.report(t);
  }
  /** End a formerly started scope. This will also report the progress as 100%.
   * @remarks Will warn if any child scope is still running (progress < 1).
  */
  static end(e) {
    const t = Ol.get(e);
    t && (t.end(), Ol.delete(e));
  }
}
const Ol = /* @__PURE__ */ new Map();
class kM {
  scopeLabel;
  parentScope;
  childScopes = [];
  parentDepth = 0;
  lastStep = 0;
  lastAutoStepWeight = 1;
  lastTotalSteps = 0;
  onProgress;
  showLogs = !1;
  selfProgress = 0;
  totalProgress = 0;
  selfReports = 0;
  totalReports = 0;
  constructor(e, t) {
    this.parentScope = t?.parentScope ? Ol.get(t.parentScope) : void 0, this.parentScope && (this.parentScope.childScopes.push(this), this.parentDepth = this.parentScope.parentDepth + 1), this.scopeLabel = " ".repeat(this.parentDepth * 2) + e, this.showLogs = t?.logTimings ?? !!PM, this.showLogs && console.time(this.scopeLabel), this.onProgress = t?.onProgress;
  }
  report(e, t = !1) {
    if (e) {
      if (e.totalSteps !== void 0 && (this.lastTotalSteps = e.totalSteps), e.currentStep !== void 0 && (this.lastStep = e.currentStep), e.autoStep !== void 0) {
        if (e.currentStep === void 0) {
          this.lastStep === void 0 && (this.lastStep = 0);
          const n = typeof e.autoStep == "number" ? e.autoStep : 1;
          this.lastStep += this.lastAutoStepWeight, this.lastAutoStepWeight = n, e.currentStep = this.lastStep;
        }
        e.totalSteps = this.lastTotalSteps;
      }
      e.progress !== void 0 ? this.selfProgress = e.progress : e.currentStep !== void 0 && e.totalSteps !== void 0 && (this.selfProgress = e.currentStep / e.totalSteps);
    }
    if (this.childScopes.length > 0) {
      let n = 0, o = 0;
      for (const a of this.childScopes)
        n += a.selfProgress, o += 1;
      o > 0 && (n /= o);
      const r = this.lastAutoStepWeight / (this.lastTotalSteps ?? 1);
      this.totalProgress = this.selfProgress + n * r;
    } else
      this.totalProgress = this.selfProgress;
    this.selfProgress = Math.min(1, this.selfProgress), this.totalProgress = Math.min(1, this.totalProgress);
    let i = (this.totalProgress * 100).toFixed(3) + "%";
    this.childScopes.length > 0 && (i += " (" + (this.selfProgress * 100).toFixed(3) + "% self)"), e?.message && (i = e.message + " – " + i), this.lastStep !== void 0 && this.lastTotalSteps !== void 0 && (i = "Step " + (this.lastStep + (this.lastAutoStepWeight != 1 ? "–" + (this.lastStep + this.lastAutoStepWeight) : "") + "/" + this.lastTotalSteps) + " " + i), t ? this.totalReports++ : (this.selfReports++, this.totalReports++), this.showLogs && console.timeLog(this.scopeLabel, i), this.onProgress && this.onProgress(this.totalProgress), this.parentScope && this.parentScope.report(void 0, !0);
  }
  end() {
    this.report({ progress: 1, autoStep: !0 }, !0), this.showLogs && (console.timeLog(this.scopeLabel, "Total reports: " + this.totalReports, "Self reports: " + this.selfReports), console.timeEnd(this.scopeLabel));
    let e = !1;
    for (const t of this.childScopes)
      if (!(t.selfProgress >= 1)) {
        e = !0;
        break;
      }
    e && console.warn("Progress end with child scopes that are still running", this), this.onProgress = void 0;
  }
}
const Ie = "</StageRoot/Materials";
function MM(s, e, t) {
  const i = /* @__PURE__ */ new Map(), n = (_) => {
    const m = _.type___needle, v = i.get(m) || /* @__PURE__ */ new Map();
    if (i.set(m, v), !v.has(_)) {
      const y = `${m}${v.size ? `_${v.size}` : ""}`;
      v.set(_, y);
    }
    return v.get(_);
  }, o = s.colorNode ? hh(s.colorNode) : [], r = s.colorNode ? `color3f inputs:diffuseColor.connect = ${Ie}/${e}/${n(o.values().next().value)}.outputs:out>` : "", a = s.roughnessNode ? hh(s.roughnessNode) : [], l = s.roughnessNode ? `float inputs:roughness.connect = ${Ie}/${e}/${n(a.values().next().value)}.outputs:out>` : "", c = s.normalNode ? hh(s.normalNode) : [], h = s.normalNode ? `float3 inputs:normal.connect = ${Ie}/${e}/${n(c.values().next().value)}.outputs:out>` : "", d = s.metalnessNode ? hh(s.metalnessNode) : [], f = s.metalnessNode ? `float inputs:metallic.connect = ${Ie}/${e}/${n(d.values().next().value)}.outputs:out>` : "", p = /* @__PURE__ */ new Set([...o, ...a, ...c, ...d]), g = EM(p, e, t, n);
  return console.debug(g), `

	def Material "${e}" ${s.name ? `(
		displayName = "${s.name}"
	)` : ""}
	{
		token outputs:mtlx:surface.connect = ${Ie}/${e}/N_mtlxsurface.outputs:surface>

		def Shader "N_mtlxsurface"
		{
			uniform token info:id = "ND_UsdPreviewSurface_surfaceshader"
			${r}
			${l}
			${h}
			${f}
			token outputs:surface
		}
		
		${g}
		
	}`;
}
function hh(s) {
  const e = (m) => {
    if (m.nodeType) return m.nodeType;
    switch (m.type) {
      case "TimerNode":
        return "float";
      case "TextureNode":
        return;
      case "ConvertNode":
        return m.convertTo;
      default:
        return;
    }
  }, t = (m) => {
    const v = /* @__PURE__ */ new Set(), y = (x) => {
      if (!(!x.isNode || v.has(x))) {
        x.nodeType___needle || (x.nodeType___needle = e(x)), x.shaderNode ? (x.type___needle = "ShaderCallNodeInternal", x.shaderNodeLayoutName___needle = x.shaderNode.layout.name.slice(3)) : x.type___needle = x.type, v.add(x);
        for (const I in x)
          x[I]?.isNode && (y(x[I]), x.nodeType___needle ||= x[I].nodeType___needle), Array.isArray(x[I]) && x[I].forEach((O) => {
            O.isNode && (y(O), x.nodeType___needle ||= O.nodeType___needle);
          });
      }
    };
    return y(m), v;
  }, i = (m) => {
    if (m.type === "ConvertNode") {
      if (m.convertTo === m.node.nodeType___needle)
        return !0;
      if (m.node.type === "ConstNode") {
        if (m.convertTo === "vec4" && m.node.value.isVector4)
          return !0;
        if (m.convertTo === "vec3" && m.node.value.isVector3)
          return !0;
        if (m.convertTo === "vec2" && m.node.value.isVector2)
          return !0;
        if (m.convertTo === "color" && m.node.value.isColor)
          return !0;
        if (m.convertTo === "float" && typeof m.node.value == "number")
          return !0;
      } else if (m.node.type == "SplitNode" && m.convertTo == "float" && m.node.components.length === 1)
        return !0;
    }
    return !1;
  }, n = (m) => {
    for (; o(m); )
      !m.node && m.shaderNode ? m = m.inputNodes[0] : m = m.node ?? m.aNode ?? m.bNode ?? m.cNode;
    return m;
  }, o = (m) => {
    const v = ["UniformNode", "UniformGroupNode", "ShaderNodeInternal"];
    return !m || i(m) || v.includes(m.type___needle) || m.type___needle === void 0;
  }, r = (m, v) => {
    for (const y of v)
      for (const x in y) {
        if (y[x]?.isNode && y[x] === m)
          return { parent: y, label: x };
        if (Array.isArray(y[x]) && y[x].find((O) => O.isNode && O === m))
          return { parent: y, label: x };
      }
    return null;
  }, a = (m, v) => {
    if (m.shaderNode)
      m.inputNodes[0] = n(m.inputNodes[0]);
    else if (Array.isArray(m.nodes))
      for (let y = 0; y < m.nodes.length; y++)
        m.nodes[y] && o(m.nodes[y]) && (m.nodes[y] = n(m.nodes[y]));
    else
      v.forEach((y) => {
        m[y] && o(m[y]) && (m[y] = n(m[y]));
      });
  }, l = (m) => {
    m.type === "MathNode" && m.method === "mix" && (m.cNode.nodeType___needle = "float", m.cNode.type === "ConvertNode" && (m.cNode.convertTo = "float"));
  }, c = (m, v) => {
    v.label === "cNode" && v.parent.type === "MathNode" && v.parent.method === "mix" || (v.parent.type === "JoinNode" ? m.nodeType___needle = "float" : m.nodeType___needle = v.parent.nodeType___needle);
  }, h = (m) => m?.type === "ConvertNode" && m.nodeType___needle === "color" && m.node.nodeType___needle === "vec4", d = (m, v) => {
    m.convertTo = "vec3", m.nodeType___needle = "vec3";
    const y = {
      type: "ConvertNode",
      convertTo: "color",
      node: m,
      isNode: !0,
      nodeType___needle: "color",
      type___needle: "ConvertNode"
    }, x = r(m, v);
    return x?.parent && (x.parent[x.label] = y), y;
  }, f = (m) => m?.type === "ConvertNode" && m.node.type === "TextureNode" && m.nodeType___needle !== m.node.nodeType___needle, p = (m) => {
    const v = /* @__PURE__ */ new Set();
    for (let y of m)
      if (!o(y)) {
        if (l(y), y.type == "SplitNode") {
          const x = r(y, m);
          if (y.components.length === 1)
            y.nodeType___needle = "float";
          else if (x)
            y.nodeType___needle = x.parent.nodeType___needle;
          else throw new Error("SplitNode without parent found, this should not happen");
        }
        if (a(y, ["node", "aNode", "bNode", "cNode"]), y.type == "ConstNode" && y.nodeType == null && c(y, r(y, m)), h(y) && v.add(d(y, m)), f(y)) {
          y.node.nodeType___needle = y.convertTo;
          const x = r(y, m);
          x?.parent && (x.parent[x.label] = y.node), y = y.node;
        }
        v.add(y);
      }
    return v;
  }, g = t(s);
  return p(g);
}
function RM(s, e) {
  switch (e) {
    case "float4":
      return s.isVector4 ? `(${s.x}, ${s.y}, ${s.z}, ${s.w})` : `(${s}, ${s}, ${s}, ${s})`;
    case "float3":
      return s.isVector3 ? `(${s.x}, ${s.y}, ${s.z})` : `(${s}, ${s}, ${s})`;
    case "float2":
      return s.isVector2 ? `(${s.x}, ${s.y})` : `(${s}, ${s})`;
    case "color3f":
      return s.isColor ? `(${s.r}, ${s.g}, ${s.b})` : `(${s}, ${s}, ${s})`;
    default:
      return s.isVector4 || s.isVector3 || s.isVector2 ? `${s.x}` : s.isColor ? `${s.r}` : `${s}`;
  }
}
function TM(s, e, t, i) {
  const n = "        ", o = (p) => ({
    float: "float",
    vec2: "vector2",
    vec3: "vector3",
    vec4: "vector4",
    color: "color3"
  })[p] || "float", r = (p) => ({
    float: "float",
    vec2: "float2",
    vec3: "float3",
    vec4: "float4",
    color: "color3f"
  })[p] || "float", a = s.type___needle, l = s.nodeType___needle, c = o(l);
  let h = r(l), d = "";
  const f = new Array();
  switch (a) {
    case "UniformGroupNode":
    case "UniformNode":
      return "";
    case "TimerNode":
      d = "time_float";
      break;
    case "ConstNode":
      d = "constant_" + c, f.push(`${h} inputs:value = ${RM(s.value, h)}`);
      break;
    case "JoinNode":
      d = "combine" + s.nodes.length + "_" + c;
      let p = 1;
      for (const x of s.nodes)
        f.push(`float inputs:in${p++}.connect = ${Ie}/${e}/${t(x)}.outputs:out>`);
      break;
    case "ConvertNode":
      d = "convert_" + o(s.node.nodeType___needle) + "_" + c, s.node && f.push(`${r(s.node.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.node)}.outputs:out>`);
      break;
    case "MathNode":
      d = s.method + "_" + c, s.aNode && !s.bNode && f.push(`${r(s.aNode.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), s.aNode && s.bNode && !s.cNode && (f.push(`${r(s.aNode.nodeType___needle)} inputs:in1.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), f.push(`${r(s.bNode.nodeType___needle)} inputs:in2.connect = ${Ie}/${e}/${t(s.bNode)}.outputs:out>`)), s.aNode && s.bNode && s.cNode && s.method == "clamp" && (f.push(`${r(s.aNode.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), f.push(`${r(s.bNode.nodeType___needle)} inputs:low.connect = ${Ie}/${e}/${t(s.bNode)}.outputs:out>`), f.push(`${r(s.cNode.nodeType___needle)} inputs:high.connect = ${Ie}/${e}/${t(s.cNode)}.outputs:out>`)), s.aNode && s.bNode && s.cNode && s.method == "mix" && (f.push(`${r(s.aNode.nodeType___needle)} inputs:fg.connect = ${Ie}/${e}/${t(s.bNode)}.outputs:out>`), f.push(`${r(s.bNode.nodeType___needle)} inputs:bg.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), f.push(`float inputs:mix.connect = ${Ie}/${e}/${t(s.cNode)}.outputs:out>`));
      break;
    case "OperatorNode":
      let _ = "";
      switch (s.op) {
        case "*":
          _ = "multiply";
          break;
        case "/":
          _ = "divide";
          break;
        case "+":
          _ = "add";
          break;
        case "-":
          _ = "subtract";
          break;
      }
      if (d = _ + "_" + c, s.aNode && !s.bNode && f.push(`${r(s.aNode.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), s.aNode && s.bNode) {
        const x = r(s.aNode.nodeType___needle), I = r(s.bNode.nodeType___needle);
        (x === "color3f" && I === "float" || I === "float" && I === "color3f") && (d = _ + "_color3FA"), f.push(`${x} inputs:in1.connect = ${Ie}/${e}/${t(s.aNode)}.outputs:out>`), f.push(`${I} inputs:in2.connect = ${Ie}/${e}/${t(s.bNode)}.outputs:out>`);
      }
      break;
    case "TextureNode":
      s.uvNode ? (d = "tiledimage_" + c, f.push(`float2 inputs:texcoord.connect = ${Ie}/${e}/${t(s.uvNode)}.outputs:out>`)) : d = "image_" + c;
      const m = s._value, v = ag.includes(m.format), y = AM(m);
      f.push(`asset inputs:file = @textures/${y}.${v ? "png" : "jpg"}@`), i[y] = { texture: m, scale: void 0 };
      break;
    case "NormalMapNode":
      h = "float3", d = "normalmap", f.push(`${h} inputs:in.connect = ${Ie}/${e}/${t(s.node)}.outputs:out>`);
      break;
    case "AttributeNode":
      d = "geompropvalue_" + c, f.push('string inputs:geomprop = "st"');
      break;
    case "ShaderCallNodeInternal":
      d = s.shaderNodeLayoutName___needle + "_" + c, f.push(`${h} inputs:in.connect = ${Ie}/${e}/${t(s.inputNodes[0])}.outputs:out>`);
      break;
    case "SplitNode":
      d = "swizzle_" + o(s.node.nodeType___needle) + "_" + c, f.push(`${r(s.node.nodeType___needle)} inputs:in.connect = ${Ie}/${e}/${t(s.node)}.outputs:out>`), f.push(`string inputs:channels = "${s.components}"`);
      break;
  }
  return `
	${n}def Shader "${t(s)}"
	${n}{
		${n}uniform token info:id = "ND_${d}"
		${n}${h} outputs:out
		${n}${f.length > 0 ? f.join(`
				`) : ""}
	${n}}
	`;
}
function EM(s, e, t, i) {
  let n = "";
  for (const o of s)
    n += TM(o, e, i, t);
  return n;
}
function AM(s) {
  return cn(s.name) + "_" + (s.source?.id ?? s.id);
}
function cn(s) {
  return s = s.replace(/[^a-zA-Z0-9_]/g, ""), s.match(/^[a-zA-Z_]/) || (s = "_" + s), s;
}
function vv(s) {
  return s = s.replace('"', '\\"'), s;
}
function wv(s) {
  if (s.length === 0) return null;
  const e = s.map((i) => {
    const n = new Array();
    for (; i.parent; )
      n.unshift(i.parent), i = i.parent;
    return n;
  });
  return e[0].findLast((i) => e.every((n) => n.includes(i))) || null;
}
function xv(s) {
  const e = wv(s), t = /* @__PURE__ */ new Set();
  for (const i of s) {
    let n = i.parent;
    for (; n && n !== e; )
      s.includes(n) || t.add(n), n = n.parent;
  }
  return t;
}
const IM = new b(), LM = new $(), DM = new b(1, 1, 1);
class st {
  static USDObject_export_id = 0;
  uuid;
  name;
  /** If no type is provided, type is chosen automatically (Xform or Mesh) */
  type;
  /** MaterialBindingAPI and SkelBindingAPI are handled automatically, extra schemas can be added here */
  extraSchemas = [];
  displayName;
  visibility;
  // defaults to "inherited" in USD
  getMatrix() {
    if (!this.transform) return new te();
    const { position: e, quaternion: t, scale: i } = this.transform, n = new te();
    return n.compose(e || IM, t || LM, i || DM), n;
  }
  setMatrix(e) {
    if (!e || !(e instanceof te)) {
      this.transform = null;
      return;
    }
    const t = new b(), i = new $(), n = new b();
    e.decompose(t, i, n), this.transform = { position: t, quaternion: i, scale: n };
  }
  /** @deprecated Use `transform`, or `getMatrix()` if you really need the matrix */
  get matrix() {
    return this.getMatrix();
  }
  /** @deprecated Use `transform`, or `setMatrix()` if you really need the matrix */
  set matrix(e) {
    this.setMatrix(e);
  }
  transform = null;
  _isDynamic;
  get isDynamic() {
    return this._isDynamic;
  }
  set isDynamic(e) {
    this._isDynamic = e;
  }
  geometry;
  material;
  camera;
  parent;
  skinnedMesh;
  children = [];
  animations;
  _eventListeners;
  // these are for tracking which xformops are needed
  needsTranslate = !1;
  needsOrient = !1;
  needsScale = !1;
  static createEmptyParent(e) {
    const t = new st(gs.generateUUID(), e.name + "_empty_" + st.USDObject_export_id++, e.transform), i = e.parent;
    return i && i.add(t), t.add(e), t.isDynamic = !0, e.transform = null, t;
  }
  static createEmpty() {
    const e = new st(gs.generateUUID(), "Empty_" + st.USDObject_export_id++);
    return e.isDynamic = !0, e;
  }
  constructor(e, t, i = null, n = null, o = null, r = null, a = null, l = null) {
    this.uuid = e, this.name = cn(t), this.displayName = t, i ? this.transform = {
      position: i.position?.clone() || null,
      quaternion: i.quaternion?.clone() || null,
      scale: i.scale?.clone() || null
    } : this.transform = null, this.geometry = n, this.material = o, this.camera = r, this.parent = null, this.children = [], this._eventListeners = {}, this._isDynamic = !1, this.skinnedMesh = a, this.animations = l;
  }
  is(e) {
    return e ? this.uuid === e.uuid : !1;
  }
  isEmpty() {
    return !this.geometry;
  }
  clone() {
    const e = new st(gs.generateUUID(), this.name, this.transform, this.geometry, this.material);
    return e.isDynamic = this.isDynamic, e;
  }
  deepClone() {
    const e = this.clone();
    for (const t of this.children)
      t && e.add(t.deepClone());
    return e;
  }
  getPath() {
    let e = this.parent, t = this.name;
    for (; e; )
      t = (e.parent ? e.name : e.name + "/Scenes/Scene") + "/" + t, e = e.parent;
    return "</" + t + ">";
  }
  add(e) {
    e.parent && e.parent.remove(e), e.parent = this, this.children.push(e);
  }
  remove(e) {
    const t = this.children.indexOf(e);
    t >= 0 && (e.parent === this && (e.parent = null), this.children.splice(t, 1));
  }
  addEventListener(e, t) {
    this._eventListeners[e] || (this._eventListeners[e] = []), this._eventListeners[e].push(t);
  }
  removeEventListener(e, t) {
    if (!this._eventListeners[e]) return;
    const i = this._eventListeners[e].indexOf(t);
    i >= 0 && this._eventListeners[e].splice(i, 1);
  }
  onSerialize(e, t) {
    const i = this._eventListeners.serialize;
    i && i.forEach((n) => n(e, t));
  }
}
class Sv extends st {
  stageLength;
  get isDocumentRoot() {
    return !0;
  }
  get isDynamic() {
    return !1;
  }
  constructor() {
    super(void 0, "StageRoot", null, null, null, null), this.children = [], this.stageLength = 200;
  }
  add(e) {
    e.parent = this, this.children.push(e);
  }
  remove(e) {
    const t = this.children.indexOf(e);
    t >= 0 && (e.parent === this && (e.parent = null), this.children.splice(t, 1));
  }
  traverse(e, t = null) {
    if (t !== null ? e(t) : t = this, t.children)
      for (const i of t.children)
        this.traverse(e, i);
  }
  findById(e) {
    let t = !1;
    function i(n) {
      if (!t) {
        if (n.uuid === e)
          return t = !0, n;
        if (n.children)
          for (const o of n.children) {
            if (!o) continue;
            const r = i(o);
            if (r) return r;
          }
      }
    }
    return i(this);
  }
  buildHeader(e) {
    const t = e.extensions?.find((h) => h?.extensionName === "animation"), i = e.extensions?.find((h) => h?.extensionName === "Behaviour"), n = e.extensions?.find((h) => h?.extensionName === "Physics"), o = t?.getStartTimeCode() ?? 0, r = t?.getEndTimeCode() ?? 0;
    let a = "";
    const l = t?.registeredClips;
    if (l)
      for (const h of l)
        a += `	# Animation: ${h.name}, start=${t.getStartTimeByClip(h) * 60}, length=${h.duration * 60}
`;
    const c = a;
    return `#usda 1.0
(
	customLayerData = {
		string creator = "Needle Engine ${En}"
		dictionary Needle = {
			bool animations = ${t ? 1 : 0}
			bool interactive = ${i ? 1 : 0}
			bool physics = ${n ? 1 : 0}
			bool quickLookCompatible = ${e.quickLookCompatible ? 1 : 0}
		}
	}
	defaultPrim = "${cn(this.name)}"
	metersPerUnit = 1
	upAxis = "Y"
	startTimeCode = ${o}
	endTimeCode = ${r}
	timeCodesPerSecond = 60
	framesPerSecond = 60
	doc = """Generated by Needle Engine USDZ Exporter ${En}"""
${c}
)
`;
  }
}
const Ar = `
`, Ut = "</StageRoot/Materials";
class jM {
  str;
  indent;
  constructor() {
    this.str = "", this.indent = 0;
  }
  clear() {
    this.str = "", this.indent = 0;
  }
  beginBlock(e = void 0, t = "{", i = !0) {
    e !== void 0 ? (e = this.applyIndent(e), this.str += e, i ? (this.str += Ar, this.str += this.applyIndent(t)) : this.str += " " + t) : this.str += this.applyIndent(t), this.str += Ar, this.indent += 1;
  }
  closeBlock(e = "}") {
    this.indent -= 1, this.str += this.applyIndent(e) + Ar;
  }
  beginArray(e) {
    e = this.applyIndent(e + " = ["), this.str += e, this.str += Ar, this.indent += 1;
  }
  closeArray() {
    this.indent -= 1, this.str += this.applyIndent("]") + Ar;
  }
  appendLine(e = "") {
    e = this.applyIndent(e), this.str += e, this.str += Ar;
  }
  toString() {
    return this.str;
  }
  applyIndent(e) {
    let t = "";
    for (let i = 0; i < this.indent; i++) t += "	";
    return t + e;
  }
}
class BM {
  root;
  exporter;
  extensions = [];
  quickLookCompatible;
  exportInvisible;
  materials;
  textures;
  files;
  document;
  output;
  animations;
  constructor(e, t, i) {
    this.root = e, this.exporter = t, this.quickLookCompatible = i.quickLookCompatible, this.exportInvisible = i.exportInvisible, i.extensions && (this.extensions = i.extensions), this.materials = /* @__PURE__ */ new Map(), this.textures = {}, this.files = {}, this.document = new Sv(), this.output = "", this.animations = [];
  }
}
class Rf {
  ar = {
    anchoring: { type: "plane" },
    planeAnchoring: { alignment: "horizontal" }
  };
  quickLookCompatible = !1;
  extensions = [];
  maxTextureSize = 4096;
  exportInvisible = !1;
}
let FM = class {
  debug;
  pruneUnusedNodes;
  sceneAnchoringOptions = new Rf();
  extensions = [];
  keepObject;
  beforeWritingDocument;
  constructor() {
    this.debug = !1, this.pruneUnusedNodes = !0;
  }
  async parse(e, t = new Rf()) {
    t = Object.assign(new Rf(), t), this.sceneAnchoringOptions = t;
    const i = new BM(e, this, t);
    this.extensions = i.extensions;
    const n = i.files, o = "model.usda";
    n[o] = null;
    const r = i.materials, a = i.textures;
    le.report("export-usdz", "Invoking onBeforeBuildDocument"), await Uh(i, "onBeforeBuildDocument"), le.report("export-usdz", "Done onBeforeBuildDocument"), le.report("export-usdz", "Reparent bones to common ancestor");
    const l = [], c = /* @__PURE__ */ new Set();
    e?.traverse((y) => {
      if (!(!t.exportInvisible && !y.visible) && y instanceof ys) {
        const x = y.skeleton.bones, I = wv(x);
        if (I) {
          const O = { object: y, originalParent: y.parent, newParent: I };
          l.push(O), c.add(O.object.uuid), O.newParent && c.add(O.newParent.uuid), O.originalParent && c.add(O.originalParent.uuid);
        }
      }
    });
    for (const y of l) {
      const { object: x, originalParent: I, newParent: O } = y;
      O.add(x);
    }
    le.report("export-usdz", "Traversing hierarchy"), e && Cv(e, i.document, i, this.keepObject), le.report("export-usdz", "Invoking onAfterBuildDocument"), await Uh(i, "onAfterBuildDocument");
    const d = i.extensions.find((y) => y.extensionName === "Behaviour")?.getAllTargetUuids() ?? /* @__PURE__ */ new Set();
    if (this.pruneUnusedNodes) {
      const y = {
        allBehaviorTargets: d,
        debug: !1,
        boneReparentings: c,
        quickLookCompatible: i.quickLookCompatible
      };
      this.debug && P_(i.document, "Hierarchy BEFORE pruning", y), Pv(i.document, y), this.debug && P_(i.document, "Hierarchy AFTER pruning");
    } else this.debug && console.log("Pruning of empty nodes is disabled. This may result in a larger USDZ file.");
    le.report("export-usdz", { message: "Parsing document", autoStep: 10 }), await zM(i, () => (le.report("export-usdz", "Building materials"), QM(r, a, t.quickLookCompatible))), le.report("export-usdz", "Invoking onAfterSerialize"), await Uh(i, "onAfterSerialize");
    for (const y of l) {
      const { object: x, originalParent: I, newParent: O } = y;
      I && I.add(x);
    }
    i.exporter?.beforeWritingDocument?.();
    const p = i.document.buildHeader(i) + `
` + i.output;
    this.debug && console.log(p), n[o] = xb(p), i.output = "", le.report("export-usdz", { message: "Exporting textures", autoStep: 10 }), le.start("export-usdz-textures", { parentScope: "export-usdz", logTimings: !1 });
    const g = new ur({
      antialias: !1,
      alpha: !0,
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0
    }), _ = Object.keys(a).length;
    le.report("export-usdz-textures", { totalSteps: _ * 3, currentStep: 0 });
    const m = async (y) => {
      const x = a[y], I = x.texture, O = ag.includes(I.format);
      let k = {
        imageData: I.image
      };
      le.report("export-usdz-textures", { message: "read back texture", autoStep: !0 });
      const E = x.scale !== void 0 && x.scale.x !== 1 && x.scale.y !== 1 && x.scale.z !== 1 && x.scale.w !== 1;
      (I.isCompressedTexture || I.isRenderTargetTexture || E) && (k = await UM(I, t.maxTextureSize, g, x.scale)), le.report("export-usdz-textures", { message: "convert texture to canvas", autoStep: !0 });
      const z = await $M(k.imageBitmap || k.imageData, t.maxTextureSize).catch((D) => {
        console.error("Error converting texture to canvas", I, D);
      });
      if (z) {
        le.report("export-usdz-textures", { message: "convert canvas to blob", autoStep: !0 });
        const D = await z.convertToBlob({ type: O ? "image/png" : "image/jpeg", quality: 0.95 });
        n[`textures/${y}.${O ? "png" : "jpg"}`] = new Uint8Array(await D.arrayBuffer());
      } else
        console.warn("Can`t export texture: ", I);
    };
    for (const y in a)
      await m(y);
    g.dispose(), le.end("export-usdz-textures");
    let v = 0;
    for (const y in n) {
      const x = n[y], I = 34 + y.length;
      v += I;
      const O = v & 63;
      if (O !== 4) {
        const k = 64 - O, E = new Uint8Array(k);
        n[y] = [x, { extra: { 12345: E } }];
      }
      v = x.length;
    }
    return le.report("export-usdz", "zip archive"), gS(n, { level: 0 });
  }
};
function Cv(s, e, t, i) {
  if (!t.exportInvisible && !s.visible) return;
  let n, o, r;
  const a = { position: s.position, quaternion: s.quaternion, scale: s.scale };
  if (s.position.x === 0 && s.position.y === 0 && s.position.z === 0 && (a.position = null), s.quaternion.x === 0 && s.quaternion.y === 0 && s.quaternion.z === 0 && s.quaternion.w === 1 && (a.quaternion = null), s.scale.x === 1 && s.scale.y === 1 && s.scale.z === 1 && (a.scale = null), (s instanceof H || s instanceof ys) && (o = s.geometry, r = s.material), i && !i(s) && (o = void 0, r = void 0), (s instanceof H || s instanceof ys) && r && typeof r == "object" && (r instanceof ct || r instanceof we || // material instanceof MeshPhysicalNodeMaterial ||
  r.isMeshPhysicalNodeMaterial || r instanceof _e && r.type === "MeshLineMaterial")) {
    const l = fh(s), c = s instanceof ys ? s : null;
    n = new st(s.uuid, l, a, o, r, void 0, c, s.animations);
  } else if (s instanceof pe || s instanceof Td) {
    const l = fh(s);
    n = new st(s.uuid, l, a, void 0, void 0, s);
  } else {
    const l = fh(s);
    n = new st(s.uuid, l, a, void 0, void 0, void 0, void 0, s.animations);
  }
  if (n) {
    if (n.displayName = s.userData?.name || s.name, n.visibility = s.visible ? void 0 : "invisible", e && e.add(n), e = n, t.extensions)
      for (const l of t.extensions)
        l.onExportObject && l.onExportObject.call(l, s, n, t);
  } else {
    const l = fh(s), c = new st(s.uuid, l, { position: s.position, quaternion: s.quaternion, scale: s.scale });
    e && e.add(c), e = c;
  }
  for (const l of s.children)
    Cv(l, e, t, i);
}
function P_(s, e, ...t) {
  const i = {};
  let n = 0;
  function o(r, a) {
    n++;
    let l = r.displayName || r.name;
    l += " (" + r.uuid + ")", (r.geometry || r.material || r.camera || r.skinnedMesh) && (l += " (" + (r.geometry ? "geo, " : "") + (r.material ? "mat, " : "") + (r.camera ? "cam, " : "") + (r.skinnedMesh ? "skin, " : "") + ")"), a[l] = {};
    const h = { object: r };
    r.material && (h.mat = !0), r.geometry && (h.geo = !0), r.camera && (h.cam = !0), r.skinnedMesh && (h.skin = !0), a[l]._self = h;
    for (const d of r.children)
      d && o(d, a[l]);
  }
  o(s, i), console.log(e + " (" + n + " nodes)", i, ...t);
}
function Pv(s, e) {
  let t = !0;
  const i = new Array(), n = new Array();
  if (s.children.length === 0)
    t = !0;
  else {
    const c = [...s.children];
    for (const h of c)
      if (h) {
        const d = Pv(h, e);
        e.debug && (d ? i.push(h) : n.push(h)), t = t && d;
      }
  }
  const o = e.allBehaviorTargets.has(s.uuid), r = s.geometry || s.material || s.camera && !e.quickLookCompatible || s.skinnedMesh || !1, a = e.boneReparentings.has(s.uuid), l = t && !o && !r && !a;
  return l ? (e.debug && console.log("Pruned object:", (s.displayName || s.name) + " (" + s.uuid + ")", {
    isVisible: r,
    isBehaviorSourceOrTarget: o,
    allChildsWerePruned: t,
    isBoneReparenting: a,
    object: s,
    prunedChilds: i,
    keptChilds: n
  }), s.parent?.remove(s)) : e.debug && console.log("Kept object:", (s.displayName || s.name) + " (" + s.uuid + ")", {
    isVisible: r,
    isBehaviorSourceOrTarget: o,
    allChildsWerePruned: t,
    isBoneReparenting: a,
    object: s,
    prunedChilds: i,
    keptChilds: n
  }), l;
}
async function zM(s, e) {
  le.start("export-usdz-resources", "export-usdz");
  const t = [];
  for (const l of s.document.children)
    Ov(l, s, t);
  const i = t.length;
  for (let l = 0; l < i; l++)
    le.report("export-usdz-resources", { totalSteps: i, currentStep: l }), await new Promise((c, h) => {
      t[l](), c();
    });
  le.end("export-usdz-resources");
  const n = new jM(), o = s.exporter.sceneAnchoringOptions.ar;
  n.beginBlock(`def Xform "${s.document.name}"`), n.beginBlock(`def Scope "Scenes" (
		kind = "sceneLibrary"
	)`), n.beginBlock('def Xform "Scene"', "(", !1), n.appendLine('apiSchemas = ["Preliminary_AnchoringAPI"]'), n.appendLine("customData = {"), n.appendLine("	bool preliminary_collidesWithEnvironment = 0"), n.appendLine('	string sceneName = "Scene"'), n.appendLine("}"), n.appendLine('sceneName = "Scene"'), n.closeBlock(")"), n.beginBlock(), n.appendLine(`token preliminary:anchoring:type = "${o.anchoring.type}"`), o.anchoring.type === "plane" && n.appendLine(`token preliminary:planeAnchoring:alignment = "${o.planeAnchoring.alignment}"`), o.anchoring.type === "image" && n.appendLine(`rel preliminary:imageAnchoring:referenceImage = </${s.document.name}/Scenes/Scene/AnchoringReferenceImage>`), n.appendLine();
  const r = (l) => {
    if (!l) return 0;
    let c = 1;
    for (const h of l.children) c += r(h);
    return c;
  }, a = r(s.document);
  le.start("export-usdz-xforms", "export-usdz"), le.report("export-usdz-xforms", { totalSteps: a, currentStep: 1 });
  for (const l of s.document.children)
    kv(l, n, s);
  le.end("export-usdz-xforms"), le.report("export-usdz", "invoke onAfterHierarchy"), await Uh(s, "onAfterHierarchy", n), n.closeBlock(), n.closeBlock(), n.appendLine(e()), n.closeBlock(), le.report("export-usdz", "write to string"), s.output += n.toString();
}
function Ov(s, e, t) {
  if (!s) return;
  const i = s.geometry, n = s.material;
  if (i)
    if (n && ("isMeshStandardMaterial" in n && n.isMeshStandardMaterial || "isMeshBasicMaterial" in n && n.isMeshBasicMaterial || n.type === "MeshLineMaterial")) {
      const o = "geometries/" + Up(i, s.name) + ".usda";
      if (!(o in e.files)) {
        const r = () => {
          const a = GM(i, s.skinnedMesh?.skeleton?.bones, e.quickLookCompatible);
          e.files[o] = HM(a);
        };
        t.push(r);
      }
    } else
      console.warn("NeedleUSDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", n?.name);
  n && (n.uuid in e.materials || (e.materials[n.uuid] = n));
  for (const o of s.children)
    Ov(o, e, t);
}
async function Uh(s, e, t = null) {
  if (s.extensions) {
    for (const i of s.extensions)
      if (i && typeof i[e] == "function") {
        const o = i[e].call(i, s, t);
        o instanceof Promise && await o;
      }
  }
}
let dh = null, Bt = null, Tf, Ir, uh;
async function UM(s, e = 1 / 0, t = null, i = void 0) {
  Tf || (Tf = new Un(2, 2, 1, 1)), Ir || (Ir = new Ln({
    uniforms: {
      blitTexture: new zi(s),
      flipY: new zi(!1),
      scale: new zi(new de(1, 1, 1, 1))
    },
    vertexShader: `
            varying vec2 vUv;
			uniform bool flipY;
            void main(){
                vUv = uv;
				if (flipY)
					vUv.y = 1. - vUv.y;
                gl_Position = vec4(position.xy * 1.0,0.,.999999);
            }`,
    fragmentShader: `
            uniform sampler2D blitTexture;
			uniform vec4 scale; 
            varying vec2 vUv;

            void main(){ 
                gl_FragColor = vec4(vUv.xy, 0, 1);
                
                #ifdef IS_SRGB
                gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );
                #else
                gl_FragColor = texture2D( blitTexture, vUv);
                #endif
				
				gl_FragColor.rgba *= scale.rgba;
            }`
  }));
  const n = Ir.uniforms;
  n.blitTexture.value = s, n.flipY.value = !1, n.scale.value = new de(1, 1, 1, 1), i !== void 0 && n.scale.value.copy(i), Ir.defines.IS_SRGB = s.colorSpace == Cs, Ir.needsUpdate = !0, uh || (uh = new H(Tf, Ir), uh.frustumCulled = !1);
  const o = new pe(), r = new gi();
  r.add(uh), t || (t = dh = new ur({ antialias: !1, alpha: !0, premultipliedAlpha: !1, preserveDrawingBuffer: !0 }));
  const a = Math.min(s.image.width, e), l = Math.min(s.image.height, e);
  Bt && (Bt.width !== a || Bt.height !== l) && (Bt.dispose(), Bt = null), Bt || (Bt = new Dn(a, l, { format: Ld, type: Fx, minFilter: Xh, magFilter: Xh })), t.setRenderTarget(Bt), t.setSize(a, l), t.clear(), t.render(r, o), dh && (dh.dispose(), dh = null);
  const c = new Uint8ClampedArray(Bt.width * Bt.height * 4);
  t.readRenderTargetPixels(Bt, 0, 0, Bt.width, Bt.height, c);
  const h = new ImageData(c, Bt.width, Bt.height, void 0), d = await createImageBitmap(h, { premultiplyAlpha: "none" });
  return {
    imageData: h,
    imageBitmap: d
  };
}
function NM(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas || typeof ImageBitmap < "u" && s instanceof ImageBitmap;
}
async function $M(s, e = 4096) {
  const t = e / Math.max(s.width, s.height), i = s.width * Math.min(1, t), n = s.height * Math.min(1, t), o = new OffscreenCanvas(i, n), r = { premultiplyAlpha: "none" };
  s.width !== i && (r.resizeWidth = i), s.height !== n && (r.resizeHeight = n);
  const a = await createImageBitmap(s, r), l = o.getContext("bitmaprenderer");
  return l && l.transferFromImageBitmap(a), o;
}
async function WM(s, e = void 0, t = !1, i = 4096) {
  if (NM(s)) {
    const n = i / Math.max(s.width, s.height), o = new OffscreenCanvas(s.width * Math.min(1, n), s.height * Math.min(1, n)), r = o.getContext("2d", { alpha: !0, premultipliedAlpha: !1 });
    if (!r) throw new Error("Could not get canvas 2D context");
    if (t === !0 && (r.translate(0, o.height), r.scale(1, -1)), r.drawImage(s, 0, 0, o.width, o.height), e !== void 0) {
      const a = e.x, l = e.y, c = e.z, h = e.w, d = r.getImageData(0, 0, o.width, o.height), f = d.data;
      for (let p = 0; p < f.length; p += 4)
        f[p + 0] = f[p + 0] * a, f[p + 1] = f[p + 1] * l, f[p + 2] = f[p + 2] * c, f[p + 3] = f[p + 3] * h;
      r.putImageData(d, 0, 0);
    }
    return o;
  } else
    throw new Error("NeedleUSDZExporter: No valid image data found. Unable to process texture.");
}
const Oe = 7;
function VM() {
  return `#usda 1.0
(
    customLayerData = {
        string creator = "Needle Engine USDZExporter"
    }
    metersPerUnit = 1
    upAxis = "Y"
)
`;
}
function HM(s, e) {
  let t = VM();
  return t += s, xb(t);
}
function fh(s) {
  return s.name.replace(/[-<>\(\)\[\]§$%&\/\\\=\?\,\;]/g, "") + "_" + s.id;
}
function O_(s) {
  return cn(s.name || "bone_" + s.uuid);
}
function Up(s, e) {
  return cn(s.name || "Geometry") + "_" + s.id;
}
function cu(s) {
  return cn(s.name || "Material") + "_" + s.id;
}
function aa(s, e) {
  let t = O_(s), i = s.parent;
  for (; i && i !== e; )
    t = O_(i) + "/" + t, i = i.parent;
  return t;
}
function kv(s, e, t) {
  if (s == null)
    return;
  le.report("export-usdz-xforms", { message: "buildXform " + s.displayName || s.name, autoStep: !0 });
  const i = s.transform, n = s.geometry, o = s.material, r = s.camera, a = s.name;
  if (s.animations)
    for (const p of s.animations)
      t.animations.push(p);
  const l = n && n.isBufferGeometry && n.attributes.skinIndex !== void 0 && n.attributes.skinIndex.count > 0, c = l ? "SkelRoot" : "Xform", h = new Array(), d = o && o instanceof we && o.color && o.color.r === 1 && o.color.g === 1 && o.color.b === 1 && !o.map && o.opacity === 1 && n?.attributes.color;
  if (n?.attributes.color && !d && console.warn("NeedleUSDZExporter: Geometry has vertex colors. Vertex colors will only be shown in QuickLook for unlit materials with white color and no texture. Otherwise, they will be ignored.", s.displayName), e.appendLine(), n ? (e.beginBlock(`def ${c} "${a}"`, "(", !1), t.quickLookCompatible && o && o.side === yi && !l ? e.appendLine(`prepend references = @./geometries/${Up(n)}.usda@</Geometry_doubleSided>`) : e.appendLine(`prepend references = @./geometries/${Up(n)}.usda@</Geometry>`), d || h.push("MaterialBindingAPI"), l && h.push("SkelBindingAPI")) : r && !t.quickLookCompatible ? e.beginBlock(`def Camera "${a}"`, "(", !1) : s.type !== void 0 ? e.beginBlock(`def ${s.type} "${a}"`) : e.beginBlock(`def Xform "${a}"`, "(", !1), s.type === void 0 && (s.extraSchemas?.length && h.push(...s.extraSchemas), h.length && e.appendLine(`prepend apiSchemas = [${h.map((p) => `"${p}"`).join(", ")}]`)), s.displayName && e.appendLine(`displayName = "${vv(s.displayName)}"`), (r || s.type === void 0) && (e.closeBlock(")"), e.beginBlock()), n && o) {
    if (!d) {
      const p = cu(o);
      e.appendLine(`rel material:binding = </StageRoot/Materials/${p}>`);
    }
    !t.quickLookCompatible && o.side === yi && (e.beginBlock('over "Geometry" '), e.appendLine("uniform bool doubleSided = 1"), e.closeBlock());
  }
  let f = !1;
  if (l ? (e.appendLine("rel skel:skeleton = <Rig>"), e.appendLine("rel skel:animationSource = <Rig/_anim>"), f = !1) : s.type === void 0 && i && (f = f || i.position !== null || i.quaternion !== null || i.scale !== null, i.position && (s.needsTranslate = !0, e.appendLine(`double3 xformOp:translate = (${ae(i.position.x)}, ${ae(i.position.y)}, ${ae(i.position.z)})`)), i.quaternion && (s.needsOrient = !0, e.appendLine(`quatf xformOp:orient = (${ae(i.quaternion.w)}, ${ae(i.quaternion.x)}, ${ae(i.quaternion.y)}, ${ae(i.quaternion.z)})`)), i.scale && (s.needsScale = !0, e.appendLine(`double3 xformOp:scale = (${ae(i.scale.x)}, ${ae(i.scale.y)}, ${ae(i.scale.z)})`))), s.visibility !== void 0 && e.appendLine(`token visibility = "${s.visibility}"`), r && !t.quickLookCompatible && ("isOrthographicCamera" in r && r.isOrthographicCamera ? (e.appendLine(`float2 clippingRange = (${r.near}, ${r.far})`), e.appendLine(`float horizontalAperture = ${((Math.abs(r.left) + Math.abs(r.right)) * 10).toPrecision(Oe)}`), e.appendLine(`float verticalAperture = ${((Math.abs(r.top) + Math.abs(r.bottom)) * 10).toPrecision(Oe)}`), e.appendLine('token projection = "orthographic"')) : "isPerspectiveCamera" in r && r.isPerspectiveCamera && (e.appendLine(`float2 clippingRange = (${r.near.toPrecision(Oe)}, ${r.far.toPrecision(Oe)})`), e.appendLine(`float focalLength = ${r.getFocalLength().toPrecision(Oe)}`), e.appendLine(`float focusDistance = ${r.focus.toPrecision(Oe)}`), e.appendLine(`float horizontalAperture = ${r.getFilmWidth().toPrecision(Oe)}`), e.appendLine('token projection = "perspective"'), e.appendLine(`float verticalAperture = ${r.getFilmHeight().toPrecision(Oe)}`))), s.onSerialize && s.onSerialize(e, t), s.type === void 0) {
    const p = new Array();
    s.needsTranslate && p.push('"xformOp:translate"'), s.needsOrient && p.push('"xformOp:orient"'), s.needsScale && p.push('"xformOp:scale"'), p.length && e.appendLine(`uniform token[] xformOpOrder = [${p.join(", ")}]`);
  }
  if (s.children) {
    e.appendLine();
    for (const p of s.children)
      kv(p, e, t);
  }
  e.closeBlock();
}
function ae(s) {
  return Number.isInteger(s) ? s.toString() : s.toFixed(10);
}
function k_(s) {
  const e = s.elements;
  return `( ${ph(e, 0)}, ${ph(e, 4)}, ${ph(e, 8)}, ${ph(e, 12)} )`;
}
function ph(s, e) {
  return `(${ae(s[e + 0])}, ${ae(s[e + 1])}, ${ae(s[e + 2])}, ${ae(s[e + 3])})`;
}
function GM(s, e = [], t = !0) {
  return `
def "Geometry"
${qM(s, e, t)}
`;
}
function qM(s, e = [], t = !0) {
  const i = "Geometry", n = s.attributes, o = n.position.count, r = e && e.length > 0, a = [], l = [];
  let c = new Array(), h = n.skinIndex;
  if (r) {
    const f = [];
    for (const m of e)
      a.push({ bone: m, index: e.indexOf(m) }), f.push(m.uuid);
    let p = 1e4;
    for (; f.length < e.length && p-- > 0; )
      for (const m of a) {
        const v = m.bone.children;
        for (const y of v)
          f.indexOf(y.uuid) === -1 && e.indexOf(y) !== -1 && (a.push({ bone: y, index: e.indexOf(y) }), f.push(y.uuid));
      }
    p <= 0 && console.error("Failed to sort bones in skinned mesh", a, e, f);
    for (const m of xv(e))
      a.push({ bone: m, index: a.length });
    const g = a[0].bone.parent;
    a.sort((m, v) => aa(m.bone, g) > aa(v.bone, g) ? 1 : -1), a.map((m) => '"' + aa(m.bone, g) + '"').join(", ");
    for (const m in a)
      l[a[m].index] = parseInt(m);
    const _ = n.skinIndex;
    c = new Array();
    for (let m = 0; m < _.count; m++) {
      const v = _.getX(m), y = _.getY(m), x = _.getZ(m), I = _.getW(m);
      c.push(l[v], l[y], l[x], l[I]);
    }
    h = new ht(new Uint16Array(c), 4);
  }
  const d = n.skinWeight && n.skinIndex;
  return `
{	
    def Mesh "${i}" ${d ? `(
        prepend apiSchemas = ["SkelBindingAPI"]
    )` : ""}
    {
        int[] faceVertexCounts = [${Ef(s)}]
        int[] faceVertexIndices = [${Af(s)}]
		${n.normal || t ? (
    // in QuickLook, normals are required, otherwise double-sided rendering doesn't work.
    `normal3f[] normals = [${Nh(n.normal, o)}] (
            interpolation = "vertex"
        )`
  ) : ""}
        point3f[] points = [${Nh(n.position, o)}]
        ${n.uv ? `texCoord2f[] primvars:st = [${Mv(n.uv, o, !0)}] (
            interpolation = "vertex"
        )` : ""}
		${n.uv1 ? If("st1", n.uv1) : ""}
		${n.uv2 ? If("st2", n.uv2) : ""}
		${n.uv3 ? If("st3", n.uv3) : ""}
		${d ? `matrix4d primvars:skel:geomBindTransform = ( (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1) ) (
				elementSize = 1
				interpolation = "constant"
			)` : ""}
		${n.skinIndex ? `int[] primvars:skel:jointIndices = [${M_(h, !0)}] (
			elementSize = 4
			interpolation = "vertex"
		)` : ""}
		${n.skinWeight ? `float[] primvars:skel:jointWeights = [${M_(n.skinWeight)}] (
			elementSize = 4
			interpolation = "vertex"
		)` : ""}
		${n.color ? `color3f[] primvars:displayColor = [${Nh(n.color, o)}] (
			interpolation = "vertex"
		)` : ""}
        uniform token subdivisionScheme = "none"
    }
}
${t ? `
# This is a workaround for QuickLook/RealityKit not supporting the doubleSided attribute. We're adding a second
# geometry definition here, that uses the same mesh data but appends extra faces with reversed winding order.
def "${i}_doubleSided" (
	prepend references = </Geometry>
)
{
	over "Geometry"
	{
		int[] faceVertexCounts = [${Ef(s) + ", " + Ef(s)}]
		int[] faceVertexIndices = [${Af(s) + ", " + Af(s, !0)}]
	}
}
` : ""}
`;
}
function Ef(s) {
  const e = s.index !== null ? s.index.count : s.attributes.position.count;
  return Array(Math.floor(e / 3)).fill(3).join(", ");
}
function Af(s, e = !1) {
  const t = s.index, i = [];
  if (t !== null)
    for (let n = 0; n < t.count; n++) {
      let o = n;
      e && (o = n % 3 === 0 ? n + 2 : n % 3 === 2 ? n - 2 : n), i.push(t.getX(o));
    }
  else {
    const n = s.attributes.position.count;
    for (let o = 0; o < n; o++) {
      let r = o;
      e && (r = o % 3 === 0 ? o + 2 : o % 3 === 2 ? o - 2 : o), i.push(r);
    }
  }
  return i.join(", ");
}
function If(s, e) {
  const t = e.itemSize;
  switch (t) {
    case 2:
      return `texCoord2f[] primvars:${s} = [${Mv(e, t, !0)}] (
				interpolation = "vertex"
			)`;
    case 3:
      return `texCoord3f[] primvars:${s} = [${Nh(e, t)}] (
				interpolation = "vertex"
			)`;
    case 4:
      return `double4[] primvars:${s} = [${XM(e, t)}] (
				interpolation = "vertex"
			)`;
    default:
      return console.warn("USDZExporter: Attribute with " + t + " components are currently not supported. Results may be undefined for " + s + "."), "";
  }
}
function Nh(s, e) {
  if (s === void 0)
    return console.warn("USDZExporter: A mesh attribute is missing and will be set with placeholder data. The result may look incorrect."), Array(e).fill("(0, 0, 1)").join(", ");
  const t = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), r = s.getZ(i);
    t.push(`(${n.toPrecision(Oe)}, ${o.toPrecision(Oe)}, ${r.toPrecision(Oe)})`);
  }
  return t.join(", ");
}
function XM(s, e) {
  if (s === void 0)
    return console.warn("USDZExporter: Attribute is missing. Results may be undefined."), Array(e).fill("(0, 0, 0, 0)").join(", ");
  const t = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), r = s.getZ(i) || 0, a = s.getW(i) || 0;
    t.push(`(${n.toPrecision(Oe)}, ${o.toPrecision(Oe)}, ${r.toPrecision(Oe)}, ${a.toPrecision(Oe)})`);
  }
  return t.join(", ");
}
function M_(s, e = !1) {
  const t = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), r = s.getZ(i), a = s.getW(i);
    t.push(`${e ? n : n.toPrecision(Oe)}`), t.push(`${e ? o : o.toPrecision(Oe)}`), t.push(`${e ? r : r.toPrecision(Oe)}`), t.push(`${e ? a : a.toPrecision(Oe)}`);
  }
  return t.join(", ");
}
function Mv(s, e, t = !1) {
  if (s === void 0)
    return console.warn("USDZExporter: UVs missing."), Array(e).fill("(0, 0)").join(", ");
  const i = [];
  for (let n = 0; n < s.count; n++) {
    const o = s.getX(n);
    let r = s.getY(n);
    t && (r = 1 - r), i.push(`(${o.toPrecision(Oe)}, ${r.toPrecision(Oe)})`);
  }
  return i.join(", ");
}
function QM(s, e, t = !1) {
  const i = [];
  for (const n in s) {
    const o = s[n];
    i.push(YM(o, e, t));
  }
  return `
	def "Materials"
    {
${i.join("")}
    }`;
}
function Li(s) {
  return cn(s.name) + "_" + (s.source?.id ?? s.id);
}
function Fs(s, e, t, i, n, o, r = void 0, a = void 0) {
  const l = Li(s), c = l + (a !== void 0 && a !== 1 ? "_" + a : ""), h = t && a !== void 0 && a !== 1, d = h ? new de(1, 1, 1, a) : void 0;
  a === void 0 && (a = 1), h && (a = 1), d && d.w <= 0.05 && (d.w = 0.05), i[c] = { texture: s, scale: d };
  const f = s.channel > 0 ? "st" + s.channel : "st";
  o.add(s.channel);
  const p = ag.includes(s.format), g = {
    1e3: "repeat",
    // RepeatWrapping
    1001: "clamp",
    // ClampToEdgeWrapping
    1002: "mirror"
    // MirroredRepeatWrapping
  }, _ = s.repeat.clone(), m = s.offset.clone(), v = s.rotation, y = Math.sin(v), x = Math.cos(v);
  m.y = 1 - m.y - _.y, t ? (_.x === 0 && (_.x = 1e-4), _.y === 0 && (_.y = 1e-4), m.x = m.x / _.x, m.y = m.y / _.y, m.x += y / _.x, m.y += x - 1) : (m.x += y * _.x, m.y += (1 - x) * _.y);
  const I = cu(n), O = _.x != 1 || _.y != 1 || m.x != 0 || m.y != 0 || v != 0, k = `${Ut}/${I}/${"uvReader_" + f}.outputs:result>`, E = `${Ut}/${I}/Transform2d_${e}.outputs:result>`, z = e !== "normal" && r && (r.r !== 1 || r.g !== 1 || r.b !== 1 || a !== 1) || !1, D = e === "normal", V = n instanceof ct && n.normalScale ? n.normalScale.x * 2 : 2, q = V.toFixed(Oe), A = (-1 * (V / 2)).toFixed(Oe), U = (1 - V).toFixed(Oe);
  return `
		${O ? `def Shader "Transform2d_${e}" (
			sdrMetadata = {
				string role = "math"
			}
		)
		{
			uniform token info:id = "UsdTransform2d"
			float2 inputs:in.connect = ${k}
			float2 inputs:scale = ${T_(_)}
			float2 inputs:translation = ${T_(m)}
			float inputs:rotation = ${(v / Math.PI * 180).toFixed(Oe)}
			float2 outputs:result
		}
		` : ""}
		def Shader "${l}_${e}"
		{
			uniform token info:id = "UsdUVTexture"
			asset inputs:file = @textures/${c}.${p ? "png" : "jpg"}@
			token inputs:sourceColorSpace = "${s.colorSpace === "srgb" ? "sRGB" : "raw"}"
			float2 inputs:st.connect = ${O ? E : k}
			${z ? `
			float4 inputs:scale = (${r ? r.r + ", " + r.g + ", " + r.b : "1, 1, 1"}, ${a})
			` : ""}
			${D ? `
			float4 inputs:scale = (${q}, ${q}, ${q}, 1)
			float4 inputs:bias = (${A}, ${A}, ${U}, 0)
			` : ""}
			token inputs:wrapS = "${g[s.wrapS]}"
			token inputs:wrapT = "${g[s.wrapT]}"
			float outputs:r
			float outputs:g
			float outputs:b
			float3 outputs:rgb
			${n.transparent || n.alphaTest > 0 ? "float outputs:a" : ""}
		}`;
}
function YM(s, e, t = !1) {
  const i = cu(s);
  if (s.colorWrite === !1 || s.userData?.isShadowCatcherMaterial || s.userData?.isLightBlendMaterial) {
    const f = s.userData.isLightBlendMaterial || s.userData.isShadowCatcherMaterial ? "ND_realitykit_shadowreceiver_surfaceshader" : "ND_realitykit_occlusion_surfaceshader";
    return `

		def Material "${i}" ${s.name ? `(
			displayName = "${s.name}"
		)` : ""}
		{
			token outputs:mtlx:surface.connect = ${Ut}/${i}/Occlusion.outputs:out>

			def Shader "Occlusion"
			{
				uniform token info:id = "${f}"
				token outputs:out
			}
		}`;
  }
  const o = "                ", r = [], a = [], l = /* @__PURE__ */ new Set();
  if (s.isMeshPhysicalNodeMaterial === !0)
    return MM(s, i, e);
  let c = s.transparent || s.alphaTest ? s.opacity : 1, h = !1, d = !1;
  if (s instanceof op && s.transmission !== void 0 && (c *= 1 - s.transmission * (1 - s.roughness * 0.5)), s.map ? (r.push(`${o}color3f inputs:diffuseColor.connect = ${Ut}/${i}/${Li(s.map)}_diffuse.outputs:rgb>`), s instanceof we && s.transparent && s.alphaTest == 0 && t ? (r.push(`${o}float inputs:opacity.connect = ${Ut}/${i}/${Li(s.map)}_diffuse.outputs:a>`), h = !0, r.push(`${o}float inputs:opacityThreshold = ${1e-10}`), d = !0) : s.transparent ? (r.push(`${o}float inputs:opacity.connect = ${Ut}/${i}/${Li(s.map)}_diffuse.outputs:a>`), h = !0) : s.alphaTest > 0 && (r.push(`${o}float inputs:opacity.connect = ${Ut}/${i}/${Li(s.map)}_diffuse.outputs:a>`), h = !0, r.push(`${o}float inputs:opacityThreshold = ${s.alphaTest}`), d = !0), a.push(Fs(s.map, "diffuse", t, e, s, l, s.color, c))) : r.push(`${o}color3f inputs:diffuseColor = ${R_(s.color)}`), s.alphaHash && t && (d ? console.warn("Opacity threshold for " + s.name + " was already connected. Skipping alphaHash opacity threshold.") : (r.push(`${o}float inputs:opacityThreshold = 0.0000000001`), d = !0)), s.aoMap && (r.push(`${o}float inputs:occlusion.connect = ${Ut}/${i}/${Li(s.aoMap)}_occlusion.outputs:r>`), a.push(Fs(s.aoMap, "occlusion", t, e, s, l))), s.alphaMap ? (r.push(`${o}float inputs:opacity.connect = ${Ut}/${i}/${Li(s.alphaMap)}_opacity.outputs:r>`), r.push(`${o}float inputs:opacityThreshold = 0.0000000001`), h = !0, d = !0, a.push(Fs(s.alphaMap, "opacity", t, e, s, l, new se(1, 1, 1), c))) : (h ? console.warn("Opacity for " + s.name + " was already connected. Skipping default opacity.") : (r.push(`${o}float inputs:opacity = ${c}`), h = !0), s.alphaTest > 0 && (d ? console.warn("Opacity threshold for " + s.name + " was already connected. Skipping default opacity threshold.") : (r.push(`${o}float inputs:opacityThreshold = ${s.alphaTest}`), d = !0))), s instanceof ct) {
    if (s.emissiveMap) {
      r.push(`${o}color3f inputs:emissiveColor.connect = ${Ut}/${i}/${Li(s.emissiveMap)}_emissive.outputs:rgb>`);
      const f = s.emissive.clone();
      f.multiplyScalar(s.emissiveIntensity), a.push(Fs(s.emissiveMap, "emissive", t, e, s, l, f));
    } else if (s.emissive?.getHex() > 0) {
      const f = s.emissive.clone();
      f.multiplyScalar(s.emissiveIntensity), r.push(`${o}color3f inputs:emissiveColor = ${R_(f)}`);
    }
    s.normalMap && (r.push(`${o}normal3f inputs:normal.connect = ${Ut}/${i}/${Li(s.normalMap)}_normal.outputs:rgb>`), a.push(Fs(s.normalMap, "normal", t, e, s, l))), s.roughnessMap && s.roughness === 1 ? (r.push(`${o}float inputs:roughness.connect = ${Ut}/${i}/${Li(s.roughnessMap)}_roughness.outputs:g>`), a.push(Fs(s.roughnessMap, "roughness", t, e, s, l))) : r.push(`${o}float inputs:roughness = ${s.roughness !== void 0 ? s.roughness : 1}`), s.metalnessMap && s.metalness === 1 ? (r.push(`${o}float inputs:metallic.connect = ${Ut}/${i}/${Li(s.metalnessMap)}_metallic.outputs:b>`), a.push(Fs(s.metalnessMap, "metallic", t, e, s, l))) : r.push(`${o}float inputs:metallic = ${s.metalness !== void 0 ? s.metalness : 0}`);
  }
  return s instanceof op && (r.push(`${o}float inputs:clearcoat = ${s.clearcoat}`), r.push(`${o}float inputs:clearcoatRoughness = ${s.clearcoatRoughness}`), r.push(`${o}float inputs:ior = ${s.ior}`), !s.transparent && !(s.alphaTest > 0) && s.transmissionMap && (r.push(`${o}float inputs:opacity.connect = ${Ut}/${i}/${Li(s.transmissionMap)}_transmission.outputs:r>`), a.push(Fs(s.transmissionMap, "transmission", t, e, s, l)))), l.size > 2 ? console.warn("USDZExporter: Material " + s.name + " uses more than 2 UV channels. Currently, only UV0 and UV1 are supported.") : l.size === 2 && (!l.has(0) || !l.has(1)) && console.warn("USDZExporter: Material " + s.name + " uses UV channels other than 0 and 1. Currently, only UV0 and UV1 are supported."), `

		def Material "${i}" ${s.name ? `(
			displayName = "${vv(s.name)}"
		)` : ""}
		{
			token outputs:surface.connect = ${Ut}/${i}/PreviewSurface.outputs:surface>

			def Shader "PreviewSurface"
			{
				uniform token info:id = "UsdPreviewSurface"
${r.join(`
`)}
				int inputs:useSpecularWorkflow = ${s instanceof we ? "1" : "0"}
				token outputs:surface
			}
${a.length > 0 ? `
${l.has(0) ? `
			def Shader "uvReader_st"
			{
				uniform token info:id = "UsdPrimvarReader_float2"
				token inputs:varname = "st"
				float2 inputs:fallback = (0.0, 0.0)
				float2 outputs:result
			}
` : ""}
${l.has(1) ? `
			def Shader "uvReader_st1"
			{
				uniform token info:id = "UsdPrimvarReader_float2"
				token inputs:varname = "st1"
				float2 inputs:fallback = (0.0, 0.0)
				float2 outputs:result
			}
` : ""}
${a.join(`
`)}` : ""}
		}`;
}
function R_(s) {
  return `(${s.r}, ${s.g}, ${s.b})`;
}
function T_(s) {
  return `(${s.x}, ${s.y})`;
}
const ag = [
  // uncompressed formats with alpha channel
  1023,
  // RGBAFormat
  // compressed formats with alpha channel
  33777,
  // RGBA_S3TC_DXT1_Format
  33778,
  // RGBA_S3TC_DXT3_Format
  33779,
  // RGBA_S3TC_DXT5_Format
  35842,
  // RGBA_PVRTC_4BPPV1_Format
  35843,
  // RGBA_PVRTC_2BPPV1_Format
  37496,
  // RGBA_ETC2_EAC_Format
  37808,
  // RGBA_ASTC_4x4_Format
  37809,
  // RGBA_ASTC_5x4_Format
  37810,
  // RGBA_ASTC_5x5_Format
  37811,
  // RGBA_ASTC_6x5_Format
  37812,
  // RGBA_ASTC_6x6_Format
  37813,
  // RGBA_ASTC_8x5_Format
  37814,
  // RGBA_ASTC_8x6_Format
  37815,
  // RGBA_ASTC_8x8_Format
  37816,
  // RGBA_ASTC_10x5_Format
  37817,
  // RGBA_ASTC_10x6_Format
  37818,
  // RGBA_ASTC_10x8_Format
  37819,
  // RGBA_ASTC_10x10_Format
  37820,
  // RGBA_ASTC_12x10_Format
  37821,
  // RGBA_ASTC_12x12_Format
  36492
  // RGBA_BPTC_Format
];
w("debugusdz");
class Et {
  static global_id = 0;
  id;
  trigger;
  action;
  exclusive = !1;
  makeExclusive(e) {
    return this.exclusive = e, this;
  }
  constructor(e, t, i) {
    this.id = "Behavior_" + cn(e) + "_" + Et.global_id++, this.trigger = t, this.action = i;
  }
  writeTo(e, t, i) {
    if (!this.trigger || !this.action) return;
    i.beginBlock(`def Preliminary_Behavior "${this.id}"`);
    let n = "";
    if (Array.isArray(this.trigger)) {
      n = "[";
      for (let o = 0; o < this.trigger.length; o++) {
        const r = this.trigger[o];
        n += "<" + r.id + ">", o + 1 < this.trigger.length && (n += ", ");
      }
      n += "]";
    } else
      n = `<${this.trigger.id}>`;
    if (i.appendLine(`rel triggers = ${n}`), i.appendLine(`rel actions = <${this.action.id}>`), i.appendLine(`uniform bool exclusive = ${this.exclusive ? 1 : 0}`), i.appendLine(), Array.isArray(this.trigger))
      for (const o of this.trigger)
        o.writeTo(t, i), i.appendLine();
    else
      this.trigger.writeTo(t, i);
    i.appendLine(), this.action.writeTo(t, i), i.closeBlock();
  }
}
const Lr = /* @__PURE__ */ new Set();
function Np(s, e) {
  let t = "";
  if (Array.isArray(s)) {
    Lr.clear();
    let i = "[ ";
    for (let n = 0; n < s.length; n++) {
      let o = s[n];
      if (!o) {
        console.warn("Invalid target object in behavior", s + ". Is the object exported?");
        continue;
      }
      if (typeof o == "string") {
        if (Lr.has(o)) continue;
        i += o, Lr.add(o);
      } else if (typeof o == "object") {
        if (o.isObject3D && (o = e.findById(o.uuid), !o)) {
          console.warn("Invalid target object in behavior", s + ". Is the object exported?");
          continue;
        }
        const r = o.getPath?.call(o);
        if (Lr.has(r)) continue;
        i += r, Lr.add(r);
      }
      n + 1 < s.length && (i += ", ");
    }
    i += " ]", t = i, Lr.clear();
  } else if (typeof s == "object") {
    const i = s;
    if (i.isObject3D && (s = e.findById(i.uuid)), !s)
      throw console.error("Invalid target object in behavior, the target object is likely missing from USDZ export. Is the object exported?", i), new Error(`Invalid target object in behavior, the target object is likely missing from USDZ export. Please report a bug. uuid: ${i.uuid}.`);
    t = s.getPath?.call(s);
  }
  return t;
}
class tr {
  static global_id = 0;
  id;
  targetId;
  tokenId;
  type;
  distance;
  constructor(e, t) {
    e && (this.targetId = e), t ? this.id = t : this.id = "Trigger_" + tr.global_id++;
  }
  writeTo(e, t) {
    t.beginBlock(`def Preliminary_Trigger "${this.id}"`), this.targetId && (typeof this.targetId != "string" && (this.targetId = Np(this.targetId, e)), t.appendLine("rel affectedObjects = " + this.targetId)), this.tokenId && t.appendLine(`token info:id = "${this.tokenId}"`), this.type && t.appendLine(`token type = "${this.type}"`), typeof this.distance == "number" && t.appendLine(`double distance = ${this.distance}`), t.closeBlock();
  }
}
function E_(s, e = { direct: !0, indirect: !0 }) {
  const t = st.createEmpty();
  t.name = "InputTarget_" + t.name, t.displayName = void 0, t.type = "RealityKitComponent", t.onSerialize = (i) => {
    i.appendLine("bool allowsDirectInput = " + (e.direct ? 1 : 0)), i.appendLine("bool allowsIndirectInput = " + (e.indirect ? 1 : 0)), i.appendLine('uniform token info:id = "RealityKit.InputTarget"');
  }, s.add(t);
}
class Vt {
  static __sceneStartTrigger;
  static sceneStartTrigger() {
    if (this.__sceneStartTrigger !== void 0) return this.__sceneStartTrigger;
    const e = new tr(void 0, "SceneStart");
    return e.tokenId = "SceneTransition", e.type = "enter", this.__sceneStartTrigger = e, e;
  }
  /** Trigger that fires when an object has been tapped/clicked.
   * @param targetObject The object or list of objects that can be interacted with.
   * @param inputMode Input Mode (direct and/or indirect). Only available for USDObject targets. Only supported on Vision OS at the moment. */
  static tapTrigger(e, t = { direct: !0, indirect: !0 }) {
    const i = new tr(e);
    if (Array.isArray(e) && e.length > 1)
      for (const n of e)
        n instanceof st && E_(n, t);
    else
      e instanceof st && E_(e, t);
    return i.tokenId = "TapGesture", i;
  }
  static isTapTrigger(e) {
    return e?.tokenId === "TapGesture";
  }
  static proximityToCameraTrigger(e, t) {
    const i = new tr(e);
    return i.tokenId = "ProximityToCamera", i.distance = t, i;
  }
}
class Xr {
  static global_id = 0;
  static getId() {
    return this.global_id++;
  }
  id;
  actions;
  loops = 0;
  performCount = 1;
  type = "serial";
  multiplePerformOperation = void 0;
  constructor(e, t) {
    this.id = e, this.actions = t;
  }
  addAction(e) {
    return this.actions.push(e), this;
  }
  makeParallel() {
    return this.type = "parallel", this;
  }
  makeSequence() {
    return this.type = "serial", this;
  }
  makeLooping() {
    return this.loops = 1, this.performCount = 0, this;
  }
  makeRepeat(e) {
    return this.performCount = e, this;
  }
  writeTo(e, t) {
    t.beginBlock(`def Preliminary_Action "${this.id}"`), t.beginArray("rel actions");
    for (const i of this.actions) {
      if (!i) continue;
      const n = i === this.actions[this.actions.length - 1];
      t.appendLine("<" + i.id + ">" + (n ? "" : ", "));
    }
    t.closeArray(), t.appendLine(), t.appendLine('token info:id = "Group"'), t.appendLine(`bool loops = ${this.loops}`), t.appendLine(`int performCount = ${this.loops > 0 ? 0 : Math.max(0, this.performCount)}`), t.appendLine(`token type = "${this.type}"`), typeof this.multiplePerformOperation == "string" && t.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`), t.appendLine();
    for (const i of this.actions)
      i && (i.writeTo(e, t), t.appendLine());
    t.closeBlock();
  }
}
class ai {
  static global_id = 0;
  id;
  tokenId;
  affectedObjects;
  easeType;
  motionType = void 0;
  duration;
  moveDistance;
  style;
  type;
  // combined types of different actions
  front;
  up;
  start;
  animationSpeed;
  reversed;
  pingPong;
  xFormTarget;
  audio;
  gain;
  auralMode;
  multiplePerformOperation;
  velocity;
  // extra info written as comment at the beginning of the action
  comment;
  animationName;
  clone() {
    const e = new ai(), t = e.id;
    return Object.assign(e, this), e.id = t, e;
  }
  constructor(e, t) {
    e && (this.affectedObjects = e), t ? this.id = t : this.id = "Action", this.id += "_" + ai.global_id++;
  }
  writeTo(e, t) {
    t.beginBlock(`def Preliminary_Action "${this.id}"`), this.comment && t.appendLine(`# ${this.comment}`), this.affectedObjects && (typeof this.affectedObjects != "string" && (this.affectedObjects = Np(this.affectedObjects, e)), t.appendLine("rel affectedObjects = " + this.affectedObjects)), typeof this.duration == "number" && (typeof this.animationSpeed == "number" && this.animationSpeed !== 1 ? t.appendLine(`double duration = ${this.duration / this.animationSpeed} `) : t.appendLine(`double duration = ${this.duration} `)), this.easeType && t.appendLine(`token easeType = "${this.easeType}"`), this.tokenId && t.appendLine(`token info:id = "${this.tokenId}"`), this.tokenId === "ChangeScene" && t.appendLine("rel scene = </StageRoot/Scenes/Scene>"), this.motionType !== void 0 && t.appendLine(`token motionType = "${this.motionType}"`), typeof this.moveDistance == "number" && t.appendLine(`double moveDistance = ${this.moveDistance} `), this.style && t.appendLine(`token style = "${this.style}"`), this.type && t.appendLine(`token type = "${this.type}"`), this.front && t.appendLine(`vector3d front = (${this.front.x}, ${this.front.y}, ${this.front.z})`), this.up && t.appendLine(`vector3d upVector = (${this.up.x}, ${this.up.y}, ${this.up.z})`), typeof this.start == "number" && t.appendLine(`double start = ${this.start} `), typeof this.animationSpeed == "number" && t.appendLine(`double animationSpeed = ${this.animationSpeed.toFixed(2)} `), typeof this.reversed == "boolean" && t.appendLine(`bool reversed = ${this.reversed}`), typeof this.pingPong == "boolean" && t.appendLine(`bool reverses = ${this.pingPong}`), this.xFormTarget && (typeof this.xFormTarget != "string" && (this.xFormTarget = Np(this.xFormTarget, e)), t.appendLine(`rel xformTarget = ${this.xFormTarget}`)), typeof this.audio == "string" && t.appendLine(`asset audio = @${this.audio}@`), typeof this.gain == "number" && t.appendLine(`double gain = ${this.gain}`), typeof this.auralMode == "string" && t.appendLine(`token auralMode = "${this.auralMode}"`), typeof this.multiplePerformOperation == "string" && t.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`), typeof this.velocity == "object" && t.appendLine(`vector3d velocity = (${this.velocity.x}, ${this.velocity.y}, ${this.velocity.z})`), t.closeBlock();
  }
}
class Fi {
  x = 0;
  y = 0;
  z = 0;
  constructor(e, t, i) {
    this.x = e, this.y = t, this.z = i;
  }
  static get up() {
    return new Fi(0, 1, 0);
  }
  static get right() {
    return new Fi(1, 0, 0);
  }
  static get forward() {
    return new Fi(0, 0, 1);
  }
  static get back() {
    return new Fi(0, 0, -1);
  }
  static get zero() {
    return new Fi(0, 0, 0);
  }
}
class fe {
  static sequence(...e) {
    return new Xr("Group_" + Xr.getId(), e).makeSequence();
  }
  static parallel(...e) {
    return new Xr("Group_" + Xr.getId(), e).makeParallel();
  }
  static fadeAction(e, t, i) {
    const n = new ai(e);
    return n.tokenId = "Visibility", n.type = i ? "show" : "hide", n.duration = t, n.style = "basic", n.motionType = "none", n.moveDistance = 0, n.easeType = "none", n;
  }
  /**
   * creates an action that plays an animation
   * @param start offset in seconds!
   * @param duration in seconds! 0 means play to end
   */
  static startAnimationAction(e, t, i = !1, n = !1) {
    const o = new ai(e);
    o.tokenId = "StartAnimation";
    const r = t.start, a = t.duration, l = t.speed, c = t.clipName;
    if (o.comment = `Animation: ${c}, start=${r * 60}, length=${a * 60}, end=${(r + a) * 60}`, o.animationName = c, o.start = r, o.duration = a, o.animationSpeed = l, o.reversed = i, o.pingPong = n, o.multiplePerformOperation = "allow", i && (o.start -= a), n) {
      o.pingPong = !1;
      const h = o.clone();
      return h.reversed = !i, h.start = o.start, h.reversed && (h.start -= a), fe.sequence(o, h);
    }
    return o;
  }
  static waitAction(e) {
    const t = new ai();
    return t.tokenId = "Wait", t.duration = e, t.motionType = void 0, t;
  }
  static lookAtCameraAction(e, t, i, n) {
    const o = new ai(e);
    return o.tokenId = "LookAtCamera", o.duration = t === void 0 ? 9999999999999 : t, o.front = i ?? Fi.forward, o.up = n ?? Fi.up, o;
  }
  static emphasize(e, t, i = "bounce", n = 1, o = "basic") {
    const r = new ai(e);
    return r.tokenId = "Emphasize", r.duration = t, r.style = o ?? "basic", r.motionType = i, r.moveDistance = n, r;
  }
  static transformAction(e, t, i, n, o = "inout") {
    const r = new ai(e);
    return r.tokenId = "Transform", r.duration = i, r.duration = Math.max(1e-6, i), r.type = n, r.easeType = i > 0 ? o : "none", Array.isArray(t) && console.error("Transform target must not be an array", t), r.xFormTarget = t, r;
  }
  static playAudioAction(e, t, i = "play", n = 1, o = "spatial") {
    const r = new ai(e);
    return r.tokenId = "Audio", r.type = i, r.audio = t, r.gain = n, r.auralMode = o, r.multiplePerformOperation = "allow", r;
  }
  // Supported only on VisionOS, Preliminary Behaviours can affect RealityKit physics as well
  static impulseAction(e, t) {
    const i = new ai(e);
    return i.tokenId = "Impulse", i.velocity = t, i;
  }
  // Currently doesn't work on VisionOS, see FB13761990
  /*
  static reloadSceneAction() {
      const act = new ActionModel();
      act.tokenId = "ChangeScene";
      // rel scene = ... is implicit since we only allow one scene right now
      return act;
  }
  */
}
class KM {
  get id() {
    return this.object.uuid;
  }
  object;
  model;
  constructor(e) {
    this.object = e;
  }
  apply(e) {
    if (!this.model && (this.model = e.findById(this.object.uuid), !this.model)) {
      console.error("could not find model with id " + this.object.uuid);
      return;
    }
    this.onApply(e);
  }
}
class Rv extends KM {
  constructor(e, t, i, n) {
    super(e), this.matrix = t, this.material = i, this.geometry = n;
  }
  matrix;
  material;
  geometry;
  onApply(e) {
    const t = this.model;
    if (!t) return;
    t.parent?.isDynamic || st.createEmptyParent(t);
    const i = t.clone();
    this.matrix && i.setMatrix(this.matrix), this.material && (i.material = this.material), this.geometry && (i.geometry = this.geometry), t.parent?.add(i);
  }
  _enableAction;
  _disableAction;
  enable() {
    return this._enableAction ? this._enableAction : (this._enableAction = fe.fadeAction(this.object, 0, !0), this._enableAction);
  }
  disable() {
    return this._disableAction ? this._disableAction : (this._disableAction = fe.fadeAction(this.object, 0, !1), this._disableAction);
  }
}
class ZM {
  actions;
  sortedActions;
  constructor(e) {
    this.actions = [...e];
  }
  // organize is called once when getting an action for the first time
  // the sorted actions are baked then and adding new actions will not be added anymore
  organize() {
    this.sortedActions = {};
    for (const e of this.actions) {
      const t = e.id;
      this.sortedActions[t] || (this.sortedActions[t] = []), this.sortedActions[t].push(e);
    }
  }
  /** returns all document actions affecting the object passed in */
  getActions(e) {
    return this.sortedActions || this.organize(), this.sortedActions[e.uuid];
  }
}
const Sn = w("debugusdzanimation"), $p = w("debugusdzanimationserialization");
class qo {
  _start;
  get start() {
    return this._start === void 0 && (this._start = this.ext.getStartTimeByClip(this.clip)), this._start;
  }
  get duration() {
    return this.clip?.duration ?? Ue.restPoseClipDuration;
  }
  get nearestAnimatedRoot() {
    return this._nearestAnimatedRoot;
  }
  get clipName() {
    return this.clip?.name ?? "rest";
  }
  ext;
  root;
  _nearestAnimatedRoot = void 0;
  clip;
  // Playback speed. Does not affect how the animation is written, just how fast actions play it back.
  speed;
  constructor(e, t, i) {
    this.ext = e, this.root = t, this.clip = i, this._nearestAnimatedRoot = this.getNearestAnimatedRoot();
  }
  static isDescendantOf(e, t) {
    let i = t;
    if (!i || !e) return !1;
    for (; i; ) {
      if (!i) return !1;
      if (i === e) return !0;
      i = i.parent;
    }
    return !1;
  }
  /** Finds the nearest actually animated object under root based on the tracks in the AnimationClip. */
  getNearestAnimatedRoot() {
    let e;
    try {
      for (const t of this.clip?.tracks ?? []) {
        const i = ca.parseTrackName(t.name);
        let n = ca.findNode(this.root, i.nodeName);
        if (n)
          if (!e) e = n;
          else {
            if (n === e || qo.isDescendantOf(e, n)) continue;
            if (!qo.isDescendantOf(n, e)) {
              for (; !qo.isDescendantOf(n, e) && n.parent; )
                n = n.parent;
              qo.isDescendantOf(n, e) || console.error("USDZExporter: Animation clip targets multiple roots that are not parent/child. Please report a bug", this.root, this.clip, e, n);
            }
            e = n;
          }
      }
    } catch (t) {
      console.error("USDZExporter: Exception when trying to find nearest animated root. Please report a bug", t), e = void 0;
    }
    return e;
  }
}
class Ue {
  clip;
  pos;
  rot;
  scale;
  root;
  target;
  duration = 0;
  useRootMotion = !1;
  /** This value can theoretically be anything – a value of 1 is good to clearly see animation gaps.
   * For production, a value of 1/60 is enough, since the files can then still properly play back at 60fps.
   */
  static frameRate = 60;
  static animationDurationPadding = 6 / 60;
  static restPoseClipDuration = 6 / 60;
  constructor(e, t, i) {
    if (this.root = e, this.target = t, this.clip = i, i ? this.duration = i.duration : this.duration = Ue.restPoseClipDuration, i && i.tracks) {
      const o = Math.max(...i.tracks.map((r) => r.times[r.times.length - 1]));
      o !== this.duration && (console.warn("USDZExporter: Animation clip duration does not match the maximum time value in the tracks.", i, o, this.duration), this.duration = o);
    }
    const n = S.getComponent(e, At);
    n && (this.useRootMotion = n.applyRootMotion);
  }
  addTrack(e) {
    if (!this.clip) {
      console.error("This is a rest clip but you're trying to add tracks to it – this is likely a bug");
      return;
    }
    e.name.endsWith("position") ? this.pos = e : e.name.endsWith("quaternion") ? this.rot = e : e.name.endsWith("scale") ? this.scale = e : (e.name.endsWith("activeSelf") ? console.warn("[USDZ] Animation of enabled/disabled state is not supported for USDZ export and will NOT be exported: " + e.name + " on " + (this.root?.name ?? this.target.name) + ". Animate scale 0/1 instead.") : console.warn("[USDZ] Animation track type not supported for USDZ export and will NOT be exported: " + e.name + " on " + (this.root?.name ?? this.target.name) + ". Only .position, .rotation, .scale are supported."), L() && ge("[USDZ] Some animations can't be exported. See console for details."));
  }
  getFrames() {
    return this.clip ? Math.max(this.pos?.times?.length ?? 0, this.rot?.times?.length ?? 0, this.scale?.times?.length ?? 0) : 2;
  }
  getDuration() {
    return this.duration;
  }
  getSortedTimesArray(e = !0, t = !0, i = !0) {
    if (!this.clip) return [0, this.duration];
    const n = this.pos?.times, o = this.rot?.times, r = this.scale?.times, a = [];
    if (e && n) for (const l of n) a.push(l);
    if (t && o) for (const l of o) a.push(l);
    if (i && r) for (const l of r) a.push(l);
    return a.includes(0) || a.push(0), a.sort((l, c) => l - c), [...new Set(a)];
  }
  /**
   * Returns an iterator that yields the values for each time sample. 
   * Values are reused objects - if you want to append them to some array 
   * instead of processing them right away, clone() them.
   * @param timesArray 
   * @param generatePos 
   * @param generateRot 
   * @param generateScale 
   */
  *getValues(e, t = !0, i = !0, n = !0) {
    const o = new b(), r = new $(), a = new b(1, 1, 1), l = this.target, c = t ? this.pos?.createInterpolant() : void 0, h = i ? this.rot?.createInterpolant() : void 0, d = n ? this.scale?.createInterpolant() : void 0;
    c || o.set(l.position.x, l.position.y, l.position.z), h || r.set(l.quaternion.x, l.quaternion.y, l.quaternion.z, l.quaternion.w), d || a.set(l.scale.x, l.scale.y, l.scale.z), c && c.valueSize !== 3 && (c.valueSize = 3), h && h.valueSize !== 4 && (h.valueSize = 4), d && d.valueSize !== 3 && (d.valueSize = 3);
    const f = 0;
    for (let p = 0 - f; p < e.length + f; p++) {
      let g = 0, _ = 0;
      if (p < 0 ? (g = e[0], _ = g - Ue.animationDurationPadding / 2 + 1 / 60) : p >= e.length ? (g = e[e.length - 1], _ = g + Ue.animationDurationPadding / 2 - 1 / 60) : (g = e[p], _ = g), c) {
        const m = c.evaluate(g);
        o.set(m[0], m[1], m[2]);
      }
      if (h) {
        const m = h.evaluate(g);
        r.set(m[0], m[1], m[2], m[3]);
      }
      if (d) {
        const m = d.evaluate(g);
        a.set(m[0], m[1], m[2]);
      }
      if (this.useRootMotion && l === this.root) {
        const m = new te();
        m.compose(o, r, a), m.multiply(l.matrix), m.decompose(o, r, a);
      }
      yield { time: _, translation: o, rotation: r, scale: a, index: p };
    }
  }
}
class lg {
  get extensionName() {
    return "animation";
  }
  get animationData() {
    return this.dict;
  }
  get registeredClips() {
    return this.clipToStartTime.keys();
  }
  get animatedRoots() {
    return this.rootTargetMap.keys();
  }
  get holdClipMap() {
    return this.clipToHoldClip;
  }
  /** For each animated object, contains time/pos/rot/scale samples in the format that USD needs,
   *  ready to be written to the .usda file.
   */
  dict = /* @__PURE__ */ new Map();
  /** Map of all roots (Animation/Animator or scene) and all targets that they animate.
   *  We need that info so that we can ensure that each target has the same number of TransformData entries
   *  so that switching between animations doesn't result in data "leaking" to another clip.
   */
  rootTargetMap = /* @__PURE__ */ new Map();
  rootAndClipToRegisteredAnimationMap = /* @__PURE__ */ new Map();
  /** Clips registered for each root */
  rootToRegisteredClip = /* @__PURE__ */ new Map();
  lastClipEndTime = 0;
  clipToStartTime = /* @__PURE__ */ new Map();
  clipToHoldClip = /* @__PURE__ */ new Map();
  serializers = [];
  /** Determines if we inject a rest pose clip for each root - only makes sense for QuickLook */
  injectRestPoses = !1;
  /** Determines if we inject a PlayAnimationOnClick component with "scenestart" trigger - only makes sense for QuickLook */
  injectImplicitBehaviours = !1;
  constructor(e) {
    this.injectRestPoses = e, this.injectImplicitBehaviours = e;
  }
  getStartTimeCode() {
    return !this.injectRestPoses || this.rootAndClipToRegisteredAnimationMap.size === 0 ? 0 : (Ue.restPoseClipDuration + Ue.animationDurationPadding) * 60;
  }
  /** Returns the end time code, based on 60 frames per second, for all registered animations.
   * This matches the highest time value in the USDZ file. */
  getEndTimeCode() {
    let e = 0;
    for (const [t, i] of this.rootAndClipToRegisteredAnimationMap) {
      const n = i.start + i.duration;
      n > e && (e = n);
    }
    return e * 60;
  }
  getClipCount(e) {
    return this.rootToRegisteredClip.get(e)?.length ?? 0 ?? 0;
  }
  /*
      // TODO why do we have this here and on TransformData? Can RegisteredAnimationInfo not cache this value?
      // TODO we probably want to assert here that this is the same value on all nodes
      getStartTime01(root: Object3D, clip: AnimationClip | null) {
          // This is a rest pose clip, it always starts at 0
          if (!clip) return 0;
  
          const targets = this.rootTargetMap.get(root);
          if (!targets) return 0;
          const transformDatas = this.dict.get(targets[0]);
          if (!transformDatas) {
              console.error("Trying to get start time for root that has no animation data", root, clip, ...this.dict);
              return 0;
          }
  
          let currentStartTime = 0;
          for (let i = 0; i < transformDatas.length; i++) {
              if (transformDatas[i].clip === clip) break;
              currentStartTime += transformDatas[i].getDuration() + TransformData.animationDurationPadding;
          }
  
          return currentStartTime;
      }
      */
  getStartTimeByClip(e) {
    return e ? this.clipToStartTime.has(e) ? this.clipToStartTime.get(e) : (console.error("USDZExporter: Missing start time for clip – please report a bug.", e), 0) : 0;
  }
  // The same clip could be registered for different roots. All of them need written animation data then.
  // The same root could have multiple clips registered to it. If it does, the clips need to write
  // independent time data, so that playing back an animation on that root doesn't result in data "leaking"/"overlapping".
  // The structure we need is:
  // - MyRoot
  //   Animator
  //     - Clip1: CubeScale (only animates MyCube), duration: 3s
  //     - Clip2: SphereRotation (only animates MySphere), duration: 2s
  //   - MyCube
  //   - MySphere
  // Results in:
  // - MyRoot
  //   - MyCube
  //     - # rest clip (0..0.1)
  //     - # CubeScale (0.2..3.2)
  //     - # rest clip for SphereRotation (3.3..5.3)
  //   - MySphere
  //     - # rest clip (0..0.1)
  //     - # rest clip for CubeScale (0.2..3.2)
  //     - # SphereRotation (3.3..5.3)
  /** Register an AnimationClip for a specific root object.
   * @param root The root object that the animation clip is targeting.
   * @param clip The animation clip to register. If null, a rest pose is registered.
   * @returns The registered animation info, which contains the start time and duration of the clip.
   */
  registerAnimation(e, t) {
    if (!e) return null;
    this.rootTargetMap.has(e) || this.rootTargetMap.set(e, []);
    const i = e.uuid + (t?.uuid ?? "-rest");
    if (this.rootAndClipToRegisteredAnimationMap.has(i))
      return this.rootAndClipToRegisteredAnimationMap.get(i);
    Sn && console.log("registerAnimation", e, t);
    const n = this.injectRestPoses ? 1 : 0, o = (this.rootToRegisteredClip.get(e)?.length ?? 0) + n, r = this.rootTargetMap.get(e), a = new Set(r);
    if (t && t.tracks)
      for (const c of t.tracks) {
        const h = ca.parseTrackName(c.name), d = ca.findNode(e, h.nodeName);
        if (!d) {
          console.warn("no object found for track", c.name, "using " + e.name + " instead");
          continue;
        }
        this.dict.has(d) || this.dict.set(d, []);
        const f = this.dict.get(d);
        if (!f) {
          console.warn("no transform data found for target ", d, "at slot " + o + ", this is likely a bug");
          continue;
        }
        a.delete(d), this.injectRestPoses && !f[0] && (console.log("Injecting rest pose", d, t, "at slot", o), f[0] = new Ue(null, d, null));
        let p = f[o];
        p || (p = new Ue(e, d, t), f[o] = p), p.addTrack(c), r?.includes(d) || r?.push(d);
      }
    Sn && console.log("Unregistered nodes for this clip", a, "clip", t, "at slot", o, "for root", e, "targets", r);
    for (const c of a) {
      const h = this.dict.get(c);
      if (!h) continue;
      if (this.injectRestPoses && !h[0]) {
        console.warn("Adding rest pose for ", c, t, "at slot", o, "This is likely a bug, should have been added earlier.");
        const f = new Ue(null, c, null);
        h[0] = f;
      }
      let d = h[o];
      d || (Sn && console.log("Adding padding clip for ", c, t, "at slot", o), d = new Ue(e, c, t), h[o] = d);
    }
    const l = new qo(this, e, t);
    if (this.rootAndClipToRegisteredAnimationMap.set(i, l), Sn && console.log({ root: e, clip: t, info: l }), t) {
      const c = this.rootToRegisteredClip.get(e);
      if (c ? c.push(t) : this.rootToRegisteredClip.set(e, [t]), !this.clipToStartTime.get(t)) {
        this.lastClipEndTime == null && (this.lastClipEndTime = Ue.restPoseClipDuration);
        let d = this.lastClipEndTime + Ue.animationDurationPadding, f = d + t.duration;
        const p = Math.round(d * 60) / 60, g = Math.round(f * 60) / 60;
        Math.abs(p - d) < 0.01 && (d = p), Math.abs(g - f) < 0.01 && (f = g), d = Math.ceil(d), f = d + t.duration, this.clipToStartTime.set(t, d), this.lastClipEndTime = f;
      }
    }
    return l;
  }
  onAfterHierarchy(e) {
    Sn && console.log("Animation clips per animation target node", this.dict);
  }
  onAfterBuildDocument(e) {
    Sn && console.log("Animation data", { dict: this.dict, rootTargetMap: this.rootTargetMap, rootToRegisteredClip: this.rootToRegisteredClip });
    for (const t of this.rootTargetMap.keys()) {
      const i = this.rootTargetMap.get(t);
      if (!i) continue;
      let n;
      const o = [];
      for (const r of i) {
        const a = this.dict.get(r);
        if (!a) {
          console.error("No data found for target on USDZ export – please report a bug!", r);
          continue;
        }
        n === void 0 && (n = a?.length), n !== a?.length && console.error("Different array lengths for targets – please report a bug!", a);
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (!c) {
            const d = l - (this.injectRestPoses ? 1 : 0);
            a[l] = new Ue(null, r, this.rootToRegisteredClip.get(t)[d]), c = a[l];
          }
          const h = c.getDuration();
          if (o[l] === void 0) o[l] = h;
          else if (o[l] !== h) {
            console.error("Error during UDSZ export: Encountered different animation durations for animated targets. Please report a bug!", { datas: a, target: r }), o[l] = h;
            continue;
          }
        }
      }
    }
    for (const t of this.serializers) {
      const i = t.model?.parent, n = i?.isDynamic === !0;
      $p && console.log(n, t.model?.parent), n && t.registerCallback(i);
    }
  }
  onExportObject(e, t, i) {
    S.foreachComponent(e, (o) => {
      const r = o;
      typeof r.createAnimation == "function" && r.createAnimation(this, t, i);
    }, !1);
    const n = new JM(e, this);
    this.serializers.push(n), n.registerCallback(t);
  }
}
class JM {
  model = void 0;
  object;
  animationData;
  ext;
  callback;
  constructor(e, t) {
    this.object = e, this.animationData = t.animationData, this.ext = t;
  }
  registerCallback(e) {
    this.model && this.callback && this.model.removeEventListener("serialize", this.callback), this.callback || (this.callback = this.onSerialize.bind(this)), $p && console.log("REPARENT", e), this.model = e, this.callback && this.model.addEventListener("serialize", this.callback);
  }
  skinnedMeshExport(e, t, i) {
    const n = this.model, o = this.animationData;
    if (n && n.skinnedMesh) {
      let r = function(A) {
        const U = [];
        for (const [W, ne] of A) {
          let re = `${W} : [`;
          const ue = [];
          for (const Se of ne)
            ue.push(`(${ae(Se.x)}, ${ae(Se.y)}, ${ae(Se.z)})`);
          re = re.concat(ue.join(", ")), re = re.concat("],"), U.push(re);
        }
        return U;
      }, a = function(A) {
        const U = [];
        for (const [W, ne] of A) {
          let re = `${W} : [`;
          const ue = [];
          for (const Se of ne)
            ue.push(`(${ae(Se.w)}, ${ae(Se.x)}, ${ae(Se.y)}, ${ae(Se.z)})`);
          re = re.concat(ue.join(", ")), re = re.concat("],"), U.push(re);
        }
        return U;
      }, l = function(A) {
        let U, W = !0;
        const ne = /* @__PURE__ */ new Map();
        for (const [ue, Se] of A) {
          U === void 0 && (U = Se.length), U !== Se.length && (W = !1);
          let Je = 0;
          for (const ki of Se)
            Je++, ki || (ne.has(ue) || ne.set(ue, []), ne.get(ue).push(Je));
        }
        Sn && console.log("Bone count: ", A.size, "TransformData entries per bone: ", U, "Undefined bone entries: ", ne), console.assert(W, "All bones should have the same number of TransformData entries", A), console.assert(ne.size === 0, "All TransformData entries should be set", ne);
        const re = [];
        for (const [ue, Se] of A)
          for (let Je = 0; Je < Se.length; Je++) {
            const ki = Se[Je], Vc = i.getStartTimeByClip(ki.clip);
            re.length <= Je && re.push({ pos: [], rot: [], scale: [], timeOffset: Vc });
            const Ds = re[Je];
            Ds.pos.push(...ki.getSortedTimesArray(!0, !1, !1)), Ds.rot.push(...ki.getSortedTimesArray(!1, !0, !1)), Ds.scale.push(...ki.getSortedTimesArray(!1, !1, !0));
          }
        for (const ue of re)
          ue.pos.sort((Se, Je) => Se - Je), ue.rot.sort((Se, Je) => Se - Je), ue.scale.sort((Se, Je) => Se - Je), ue.pos = [...new Set(ue.pos)], ue.rot = [...new Set(ue.rot)], ue.scale = [...new Set(ue.scale)];
        return re;
      }, c = function(A, U, W) {
        const ne = /* @__PURE__ */ new Map(), re = /* @__PURE__ */ new Map(), ue = /* @__PURE__ */ new Map(), Se = U.length;
        for (const Je of W) {
          const ki = A.get(Je);
          let Vc;
          ki ? console.assert(ki.length === Se, "We should have the same number of TransformData entries for each bone", ki, U) : Vc = new Ue(null, Je, null);
          for (let Ds = 0; Ds < Se; Ds++) {
            const Wu = ki ? ki[Ds] : Vc, kr = U[Ds];
            for (const { time: Ya, translation: Ka } of Wu.getValues(kr.pos, !0, !1, !1)) {
              const Ki = (Ya + kr.timeOffset) * 60;
              ne.has(Ki) || ne.set(Ki, new Array()), ne.get(Ki).push(Ka.clone());
            }
            for (const { time: Ya, rotation: Ka } of Wu.getValues(kr.rot, !1, !0, !1)) {
              const Ki = (Ya + kr.timeOffset) * 60;
              re.has(Ki) || re.set(Ki, new Array()), re.get(Ki).push(Ka.clone());
            }
            for (const { time: Ya, scale: Ka } of Wu.getValues(kr.scale, !1, !1, !0)) {
              const Ki = (Ya + kr.timeOffset) * 60;
              ue.has(Ki) || ue.set(Ki, new Array()), ue.get(Ki).push(Ka.clone());
            }
          }
        }
        return {
          position: ne.size == 0 ? void 0 : ne,
          quaternion: re.size == 0 ? void 0 : re,
          scale: ue.size == 0 ? void 0 : ue
        };
      }, h = function(A) {
        const U = [];
        for (const W of A)
          U.push(`(${ae(W.x)}, ${ae(W.y)}, ${ae(W.z)})`);
        return U.join(", ");
      }, d = function(A) {
        const U = [];
        for (const W of A)
          U.push(`(${ae(W.w)}, ${ae(W.x)}, ${ae(W.y)}, ${ae(W.z)})`);
        return U.join(", ");
      }, f = function(A) {
        const U = /* @__PURE__ */ new Map();
        if (Sn) {
          const W = new Array();
          for (const [ne, re] of o)
            W.push(ne.uuid + ": " + re.length + " " + re.map((ue) => ue.clip?.uuid.substring(0, 6)).join(" "));
          console.log(`getPerBoneTransformData
` + W.join(`
`));
        }
        for (const W of A) {
          const ne = o.get(W);
          ne && U.set(W, ne);
        }
        return U;
      }, p = function(A) {
        const U = f(A), W = l(U);
        return c(U, W, A);
      };
      const g = n.skinnedMesh.skeleton, _ = new Array(), m = [], v = [];
      for (const A of g.bones) {
        m.push(A), v.push(A.uuid);
        const U = g.boneInverses[g.bones.indexOf(A)];
        _.push({ bone: A, inverse: U });
      }
      let y = 1e4;
      for (; v.length < g.bones.length && y-- > 0; )
        for (const A of m) {
          const U = A.children;
          for (const W of U)
            if (v.indexOf(W.uuid) === -1 && g.bones.indexOf(W) !== -1) {
              m.push(W), v.push(W.uuid);
              const ne = g.boneInverses[g.bones.indexOf(W)];
              _.push({ bone: W, inverse: ne });
            }
        }
      y <= 0 && console.error("Failed to sort bones in skinned mesh", n.skinnedMesh, g.bones, v);
      for (const A of xv(g.bones))
        _.push({ bone: A, inverse: A.matrixWorld.clone().invert() });
      const x = _[0].bone.parent;
      x || console.error("No bone parent found for skinned mesh during USDZ export", n.skinnedMesh), _.sort((A, U) => aa(A.bone, x) > aa(U.bone, x) ? 1 : -1);
      const I = t.quickLookCompatible, O = [], k = [], E = [], z = [];
      for (const { bone: A } of _) {
        if (I) {
          const U = A.scale;
          U.x == 0 && (U.x = 1e-5), U.y == 0 && (U.y = 1e-5), U.z == 0 && (U.z = 1e-5), O.push(new te().compose(A.position, A.quaternion, A.scale));
        } else
          O.push(A.matrix.clone());
        k.push(A.position), E.push(A.quaternion), z.push(A.scale);
      }
      const D = _.map((A) => '"' + aa(A.bone, x) + '"').join(", "), V = _.map((A) => k_(A.inverse.clone().invert())).join(", ");
      e.beginBlock('def Skeleton "Rig"'), e.appendLine(`uniform matrix4d[] bindTransforms = [${V}]`), e.appendLine(`uniform token[] joints = [${D}]`), e.appendLine('uniform token purpose = "guide"'), e.appendLine(`uniform matrix4d[] restTransforms = [${O.map((A) => k_(A)).join(", ")}]`);
      const q = p(_.map((A) => A.bone));
      if (Sn) {
        let A = 1e7, U = 0;
        for (const W of q.position?.keys() ?? [])
          A = Math.min(A, W), U = Math.max(U, W);
        console.log("Time samples", A, U, q);
      }
      if (e.beginBlock('def SkelAnimation "_anim"'), e.appendLine(`uniform token[] joints = [${D}]`), e.appendLine(`quatf[] rotations = [${d(E)}]`), q && q.quaternion) {
        e.beginBlock("quatf[] rotations.timeSamples = {", "");
        const A = a(q.quaternion);
        for (const U of A)
          e.appendLine(U);
        e.closeBlock();
      }
      if (e.appendLine(`half3[] scales = [${h(z)}]`), q && q.scale) {
        e.beginBlock("half3[] scales.timeSamples = {", "");
        const A = r(q.scale);
        for (const U of A)
          e.appendLine(U);
        e.closeBlock();
      }
      if (e.appendLine(`float3[] translations = [${h(k)}]`), q && q.position) {
        e.beginBlock("float3[] translations.timeSamples = {", "");
        const A = r(q.position);
        for (const U of A)
          e.appendLine(U);
        e.closeBlock();
      }
      e.closeBlock(), e.closeBlock();
    }
  }
  onSerialize(e, t) {
    if (!this.model) return;
    const i = this.animationData.get(this.object);
    if (i)
      for (let h = 0; h < i.length; h++)
        i[h] === void 0 && (i[h] = new Ue(null, this.object, null));
    const n = this.ext;
    this.skinnedMeshExport(e, t, n);
    const o = this.object, r = this.model, a = this.animationData.get(o);
    if (!a || o.isSkinnedMesh) return;
    $p && console.log("SERIALIZE", this.model.name, this.object.type, a);
    const l = Intl.NumberFormat("en-US", {
      maximumFractionDigits: 3,
      minimumFractionDigits: 0,
      useGrouping: !1
    });
    function c(h, d) {
      if (h.some((p) => p && {
        position: p.pos,
        rotation: p.rot,
        scale: p.scale
      }[d])) {
        switch (d) {
          case "position":
            r.needsTranslate = !0, e.beginBlock("double3 xformOp:translate.timeSamples = {", "");
            break;
          case "rotation":
            r.needsOrient = !0, e.beginBlock("quatf xformOp:orient.timeSamples = {", "");
            break;
          case "scale":
            r.needsScale = !0, e.beginBlock("double3 xformOp:scale.timeSamples = {", "");
            break;
        }
        for (let p = 0; p < h.length; p++) {
          const g = h[p];
          if (!g) continue;
          const _ = n.getStartTimeByClip(g.clip), m = g.getSortedTimesArray(d === "position", d === "rotation", d === "scale");
          if (!m || m.length === 0) {
            console.error("got an animated object but no time values?", o, g);
            continue;
          }
          const v = !g.clip, y = d === "position" && (g.pos || v), x = d === "rotation" && (g.rot || v), I = d === "scale" && (g.scale || v);
          if (y || x || I) {
            const O = g.clip?.name ?? "rest", k = g.getDuration();
            Sn && console.log("Write .timeSamples:", O, _, k, h), e.appendLine("# " + O + ": start=" + l.format(_ * Ue.frameRate) + ", length=" + l.format(k * Ue.frameRate) + ", frames=" + g.getFrames());
          }
          if (y)
            for (const { time: O, translation: k } of g.getValues(m, !0, !1, !1)) {
              const z = `${l.format((_ + O) * Ue.frameRate)}: (${ae(k.x)}, ${ae(k.y)}, ${ae(k.z)}),`;
              e.appendLine(z);
            }
          if (x)
            for (const { time: O, rotation: k } of g.getValues(m, !1, !0, !1)) {
              const z = `${l.format((_ + O) * Ue.frameRate)}: (${ae(k.w)}, ${ae(k.x)}, ${ae(k.y)}, ${ae(k.z)}),`;
              e.appendLine(z);
            }
          if (I)
            for (const { time: O, scale: k } of g.getValues(m, !1, !1, !0)) {
              const z = `${l.format((_ + O) * Ue.frameRate)}: (${ae(k.x)}, ${ae(k.y)}, ${ae(k.z)}),`;
              e.appendLine(z);
            }
        }
        e.closeBlock();
      }
    }
    c(a, "position"), c(a, "rotation"), c(a, "scale");
  }
}
const eR = w("debugusdz");
class La {
  static getName(e) {
    const t = e.split(".").pop();
    let n = e.split(".").slice(0, -1).join(".").split("/").pop()?.replace(".", "_");
    return n || (n = "Audio_" + Math.random().toString(36).substring(2, 15)), cn(n) + "." + t;
  }
  get extensionName() {
    return "Audio";
  }
  files = new Array();
  onExportObject(e, t, i) {
    const n = S.getComponents(e, ln);
    if (n.length)
      for (const o of n) {
        if (!o.clip || typeof o.clip != "string" || !o.playOnAwake)
          continue;
        const r = o.clip.split("/").pop() || "Audio", a = La.getName(o.clip), l = cn(a);
        if (!this.files.some((c) => c.path === o.clip)) {
          this.files.push({ path: o.clip, name: a });
          const c = a.toLowerCase();
          i.quickLookCompatible && !c.endsWith(".mp3") && !c.endsWith(".wav") && !c.endsWith(".m4a") && console.error("Audio file " + o.clip + " from " + o.name + " is not an MP3 or WAV file. QuickLook may not support playing it.");
        }
        i.quickLookCompatible || t.addEventListener("serialize", (c, h) => {
          c.appendLine(), c.beginBlock(`def SpatialAudio "${l}"`, "(", !1), c.appendLine(`displayName = "${r}"`), c.closeBlock(")"), c.beginBlock(), c.appendLine(`uniform asset filePath = @audio/${a}@`), c.appendLine(`uniform token auralMode = "${o.spatialBlend > 0 ? "spatial" : "nonSpatial"}"`), c.appendLine(`uniform token playbackMode = "${o.loop ? "loopFromStage" : "onceFromStart"}"`), c.appendLine(`uniform float gain = ${o.volume}`), c.closeBlock();
        });
      }
  }
  async onAfterSerialize(e) {
    for (const t of this.files) {
      const i = "audio/" + t.name;
      if (e.files[i]) {
        eR && console.warn("Audio file with name " + i + " already exists in the context. Skipping.");
        continue;
      }
      const r = await (await (await fetch(t.path)).blob()).arrayBuffer(), a = new Uint8Array(r);
      e.files[i] = a;
    }
  }
}
var tR = Object.defineProperty, Fe = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && tR(e, t, n), n;
};
const A_ = w("debugusdzbehaviours");
function xc(s) {
  s && (s.getComponentInParent(Sa) || (L() && console.debug('Raycaster on "' + s.name + '" was automatically added, because no raycaster was found in the parent hierarchy.'), s.addComponent(Vi)));
}
class Da extends T {
  object;
  target;
  duration = 1;
  relativeMotion = !1;
  coroutine = null;
  targetPos = new b();
  targetRot = new $();
  targetScale = new b();
  start() {
    xc(this.gameObject);
  }
  onPointerClick(e) {
    e.use(), this.coroutine && this.stopCoroutine(this.coroutine), this.relativeMotion ? this.coroutine = this.startCoroutine(this.moveRelative()) : this.coroutine = this.startCoroutine(this.moveToTarget());
  }
  *moveToTarget() {
    if (!this.target || !this.object) return;
    const e = Z(this.object).clone(), t = Z(this.target).clone(), i = be(this.object).clone(), n = be(this.target).clone(), o = $e(this.object).clone(), r = $e(this.target).clone(), a = e.distanceTo(t), l = i.angleTo(n), c = o.distanceTo(r);
    if (a < 0.01 && l < 0.01 && c < 0.01) {
      ut(this.object, t), an(this.object, n), tc(this.object, r), this.coroutine = null;
      return;
    }
    let h = 0, d = 0;
    for (; h < 1; )
      h += this.context.time.deltaTime / this.duration, h > 1 && (h = 1), d = h < 0.5 ? 4 * h * h * h : 1 - Math.pow(-2 * h + 2, 3) / 2, this.targetPos.lerpVectors(e, t, d), this.targetRot.slerpQuaternions(i, n, d), this.targetScale.lerpVectors(o, r, d), ut(this.object, this.targetPos), an(this.object, this.targetRot), tc(this.object, this.targetScale), yield;
    this.coroutine = null;
  }
  *moveRelative() {
    if (!this.target || !this.object) return;
    const e = this.object.position.clone(), t = this.object.quaternion.clone(), i = this.object.scale.clone(), n = this.target.position.clone(), o = this.target.quaternion.clone(), r = this.target.scale.clone();
    n.applyQuaternion(this.object.quaternion), this.targetPos.copy(this.object.position).add(n), this.targetRot.copy(this.object.quaternion).multiply(o), this.targetScale.copy(this.object.scale).multiply(r);
    let a = 0, l = 0;
    for (; a < 1; )
      a += this.context.time.deltaTime / this.duration, a > 1 && (a = 1), l = a < 0.5 ? 4 * a * a * a : 1 - Math.pow(-2 * a + 2, 3) / 2, this.object.position.lerpVectors(e, this.targetPos, l), this.object.quaternion.slerpQuaternions(t, this.targetRot, l), this.object.scale.lerpVectors(i, this.targetScale, l), yield;
    this.coroutine = null;
  }
  beforeCreateDocument(e) {
    if (this.target && this.object && this.gameObject) {
      const t = new Et(
        "Move to " + this.target?.name,
        Vt.tapTrigger(this.gameObject),
        fe.transformAction(this.object, this.target, this.duration, this.relativeMotion ? "relative" : "absolute")
      );
      e.addBehavior(t);
    }
  }
}
Fe([
  u(M)
], Da.prototype, "object");
Fe([
  u(M)
], Da.prototype, "target");
Fe([
  u()
], Da.prototype, "duration");
Fe([
  u()
], Da.prototype, "relativeMotion");
const hu = class zt extends T {
  materialToSwitch;
  variantMaterial;
  fadeDuration = 0;
  start() {
    this._objectsWithThisMaterial = this.objectsWithThisMaterial, xc(this.gameObject), L() && this._objectsWithThisMaterial.length <= 0 && console.warn('ChangeMaterialOnClick: No objects found with material "' + this.materialToSwitch?.name + '"');
  }
  onPointerEnter(e) {
    this.context.input.setCursor("pointer");
  }
  onPointerExit(e) {
    this.context.input.unsetCursor("pointer");
  }
  onPointerClick(e) {
    if (e.use(), !!this.variantMaterial)
      for (let t = 0; t < this.objectsWithThisMaterial.length; t++) {
        const i = this.objectsWithThisMaterial[t];
        i.material = this.variantMaterial;
      }
  }
  _objectsWithThisMaterial = null;
  /** Get all objects in the scene that have the assigned materialToSwitch */
  get objectsWithThisMaterial() {
    return this._objectsWithThisMaterial != null ? this._objectsWithThisMaterial : (this._objectsWithThisMaterial = [], this.variantMaterial && this.materialToSwitch && this.context.scene.traverse((e) => {
      if (e instanceof H)
        if (Array.isArray(e.material)) {
          for (const t of e.material)
            if (t === this.materialToSwitch) {
              this.objectsWithThisMaterial.push(e);
              break;
            }
        } else
          e.material === this.materialToSwitch ? this.objectsWithThisMaterial.push(e) : hP(e.material, this.materialToSwitch) && this.objectsWithThisMaterial.push(e);
    }), this._objectsWithThisMaterial);
  }
  selfModel;
  targetModels;
  static _materialTriggersPerId = {};
  static _startHiddenBehaviour = null;
  static _parallelStartHiddenActions = [];
  async beforeCreateDocument(e, t) {
    this.targetModels = [], zt._materialTriggersPerId = {}, zt.variantSwitchIndex = 0, this.materialToSwitch && await We.assignTextureLOD(this.materialToSwitch, 0), this.variantMaterial && await We.assignTextureLOD(this.variantMaterial, 0);
  }
  createBehaviours(e, t, i) {
    this.objectsWithThisMaterial.find((o) => o.uuid === t.uuid) && this.targetModels.push(t), this.gameObject.uuid === t.uuid && (this.selfModel = t, this.materialToSwitch && (zt._materialTriggersPerId[this.materialToSwitch.uuid] || (zt._materialTriggersPerId[this.materialToSwitch.uuid] = []), zt._materialTriggersPerId[this.materialToSwitch.uuid].push(this)));
  }
  afterCreateDocument(e, t) {
    if (!this.materialToSwitch) return;
    const i = zt._materialTriggersPerId[this.materialToSwitch.uuid];
    if (i) {
      const n = {};
      for (const o of i) {
        const r = o.createVariants();
        r && r.length > 0 && (n[o.selfModel.uuid] = r);
      }
      for (const o of i) {
        const r = [];
        for (const a in n)
          a !== o.selfModel.uuid && r.push(...n[a]);
        o.createAndAttachBehaviors(e, n[o.selfModel.uuid], r);
      }
    }
    delete zt._materialTriggersPerId[this.materialToSwitch.uuid];
  }
  createAndAttachBehaviors(e, t, i) {
    const n = [], o = Math.max(0, this.fadeDuration);
    n.push(fe.fadeAction([...this.targetModels, ...i], o, !1)), n.push(fe.fadeAction(t, o, !0)), e.addBehavior(
      new Et(
        "Select_" + this.selfModel.name,
        Vt.tapTrigger(this.selfModel),
        fe.parallel(...n)
      )
    ), zt._parallelStartHiddenActions.push(...t), zt._startHiddenBehaviour || (zt._startHiddenBehaviour = new Et(
      "StartHidden_" + this.selfModel.name,
      Vt.sceneStartTrigger(),
      fe.fadeAction(zt._parallelStartHiddenActions, o, !1)
    ), e.addBehavior(zt._startHiddenBehaviour));
  }
  static getMaterialName(e) {
    return cn(e.name || "Material") + "_" + e.id;
  }
  static variantSwitchIndex = 0;
  createVariants() {
    if (!this.variantMaterial) return null;
    const e = [];
    for (const t of this.targetModels) {
      const i = t.clone();
      i.name += "_Variant_" + zt.variantSwitchIndex++ + "_" + zt.getMaterialName(this.variantMaterial), i.displayName = i.displayName + ": Variant with material " + this.variantMaterial.name, i.material = this.variantMaterial, i.geometry = t.geometry, i.transform = t.transform, (!t.parent || !t.parent.isEmpty()) && st.createEmptyParent(t), t.parent && t.parent.add(i), e.push(i);
    }
    return e;
  }
};
Fe([
  u(_e)
], hu.prototype, "materialToSwitch");
Fe([
  u(_e)
], hu.prototype, "variantMaterial");
Fe([
  u()
], hu.prototype, "fadeDuration");
let Tv = hu;
const Sc = class Ae extends T {
  target;
  toggleOnClick = !1;
  targetState = !0;
  hideSelf = !0;
  start() {
    xc(this.gameObject);
  }
  onPointerClick(e) {
    e.use(), !this.toggleOnClick && this.hideSelf && (this.gameObject.visible = !1), this.target && (this.target.visible = this.toggleOnClick ? !this.target.visible : this.targetState);
  }
  selfModel;
  selfModelClone;
  targetModel;
  toggleModel;
  createBehaviours(e, t, i) {
    t.uuid === this.gameObject.uuid && (this.selfModel = t, this.selfModelClone = t.clone());
  }
  stateBeforeCreatingDocument = !1;
  targetStateBeforeCreatingDocument = !1;
  static clonedToggleIndex = 0;
  static wasVisible = Symbol("usdz_SetActiveOnClick_wasVisible");
  static toggleClone = Symbol("clone for toggling");
  static reverseToggleClone = Symbol("clone for reverse toggling");
  beforeCreateDocument() {
    this.target && (this.gameObject[Ae.wasVisible] === void 0 && (this.gameObject[Ae.wasVisible] = this.gameObject.activeSelf), this.target[Ae.wasVisible] === void 0 && (this.target[Ae.wasVisible] = this.target.activeSelf), this.stateBeforeCreatingDocument = this.gameObject[Ae.wasVisible], this.targetStateBeforeCreatingDocument = this.target[Ae.wasVisible], this.gameObject.visible = !0, this.target.visible = !0);
  }
  afterCreateDocument(e, t) {
    if (!this.target) return;
    this.targetModel = t.document.findById(this.target.uuid);
    const i = this.selfModel;
    if (this.selfModel && this.targetModel) {
      let n = this.selfModel, o = this.targetState;
      if (this.toggleOnClick)
        if (o = !this.targetStateBeforeCreatingDocument, !this.selfModelClone.geometry)
          (!this.selfModel.parent || this.selfModel.parent.isEmpty()) && Sv.createEmptyParent(this.selfModel), this.toggleModel = this.selfModel.deepClone(), this.toggleModel.name += "_toggle", this.selfModel.parent.add(this.toggleModel);
        else {
          if (!this.gameObject[Ae.toggleClone]) {
            const l = this.selfModelClone.clone();
            l.setMatrix(new te()), l.name += "_toggle" + Ae.clonedToggleIndex++, i.add(l), this.gameObject[Ae.toggleClone] = l, console.warn("USDZExport: Toggle " + this.gameObject.name + " doesn't have geometry. It will be deep cloned and nested behaviours will likely not work.");
          }
          const a = this.gameObject[Ae.toggleClone];
          if (!this.gameObject[Ae.reverseToggleClone]) {
            const l = this.selfModelClone.clone();
            l.setMatrix(new te()), l.name += "_toggleReverse" + Ae.clonedToggleIndex++, i.add(l), this.gameObject[Ae.reverseToggleClone] = l;
          }
          this.toggleModel = this.gameObject[Ae.reverseToggleClone], (!this.toggleModel.geometry || !a.geometry) && console.error("triggers without childs and without geometry won't work!", this, i.geometry), n = a, i.geometry = null, i.material = null;
        }
      if (this.toggleModel) {
        if (this.toggleOnClick) {
          const a = [];
          a.push(fe.fadeAction(n, 0, !1)), a.push(fe.fadeAction(this.toggleModel, 0, !0)), a.push(fe.fadeAction(this.targetModel, 0, o)), e.addBehavior(new Et(
            "Toggle_" + n.name + "_ToggleTo" + (o ? "On" : "Off"),
            Vt.tapTrigger(n),
            fe.parallel(...a)
          ));
          const l = [];
          l.push(fe.fadeAction(this.toggleModel, 0, !1)), l.push(fe.fadeAction(n, 0, !0)), l.push(fe.fadeAction(this.targetModel, 0, !o)), e.addBehavior(new Et(
            "Toggle_" + n.name + "_ToggleTo" + (o ? "Off" : "On"),
            Vt.tapTrigger(this.toggleModel),
            fe.parallel(...l)
          ));
        }
      } else {
        const a = [];
        this.hideSelf && a.push(fe.fadeAction(n, 0, !1)), a.push(fe.fadeAction(this.targetModel, 0, o)), e.addBehavior(new Et(
          "Toggle_" + n.name + "_ToggleTo" + (o ? "On" : "Off"),
          Vt.tapTrigger(n),
          a.length > 1 ? fe.parallel(...a) : a[0]
        ));
      }
      const r = new Array();
      this.targetStateBeforeCreatingDocument || r.push(this.targetModel), this.stateBeforeCreatingDocument || r.push(i), this.toggleModel && r.push(this.toggleModel), tn.add(r, e);
    }
  }
  afterSerialize(e, t) {
    this.gameObject[Ae.wasVisible] !== void 0 && (this.gameObject.visible = this.gameObject[Ae.wasVisible], delete this.gameObject[Ae.wasVisible]), this.target && this.target[Ae.wasVisible] !== void 0 && (this.target.visible = this.target[Ae.wasVisible], delete this.target[Ae.wasVisible]), delete this.gameObject[Ae.toggleClone], delete this.gameObject[Ae.reverseToggleClone];
  }
};
Fe([
  u(M)
], Sc.prototype, "target");
Fe([
  u()
], Sc.prototype, "toggleOnClick");
Fe([
  u()
], Sc.prototype, "targetState");
Fe([
  u()
], Sc.prototype, "hideSelf");
let Ev = Sc;
class tn extends T {
  static _fadeBehaviour;
  static _fadeObjects = [];
  static add(e, t) {
    const i = Array.isArray(e) ? e : [e];
    for (const n of i)
      tn._fadeObjects.includes(n) || (console.log("adding hide on start", n), tn._fadeObjects.push(n));
    tn._fadeBehaviour === void 0 && (tn._fadeBehaviour = new Et(
      "HideOnStart",
      Vt.sceneStartTrigger(),
      //@ts-ignore
      fe.fadeAction(tn._fadeObjects, 0, !1)
    ), t.addBehavior(tn._fadeBehaviour));
  }
  start() {
    S.setActive(this.gameObject, !1);
  }
  createBehaviours(e, t, i) {
    t.uuid === this.gameObject.uuid && (this.wasVisible || tn.add(t, e));
  }
  wasVisible = !1;
  beforeCreateDocument() {
    this.wasVisible = S.isActiveSelf(this.gameObject);
  }
}
class Cc extends T {
  target;
  duration = 0.5;
  motionType = "bounce";
  beforeCreateDocument() {
  }
  createBehaviours(e, t, i) {
    if (this.target && t.uuid === this.gameObject.uuid) {
      const n = new Et(
        "emphasize " + this.name,
        Vt.tapTrigger(this.gameObject),
        fe.emphasize(this.target, this.duration, this.motionType, void 0, "basic")
      );
      e.addBehavior(n);
    }
  }
  afterCreateDocument(e, t) {
  }
}
Fe([
  u()
], Cc.prototype, "target");
Fe([
  u()
], Cc.prototype, "duration");
Fe([
  u()
], Cc.prototype, "motionType");
class rr extends T {
  target;
  clip = "";
  toggleOnClick = !1;
  // Not exposed, but used for implicit playback of PlayOnAwake audio sources
  trigger = "tap";
  start() {
    xc(this.gameObject);
  }
  ensureAudioSource() {
    if (!this.target) {
      const e = this.gameObject.addComponent(ln);
      e && (this.target = e, e.spatialBlend = 1, e.volume = 1, e.loop = !1, e.preload = !0);
    }
  }
  onPointerClick(e) {
    e.use(), !(!this.target?.clip && !this.clip) && (this.ensureAudioSource(), this.target && (this.target.isPlaying && this.toggleOnClick ? this.target.stop() : (!this.toggleOnClick && this.target.isPlaying && this.target.stop(), this.clip ? this.target.play(this.clip) : this.target.play())));
  }
  createBehaviours(e, t, i) {
    if (!(!this.target && !this.clip) && t.uuid === this.gameObject.uuid) {
      const n = this.clip ? this.clip : this.target ? this.target.clip : void 0;
      if (!n || typeof n != "string") return;
      const o = this.target ? this.target.gameObject : this.gameObject;
      La.getName(n);
      const r = this.target ? this.target.volume : 1, a = this.target && this.target.spatialBlend == 0 ? "nonSpatial" : "spatial";
      let l = !1;
      this.gameObject.traverse((f) => {
        f instanceof H && f.visible && (l = !0);
      }), l = !0;
      const c = e.addAudioClip(n);
      let h = fe.playAudioAction(o, c, "play", r, a);
      this.target && this.target.loop && (h = fe.sequence(h).makeLooping());
      const d = this.name ? "_" + this.name : "";
      if (l && this.trigger === "tap") {
        this.toggleOnClick && (h.multiplePerformOperation = "stop");
        const f = new Et(
          "playAudio" + d,
          Vt.tapTrigger(t),
          h
        );
        e.addBehavior(f);
      }
      if (this.target && this.target.playOnAwake && this.target.enabled)
        if (l && this.trigger === "tap")
          console.warn("USDZExport: Audio sources that are played on tap can't also auto-play at scene start due to a QuickLook bug.");
        else {
          const f = new Et(
            "playAudioOnStart" + d,
            Vt.sceneStartTrigger(),
            h
          );
          e.addBehavior(f);
        }
    }
  }
}
Fe([
  u(ln)
], rr.prototype, "target");
Fe([
  u(URL)
], rr.prototype, "clip");
Fe([
  u()
], rr.prototype, "toggleOnClick");
const cg = class yn extends T {
  animator;
  stateName;
  // Not editable from the outside yet, but from code
  // we want to expose this once we have a nice drawer for "Triggers" (e.g. shows proximity distance)
  // and once we rename the component to "PlayAnimation" or "PlayAnimationOnTrigger"
  trigger = "tap";
  // "proximity"
  animation;
  get target() {
    return this.animator?.gameObject || this.animation?.gameObject;
  }
  start() {
    xc(this.gameObject);
  }
  onPointerClick(e) {
    e.use(), this.target && this.stateName && this.animator?.play(this.stateName, 0, 0, 0.1);
  }
  selfModel;
  stateAnimationModel;
  animationSequence = new Array();
  animationLoopAfterSequence = new Array();
  randomOffsetNormalized = 0;
  createBehaviours(e, t, i) {
    t.uuid === this.gameObject.uuid && (this.selfModel = t);
  }
  static animationActions = [];
  static rootsWithExclusivePlayback = /* @__PURE__ */ new Set();
  // Cleanup. TODO This is not the best way as it's called multiple times (once for each component).
  afterSerialize() {
    if (yn.rootsWithExclusivePlayback.size > 1) {
      const e = 'Multiple root objects targeted by more than one animation. To work around QuickLook bug FB13410767, animations will be set as "exclusive" and activating them will stop other animations being marked as exclusive.';
      L() && ge(e), console.warn(e, ...yn.rootsWithExclusivePlayback);
    }
    yn.animationActions = [], yn.rootsWithExclusivePlayback = /* @__PURE__ */ new Set();
  }
  afterCreateDocument(e, t) {
    if (this.animationSequence === void 0 && this.animationLoopAfterSequence === void 0 || !this.stateAnimationModel || !this.target) return;
    const i = t.document, n = t.extensions.find((a) => a instanceof lg);
    if (!n) return;
    const o = n.getClipCount(this.target) > 1;
    o && (L() && console.warn("Setting exclusive playback for " + this.target.name + "@" + this.stateName + " because it has " + n.getClipCount(this.target) + " animations. This works around QuickLook bug FB13410767."), yn.rootsWithExclusivePlayback.add(this.target));
    const r = this.name ? this.name : "";
    i.traverse((a) => {
      if (a.uuid === this.target?.uuid) {
        const l = yn.getActionForSequences(
          i,
          a,
          this.animationSequence,
          this.animationLoopAfterSequence,
          this.randomOffsetNormalized
        ), c = new Et(
          this.trigger + "_" + r + "_toPlayAnimation_" + this.stateName + "_on_" + this.target?.name,
          this.trigger == "tap" ? Vt.tapTrigger(this.selfModel) : Vt.sceneStartTrigger(),
          l
        );
        o && c.makeExclusive(!0), e.addBehavior(c);
      }
    });
  }
  static getActionForSequences(e, t, i, n, o) {
    const r = (l, c) => {
      let h = yn.animationActions.find((d) => d.affectedObjects == l && d.start == c.start && d.duration == c.duration && d.animationSpeed == c.speed);
      return h || (h = fe.startAnimationAction(l, c), yn.animationActions.push(h)), h;
    }, a = fe.sequence();
    if (i && i.length > 0)
      for (const l of i)
        a.addAction(r(t, l));
    if (n && n.length > 0) {
      const l = a.actions.length == 0 ? a : fe.sequence();
      for (const c of n)
        l.addAction(r(t, c));
      l.makeLooping(), a !== l && a.addAction(l);
    }
    return o && o > 0 && a.actions.unshift(fe.waitAction(o)), a;
  }
  static getAndRegisterAnimationSequences(e, t, i) {
    if (!t) return;
    const n = t.getComponent(At), o = t.getComponent(bi);
    if (!n && !o) return;
    if (n && !i)
      throw new Error("PlayAnimationOnClick: No stateName specified for animator " + n.name + " on " + t.name);
    let r = [], a = [];
    if (o) {
      const g = e.registerAnimation(t, o.clip);
      g && (o.loop ? a.push(g) : r.push(g));
      let _ = 0;
      if (o.minMaxOffsetNormalized) {
        const m = o.minMaxOffsetNormalized.x, v = o.minMaxOffsetNormalized.y;
        _ = (o.clip?.duration || 1) * (m + Math.random() * (v - m));
      }
      return {
        animationSequence: r,
        animationLoopAfterSequence: a,
        randomTimeOffset: _
      };
    }
    const l = n?.runtimeAnimatorController;
    let c = l?.findState(i), h = [], d = [];
    if (l && c) {
      const g = new Array();
      g.push(c);
      let _ = !1;
      for (; g.length < 100; ) {
        if (!c || c === null || !c.transitions || c.transitions.length === 0) {
          c.motion?.isLooping && (_ = !0);
          break;
        }
        const m = c.transitions.find((y) => y.conditions.length === 0), v = m ? l.getState(m.destinationState, 0) : null;
        if (v && g.includes(v)) {
          c = v, _ = !0;
          break;
        } else if (m) {
          if (c = v, !c)
            break;
          g.push(c);
        } else {
          _ = c.motion?.isLooping ?? !1;
          break;
        }
      }
      if (_ && c) {
        const m = g.indexOf(c);
        h = g.slice(0, m), d = g.slice(m), A_ && console.log("found loop from " + i, "states until loop", h, "states looping", d);
      } else
        h = g, d = [], A_ && console.log("found no loop from " + i, "states", h);
      if (!d.length) {
        const m = h[h.length - 1], v = m.motion?.clip;
        if (v) {
          let y;
          if (e.holdClipMap.has(v))
            y = e.holdClipMap.get(v);
          else {
            const x = m.name + "_hold";
            y = v.clone(), y.duration = 1, y.name = x;
            const I = v.duration;
            y.tracks = v.tracks.map((O) => {
              const k = O.clone();
              k.times = new Float32Array([0, I]);
              const E = O.values.length, z = O.getValueSize(), D = O.values.slice(E - z, E);
              return k.values = new Float32Array(2 * z), k.values.set(D, 0), k.values.set(D, z), k;
            }), y.name = x, e.holdClipMap.set(v, y);
          }
          if (y) {
            const x = {
              name: y.name,
              motion: { clip: y, isLooping: !1, name: y.name },
              speed: 1,
              transitions: [],
              behaviours: [],
              hash: m.hash + 1
            };
            d.push(x);
          }
        }
      }
    }
    if (h.length === 1 && (!h[0].motion?.clip || h[0].motion?.clip.tracks?.length === 0)) {
      r = new Array();
      const g = e.registerAnimation(t, null);
      g && r.push(g);
      return;
    }
    if (h = h.filter((g) => g.motion?.clip && g.motion?.clip.tracks?.length > 0), d = d.filter((g) => g.motion?.clip && g.motion?.clip.tracks?.length > 0), h.length === 0 && d.length === 0) {
      console.warn("No clips found for state " + i + " on " + n?.name + ", can't export animation data");
      return;
    }
    const f = (g, _) => {
      if (!t) return;
      const m = e.registerAnimation(t, g.motion.clip ?? null);
      m ? (m.speed = g.speed, _.push(m)) : console.warn("Couldn't register animation for state " + g.name + " on " + n?.name);
    };
    if (h.length > 0) {
      r = new Array();
      for (const g of h)
        f(g, r);
    }
    if (d.length > 0) {
      a = new Array();
      for (const g of d)
        f(g, a);
    }
    let p = 0;
    if (n && l && n.minMaxOffsetNormalized) {
      const g = n.minMaxOffsetNormalized.x, _ = n.minMaxOffsetNormalized.y;
      p = ((h.length ? h[0] : d.length ? d[0] : null)?.motion.clip?.duration || 1) * (g + Math.random() * (_ - g));
    }
    return {
      animationSequence: r,
      animationLoopAfterSequence: a,
      randomTimeOffset: p
    };
  }
  createAnimation(e, t, i) {
    if (!this.target || !this.animator && !this.animation) return;
    const n = yn.getAndRegisterAnimationSequences(e, this.target, this.stateName);
    n && (this.animationSequence = n.animationSequence, this.animationLoopAfterSequence = n.animationLoopAfterSequence, this.randomOffsetNormalized = n.randomTimeOffset, this.stateAnimationModel = t);
  }
};
Fe([
  u(At)
], cg.prototype, "animator");
Fe([
  u()
], cg.prototype, "stateName");
let _d = cg;
class Pc extends T {
  getType() {
  }
  target;
  getDuration() {
  }
}
Fe([
  u(M)
], Pc.prototype, "target");
class du extends T {
  target;
}
Fe([
  u(Pc)
], du.prototype, "target");
class uu extends Pc {
  type = 1;
  duration = 1;
  getType() {
    switch (this.type) {
      case 1:
        return "hide";
      case 0:
        return "show";
    }
  }
  getDuration() {
    return this.duration;
  }
}
Fe([
  u()
], uu.prototype, "type");
Fe([
  u()
], uu.prototype, "duration");
class Av extends du {
}
class ir {
  static _instance;
  static create() {
    return new ir();
  }
  static getOrCreate() {
    return this._instance || (this._instance = this.create()), this._instance;
  }
  get isSecureConnection() {
    return window.location.protocol === "https:";
  }
  get quicklookButton() {
    return this._quicklookButton;
  }
  _quicklookButton;
  get arButton() {
    return this._arButton;
  }
  _arButton;
  get vrButton() {
    return this._vrButton;
  }
  _vrButton;
  get sendToQuestButton() {
    return this._sendToQuestButton;
  }
  _sendToQuestButton;
  get qrButton() {
    return On.getOrCreate().createQRCode();
  }
  /** get or create the quicklook button 
   * Behaviour of the button:
   * - if the button is clicked a USDZExporter component will be searched for in the scene and if found, it will be used to export the scene to USDZ / Quicklook
  */
  createQuicklookButton() {
    if (this._quicklookButton) return this._quicklookButton;
    const e = document.createElement("button");
    this._quicklookButton = e, e.dataset.needle = "quicklook-button";
    const t = X.supportsQuickLookAR();
    e.innerText = "View in AR", e.prepend(Mt("view_in_ar"));
    let i = !1, n = null;
    return e.addEventListener("click", () => {
      n = Qd(ws), n || (i = !0, n = new ws()), i && (n.objectToExport = N.Current.scene), n ? (e.classList.add("this-mode-is-requested"), n.exportAndOpen().then(() => {
        e.classList.remove("this-mode-is-requested");
      }).catch((o) => {
        e.classList.remove("this-mode-is-requested"), console.error(o);
      })) : console.warn("No USDZExporter component found in the scene");
    }), this.hideElementDuringXRSession(e), e;
  }
  /** get or create the WebXR AR button  
   * @param init optional session init options
   * Behaviour of the button:
   * - if the device supports AR, the button will be visible and clickable
   * - if the device does not support AR, the button will be hidden
   * - if the device changes and now supports AR, the button will be visible
   */
  createARButton(e) {
    if (this._arButton) return this._arButton;
    const t = "immersive-ar", i = document.createElement("button");
    return this._arButton = i, i.classList.add("webxr-button"), i.dataset.needle = "webxr-ar-button", i.innerText = "Enter AR", i.prepend(Mt("view_in_ar")), i.title = "Click to start an AR session", i.addEventListener("click", () => K.start(t, e)), this.updateSessionSupported(i, t), this.listenToXRSessionState(i, t), this.hideElementDuringXRSession(i), this.isSecureConnection || (i.disabled = !0, i.title = "WebXR requires a secure connection (HTTPS)"), X.isMozillaXR() || navigator.xr?.addEventListener("devicechange", () => this.updateSessionSupported(i, t)), i;
  }
  /** get or create the WebXR VR button 
   * @param init optional session init options
   * Behaviour of the button:
   * - if the device supports VR, the button will be visible and clickable
   * - if the device does not support VR, the button will be hidden
   * - if the device changes and now supports VR, the button will be visible
  */
  createVRButton(e) {
    if (this._vrButton) return this._vrButton;
    const t = "immersive-vr", i = document.createElement("button");
    return this._vrButton = i, i.classList.add("webxr-button"), i.dataset.needle = "webxr-vr-button", i.innerText = "Enter VR", i.prepend(Mt("panorama_photosphere")), i.title = "Click to start a VR session", i.addEventListener("click", () => K.start(t, e)), this.updateSessionSupported(i, t), this.listenToXRSessionState(i, t), this.hideElementDuringXRSession(i), this.isSecureConnection || (i.disabled = !0, i.title = "WebXR requires a secure connection (HTTPS)"), X.isMozillaXR() || navigator.xr?.addEventListener("devicechange", () => this.updateSessionSupported(i, t)), i;
  }
  /** get or create the Send To Quest button 
   * Behaviour of the button:
   * - if the button is clicked, the current URL will be sent to the Oculus Browser on the Quest
  */
  createSendToQuestButton() {
    if (this._sendToQuestButton) return this._sendToQuestButton;
    const e = "https://oculus.com/open_url/?url=", t = document.createElement("button");
    return this._sendToQuestButton = t, t.dataset.needle = "webxr-sendtoquest-button", t.innerText = "Open on Quest", t.prepend(Mt("share_windows")), t.title = "Click to send this page to the Oculus Browser on your Quest", t.addEventListener("click", () => {
      const i = encodeURIComponent(window.location.href), n = e + i;
      window.open(n) == null && Be("This page doesn't allow popups. Please paste " + n + " into your browser.");
    }), this.listenToXRSessionState(t), this.hideElementDuringXRSession(t), X.isMozillaXR() || navigator.xr?.addEventListener("devicechange", () => {
      navigator.xr?.isSessionSupported("immersive-vr") ? t.style.display = "none" : t.style.display = "";
    }), t;
  }
  /**
   * @deprecated please use ButtonsFactory.getOrCreate().createQRCode(). This method will be removed in a future update
   */
  createQRCode() {
    return On.getOrCreate().createQRCode();
  }
  updateSessionSupported(e, t) {
    if (!("xr" in navigator)) {
      e.style.display = "none";
      return;
    }
    K.isSessionSupported(t).then((i) => {
      e.style.display = i ? "" : "none", L() && !i && console.log('[WebXR] "' + t + '" is not supported on this device – make sure your server runs using HTTPS and you have a device connected that supports ' + t);
    });
  }
  hideElementDuringXRSession(e) {
    Om((t) => {
      e["previous-display"] = e.style.display, e.style.display = "none";
    }), Kb((t) => {
      e["previous-display"] != null && (e.style.display = e["previous-display"]);
    });
  }
  listenToXRSessionState(e, t) {
    t && (K.onSessionRequestStart((i) => {
      i.mode === t ? e.classList.add("this-mode-is-requested") : (e["was-disabled"] = e.disabled, e.disabled = !0, e.classList.add("other-mode-is-requested"));
    }), K.onSessionRequestEnd((i) => {
      e.classList.remove("this-mode-is-requested"), e.classList.remove("other-mode-is-requested"), e.disabled = e["was-disabled"];
    }));
  }
}
var iR = Object.defineProperty, nR = Object.getOwnPropertyDescriptor, mt = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? nR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && iR(e, t, n), n;
};
const bd = w("debugspriterenderer"), sR = w("wireframe");
class ar {
  static cache = {};
  static getOrCreateGeometry(e) {
    if (e.__cached_geometry) return e.__cached_geometry;
    if (e.guid && ar.cache[e.guid])
      return bd && console.log("Take cached geometry for sprite", e.guid), ar.cache[e.guid];
    const t = new Tn();
    e.__cached_geometry = t;
    const i = new Float32Array(e.triangles.length * 3), n = new Float32Array(e.triangles.length * 2);
    for (let o = 0; o < e.triangles.length; o += 1) {
      const r = e.triangles[o];
      i[o * 3] = -e.vertices[r].x, i[o * 3 + 1] = e.vertices[r].y, i[o * 3 + 2] = 0;
      const a = e.uv[r];
      n[o * 2] = a.x, n[o * 2 + 1] = 1 - a.y;
    }
    return t.setAttribute("position", new ht(i, 3)), t.setAttribute("uv", new ht(n, 2)), e.guid && (this.cache[e.guid] = t), bd && console.log("Built sprite geometry", e, t), t;
  }
}
class oR {
  x;
  y;
}
function Iv(s) {
  s && (s.colorSpace != Cs && (s.colorSpace = Cs, s.needsUpdate = !0), s.minFilter == qh && s.magFilter == qh && (s.anisotropy = 1, s.needsUpdate = !0));
}
let _o = class {
  constructor(e) {
    e && (this.texture = e, this.triangles = [0, 1, 2, 0, 2, 3], this.uv = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }], this.vertices = [{ x: -0.5, y: -0.5 }, { x: 0.5, y: -0.5 }, { x: 0.5, y: 0.5 }, { x: -0.5, y: 0.5 }]);
  }
  guid;
  texture;
  triangles;
  uv;
  vertices;
  /** @internal */
  __cached_geometry;
  /**
   * The mesh that represents the sprite
   */
  get mesh() {
    return this._mesh || (this._mesh = new H(ar.getOrCreateGeometry(this), this.material)), this._mesh;
  }
  _mesh;
  /**
   * The material used to render the sprite
   */
  get material() {
    return this._material || (this.texture && Iv(this.texture), this._material = new we({
      map: this.texture,
      color: 16777215,
      side: yi,
      transparent: !0
    })), this._material;
  }
  _material;
  /**
   * The geometry of the sprite that can be used to create a mesh
   */
  getGeometry() {
    return ar.getOrCreateGeometry(this);
  }
};
mt([
  u()
], _o.prototype, "guid", 2);
mt([
  u(Te)
], _o.prototype, "texture", 2);
mt([
  Ma()
], _o.prototype, "triangles", 2);
mt([
  Ma()
], _o.prototype, "uv", 2);
mt([
  Ma()
], _o.prototype, "vertices", 2);
const Lf = Symbol("spriteOwner");
class cc {
  sprites;
  constructor() {
    this.sprites = [];
  }
}
mt([
  u(_o)
], cc.prototype, "sprites", 2);
const hg = class Wp {
  static create() {
    const e = new Wp();
    return e.spriteSheet = new cc(), e;
  }
  // we don't assign anything here because it's used by the serialization system.
  // there's currently a limitation in the serializer when e.g. spriteSheet is already assigned it will not be overriden by the serializer
  // hence the spriteSheet field is undefined by default
  constructor() {
  }
  clone() {
    const e = new Wp();
    return e.index = this.index, e.spriteSheet = this.spriteSheet, e;
  }
  /**
   * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link index}
   */
  set sprite(e) {
    e && (this.spriteSheet ? ((this.index === null || this.index === void 0) && (this.index = 0), this.spriteSheet.sprites[this.index] = e) : (this.spriteSheet = new cc(), this.spriteSheet.sprites = [e], this.index = 0));
  }
  /** The currently active sprite */
  get sprite() {
    if (this.spriteSheet)
      return this.spriteSheet.sprites[this.index];
  }
  spriteSheet;
  index = 0;
  update(e) {
    if (!this.spriteSheet) return;
    const t = this.index;
    if (t < 0 || t >= this.spriteSheet.sprites.length)
      return;
    const i = this.spriteSheet.sprites[t], n = i?.texture;
    if (n && (Iv(n), !i.__hasLoadedProgressive)) {
      i.__hasLoadedProgressive = !0;
      const o = n;
      We.assignTextureLOD(n, 0).then((r) => {
        r instanceof Te && (i.texture = r, e?.map === o && (e.map = r, e.needsUpdate = !0));
      });
    }
  }
};
mt([
  u(cc)
], hg.prototype, "spriteSheet", 2);
mt([
  u()
], hg.prototype, "index", 2);
let Hl = hg;
class xi extends T {
  drawMode = 0;
  size = { x: 1, y: 1 };
  color;
  sharedMaterial;
  transparent = !0;
  cutoutThreshold = 0;
  castShadows = !1;
  renderOrder = 0;
  toneMapped = !0;
  /**
   * Assign a new texture to the currently active sprite
   */
  set texture(e) {
    if (!this._spriteSheet) return;
    const t = this._spriteSheet.spriteSheet?.sprites[this.spriteIndex];
    t && (t.texture = e, this.updateSprite());
  }
  /**
   * Add a new sprite to the currently assigned sprite sheet. The sprite will be added to the end of the sprite sheet.
   * Note that the sprite will not be rendered by default - set the `spriteIndex` to the index of the sprite to be rendered.
   * @param sprite The sprite to be added
   * @returns The index of the sprite in the sprite sheet
   * @example
   * ```typescript
   * const spriteRenderer = gameObject.addComponent(SpriteRenderer);
   * const index = spriteRenderer.addSprite(mySprite);
   * if(index >= 0)
   *   spriteRenderer.spriteIndex = index;
   * ```
   */
  addSprite(e, t = !1) {
    if (this._spriteSheet || (this._spriteSheet = Hl.create()), !this._spriteSheet.spriteSheet) return -1;
    this._spriteSheet.spriteSheet?.sprites.push(e);
    const i = this._spriteSheet.spriteSheet?.sprites.length - 1;
    return t && (this.spriteIndex = i), i;
  }
  get sprite() {
    return this._spriteSheet;
  }
  /**
   * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link spriteIndex}
   */
  set sprite(e) {
    if (e !== this._spriteSheet)
      if (typeof e == "number") {
        const t = Math.floor(e);
        this.spriteIndex = t;
      } else e instanceof _o ? (this._spriteSheet || (this._spriteSheet = Hl.create()), this._spriteSheet.sprite != e && (this._spriteSheet.sprite = e), this.updateSprite()) : e != this._spriteSheet && (this._spriteSheet = e, this.updateSprite());
  }
  /**
   * Set the index of the sprite to be rendered in the currently assigned sprite sheet
   */
  set spriteIndex(e) {
    this._spriteSheet && (this._spriteSheet.index = e, this.updateSprite());
  }
  get spriteIndex() {
    return this._spriteSheet?.index ?? 0;
  }
  /**
   * Get the number of sprites in the currently assigned sprite sheet
   */
  get spriteFrames() {
    return this._spriteSheet?.spriteSheet?.sprites.length ?? 0;
  }
  _spriteSheet;
  _currentSprite;
  /** @internal */
  awake() {
    this._currentSprite = void 0, this._spriteSheet ? this._spriteSheet = this._spriteSheet.clone() : this._spriteSheet = Hl.create(), bd && console.log("Awake", this.name, this, this.sprite);
  }
  /** @internal */
  start() {
    this._currentSprite ? this.gameObject && this.gameObject.add(this._currentSprite) : this.updateSprite();
  }
  /**
   * Update the sprite. Modified properties will be applied to the sprite mesh. This method is called automatically when the sprite is changed.
   * @param force If true, the sprite will be forced to update.
   * @returns True if the sprite was updated successfully
   */
  updateSprite(e = !1) {
    if (!this.__didAwake && !e) return !1;
    const t = this._spriteSheet;
    if (!t?.spriteSheet?.sprites)
      return console.warn("SpriteRenderer has no data or spritesheet assigned..."), !1;
    const i = t.spriteSheet.sprites[this.spriteIndex];
    if (!i)
      return bd && console.warn("Sprite not found", this.spriteIndex, t.spriteSheet.sprites), !1;
    if (this._currentSprite)
      this._currentSprite.geometry = ar.getOrCreateGeometry(i), this._currentSprite.material.map = i.texture;
    else {
      const n = new we({ color: 16777215, side: yi });
      if (sR && (n.wireframe = !0), this.color && (n.color || (n.color = new se()), n.color.copy(this.color), n.opacity = this.color.alpha), n.transparent = !0, n.toneMapped = this.toneMapped, n.depthWrite = !1, i.texture && !n.wireframe) {
        let o = i.texture;
        o[Lf] !== void 0 && o[Lf] !== this && this.spriteFrames > 1 && (o = i.texture = o.clone()), o[Lf] = this, n.map = o;
      }
      this.sharedMaterial = n, this._currentSprite = new H(ar.getOrCreateGeometry(i), n), this._currentSprite.renderOrder = Math.round(this.renderOrder), We.assignTextureLOD(n, 0);
    }
    return this._currentSprite.parent !== this.gameObject && (this.drawMode === 2 && this._currentSprite.scale.set(this.size.x, this.size.y, 1), this.gameObject && this.gameObject.add(this._currentSprite)), this._currentSprite && this._currentSprite.layers.set(this.layer), this.sharedMaterial && (this.sharedMaterial.alphaTest = this.cutoutThreshold, this.sharedMaterial.transparent = this.transparent), this._currentSprite.castShadow = this.castShadows, t?.update(this.sharedMaterial), !0;
  }
}
mt([
  u()
], xi.prototype, "drawMode", 2);
mt([
  u(oR)
], xi.prototype, "size", 2);
mt([
  u(oe)
], xi.prototype, "color", 2);
mt([
  u(_e)
], xi.prototype, "sharedMaterial", 2);
mt([
  u()
], xi.prototype, "transparent", 2);
mt([
  u()
], xi.prototype, "cutoutThreshold", 2);
mt([
  u()
], xi.prototype, "castShadows", 2);
mt([
  u()
], xi.prototype, "renderOrder", 2);
mt([
  u()
], xi.prototype, "toneMapped", 2);
mt([
  u(Hl)
], xi.prototype, "sprite", 1);
const I_ = w("debugwebxr"), rR = new te().makeRotationY(Math.PI);
class Ni extends T {
  static _eventListeners = {};
  /**
   * Event that is called when the scene has been placed in AR.
   * @param cb the callback that is called when the scene has been placed
   * @returns a function to remove the event listener
   */
  static onPlaced(e) {
    const t = "placed";
    return this._eventListeners[t] || (this._eventListeners[t] = []), this._eventListeners[t].push(e), () => {
      const i = this._eventListeners[t].indexOf(e);
      i >= 0 && this._eventListeners[t].splice(i, 1);
    };
  }
  static _hasPlaced = !1;
  /**
   * @returns true if the scene has been placed in AR by the user or automatic placement
   */
  static get hasPlaced() {
    return this._hasPlaced;
  }
  /** The scale of the user in AR.  
   * **NOTE**: a large value makes the scene appear smaller  
   * @default 1
   */
  get arScale() {
    return this._arScale;
  }
  set arScale(e) {
    this._arScale = Math.max(1e-6, e), this.onSetScale();
  }
  _arScale = 1;
  /** When enabled the placed scene forward direction will towards the XRRig 
   * @deprecated
   * @default false
  */
  invertForward = !1;
  /** When assigned this asset will be loaded and visualize the placement while in AR
   * @default null
   */
  customReticle;
  /** Enable touch transform to translate, rotate and scale the scene in AR with multitouch
   * @default true
   */
  arTouchTransform = !0;
  /** When enabled the scene will be placed automatically when a point in the real world is found
   * @default false
   */
  autoPlace = !1;
  /** When enabled the scene center will be automatically calculated from the content in the scene */
  autoCenter = !1;
  /** Experimental: When enabled we will create a XR anchor for the scene placement    
   * and make sure the scene is at that anchored point during a XR session 
   * @default false
   **/
  useXRAnchor = !1;
  /** true if we're currently placing the scene */
  _isPlacing = !0;
  /** This is the world matrix of the ar session root when entering webxr
   * it is applied when the scene has been placed (e.g. if the session root is x:10, z:10 we want this position to be the center of the scene)
   */
  _startOffset = new te();
  _createdPlacementObject = null;
  _reparentedComponents = [];
  // move objects into a temporary scene while placing (which is not rendered) so that the components won't be disabled during this process
  // e.g. we want the avatar to still be updated while placing
  // another possibly solution would be to ensure from this component that the Rig is *also* not disabled while placing
  _placementScene = new gi();
  /** the reticles used for placement */
  _reticle = [];
  /** needs to be in sync with the reticles */
  _hits = [];
  _placementStartTime = -1;
  _rigPlacementMatrix;
  /** if useAnchor is enabled this is the anchor we have created on placing the scene using the placement hit */
  _anchor = null;
  /** user input is used for ar touch transform */
  userInput;
  onEnable() {
    this.customReticle?.preload();
  }
  supportsXR(e) {
    return e === "immersive-ar";
  }
  onEnterXR(e) {
    I_ && console.log("ENTER WEBXR: SessionRoot start..."), this._anchor = null, Ni._hasPlaced = !1, this.gameObject.updateMatrixWorld(), this._startOffset.copy(this.gameObject.matrixWorld);
    const t = new M();
    this._createdPlacementObject = t, t.name = "AR Session Root", this._placementScene.name = "AR Placement Scene", this._placementScene.children.length = 0;
    for (let i = this.context.scene.children.length - 1; i >= 0; i--) {
      const n = this.context.scene.children[i];
      this._placementScene.add(n);
    }
    if (this.context.scene.add(t), this.autoCenter) {
      const i = _i(this._placementScene.children), n = i.getCenter(new b()), o = i.getSize(new b()), r = new te();
      r.makeTranslation(n.x, n.y - o.y * 0.5, n.z), this._startOffset.multiply(r);
    }
    this._reparentedComponents.length = 0, this._reparentedComponents.push({ comp: this, originalObject: this.gameObject }), S.addComponent(t, this);
    for (const i of this._reticle)
      Wi(i);
    this._reticle.length = 0, this._isPlacing = !0, this.context.input.addEventListener("pointerup", this.onPlaceScene, { queue: li.Early });
  }
  onLeaveXR() {
    this.context.input.removeEventListener("pointerup", this.onPlaceScene, { queue: li.Early }), this.onRevertSceneChanges(), this._anchor = null, Ni._hasPlaced = !1, this._rigPlacementMatrix = void 0;
  }
  onUpdateXR(e) {
    if (e.xr.isTrackingImages) {
      for (const t of this._reticle)
        t.visible = !1;
      return;
    }
    if (this._isPlacing) {
      const t = e.xr.rig?.gameObject;
      t && t.parent !== this.context.scene && this.context.scene.add(t);
      let i = !1;
      if (e.xr.isPassThrough && e.xr.controllers.length > 0 && !this.autoPlace)
        for (const n of e.xr.controllers) {
          const o = n.getHitTest();
          o && (i = !0, this.updateReticleAndHits(e.xr, n.index, o, e.xr.rigScale));
        }
      if (!i) {
        const n = e.xr.getHitTest();
        n && this.updateReticleAndHits(e.xr, 0, n, e.xr.rigScale);
      }
    } else {
      if (this._anchor && e.xr.referenceSpace) {
        const t = e.xr.frame.getPose(this._anchor.anchorSpace, e.xr.referenceSpace);
        if (t && this.context.time.frame % 20 === 0) {
          const i = e.xr.convertSpace(t.transform), n = this._reticle[0];
          n && (n.position.copy(i.position), n.quaternion.copy(i.quaternion), this.onApplyPose(n));
        }
      }
      if (this.arTouchTransform ? (this.userInput || (this.userInput = new vd(this.context)), this.userInput?.enable()) : this.userInput?.disable(), this.arTouchTransform && this.userInput?.hasChanged) {
        if (e.xr.rig) {
          const t = e.xr.rig.gameObject;
          this.userInput.applyMatrixTo(t.matrix, !0), t.matrix.decompose(t.position, t.quaternion, t.scale), this.userInput.factor = t.scale.x;
        }
        this.userInput.reset();
      }
    }
  }
  updateReticleAndHits(e, t, i, n) {
    this._hits[t] = i.hit;
    let o = this._reticle[t];
    if (!o) {
      if (this.customReticle)
        if (this.customReticle.asset)
          o = va(this.customReticle.asset);
        else {
          this.customReticle.loadAssetAsync();
          return;
        }
      else
        o = new H(
          new zx(0.07, 0.09, 32).rotateX(-Math.PI / 2),
          new we({ side: yi, depthTest: !1, depthWrite: !1, transparent: !0, opacity: 1, color: 15658734 })
        ), o.name = "AR Placement Reticle";
      if (I_) {
        const r = new mi(1);
        r.position.y += 0.01, o.add(r);
      }
      this._reticle[t] = o, o.matrixAutoUpdate = !1, o.visible = !1;
    }
    if (o.lastPos = o.lastPos || i.position.clone(), o.lastQuat = o.lastQuat || i.quaternion.clone(), o.position.copy(o.lastPos.lerp(i.position, this.context.time.deltaTime / 0.1)), o.lastPos.copy(o.position), o.quaternion.copy(o.lastQuat.slerp(i.quaternion, this.context.time.deltaTime / 0.05)), o.lastQuat.copy(o.quaternion), o.scale.set(n, n, n), this.customReticle && this.applyViewBasedTransform(o), o.updateMatrix(), o.visible = !0, o.parent !== this.context.scene && this.context.scene.add(o), this._placementStartTime < 0 && (this._placementStartTime = this.context.time.realtimeSinceStartup), this.autoPlace)
      if (this.upVec.set(0, 1, 0).applyQuaternion(o.quaternion), this.upVec.dot(G(0, 1, 0)) > 0.9) {
        let a = o["autoplace:timer"] || 0;
        a >= 1 ? (o.visible = !1, this.onPlaceScene(null)) : (a += this.context.time.deltaTime, o["autoplace:timer"] = a);
      } else
        o["autoplace:timer"] = 0;
  }
  onPlaceScene = (e) => {
    if (this._isPlacing == !1 || e?.used) return;
    let t = this._reticle[0];
    if (!t) {
      console.warn("No reticle to place...");
      return;
    }
    if (!t.visible && !this.autoPlace) {
      console.warn("Reticle is not visible (can not place)");
      return;
    }
    if (K.active?.isTrackingImages) {
      console.warn("Scene Placement is disabled while images are being tracked");
      return;
    }
    let i = this._hits[0];
    if (e && e.origin instanceof Zb) {
      const n = this._reticle[e.origin.index];
      n && (t = n, i = this._hits[e.origin.index]);
    }
    if (e && (e.stopImmediatePropagation(), e.stopPropagation(), e.use()), this._isPlacing = !1, this.context.input.removeEventListener("pointerup", this.onPlaceScene), this.onRevertSceneChanges(), t.position.copy(t.lastPos), t.quaternion.copy(t.lastQuat), this.onApplyPose(t), Ni._hasPlaced = !0, this.useXRAnchor && this.onCreateAnchor(K.active, i), this.context.xr)
      for (const n of this.context.xr.controllers)
        n.cancelHitTestSource();
  };
  onSetScale() {
    if (!Ni._hasPlaced) return;
    const e = K.active?.rig?.gameObject;
    if (e) {
      const t = K.active?.rigScale || 1, i = 1 / this._arScale * t, n = new te().makeScale(i, i, i).invert();
      e.matrix.premultiply(n), e.matrix.decompose(e.position, e.quaternion, e.scale);
    }
  }
  onRevertSceneChanges() {
    for (const e of this._reticle)
      e && (e.visible = !1, e?.removeFromParent());
    this._reticle.length = 0;
    for (let e = this._placementScene.children.length - 1; e >= 0; e--) {
      const t = this._placementScene.children[e];
      this.context.scene.add(t);
    }
    this._createdPlacementObject?.removeFromParent();
    for (const e of this._reparentedComponents)
      S.addComponent(e.originalObject, e.comp);
  }
  async onCreateAnchor(e, t) {
    if (t.createAnchor === void 0) {
      console.warn("Hit does not support creating an anchor", t), L() && ge("Hit does not support creating an anchor");
      return;
    } else {
      const i = await t.createAnchor(e.viewerPose.transform);
      e.running && i && (this._anchor = i);
    }
  }
  upVec = new b(0, 1, 0);
  lookPoint = new b();
  worldUpVec = new b(0, 1, 0);
  applyViewBasedTransform(e) {
    const t = this.context.mainCamera, i = e, n = t.worldPosition, o = i.worldPosition;
    this.upVec.set(0, 1, 0).applyQuaternion(e.quaternion);
    const r = t.worldPosition;
    r && e.position.clone().sub(r).angleTo(this.upVec) < Math.PI / 2 && this.upVec.negate();
    const a = this.upVec.angleTo(this.worldUpVec) * 180 / Math.PI, l = 30;
    a > l && a < 180 - l || a < -l && a > -180 + l ? (this.lookPoint.copy(e.position).add(this.upVec), this.lookPoint.y = e.position.y, e.lookAt(this.lookPoint)) : (n.y = o.y, e.lookAt(n));
  }
  onApplyPose(e) {
    const t = K.active?.rig?.gameObject;
    if (!t) {
      console.warn("No rig object to place");
      return;
    }
    const i = t.parent || this.context.scene;
    this._rigPlacementMatrix ? this._rigPlacementMatrix?.decompose(t.position, t.quaternion, t.scale) : this._rigPlacementMatrix = t.matrix.clone(), this.applyViewBasedTransform(e), e.updateMatrix(), this.context.scene.add(e), e.attach(t), e.removeFromParent(), t.scale.set(this.arScale, this.arScale, this.arScale), t.position.multiplyScalar(this.arScale), t.updateMatrix(), this.invertForward && t.matrix.premultiply(rR), t.matrix.premultiply(this._startOffset), t.matrix.decompose(t.position, t.quaternion, t.scale), i.add(t);
  }
}
class vd {
  static up = new b(0, 1, 0);
  static zero = new b(0, 0, 0);
  static one = new b(1, 1, 1);
  oneFingerDrag = !0;
  twoFingerRotate = !0;
  twoFingerScale = !0;
  factor = 1;
  context;
  offset;
  plane;
  _scale = 1;
  _hasChanged = !1;
  get scale() {
    return this._scale;
  }
  // readonly translate: Vector3 = new Vector3();
  // readonly rotation: Quaternion = new Quaternion();
  // readonly scale: Vector3 = new Vector3(1, 1, 1);
  constructor(e) {
    this.context = e, this.offset = new te(), this.plane = new nr(), this.plane.setFromNormalAndCoplanarPoint(vd.up, vd.zero);
  }
  _enabled = !1;
  reset() {
    this._scale = 1, this.offset.identity(), this._hasChanged = !0;
  }
  get hasChanged() {
    return this._hasChanged;
  }
  /**
   * Applies the matrix to the offset matrix
   * @param matrix the matrix to apply the drag offset to
   * @param invert if true the offset matrix will be inverted before applying it to the matrix and premultiplied 
   */
  applyMatrixTo(e, t) {
    this._hasChanged = !1, t ? (this.offset.invert(), e.premultiply(this.offset)) : e.multiply(this.offset);
  }
  currentlyUsedPointerIds = /* @__PURE__ */ new Set();
  currentlyUnusedPointerIds = /* @__PURE__ */ new Set();
  get isActive() {
    return this.currentlyUsedPointerIds.size <= 0 && this.currentlyUnusedPointerIds.size > 0;
  }
  enable() {
    this._enabled || (this._enabled = !0, this.context.input.addEventListener("pointerdown", this.onPointerDownEarly, { queue: li.Early }), this.context.input.addEventListener("pointerdown", this.onPointerDownLate, { queue: li.Late }), this.context.input.addEventListener("pointerup", this.onPointerUpEarly, { queue: li.Early }), window.addEventListener("touchstart", this.touchStart, { passive: !1 }), window.addEventListener("touchmove", this.touchMove, { passive: !1 }), window.addEventListener("touchend", this.touchEnd, { passive: !1 }));
  }
  disable() {
    this._enabled && (this._enabled = !1, this.context.input.removeEventListener("pointerdown", this.onPointerDownEarly, { queue: li.Early }), this.context.input.removeEventListener("pointerdown", this.onPointerDownLate, { queue: li.Late }), this.context.input.removeEventListener("pointerup", this.onPointerUpEarly, { queue: li.Early }), window.removeEventListener("touchstart", this.touchStart), window.removeEventListener("touchmove", this.touchMove), window.removeEventListener("touchend", this.touchEnd));
  }
  onPointerDownEarly = (e) => {
    this.isActive && e.stopPropagation();
  };
  onPointerDownLate = (e) => {
    e.used ? this.currentlyUsedPointerIds.add(e.pointerId) : this.currentlyUsedPointerIds.size <= 0 && this.currentlyUnusedPointerIds.add(e.pointerId);
  };
  onPointerUpEarly = (e) => {
    this.currentlyUsedPointerIds.delete(e.pointerId), this.currentlyUnusedPointerIds.delete(e.pointerId);
  };
  // private _needsUpdate: boolean = true;
  // private _rotationMatrix: Matrix4 = new Matrix4();
  // private updateMatrix() {
  //     this._needsUpdate = false;
  //     this._rotationMatrix.makeRotationFromQuaternion(this.rotation);
  //     this.offset.compose(this.translate, new Quaternion(), this.scale);
  //     // const rot = this._tempMatrix.makeRotationY(this.angle);
  //     // this.translate.applyMatrix4(rot);
  //     // this.offset.elements[12] = this.translate.x;
  //     // this.offset.elements[13] = this.translate.y;
  //     // this.offset.elements[14] = this.translate.z;
  //     // this.offset.premultiply(rot);
  //     // const s = this.scale;
  //     // this.offset.premultiply(this._tempMatrix.makeScale(s, s, s));
  // }
  prev = /* @__PURE__ */ new Map();
  _didMultitouch = !1;
  touchStart = (e) => {
    if (!e.defaultPrevented)
      for (let t = 0; t < e.changedTouches.length; t++) {
        const i = e.changedTouches[t], n = X.isAndroidDevice() && i.clientY < window.innerHeight * 0.1;
        this.prev.has(i.identifier) || this.prev.set(i.identifier, {
          ignore: n,
          x: 0,
          z: 0,
          screenx: 0,
          screeny: 0
        });
        const o = this.prev.get(i.identifier);
        if (o) {
          const r = this.getPositionOnPlane(i.clientX, i.clientY);
          o.x = r.x, o.z = r.z, o.screenx = i.clientX, o.screeny = i.clientY;
        }
      }
  };
  touchEnd = (e) => {
    e.touches.length <= 0 && (this._didMultitouch = !1);
    for (let t = 0; t < e.changedTouches.length; t++) {
      const i = e.changedTouches[t];
      this.prev.delete(i.identifier);
    }
  };
  touchMove = (e) => {
    if (!e.defaultPrevented && this.isActive) {
      if (e.touches.length === 1) {
        if (this._didMultitouch)
          return;
        const t = e.touches[0], i = this.prev.get(t.identifier);
        if (!i || i.ignore) return;
        const n = this.getPositionOnPlane(t.clientX, t.clientY), o = n.x - i.x, r = n.z - i.z;
        if (o === 0 && r === 0) return;
        this.oneFingerDrag && this.addMovement(o, r), i.x = n.x, i.z = n.z, i.screenx = t.clientX, i.screeny = t.clientY;
        return;
      } else if (e.touches.length === 2) {
        this._didMultitouch = !0;
        const t = e.touches[0], i = e.touches[1], n = this.prev.get(t.identifier), o = this.prev.get(i.identifier);
        if (!n || !o) return;
        if (this.twoFingerRotate) {
          const r = Math.atan2(t.clientY - i.clientY, t.clientX - i.clientX), a = Math.atan2(n.screeny - o.screeny, n.screenx - o.screenx), l = r - a;
          Math.abs(l) > 1e-3 && this.addRotation(l);
        }
        if (this.twoFingerScale) {
          const r = t.clientX - i.clientX, a = t.clientY - i.clientY, l = Math.sqrt(r * r + a * a), c = n.screenx - o.screenx, h = n.screeny - o.screeny, d = Math.sqrt(c * c + h * h), f = l - d;
          Math.abs(f) > 2 && this.addScale(f);
        }
        n.screenx = t.clientX, n.screeny = t.clientY, o.screenx = i.clientX, o.screeny = i.clientY;
      }
    }
  };
  _raycaster = new Ad();
  _intersection = new b();
  _screenPos = new b();
  getPositionOnPlane(e, t) {
    const i = this.context.mainCamera;
    return this._screenPos.x = e / window.innerWidth * 2 - 1, this._screenPos.y = -(t / window.innerHeight) * 2 + 1, this._screenPos.z = 1, this._screenPos.unproject(i), this._raycaster.set(i.position, this._screenPos.sub(i.position)), this._raycaster.ray.intersectPlane(this.plane, this._intersection), this._intersection;
  }
  addMovement(e, t) {
    e /= this._scale, t /= this._scale, e *= this.factor, t *= this.factor, this.offset.elements[12] += e, this.offset.elements[14] += t, (e !== 0 || t !== 0) && (this._hasChanged = !0);
  }
  _tempMatrix = new te();
  addScale(e) {
    e /= window.innerWidth, e *= -1, this._scale *= 1 + e, this._tempMatrix.makeScale(1 - e, 1 - e, 1 - e), this.offset.premultiply(this._tempMatrix), e !== 0 && (this._hasChanged = !0);
  }
  addRotation(e) {
    e *= -1, this._tempMatrix.makeRotationY(e), this.offset.premultiply(this._tempMatrix), e !== 0 && (this._hasChanged = !0);
  }
}
const Ks = w("debugautosync"), Df = Symbol("syncerId");
class aR {
  _syncers = {};
  getOrCreateSyncer(e) {
    if (!e.guid) return null;
    if (this._syncers[e.guid]) return this._syncers[e.guid];
    const t = new lR(e);
    return t[Df] = e.guid, this._syncers[t[Df]] = t, t;
  }
  removeSyncer(e) {
    delete this._syncers[e[Df]];
  }
}
const dg = new aR();
class lR {
  comp;
  constructor(e) {
    this.comp = e;
  }
  // private getters: { [key: string]: Function } = {};
  hasChanges = !1;
  changedProperties = {};
  get networkingKey() {
    return this.comp.guid;
  }
  /** is set to true in on receive call to avoid circular sending */
  _isReceiving = !1;
  _isInit = !1;
  init(e) {
    if (this._isInit) return;
    this._isInit = !0, this.comp = e, this.comp.context.post_render_callbacks.push(this.onHandleSending), this.comp.context.connection.beginListen(this.networkingKey, this.onHandleReceiving);
    const t = this.comp.context.connection.tryGetState(this.comp.guid);
    t && this.onHandleReceiving(t);
  }
  destroy() {
    this._isInit && (this.comp.context.post_render_callbacks.splice(this.comp.context.post_render_callbacks.indexOf(this.onHandleSending), 1), this.comp.context.connection.stopListen(this.networkingKey, this.onHandleReceiving), this.comp = null, this._isInit = !1);
  }
  notifyChanged(e, t) {
    this._isReceiving || (Ks && console.log("Property changed: " + e, t), this.hasChanges = !0, this.changedProperties[e] = t);
  }
  onHandleSending = () => {
    if (!this.hasChanges) return;
    this.hasChanges = !1;
    const e = this.comp.context.connection;
    if (!e || !e.isConnected || !e.isInRoom) {
      for (const t in this.changedProperties)
        delete this.changedProperties[t];
      return;
    }
    for (const t in this.changedProperties) {
      const i = this.changedProperties[t];
      Ks && console.log("SEND", this.comp.guid, this.networkingKey), e.send(this.networkingKey, { guid: this.comp.guid, property: t, data: i }, vn.Queued), delete this.changedProperties[t];
    }
  };
  onHandleReceiving = (e) => {
    if (Ks && console.log("SYNCFIELD RECEIVE", this.comp.name, this.comp.guid, e), !!this._isInit && this.comp && e.guid === this.comp.guid)
      try {
        this._isReceiving = !0, this.comp[e.property] = e.data;
      } catch (t) {
        console.error(t);
      } finally {
        this._isReceiving = !1;
      }
  };
}
function cR(s, e) {
  let t = e !== s;
  return !t && s && e && (Array.isArray(s) && Array.isArray(e) || typeof s == "object" && typeof e == "object") && (t = !0), t;
}
const Gl = Symbol("AutoSyncHandler");
function hR(s) {
  if (s[Gl])
    return s[Gl];
  const e = dg.getOrCreateSyncer(s);
  return e?.init(s), s[Gl] = e, e;
}
function dR(s) {
  const e = s[Gl];
  e && (dg.removeSyncer(e), e.destroy(), delete s[Gl]);
}
const Lv = function(s = null) {
  return function(e, t) {
    let i = "";
    typeof t == "string" ? i = t : i = t.name;
    let n = null, o;
    typeof s == "string" ? o = e[s] : typeof s == "function" && (o = s), o == null && (L() || Ks) && s != null && console.warn('syncField: no callback function found for property "' + i + '"', '"' + s + '"');
    const r = e, a = r.__internalAwake;
    if (typeof a != "function") {
      (Ks || L()) && console.error('@syncField can currently only used on Needle Engine Components, custom object of type "' + e?.constructor?.name + '" is not supported', e);
      return;
    }
    Ks && console.log(i);
    const l = Symbol(i);
    r.__internalAwake = function() {
      if (this[l] !== void 0)
        return;
      if (this[l] = this[i], n = dg.getOrCreateSyncer(this), Object.getOwnPropertyDescriptor(this, i)?.set === void 0) {
        let d = !1;
        Object.defineProperty(this, i, {
          set: function(f) {
            const p = this[l];
            if (this[l] = f, d) {
              (L() || Ks) && console.warn("Recursive call detected", i);
              return;
            }
            d = !0;
            try {
              const g = cR(f, p);
              Ks && console.log("SyncField assignment", i, "changed?", g, f, o), g && o?.call(this, f, p) !== !1 && hR(this)?.notifyChanged(i, f);
            } finally {
              d = !1;
            }
          },
          get: function() {
            return this[l];
          },
          configurable: !0,
          enumerable: !0
        });
      }
      n?.init(this), a.call(this);
    };
    const c = r.__internalDestroy;
    r.__internalDestroy = function() {
      dR(this), c.call(this);
    };
  };
};
var uR = Object.defineProperty, fu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && uR(e, t, n), n;
};
const Nt = w("debugplayersync"), pu = class Dv extends T {
  /**
   * This API is experimental and may change or be removed in the future.
   * Creates a PlayerSync instance at runtime from a given URL and sets it up for networking
   * @param url Path to the asset that should be instantiated for each player
   * @param init Optional initialization parameters for the PlayerSync component
   * @returns Promise resolving to a PlayerSync instance with a guaranteed asset property
   * @example
   * ```typescript
   * const res = await PlayerSync.setupFrom("/assets/demo.glb");
   * addComponent(res.asset?.asset, DragControls);
   * addComponent(res.asset?.asset, SyncedTransform);
   * scene.add(res.gameObject);
   * ```
   */
  static async setupFrom(e, t) {
    const i = ie.getOrCreateFromUrl(e);
    if (!i.asset) {
      const r = await i.loadAssetAsync();
      r && S.getOrAddComponent(r, Mn);
    }
    const n = new Dv();
    n._internalInit(t), n.asset = i;
    const o = new M();
    return o.guid = e, S.addComponent(o, n), n;
  }
  autoSync = !0;
  asset;
  onPlayerSpawned;
  _localInstance;
  awake() {
    this.watchTabVisible(), this.onPlayerSpawned || (this.onPlayerSpawned = new me());
  }
  onEnable() {
    this.context.connection.beginListen(ee.RoomStateSent, this.onJoinedRoom), this.context.connection.beginListen(ee.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ee.LeftRoom, this.destroyInstance), this.context.connection.isInRoom && this.onJoinedRoom();
  }
  onDisable() {
    this.context.connection.stopListen(ee.RoomStateSent, this.onJoinedRoom), this.context.connection.stopListen(ee.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ee.LeftRoom, this.destroyInstance);
  }
  onJoinedRoom = () => {
    Nt && console.log("PlayerSync.joinedRoom. autoSync is set to " + this.autoSync), this.autoSync && this.getInstance();
  };
  /**
   * Gets or creates an instance of the assigned asset for the local player
   * @returns Promise resolving to the instantiated player object or null if creation failed
   */
  async getInstance() {
    if (this._localInstance) return this._localInstance;
    if (Nt && console.log("PlayerSync.createInstance", this.asset?.url), !this.asset?.asset && !this.asset?.url)
      return console.error('PlayerSync: can not create an instance because "asset" is not set and or has no URL!'), null;
    this.gameObject.guid || console.warn("PlayerSync: gameObject has no guid! This might cause issues with syncing the player state."), this._localInstance = this.asset?.instantiateSynced({ parent: this.gameObject, deleteOnDisconnect: !0 }, !0);
    const e = await this._localInstance;
    if (e) {
      const t = S.getComponentsInChildren(e, Mn);
      if (Nt && console.log(`PlayerSync.createInstance: found ${t?.length} PlayerState components. Owner: ${this.context.connection.connectionId}`), t?.length) {
        for (const i of t)
          i.owner = this.context.connection.connectionId;
        this.onPlayerSpawned?.invoke(e);
      } else
        this._localInstance = void 0, console.error("<strong>Failed finding PlayerState on " + this.asset?.url + "</strong>: please make sure the asset has a PlayerState component!"), S.destroySynced(e);
    } else
      this._localInstance = void 0, console.warn("PlayerSync: failed instantiating asset!");
    return this._localInstance;
  }
  /**
   * Destroys the current player instance and cleans up networking state
   */
  destroyInstance = () => {
    this._localInstance?.then((e) => {
      Nt && console.log("PlayerSync.destroyInstance", e), Hd(e, this.context.connection, !0, { saveInRoom: !1 });
    }), this._localInstance = void 0;
  };
  /**
   * Sets up visibility change listeners to handle player cleanup when browser tab visibility changes
   */
  watchTabVisible() {
    window.addEventListener("visibilitychange", (e) => {
      if (document.visibilityState === "visible")
        for (let t = Mn.all.length - 1; t >= 0; t--) {
          const i = Mn.all[t];
          (!i.owner || !this.context.connection.userIsInRoom(i.owner)) && i.doDestroy();
        }
    });
  }
};
fu([
  u()
], pu.prototype, "autoSync");
fu([
  u(ie)
], pu.prototype, "asset");
fu([
  u(me)
], pu.prototype, "onPlayerSpawned");
let jv = pu;
var fR = /* @__PURE__ */ ((s) => (s.OwnerChanged = "ownerChanged", s))(fR || {});
const Vp = class xt extends T {
  static _all = [];
  /** All PlayerState instances for all players in the scene */
  static get all() {
    return xt._all;
  }
  static _local = [];
  /** All PlayerState instances that belong to the local player */
  static get local() {
    return xt._local;
  }
  /**
   * Gets the PlayerState component for a given object or component
   * @param obj Object3D or Component to find the PlayerState for
   * @returns The PlayerState component if found, undefined otherwise
   */
  static getFor(e) {
    if (e instanceof M)
      return S.getComponentInParent(e, xt);
    if (e instanceof T)
      return S.getComponentInParent(e.gameObject, xt);
  }
  /**
   * Checks if a given object or component belongs to the local player
   * @param obj Object3D or Component to check
   * @returns True if the object belongs to the local player, false otherwise
   */
  static isLocalPlayer(e) {
    return xt.getFor(e)?.isLocalPlayer ?? !1;
  }
  static _callbacks = {};
  /**
   * Registers a callback for a specific PlayerState event
   * @param event The event to listen for
   * @param cb Callback function that will be invoked when the event occurs
   * @returns The provided callback function for chaining
   */
  static addEventListener(e, t) {
    return this._callbacks[e] || (this._callbacks[e] = []), this._callbacks[e].push(t), t;
  }
  /**
   * Removes a previously registered event callback
   * @param event The event type to remove the callback from
   * @param cb The callback function to remove
   */
  static removeEventListener(e, t) {
    if (!this._callbacks[e]) return;
    const i = this._callbacks[e].indexOf(t);
    i >= 0 && this._callbacks[e].splice(i, 1);
  }
  static dispatchEvent(e, t) {
    if (this._callbacks[e])
      for (const i of this._callbacks[e])
        i(t);
  }
  /** Event triggered when the owner of this PlayerState changes */
  onOwnerChangeEvent = new me();
  /** Event triggered the first time an owner is assigned to this PlayerState */
  onFirstOwnerChangeEvent = new me();
  /** Indicates if this PlayerState has an owner assigned */
  hasOwner = !1;
  owner;
  /** 
   * When enabled, PlayerState will not destroy itself when the owner is not connected anymore 
   */
  dontDestroy = !1;
  /**
   * Indicates if this PlayerState belongs to the local player
   */
  get isLocalPlayer() {
    return this.owner === this.context.connection.connectionId;
  }
  /**
   * Handles owner change events and updates relevant state
   * @param newOwner The new owner's connection ID
   * @param oldOwner The previous owner's connection ID
   */
  onOwnerChange(e, t) {
    Nt && console.log(`PlayerSync.onOwnerChange: ${t} → ${e} (me: ${this.context.connection.connectionId})`);
    const i = xt._local.indexOf(this);
    i >= 0 && xt._local.splice(i, 1);
    const n = {
      playerState: this,
      oldValue: t,
      newValue: e
    };
    if (this.hasOwner || (this.hasOwner = !0, this.onFirstOwnerChangeEvent?.invoke(n)), this.onOwnerChangeEvent?.invoke(n), this.owner === this.context.connection.connectionId) {
      xt._local.push(this);
      const r = new CustomEvent("local-owner-changed", { detail: n });
      this.dispatchEvent(r);
    }
    const o = new CustomEvent("owner-changed", { detail: n });
    this.dispatchEvent(o), xt.dispatchEvent("ownerChanged", o);
  }
  /** @internal */
  awake() {
    xt.all.push(this), Nt && console.log("Registered new PlayerState", this.guid, xt.all.length - 1, xt.all), this.context.connection.beginListen(ee.UserLeftRoom, this.onUserLeftRoom);
  }
  /** @internal */
  async start() {
    Nt && console.log("PLAYERSTATE.START, owner: " + this.owner, this.context.connection.usersInRoom([])), this.owner ? (this.context.connection.isInRoom || await Os(300), this.context.connection.userIsInRoom(this.owner) == !1 && (Nt && console.log(`PlayerSync.start → doDestroy "${this.name}" because user "${this.owner}" is not in room anymore...`, "Currently in room:", ...this.context.connection.usersInRoom()), this.doDestroy())) : this.owner || (Nt && console.warn("PlayerState.start → owner is undefined!", this.name), setTimeout(() => {
      !this.destroyed && !this.owner ? this.dontDestroy ? Nt && console.warn("PlayerState.start → owner is still undefined but dontDestroy is set to true", this.name) : (Nt && console.warn(`PlayerState.start → owner is still undefined: destroying "${this.name}" instance now`), this.doDestroy()) : Nt && console.log("PlayerState.start → owner is assigned", this.owner);
    }, 2e3));
  }
  /** Tells the server that this client has been destroyed, and the networking message for the instantiate will be removed      */
  doDestroy() {
    Nt && console.log("PlayerSync.doDestroy → syncDestroy", this.name), Hd(this.gameObject, this.context.connection, !0, { saveInRoom: !1 });
  }
  /** @internal */
  onDestroy() {
    if (Nt && console.warn("PlayerState.onDestroy", this.owner), this.context.connection.stopListen(ee.UserLeftRoom, this.onUserLeftRoom), xt.all.splice(xt.all.indexOf(this), 1), this.isLocalPlayer) {
      const e = xt._local.indexOf(this);
      e >= 0 && xt._local.splice(e, 1);
    }
  }
  /**
   * Handler for when a user leaves the networked room
   * @param model Object containing the ID of the user who left
   */
  onUserLeftRoom = (e) => {
    if (e.userId === this.owner) {
      Nt && console.log("PLAYERSYNC LEFT", this.owner), this.doDestroy();
      return;
    }
  };
};
fu([
  Lv(Vp.prototype.onOwnerChange)
], Vp.prototype, "owner");
let Mn = Vp;
var pR = Object.defineProperty, ja = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && pR(e, t, n), n;
};
class Es extends T {
  position = "bottom";
  showNeedleLogo = !1;
  showSpatialMenu;
  createFullscreenButton;
  createMuteButton;
  createQRCodeButton;
  /** 
   * Applies the configured menu options when the component is enabled
   * @hidden
   */
  onEnable() {
    this.applyOptions();
  }
  /** 
   * Applies all configured options to the active {@link Context.menu}.
   */
  applyOptions() {
    this.context.menu.setPosition(this.position), this.context.menu.showNeedleLogo(this.showNeedleLogo), this.createFullscreenButton === !0 && this.context.menu.showFullscreenOption(!0), this.createMuteButton === !0 && this.context.menu.showAudioPlaybackOption(!0), this.showSpatialMenu === !0 && this.context.menu.showSpatialMenu(this.showSpatialMenu), this.createQRCodeButton === !0 && (X.isMobileDevice() || this.context.menu.showQRCodeButton(!0));
  }
}
ja([
  u()
], Es.prototype, "position");
ja([
  u()
], Es.prototype, "showNeedleLogo");
ja([
  u()
], Es.prototype, "showSpatialMenu");
ja([
  u()
], Es.prototype, "createFullscreenButton");
ja([
  u()
], Es.prototype, "createMuteButton");
ja([
  u()
], Es.prototype, "createQRCodeButton");
var mR = Object.defineProperty, ug = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && mR(e, t, n), n;
};
const rl = w("debugwebxr"), L_ = new $().setFromAxisAngle(new b(0, 1, 0), Math.PI);
class lr extends T {
  head;
  leftHand;
  rightHand;
  _leftHandMeshes;
  _rightHandMeshes;
  _syncTransforms;
  async onEnterXR(e) {
    if (!this.activeAndEnabled) return;
    rl && console.warn("AVATAR ENTER XR", this.guid, this.sourceId, this, this.activeAndEnabled), this._syncTransforms && (this._syncTransforms.length = 0), await this.prepareAvatar();
    const t = Mn.getFor(this);
    if (t?.owner) {
      const i = this.gameObject.addComponent(je);
      i.avatar = this.gameObject, i.connectionId = t.owner;
    } else this.context.connection.isConnected ? console.error("No player state found for avatar", this) : t && !this.context.connection.isConnected && (t.dontDestroy = !0);
  }
  onLeaveXR(e) {
    const t = this.gameObject.getComponent(je);
    t && t.destroy();
  }
  onUpdateXR(e) {
    if (!this.activeAndEnabled) return;
    const t = Mn.isLocalPlayer(this);
    if (!t) return;
    const i = e.xr;
    if (i.rig && i.rig.gameObject !== this.gameObject.parent && (this.gameObject.position.set(0, 0, 0), this.gameObject.rotation.set(0, 0, 0), this.gameObject.scale.set(1, 1, 1), i.rig.gameObject.add(this.gameObject)), this._syncTransforms && t)
      for (const l of this._syncTransforms)
        l.fastMode = !0, l.isOwned() || l.requestOwnership();
    if (this.head && this.context.mainCamera) {
      const l = this.head.asset;
      if (l.position.copy(this.context.mainCamera.position), l.position.x *= -1, l.position.z *= -1, l.quaternion.copy(this.context.mainCamera.quaternion), l.quaternion.x *= -1, this.context.time.frameCount % 10 === 0 && this.head.asset) {
        const c = S.getComponentsInChildren(this.head.asset, nn);
        for (const h of c)
          h.enabled = !1, h.gameObject.visible = !1;
      }
    }
    const n = e.xr.leftController, o = this.leftHand?.asset;
    n && o ? (o.position.copy(n.gripPosition), o.quaternion.copy(n.gripQuaternion), o.quaternion.multiply(L_), o.visible = n.isTracking, this.updateHandVisibility(n, o, this._leftHandMeshes)) : o && o.visible && (o.visible = !1);
    const r = e.xr.rightController, a = this.rightHand?.asset;
    r && a ? (a.position.copy(r.gripPosition), a.quaternion.copy(r.gripQuaternion), a.quaternion.multiply(L_), a.visible = r.isTracking, this.updateHandVisibility(r, a, this._rightHandMeshes)) : a && a.visible && (a.visible = !1);
  }
  onBeforeRender() {
    this.context.xr && this.context.time.frame % 10 === 0 && this.updateRemoteAvatarVisibility();
  }
  updateHandVisibility(e, t, i) {
    if (i) {
      const n = e.model && e.model.visible && e.model !== t;
      i.forEach((o) => {
        hs(o, !n);
      });
    }
  }
  updateRemoteAvatarVisibility() {
    if (this.context.connection.isConnected) {
      const e = Mn.getFor(this);
      if (e && e.isLocalPlayer == !1) {
        const t = K.getXRSync(this.context);
        if (t && t.hasState(e.owner)) {
          this.tryFindAvatarObjectsIfMissing();
          const i = this.leftHand?.asset;
          i && (i.visible = t?.isTracking(e.owner, "left") ?? !1);
          const n = this.rightHand?.asset;
          n && (n.visible = t?.isTracking(e.owner, "right") ?? !1);
        }
        if (this.head?.asset) {
          const i = S.getComponentsInChildren(this.head.asset, nn);
          for (const n of i)
            n.enabled = !1, n.gameObject.visible = !0;
        }
      }
    }
  }
  tryFindAvatarObjectsIfMissing() {
    if (!this.head || !this.leftHand || !this.rightHand) {
      const e = { head: this.head, leftHand: this.leftHand, rightHand: this.rightHand };
      I1.tryFindAvatarObjects(this.gameObject, this.sourceId || "", e), e.head && (this.head = e.head), e.leftHand && (this.leftHand = e.leftHand), e.rightHand && (this.rightHand = e.rightHand);
    }
  }
  async prepareAvatar() {
    if (this.tryFindAvatarObjectsIfMissing(), this.head)
      this.head instanceof M && (this.head = new ie("", this.sourceId, this.head));
    else {
      const e = new M();
      e.name = "Head";
      const t = Oa.createPrimitive(ma.Cube);
      e.add(t), this.gameObject.add(e), this.head = new ie("", this.sourceId, e), rl && console.log("Create head", e);
    }
    if (this.rightHand)
      this.rightHand instanceof M && (this.rightHand = new ie("", this.sourceId, this.rightHand));
    else {
      const e = new M();
      e.name = "Right Hand", this.gameObject.add(e), this.rightHand = new ie("", this.sourceId, e), rl && console.log("Create right hand", e);
    }
    if (this.leftHand)
      this.leftHand instanceof M && (this.leftHand = new ie("", this.sourceId, this.leftHand));
    else {
      const e = new M();
      e.name = "Left Hand", this.gameObject.add(e), this.leftHand = new ie("", this.sourceId, e), rl && console.log("Create left hand", e);
    }
    await this.loadAvatarObjects(this.head, this.leftHand, this.rightHand), this._leftHandMeshes = [], this.leftHand.asset?.traverse((e) => {
      e?.isMesh && this._leftHandMeshes.push(e);
    }), this._rightHandMeshes = [], this.rightHand.asset?.traverse((e) => {
      e?.isMesh && this._rightHandMeshes.push(e);
    }), Mn.isLocalPlayer(this.gameObject) && (this._syncTransforms = S.getComponentsInChildren(this.gameObject, Fn));
  }
  async loadAvatarObjects(e, t, i) {
    const n = e.loadAssetAsync(), o = t.loadAssetAsync(), r = i.loadAssetAsync(), a = new Array();
    n && a.push(n), o && a.push(o), r && a.push(r);
    const l = await Tb(a);
    rl && console.log("Avatar loaded results:", l);
  }
}
ug([
  u(ie)
], lr.prototype, "head");
ug([
  u(ie)
], lr.prototype, "leftHand");
ug([
  u(ie)
], lr.prototype, "rightHand");
var gR = Object.defineProperty, mu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && gR(e, t, n), n;
};
const Jn = w("debugwebxr"), zs = new Array();
class uo extends T {
  createControllerModel = !0;
  createHandModel = !0;
  customLeftHand;
  customRightHand;
  static factory = new yS();
  supportsXR(e) {
    return e === "immersive-vr" || e === "immersive-ar";
  }
  _models = new Array();
  async onXRControllerAdded(e) {
    if (!(e.xr.isVR || e.xr.isPassThrough)) return;
    const { controller: i } = e;
    if (Jn && console.warn("Add Controller Model for", i.side, i.index), this.createControllerModel || this.createHandModel) {
      if (i.hand) {
        if (this.createHandModel) {
          const n = await this.loadHandModel(this, i);
          if (!n || !i.connected || !i.isHand) {
            n?.handObject && el(n.handObject, !1), n?.handObject?.destroy();
            return;
          }
          this._models.push({ controller: i, model: n.handObject, handmesh: n.handmesh }), this._models.sort((o, r) => o.controller.index - r.controller.index), this.scene.add(n.handObject), i.model = n.handObject;
        }
      } else if (this.createControllerModel) {
        const n = await i.getModelUrl();
        if (n) {
          const o = await this.loadModel(i, n);
          if (!o || !i.connected || i.isHand)
            return;
          this._models.push({ controller: i, model: o }), this._models.sort((r, a) => r.controller.index - a.controller.index), this.scene.add(o), o.traverse((r) => {
            r.layers.set(2), r.matrixAutoUpdate = !1, r.updateMatrix();
          }), i.model = o;
        } else i.targetRayMode !== "transient-pointer" && console.warn("XRControllerModel: no model found for " + i.side);
      }
    }
  }
  onXRControllerRemoved(e) {
    console.debug("XR Controller Removed", e.controller.side, e.controller.index);
    const t = this._models.findIndex((n) => n.controller === e.controller), i = this._models[t];
    i && (this._models.splice(t, 1), i.model && (el(i.model, !1), i.model.destroy(), i.model = void 0));
  }
  onBeforeXR(e, t) {
    this.createHandModel && (this.customLeftHand || this.customRightHand) && (t.optionalFeatures = t.optionalFeatures || [], t.optionalFeatures.includes("hand-tracking") || t.optionalFeatures.push("hand-tracking"));
  }
  onLeaveXR(e) {
    for (const t of this._models)
      t && (t.model && (el(t.model, !1), t.model.destroy(), t.model = void 0), t.controller.model === t.model && (t.controller.model = null));
    this._models.length = 0;
  }
  onBeforeRender() {
    if (K.active && (Jn && (zs[0] = Date.now()), this.updateRendering(K.active), Jn)) {
      const e = Date.now() - zs[0];
      zs.push(e), zs.length >= 30 && (zs[0] = 0, zs.reduce((t, i) => t + i, 0) / zs.length, zs.length = 0);
    }
  }
  updateRendering(e) {
    for (let t = 0; t < this._models.length; t++) {
      const i = this._models[t];
      if (!i) continue;
      const n = i.controller;
      if (!n.connected) {
        Jn && console.warn("XRControllerModel.onUpdateXR: controller is not connected anymore", n.side, n.hand);
        continue;
      }
      if (i.model && !i.handmesh)
        i.model.matrixAutoUpdate = !1, i.model.matrix.copy(n.gripMatrix), i.model.visible = n.isTracking, e.rig?.gameObject.add(i.model);
      else if (n.inputSource.hand && i.handmesh) {
        const o = e.referenceSpace, r = this.context.renderer.xr.getHand(n.index);
        if (o && e.frame.getJointPose) {
          for (const a of n.inputSource.hand.values()) {
            const l = r.joints[a.jointName];
            if (l) {
              const c = n.getHandJointPose(a);
              if (c) {
                const h = c.transform.position, d = c.transform.orientation;
                l.position.copy(h), l.quaternion.copy(d), l.matrixAutoUpdate = !1;
              }
              l.visible = c != null;
            }
          }
          i.model && (i.model.visible = n.isTracking, i.model.visible && i.model.parent !== e.rig?.gameObject && e.rig?.gameObject.add(i.model)), i.model?.visible && (i.handmesh?.updateMesh(), i.model.matrixAutoUpdate = !1, i.model.matrix.identity(), i.model.applyMatrix4(Kr));
        }
      }
    }
  }
  async loadModel(e, t) {
    if (!e.connected)
      return console.warn("XRControllerModel.onXRControllerAdded: controller is not connected anymore", e.side), null;
    const n = await ie.getOrCreate("", t).instantiate();
    return el(n), K.active?.isPassThrough && n.traverseVisible((o) => {
      this.makeOccluder(o);
    }), n;
  }
  async loadHandModel(e, t) {
    const i = this.context, n = i.renderer.xr.getHand(t.index);
    n || (Jn ? F.DrawLabel(t.rayWorldPosition, "No hand found for index " + t.index, 0.05, 5) : console.warn("No hand found for index " + t.index));
    const o = new Ps();
    $m(o, i), await Fp(o, i, this.sourceId ?? "");
    const r = uv(o);
    let a = "";
    const l = t.side === "left" ? this.customLeftHand : this.customRightHand;
    l ? (a = l.url.split(".").slice(0, -1).join("."), o.setPath("")) : (a = t.inputSource.handedness === "left" ? "left" : "right", o.setPath("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/"));
    const c = new M();
    el(c);
    const h = new _S(c, n, o.path, a, o, (d) => {
      const f = r?.gltf;
      f?.scene.children?.length === 0 && (f.scene.children[0] = d), r?.gltf && jn().createBuiltinComponents(e.context, e.sourceId || a, r.gltf, null, r), d.traverse((p) => {
        p.layers.set(2), K.active?.isPassThrough && !l && this.makeOccluder(p), p instanceof H && We.assignMeshLOD(p, 0);
      }), t.connected || (Jn && F.DrawLabel(t.rayWorldPosition, "Hand is loaded but not connected anymore", 0.05, 5), d.removeFromParent());
    });
    if (Jn && c.add(new mi(0.5)), t.inputSource.hand) {
      Jn && console.log(t.inputSource.hand);
      for (const d of t.inputSource.hand.values())
        if (n.joints[d.jointName] === void 0) {
          const f = new io();
          f.matrixAutoUpdate = !1, f.visible = !0, n.joints[d.jointName] = f, n.add(f);
        }
    } else
      Jn && F.DrawLabel(t.rayWorldPosition, "No inputSource.hand found for index " + t.index, 0.05, 5);
    return { handObject: c, handmesh: h };
  }
  makeOccluder(e) {
    if (e instanceof H) {
      let t = e.material;
      t instanceof _e && (t = e.material = t.clone(), t.depthWrite = !0, t.depthTest = !0, t.colorWrite = !1, e.receiveShadow = !1, e.renderOrder = -100);
    }
  }
}
mu([
  u()
], uo.prototype, "createControllerModel");
mu([
  u()
], uo.prototype, "createHandModel");
mu([
  u(ie)
], uo.prototype, "customLeftHand");
mu([
  u(ie)
], uo.prototype, "customRightHand");
class fg extends T {
}
var yR = Object.defineProperty, bo = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && yR(e, t, n), n;
};
const jf = w("debugwebxr");
class Gi extends T {
  movementSpeed = 1.5;
  rotationStep = 30;
  useTeleport = !0;
  usePinchToTeleport = !0;
  useTeleportTarget = !1;
  useTeleportFade = !1;
  showRays = !0;
  showHits = !0;
  isXRMovementHandler = !0;
  xrSessionMode = "immersive-vr";
  _didApplyRotation = !1;
  _didTeleport = !1;
  onUpdateXR(e) {
    const t = e.xr.rig;
    if (!t?.gameObject || e.xr.isPassThrough)
      return;
    const i = e.xr.leftController, n = e.xr.rightController;
    i && this.onHandleMovement(i, t.gameObject), n && (this.onHandleRotation(n, t.gameObject), this.useTeleport && this.onHandleTeleport(n, t.gameObject));
  }
  onLeaveXR(e) {
    for (const t of this._lines)
      t.removeFromParent();
    for (const t of this._hitDiscs)
      t?.removeFromParent();
  }
  onBeforeRender() {
    this.context.xr?.running && (this.showRays && this.renderRays(this.context.xr), this.showHits && this.renderHits(this.context.xr));
  }
  onHandleMovement(e, t) {
    const i = e.getStick("xr-standard-thumbstick");
    if (i.x != 0 || i.y != 0) {
      const n = G(i.x, 0, i.y);
      n.multiplyScalar(this.context.time.deltaTimeUnscaled * this.movementSpeed);
      const o = $e(t);
      n.multiplyScalar(o.x), n.applyQuaternion(e.xr.poseOrientation), n.y = 0, n.applyQuaternion(t.worldQuaternion), t.position.add(n), t.updateWorldMatrix(!1, !1);
      for (const r of t.children) r.updateWorldMatrix(!1, !1);
    }
  }
  onHandleRotation(e, t) {
    if (e._isMxInk) return;
    const n = e.getStick("xr-standard-thumbstick").x;
    if (this._didApplyRotation)
      Math.abs(n) < 0.3 && (this._didApplyRotation = !1);
    else if (Math.abs(n) > 0.5) {
      this._didApplyRotation = !0;
      const o = n > 0 ? 1 : -1, r = Z(this.context.mainCamera).clone();
      t.rotateY(o * j.toRadians(this.rotationStep));
      const l = Z(this.context.mainCamera).clone().sub(r);
      l.y = 0, t.position.sub(l);
    }
  }
  _teleportBuffer = new Array();
  onHandleTeleport(e, t) {
    let i = 0;
    if (e.hand && this.usePinchToTeleport && e.isTeleportGesture) {
      const n = e.getPointerId("primary");
      if (n != null && this.context.input.getIsPointerIdInUse(n))
        return;
      const o = e.getGesture("pinch");
      o && (i = o.value);
    } else
      i = e.getStick("xr-standard-thumbstick")?.y;
    if (this._didTeleport)
      i >= 0 && i < 0.4 ? this._didTeleport = !1 : i < 0 && i > -0.4 && (this._didTeleport = !1);
    else if (i > 0.8) {
      this._didTeleport = !0;
      const n = this.context.physics.raycastFromRay(e.ray)[0];
      if (n && n.object instanceof da) {
        const r = n.normal?.dot(G(0, 1, 0));
        if (r !== void 0 && r < 0.4)
          return;
      }
      let o = n?.point;
      if (!o && !this.useTeleportTarget) {
        this._plane || (this._plane = new nr(new b(0, 1, 0), 0));
        const r = t.worldPosition;
        this._plane.setFromNormalAndCoplanarPoint(new b(0, 1, 0), r);
        const a = e.ray;
        o = r.clone(), this._plane.intersectLine(new Ux(a.origin, G(a.direction).multiplyScalar(1e4).add(a.origin)), o), o.distanceTo(r) > t.scale.x * 10 && (o = null);
      }
      if (o) {
        if (this.useTeleportTarget && !S.getComponentInParent(n.object, fg))
          return;
        const r = o.clone();
        if (jf && F.DrawSphere(o, 0.025, 16711680, 5), this.context.mainCamera?.position) {
          const l = this.context.xr?.getUserOffsetInRig();
          l && (l.y = 0, r.sub(l), jf && F.DrawWireSphere(l.add(r), 0.025, 65280, 5));
        }
        this._teleportBuffer.push(t.matrix.clone()), this._teleportBuffer.length > 10 && this._teleportBuffer.shift(), this.useTeleportFade ? e.xr.fadeTransition()?.then(() => {
          t.worldPosition = r;
        }) : t.worldPosition = r;
      }
    } else if (i < -0.8 && (this._didTeleport = !0, this._teleportBuffer.length > 0)) {
      const n = this._teleportBuffer.pop();
      n && n.decompose(t.position, t.quaternion, t.scale);
    }
  }
  _plane = null;
  _lines = [];
  _hitDiscs = [];
  _hitDistances = [];
  _lastHitDistances = [];
  renderRays(e) {
    for (let t = 0; t < this._lines.length; t++) {
      const i = this._lines[t];
      i && (i.visible = !1);
    }
    for (let t = 0; t < e.controllers.length; t++) {
      const i = e.controllers[t];
      let n = this._lines[t];
      if (!i.connected || !i.isTracking || !i.ray || i.targetRayMode === "transient-pointer" || !i.hasSelectEvent) {
        n && (n.visible = !1);
        continue;
      }
      n || (n = this.createRayLineObject(), n.scale.z = 0.5, this._lines[t] = n), i.updateRayWorldPosition(), i.updateRayWorldQuaternion();
      const o = i.rayWorldPosition, r = i.rayWorldQuaternion;
      n.position.copy(o), n.quaternion.copy(r);
      const a = e.rigScale, l = this.usePinchToTeleport && i.isTeleportGesture, c = this._lastHitDistances[t], h = this._hitDistances[t] != null, d = c ?? a;
      n.scale.set(a, a, d), n.visible = !0, n.layers.disableAll(), n.layers.enable(2);
      let f = n.material.opacity;
      l ? f = 1 : this.showHits && d < e.rigScale * 0.5 ? f = 0 : i.getButton("primary")?.pressed ? f = 0.5 : f = h ? 0.2 : 0.1, n.material.opacity = j.lerp(n.material.opacity, f, this.context.time.deltaTimeUnscaled / 0.1), n.parent !== this.context.scene && this.context.scene.add(n);
    }
  }
  renderHits(e) {
    for (const t of this._hitDiscs) {
      if (!t) continue;
      const i = t.controller;
      if (!i || !i.connected || !i.isTracking) {
        t.visible = !1;
        continue;
      }
    }
    for (let t = 0; t < e.controllers.length; t++) {
      const i = e.controllers[t];
      if (!i.connected || !i.isTracking || !i.ray || !i.hasSelectEvent) continue;
      let n = this._hitDiscs[t], o = !0;
      const r = i.getPointerId("primary");
      r != null && this.context.input.getIsPointerIdInUse(r) && (n && (n.visible = !1), this._hitDistances[t] = null, this._lastHitDistances[t] = 0, o = !1);
      const a = this.context.time.smoothedFps >= 59 ? 1 : 10;
      if ((this.context.time.frame + i.index) % a !== 0 && (o = !1), !o) {
        const h = this._hitDiscs[t];
        h && h.visible && h.hit && this.updateHitPointerPosition(i, h, h.hit.distance);
        continue;
      }
      const l = this.context.physics.raycastFromRay(i.ray, { testObject: this.hitPointRaycastFilter, precise: !1 });
      let c = l.find((h) => this.usePinchToTeleport && i.isTeleportGesture ? !0 : this.isObjectWithInteractiveComponent(h.object));
      if (c || (c = l[0]), n && (n.controller = i, n.hit = c), this._hitDistances[t] = c?.distance || null, c) {
        this._lastHitDistances[t] = c.distance;
        const h = e.rigScale ?? 1;
        jf && (F.DrawWireSphere(c.point, 0.025 * h, 16711680), F.DrawLabel(G(0, 0.2, 0).add(c.point), c.object.name, 0.02, 0)), n || (n = this.createHitPointObject(), this._hitDiscs[t] = n), n.hit = c, n.visible = c.distance > h * 0.05;
        let d = 0.01 * (h + c.distance);
        const f = i.getButton("primary")?.pressed;
        f && (d *= 1.1), n.scale.set(d, d, d), n.layers.set(2);
        let p = n.material.opacity;
        if (f ? p = 1 : p = c.distance < 0.15 * h ? 0.2 : 0.6, n.material.opacity = j.lerp(n.material.opacity, p, this.context.time.deltaTimeUnscaled / 0.1), n.visible) {
          if (c.normal) {
            this.updateHitPointerPosition(i, n, c.distance);
            const g = c.normal.applyQuaternion(be(c.object));
            n.quaternion.setFromUnitVectors(_R, g);
          } else
            this.updateHitPointerPosition(i, n, c.distance);
          n.parent !== this.context.scene && this.context.scene.add(n);
        }
      } else
        this._hitDiscs[t] && (this._hitDiscs[t].visible = !1);
    }
  }
  isObjectWithInteractiveComponent(e, t = 0) {
    return Lp(e) || e.isUI === !0 ? !0 : e.isScene ? !1 : e.parent ? this.isObjectWithInteractiveComponent(e.parent, t + 1) : !1;
  }
  updateHitPointerPosition(e, t, i) {
    const n = G(e.rayWorldPosition);
    n.add(G(0, 0, i - 0.01).applyQuaternion(e.rayWorldQuaternion)), t.position.lerp(n, this.context.time.deltaTimeUnscaled / 0.05);
  }
  hitPointRaycastFilter = (e) => e.type === "SkinnedMesh" ? "continue in children" : !0;
  /** create an object to visualize hit points in the scene */
  createHitPointObject() {
    const e = new H(
      new Ed(0.3, 6, 6),
      // new RingGeometry(.3, 0.5, 32).rotateX(- Math.PI / 2),
      new we({
        color: 15658734,
        opacity: 0.7,
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
        side: yi
      })
    );
    return e.layers.disableAll(), e.layers.enable(2), e;
  }
  /** create an object to visualize controller rays */
  createRayLineObject() {
    const e = new bS();
    e.layers.disableAll(), e.layers.enable(2);
    const t = new vS();
    e.geometry = t;
    const i = new Float32Array(9);
    i.set([0, 0, 0.02, 0, 0, 0.4, 0, 0, 1]), t.setPositions(i);
    const n = new Float32Array(9);
    n.set([1, 1, 1, 0.1, 0.1, 0.1, 0, 0, 0]), t.setColors(n);
    const o = new wS({
      color: 16777215,
      vertexColors: !0,
      worldUnits: !0,
      linewidth: 4e-3,
      transparent: !0,
      depthWrite: !1,
      // TODO: this doesnt work with passthrough
      blending: pb,
      dashed: !1
      // alphaToCoverage: true,
    });
    return e.material = o, e;
  }
}
bo([
  u()
], Gi.prototype, "movementSpeed");
bo([
  u()
], Gi.prototype, "rotationStep");
bo([
  u()
], Gi.prototype, "useTeleport");
bo([
  u()
], Gi.prototype, "usePinchToTeleport");
bo([
  u()
], Gi.prototype, "useTeleportTarget");
bo([
  u()
], Gi.prototype, "useTeleportFade");
bo([
  u()
], Gi.prototype, "showRays");
bo([
  u()
], Gi.prototype, "showHits");
const _R = new b(0, 1, 0);
var bR = Object.defineProperty, gt = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && bR(e, t, n), n;
};
const al = w("debugwebxr"), vR = w("debugusdz"), rt = class Wr extends T {
  createVRButton = !0;
  createARButton = !0;
  createSendToQuestButton = !0;
  createQRCode = !0;
  useDefaultControls = !0;
  showControllerModels = !0;
  showHandModels = !0;
  usePlacementReticle = !0;
  customARPlacementReticle;
  usePlacementAdjustment = !0;
  arScale = 1;
  useXRAnchor = !1;
  autoPlace = !1;
  autoCenter = !1;
  useQuicklookExport = !1;
  useDepthSensing = !1;
  useSpatialGrab = !0;
  defaultAvatar;
  _playerSync;
  /** these components were created by the WebXR component on session start and will be cleaned up again in session end */
  _createdComponentsInSession = [];
  _usdzExporter;
  static activeWebXRComponent = null;
  /**
   * Initializes the WebXR component by obtaining the XR sync object for this context.
   * @internal
   */
  awake() {
    K.getXRSync(this.context);
  }
  /**
   * Sets up the WebXR component when it's enabled. Checks for HTTPS connection,
   * sets up USDZ export if enabled, creates UI buttons, and configures avatar settings.
   * @internal
   */
  onEnable() {
    window.location.protocol !== "https:" && ge('<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API" target="_blank">WebXR</a> only works on secure connections (https).'), this.useQuicklookExport && (S.findObjectOfType(ws) || (al && console.log("WebXR: Adding USDZExporter"), this._usdzExporter = S.addComponent(this.gameObject, ws), this._usdzExporter.objectToExport = this.context.scene, this._usdzExporter.autoExportAnimations = !0, this._usdzExporter.autoExportAudioSources = !0)), this.handleCreatingHTML(), this.handleOfferSession(), this.defaultAvatar === !0 && (al && console.warn("WebXR: No default avatar set, using static default avatar"), this.defaultAvatar = new ie("https://cdn.needle.tools/static/avatars/DefaultAvatar.glb")), this.defaultAvatar && (this._playerSync = this.gameObject.getOrAddComponent(jv), this._playerSync.autoSync = !1), this._playerSync && typeof this.defaultAvatar != "boolean" && (this._playerSync.asset = this.defaultAvatar, this._playerSync.onPlayerSpawned?.removeEventListener(this.onAvatarSpawned), this._playerSync.onPlayerSpawned?.addEventListener(this.onAvatarSpawned));
  }
  /**
   * Cleans up resources when the component is disabled.
   * Destroys the USDZ exporter if one was created and removes UI buttons.
   * @internal
   */
  onDisable() {
    this._usdzExporter?.destroy(), this.removeButtons();
  }
  /**
   * Checks if WebXR is supported and offers an appropriate session.
   * This is used to show the WebXR session joining prompt in browsers that support it.
   * @returns A Promise that resolves to true if a session was offered, false otherwise
   */
  async handleOfferSession() {
    return this.createVRButton && await K.isVRSupported() && this.createVRButton ? K.offerSession("immersive-vr", "default", this.context) : this.createARButton && await K.isARSupported() && this.createARButton ? K.offerSession("immersive-ar", "default", this.context) : !1;
  }
  /** the currently active webxr input session */
  get session() {
    return K.active ?? null;
  }
  /** immersive-vr or immersive-ar */
  get sessionMode() {
    return K.activeMode ?? null;
  }
  /** While AR: this will return the currently active WebARSessionRoot component.   
   * You can also query this component in your scene with `findObjectOfType(WebARSessionRoot)` 
   */
  get arSessionRoot() {
    return this._activeWebARSessionRoot;
  }
  /** Call to start an WebVR session.     
   * 
   * This is a shorthand for `NeedleXRSession.start("immersive-vr", init, this.context)`
  */
  async enterVR(e) {
    return K.start("immersive-vr", e, this.context);
  }
  /** Call to start an WebAR session   
   * 
   * This is a shorthand for `NeedleXRSession.start("immersive-ar", init, this.context)`
  */
  async enterAR(e) {
    return K.start("immersive-ar", e, this.context);
  }
  /** Call to end a WebXR (AR or VR) session.   
   * 
   * This is a shorthand for `NeedleXRSession.stop()`
   */
  exitXR() {
    K.stop();
  }
  _exitXRMenuButton;
  _previousXRState = 0;
  _spatialGrabRaycaster;
  _activeWebARSessionRoot = null;
  get isActiveWebXR() {
    return !Wr.activeWebXRComponent || Wr.activeWebXRComponent === this;
  }
  /**
   * Called before entering a WebXR session. Sets up optional features like depth sensing, if needed.
   * @param _mode The XR session mode being requested (immersive-ar or immersive-vr)
   * @param args The XRSessionInit object that will be passed to the WebXR API
   * @internal
   */
  onBeforeXR(e, t) {
    if (!this.isActiveWebXR) {
      console.warn(`WebXR: another WebXR component is already active (${Wr.activeWebXRComponent?.name}). This is ignored: ${this.name}`);
      return;
    }
    Wr.activeWebXRComponent = this, e == "immersive-ar" && this.useDepthSensing && (t.optionalFeatures = t.optionalFeatures || [], t.optionalFeatures.push("depth-sensing"));
  }
  /**
   * Called when a WebXR session begins. Sets up the scene for XR by configuring controllers,
   * AR placement, and other features based on component settings.
   * @param args Event arguments containing information about the started XR session
   * @internal
   */
  async onEnterXR(e) {
    if (!this.isActiveWebXR) return;
    al && console.log("WebXR onEnterXR"), this._previousXRState = Zt.Global.Mask;
    const t = e.xr.isVR;
    if (Zt.Global.Set(t ? us.VR : us.AR), e.xr.isAR) {
      let i = S.findObjectOfType(Ni);
      if (!i)
        if (this.usePlacementReticle) {
          const n = new M();
          for (const o of this.context.scene.children)
            n.add(o);
          this.context.scene.add(n), i = S.addComponent(n, Ni), this._createdComponentsInSession.push(i);
        } else (al || L()) && console.warn("WebXR: No WebARSessionRoot found in scene and usePlacementReticle is disabled in WebXR component.");
      this._activeWebARSessionRoot = i, i && (i.customReticle = this.customARPlacementReticle, i.arScale = this.arScale, i.arTouchTransform = this.usePlacementAdjustment, i.autoPlace = this.autoPlace, i.autoCenter = this.autoCenter, i.useXRAnchor = this.useXRAnchor);
    }
    this.useDefaultControls && this.setDefaultMovementEnabled(!0), (this.showControllerModels || this.showHandModels) && this.setDefaultControllerRenderingEnabled(!0), this.useSpatialGrab && (this._spatialGrabRaycaster = S.findObjectOfType(Ca) ?? void 0, this._spatialGrabRaycaster || (this._spatialGrabRaycaster = this.gameObject.addComponent(Ca))), this.createLocalAvatar(e.xr), e.xr.isScreenBasedAR || (this._exitXRMenuButton = this.context.menu.appendChild({
      label: "Quit XR",
      onClick: () => this.exitXR(),
      icon: "exit_to_app",
      priority: 2e4
    }));
  }
  /**
   * Called every frame during an active WebXR session.
   * Updates components that depend on the current XR state.
   * @param _args Event arguments containing information about the current XR session frame
   * @internal
   */
  onUpdateXR(e) {
    this.isActiveWebXR && this._spatialGrabRaycaster && (this._spatialGrabRaycaster.enabled = this.useSpatialGrab);
  }
  /**
   * Called when a WebXR session ends. Restores pre-session state,
   * removes temporary components, and cleans up resources.
   * @param _ Event arguments containing information about the ended XR session
   * @internal
   */
  onLeaveXR(e) {
    if (this._exitXRMenuButton?.remove(), !!this.isActiveWebXR) {
      Zt.Global.Set(this._previousXRState), this._playerSync?.destroyInstance();
      for (const t of this._createdComponentsInSession)
        t.destroy();
      this._createdComponentsInSession.length = 0, this._activeWebARSessionRoot = null, this.handleOfferSession(), Ud(1).then(() => Wr.activeWebXRComponent = null);
    }
  }
  /** Call to enable or disable default controller behaviour */
  setDefaultMovementEnabled(e) {
    let t = this.gameObject.getComponent(Gi);
    return !t && e && (t = this.gameObject.addComponent(Gi), this._createdComponentsInSession.push(t)), t && (t.enabled = e), t;
  }
  /** Call to enable or disable default controller rendering */
  setDefaultControllerRenderingEnabled(e) {
    let t = this.gameObject.getComponent(uo);
    return !t && e && (t = this.gameObject.addComponent(uo), this._createdComponentsInSession.push(t), t.createControllerModel = this.showControllerModels, t.createHandModel == this.showHandModels), t && (t.enabled = e), t;
  }
  /**
   * Creates and instantiates the user's avatar representation in the WebXR session.
   * @param xr The active session
   */
  async createLocalAvatar(e) {
    this._playerSync && e.running && typeof this.defaultAvatar != "boolean" && (this._playerSync.asset = this.defaultAvatar, await this._playerSync.getInstance());
  }
  /**
   * Event handler called when a player avatar is spawned.
   * Ensures the avatar has the necessary Avatar component.
   * @param instance The spawned avatar 3D object
   */
  onAvatarSpawned = (e) => {
    al && console.log("WebXR.onAvatarSpawned", e);
    let t = S.getComponentInChildren(e, lr);
    t ??= S.addComponent(e, lr);
  };
  // HTML UI
  /** @deprecated use {@link getButtonsFactory} or directly access {@link WebXRButtonFactory.getOrCreate} */
  getButtonsContainer() {
    return this.getButtonsFactory();
  }
  /**
   * Returns the WebXR button factory, creating one if it doesn't exist.
   * Use this to access and modify WebXR UI buttons.
   * @returns The WebXRButtonFactory instance
   */
  getButtonsFactory() {
    return this._buttonFactory || (this._buttonFactory = ir.getOrCreate()), this._buttonFactory;
  }
  /**
   * Reference to the WebXR button factory used by this component.
   */
  _buttonFactory;
  /**
   * Creates and sets up UI elements for WebXR interaction based on component settings
   * and device capabilities. Handles creating AR, VR, QuickLook buttons and utility buttons like QR codes.
   */
  handleCreatingHTML() {
    if (this.createARButton || this.createVRButton || this.useQuicklookExport) {
      if ((X.isiOS() && X.isSafari() || vR) && this.useQuicklookExport) {
        const t = S.findObjectOfType(ws);
        if (!t || t && t.allowCreateQuicklookButton) {
          const i = this.getButtonsFactory().createQuicklookButton();
          this.addButton(i, 50);
        }
      }
      if (this.createARButton) {
        const t = this.getButtonsFactory().createARButton();
        this.addButton(t, 50);
      }
      if (this.createVRButton) {
        const t = this.getButtonsFactory().createVRButton();
        this.addButton(t, 50);
      }
    }
    if (this.createSendToQuestButton && !X.isQuest() && K.isVRSupported().then((t) => {
      if (!t) {
        const i = this.getButtonsFactory().createSendToQuestButton();
        this.addButton(i, 50);
      }
    }), this.createQRCode) {
      const t = Qd(Es);
      if (t && t.createQRCodeButton === !1)
        L() && console.warn("WebXR: QRCode button is disabled in the Needle Menu component");
      else if (!X.isMobileDevice()) {
        const i = On.getOrCreate().createQRCode();
        this.addButton(i, 50);
      }
    }
  }
  /**
   * Storage for UI buttons created by this component.
   */
  _buttons = [];
  /**
   * Adds a button to the UI with the specified priority.
   * @param button The HTML element to add
   * @param priority The button's priority value (lower numbers appear first)
   */
  addButton(e, t) {
    this._buttons.push(e), e.setAttribute("priority", t.toString()), this.context.menu.appendChild(e);
  }
  /**
   * Removes all buttons created by this component from the UI.
   */
  removeButtons() {
    for (const e of this._buttons)
      e.remove();
    this._buttons.length = 0;
  }
};
gt([
  u()
], rt.prototype, "createVRButton");
gt([
  u()
], rt.prototype, "createARButton");
gt([
  u()
], rt.prototype, "createSendToQuestButton");
gt([
  u()
], rt.prototype, "createQRCode");
gt([
  u()
], rt.prototype, "useDefaultControls");
gt([
  u()
], rt.prototype, "showControllerModels");
gt([
  u()
], rt.prototype, "showHandModels");
gt([
  u()
], rt.prototype, "usePlacementReticle");
gt([
  u(ie)
], rt.prototype, "customARPlacementReticle");
gt([
  u()
], rt.prototype, "usePlacementAdjustment");
gt([
  u()
], rt.prototype, "arScale");
gt([
  u()
], rt.prototype, "useXRAnchor");
gt([
  u()
], rt.prototype, "autoPlace");
gt([
  u()
], rt.prototype, "autoCenter");
gt([
  u()
], rt.prototype, "useQuicklookExport");
gt([
  u()
], rt.prototype, "useDepthSensing");
gt([
  u()
], rt.prototype, "useSpatialGrab");
gt([
  u(ie)
], rt.prototype, "defaultAvatar");
let pg = rt;
const mh = w("debugusdzbehaviours");
class Bv {
  get extensionName() {
    return "Behaviour";
  }
  behaviours = [];
  addBehavior(e) {
    this.behaviours.push(e);
  }
  /** Register audio clip for USDZ export. The clip will be embedded in the resulting file. */
  addAudioClip(e) {
    if (!e || typeof e != "string") return "";
    const i = "audio/" + La.getName(e);
    return this.audioClips.push({ clipUrl: e, filesKey: i }), i;
  }
  behaviourComponents = [];
  behaviourComponentsCopy = [];
  audioClips = [];
  audioClipsCopy = [];
  targetUuids = /* @__PURE__ */ new Set();
  getAllTargetUuids() {
    return this.targetUuids;
  }
  onBeforeBuildDocument(e) {
    if (!e.root) return Promise.resolve();
    const t = [];
    return e.root.traverse((i) => {
      S.foreachComponent(i, (n) => {
        const o = n;
        if (typeof o.createBehaviours == "function" || typeof o.beforeCreateDocument == "function" || typeof o.afterCreateDocument == "function" || typeof o.afterSerialize == "function") {
          this.behaviourComponents.push(o);
          const r = o.beforeCreateDocument?.call(o, this, e);
          r instanceof Promise && t.push(r);
        }
      }, !1);
    }), mh && console.log("onBeforeBuildDocument: all components", this.behaviourComponents), Promise.all(t);
  }
  onExportObject(e, t, i) {
    for (const n of this.behaviourComponents)
      n.createBehaviours?.call(n, this, t, i);
  }
  onAfterBuildDocument(e) {
    for (const d of this.behaviourComponents)
      typeof d.afterCreateDocument == "function" && d.afterCreateDocument(this, e);
    this.behaviourComponentsCopy = this.behaviourComponents.slice(), this.behaviourComponents.length = 0, this.audioClipsCopy = this.audioClips.slice(), this.audioClips.length = 0;
    const t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = mh;
    let a = `graph LR
`, l = "";
    function c(d) {
      if (d instanceof Xr) {
        r && (a += `subgraph Group_${d.id}
`);
        for (const f of d.actions)
          r && (a += `${d.id}[${d.id}] -- ${d.type},loops:${d.loops} --> ${f.id}[${f.id}]
`), c(f);
        r && (a += `end
`);
      } else if (d instanceof ai) {
        d.tokenId === "StartAnimation" && o.add(d);
        let f = d.tokenId;
        d.type !== void 0 && (f += ":" + d.type);
        const p = d.affectedObjects;
        if (p)
          if (Array.isArray(p))
            for (const _ of p)
              i.add(_), r && (l += `${d.id}[${d.id}
${f}] -- ${f} --> ${_.uuid}(("${_.displayName || _.name || _.uuid}"))
`);
          else typeof p == "object" ? (i.add(p), r && (l += `${d.id}[${d.id}
${f}] -- ${f} --> ${p.uuid}(("${p.displayName || p.name || p.uuid}"))
`)) : typeof p == "string" && i.add({ uuid: p });
        const g = d.xFormTarget;
        g && (typeof g == "object" ? (i.add(g), r && (l += `${d.id}[${d.id}
${f}] -- ${f} --> ${g.uuid}(("${g.displayName || g.name || g.uuid}"))
`)) : typeof g == "string" && i.add({ uuid: g }));
      }
    }
    function h(d, f) {
      if (Array.isArray(d))
        for (const p of d)
          h(p, f);
      else if (d instanceof tr) {
        let p = d.tokenId;
        d.type !== void 0 && (p += ":" + d.type), typeof d.targetId == "object" && (t.add(d.targetId), r && (l += `${d.targetId.uuid}(("${d.targetId.displayName}")) --> ${d.id}[${d.id}
${p}]
`)), r && (a += `${d.id}((${d.id})) -- ${p} --> ${f.id}[${f.tokenId || f.id}]
`);
      }
    }
    for (const d of this.behaviours)
      r && (a += `subgraph ${d.id}
`), c(d.action), h(d.trigger, d.action), r && (a += `end
`);
    r && (a += `
` + l), r && (console.log("All USDZ behaviours", this.behaviours), this.behaviours.length && (console.warn("The Mermaid graph can be pasted into https://massive-mermaid.glitch.me/ or https://mermaid.live/edit. It should be in your clipboard already!"), console.log(a), navigator.clipboard.writeText(a)));
    {
      let d = `gantt
title Animations
dateFormat X
axisFormat %s
`;
      const f = Array.from(o), p = /* @__PURE__ */ new Set();
      for (const v of f)
        if (v.affectedObjects && typeof v.affectedObjects != "string") {
          if (Array.isArray(v.affectedObjects))
            for (const y of v.affectedObjects)
              p.add(y);
          else
            p.add(v.affectedObjects);
          r && (d += `section ${v.animationName} (${v.id})
`, d += `${v.id} : ${v.start}, ${v.duration}s
`);
        }
      r && o.size && console.log(d);
      const g = /* @__PURE__ */ new Set();
      for (const v of p) {
        v.getPath || console.error("USDZExporter: Animation target object has no getPath method. This is likely a bug", v);
        let y = v.getPath();
        y.startsWith("<") && (y = y.substring(1)), y.endsWith(">") && (y = y.substring(0, y.length - 1)), g.add({ path: y, obj: v });
      }
      const _ = Array.from(g).sort((v, y) => v.path.length - y.path.length), m = new Array();
      for (let v = 0; v < _.length; v++)
        for (let y = v + 1; y < _.length; y++)
          if (_[y].path.startsWith(_[v].path)) {
            const x = _[y], I = _[v];
            m.push({ child: x.obj.displayName + " (" + x.path + ")", parent: I.obj.displayName + " (" + I.path + ")" });
          }
      m.length && console.warn(
        "USDZExporter: There are overlapping PlayAnimation actions. This can lead to undefined runtime behaviour when playing multiple animations. Please restructure the hierarchy so that animations don't overlap.",
        {
          overlappingTargets: m,
          playAnimationActions: o
        }
      );
    }
    for (const d of /* @__PURE__ */ new Set([...t, ...i]))
      if (Array.isArray(d))
        for (const f of d)
          n.add(f.uuid);
      else
        n.add(d.uuid);
    mh && console.log("All Behavior trigger sources and action targets", t, i, n), this.targetUuids = new Set(n);
  }
  onAfterHierarchy(e, t) {
    if (this.behaviours?.length) {
      t.beginBlock('def Scope "Behaviors"');
      for (const i of this.behaviours)
        i.writeTo(this, e.document, t);
      t.closeBlock();
    }
  }
  async onAfterSerialize(e) {
    mh && console.log("onAfterSerialize behaviours", this.behaviourComponentsCopy);
    for (const t of this.behaviourComponentsCopy)
      typeof t.afterSerialize == "function" && (t.afterSerialize.constructor.name === "AsyncFunction" ? await t.afterSerialize(this, e) : t.afterSerialize(this, e));
    for (const { clipUrl: t, filesKey: i } of this.audioClipsCopy) {
      if (e.files[i]) return;
      const r = await (await (await fetch(t)).blob()).arrayBuffer(), a = new Uint8Array(r);
      e.files[i] = a;
    }
    this.behaviourComponentsCopy.length = 0, this.audioClipsCopy.length = 0;
  }
}
class Fv {
  get extensionName() {
    return "Physics";
  }
  onExportObject(e, t, i) {
    const n = S.getComponents(e, ft).filter((l) => l.enabled), o = S.getComponents(e, wi).filter((l) => l.enabled && !l.isTrigger);
    let r = n.length > 0 ? n[0] : null;
    const a = o.length > 0 ? o[0] : null;
    a && !r && (r = new ft(), r.isKinematic = !0), r && t.addEventListener("serialize", (l, c) => {
      if (r) {
        if (l.appendLine(), l.beginBlock('def RealityKitComponent "RigidBody"', "{", !0), r.useGravity || l.appendLine("bool gravityEnabled = 0"), l.appendLine('uniform token info:id = "RealityKit.RigidBody"'), r.isKinematic && l.appendLine('token motionType = "Kinematic"'), l.beginBlock('def RealityKitStruct "massFrame"', "{", !0), l.appendLine(`float m_mass = ${r.mass}`), l.beginBlock('def RealityKitStruct "m_pose"', "{", !0), l.appendLine(`float3 position = (${r.centerOfMass.x}, ${r.centerOfMass.y}, ${r.centerOfMass.z})`), l.closeBlock("}"), l.closeBlock("}"), o.length > 0) {
          const h = o[0];
          l.beginBlock('def RealityKitStruct "material"', "{", !0);
          const d = h.sharedMaterial;
          d && d.dynamicFriction !== void 0 && l.appendLine(`double dynamicFriction = ${h.sharedMaterial?.dynamicFriction}`), d && d.bounciness !== void 0 && l.appendLine(`double restitution = ${h.sharedMaterial?.bounciness}`), d && d.staticFriction !== void 0 && l.appendLine(`double staticFriction = ${h.sharedMaterial?.staticFriction}`), l.closeBlock("}");
        }
        l.closeBlock("}");
      }
    }), a && (t.addEventListener("serialize", (l, c) => {
      l.beginBlock('def RealityKitComponent "Collider"', "{", !0), l.appendLine("uint group = 1"), l.appendLine('uniform token info:id = "RealityKit.Collider"'), l.appendLine("uint mask = 4294967295");
      const d = a.isTrigger ? "Trigger" : "Default";
      if (l.appendLine(`token type = "${d}"`), l.beginBlock('def RealityKitStruct "Shape"', "{", !0), a instanceof wc) {
        const f = a;
        l.appendLine('token shapeType = "Sphere"'), l.appendLine(`float radius = ${f.radius}`);
      } else if (a instanceof Jm) {
        const f = a;
        l.appendLine('token shapeType = "Box"'), l.appendLine(`float3 extent = (${f.size.x}, ${f.size.y}, ${f.size.z})`);
      } else if (a instanceof ho) {
        const f = a;
        l.appendLine('token shapeType = "Capsule"'), l.appendLine(`float radius = ${f.radius}`), l.appendLine(`float height = ${f.height}`);
      } else if (a instanceof br && a.sharedMesh?.geometry) {
        const f = a.sharedMesh.geometry;
        f.boundingBox || f.computeBoundingBox();
        const p = a.sharedMesh.geometry.boundingBox;
        p && (l.appendLine('token shapeType = "Box"'), l.appendLine(`float3 extent = (${p.max.x - p.min.x}, ${p.max.y - p.min.y}, ${p.max.z - p.min.z})`), console.log("[USDZ] Only Box, Sphere, and Capsule colliders are supported in visionOS/iOS. MeshCollider will be exported as Box", a));
      } else
        console.warn("[USDZ] Only Box, Sphere, and Capsule colliders are supported in visionOS/iOS. Ignoring collider:", a);
      l.beginBlock('def RealityKitStruct "pose"', "{", !0), l.closeBlock("}"), l.closeBlock("}"), l.closeBlock("}");
    }), o.length > 1 && console.log("WARNING: Multiple colliders detected. visionOS / iOS can only support objects with a single collider, only exporting the first collider: ", a));
  }
}
const wR = w("debugshadowcomponents");
Ob.prototype.interactable = {
  get() {
    return this.interactive;
  },
  set(s) {
    this.interactable = s;
  }
};
class hn extends T {
  /** Is this object on the root of the UI hierarchy ? */
  isRoot() {
    return this.Root?.gameObject === this.gameObject;
  }
  /** Access the parent canvas component */
  get canvas() {
    const e = this.Root;
    return e?.isCanvas ? e : null;
  }
  /** @deprecated use `canvas` */
  get Canvas() {
    return this.canvas;
  }
  /** Mark the UI dirty which will trigger an THREE-Mesh-UI update */
  markDirty() {
    Jt.markUIDirty(this.context);
  }
  /** the underlying three-mesh-ui */
  get shadowComponent() {
    return this._shadowComponent;
  }
  set shadowComponent(e) {
    this._shadowComponent = e;
  }
  _shadowComponent = null;
  _controlsChildLayout = !0;
  get controlsChildLayout() {
    return this._controlsChildLayout;
  }
  set controlsChildLayout(e) {
    this._controlsChildLayout = e, this.shadowComponent && (this.shadowComponent.autoLayout = e);
  }
  _root = void 0;
  get Root() {
    return this._root === void 0 && (this._root = S.getComponentInParent(this.gameObject, gu)), this._root;
  }
  // private _intermediate?: Object3D;
  _parentComponent = void 0;
  __internalNewInstanceCreated(e) {
    return super.__internalNewInstanceCreated(e), this.shadowComponent = null, this._root = void 0, this._parentComponent = void 0, this;
  }
  onEnable() {
    super.onEnable();
  }
  /** Add a three-mesh-ui object to the UI hierarchy 
   * @param container the three-mesh-ui object to add
   * @param parent the parent component to add the object to
  */
  addShadowComponent(e, t) {
    if (!e) return;
    this.removeShadowComponent();
    const i = this.isRoot() ? this.gameObject : this.gameObject.parent;
    if (this._parentComponent = S.getComponentInParent(i, hn), !this._parentComponent) {
      console.warn(`Component "${this.name}" doesn't have a UI parent anywhere. Do you have an UI element outside a Canvas? UI components must be a child of a Canvas component`, this);
      return;
    }
    e.name = this.name + " (" + (this.constructor.name ?? "UI") + ")", e.autoLayout = this._parentComponent.controlsChildLayout, e[ci] = this, this.setShadowComponentOwner(e);
    let n = !1;
    if (this.Root?.gameObject === this.gameObject)
      this.gameObject.add(e);
    else {
      const o = this._parentComponent.shadowComponent;
      o && (o?.add(e), n = !0);
    }
    this.shadowComponent = e, t && t.shadowComponent && this.shadowComponent && t.shadowComponent.add(this.shadowComponent), mc && e.add(new mi(0.5)), this.onAfterAddedToScene(), n && FS(), wR && console.warn("Added shadow component", this.shadowComponent);
  }
  setShadowComponentOwner(e) {
    if (e && (e[ci] === void 0 || e[ci] === this) && (e[ci] = this, e.children))
      for (const t of e.children)
        this.setShadowComponentOwner(t);
  }
  traverseOwnedShadowComponents(e, t, i) {
    if (e && e[ci] === t) {
      i(e);
      for (const n of e.children)
        this.traverseOwnedShadowComponents(n, t, i);
    }
  }
  /** Remove the underlying UI object from the hierarchy */
  removeShadowComponent() {
    this.shadowComponent && this.shadowComponent.removeFromParent();
  }
  onAfterAddedToScene() {
  }
  setInteractable(e) {
    this.shadowComponent && (this.shadowComponent.interactable = e);
  }
}
class gu extends hn {
  awake() {
    super.awake();
  }
}
var xR = Object.defineProperty, SR = Object.getOwnPropertyDescriptor, Oc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? SR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && xR(e, t, n), n;
};
const Bf = w("debugui"), Ff = w("debuguilayout");
class CR {
  width;
  height;
}
class PR {
  x;
  y;
  width;
  height;
}
const en = new b(), ll = new te(), gh = new $(), Ba = class zv extends hn {
  get parent() {
    return this._parentRectTransform;
  }
  // @serializable(Object3D)
  // root? : Object3D;
  get translation() {
    return this.gameObject.position;
  }
  get rotation() {
    return this.gameObject.quaternion;
  }
  get scale() {
    return this.gameObject.scale;
  }
  _anchoredPosition;
  get anchoredPosition() {
    return this._anchoredPosition || (this._anchoredPosition = new J()), this._anchoredPosition;
  }
  set anchoredPosition(e) {
    this._anchoredPosition = e;
  }
  sizeDelta = new J(100, 100);
  pivot = new J(0.5, 0.5);
  anchorMin = new J(0, 0);
  anchorMax = new J(1, 1);
  // @serializable(Vector2)
  // offsetMin: Vector2 = new Vector2(0, 0);
  // @serializable(Vector2)
  // offsetMax: Vector2 = new Vector2(0, 0);
  /** Optional min width in pixel, set to undefined to disable it */
  minWidth;
  /** Optional min height in pixel, set to undefined to disable it */
  minHeight;
  get width() {
    let e = this.sizeDelta.x;
    if (this.anchorMin.x !== this.anchorMax.x && this._parentRectTransform) {
      const t = this._parentRectTransform.width, i = this.anchorMax.x - this.anchorMin.x;
      e = t * i, e += this.sizeDelta.x;
    }
    return this.minWidth !== void 0 && e < this.minWidth ? this.minWidth : e;
  }
  get height() {
    let e = this.sizeDelta.y;
    if (this.anchorMin.y !== this.anchorMax.y && this._parentRectTransform) {
      const t = this._parentRectTransform.height, i = this.anchorMax.y - this.anchorMin.y;
      e = t * i, e += this.sizeDelta.y;
    }
    return this.minHeight !== void 0 && e < this.minHeight ? this.minHeight : e;
  }
  // private lastMatrixWorld!: Matrix4;
  lastMatrix;
  rectBlock;
  _transformNeedsUpdate = !1;
  _initialPosition;
  _parentRectTransform;
  _lastUpdateFrame = -1;
  awake() {
    super.awake(), this._lastUpdateFrame = -1, this._parentRectTransform = void 0, this.rectBlock = new M(), this.rectBlock.name = this.name, this.lastMatrix = new te(), this._lastAnchoring = null, this._initialPosition = this.gameObject.position.clone(), this._initialPosition.z = 0, this._anchoredPosition || (this._anchoredPosition = new J()), zr(this, "_anchoredPosition", () => {
      this.markDirty();
    }), zr(this, "sizeDelta", () => {
      this.markDirty();
    }), zr(this, "pivot", () => {
      this.markDirty();
    }), zr(this, "anchorMin", () => {
      this.markDirty();
    }), zr(this, "anchorMax", () => {
      this.markDirty();
    });
  }
  onEnable() {
    super.onEnable(), this.rectBlock || (this.rectBlock = new M()), this.lastMatrix || (this.lastMatrix = new te()), this._lastAnchoring || (this._lastAnchoring = new J()), this._initialPosition || (this._initialPosition = new b()), this._anchoredPosition || (this._anchoredPosition = new J()), this.addShadowComponent(this.rectBlock), this._transformNeedsUpdate = !0, this.canvas?.registerTransform(this);
  }
  onDisable() {
    super.onDisable(), this.removeShadowComponent(), this.canvas?.unregisterTransform(this);
  }
  onParentRectTransformChanged(e) {
    this._transformNeedsUpdate || this.onApplyTransform(Ff ? `${e.name} changed` : void 0);
  }
  get isDirty() {
    return this._transformNeedsUpdate || (this._transformNeedsUpdate = !this.lastMatrix.equals(this.gameObject.matrix)), this._transformNeedsUpdate;
  }
  // private _copyMatrixAfterRender: boolean = false;
  markDirty() {
    this._transformNeedsUpdate || (Ff && console.warn("RectTransform markDirty()", this.name), this._transformNeedsUpdate = !0, this._lastUpdateFrame = -1);
  }
  /** Will update the transforms if it changed or is dirty */
  updateTransform() {
    (this._transformNeedsUpdate || !this.lastMatrix.equals(this.gameObject.matrix)) && this.canUpdate() && this.onApplyTransform(this._transformNeedsUpdate ? "Marked dirty" : "Matrix changed");
  }
  canUpdate() {
    return this._transformNeedsUpdate && this.activeAndEnabled && this._lastUpdateFrame !== this.context.time.frame;
  }
  onApplyTransform(e) {
    if (this.context.time.frameCount === this._lastUpdateFrame) return;
    this._lastUpdateFrame = this.context.time.frameCount;
    const t = this.shadowComponent;
    if (!t) return;
    this.gameObject.parent ? this._parentRectTransform = S.getComponentInParent(this.gameObject.parent, zv) : this._parentRectTransform = void 0, this._transformNeedsUpdate = !1, Ff && console.warn("RectTransform → ApplyTransform", this.name + " because " + e), this.isRoot() ? this.Root.screenspace || (t.rotation.y = Math.PI) : (t.matrix.identity(), t.matrixAutoUpdate = !1, en.set(0, 0, 0), this.applyPivot(en), t.matrix.setPosition(en.x, en.y, 0), (this.gameObject.quaternion.x || this.gameObject.quaternion.y || this.gameObject.quaternion.z) && (gh.copy(this.gameObject.quaternion), gh.x *= -1, gh.z *= -1, ll.makeRotationFromQuaternion(gh), t.matrix.premultiply(ll)), en.set(0, 0, 0), this.applyAnchoring(en), this.canvas?.screenspace ? en.z += 0.1 : en.z += 0.01, ll.identity(), ll.setPosition(en.x, en.y, en.z), t.matrix.premultiply(ll), t.matrix.scale(this.gameObject.scale)), this.lastMatrix.copy(this.gameObject.matrix);
    const i = !0;
    for (const n of Fm(this.gameObject, hn, i, 1)) {
      if (n === this || !n.activeAndEnabled) continue;
      const o = n;
      o.onParentRectTransformChanged && o.onParentRectTransformChanged(this);
    }
  }
  // onAfterRender() {
  //     if (this._copyMatrixAfterRender) {
  //         // can we only have this event when the transform changed in this frame? Otherwise all RectTransforms will be iterated. Not sure what is better
  //         this.lastMatrixWorld.copy(this.gameObject.matrixWorld);
  //     }
  // }
  _lastAnchoring;
  /** applies the position offset to the passed in vector */
  applyAnchoring(e) {
    this._lastAnchoring || (this._lastAnchoring = new J());
    const t = this._lastAnchoring.sub(this._anchoredPosition);
    this.gameObject.position.x += t.x, this.gameObject.position.y += t.y, this._lastAnchoring.copy(this._anchoredPosition), e.x += this._initialPosition.x - this.gameObject.position.x, e.y += this._initialPosition.y - this.gameObject.position.y, e.z += this._initialPosition.z - this.gameObject.position.z;
    const i = this._parentRectTransform;
    if (i) {
      let n = 0;
      const o = 1 - this.anchorMax.y - this.anchorMin.y;
      n -= i.height * 0.5 * o, e.y += n;
      let r = 0;
      const a = 1 - this.anchorMax.x - this.anchorMin.x;
      r -= i.width * 0.5 * a, e.x += r;
    }
  }
  /** applies the pivot offset to the passed in vector */
  applyPivot(e) {
    if (this.pivot && !this.isRoot()) {
      const t = this.pivot.x - 0.5;
      e.x -= t * this.sizeDelta.x * this.gameObject.scale.x;
      const i = this.pivot.y - 0.5;
      e.y -= i * this.sizeDelta.y * this.gameObject.scale.y;
    }
  }
  getBasicOptions() {
    const e = {
      width: this.sizeDelta.x,
      height: this.sizeDelta.y,
      // * this.context.mainCameraComponent!.aspect,
      offset: 0,
      backgroundOpacity: 0,
      borderWidth: 0,
      // if we dont specify width here a border will automatically propagated to child blocks
      borderRadius: 0,
      borderOpacity: 0,
      letterSpacing: -0.03
      // justifyContent: 'center',
      // alignItems: 'center',
      // alignContent: 'center',
      // backgroundColor: new Color(1, 1, 1),
    };
    return this.ensureValidSize(e), e;
  }
  // e.g. when a transform has the size 0,0 we still want to render the text
  ensureValidSize(e, t = 1e-4) {
    return e.width <= 0 && (e.width = t), e.height <= 0 && (e.height = 1e-4), e;
  }
  _createdBlocks = [];
  _createdTextBlocks = [];
  createNewBlock(e) {
    e = {
      ...this.getBasicOptions(),
      ...e
    }, Bf && console.log(this.name, e);
    const t = new Ob(e);
    return this._createdBlocks.push(t), t;
  }
  createNewText(e) {
    Bf && console.log(e), e = {
      ...this.getBasicOptions(),
      ...e
    }, Bf && console.log(this.name, e);
    const t = new Pb(e);
    return this._createdTextBlocks.push(t), t;
  }
};
Oc([
  u(J)
], Ba.prototype, "anchoredPosition", 1);
Oc([
  u(J)
], Ba.prototype, "sizeDelta", 2);
Oc([
  u(J)
], Ba.prototype, "pivot", 2);
Oc([
  u(J)
], Ba.prototype, "anchorMin", 2);
Oc([
  u(J)
], Ba.prototype, "anchorMax", 2);
let zn = Ba;
var OR = Object.defineProperty, Uv = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && OR(e, t, n), n;
};
class kc extends T {
  effectColor;
  effectDistance;
}
Uv([
  u(oe)
], kc.prototype, "effectColor");
Uv([
  u(J)
], kc.prototype, "effectDistance");
var kR = Object.defineProperty, MR = Object.getOwnPropertyDescriptor, Nv = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? MR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && kR(e, t, n), n;
};
const yh = {
  backgroundColor: new se(1, 1, 1),
  backgroundOpacity: 1,
  borderColor: new se(1, 1, 1),
  borderOpacity: 1
}, mg = class kl extends hn {
  get isGraphic() {
    return !0;
  }
  get color() {
    return this._color || (this._color = new oe(1, 1, 1, 1)), this._color;
  }
  set color(e) {
    (!this._color || this._color.r !== e.r || this._color.g !== e.g || this._color.b !== e.b || this._color.alpha !== e.alpha) && (this._color || (this._color = new oe(1, 1, 1, 1)), this._color.copy(e), this.onColorChanged());
  }
  _alphaFactor = 1;
  setAlphaFactor(e) {
    this._alphaFactor = e, this.onColorChanged();
  }
  get alphaFactor() {
    return this._alphaFactor;
  }
  sRGBColor = new se(1, 0, 1);
  onColorChanged() {
    this.uiObject && (this.sRGBColor.copy(this._color), this.sRGBColor.convertLinearToSRGB(), yh.backgroundColor = this.sRGBColor, yh.backgroundOpacity = this._color.alpha * this._alphaFactor, this.applyEffects(yh, this._alphaFactor), this.uiObject.set(yh), this.markDirty());
  }
  // used via animations
  get m_Color() {
    return this._color;
  }
  raycastTarget = !0;
  uiObject = null;
  _color = null;
  _rect = null;
  _stateManager = null;
  get rectTransform() {
    if (this._rect || (this._rect = S.getComponent(this.gameObject, zn)), !this._rect) throw new Error("Not Supported: Make sure to add a RectTransform component before adding a UI Graphic component.");
    return this._rect;
  }
  onParentRectTransformChanged() {
    this.uiObject?.set({ width: this.rectTransform.width, height: this.rectTransform.height }), this.markDirty();
  }
  __internalNewInstanceCreated(e) {
    return super.__internalNewInstanceCreated(e), this._rect = null, this.uiObject = null, this._stateManager = null, this._color && (this._color = this._color.clone()), this;
  }
  setState(e) {
    this.makePanel(), this.uiObject && (this.uiObject.setState(e), this?.markDirty());
  }
  setupState(e) {
    this.makePanel(), this.uiObject && (this._stateManager || (this._stateManager = new zS(this.uiObject)), this.uiObject.setupState(e.state, e.attributes));
  }
  setOptions(e) {
    this.makePanel(), this.uiObject && this.uiObject.set(e);
  }
  awake() {
    super.awake(), this.makePanel(), zr(this, "_color", () => ok(this, this.onColorChanged));
  }
  onEnable() {
    super.onEnable(), this.uiObject && (this.rectTransform.shadowComponent?.add(this.uiObject), this.addShadowComponent(this.uiObject, this.rectTransform));
  }
  onDisable() {
    super.onDisable(), this.uiObject && this.removeShadowComponent();
  }
  _currentlyCreatingPanel = !1;
  makePanel() {
    if (this.uiObject || this._currentlyCreatingPanel) return;
    this._currentlyCreatingPanel = !0;
    const t = {
      backgroundColor: this.color,
      backgroundOpacity: this.color.alpha,
      offset: 0.015
      // without a tiny offset we get z fighting
    };
    this.onBeforeCreate(t), this.applyEffects(t), this.onCreate(t), this.controlsChildLayout = !1, this._currentlyCreatingPanel = !1, this.onAfterCreated(), this.onColorChanged();
  }
  onBeforeCreate(e) {
  }
  onCreate(e) {
    this.uiObject = this.rectTransform.createNewBlock(e), this.uiObject.name = this.name;
  }
  onAfterCreated() {
  }
  applyEffects(e, t = 1) {
    const i = this.gameObject?.getComponent(kc);
    i && (i.effectDistance && (e.borderWidth = Math.max(Math.abs(i.effectDistance.x), Math.abs(i.effectDistance.y))), i.effectColor && (e.borderColor = i.effectColor, e.borderOpacity = i.effectColor.alpha * t));
  }
  /** used internally to ensure textures assigned to UI use linear encoding */
  static textureCache = /* @__PURE__ */ new Map();
  async setTexture(e) {
    if (this.setOptions({ backgroundOpacity: 0 }), e) {
      if (kl.textureCache.has(e))
        e = kl.textureCache.get(e);
      else if (!e.isRenderTargetTexture) {
        const t = e.clone();
        t.colorSpace = Ss, kl.textureCache.set(e, t), e = t;
      }
      this.setOptions({ backgroundImage: e, borderRadius: 0, backgroundOpacity: this.color.alpha, backgroundSize: "stretch" }), We.assignTextureLOD(e, 0).then((t) => {
        t instanceof Te && (e && kl.textureCache.set(e, t), this.setOptions({ backgroundImage: t }), this.markDirty());
      });
    } else
      this.setOptions({ backgroundImage: void 0, borderRadius: 0, backgroundOpacity: this.color.alpha });
    this.markDirty();
  }
  onAfterAddedToScene() {
    super.onAfterAddedToScene(), this.shadowComponent && (this.shadowComponent.offset = this.shadowComponent.position.z);
  }
};
Nv([
  u(oe)
], mg.prototype, "color", 1);
Nv([
  u()
], mg.prototype, "raycastTarget", 2);
let yu = mg;
class _u extends yu {
  _flippedObject = !1;
  onAfterCreated() {
    this.uiObject && !this._flippedObject && (this._flippedObject = !0, this.uiObject.scale.y *= -1);
  }
}
var RR = Object.defineProperty, TR = Object.getOwnPropertyDescriptor, As = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? TR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && RR(e, t, n), n;
};
const Do = w("debugtext");
var it = /* @__PURE__ */ ((s) => (s[s.UpperLeft = 0] = "UpperLeft", s[s.UpperCenter = 1] = "UpperCenter", s[s.UpperRight = 2] = "UpperRight", s[s.MiddleLeft = 3] = "MiddleLeft", s[s.MiddleCenter = 4] = "MiddleCenter", s[s.MiddleRight = 5] = "MiddleRight", s[s.LowerLeft = 6] = "LowerLeft", s[s.LowerCenter = 7] = "LowerCenter", s[s.LowerRight = 8] = "LowerRight", s))(it || {}), $v = /* @__PURE__ */ ((s) => (s[s.Normal = 0] = "Normal", s[s.Bold = 1] = "Bold", s[s.Italic = 2] = "Italic", s[s.BoldAndItalic = 3] = "BoldAndItalic", s))($v || {});
class Gt extends yu {
  alignment = 0;
  verticalOverflow = 0;
  horizontalOverflow = 0;
  lineSpacing = 1;
  supportRichText = !1;
  font;
  fontStyle = 0;
  // private _alphaFactor : number = 1;
  setAlphaFactor(e) {
    super.setAlphaFactor(e), this.uiObject?.set({ fontOpacity: this.color.alpha * this.alphaFactor }), this.markDirty();
  }
  get text() {
    return this._text;
  }
  set text(e) {
    e !== this._text && (this._text = e, this.feedText(this.text, this.supportRichText), this.markDirty());
  }
  set_text(e) {
    this.text = e;
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(e) {
    this._fontSize = e, this.uiObject?.set({ fontSize: e });
  }
  sRGBTextColor = new se(1, 0, 1);
  onColorChanged() {
    this.sRGBTextColor.copy(this.color), this.sRGBTextColor.convertLinearToSRGB(), this.uiObject?.set({ color: this.sRGBTextColor, fontOpacity: this.color.alpha });
  }
  onParentRectTransformChanged() {
    super.onParentRectTransformChanged(), this.uiObject && this.updateOverflow();
  }
  // onBeforeRender(): void {
  //     // TODO TMUI @swingingtom this is so we don't have text clipping
  //     if (this.uiObject && (this.Canvas?.screenspace || this.context.isInVR)) {
  //         this.updateOverflow();
  //     }
  // }
  onBeforeCanvasRender(e) {
    this.updateOverflow();
  }
  updateOverflow() {
    const e = this.uiObject?._overflow;
    e && (e._needsUpdate = !0);
  }
  onCreate(e) {
    Do && console.log(this), this.horizontalOverflow == 1 && (e.whiteSpace = "pre"), this.verticalOverflow == 0 && (this.context.renderer.localClippingEnabled = !0, e.overflow = "hidden"), this.horizontalOverflow == 1 && this.verticalOverflow == 0, e.lineHeight = this.lineSpacing, delete e.backgroundOpacity, delete e.backgroundColor, Do && (e.backgroundColor = 16750848, e.backgroundOpacity = 0.5);
    const t = this.rectTransform;
    e = { ...e, ...this.getTextOpts() }, this.getAlignment(e), Do && (e.backgroundColor = Math.random() * 16777215, e.backgroundOpacity = 0.1), this.uiObject = t.createNewText(e), this.feedText(this.text, this.supportRichText);
  }
  onAfterAddedToScene() {
    super.onAfterAddedToScene(), this.handleTextRenderOnTop();
  }
  _text = "";
  _fontSize = 12;
  _textMeshUi = null;
  getTextOpts() {
    const e = this.fontSize, t = {
      color: this.color,
      fontOpacity: this.color.alpha,
      fontSize: e,
      fontKerning: "normal"
    };
    return this.setFont(t, this.fontStyle), t;
  }
  onEnable() {
    super.onEnable(), this._didHandleTextRenderOnTop = !1, this.uiObject && this.uiObject.addAfterUpdate(() => {
      this.setShadowComponentOwner(this.uiObject), this.markDirty();
    }), setTimeout(() => this.markDirty(), 10), this.canvas?.registerEventReceiver(this);
  }
  onDisable() {
    super.onDisable(), this.canvas?.unregisterEventReceiver(this);
  }
  getAlignment(e) {
    switch (e.flexDirection = "column", this.alignment) {
      case 0:
      case 3:
      case 6:
        e.textAlign = "left";
        break;
      case 1:
      case 4:
      case 7:
        e.textAlign = "center";
        break;
      case 2:
      case 5:
      case 8:
        e.textAlign = "right";
        break;
    }
    switch (this.alignment) {
      default:
      case 0:
      case 1:
      case 2:
        e.alignItems = "start";
        break;
      case 3:
      case 4:
      case 5:
        e.alignItems = "center";
        break;
      case 6:
      case 7:
      case 8:
        e.alignItems = "end";
        break;
    }
    return e;
  }
  feedText(e, t) {
    if (Do && console.log("feedText", this.uiObject, e, t), !!this.uiObject)
      if (this._textMeshUi || (this._textMeshUi = []), this.uiObject.children.length = 0, !t || e.length === 0)
        this.uiObject.textContent = e;
      else {
        let i = this.getNextTag(e);
        if (i) {
          if (i.startIndex > 0) {
            for (let r = this.uiObject.children.length - 1; r >= 0; r--) {
              const a = this.uiObject.children[r];
              a.isUI && (this.uiObject.remove(a), a.clear());
            }
            const o = new Gu({ textContent: e.substring(0, i.startIndex), color: "inherit" });
            this.uiObject.add(o);
          }
        } else {
          this.uiObject.textContent = "", this.setOptions({ textContent: e });
          return;
        }
        const n = [];
        for (; i; ) {
          const o = this.getNextTag(e, i.endIndex), r = {
            fontFamily: this.uiObject?.get("fontFamily"),
            color: "inherit",
            textContent: ""
          };
          if (o) {
            r.textContent = this.getText(e, i, o), this.handleTag(i, r, n);
            const a = new Gu(r);
            this.uiObject?.add(a);
          } else {
            r.textContent = e.substring(i.endIndex), this.handleTag(i, r, n);
            const a = new Gu(r);
            this.uiObject?.add(a);
          }
          i = o;
        }
      }
  }
  _didHandleTextRenderOnTop = !1;
  handleTextRenderOnTop() {
    this._didHandleTextRenderOnTop || (this._didHandleTextRenderOnTop = !0, this.startCoroutine(this.renderOnTopCoroutine()));
  }
  // waits for all the text objects to be ready to set the render on top setting
  // @THH :  this isn't true anymore. We can set mesh and material properties before their counterparts are created.
  //         Values would automatically be passed when created. Not sure for depthWrite but it can be added;
  *renderOnTopCoroutine() {
    if (!this.canvas) return;
    const e = [], t = this.canvas, i = {
      renderOnTop: t.renderOnTop,
      depthWrite: t.depthWrite,
      doubleSided: t.doubleSided
    };
    for (; ; ) {
      let n = !1;
      if (this._textMeshUi)
        for (let o = 0; o < this._textMeshUi.length; o++) {
          if (e[o] === !0) continue;
          n = !0;
          const r = this._textMeshUi[o];
          r.textContent && (ud(r, i), e[o] = !0);
        }
      if (!n) break;
      yield;
    }
  }
  handleTag(e, t, i) {
    if (!e.isEndTag) {
      if (e.type.includes("color")) {
        const n = new zf(e, { color: t.color });
        if (i.push(n), e.type.length > 6) {
          const o = parseInt("0x" + e.type.substring(7));
          t.color = o;
        } else
          t.color = new se(1, 1, 1);
      } else if (e.type == "b") {
        this.setFont(
          t,
          1
          /* Bold */
        );
        const n = new zf(e, {
          fontWeight: 700
        });
        i.push(n);
      } else if (e.type == "i") {
        this.setFont(
          t,
          2
          /* Italic */
        );
        const n = new zf(e, {
          fontStyle: "italic"
        });
        i.push(n);
      }
    }
  }
  getText(e, t, i) {
    return e.substring(t.endIndex, i.startIndex);
  }
  getNextTag(e, t = 0) {
    const i = e.indexOf("<", t), n = e.indexOf(">", i);
    if (i >= 0 && n >= 0) {
      const o = e.substring(i + 1, n);
      return { type: o, startIndex: i, endIndex: n + 1, isEndTag: o.startsWith("/") };
    }
    return null;
  }
  /**
   * Update provided opts to have a proper fontDefinition : family+weight+style
   * Ensure Family and Variant are registered in FontLibrary
   *
   * @param opts
   * @param fontStyle
   * @private
   */
  setFont(e, t) {
    if (!this.font) return;
    const i = this.font, n = this.getFamilyNameWithCorrectSuffix(i, t);
    Do && console.log("Selected font family:" + n);
    let o = ey.getFontFamily(n);
    switch (o || (o = ey.addFontFamily(n)), e.fontFamily = o, t) {
      default:
      case 0:
        e.fontWeight = 400, e.fontStyle = "normal";
        break;
      case 1:
        e.fontWeight = 700, e.fontStyle = "normal";
        break;
      case 2:
        e.fontWeight = 400, e.fontStyle = "italic";
        break;
      case 3:
        e.fontStyle = "italic", e.fontWeight = 400;
    }
    let r = o.getVariant(e.fontWeight, e.fontStyle);
    if (!r) {
      let a = n;
      a?.endsWith("-msdf.json") || (a += "-msdf.json");
      let l = n;
      l?.endsWith(".png") || (l += ".png"), r = o.addVariant(e.fontWeight, e.fontStyle, a, l), r?.addEventListener("ready", () => {
        this.markDirty();
      });
    }
  }
  getFamilyNameWithCorrectSuffix(e, t) {
    const i = e.lastIndexOf("-");
    if (i < 0) return e;
    const n = e.substring(i + 1)?.toLowerCase();
    if (ER.includes(n))
      return Do && console.warn("Unsupported font style: " + n), e;
    const o = e.lastIndexOf("/");
    let r = e;
    o >= 0 && (r = r.substring(o + 1));
    const a = r[0] === r[0].toUpperCase(), l = e.substring(0, i);
    switch (Do && console.log("Select font: ", e, $v[t], r, a, l), t) {
      case 0:
        return a ? l + "-Regular" : l + "-regular";
      case 1:
        return a ? l + "-Bold" : l + "-bold";
      case 2:
        return a ? l + "-Italic" : l + "-italic";
      case 3:
        return a ? l + "-BoldItalic" : l + "-bolditalic";
      default:
        return e;
    }
  }
}
As([
  u()
], Gt.prototype, "alignment", 2);
As([
  u()
], Gt.prototype, "verticalOverflow", 2);
As([
  u()
], Gt.prototype, "horizontalOverflow", 2);
As([
  u()
], Gt.prototype, "lineSpacing", 2);
As([
  u()
], Gt.prototype, "supportRichText", 2);
As([
  u(URL)
], Gt.prototype, "font", 2);
As([
  u()
], Gt.prototype, "fontStyle", 2);
As([
  u()
], Gt.prototype, "text", 1);
As([
  u()
], Gt.prototype, "fontSize", 1);
class zf {
  tag;
  previousValues;
  constructor(e, t) {
    this.tag = e, this.previousValues = t;
  }
}
const ER = [
  "medium",
  "mediumitalic",
  "black",
  "blackitalic",
  "thin",
  "thinitalic",
  "extrabold",
  "light",
  "lightitalic",
  "semibold"
];
class Ml {
  static global_id = 0;
  static getId() {
    return this.global_id++;
  }
  id;
  content = "";
  font = [];
  pointSize = 144;
  width;
  height;
  depth;
  wrapMode;
  horizontalAlignment;
  verticalAlignment;
  material;
  setDepth(e) {
    return this.depth = e, this;
  }
  setPointSize(e) {
    return this.pointSize = e, this;
  }
  setHorizontalAlignment(e) {
    return this.horizontalAlignment = e, this;
  }
  setVerticalAlignment(e) {
    return this.verticalAlignment = e, this;
  }
  constructor(e) {
    this.id = e;
  }
  writeTo(e, t) {
    t.beginBlock(`def Preliminary_Text "${this.id}"`, "(", !1), t.appendLine('prepend apiSchemas = ["MaterialBindingAPI"]'), t.closeBlock(")"), t.beginBlock(), this.content && t.appendLine(`string content = "${this.content}"`), (!this.font || this.font.length <= 0) && (this.font ||= [], this.font?.push("sans-serif"));
    const i = this.font.map((n) => `"${n}"`).join(", ");
    t.appendLine(`string[] font = [ ${i} ]`), t.appendLine(`double pointSize = ${this.pointSize}`), typeof this.width == "number" && t.appendLine(`double width = ${this.width}`), typeof this.height == "number" && t.appendLine(`double height = ${this.height}`), typeof this.depth == "number" && t.appendLine(`double depth = ${this.depth}`), this.wrapMode && t.appendLine(`token wrapMode = "${this.wrapMode}"`), this.horizontalAlignment && t.appendLine(`token horizontalAlignment = "${this.horizontalAlignment}"`), this.verticalAlignment && t.appendLine(`token verticalAlignment = "${this.verticalAlignment}"`), this.material !== void 0 && t.appendLine(`rel material:binding = </StageRoot/Materials/${cu(this.material)}>`), t.closeBlock();
  }
}
class Wv {
  static singleLine(e, t, i) {
    const n = new Ml("text_" + Ml.getId());
    return n.content = e, t && (n.pointSize = t), i && (n.depth = i), n;
  }
  static multiLine(e, t, i, n, o, r) {
    const a = new Ml("text_" + Ml.getId());
    return a.content = e, a.width = t, a.height = i, a.horizontalAlignment = n, a.verticalAlignment = o, r !== void 0 && (a.wrapMode = r), a;
  }
}
const AR = new te().makeRotationY(Math.PI), IR = new te().makeScale(-1, 1, -1);
class gg {
  get extensionName() {
    return "text";
  }
  exportText(e, t, i) {
    const n = S.getComponent(e, Gt);
    if (!n) return;
    const o = S.getComponent(e, zn);
    let r = 100, a = 100;
    o && (r = o.width, a = o.height);
    const l = AR.clone();
    o && l.premultiply(IR), t.setMatrix(l);
    const c = n.color.clone();
    t.material = new ct({ color: c, emissive: c }), t.addEventListener("serialize", (h, d) => {
      let f = n.text;
      f = f.replace(/\r/g, ""), f = f.replace(/\n/g, "\\n");
      const p = Wv.multiLine(
        f,
        r,
        a,
        "center",
        "bottom",
        "flowing"
        /* flowing */
      );
      this.setTextAlignment(p, n.alignment), this.setOverflow(p, n), t.material && (p.material = t.material), p.pointSize = this.convertToTextSize(n.fontSize), p.depth = 1e-3, p.writeTo(void 0, h);
    });
  }
  convertToTextSize(e) {
    return 1 / 0.0502 * 144 * e;
  }
  setOverflow(e, t) {
    t.horizontalOverflow ? e.wrapMode = "singleLine" : e.wrapMode = "flowing";
  }
  setTextAlignment(e, t) {
    switch (t) {
      case it.LowerLeft:
      case it.MiddleLeft:
      case it.UpperLeft:
        e.horizontalAlignment = "left";
        break;
      case it.LowerCenter:
      case it.MiddleCenter:
      case it.UpperCenter:
        e.horizontalAlignment = "center";
        break;
      case it.LowerRight:
      case it.MiddleRight:
      case it.UpperRight:
        e.horizontalAlignment = "right";
        break;
    }
    switch (t) {
      case it.LowerLeft:
      case it.LowerCenter:
      case it.LowerRight:
        e.verticalAlignment = "bottom";
        break;
      case it.MiddleLeft:
      case it.MiddleCenter:
      case it.MiddleRight:
        e.verticalAlignment = "middle";
        break;
      case it.UpperLeft:
      case it.UpperCenter:
      case it.UpperRight:
        e.verticalAlignment = "top";
        break;
    }
  }
}
var LR = Object.defineProperty, Ye = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && LR(e, t, n), n;
};
const D_ = w("debuguilayout");
class Fa {
  left = 0;
  right = 0;
  top = 0;
  bottom = 0;
  get vertical() {
    return this.top + this.bottom;
  }
  get horizontal() {
    return this.left + this.right;
  }
}
Ye([
  u()
], Fa.prototype, "left");
Ye([
  u()
], Fa.prototype, "right");
Ye([
  u()
], Fa.prototype, "top");
Ye([
  u()
], Fa.prototype, "bottom");
class Si extends T {
  _rectTransform = null;
  get rectTransform() {
    return this._rectTransform;
  }
  onParentRectTransformChanged(e) {
    this._needsUpdate = !0;
  }
  _needsUpdate = !1;
  get isDirty() {
    return this._needsUpdate;
  }
  get isLayoutGroup() {
    return !0;
  }
  updateLayout() {
    this._rectTransform && (D_ && console.warn("Layout Update", this.context.time.frame, this.name), this._needsUpdate = !1, this.onCalculateLayout(this._rectTransform));
  }
  childAlignment = 0;
  reverseArrangement = !1;
  spacing = 0;
  padding;
  minWidth = 0;
  minHeight = 0;
  flexibleHeight = 0;
  flexibleWidth = 0;
  preferredHeight = 0;
  preferredWidth = 0;
  start() {
    this._needsUpdate = !0;
  }
  onEnable() {
    D_ && console.log(this.name, this), this._rectTransform = this.gameObject.getComponent(zn);
    const e = this.gameObject.getComponentInParent(hc);
    e && e.registerLayoutGroup(this), this._needsUpdate = !0;
  }
  onDisable() {
    const e = this.gameObject.getComponentInParent(hc);
    e && e.unregisterLayoutGroup(this);
  }
  // for animation:
  set m_Spacing(e) {
    e !== this.spacing && (this._needsUpdate = !0, this.spacing = e);
  }
  get m_Spacing() {
    return this.spacing;
  }
}
Ye([
  u()
], Si.prototype, "childAlignment");
Ye([
  u()
], Si.prototype, "reverseArrangement");
Ye([
  u()
], Si.prototype, "spacing");
Ye([
  u(Fa)
], Si.prototype, "padding");
Ye([
  u()
], Si.prototype, "minWidth");
Ye([
  u()
], Si.prototype, "minHeight");
Ye([
  u()
], Si.prototype, "flexibleHeight");
Ye([
  u()
], Si.prototype, "flexibleWidth");
Ye([
  u()
], Si.prototype, "preferredHeight");
Ye([
  u()
], Si.prototype, "preferredWidth");
class vo extends Si {
  childControlHeight = !0;
  childControlWidth = !0;
  childForceExpandHeight = !1;
  childForceExpandWidth = !1;
  childScaleHeight = !1;
  childScaleWidth = !1;
  onCalculateLayout(e) {
    const t = this.primaryAxis, i = e.width;
    let n = i;
    const o = e.height;
    let r = o;
    n -= this.padding.horizontal, r -= this.padding.vertical, t === "x" ? this.padding.horizontal : this.padding.vertical;
    const a = t === "x", l = a ? "y" : "x", c = a ? this.childControlWidth : this.childControlHeight, h = a ? this.childControlHeight : this.childControlWidth, d = a ? this.childForceExpandWidth : this.childForceExpandHeight, f = a ? this.childForceExpandHeight : this.childForceExpandWidth, p = a ? r : n, g = a ? i : o, _ = 0.5 * (a ? this.childAlignment % 3 : Math.floor(this.childAlignment / 3));
    let m = 0;
    a ? m += this.padding.left : m += this.padding.top;
    let v = 0, y = 0;
    for (let E = 0; E < this.gameObject.children.length; E++) {
      const z = this.gameObject.children[E], D = S.getComponent(z, zn);
      D?.activeAndEnabled && (y += 1, a ? v += D.width : v += D.height);
    }
    let x = 0;
    const I = this.spacing * (y - 1);
    if (d || c) {
      let E = 0;
      a ? E = n -= I : E = r -= I, y > 0 && (x = E / y);
    }
    let O = 0;
    O += this.padding.left, O -= this.padding.right, _ !== 0 && (m = g - v, m *= _, m -= I * _, a ? (m -= this.padding.right * _, m += this.padding.left * (1 - _), m < this.padding.left && (m = this.padding.left)) : (m -= this.padding.bottom * _, m += this.padding.top * (1 - _), m < this.padding.top && (m = this.padding.top)));
    let k = 1;
    for (let E = 0; E < this.gameObject.children.length; E++) {
      const z = this.gameObject.children[E], D = S.getComponent(z, zn);
      if (D?.activeAndEnabled) {
        D.pivot?.set(0.5, 0.5), D.anchorMin.set(0, 1), D.anchorMax.set(0, 1);
        const V = i * 0.5 + O * 0.5;
        D.anchoredPosition.x !== V && (D.anchoredPosition.x = V);
        const q = o * -0.5;
        D.anchoredPosition.y !== q && (D.anchoredPosition.y = q), f && h && D.sizeDelta[l] !== p && (D.sizeDelta[l] = p), d && c && D.sizeDelta[t] !== x && (D.sizeDelta[t] = x);
        const A = a ? D.width : D.height, U = A * 0.5;
        if (m += U, d) {
          const ne = x * k - x * 0.5;
          ne > m && (m = ne - x * 0.5 + A + this.padding.left, m -= U);
        }
        let W = m;
        t === "y" && (W = -W), D.anchoredPosition[t] !== W && (D.anchoredPosition[t] = W), m += U, m += this.spacing, k += 1;
      }
    }
  }
}
Ye([
  u()
], vo.prototype, "childControlHeight");
Ye([
  u()
], vo.prototype, "childControlWidth");
Ye([
  u()
], vo.prototype, "childForceExpandHeight");
Ye([
  u()
], vo.prototype, "childForceExpandWidth");
Ye([
  u()
], vo.prototype, "childScaleHeight");
Ye([
  u()
], vo.prototype, "childScaleWidth");
class Vv extends vo {
  get primaryAxis() {
    return "y";
  }
}
class Hv extends vo {
  get primaryAxis() {
    return "x";
  }
}
class Gv extends Si {
  onCalculateLayout() {
  }
}
var DR = Object.defineProperty, jR = Object.getOwnPropertyDescriptor, Wn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? jR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && DR(e, t, n), n;
}, qv = /* @__PURE__ */ ((s) => (s[s.ScreenSpaceOverlay = 0] = "ScreenSpaceOverlay", s[s.ScreenSpaceCamera = 1] = "ScreenSpaceCamera", s[s.WorldSpace = 2] = "WorldSpace", s[s.Undefined = -1] = "Undefined", s))(qv || {});
const Uf = w("debuguilayout"), qi = class Xv extends gu {
  get isCanvas() {
    return !0;
  }
  get screenspace() {
    return this.renderMode !== 2;
  }
  set renderOnTop(e) {
    e !== this._renderOnTop && (this._renderOnTop = e, this.onRenderSettingsChanged());
  }
  get renderOnTop() {
    return this._renderOnTop !== void 0 ? this._renderOnTop : !!(this.screenspace && this._renderMode === 0);
  }
  _renderOnTop;
  set depthWrite(e) {
    this._depthWrite !== e && (this._depthWrite = e, this.onRenderSettingsChanged());
  }
  get depthWrite() {
    return this._depthWrite;
  }
  _depthWrite = !1;
  set doubleSided(e) {
    this._doubleSided !== e && (this._doubleSided = e, this.onRenderSettingsChanged());
  }
  get doubleSided() {
    return this._doubleSided;
  }
  _doubleSided = !0;
  set castShadows(e) {
    this._castShadows !== e && (this._castShadows = e, this.onRenderSettingsChanged());
  }
  get castShadows() {
    return this._castShadows;
  }
  _castShadows = !1;
  set receiveShadows(e) {
    this._receiveShadows !== e && (this._receiveShadows = e, this.onRenderSettingsChanged());
  }
  get receiveShadows() {
    return this._receiveShadows;
  }
  _receiveShadows = !1;
  get renderMode() {
    return this._renderMode;
  }
  set renderMode(e) {
    this._renderMode !== e && (this._renderMode = e, this.onRenderSettingsChanged());
  }
  _renderMode = -1;
  _rootCanvas;
  set rootCanvas(e) {
    this._rootCanvas instanceof Xv || (this._rootCanvas = e);
  }
  get rootCanvas() {
    return this._rootCanvas;
  }
  _scaleFactor = 1;
  get scaleFactor() {
    return this._scaleFactor;
  }
  set scaleFactor(e) {
    this._scaleFactor = e;
  }
  worldCamera;
  planeDistance = -1;
  awake() {
    this.shadowComponent = this.gameObject, this.previousParent = this.gameObject.parent, Uf && console.log("Canvas.Awake()", this.previousParent?.name + "/" + this.gameObject.name), super.awake();
  }
  start() {
    this.applyRenderSettings();
  }
  onEnable() {
    super.onEnable(), this._updateRenderSettingsRoutine = void 0, this._lastMatrixWorld = new te(), this.applyRenderSettings(), document.addEventListener("resize", this._boundRenderSettingsChanged), this.context.pre_render_callbacks.push(this.onBeforeRenderRoutine), this.context.post_render_callbacks.push(this.onAfterRenderRoutine);
  }
  onDisable() {
    super.onDisable(), document.removeEventListener("resize", this._boundRenderSettingsChanged);
    const e = this.context.pre_render_callbacks.indexOf(this.onBeforeRenderRoutine);
    e !== -1 && this.context.pre_render_callbacks.splice(e, 1);
    const t = this.context.post_render_callbacks.indexOf(this.onAfterRenderRoutine);
    t !== -1 && this.context.post_render_callbacks.splice(t, 1);
  }
  _boundRenderSettingsChanged = this.onRenderSettingsChanged.bind(this);
  previousParent = null;
  _lastMatrixWorld = null;
  _rectTransforms = [];
  registerTransform(e) {
    this._rectTransforms.push(e);
  }
  unregisterTransform(e) {
    const t = this._rectTransforms.indexOf(e);
    t !== -1 && this._rectTransforms.splice(t, 1);
  }
  _layoutGroups = /* @__PURE__ */ new Map();
  registerLayoutGroup(e) {
    const t = e.gameObject;
    this._layoutGroups.set(t, e);
  }
  unregisterLayoutGroup(e) {
    const t = e.gameObject;
    this._layoutGroups.delete(t);
  }
  _receivers = [];
  registerEventReceiver(e) {
    this._receivers.push(e);
  }
  unregisterEventReceiver(e) {
    const t = this._receivers.indexOf(e);
    t !== -1 && this._receivers.splice(t, 1);
  }
  async onEnterXR(e) {
    this.screenspace ? (e.xr.isVR || e.xr.isPassThrough) && (this.gameObject.visible = !1) : (this.gameObject.visible = !1, await Ud(1).then(() => {
      this.gameObject.visible = !0;
    }));
  }
  onLeaveXR(e) {
    this.screenspace && (e.xr.isVR || e.xr.isPassThrough) && (this.gameObject.visible = !0);
  }
  onBeforeRenderRoutine = () => {
    if (this.previousParent = this.gameObject.parent, (this.context.xr?.isVR || this.context.xr?.isPassThrough) && this.screenspace) {
      this.gameObject.visible = !1, this.gameObject.removeFromParent();
      return;
    }
    this.renderOnTop || this.screenspace ? this.gameObject.removeFromParent() : (this.onUpdateRenderMode(), this.handleLayoutUpdates(), this.shadowComponent?.updateMatrixWorld(!0), this.shadowComponent?.updateWorldMatrix(!0, !0), this.invokeBeforeRenderEvents(), Jt.ensureUpdateMeshUI(ty, this.context));
  };
  onAfterRenderRoutine = () => {
    if ((this.context.xr?.isVR || this.context.xr?.isPassThrough) && this.screenspace) {
      this.previousParent?.add(this.gameObject);
      return;
    }
    if ((this.screenspace || this.renderOnTop) && this.previousParent && this.context.mainCamera) {
      this.screenspace ? this.context.mainCamera?.add(this.gameObject) : this.previousParent.add(this.gameObject);
      const e = this.context.renderer.autoClear, t = this.context.renderer.autoClearColor;
      this.context.renderer.autoClear = !1, this.context.renderer.autoClearColor = !1, this.context.renderer.clearDepth(), this.onUpdateRenderMode(!0), this.handleLayoutUpdates(), this.shadowComponent?.updateMatrixWorld(!0), this.invokeBeforeRenderEvents(), Jt.ensureUpdateMeshUI(ty, this.context, !0), this.context.renderer.render(this.gameObject, this.context.mainCamera), this.context.renderer.autoClear = e, this.context.renderer.autoClearColor = t, this.previousParent.add(this.gameObject);
    }
    this._lastMatrixWorld?.copy(this.gameObject.matrixWorld);
  };
  invokeBeforeRenderEvents() {
    for (const e of this._receivers)
      e.onBeforeCanvasRender?.(this);
  }
  handleLayoutUpdates() {
    this._lastMatrixWorld === null && (this._lastMatrixWorld = new te());
    const e = !this._lastMatrixWorld.equals(this.gameObject.matrixWorld);
    Uf && e && console.log("Canvas Layout changed", this.context.time.frameCount, this.name);
    for (const t of this._rectTransforms) {
      e && t.markDirty();
      let i = this._layoutGroups.get(t.gameObject);
      t.isDirty && !i && (i = t.gameObject.getComponentInParent(Si)), (t.isDirty || i?.isDirty) && (Uf && console.log("CANVAS UPDATE ### " + t.name + " ##################################### " + this.context.time.frame), i?.updateLayout(), t.updateTransform());
    }
  }
  applyRenderSettings() {
    this.onRenderSettingsChanged();
  }
  _updateRenderSettingsRoutine;
  onRenderSettingsChanged() {
    this._updateRenderSettingsRoutine || (this._updateRenderSettingsRoutine = this.startCoroutine(this._updateRenderSettingsDelayed(), xe.OnBeforeRender));
  }
  *_updateRenderSettingsDelayed() {
    if (yield, this._updateRenderSettingsRoutine = void 0, this.shadowComponent) {
      this.onUpdateRenderMode(), ud(this.shadowComponent, this);
      for (const e of S.getComponentsInChildren(this.gameObject, hn))
        ud(e.shadowComponent, this);
    }
  }
  _activeRenderMode = -1;
  _lastWidth = -1;
  _lastHeight = -1;
  onUpdateRenderMode(e = !1) {
    if (!e && this._renderMode === this._activeRenderMode && this._lastWidth === this.context.domWidth && this._lastHeight === this.context.domHeight)
      return;
    this._activeRenderMode = this._renderMode;
    let t = this.context.mainCameraComponent, i = 10;
    switch (t && t.nearClipPlane > 0 && t.farClipPlane > 0 && (i = j.lerp(t.nearClipPlane, t.farClipPlane, 0.01)), this._renderMode === 1 && (this.worldCamera && (t = this.worldCamera), this.planeDistance > 0 && (i = this.planeDistance)), this._renderMode) {
      case 0:
      case 1:
        if (this._lastWidth = this.context.domWidth, this._lastHeight = this.context.domHeight, !t) return;
        const n = i + 0.01;
        this.gameObject.position.x = 0, this.gameObject.position.y = 0, this.gameObject.position.z = -n, this.gameObject.quaternion.identity();
        const o = this.gameObject.getComponent(zn);
        let r = !1;
        o.sizeDelta.x !== this.context.domWidth && (r = !0), o.sizeDelta.y !== this.context.domHeight && (r = !0);
        const a = t.fieldOfView * Math.PI / 180, l = 2 * Math.tan(a / 2) * Math.abs(n);
        this.gameObject.scale.x = l / this.context.domHeight, this.gameObject.scale.y = l / this.context.domHeight, this.gameObject.scale.z = 0.01, r && (o.sizeDelta.x = this.context.domWidth, o.sizeDelta.y = this.context.domHeight, o?.markDirty());
        break;
      case 2:
        this._lastWidth = -1, this._lastHeight = -1;
        break;
    }
  }
};
Wn([
  u()
], qi.prototype, "renderOnTop", 1);
Wn([
  u()
], qi.prototype, "depthWrite", 1);
Wn([
  u()
], qi.prototype, "doubleSided", 1);
Wn([
  u()
], qi.prototype, "castShadows", 1);
Wn([
  u()
], qi.prototype, "receiveShadows", 1);
Wn([
  u()
], qi.prototype, "renderMode", 1);
Wn([
  u(qi)
], qi.prototype, "rootCanvas", 1);
Wn([
  u()
], qi.prototype, "scaleFactor", 1);
Wn([
  u(ui)
], qi.prototype, "worldCamera", 2);
Wn([
  u()
], qi.prototype, "planeDistance", 2);
let hc = qi;
var BR = Object.defineProperty, FR = Object.getOwnPropertyDescriptor, yg = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? FR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && BR(e, t, n), n;
};
class cr extends T {
  get alpha() {
    return this._alpha;
  }
  set alpha(e) {
    e !== this._alpha && (this._alpha = e, this.markDirty());
  }
  get isCanvasGroup() {
    return !0;
  }
  _alpha = 1;
  interactable = !0;
  blocksRaycasts = !0;
  _isDirty = !1;
  markDirty() {
    this._isDirty || (this._isDirty = !0, this.startCoroutine(this.applyChangesDelayed(), xe.OnBeforeRender));
  }
  *applyChangesDelayed() {
    this._isDirty = !1, this.applyChangesNow();
  }
  _buffer = [];
  applyChangesNow() {
    this._buffer.length = 0;
    for (const e of S.getComponentsInChildren(this.gameObject, hn, this._buffer)) {
      const t = e;
      t.setAlphaFactor && t.setAlphaFactor(this._alpha);
    }
  }
}
yg([
  u()
], cr.prototype, "alpha", 1);
yg([
  u()
], cr.prototype, "interactable", 2);
yg([
  u()
], cr.prototype, "blocksRaycasts", 2);
class Qv {
  get extensionName() {
    return "tmui";
  }
  // TODO would probably be better to export each object instead of the entire Canvas
  // so that we don't export them twice (once as regular hierarchy, once as part of Canvas export)
  onExportObject(e, t, i) {
    const n = S.getComponent(e, hc);
    if (n && n.enabled && n.renderMode === qv.WorldSpace) {
      const o = new gg(), r = S.getComponent(e, zn), a = S.getComponent(e, cr), l = new Array();
      if (r) {
        if (!S.isActiveSelf(e)) {
          const d = S.isActiveSelf(e);
          S.setActive(e, !0), r.onEnable(), r.updateTransform(), l.push(() => {
            r.onDisable(), S.setActive(e, d);
          });
        }
        e.traverse((d) => {
          if (!S.isActiveInHierarchy(d)) {
            const f = S.isActiveSelf(d);
            S.setActive(d, !0);
            const p = S.getComponent(d, hn);
            p && (p.onEnable(), l.push(() => {
              p.onDisable();
            }));
            const g = S.getComponent(d, zn);
            g && (g.onEnable(), g.updateTransform(), g.onApplyTransform(), l.push(() => {
              g.onDisable();
            }));
            const _ = S.getComponent(d, Gt);
            _ && (_.onEnable(), l.push(() => {
              _.onDisable();
            })), l.push(() => {
              S.setActive(d, f);
            });
          }
        }), r.width, r.height;
        const c = st.createEmpty(), h = r.shadowComponent;
        if (t.add(c), h) {
          const d = h.matrix;
          c.setMatrix(d);
          const f = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map();
          f.set(h, c), p.set(h, a ? a.alpha : 1), h.traverse((g) => {
            if (g === h) return;
            const _ = st.createEmpty();
            _.setMatrix(g.matrix);
            const m = g.parent, v = !!m && typeof m.textContent == "string" && m.textContent.length > 0;
            let y = p.get(m) || 1;
            const x = S.getComponent(g, cr);
            if (x && (y *= x.alpha), g instanceof H && v) {
              const O = g[ci];
              O ? o.exportText(O.gameObject, _, i) : console.error("Error when exporting UI: shadow component owner not found. This is likely a bug.", g);
            }
            if (g instanceof H && !v) {
              const O = g.geometry.clone();
              O.scale(1, 1, -1), this.flipWindingOrder(O), _.geometry = O;
              const k = new se(), E = g.material.opacity;
              k.copy(g.material.color), _.material = new we({
                color: k,
                opacity: E * y,
                map: g.material.map,
                transparent: !0
              });
            }
            f.set(g, _), p.set(g, y);
            const I = f.get(m);
            if (!I) {
              console.error("Error when exporting UI: shadow component parent not found!", g, g.parent);
              return;
            }
            I.add(_);
          });
        }
      }
      for (const c of l)
        c();
    }
  }
  flipWindingOrder(e) {
    const t = e.index.array;
    for (let i = 0, n = t.length / 3; i < n; i++) {
      const o = t[i * 3];
      t[i * 3] = t[i * 3 + 2], t[i * 3 + 2] = o;
    }
    e.index.needsUpdate = !0;
  }
}
const Rl = w("debugusdz");
function zR(s, e) {
  const t = [], i = S.getComponentsInChildren(s, At), n = S.getComponentsInChildren(s, bi), o = new Array(), r = new Array();
  if (e.injectImplicitBehaviours)
    for (const a of i) {
      if (!a || !a.runtimeAnimatorController || !a.enabled) continue;
      const l = a.runtimeAnimatorController.activeState;
      if (!l || !l.motion || !l.motion.clip || l.motion.clip.tracks?.length < 1 || o.includes(a)) continue;
      const c = new _d();
      c.animator = a, c.stateName = l.name, c.trigger = "start", c.name = "PlayAnimationOnClick_implicitAtStart_" + c.stateName;
      const h = new M();
      S.addComponent(h, c), r.push(h), o.push(a), s.add(h);
    }
  else
    for (const a of i) {
      if (!a || !a.runtimeAnimatorController || !a.enabled) continue;
      Rl && console.log(a);
      const l = [];
      for (const c of a.runtimeAnimatorController.enumerateActions()) {
        Rl && console.log(c);
        const h = c.getClip();
        l.includes(h) || l.push(h);
      }
      t.push({ root: a.gameObject, clips: l });
    }
  if (e.injectImplicitBehaviours)
    for (const a of n) {
      if (!a || !a.clip || !a.enabled || !a.playAutomatically || o.includes(a)) continue;
      const l = new _d();
      l.animation = a, l.stateName = a.clip.name, l.trigger = "start", l.name = "PlayAnimationOnClick_implicitAtStart_" + l.stateName;
      const c = new M();
      S.addComponent(c, l), r.push(c), o.push(a), s.add(c);
    }
  else
    for (const a of n) {
      Rl && console.log(a);
      const l = [];
      for (const c of a.animations)
        l.includes(c) || l.push(c);
      t.push({ root: a.gameObject, clips: l });
    }
  Rl && t?.length > 0 && console.log("USDZ Animation Clips without behaviours", t);
  for (const a of t)
    for (const l of a.clips)
      e.registerAnimation(a.root, l);
  return r;
}
function UR(s, e) {
  const t = S.getComponentsInChildren(s, ln), i = S.getComponentsInChildren(s, rr), n = new Array(), o = new Array();
  Rl && console.log({ audioSources: t, playAudioOnClicks: i });
  for (const r of i) {
    if (!r.target) continue;
    const a = t.indexOf(r.target);
    a > -1 && t.splice(a, 1);
  }
  for (const r of t) {
    if (!r || !r.clip || r.volume <= 0 || n.includes(r)) continue;
    const a = new rr();
    a.target = r, a.name = "PlayAudioOnClick_implicitAtStart_", a.trigger = "start";
    const l = new M();
    S.addComponent(l, a), console.log("implicit PlayAudioOnStart", l, a), o.push(l), n.push(r), s.add(l);
  }
  return o;
}
function NR(s) {
  return new Et(
    "DisableAtStart",
    Vt.sceneStartTrigger(),
    fe.fadeAction(s, 0, !1)
  );
}
function j_(s, e) {
  const t = s.domElement.shadowRoot.querySelector("link[rel='ar']");
  if (t) return t;
  const i = document.createElement("div");
  i.classList.add("menu"), i.classList.add("quicklook-menu"), i.style.display = "none", i.style.visibility = "hidden";
  const n = document.createElement("button");
  n.id = "open-in-ar", e ? (n.innerText = "View in AR", n.title = "View this scene in AR. The scene will be exported to USDZ and opened with Apple's QuickLook.") : (n.innerText = "View in AR", n.title = "Download this scene for AR. Open the downloaded USDZ file to view it in AR using Apple's QuickLook."), i.appendChild(n);
  const o = document.createElement("a");
  o.id = "needle-usdz-link", o.style.display = "none", o.rel = "ar", o.href = "", o.target = "_blank", i.appendChild(o);
  const r = document.createElement("img");
  return r.id = "button", o.appendChild(r), s.domElement.shadowRoot.appendChild(i), o;
}
var $R = Object.defineProperty, Pt = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && $R(e, t, n), n;
};
const ni = w("debugusdz"), WR = w("debugusdzpruning");
class za {
  callToAction;
  checkoutTitle;
  checkoutSubtitle;
  callToActionURL;
}
Pt([
  u()
], za.prototype, "callToAction");
Pt([
  u()
], za.prototype, "checkoutTitle");
Pt([
  u()
], za.prototype, "checkoutSubtitle");
Pt([
  u()
], za.prototype, "callToActionURL");
const ii = class Tl extends T {
  static beforeExport = new me();
  static afterExport = new me();
  objectToExport = void 0;
  autoExportAnimations = !0;
  autoExportAudioSources = !0;
  exportFileName = void 0;
  customUsdzFile = void 0;
  customBranding;
  anchoringType = "plane";
  maxTextureSize = 2048;
  planeAnchoringAlignment = "horizontal";
  interactive = !0;
  physics = !0;
  allowCreateQuicklookButton = !0;
  quickLookCompatible = !0;
  /**
   * Extensions to add custom behaviors and interactions to the USDZ file.   
   * You can add your own extensions here by extending {@link IUSDExporterExtension}.
   */
  extensions = [];
  link;
  button;
  /** @internal */
  start() {
    ni && (console.log("USDZExporter", this), console.log("Debug USDZ Mode. Press 'T' to export"), window.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "t":
          this.exportAndOpen();
          break;
      }
    })), this.objectToExport || (this.objectToExport = this.gameObject), !this.objectToExport?.children?.length && !this.objectToExport?.isMesh && (this.objectToExport = this.context.scene);
  }
  /** @internal */
  onEnable() {
    const e = X.supportsQuickLookAR(), t = X.isiOS() || X.isiPad();
    !this.button && (ni || e || t) && (this.allowCreateQuicklookButton && (this.button = this.createQuicklookButton()), this.lastCallback = this.quicklookCallback.bind(this), this.link = j_(this.context, e), this.link.addEventListener("message", this.lastCallback)), ni && Be("USDZ Exporter enabled: " + this.name), document.getElementById("open-in-ar")?.addEventListener("click", this.onClickedOpenInARElement), ic.registerExporter(this);
  }
  /** @internal */
  onDisable() {
    this.button?.remove(), this.link?.removeEventListener("message", this.lastCallback), ni && Be("USDZ Exporter disabled: " + this.name), document.getElementById("open-in-ar")?.removeEventListener("click", this.onClickedOpenInARElement), ic.unregisterExporter(this);
  }
  onClickedOpenInARElement = (e) => {
    e.preventDefault(), this.exportAndOpen();
  };
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * Use the various public properties of USDZExporter to customize export behaviour.
   * @deprecated use {@link exportAndOpen} instead
   */
  async exportAsync() {
    return this.exportAndOpen();
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * @returns a Promise<Blob> containing the USDZ file
   */
  async exportAndOpen() {
    let e = this.exportFileName ?? this.objectToExport?.name ?? this.name;
    if (e += "-" + OM(), bs() || (e !== "" && (e += "-"), e += "MadeWithNeedle"), this.link || (this.link = j_(this.context, X.supportsQuickLookAR())), this.customUsdzFile)
      return ni && console.log("Exporting custom usdz", this.customUsdzFile), this.openInQuickLook(this.customUsdzFile, e), null;
    if (!this.objectToExport)
      return console.warn("No object to export", this), null;
    Tl.beforeExport.invoke({ exporter: this });
    const t = await this.export(this.objectToExport).finally(() => {
      Tl.afterExport.invoke({ exporter: this });
    });
    return t ? (ni && console.log("USDZ generation done. Downloading as " + e), this.openInQuickLook(t, e), t) : (console.error("USDZ generation failed. Please report a bug", this), null);
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * @returns a Promise<Blob> containing the USDZ file
   */
  async export(e) {
    if (!e)
      return console.warn("No object to export"), null;
    const t = this._currentExportTasks.get(e);
    if (t)
      return t;
    const i = this.internalExport(e);
    return i instanceof Promise ? (this._currentExportTasks.set(e, i), i.then((n) => (this._currentExportTasks.delete(e), n)).catch((n) => (this._currentExportTasks.delete(e), console.error("Error during USDZ export – please report a bug!", n), null))) : i;
  }
  _currentExportTasks = /* @__PURE__ */ new Map();
  _previousTimeScale = 1;
  async internalExport(e) {
    le.start("export-usdz", {
      onProgress: (O) => {
        this.dispatchEvent(new CustomEvent("export-progress", { detail: { progress: O } }));
      }
    }), le.report("export-usdz", { message: "Starting export", totalSteps: 40, currentStep: 0 }), le.report("export-usdz", { message: "Load progressive textures", autoStep: 5 }), le.start("export-usdz-textures", "export-usdz");
    const t = S.getComponentsInChildren(e, xi);
    for (const O of t)
      O && O.enabled && O.updateSprite(!0);
    const i = S.getComponentsInChildren(e, Hi), n = new Array();
    let o = 0;
    for (const O of i) {
      for (const k of O.sharedMeshes)
        if (k) {
          const E = We.assignMeshLOD(k, 0);
          E instanceof Promise && n.push(new Promise((z, D) => {
            E.then(() => {
              o++, le.report("export-usdz-textures", { message: "Loaded progressive mesh", currentStep: o, totalSteps: n.length }), z();
            }).catch((V) => D(V));
          }));
        }
      for (const k of O.sharedMaterials)
        if (k) {
          const E = We.assignTextureLOD(k, 0);
          E instanceof Promise && n.push(new Promise((z, D) => {
            E.then(() => {
              o++, le.report("export-usdz-textures", { message: "Loaded progressive texture", currentStep: o, totalSteps: n.length }), z();
            }).catch((V) => D(V));
          }));
        }
    }
    ni && Be("Progressive Loading: " + n.length), await Promise.all(n), ni && Be("Progressive Loading: done"), le.end("export-usdz-textures");
    const r = Zt.Global.Mask;
    Zt.Global.Set(us.AR);
    const a = new FM(), l = new lg(this.quickLookCompatible);
    let c;
    const h = [];
    this.interactive && (h.push(new Bv()), h.push(new La()), globalThis.NEEDLE_USE_RAPIER && S.getComponentsInChildren(e, ft).length > 0 && (this.physics ? (c = new Fv(), h.push(c)) : L() && console.warn("USDZExporter: Physics export is disabled, but there are active Rigidbody components in the scene. They will not be exported.")), h.push(new gg()), h.push(new Qv()));
    const d = [l, ...h, ...this.extensions], f = { self: this, exporter: a, extensions: d, object: e };
    le.report("export-usdz", "Invoking before-export"), this.dispatchEvent(new CustomEvent("before-export", { detail: f })), this.applyWebARSessionRoot(), this._previousTimeScale = this.context.time.timeScale, this.context.time.timeScale = 0, le.report("export-usdz", "auto export animations and audio sources");
    const p = new Array();
    this.autoExportAnimations && p.push(...zR(e, l)), d.find((O) => O.extensionName === "Audio") && this.autoExportAudioSources && p.push(...UR(e)), a.debug = ni, a.pruneUnusedNodes = !WR;
    const _ = Pa.instance.objs.map((O) => O.batchedMesh);
    a.keepObject = (O) => {
      let k = !0;
      const E = S.getComponent(O, Hi);
      return E && !E.enabled && (k = !1), k && _.includes(O) && (k = !1), k && S.getComponentInParent(O, ou) && (k = !1), k && S.getComponentInParent(O, Ms) && (k = !1), ni && !k && console.log("USDZExporter: Discarding object", O), k;
    }, a.beforeWritingDocument = () => {
      if (L() && l && c) {
        const O = l.animatedRoots;
        for (const k of O) {
          const E = S.getComponentsInChildren(k, ft).filter((D) => D.enabled), z = S.getComponents(k, wi).filter((D) => D.enabled && !D.isTrigger);
          (E.length > 0 || z.length > 0) && console.error("An animated object has physics components in its child hierarchy. This can lead to undefined behaviour due to a bug in Apple's QuickLook (FB15925487). Remove the physics components from child objects or verify that you get the expected results.", k);
        }
      }
    };
    const m = new Array();
    this.objectToExport && this.quickLookCompatible && this.interactive && this.objectToExport.traverse((O) => {
      O.visible || m.push(O);
    });
    const v = d.find((O) => O.extensionName === "Behaviour");
    this.interactive && v && m.length > 0 && v.addBehavior(NR(m));
    let y = !0;
    this.quickLookCompatible && !this.interactive && (y = !1), this.anchoringType !== "plane" && this.anchoringType !== "none" && this.anchoringType !== "image" && this.anchoringType !== "face" && (this.anchoringType = "plane"), this.planeAnchoringAlignment !== "horizontal" && this.planeAnchoringAlignment !== "vertical" && this.planeAnchoringAlignment !== "any" && (this.planeAnchoringAlignment = "horizontal"), le.report("export-usdz", "Invoking exporter.parse");
    const x = await a.parse(this.objectToExport, {
      ar: {
        anchoring: {
          type: this.anchoringType
        },
        planeAnchoring: {
          alignment: this.planeAnchoringAlignment
        }
      },
      extensions: d,
      quickLookCompatible: this.quickLookCompatible,
      maxTextureSize: this.maxTextureSize,
      exportInvisible: y
    }), I = new Blob([x], { type: "model/vnd.usdz+zip" });
    this.revertWebARSessionRoot(), this.context.time.timeScale = this._previousTimeScale, le.report("export-usdz", "Invoking after-export"), this.dispatchEvent(new CustomEvent("after-export", { detail: f }));
    for (const O of p)
      S.destroy(O);
    return Zt.Global.Set(r), le.end("export-usdz"), I;
  }
  /**
   * Opens QuickLook on iOS/iPadOS/visionOS with the given content in AR mode.
   * @param content The URL to the .usdz or .reality file or a blob containing an USDZ file.
   * @param name Download filename
   */
  openInQuickLook(e, t) {
    const i = e instanceof Blob ? URL.createObjectURL(e) : e, n = this.buildQuicklookOverlay();
    ni && console.log("QuickLook Overlay", n);
    const o = n.callToAction ? encodeURIComponent(n.callToAction) : "", r = n.checkoutTitle ? encodeURIComponent(n.checkoutTitle) : "", a = n.checkoutSubtitle ? encodeURIComponent(n.checkoutSubtitle) : "";
    this.link.href = i + `#callToAction=${o}&checkoutTitle=${r}&checkoutSubtitle=${a}&callToActionURL=${n.callToActionURL}`, this.lastCallback || (this.lastCallback = this.quicklookCallback.bind(this), this.link.addEventListener("message", this.lastCallback)), this.link.download = t + ".usdz", this.link.click();
  }
  /**
   * Downloads the given blob as a file.
   */
  download(e, t) {
    Tl.save(e, t);
  }
  // Matches GltfExport.save(blob, filename)
  static save(e, t) {
    const i = document.createElement("a");
    i.style.display = "none", document.body.appendChild(i), typeof e == "string" ? i.href = e : i.href = URL.createObjectURL(e), i.download = t, i.click(), i.remove();
  }
  lastCallback;
  quicklookCallback(e) {
    if (e?.data == "_apple_ar_quicklook_button_tapped") {
      ni && ge("Quicklook closed via call to action button");
      var t = new CustomEvent("quicklook-button-tapped", { detail: this });
      if (this.dispatchEvent(t), !t.defaultPrevented) {
        const i = new URLSearchParams(this.link.href);
        if (i) {
          const n = i.get("callToActionURL");
          ni && Be("Quicklook url: " + n), n && (bs() ? globalThis.open(n, "_blank") : console.warn("Quicklook closed: custom redirects require a Needle Engine Pro license: https://needle.tools/pricing", n));
        }
      }
    }
  }
  buildQuicklookOverlay() {
    const e = {};
    return this.customBranding && Object.assign(e, this.customBranding), bs() || (console.log("Custom Quicklook banner text requires pro license: https://needle.tools/pricing"), e.callToAction = "Close", e.checkoutTitle = "🌵 Made with Needle", e.checkoutSubtitle = "_"), (e.callToAction?.length || e.checkoutTitle?.length || e.checkoutSubtitle?.length) && (e.callToAction?.length || (e.callToAction = "\0"), e.checkoutTitle?.length || (e.checkoutTitle = "\0"), e.checkoutSubtitle?.length || (e.checkoutSubtitle = "\0")), this.dispatchEvent(new CustomEvent("quicklook-overlay", { detail: e })), e;
  }
  static invertForwardMatrix = new te().makeRotationY(Math.PI);
  static invertForwardQuaternion = new $().setFromEuler(new Rt(0, Math.PI, 0));
  _rootSessionRootWasAppliedTo = null;
  _rootPositionBeforeExport = new b();
  _rootRotationBeforeExport = new $();
  _rootScaleBeforeExport = new b();
  getARScaleAndTarget() {
    if (!this.objectToExport) return { scale: 1, _invertForward: !1, target: this.gameObject, sessionRoot: null };
    const e = S.findObjectOfType(pg);
    let t = S.getComponentInParent(this.objectToExport, Ni);
    t || (t = S.getComponentInChildren(this.objectToExport, Ni));
    let i = 1, n = !1;
    const o = this.objectToExport;
    return e ? i = e.arScale : t && (i = t.arScale, n = t.invertForward), { scale: 1 / i, _invertForward: n, target: o, sessionRoot: t?.gameObject ?? null };
  }
  applyWebARSessionRoot() {
    if (!this.objectToExport) return;
    const { scale: e, _invertForward: t, target: i, sessionRoot: n } = this.getARScaleAndTarget(), o = n?.matrixWorld.clone().invert();
    this._rootSessionRootWasAppliedTo = i, this._rootPositionBeforeExport.copy(i.position), this._rootRotationBeforeExport.copy(i.quaternion), this._rootScaleBeforeExport.copy(i.scale), i.scale.multiplyScalar(e), t && i.quaternion.multiply(Tl.invertForwardQuaternion), i.updateMatrix(), i.updateMatrixWorld(!0), n && o && i.matrix.premultiply(o);
  }
  revertWebARSessionRoot() {
    if (!this.objectToExport || !this._rootSessionRootWasAppliedTo) return;
    const e = this._rootSessionRootWasAppliedTo;
    e.position.copy(this._rootPositionBeforeExport), e.quaternion.copy(this._rootRotationBeforeExport), e.scale.copy(this._rootScaleBeforeExport), e.updateMatrix(), e.updateMatrixWorld(!0), this._rootSessionRootWasAppliedTo = null;
  }
  createQuicklookButton() {
    const t = ir.getOrCreate().createQuicklookButton();
    return t.parentNode || this.context.menu.appendChild(t), t;
  }
};
Pt([
  u(M)
], ii.prototype, "objectToExport");
Pt([
  u()
], ii.prototype, "autoExportAnimations");
Pt([
  u()
], ii.prototype, "autoExportAudioSources");
Pt([
  u()
], ii.prototype, "exportFileName");
Pt([
  u(URL)
], ii.prototype, "customUsdzFile");
Pt([
  u(za)
], ii.prototype, "customBranding");
Pt([
  u()
], ii.prototype, "anchoringType");
Pt([
  u()
], ii.prototype, "maxTextureSize");
Pt([
  u()
], ii.prototype, "planeAnchoringAlignment");
Pt([
  u()
], ii.prototype, "interactive");
Pt([
  u()
], ii.prototype, "physics");
Pt([
  u()
], ii.prototype, "allowCreateQuicklookButton");
Pt([
  u()
], ii.prototype, "quickLookCompatible");
let ws = ii;
var VR = Object.defineProperty, HR = Object.getOwnPropertyDescriptor, _g = (s, e, t, i) => {
  for (var n = HR(e, t), o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && VR(e, t, n), n;
};
class Mc extends T {
  get fog() {
    return this._fog || (this._fog = new lb(0, 0, 50)), this._fog;
  }
  get mode() {
    return 1;
  }
  set near(e) {
    this.fog.near = e;
  }
  get near() {
    return this.fog.near;
  }
  set far(e) {
    this.fog.far = e;
  }
  get far() {
    return this.fog.far;
  }
  set color(e) {
    this.fog.color.copy(e);
  }
  get color() {
    return this.fog.color;
  }
  _fog;
  onEnable() {
    this.scene.fog = this.fog;
  }
  onDisable() {
    this.scene.fog === this._fog && (this.scene.fog = null);
  }
}
_g([
  u()
], Mc.prototype, "near");
_g([
  u()
], Mc.prototype, "far");
_g([
  u(se)
], Mc.prototype, "color");
var GR = Object.defineProperty, bg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && GR(e, t, n), n;
};
class Ua extends T {
  objectBounds = !1;
  color;
  isGizmo = !0;
  _gizmoObject = null;
  _boxHelper = null;
  onEnable() {
    this.isGizmo && !mc || (this._gizmoObject || (this.objectBounds ? this._gizmoObject = new Nx(this.gameObject, this.color ?? 16776960) : (this.objectBounds = !1, this._gizmoObject = Tm(this.color ?? 16776960))), this.objectBounds ? (this.scene.add(this._gizmoObject), this._boxHelper = this._gizmoObject, this.startCoroutine(this.syncObjectBounds(), xe.OnBeforeRender)) : this.gameObject.add(this._gizmoObject));
  }
  onDisable() {
    this._gizmoObject && this.gameObject.remove(this._gizmoObject);
  }
  *syncObjectBounds() {
    for (; this._boxHelper; )
      this._boxHelper?.update(), yield;
  }
}
bg([
  u()
], Ua.prototype, "objectBounds");
bg([
  u(se)
], Ua.prototype, "color");
bg([
  u()
], Ua.prototype, "isGizmo");
var qR = Object.defineProperty, vg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && qR(e, t, n), n;
};
class Rc extends T {
  isGizmo = !1;
  color0;
  color1;
  gridHelper;
  size;
  divisions;
  offset;
  /** @internal */
  onEnable() {
    if (this.isGizmo && !mc) return;
    const e = this.size, t = this.divisions;
    this.gridHelper || (this.gridHelper = new am(e, t, this.color0 ?? new se(0.4, 0.4, 0.4), this.color1 ?? new se(0.6, 0.6, 0.6)), this.offset !== void 0 && (this.gridHelper.position.y += this.offset)), this.gridHelper && this.gameObject.add(this.gridHelper);
  }
  /** @internal */
  onDisable() {
    this.gridHelper && (this.gameObject.remove(this.gridHelper), this.gridHelper = null);
  }
}
vg([
  u()
], Rc.prototype, "isGizmo");
vg([
  u(se)
], Rc.prototype, "color0");
vg([
  u(se)
], Rc.prototype, "color1");
var XR = Object.defineProperty, wg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && XR(e, t, n), n;
};
class xg extends T {
  connectedBody;
  get rigidBody() {
    return this._rigidBody;
  }
  _rigidBody = null;
  onEnable() {
    this._rigidBody || (this._rigidBody = this.gameObject.getComponent(ft)), this.rigidBody && this.connectedBody && this.startCoroutine(this.create());
  }
  *create() {
    yield, this.rigidBody && this.connectedBody && this.activeAndEnabled && this.createJoint(this.rigidBody, this.connectedBody);
  }
}
wg([
  u(ft)
], xg.prototype, "connectedBody");
class Yv extends xg {
  createJoint(e, t) {
    this.context.physics.engine?.addFixedJoint(e, t);
  }
}
class bu extends xg {
  anchor;
  axis;
  createJoint(e, t) {
    this.axis && this.anchor && this.context.physics.engine?.addHingeJoint(e, t, this.anchor, this.axis);
  }
}
wg([
  u(b)
], bu.prototype, "anchor");
wg([
  u(b)
], bu.prototype, "axis");
var QR = Object.defineProperty, YR = Object.getOwnPropertyDescriptor, Vn = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? YR(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && QR(e, t, n), n;
};
function Nf(s) {
  return s * Math.PI / 180;
}
const B_ = 300, Us = w("debuglights");
class Yi extends T {
  type = 0;
  /**
   * The maximum distance the light affects
   */
  range = 1;
  /**
   * The full outer angle of the spotlight cone in degrees
   */
  spotAngle = 1;
  /**
   * The angle of the inner cone in degrees for soft-edge spotlights
   */
  innerSpotAngle = 1;
  set color(e) {
    this._color = e, this.light !== void 0 && (this.light.color = e);
  }
  get color() {
    return this.light ? this.light.color : this._color;
  }
  _color = new se(16777215);
  set shadowNearPlane(e) {
    if (e !== this._shadowNearPlane && (this._shadowNearPlane = e, this.light?.shadow?.camera !== void 0)) {
      const t = this.light.shadow.camera;
      t.near = e;
    }
  }
  get shadowNearPlane() {
    return this._shadowNearPlane;
  }
  _shadowNearPlane = 0.1;
  set shadowBias(e) {
    e !== this._shadowBias && (this._shadowBias = e, this.light?.shadow?.bias !== void 0 && (this.light.shadow.bias = e, this.light.shadow.needsUpdate = !0));
  }
  get shadowBias() {
    return this._shadowBias;
  }
  _shadowBias = 0;
  set shadowNormalBias(e) {
    e !== this._shadowNormalBias && (this._shadowNormalBias = e, this.light?.shadow?.normalBias !== void 0 && (this.light.shadow.normalBias = e, this.light.shadow.needsUpdate = !0));
  }
  get shadowNormalBias() {
    return this._shadowNormalBias;
  }
  _shadowNormalBias = 0;
  /** when enabled this will remove the multiplication when setting the shadow bias settings initially */
  _overrideShadowBiasSettings = !1;
  set shadows(e) {
    this._shadows = e, this.light && (this.light.castShadow = e !== 0, this.updateShadowSoftHard());
  }
  get shadows() {
    return this._shadows;
  }
  _shadows = 1;
  lightmapBakeType = 4;
  set intensity(e) {
    if (this._intensity = e, this.light) {
      let t = 1;
      if (this.context.isInXR && this._webARRoot) {
        const i = this._webARRoot?.arScale;
        typeof i == "number" && i > 0 && (t /= i);
      }
      this.light.intensity = e * t;
    }
    Us && console.log("Set light intensity to " + this._intensity, e, this);
  }
  get intensity() {
    return this._intensity;
  }
  _intensity = -1;
  get shadowDistance() {
    const e = this.light;
    return e?.shadow ? e.shadow.camera.far : -1;
  }
  set shadowDistance(e) {
    this._shadowDistance = e;
    const t = this.light;
    if (t?.shadow) {
      const i = t.shadow.camera;
      i.far = e, i.updateProjectionMatrix();
    }
  }
  _shadowDistance;
  // set from additional component
  shadowWidth;
  shadowHeight;
  get shadowResolution() {
    const e = this.light;
    return e?.shadow ? e.shadow.mapSize.x : -1;
  }
  set shadowResolution(e) {
    if (e === this._shadowResolution) return;
    this._shadowResolution = e;
    const t = this.light;
    t?.shadow && (t.shadow.mapSize.set(e, e), t.shadow.needsUpdate = !0);
  }
  _shadowResolution = void 0;
  /**
   * Whether this light's illumination is entirely baked into lightmaps
   */
  get isBaked() {
    return this.lightmapBakeType === 2;
  }
  /**
   * Checks if the GameObject itself is a {@link ThreeLight} object
   */
  get selfIsLight() {
    if (this.gameObject.isLight === !0) return !0;
    switch (this.gameObject.type) {
      case "SpotLight":
      case "PointLight":
      case "DirectionalLight":
        return !0;
    }
    return !1;
  }
  /**
   * The underlying three.js {@link ThreeLight} instance
   */
  light = void 0;
  /**
   * Gets the world position of the light
   * @param vec Vector3 to store the result
   * @returns The world position as a Vector3
   */
  getWorldPosition(e) {
    return this.light ? this.type === 1 ? this.light.getWorldPosition(e).multiplyScalar(1) : this.light.getWorldPosition(e) : e;
  }
  // public updateIntensity() {
  //     this.intensity = this._intensity;
  // }
  awake() {
    this.color = new se(this.color ?? 16777215), Us && console.log(this.name, this);
  }
  onEnable() {
    Us && console.log("ENABLE LIGHT", this.name), this.createLight(), !this.isBaked && (this.light && (this.light.visible = !0, this.light.intensity = this._intensity, Us && console.log("Set light intensity to " + this.light.intensity, this.name), this.selfIsLight || this.light.parent !== this.gameObject && this.gameObject.add(this.light)), this.type === 1 && this.startCoroutine(this.updateMainLightRoutine(), xe.LateUpdate));
  }
  onDisable() {
    Us && console.log("DISABLE LIGHT", this.name), this.light && (this.selfIsLight ? this.light.intensity = 0 : this.light.visible = !1);
  }
  _webXRStartedListener;
  _webXREndedListener;
  _webARRoot;
  onEnterXR(e) {
    this._webARRoot = S.getComponentInParent(this.gameObject, Ni) ?? void 0;
  }
  // private *_updateLightIntensityInARRoutine() {
  //     while (this.context.isInAR) {
  //         yield;
  //         // this.updateIntensity();
  //         for (let i = 0; i < 30; i++) yield;
  //     }
  // }
  onLeaveXR(e) {
  }
  /**
   * Creates the appropriate three.js light based on the configured light type
   * and applies all settings like shadows, intensity, and color.
   */
  createLight() {
    const e = this.selfIsLight;
    if (e && !this.light)
      switch (this.light = this.gameObject, this.light.name = this.name, this._intensity = this.light.intensity, this.type) {
        case 1:
          this.setDirectionalLight(this.light);
          break;
      }
    else if (!this.light)
      switch (this.type) {
        case 1:
          const t = new ip(this.color, this.intensity * Math.PI);
          if (t.position.set(0, 0, -B_ * 0.5).applyQuaternion(this.gameObject.quaternion), this.gameObject.add(t.target), ua(t.target, 0, 0, 0), this.light = t, this.gameObject.position.set(0, 0, 0), this.gameObject.rotation.set(0, 0, 0), Us) {
            const r = new Wx(this.light, 0.2, this.color);
            this.context.scene.add(r);
          }
          break;
        case 0:
          const i = new $x(this.color, this.intensity * Math.PI, this.range, Nf(this.spotAngle / 2), 1 - Nf(this.innerSpotAngle / 2) / Nf(this.spotAngle / 2), 2);
          i.position.set(0, 0, 0), i.rotation.set(0, 0, 0), this.light = i;
          const n = i.target;
          i.add(n), n.position.set(0, 0, this.range), n.rotation.set(0, 0, 0);
          break;
        case 2:
          const o = new lm(this.color, this.intensity * Math.PI, this.range);
          this.light = o;
          break;
      }
    if (this.light) {
      if (this._intensity >= 0 ? this.light.intensity = this._intensity : this._intensity = this.light.intensity, this.shadows !== 0 ? this.light.castShadow = !0 : this.light.castShadow = !1, this.light.shadow) {
        this._shadowResolution !== void 0 && this._shadowResolution > 4 ? (this.light.shadow.mapSize.width = this._shadowResolution, this.light.shadow.mapSize.height = this._shadowResolution) : (this.light.shadow.mapSize.width = 2048, this.light.shadow.mapSize.height = 2048), Us && console.log("Override shadow bias?", this._overrideShadowBiasSettings, this.shadowBias, this.shadowNormalBias), this.light.shadow.bias = this.shadowBias, this.light.shadow.normalBias = this.shadowNormalBias, this.updateShadowSoftHard();
        const t = this.light.shadow.camera;
        if (t.near = this.shadowNearPlane, this._shadowDistance !== void 0 && typeof this._shadowDistance == "number" ? t.far = this._shadowDistance : t.far = B_ * Math.abs(this.gameObject.scale.z), this.gameObject.scale.set(1, 1, 1), this.shadowWidth !== void 0)
          t.left = -this.shadowWidth / 2, t.right = this.shadowWidth / 2;
        else {
          const i = this.gameObject.scale.x;
          t.left *= i, t.right *= i;
        }
        if (this.shadowHeight !== void 0)
          t.top = this.shadowHeight / 2, t.bottom = -this.shadowHeight / 2;
        else {
          const i = this.gameObject.scale.y;
          t.top *= i, t.bottom *= i;
        }
        this.light.shadow.needsUpdate = !0, Us && this.context.scene.add(new Vx(t));
      }
      this.isBaked ? this.light.removeFromParent() : e || this.gameObject.add(this.light);
    }
  }
  /**
   * Coroutine that updates the main light reference in the context
   * if this directional light should be the main light
   */
  *updateMainLightRoutine() {
    for (; ; ) {
      this.type === 1 && ((!this.context.mainLight || this.intensity > this.context.mainLight.intensity) && (this.context.mainLight = this), yield);
      break;
    }
  }
  /**
   * Controls whether the renderer's shadow map type can be changed when soft shadows are used
   */
  static allowChangingRendererShadowMapType = !0;
  /**
   * Updates shadow settings based on whether the shadows are set to hard or soft
   */
  updateShadowSoftHard() {
    this.light && this.light.shadow && (this.shadows === 2 || (this.light.shadow.radius = 1, this.light.shadow.blurSamples = 1));
  }
  /**
   * Configures a directional light by adding and positioning its target
   * @param dirLight The directional light to set up
   */
  setDirectionalLight(e) {
    e.add(e.target), e.target.position.set(0, 0, -1);
  }
}
Vn([
  u()
], Yi.prototype, "type", 2);
Vn([
  u(se)
], Yi.prototype, "color", 1);
Vn([
  u()
], Yi.prototype, "shadowNearPlane", 1);
Vn([
  u()
], Yi.prototype, "shadowBias", 1);
Vn([
  u()
], Yi.prototype, "shadowNormalBias", 1);
Vn([
  u()
], Yi.prototype, "shadows", 1);
Vn([
  u()
], Yi.prototype, "lightmapBakeType", 2);
Vn([
  u()
], Yi.prototype, "intensity", 1);
Vn([
  u()
], Yi.prototype, "shadowDistance", 1);
Vn([
  u()
], Yi.prototype, "shadowResolution", 1);
new b(0, 0, 0);
var KR = Object.defineProperty, Tc = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && KR(e, t, n), n;
};
const $f = w("debuglods"), ZR = w("nolods");
class Ec {
  screenRelativeTransitionHeight;
  distance;
  renderers;
}
Tc([
  u()
], Ec.prototype, "screenRelativeTransitionHeight");
Tc([
  u()
], Ec.prototype, "distance");
Tc([
  u(Hi)
], Ec.prototype, "renderers");
class JR {
  model;
  get renderers() {
    return this.model.renderers;
  }
  constructor(e) {
    this.model = e;
  }
}
class vu extends T {
  fadeMode = 0;
  localReferencePoint = void 0;
  lodCount = 0;
  size = 0;
  animateCrossFading = !1;
  lodModels;
  _lods = [];
  _settings = [];
  // https://threejs.org/docs/#api/en/objects/LOD
  _lodsHandler;
  start() {
    if ($f && console.log("LODGROUP", this.name, this.lodModels, this), !ZR && !this._lodsHandler && this.gameObject && this.lodModels && Array.isArray(this.lodModels)) {
      const e = [];
      for (const i of this.lodModels) {
        const n = new JR(i);
        this._lods.push(n);
        for (const o of n.renderers)
          e.includes(o) || e.push(o);
      }
      this._lodsHandler = new Array();
      for (let i = 0; i < e.length; i++) {
        const n = new Hx();
        this._lodsHandler.push(n), this.gameObject.add(n);
      }
      const t = new M();
      t.name = "Cull " + this.name;
      for (let i = 0; i < e.length; i++) {
        const n = e[i], o = this._lodsHandler[i], r = n.gameObject;
        $f && console.log(i, r.name);
        for (const a of this._lods) {
          const l = a.model.distance;
          let c = null;
          if (a.renderers.includes(n) ? c = r : c = t, c.type === "Group") {
            console.warn(`LODGroup ${this.name}: Group or MultiMaterial object's are not supported as LOD object: ${c.name}`);
            continue;
          }
          $f && console.log("LEVEL", c.name, l), o.autoUpdate = !1, this.onAddLodLevel(o, c, a.model.distance);
        }
      }
    }
  }
  onAfterRender() {
    if (!this.gameObject || !this._lodsHandler) return;
    const e = this.context.mainCamera;
    if (e)
      for (const t of this._lodsHandler) {
        t.update(e);
        const i = t.getCurrentLevel(), n = t.levels[i];
        t.layers.mask = n.object.layers.mask;
      }
  }
  onAddLodLevel(e, t, i) {
    if (t === this.gameObject) {
      console.warn("LODGroup component must be on parent object and not mesh directly at the moment", t.name, t);
      return;
    }
    e.addLevel(t, i * this._distanceFactor, 0.01);
    const n = { lod: e, levelIndex: e.levels.length - 1, distance: i };
    this._settings.push(n);
  }
  _distanceFactor = 1;
  distanceFactor(e) {
    if (e !== this._distanceFactor) {
      this._distanceFactor = e;
      for (const t of this._settings) {
        const i = t.lod.levels[t.levelIndex];
        i.distance = t.distance * e;
      }
    }
  }
}
Tc([
  u(b)
], vu.prototype, "localReferencePoint");
Tc([
  u(Ec)
], vu.prototype, "lodModels");
var eT = Object.defineProperty, tT = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && eT(e, t, n), n;
};
const _h = w("debugnestedgltf");
class Sg extends T {
  filePath;
  /**
   * EXPERIMENTAL for cloud asset loading
   */
  loadAssetInParent = !0;
  _isLoadingOrDoneLoading = !1;
  /** Register a callback that will be called when the progress of the loading changes */
  listenToProgress(e) {
    this.filePath?.beginListenDownload(e);
  }
  /** Begin loading the referenced gltf file in filePath */
  preload() {
    this.filePath?.preload();
  }
  /** @internal */
  async start() {
    if (this._isLoadingOrDoneLoading) return;
    _h && console.log(this, this.guid);
    const e = this.gameObject.parent;
    if (e) {
      this._isLoadingOrDoneLoading = !0;
      const t = new Nn();
      t.idProvider = new Tt(this.hash(this.guid)), t.parent = this.loadAssetInParent !== !1 ? e : this.gameObject, this.gameObject.updateMatrix();
      const i = this.gameObject.matrix;
      _h && console.log("Load nested:", this.filePath?.url ?? this.filePath, this.gameObject.position);
      const n = await this.filePath?.instantiate?.call(this.filePath, t);
      _h && console.log("Nested loaded:", this.filePath?.url ?? this.filePath, n), n && this.loadAssetInParent !== !1 && (n.matrixAutoUpdate = !1, n.matrix.identity(), n.applyMatrix4(i), n.matrixAutoUpdate = !0, n.layers.disableAll(), n.layers.set(this.layer), this.dispatchEvent(new CustomEvent("loaded", { detail: { instance: n, assetReference: this.filePath } }))), _h && console.log("Nested loading done:", this.filePath?.url ?? this.filePath, n);
    }
  }
  /** @internal */
  onDestroy() {
    this.filePath?.unload();
  }
  hash(e) {
    let t = 0;
    for (let i = 0; i < e.length; i++)
      t = e.charCodeAt(i) + ((t << 5) - t);
    return t;
  }
}
tT([
  u(ie)
], Sg.prototype, "filePath");
var iT = Object.defineProperty, Cg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && iT(e, t, n), n;
};
const nT = w("debugnet"), wu = class Hp extends T {
  url = null;
  urlParameterName = null;
  localhost = null;
  /** @internal */
  awake() {
    nT && console.log(this), this.context.connection.registerProvider(this);
  }
  /** 
   * Determines the websocket URL to use for networking connections.
   * Processes the configured URL, applying localhost fallbacks when appropriate and
   * handling URL parameter overrides if specified.
   * @returns The formatted websocket URL string or null if no valid URL could be determined
   * @internal
   */
  getWebsocketUrl() {
    let e = this.url ? Hp.GetUrl(this.url, this.localhost) : null;
    if (this.urlParameterName) {
      const o = w(this.urlParameterName);
      o && typeof o == "string" && (e = o);
    }
    if (!e) return null;
    const i = new RegExp("(((https?)|(?<socket_prefix>wss?))://)?(www.)?(?<url>.+)", "gm").exec(e);
    return i?.groups ? i?.groups.socket_prefix ? e : "wss://" + i?.groups.url : null;
  }
  /**
   * Processes a URL string applying various transformations based on network environment.
   * Handles relative paths and localhost fallbacks for local network environments.
   * @param url The original URL to process
   * @param localhostFallback Alternative URL to use when on a local network
   * @returns The processed URL string or null/undefined if input was invalid
   */
  static GetUrl(e, t) {
    let i = e;
    const n = Hp.IsLocalNetwork() && t;
    if (n && (i = t), e?.startsWith("/")) {
      const o = n ? i : window.location.origin;
      o?.endsWith("/") && e.startsWith("/") && (e = e.substring(1)), i = o + e;
    }
    return i;
  }
  /**
   * Determines if the current connection is on a local network.
   * Useful for applying different networking configurations in local development environments.
   * This is the same as calling {@link isLocalNetwork}.
   * @param hostname Optional hostname to check instead of the current window location
   * @returns True if the connection is on a local network, false otherwise
   */
  static IsLocalNetwork(e = window.location.hostname) {
    return rn(e);
  }
};
Cg([
  u()
], wu.prototype, "url");
Cg([
  u()
], wu.prototype, "urlParameterName");
Cg([
  u()
], wu.prototype, "localhost");
let Kv = wu;
var sT = Object.defineProperty, xu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && sT(e, t, n), n;
};
class Na extends T {
  referenceSpace;
  from;
  affectPosition = !1;
  affectRotation = !1;
  alignLookDirection = !1;
  levelLookDirection = !1;
  levelPosition = !1;
  positionOffset = new b(0, 0, 0);
  rotationOffset = new b(0, 0, 0);
  offset = new b(0, 0, 0);
  update() {
    if (!this.from) return;
    var e = Z(this.from), t = be(this.from);
    this.offset.copy(this.positionOffset);
    const i = this.offset.length();
    if (this.referenceSpace && this.offset.transformDirection(this.referenceSpace.matrixWorld).multiplyScalar(i), e.add(this.offset), this.levelPosition && this.referenceSpace) {
      const a = new nr(this.gameObject.up, 0), l = Z(this.referenceSpace);
      a.setFromNormalAndCoplanarPoint(this.gameObject.up, l);
      const c = new b(0, 0, 0);
      a.projectPoint(e, c), e.copy(c);
    }
    this.affectPosition && ut(this.gameObject, e);
    const n = new Rt(this.rotationOffset.x, this.rotationOffset.y, this.rotationOffset.z), o = new $().setFromEuler(n);
    this.affectRotation && an(this.gameObject, t.multiply(o));
    const r = new b();
    this.from.getWorldDirection(r).multiplyScalar(50), this.levelLookDirection && (r.y = 0), this.alignLookDirection && this.gameObject.lookAt(r);
  }
}
xu([
  u(S)
], Na.prototype, "referenceSpace");
xu([
  u(S)
], Na.prototype, "from");
xu([
  u(b)
], Na.prototype, "positionOffset");
xu([
  u(b)
], Na.prototype, "rotationOffset");
var oT = Object.defineProperty, wo = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && oT(e, t, n), n;
};
class fi {
  time = 0;
  value = 0;
  inTangent = 1 / 0;
  inWeight;
  outTangent = 1 / 0;
  outWeight;
  weightedMode;
  constructor(e = 0, t = 0) {
    this.time = e, this.value = t;
  }
}
wo([
  u()
], fi.prototype, "time");
wo([
  u()
], fi.prototype, "value");
wo([
  u()
], fi.prototype, "inTangent");
wo([
  u()
], fi.prototype, "inWeight");
wo([
  u()
], fi.prototype, "outTangent");
wo([
  u()
], fi.prototype, "outWeight");
wo([
  u()
], fi.prototype, "weightedMode");
const Zv = class El {
  /**
   * Creates an animation curve that goes from the `from` value to the `to` value over the given `duration`.
   */
  static linearFromTo(e, t, i) {
    const n = new El(), o = new fi();
    o.time = 0, o.value = e;
    const r = new fi();
    return r.time = i, r.value = t, n.keys.push(o, r), n;
  }
  /** Creates an animation curve with just one keyframe */
  static constant(e) {
    const t = new El(), i = new fi();
    return i.time = 0, i.value = e, t.keys.push(i), t;
  }
  keys = [];
  /** 
   * Clones this AnimationCurve and returns a new instance with the same keyframes (the keyframes are also cloned).
  */
  clone() {
    const e = new El();
    return e.keys = this.keys?.map((t) => {
      const i = new fi();
      return i.time = t.time, i.value = t.value, i.inTangent = t.inTangent, i.inWeight = t.inWeight, i.outTangent = t.outTangent, i.outWeight = t.outWeight, i.weightedMode = t.weightedMode, i;
    }) || [], e;
  }
  /** The duration of the curve, which is the time of the last keyframe. */
  get duration() {
    return !this.keys || this.keys.length == 0 ? 0 : this.keys[this.keys.length - 1].time;
  }
  /** Evaluates the curve at the given time and returns the value of the curve at that time.
   * @param time The time at which to evaluate the curve.
   * @returns The value of the curve at the given time.
   */
  evaluate(e) {
    if (!this.keys || this.keys.length == 0) return 0;
    if (this.keys.length === 1)
      return this.keys[0].value;
    if (this.keys[0].time >= e)
      return this.keys[0].value;
    for (let t = 0; t < this.keys.length; t++) {
      const i = this.keys[t];
      if (i.time <= e)
        if (t + 1 < this.keys.length) {
          const o = this.keys[t + 1];
          if (o.time < e) continue;
          return !isFinite(i.outTangent) || !isFinite(o.inTangent) ? i.value : El.interpolateValue(e, i, o);
        } else
          return i.value;
    }
    return this.keys[this.keys.length - 1].value;
  }
  static interpolateValue(e, t, i) {
    const n = t.time, o = t.value, r = t.outTangent, a = i.time, l = i.value, c = i.inTangent, h = a - n, d = h * h, f = d * h, p = ((r + c) * h - 2 * (l - o)) / f, g = (3 * (l - o) - (c + 2 * r) * h) / d, _ = r, m = o, v = e - n, y = v * v, x = y * v;
    return p * x + g * y + _ * v + m;
  }
};
wo([
  u(fi)
], Zv.prototype, "keys");
let Su = Zv;
var rT = Object.defineProperty, C = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && rT(e, t, n), n;
};
const bh = w("debugparticles");
var ls = /* @__PURE__ */ ((s) => (s[s.Billboard = 0] = "Billboard", s[s.Stretch = 1] = "Stretch", s[s.HorizontalBillboard = 2] = "HorizontalBillboard", s[s.VerticalBillboard = 3] = "VerticalBillboard", s[s.Mesh = 4] = "Mesh", s))(ls || {});
class $a {
  alphaKeys = [];
  colorKeys = [];
  get duration() {
    return 1;
  }
  evaluate(e, t) {
    let i, n = 0, o = null, r = 0;
    for (let a = 0; a < this.alphaKeys.length; a++) {
      const l = this.alphaKeys[a];
      (l.time < e || !i) && (i = l, n = a);
    }
    for (let a = 0; a < this.colorKeys.length; a++) {
      const l = this.colorKeys[a];
      (l.time < e || !o) && (o = l, r = a);
    }
    if (o)
      if (r + 1 < this.colorKeys.length) {
        const l = this.colorKeys[r + 1], c = j.remap(e, o.time, l.time, 0, 1);
        t.r = j.lerp(o.color.r, l.color.r, c), t.g = j.lerp(o.color.g, l.color.g, c), t.b = j.lerp(o.color.b, l.color.b, c);
      } else
        t.r = o.color.r, t.g = o.color.g, t.b = o.color.b;
    if (i)
      if (n + 1 < this.alphaKeys.length) {
        const l = this.alphaKeys[n + 1], c = j.remap(e, i.time, l.time, 0, 1);
        t.alpha = j.lerp(i.alpha, l.alpha, c);
      } else
        t.alpha = i.alpha;
    return t;
  }
}
C([
  u()
], $a.prototype, "alphaKeys");
C([
  u()
], $a.prototype, "colorKeys");
var dc = /* @__PURE__ */ ((s) => (s[s.Local = 0] = "Local", s[s.World = 1] = "World", s[s.Custom = 2] = "Custom", s))(dc || {}), Gp = /* @__PURE__ */ ((s) => (s[s.Sphere = 0] = "Sphere", s[s.SphereShell = 1] = "SphereShell", s[s.Hemisphere = 2] = "Hemisphere", s[s.HemisphereShell = 3] = "HemisphereShell", s[s.Cone = 4] = "Cone", s[s.Box = 5] = "Box", s[s.Mesh = 6] = "Mesh", s[s.ConeShell = 7] = "ConeShell", s[s.ConeVolume = 8] = "ConeVolume", s[s.ConeVolumeShell = 9] = "ConeVolumeShell", s[s.Circle = 10] = "Circle", s[s.CircleEdge = 11] = "CircleEdge", s[s.SingleSidedEdge = 12] = "SingleSidedEdge", s[s.MeshRenderer = 13] = "MeshRenderer", s[s.SkinnedMeshRenderer = 14] = "SkinnedMeshRenderer", s[s.BoxShell = 15] = "BoxShell", s[s.BoxEdge = 16] = "BoxEdge", s[s.Donut = 17] = "Donut", s[s.Rectangle = 18] = "Rectangle", s[s.Sprite = 19] = "Sprite", s[s.SpriteRenderer = 20] = "SpriteRenderer", s))(Gp || {});
const Is = class Al {
  static constant(e) {
    const t = new Al();
    return t.setConstant(e), t;
  }
  static betweenTwoConstants(e, t) {
    const i = new Al();
    return i.setMinMaxConstant(e, t), i;
  }
  static curve(e, t = 1) {
    const i = new Al();
    return i.setCurve(e, t), i;
  }
  setConstant(e) {
    this.mode = 0, this.constant = e;
  }
  setMinMaxConstant(e, t) {
    this.mode = 3, this.constantMin = e, this.constantMax = t;
  }
  setCurve(e, t = 1) {
    this.mode = 1, this.curve = e, this.curveMultiplier = t;
  }
  mode = "Constant";
  constant;
  constantMin;
  constantMax;
  curve;
  curveMin;
  curveMax;
  curveMultiplier;
  clone() {
    const e = new Al();
    return e.mode = this.mode, e.constant = this.constant, e.constantMin = this.constantMin, e.constantMax = this.constantMax, e.curve = this.curve?.clone(), e.curveMin = this.curveMin?.clone(), e.curveMax = this.curveMax?.clone(), e.curveMultiplier = this.curveMultiplier, e;
  }
  evaluate(e, t) {
    const i = t === void 0 ? Math.random() : t;
    switch (this.mode) {
      case 0:
      case "Constant":
        return this.constant;
      case 1:
      case "Curve":
        return e = j.clamp01(e), this.curve.evaluate(e) * this.curveMultiplier;
      case 2:
      case "TwoCurves":
        const n = e * this.curveMin.duration, o = e * this.curveMax.duration;
        return j.lerp(this.curveMin.evaluate(n), this.curveMax.evaluate(o), i % 1) * this.curveMultiplier;
      case 3:
      case "TwoConstants":
        return j.lerp(this.constantMin, this.constantMax, i % 1);
      default:
        this.curveMax.evaluate(e) * this.curveMultiplier;
        break;
    }
    return 0;
  }
  getMax() {
    switch (this.mode) {
      case 0:
      case "Constant":
        return this.constant;
      case 1:
      case "Curve":
        return this.getMaxFromCurve(this.curve) * this.curveMultiplier;
      case 2:
      case "TwoCurves":
        return Math.max(this.getMaxFromCurve(this.curveMin), this.getMaxFromCurve(this.curveMax)) * this.curveMultiplier;
      case 3:
      case "TwoConstants":
        return Math.max(this.constantMin, this.constantMax);
      default:
        return 0;
    }
  }
  getMaxFromCurve(e) {
    if (!e) return 0;
    let t = Number.MIN_VALUE;
    for (let i = 0; i < e.keys.length; i++) {
      const n = e.keys[i];
      n.value > t && (t = n.value);
    }
    return t;
  }
};
C([
  u()
], Is.prototype, "mode");
C([
  u()
], Is.prototype, "constant");
C([
  u()
], Is.prototype, "constantMin");
C([
  u()
], Is.prototype, "constantMax");
C([
  u(Su)
], Is.prototype, "curve");
C([
  u(Su)
], Is.prototype, "curveMin");
C([
  u(Su)
], Is.prototype, "curveMax");
C([
  u()
], Is.prototype, "curveMultiplier");
let Y = Is;
const xo = class St {
  static constant(e) {
    const t = new St();
    return t.constant(e), t;
  }
  static betweenTwoColors(e, t) {
    const i = new St();
    return i.betweenTwoColors(e, t), i;
  }
  constant(e) {
    return this.mode = 0, this.color = e, this;
  }
  betweenTwoColors(e, t) {
    return this.mode = 2, this.colorMin = e, this.colorMax = t, this;
  }
  mode = 0;
  color;
  colorMin;
  colorMax;
  gradient;
  gradientMin;
  gradientMax;
  static _temp = new oe(0, 0, 0, 1);
  static _temp2 = new oe(0, 0, 0, 1);
  evaluate(e, t) {
    const i = t === void 0 ? Math.random() : t;
    switch (this.mode) {
      case 0:
      case "Color":
        return this.color;
      case 1:
      case "Gradient":
        return this.gradient.evaluate(e, St._temp), St._temp;
      case 2:
      case "TwoColors":
        return St._temp.lerpColors(this.colorMin, this.colorMax, i);
      case 3:
      case "TwoGradients":
        return this.gradientMin.evaluate(e, St._temp), this.gradientMax.evaluate(e, St._temp2), St._temp.lerp(St._temp2, i);
      case 4:
      case "RandomColor":
        const o = Math.random();
        return this.gradientMin.evaluate(e, St._temp), this.gradientMax.evaluate(e, St._temp2), St._temp.lerp(St._temp2, o);
    }
    return St._temp.set(16777215), St._temp.alpha = 1, St._temp;
  }
};
C([
  u()
], xo.prototype, "mode");
C([
  u(oe)
], xo.prototype, "color");
C([
  u(oe)
], xo.prototype, "colorMin");
C([
  u(oe)
], xo.prototype, "colorMax");
C([
  u($a)
], xo.prototype, "gradient");
C([
  u($a)
], xo.prototype, "gradientMin");
C([
  u($a)
], xo.prototype, "gradientMax");
let Wa = xo;
var qp = /* @__PURE__ */ ((s) => (s[s.Hierarchy = 0] = "Hierarchy", s[s.Local = 1] = "Local", s[s.Shape = 2] = "Shape", s))(qp || {});
class qt {
  cullingMode;
  duration;
  emitterVelocityMode;
  flipRotation;
  gravityModifier;
  gravityModifierMultiplier;
  loop;
  maxParticles;
  playOnAwake;
  prewarm;
  ringBufferLoopRange;
  ringBufferMode;
  scalingMode;
  simulationSpace;
  simulationSpeed;
  startColor;
  startDelay;
  startDelayMultiplier;
  startLifetime;
  startLifetimeMultiplier;
  startRotation;
  startRotationMultiplier;
  startRotation3D;
  startRotationX;
  startRotationXMultiplier;
  startRotationY;
  startRotationYMultiplier;
  startRotationZ;
  startRotationZMultiplier;
  startSize;
  startSize3D;
  startSizeMultiplier;
  startSizeX;
  startSizeXMultiplier;
  startSizeY;
  startSizeYMultiplier;
  startSizeZ;
  startSizeZMultiplier;
  startSpeed;
  startSpeedMultiplier;
  stopAction;
  useUnscaledTime;
}
C([
  u(Y)
], qt.prototype, "gravityModifier");
C([
  u(Wa)
], qt.prototype, "startColor");
C([
  u(Y)
], qt.prototype, "startDelay");
C([
  u(Y)
], qt.prototype, "startLifetime");
C([
  u(Y)
], qt.prototype, "startRotation");
C([
  u(Y)
], qt.prototype, "startRotationX");
C([
  u(Y)
], qt.prototype, "startRotationY");
C([
  u(Y)
], qt.prototype, "startRotationZ");
C([
  u(Y)
], qt.prototype, "startSize");
C([
  u(Y)
], qt.prototype, "startSizeX");
C([
  u(Y)
], qt.prototype, "startSizeY");
C([
  u(Y)
], qt.prototype, "startSizeZ");
C([
  u(Y)
], qt.prototype, "startSpeed");
class Xp {
  cycleCount;
  maxCount;
  minCount;
  probability;
  repeatInterval;
  time;
  count;
  _performed = 0;
  reset() {
    this._performed = 0;
  }
  run(e) {
    if (e <= this.time)
      return 0;
    let t = 0;
    if (this.cycleCount === 0 || this._performed < this.cycleCount) {
      const i = this.time + this.repeatInterval * this._performed;
      if (e >= i && (this._performed += 1, Math.random() < this.probability))
        switch (this.count.mode) {
          case 0:
            t = this.count.constant;
            break;
          case 3:
            t = j.lerp(this.count.constantMin, this.count.constantMax, Math.random());
            break;
          case 1:
            t = this.count.curve.evaluate(Math.random());
            break;
          case 2:
            const n = Math.random();
            t = j.lerp(this.count.curveMin.evaluate(n), this.count.curveMax.evaluate(n), Math.random());
            break;
        }
    }
    return t;
  }
}
class So {
  enabled;
  get burstCount() {
    return this.bursts?.length ?? 0;
  }
  bursts;
  rateOverTime;
  rateOverTimeMultiplier;
  rateOverDistance;
  rateOverDistanceMultiplier;
  /** set from system */
  system;
  reset() {
    this.bursts?.forEach((e) => e.reset());
  }
  getBurst() {
    let e = 0;
    if (this.burstCount > 0)
      for (let t = 0; t < this.burstCount; t++) {
        const i = this.bursts[t];
        this.system.main.loop && i.time >= this.system.time && i.reset(), e += Math.round(i.run(this.system.time));
      }
    return e;
  }
}
C([
  u()
], So.prototype, "enabled");
C([
  u()
], So.prototype, "bursts");
C([
  u(Y)
], So.prototype, "rateOverTime");
C([
  u()
], So.prototype, "rateOverTimeMultiplier");
C([
  u(Y)
], So.prototype, "rateOverDistance");
C([
  u()
], So.prototype, "rateOverDistanceMultiplier");
class Pg {
  enabled;
  color;
}
C([
  u(Wa)
], Pg.prototype, "color");
class Va {
  enabled;
  separateAxes;
  size;
  sizeMultiplier;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  _time = 0;
  _temp = new b();
  evaluate(e, t, i) {
    if (t || (t = this._temp), !this.enabled)
      return t.x = t.y = t.z = 1, t;
    if (this.separateAxes)
      t.x = this.x.evaluate(e, i) * this.xMultiplier, t.y = this.y.evaluate(e, i) * this.yMultiplier, t.z = this.z.evaluate(e, i) * this.zMultiplier;
    else {
      const n = this.size.evaluate(e, i) * this.sizeMultiplier;
      t.x = n;
    }
    return t;
  }
}
C([
  u(Y)
], Va.prototype, "size");
C([
  u(Y)
], Va.prototype, "x");
C([
  u(Y)
], Va.prototype, "y");
C([
  u(Y)
], Va.prototype, "z");
const Ke = class Il {
  // Emittershape start
  get type() {
    return Gp[this.shapeType];
  }
  initialize(e) {
    this.onInitialize(e), e.position.x = this._vector.x, e.position.y = this._vector.y, e.position.z = this._vector.z;
  }
  toJSON() {
    return this;
  }
  clone() {
    return new Il();
  }
  shapeType = 5;
  enabled = !0;
  alignToDirection = !1;
  angle = 0;
  arc = 360;
  arcSpread;
  arcSpeedMultiplier;
  arcMode;
  boxThickness;
  position;
  rotation;
  _rotation = new Rt();
  scale;
  radius;
  radiusThickness;
  sphericalDirectionAmount;
  randomDirectionAmount;
  randomPositionAmount;
  meshShapeType;
  meshRenderer;
  _meshObj;
  _meshGeometry;
  setMesh(e) {
    this.meshRenderer = e, e ? (this._meshObj = e.sharedMeshes[Math.floor(Math.random() * e.sharedMeshes.length)], this._meshGeometry = this._meshObj.geometry) : (this._meshObj = void 0, this._meshGeometry = void 0);
  }
  system;
  _space;
  _worldSpaceMatrix = new te();
  _worldSpaceMatrixInverse = new te();
  constructor() {
    bh && console.log(this);
  }
  update(e, t) {
  }
  onUpdate(e, t, i, n) {
    this.system = e, this._space = i, i === 1 && (this._worldSpaceMatrix.copy(n.matrixWorld), this._worldSpaceMatrix.elements[0] = 1, this._worldSpaceMatrix.elements[5] = 1, this._worldSpaceMatrix.elements[10] = 1, this._worldSpaceMatrixInverse.copy(this._worldSpaceMatrix).invert());
  }
  applyRotation(e) {
    const t = this.rotation.x !== 0 || this.rotation.y !== 0 || this.rotation.z !== 0;
    return t && (this._rotation.x = j.toRadians(this.rotation.x), this._rotation.y = j.toRadians(this.rotation.y), this._rotation.z = j.toRadians(this.rotation.z), this._rotation.order = "ZYX", e.applyEuler(this._rotation)), t;
  }
  /** nebula implementations: */
  /** initializer implementation */
  _vector = new b(0, 0, 0);
  _temp = new b(0, 0, 0);
  _triangle = new Gx();
  onInitialize(e) {
    this._vector.set(0, 0, 0), e.mesh = void 0, e.mesh_geometry = void 0;
    const t = this._temp.copy(this.position), i = this._space === 1;
    i && t.applyQuaternion(this.system.worldQuaternion);
    let n = this.radius;
    if (i && (n *= this.system.worldScale.x), this.enabled) {
      switch (this.shapeType) {
        case 5:
          bh && F.DrawWireBox(this.position, this.scale, 14540253, 1), this._vector.x = Math.random() * this.scale.x - this.scale.x / 2, this._vector.y = Math.random() * this.scale.y - this.scale.y / 2, this._vector.z = Math.random() * this.scale.z - this.scale.z / 2, this._vector.add(t);
          break;
        case 4:
          this.randomConePoint(this.position, this.angle, n, this.radiusThickness, this.arc, this.arcMode, this._vector);
          break;
        case 0:
          this.randomSpherePoint(this.position, n, this.radiusThickness, this.arc, this._vector);
          break;
        case 10:
          this.randomCirclePoint(this.position, n, this.radiusThickness, this.arc, this._vector);
          break;
        case 13:
          const o = this.meshRenderer;
          o?.destroyed == !1 && this.setMesh(o);
          const r = e.mesh = this._meshObj, a = e.mesh_geometry = this._meshGeometry;
          if (r && a)
            switch (this.meshShapeType) {
              case 0:
                {
                  const l = a.getAttribute("position"), c = Math.floor(Math.random() * l.count);
                  this._vector.fromBufferAttribute(l, c), this._vector.applyMatrix4(r.matrixWorld), e.mesh_normal = c;
                }
                break;
              case 1:
                break;
              case 2:
                {
                  const l = a.index;
                  if (l) {
                    let c = Math.random(), h = Math.random();
                    c + h > 1 && (c = 1 - c, h = 1 - h);
                    const d = Math.floor(Math.random() * (l.count / 3));
                    let f = d * 3, p = d * 3 + 1, g = d * 3 + 2;
                    f = l.getX(f), p = l.getX(p), g = l.getX(g);
                    const _ = a.getAttribute("position");
                    this._triangle.a.fromBufferAttribute(_, f), this._triangle.b.fromBufferAttribute(_, p), this._triangle.c.fromBufferAttribute(_, g), this._vector.set(0, 0, 0).addScaledVector(this._triangle.a, c).addScaledVector(this._triangle.b, h).addScaledVector(this._triangle.c, 1 - (c + h)), this._vector.applyMatrix4(r.matrixWorld), e.mesh_normal = d;
                  }
                }
                break;
            }
          break;
        default:
          this._vector.set(0, 0, 0), L() && !globalThis.__particlesystem_shapetype_unsupported && (console.warn("ParticleSystem ShapeType is not supported:", Gp[this.shapeType]), globalThis.__particlesystem_shapetype_unsupported = !0);
          break;
      }
      this.randomizePosition(this._vector, this.randomPositionAmount);
    }
    this.applyRotation(this._vector), i && (this._vector.applyQuaternion(this.system.worldQuaternion), this._vector.add(this.system.worldPos)), bh && F.DrawSphere(this._vector, 0.03, 16711680, 0.5, !0);
  }
  _dir = new b();
  getDirection(e, t) {
    if (!this.enabled)
      return this._dir.set(0, 0, 1), this._dir;
    switch (this.shapeType) {
      case 5:
        this._dir.set(0, 0, 1);
        break;
      case 4:
        this._dir.set(0, 0, 1);
        break;
      case 10:
      case 0:
        const i = t.x, n = t.y, o = t.z;
        this._dir.set(i, n, o), this.system?.worldspace ? this._dir.sub(this.system.worldPos) : this._dir.sub(this.position);
        break;
      case 13:
        const r = e.mesh, a = e.mesh_geometry;
        if (r && a)
          switch (this.meshShapeType) {
            case 0:
              {
                const l = a.getAttribute("normal"), c = e.mesh_normal;
                this._dir.fromBufferAttribute(l, c);
              }
              break;
            case 1:
              break;
            case 2:
              {
                const l = a.index;
                if (l) {
                  const c = e.mesh_normal, h = l.getX(c * 3), d = l.getX(c * 3 + 1), f = l.getX(c * 3 + 2), p = a.getAttribute("position"), g = G(), _ = G(), m = G();
                  g.fromBufferAttribute(p, h), _.fromBufferAttribute(p, d), m.fromBufferAttribute(p, f), g.sub(_), m.sub(_), g.cross(m), this._dir.copy(g).multiplyScalar(-1);
                  const v = be(r);
                  this._dir.applyQuaternion(v);
                }
              }
              break;
          }
        break;
      default:
        this._dir.set(0, 0, 1);
        break;
    }
    return this._space === 1 && this._dir.applyQuaternion(this.system.worldQuaternion), this.applyRotation(this._dir), this._dir.normalize(), this.spherizeDirection(this._dir, this.sphericalDirectionAmount), this.randomizeDirection(this._dir, this.randomDirectionAmount), bh && (F.DrawSphere(t, 0.01, 8925952, 0.5, !0), F.DrawDirection(t, this._dir, 8925952, 0.5, !0)), this._dir;
  }
  static _randomQuat = new $();
  static _tempVec = new b();
  randomizePosition(e, t) {
    if (t <= 0) return;
    const i = Il._tempVec;
    i.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1), i.x *= t * this.scale.x, i.y *= t * this.scale.y, i.z *= t * this.scale.z, e.add(i);
  }
  randomizeDirection(e, t) {
    if (t === 0) return;
    const i = Il._randomQuat, n = Il._tempVec;
    n.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(), i.setFromAxisAngle(n, t * Math.random() * Math.PI), e.applyQuaternion(i);
  }
  spherizeDirection(e, t) {
    if (t === 0) return;
    const i = Math.random() * Math.PI * 2, n = Math.acos(1 - Math.random() * 2), o = Math.sin(n) * Math.cos(i), r = Math.sin(n) * Math.sin(i), a = Math.cos(n), l = new b(o, r, a);
    e.lerp(l, t);
  }
  randomSpherePoint(e, t, i, n, o) {
    const r = Math.random(), a = Math.random(), l = 2 * Math.PI * r * (n / 360), c = Math.acos(2 * a - 1), h = j.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), i) * t, d = e.x + this.scale.x * (-h * Math.sin(c) * Math.cos(l)), f = e.y + this.scale.y * (h * Math.sin(c) * Math.sin(l)), p = e.z + this.scale.z * (h * Math.cos(c));
    o.x = d, o.y = f, o.z = p;
  }
  randomCirclePoint(e, t, i, n, o) {
    const r = Math.random(), a = 2 * Math.PI * r * (n / 360), l = j.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), i) * t, c = e.x + this.scale.x * l * Math.cos(a), h = e.y + this.scale.y * l * Math.sin(a), d = e.z;
    o.x = c, o.y = h, o.z = d;
  }
  _loopTime = 0;
  _loopDirection = 1;
  randomConePoint(e, t, i, n, o, r, a) {
    let l = 0, c = 0;
    switch (r) {
      case 0:
        l = Math.random(), c = Math.random();
        break;
      case 2:
        this._loopTime > 1 && (this._loopDirection = -1), this._loopTime < 0 && (this._loopDirection = 1);
      // continue with loop 
      case 1:
        l = 0.5, c = Math.random(), this._loopTime += this.system.deltaTime * this._loopDirection;
        break;
    }
    let h = 2 * Math.PI * l * (o / 360);
    switch (r) {
      case 2:
      case 1:
        h += Math.PI + 0.5, h += this._loopTime * Math.PI * 2, h %= j.toRadians(o);
        break;
    }
    const d = Math.acos(2 * c - 1), f = j.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), n) * i, p = e.x + -f * Math.sin(d) * Math.cos(h), g = e.y + f * Math.sin(d) * Math.sin(h), _ = e.z;
    a.x = p * this.scale.x, a.y = g * this.scale.y, a.z = _ * this.scale.z;
  }
};
C([
  u()
], Ke.prototype, "shapeType");
C([
  u()
], Ke.prototype, "enabled");
C([
  u()
], Ke.prototype, "alignToDirection");
C([
  u()
], Ke.prototype, "angle");
C([
  u()
], Ke.prototype, "arc");
C([
  u()
], Ke.prototype, "arcSpread");
C([
  u()
], Ke.prototype, "arcSpeedMultiplier");
C([
  u()
], Ke.prototype, "arcMode");
C([
  u(b)
], Ke.prototype, "boxThickness");
C([
  u(b)
], Ke.prototype, "position");
C([
  u(b)
], Ke.prototype, "rotation");
C([
  u(b)
], Ke.prototype, "scale");
C([
  u()
], Ke.prototype, "radius");
C([
  u()
], Ke.prototype, "radiusThickness");
C([
  u()
], Ke.prototype, "sphericalDirectionAmount");
C([
  u()
], Ke.prototype, "randomDirectionAmount");
C([
  u()
], Ke.prototype, "randomPositionAmount");
C([
  u()
], Ke.prototype, "meshShapeType");
C([
  u(lu)
], Ke.prototype, "meshRenderer");
let Jv = Ke;
class ve {
  damping;
  enabled;
  frequency;
  octaveCount;
  octaveMultiplier;
  octaveScale;
  positionAmount;
  quality;
  remap;
  remapEnabled;
  remapMultiplier;
  remapX;
  remapXMultiplier;
  remapY;
  remapYMultiplier;
  remapZ;
  remapZMultiplier;
  scrollSpeedMultiplier;
  separateAxes;
  strengthMultiplier;
  strengthX;
  strengthXMultiplier;
  strengthY;
  strengthYMultiplier;
  strengthZ;
  strengthZMultiplier;
  _noise;
  _time = 0;
  update(e) {
    this._time += e.time.deltaTime * this.scrollSpeedMultiplier;
  }
  /** nebula implementations: */
  _temp = new b();
  apply(e, t, i, n, o, r) {
    if (!this.enabled) return;
    this._noise || (this._noise = TS(() => 0));
    const a = this._temp.set(t.x, t.y, t.z).multiplyScalar(this.frequency), l = this._noise(a.x, a.y, a.z, this._time), c = this._noise(a.x, a.y, a.z, this._time + 1e3 * this.frequency), h = this._noise(a.x, a.y, a.z, this._time + 2e3 * this.frequency);
    this._temp.set(l, c, h).normalize();
    const d = o / r;
    let f = this.positionAmount.evaluate(d);
    this.separateAxes ? (this._temp.x *= f * this.strengthXMultiplier, this._temp.y *= f * this.strengthYMultiplier, this._temp.z *= f * this.strengthZMultiplier) : (this.strengthX && (f *= this.strengthX.evaluate(d) * 1.5), this._temp.multiplyScalar(f)), i.x += this._temp.x, i.y += this._temp.y, i.z += this._temp.z;
  }
}
C([
  u()
], ve.prototype, "damping");
C([
  u()
], ve.prototype, "enabled");
C([
  u()
], ve.prototype, "frequency");
C([
  u()
], ve.prototype, "octaveCount");
C([
  u()
], ve.prototype, "octaveMultiplier");
C([
  u()
], ve.prototype, "octaveScale");
C([
  u(Y)
], ve.prototype, "positionAmount");
C([
  u()
], ve.prototype, "quality");
C([
  u(Y)
], ve.prototype, "remap");
C([
  u()
], ve.prototype, "remapEnabled");
C([
  u()
], ve.prototype, "remapMultiplier");
C([
  u(Y)
], ve.prototype, "remapX");
C([
  u()
], ve.prototype, "remapXMultiplier");
C([
  u(Y)
], ve.prototype, "remapY");
C([
  u()
], ve.prototype, "remapYMultiplier");
C([
  u(Y)
], ve.prototype, "remapZ");
C([
  u()
], ve.prototype, "remapZMultiplier");
C([
  u()
], ve.prototype, "scrollSpeedMultiplier");
C([
  u()
], ve.prototype, "separateAxes");
C([
  u()
], ve.prototype, "strengthMultiplier");
C([
  u(Y)
], ve.prototype, "strengthX");
C([
  u()
], ve.prototype, "strengthXMultiplier");
C([
  u(Y)
], ve.prototype, "strengthY");
C([
  u()
], ve.prototype, "strengthYMultiplier");
C([
  u(Y)
], ve.prototype, "strengthZ");
C([
  u()
], ve.prototype, "strengthZMultiplier");
class Ne {
  enabled;
  attachRibbonToTransform = !1;
  colorOverLifetime;
  colorOverTrail;
  dieWithParticles = !0;
  inheritParticleColor = !0;
  lifetime;
  lifetimeMultiplier;
  minVertexDistance = 0.2;
  mode = 0;
  ratio = 1;
  ribbonCount = 1;
  shadowBias = 0;
  sizeAffectsLifetime = !1;
  sizeAffectsWidth = !1;
  splitSubEmitterRibbons = !1;
  textureMode = 0;
  widthOverTrail;
  widthOverTrailMultiplier;
  worldSpace = !1;
  getWidth(e, t, i, n) {
    const o = this.widthOverTrail.evaluate(i, n);
    return e *= o, e;
  }
  getColor(e, t, i) {
    const n = this.colorOverTrail.evaluate(i), o = this.colorOverLifetime.evaluate(t);
    e.x *= n.r * o.r, e.y *= n.g * o.g, e.z *= n.b * o.b, "alpha" in n && "alpha" in o && (e.w *= n.alpha * o.alpha);
  }
}
C([
  u()
], Ne.prototype, "enabled");
C([
  u()
], Ne.prototype, "attachRibbonToTransform");
C([
  u(Wa)
], Ne.prototype, "colorOverLifetime");
C([
  u(Wa)
], Ne.prototype, "colorOverTrail");
C([
  u()
], Ne.prototype, "dieWithParticles");
C([
  u()
], Ne.prototype, "inheritParticleColor");
C([
  u(Y)
], Ne.prototype, "lifetime");
C([
  u()
], Ne.prototype, "lifetimeMultiplier");
C([
  u()
], Ne.prototype, "minVertexDistance");
C([
  u()
], Ne.prototype, "mode");
C([
  u()
], Ne.prototype, "ratio");
C([
  u()
], Ne.prototype, "ribbonCount");
C([
  u()
], Ne.prototype, "shadowBias");
C([
  u()
], Ne.prototype, "sizeAffectsLifetime");
C([
  u()
], Ne.prototype, "sizeAffectsWidth");
C([
  u()
], Ne.prototype, "splitSubEmitterRibbons");
C([
  u()
], Ne.prototype, "textureMode");
C([
  u(Y)
], Ne.prototype, "widthOverTrail");
C([
  u()
], Ne.prototype, "widthOverTrailMultiplier");
C([
  u()
], Ne.prototype, "worldSpace");
class Ve {
  enabled;
  space = 0;
  orbitalX;
  orbitalY;
  orbitalZ;
  orbitalXMultiplier;
  orbitalYMultiplier;
  orbitalZMultiplier;
  orbitalOffsetX;
  orbitalOffsetY;
  orbitalOffsetZ;
  speedModifier;
  speedModifierMultiplier;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  _system;
  // private _worldRotation: Quaternion = new Quaternion();
  update(e) {
    this._system = e;
  }
  _temp = new b();
  _temp2 = new b();
  _temp3 = new b();
  _hasOrbital = !1;
  _index = 0;
  _orbitalMatrix = new te();
  init(e) {
    this._index == 0 && (e.debug = !0), this._index += 1, e.orbitx = this.orbitalX.evaluate(Math.random()), e.orbity = this.orbitalY.evaluate(Math.random()), e.orbitz = this.orbitalZ.evaluate(Math.random()), this._hasOrbital = e.orbitx != 0 || e.orbity != 0 || e.orbitz != 0;
  }
  apply(e, t, i, n, o, r, a) {
    if (!this.enabled) return;
    const l = r / a, c = this.speedModifier.evaluate(l) * this.speedModifierMultiplier, h = this.x.evaluate(l), d = this.y.evaluate(l), f = this.z.evaluate(l);
    if (this._temp.set(-h, d, f), this._system && this._system.main.simulationSpace === 1 && this._temp.applyQuaternion(this._system.worldQuaternion), this._hasOrbital && this._system?.worldPos) {
      const g = this._temp2.set(i.x, i.y, i.z), _ = this.orbitalXMultiplier, m = this.orbitalYMultiplier, v = this.orbitalZMultiplier, y = c * Math.PI * 2 * 10, x = Math.cos(y * _), I = Math.sin(y * _), O = Math.cos(y * m), k = Math.sin(y * m), E = Math.cos(y * v), z = Math.sin(y * v), D = g.x * (O * E) + g.y * (O * z) + g.z * -k, V = g.x * (I * k * E - x * z) + g.y * (I * k * z + x * E) + g.z * (I * O), q = g.x * (x * k * E + I * z) + g.y * (x * k * z - I * E) + g.z * (x * O), A = this._temp3.set(g.x - D, g.y - V, g.z - q);
      A.normalize(), A.multiplyScalar(0.2 / o * Math.max(this.orbitalXMultiplier, this.orbitalYMultiplier, this.orbitalZMultiplier)), n.x += A.x, n.y += A.y, n.z += A.z;
    }
    n.x += this._temp.x, n.y += this._temp.y, n.z += this._temp.z, n.x *= c, n.y *= c, n.z *= c;
  }
}
C([
  u()
], Ve.prototype, "enabled");
C([
  u()
], Ve.prototype, "space");
C([
  u(Y)
], Ve.prototype, "orbitalX");
C([
  u(Y)
], Ve.prototype, "orbitalY");
C([
  u(Y)
], Ve.prototype, "orbitalZ");
C([
  u()
], Ve.prototype, "orbitalXMultiplier");
C([
  u()
], Ve.prototype, "orbitalYMultiplier");
C([
  u()
], Ve.prototype, "orbitalZMultiplier");
C([
  u()
], Ve.prototype, "orbitalOffsetX");
C([
  u()
], Ve.prototype, "orbitalOffsetY");
C([
  u()
], Ve.prototype, "orbitalOffsetZ");
C([
  u(Y)
], Ve.prototype, "speedModifier");
C([
  u()
], Ve.prototype, "speedModifierMultiplier");
C([
  u(Y)
], Ve.prototype, "x");
C([
  u()
], Ve.prototype, "xMultiplier");
C([
  u(Y)
], Ve.prototype, "y");
C([
  u()
], Ve.prototype, "yMultiplier");
C([
  u(Y)
], Ve.prototype, "z");
C([
  u()
], Ve.prototype, "zMultiplier");
class Xt {
  animation;
  enabled;
  cycleCount;
  frameOverTime;
  frameOverTimeMultiplier;
  numTilesX;
  numTilesY;
  startFrame;
  startFrameMultiplier;
  rowMode;
  rowIndex;
  spriteCount;
  timeMode;
  sampleOnceAtStart() {
    if (this.timeMode === 0)
      switch (this.frameOverTime.mode) {
        case 0:
        case 3:
        case 2:
        case 1:
          return !0;
      }
    return !1;
  }
  getStartIndex() {
    return this.sampleOnceAtStart() ? Math.random() * (this.numTilesX * this.numTilesY) : 0;
  }
  evaluate(e) {
    if (!this.sampleOnceAtStart())
      return this.getIndex(e);
  }
  getIndex(e) {
    const t = this.numTilesX * this.numTilesY;
    e = e * this.cycleCount;
    let i = this.frameOverTime.evaluate(e % 1);
    return i *= this.frameOverTimeMultiplier, i *= t, i = i % t, i = Math.floor(i), i;
  }
}
C([
  u()
], Xt.prototype, "animation");
C([
  u()
], Xt.prototype, "enabled");
C([
  u()
], Xt.prototype, "cycleCount");
C([
  u(Y)
], Xt.prototype, "frameOverTime");
C([
  u()
], Xt.prototype, "frameOverTimeMultiplier");
C([
  u()
], Xt.prototype, "numTilesX");
C([
  u()
], Xt.prototype, "numTilesY");
C([
  u(Y)
], Xt.prototype, "startFrame");
C([
  u()
], Xt.prototype, "startFrameMultiplier");
C([
  u()
], Xt.prototype, "rowMode");
C([
  u()
], Xt.prototype, "rowIndex");
C([
  u()
], Xt.prototype, "spriteCount");
C([
  u()
], Xt.prototype, "timeMode");
class Hn {
  enabled;
  separateAxes;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  evaluate(e, t) {
    return this.enabled ? this.separateAxes ? 0 : this.z.evaluate(e, t) * -1 : 0;
  }
}
C([
  u()
], Hn.prototype, "enabled");
C([
  u()
], Hn.prototype, "separateAxes");
C([
  u(Y)
], Hn.prototype, "x");
C([
  u()
], Hn.prototype, "xMultiplier");
C([
  u(Y)
], Hn.prototype, "y");
C([
  u()
], Hn.prototype, "yMultiplier");
C([
  u(Y)
], Hn.prototype, "z");
C([
  u()
], Hn.prototype, "zMultiplier");
class un {
  enabled;
  range;
  separateAxes;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  evaluate(e, t) {
    if (!this.enabled) return 0;
    if (!this.separateAxes) {
      const i = j.lerp(this.range.x, this.range.y, t);
      return this.z.evaluate(i) * -1;
    }
    return 0;
  }
}
C([
  u()
], un.prototype, "enabled");
C([
  u()
], un.prototype, "range");
C([
  u()
], un.prototype, "separateAxes");
C([
  u(Y)
], un.prototype, "x");
C([
  u()
], un.prototype, "xMultiplier");
C([
  u(Y)
], un.prototype, "y");
C([
  u()
], un.prototype, "yMultiplier");
C([
  u(Y)
], un.prototype, "z");
C([
  u()
], un.prototype, "zMultiplier");
class yt {
  enabled;
  dampen;
  drag;
  dragMultiplier;
  limit;
  limitMultiplier;
  separateAxes;
  limitX;
  limitXMultiplier;
  limitY;
  limitYMultiplier;
  limitZ;
  limitZMultiplier;
  multiplyDragByParticleSize = !1;
  multiplyDragByParticleVelocity = !1;
  space;
  _temp = new b();
  _temp2 = new b();
  apply(e, t, i, n, o, r, a) {
    if (this.enabled) {
      const l = this.limit.evaluate(o) * this.limitMultiplier;
      if (t.length() > l) {
        this._temp.copy(t).normalize().multiplyScalar(l);
        const h = this.dampen * 0.5;
        t.x = j.lerp(t.x, this._temp.x, h), t.y = j.lerp(t.y, this._temp.y, h), t.z = j.lerp(t.z, this._temp.z, h), i.x = j.lerp(i.x, this._temp.x, h), i.y = j.lerp(i.y, this._temp.y, h), i.z = j.lerp(i.z, this._temp.z, h);
      }
    }
  }
}
C([
  u()
], yt.prototype, "enabled");
C([
  u()
], yt.prototype, "dampen");
C([
  u(Y)
], yt.prototype, "drag");
C([
  u()
], yt.prototype, "dragMultiplier");
C([
  u(Y)
], yt.prototype, "limit");
C([
  u()
], yt.prototype, "limitMultiplier");
C([
  u()
], yt.prototype, "separateAxes");
C([
  u(Y)
], yt.prototype, "limitX");
C([
  u()
], yt.prototype, "limitXMultiplier");
C([
  u(Y)
], yt.prototype, "limitY");
C([
  u()
], yt.prototype, "limitYMultiplier");
C([
  u(Y)
], yt.prototype, "limitZ");
C([
  u()
], yt.prototype, "limitZMultiplier");
C([
  u()
], yt.prototype, "multiplyDragByParticleSize");
C([
  u()
], yt.prototype, "multiplyDragByParticleVelocity");
C([
  u()
], yt.prototype, "space");
const Ac = class ew {
  enabled;
  curve;
  curveMultiplier;
  mode;
  clone() {
    const e = new ew();
    return e.enabled = this.enabled, e.curve = this.curve?.clone(), e.curveMultiplier = this.curveMultiplier, e.mode = this.mode, e;
  }
  system;
  get _lastWorldPosition() {
    return this.system._iv_lastWorldPosition || (this.system._iv_lastWorldPosition = new b()), this.system._iv_lastWorldPosition;
  }
  get _velocity() {
    return this.system._iv_velocity || (this.system._iv_velocity = new b()), this.system._iv_velocity;
  }
  _temp = new b();
  _firstUpdate = !0;
  awake(e) {
    this.system = e, this.reset();
  }
  reset() {
    this._firstUpdate = !0;
  }
  update(e) {
    this.enabled && this.system.worldspace !== !1 && (this._firstUpdate ? (this._firstUpdate = !1, this._velocity.set(0, 0, 0), this._lastWorldPosition.copy(this.system.worldPos)) : this._lastWorldPosition && (this._velocity.copy(this.system.worldPos).sub(this._lastWorldPosition).multiplyScalar(1 / this.system.deltaTime), this._lastWorldPosition.copy(this.system.worldPos)));
  }
  // TODO: make work for subsystems
  applyInitial(e) {
    if (this.enabled && this.system.worldspace !== !1 && this.mode === 0) {
      const t = this.curve.evaluate(Math.random(), Math.random());
      this._temp.copy(this._velocity).multiplyScalar(t), e.x += this._temp.x, e.y += this._temp.y, e.z += this._temp.z;
    }
  }
  _frames = 0;
  applyCurrent(e, t, i) {
    if (this.enabled && this.system && this.system.worldspace !== !1 && this.mode === 1) {
      const n = this.curve.evaluate(t, i);
      this._temp.copy(this._velocity).multiplyScalar(n), e.x += this._temp.x, e.y += this._temp.y, e.z += this._temp.z;
    }
  }
};
C([
  u()
], Ac.prototype, "enabled");
C([
  u(Y)
], Ac.prototype, "curve");
C([
  u()
], Ac.prototype, "curveMultiplier");
C([
  u()
], Ac.prototype, "mode");
let tw = Ac;
class Ci {
  enabled;
  range;
  separateAxes;
  size;
  sizeMultiplier;
  x;
  xMultiplier;
  y;
  yMultiplier;
  z;
  zMultiplier;
  evaluate(e, t, i, n) {
    const o = e.length(), r = j.remap(o, this.range.x, this.range.y, 0, 1), a = this.size.evaluate(r, i);
    return n.x *= a, n.y *= a, n.z *= a, n;
  }
}
C([
  u()
], Ci.prototype, "enabled");
C([
  u(J)
], Ci.prototype, "range");
C([
  u()
], Ci.prototype, "separateAxes");
C([
  u(Y)
], Ci.prototype, "size");
C([
  u()
], Ci.prototype, "sizeMultiplier");
C([
  u(Y)
], Ci.prototype, "x");
C([
  u()
], Ci.prototype, "xMultiplier");
C([
  u(Y)
], Ci.prototype, "y");
C([
  u()
], Ci.prototype, "yMultiplier");
C([
  u(Y)
], Ci.prototype, "z");
C([
  u()
], Ci.prototype, "zMultiplier");
class Ic {
  enabled;
  range;
  color;
  evaluate(e, t, i) {
    const n = e.length(), o = j.remap(n, this.range.x, this.range.y, 0, 1), r = this.color.evaluate(o, t);
    i.x *= r.r, i.y *= r.g, i.z *= r.b, "alpha" in r && (i.w *= r.alpha);
  }
}
C([
  u()
], Ic.prototype, "enabled");
C([
  u(J)
], Ic.prototype, "range");
C([
  u(Wa)
], Ic.prototype, "color");
new b(1, 1, 1);
new b(0, 0, 1);
class iw {
  constructor(e, t, i, n) {
    this.system = e, this.particleSystem = t, this.subSystem = i, this.subParticleSystem = n, this.subParticleSystem && this.subParticleSystem && (this.subParticleSystem.onlyUsedByOther = !0);
    const o = 1e3;
    this._circularBuffer = new $i(() => new Hu(), o);
  }
  type = "NeedleParticleSubEmitter";
  emitterType;
  emitterProbability;
  //private matrix_ = new Matrix4();
  q_ = new $();
  v_ = new b();
  v2_ = new b();
  _emitterMatrix = new Hu();
  _circularBuffer;
  clone() {
    throw new Error("Method not implemented.");
  }
  initialize(e) {
    e.emissionState = {
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0
      // matrix: new Matrix4(),
    }, this._emitterMatrix.copy(this.subSystem.matrixWorld).invert().premultiply(this.system.matrixWorld), this._emitterMatrix.setPosition(0, 0, 0), this.emitterType === Qp.Birth && this.run(e);
  }
  update(e, t) {
    this.run(e);
  }
  frameUpdate(e) {
  }
  toJSON() {
  }
  reset() {
  }
  run(e) {
    if (this.subSystem.currentParticles >= this.subSystem.main.maxParticles || !this.subParticleSystem || !e.emissionState || this.emitterProbability && Math.random() > this.emitterProbability)
      return;
    const t = this.system.deltaTime;
    if (this.emitterType === Qp.Death) {
      let n = e.life;
      if (e[Qr] !== void 0 && (n = e[Qr]), !(e.age + t * 1.2 >= n)) return;
      const r = this.subSystem.main.maxParticles - this.subSystem.currentParticles;
      e.emissionState.waitEmiting = r;
    }
    const i = new Hu();
    i.set(
      1,
      0,
      0,
      e.position.x,
      0,
      1,
      0,
      e.position.y,
      0,
      0,
      1,
      e.position.z,
      0,
      0,
      0,
      1
    ), this.particleSystem.worldSpace || i.multiplyMatrices(this._emitterMatrix, i), this.subParticleSystem.emit(t, e.emissionState, i);
  }
}
var aT = Object.defineProperty, ze = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && aT(e, t, n), n;
};
const Xs = w("debugparticles"), lT = w("noprogressive"), cT = w("debugprogressive");
var Qp = /* @__PURE__ */ ((s) => (s[s.Birth = 0] = "Birth", s[s.Collision = 1] = "Collision", s[s.Death = 2] = "Death", s[s.Trigger = 3] = "Trigger", s[s.Manual = 4] = "Manual", s))(Qp || {});
class fn extends T {
  renderMode;
  particleMaterial;
  trailMaterial;
  // @serializable(Mesh)
  particleMesh;
  maxParticleSize;
  minParticleSize;
  velocityScale;
  cameraVelocityScale;
  lengthScale;
  start() {
    if (this.maxParticleSize !== 0.5 && this.minParticleSize !== 0 && L()) {
      const e = `ParticleSystem "${this.name}" has non-default min/max particle size. This may not render correctly. Please set min size to 0 and the max size to 0.5 and use the "StartSize" setting instead`;
      console.warn(e);
    }
  }
  get transparent() {
    return this.particleMaterial?.transparent ?? !1;
  }
  getMaterial(e = !1) {
    let t = e === !0 && this.trailMaterial ? this.trailMaterial : this.particleMaterial;
    if (t) {
      if (t.type === "MeshStandardMaterial") {
        Xs && console.debug("ParticleSystemRenderer.getMaterial: MeshStandardMaterial detected, converting to MeshBasicMaterial. See https://github.com/Alchemist0823/three.quarks/issues/101"), "map" in t && t.map && (t.map.colorSpace = Ss, t.map.premultiplyAlpha = !1);
        const i = new we();
        i.copy(t), e ? this.trailMaterial = i : this.particleMaterial = i;
      }
      t.map && (t.map.colorSpace = Ss, t.map.premultiplyAlpha = !1), e && t.side === co && (t = t.clone(), t.side = Bd, e ? this.trailMaterial = t : this.particleMaterial = t);
    }
    return t && !lT && t._didRequestTextureLOD === void 0 && (t._didRequestTextureLOD = 0, cT && console.log("Load material LOD", t.name), We.assignTextureLOD(t, 0)), t;
  }
  getMesh(e) {
    let t = null;
    if (!t && (this.particleMesh instanceof H && (t = this.particleMesh.geometry), t === null)) {
      t = new Un(1, 1);
      const n = t.attributes.uv;
      for (let o = 0; o < n.count; o++)
        n.setX(o, 1 - n.getX(o));
    }
    return new H(t, this.getMaterial());
  }
}
ze([
  u()
], fn.prototype, "renderMode");
ze([
  u(_e)
], fn.prototype, "particleMaterial");
ze([
  u(_e)
], fn.prototype, "trailMaterial");
ze([
  u()
], fn.prototype, "maxParticleSize");
ze([
  u()
], fn.prototype, "minParticleSize");
ze([
  u()
], fn.prototype, "velocityScale");
ze([
  u()
], fn.prototype, "cameraVelocityScale");
ze([
  u()
], fn.prototype, "lengthScale");
class vh {
  _curve;
  _factor;
  constructor(e, t = 1) {
    this._curve = e, this._factor = t;
  }
  type = "function";
  startGen(e) {
  }
  genValue(e, t) {
    return this._curve.evaluate(t, Math.random()) * this._factor;
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
}
class Og {
  type = "value";
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  startGen(e) {
  }
  system;
  constructor(e) {
    this.system = e;
  }
}
class hT extends Og {
  genValue() {
    return this.system.textureSheetAnimation.getStartIndex();
  }
}
class dT extends Og {
  _lastPosition = new b();
  _lastDistance = 0;
  update() {
    const e = Z(this.system.gameObject);
    this._lastDistance = this._lastPosition.distanceTo(e), this._lastPosition.copy(e);
  }
  genValue() {
    if (!this.system.isPlaying || !this.system.emission.enabled || this.system.currentParticles >= this.system.maxParticles) return 0;
    let e = this.system.emission.rateOverTime.evaluate(this.system.time / this.system.duration, Math.random());
    if (this.system.deltaTime > 0) {
      const n = this.system.emission.rateOverDistance.evaluate(this.system.time / this.system.duration, Math.random());
      let r = this._lastDistance / this.system.deltaTime * n;
      Number.isFinite(r) || (r = 0), e += r;
    }
    const t = this.system.emission.getBurst();
    t > 0 && (e += t / this.system.deltaTime);
    const i = this.system.maxParticles - this.system.currentParticles;
    return j.clamp(e, 0, i / this.system.deltaTime);
  }
}
class uT extends Og {
  genValue() {
    return this.system.isPlaying, 0;
  }
}
class xr {
  system;
  get context() {
    return this.system.context;
  }
  constructor(e) {
    this.type = Object.getPrototypeOf(this).constructor.name || "ParticleSystemBaseBehaviour", e && (this.system = e);
  }
  type;
  initialize(e) {
  }
  update(e, t) {
  }
  frameUpdate(e) {
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  reset() {
  }
}
class fT extends xr {
  type = "NeedleTextureSheet";
  // initialize(_particle: Particle): void {
  //     _particle[$startFrame] = this.system.textureSheetAnimation.getStartIndex();
  // }
  update(e, t) {
    const i = this.system.textureSheetAnimation;
    if (i.enabled) {
      const n = e.age / e.life, o = i.evaluate(n);
      o !== void 0 && (e.uvTile = o);
    }
  }
}
const F_ = Symbol("particleRotation");
class pT extends xr {
  type = "NeedleRotation";
  initialize(e) {
    e[F_] = Math.random();
  }
  update(e, t) {
    if (e.rotation === void 0) return;
    const i = e.age / e.life;
    if (typeof e.rotation == "number" && (this.system.rotationOverLifetime.enabled ? e.rotation += this.system.rotationOverLifetime.evaluate(i, e[F_]) * t : this.system.renderer.renderMode === ls.Billboard && (e.rotation = Math.PI), this.system.rotationBySpeed.enabled)) {
      const n = e.velocity.length();
      e.rotation += this.system.rotationBySpeed.evaluate(i, n) * t;
    }
  }
}
const z_ = Symbol("sizeLerpFactor"), mT = new b();
class gT extends xr {
  type = "NeedleSize";
  _minSize = 0;
  _maxSize = 1;
  initialize(e) {
    e[z_] = Math.random(), this._minSize = this.system.renderer.minParticleSize, this._maxSize = this.system.renderer.maxParticleSize;
  }
  update(e, t) {
    const i = e.age / e.life;
    let n = 1;
    this.system.sizeOverLifetime.enabled && (n *= this.system.sizeOverLifetime.evaluate(i, void 0, e[z_]).x);
    let o = 1;
    this.system.renderer.renderMode !== ls.Mesh && (o = this.system.worldScale.x / this.system.cameraScale);
    const r = G(e.startSize).multiplyScalar(n * o);
    if (e.size.set(r.x, r.y, r.z), this.system.localspace) {
      const a = nw(this.system, mT);
      e.size.x *= a.x, e.size.y *= a.y, e.size.z *= a.z;
    }
  }
}
const Qr = Symbol("particleLife"), Wf = Symbol("trailLifetime"), U_ = Symbol("trailStartLength"), Vf = Symbol("trailWidthRandom");
class yT extends xr {
  type = "NeedleTrail";
  initialize(e) {
    e instanceof Jg && (e[Qr] = e.life, this.system.trails.enabled && this.system.trails.dieWithParticles === !1 && (e[Wf] = this.system.trails.lifetime.evaluate(Math.random(), Math.random()), e.life += e[Wf]), e[U_] = e.length, e[Vf] = Math.random());
  }
  update(e) {
    if (this.system.trails?.enabled && e instanceof Jg) {
      const t = e, i = e.age / e[Qr], n = e.previous.values(), o = e.previous.length;
      for (let r = 0; r < o; r++) {
        const l = n.next().value, c = 1 - r / (o - 1), h = e.size;
        if (h.x <= 0 && !this.system.trails.sizeAffectsWidth) {
          const d = 20 * this.system.trails.widthOverTrail.evaluate(0.5, t[Vf]);
          h.x = d, h.y = d, h.z = d;
        }
        l.size = this.system.trails.getWidth(h.x, i, c, t[Vf]), l.color.copy(e.color), this.system.trails.getColor(l.color, i, c);
      }
      if (e.age > e[Qr]) {
        e.velocity.set(0, 0, 0);
        const r = (e.age - e[Qr]) / e[Wf];
        t.length = j.lerp(e[U_], 0, r);
      }
    }
  }
}
const wh = Symbol("startVelocity"), N_ = Symbol("gravityModifier"), Hf = Symbol("gravitySpeed"), xh = Symbol("velocity lerp factor"), Yp = new b();
class _T extends xr {
  type = "NeedleVelocity";
  _gravityDirection = new b();
  initialize(e) {
    const t = this.system.main.simulationSpeed;
    e.startSpeed = this.system.main.startSpeed.evaluate(Math.random(), Math.random());
    const i = this.system.shape.getDirection(e, e.position);
    e.velocity.x = i.x * e.startSpeed, e.velocity.y = i.y * e.startSpeed, e.velocity.z = i.z * e.startSpeed, this.system.inheritVelocity?.enabled && this.system.inheritVelocity.applyInitial(e.velocity), e[wh] ? e[wh].copy(e.velocity) : e[wh] = e.velocity.clone();
    const n = this.system.main.gravityModifier.evaluate(Math.random(), Math.random());
    e[N_] = n * t, e[Hf] = n * t * 0.5, e[xh] = Math.random(), this.system.velocityOverLifetime?.init(e), this._gravityDirection.set(0, -1, 0), this.system.main.simulationSpace === dc.Local && this._gravityDirection.applyQuaternion(this.system.worldQuaternionInverted).normalize();
  }
  update(e, t) {
    const i = e[wh], n = e[N_];
    if (n !== 0) {
      const d = n * e[Hf];
      Yp.copy(this._gravityDirection).multiplyScalar(d), e[Hf] += t * 0.05, i.add(Yp);
    }
    e.velocity.copy(i);
    const o = e.age / e.life;
    this.system.inheritVelocity?.enabled && this.system.inheritVelocity.applyCurrent(e.velocity, o, e[xh]);
    const r = this.system.noise;
    r.enabled && r.apply(0, e.position, e.velocity, t, e.age, e.life);
    const a = this.system.sizeBySpeed;
    a?.enabled && (e.size = a.evaluate(e.velocity, o, e[xh], e.size));
    const l = this.system.colorBySpeed;
    l?.enabled && l.evaluate(e.velocity, e[xh], e.color);
    const c = this.system.velocityOverLifetime;
    c.enabled && c.apply(e, 0, e.position, e.velocity, t, e.age, e.life);
    const h = this.system.limitVelocityOverLifetime;
    if (h.enabled && h.apply(e.position, i, e.velocity, e.size, o, t, 1), this.system.worldspace) {
      const d = this.system.worldScale;
      e.velocity.x *= d.x, e.velocity.y *= d.y, e.velocity.z *= d.z;
    }
  }
}
const $_ = Symbol("colorLerpFactor"), W_ = new oe(1, 1, 1, 1), jo = new oe(1, 1, 1, 1);
class bT extends xr {
  type = "NeedleColor";
  initialize(e) {
  }
  _init(e) {
    const t = this.system.renderer.particleMaterial;
    jo.copy(this.system.main.startColor.evaluate(Math.random())), t?.color && (W_.copy(t.color), jo.multiply(W_)), jo.convertLinearToSRGB(), e.startColor.set(jo.r, jo.g, jo.b, jo.alpha), e.color.copy(e.startColor), e[$_] = Math.random();
  }
  update(e, t) {
    if (e.age === 0 && this._init(e), this.system.colorOverLifetime.enabled) {
      const i = e.age / e.life, n = this.system.colorOverLifetime.color.evaluate(i, e[$_]);
      e.color.set(n.r, n.g, n.b, "alpha" in n ? n.alpha : 1).multiply(e.startColor);
    } else
      e.color.copy(e.startColor);
  }
}
class vT {
  system;
  emission;
  get anim() {
    return this.system.textureSheetAnimation;
  }
  constructor(e) {
    this.system = e, this.emission = new dT(this.system);
  }
  get prewarm() {
    return !1;
  }
  // force disable three.quark prewarm, we have our own!
  get material() {
    return this.system.renderer.getMaterial(this.system.trails.enabled);
  }
  get layers() {
    return this.system.gameObject.layers;
  }
  update() {
    this.emission.update();
  }
  autoDestroy;
  get looping() {
    return this.system.main.loop;
  }
  get duration() {
    return this.system.duration;
  }
  get shape() {
    return this.system.shape;
  }
  get startLife() {
    return new vh(this.system.main.startLifetime);
  }
  get startSpeed() {
    return new vh(this.system.main.startSpeed);
  }
  get startRotation() {
    return new vh(this.system.main.startRotation);
  }
  get startSize() {
    return new vh(this.system.main.startSize);
  }
  startLength;
  /** start length is for trails */
  get startColor() {
    return new IS(new LS(1, 1, 1, 1));
  }
  get emissionOverTime() {
    return this.emission;
  }
  /** this is not supported yet */
  get emissionOverDistance() {
    return new uT(this.system);
  }
  /** not used - burst is controled via emissionOverTime */
  emissionBursts;
  onlyUsedByOther;
  behaviors = [];
  get instancingGeometry() {
    return this.system.renderer.getMesh(this.system.renderer.renderMode).geometry;
  }
  get renderMode() {
    if (this.system.trails.enabled === !0)
      return as.Trail;
    switch (this.system.renderer.renderMode) {
      case ls.Billboard:
        return as.BillBoard;
      case ls.Stretch:
        return as.StretchedBillBoard;
      case ls.HorizontalBillboard:
        return as.HorizontalBillBoard;
      case ls.VerticalBillboard:
        return as.VerticalBillBoard;
      case ls.Mesh:
        return as.Mesh;
    }
    return as.BillBoard;
  }
  rendererEmitterSettings = {
    startLength: new DS(220),
    followLocalOrigin: !1
  };
  get speedFactor() {
    let e = this.system.main.simulationSpeed;
    return this.system.renderer?.renderMode === ls.Stretch && (e *= this.system.renderer.velocityScale ?? 1), e;
  }
  flatWhiteTexture;
  clonedTexture = { original: void 0, clone: void 0 };
  get texture() {
    const e = this.material;
    if (e && e.map) {
      const t = e.map;
      if (this.clonedTexture.original !== t || !this.clonedTexture.clone) {
        const i = t.clone();
        i.premultiplyAlpha = !1, i.colorSpace = Ss, this.clonedTexture.original = t, this.clonedTexture.clone = i;
      }
      return this.clonedTexture.clone;
    }
    return this.flatWhiteTexture || (this.flatWhiteTexture = zm(new oe(1, 1, 1, 1), 1)), this.flatWhiteTexture;
  }
  get startTileIndex() {
    return new hT(this.system);
  }
  get uTileCount() {
    return this.anim.enabled ? this.anim?.numTilesX : void 0;
  }
  get vTileCount() {
    return this.anim.enabled ? this.anim?.numTilesY : void 0;
  }
  get renderOrder() {
    return 1;
  }
  get blending() {
    return this.system.renderer.particleMaterial?.blending ?? qx;
  }
  get transparent() {
    return this.system.renderer.transparent;
  }
  get worldSpace() {
    return this.system.main.simulationSpace === dc.World;
  }
}
class wT {
  burstParticleIndex = 0;
  burstParticleCount = 0;
  isBursting = !1;
  travelDistance = 0;
  previousWorldPos;
  burstIndex = 0;
  burstWaveIndex = 0;
  time = 0;
  waitEmiting = 0;
}
const Dt = class $h extends T {
  play(e = !1) {
    e && S.foreachComponent(this.gameObject, (t) => {
      t instanceof $h && t !== this && t.play(!1);
    }, !0), this._isPlaying = !0, this._particleSystem && (this._particleSystem.emissionState.time = 0, this._particleSystem.emitEnded = !1), this.emission?.reset();
  }
  pause(e = !0) {
    e && S.foreachComponent(this.gameObject, (t) => {
      t instanceof $h && t !== this && t.pause(!1);
    }, !0), this._isPlaying = !1;
  }
  /** clear=true removes all emitted particles */
  stop(e = !0, t = !1) {
    e && S.foreachComponent(this.gameObject, (i) => {
      i instanceof $h && i !== this && i.stop(!1, t);
    }, !0), this._isPlaying = !1, this._time = 0, t && this.reset();
  }
  /** remove emitted particles and reset time */
  reset() {
    this._time = 0, this._particleSystem && (this._particleSystem.particleNum = 0, this._particleSystem.emissionState.time = 0, this._particleSystem.emitEnded = !1, this.emission?.reset());
  }
  _state;
  emit(e) {
    if (this._particleSystem) {
      this.onUpdate(), e = Math.min(e, this.maxParticles - this.currentParticles), this._state || (this._state = new wT()), this._state.waitEmiting = e, this._state.time = 0;
      const t = this._particleSystem.emitEnded;
      this._particleSystem.emitEnded = !1, this._particleSystem.emit(this.deltaTime, this._state, this._particleSystem.emitter.matrixWorld), this._particleSystem.emitEnded = t;
    }
  }
  get playOnAwake() {
    return this.main.playOnAwake;
  }
  set playOnAwake(e) {
    this.main.playOnAwake = e;
  }
  colorOverLifetime;
  main;
  emission;
  sizeOverLifetime;
  shape;
  noise;
  trails;
  velocityOverLifetime;
  limitVelocityOverLifetime;
  inheritVelocity;
  colorBySpeed;
  textureSheetAnimation;
  rotationOverLifetime;
  rotationBySpeed;
  sizeBySpeed;
  get renderer() {
    return this._renderer;
  }
  get isPlaying() {
    return this._isPlaying;
  }
  get currentParticles() {
    return this._particleSystem?.particleNum ?? 0;
  }
  get maxParticles() {
    return this.main.maxParticles;
  }
  get time() {
    return this._time;
  }
  get duration() {
    return this.main.duration;
  }
  get deltaTime() {
    return this.context.time.deltaTime * this.main.simulationSpeed;
  }
  get scale() {
    return this.gameObject.scale.x;
  }
  get cameraScale() {
    return this._cameraScale;
  }
  _cameraScale = 1;
  get container() {
    return this._container;
  }
  get worldspace() {
    return this.main.simulationSpace === dc.World;
  }
  get localspace() {
    return this.main.simulationSpace === dc.Local;
  }
  __worldQuaternion = new $();
  get worldQuaternion() {
    return this.__worldQuaternion;
  }
  _worldQuaternionInverted = new $();
  get worldQuaternionInverted() {
    return this._worldQuaternionInverted;
  }
  _worldScale = new b();
  get worldScale() {
    return this._worldScale;
  }
  _worldPositionFrame = -1;
  _worldPos = new b();
  get worldPos() {
    return this._worldPositionFrame !== this.context.time.frame && (this._worldPositionFrame = this.context.time.frame, Z(this.gameObject, this._worldPos)), this._worldPos;
  }
  get matrixWorld() {
    return this._container.matrixWorld;
  }
  get isSubsystem() {
    return this._isUsedAsSubsystem;
  }
  /** Add a custom quarks behaviour to the particle system.   
   * You can add a quarks.Behaviour type or derive from {@link ParticleSystemBaseBehaviour}  
   * @link https://github.com/Alchemist0823/three.quarks    
   * @example
   * ```typescript
   * class MyBehaviour extends ParticleSystemBaseBehaviour {
   *    initialize(particle: Particle) {
   *       // initialize the particle
   *   }
   *    update(particle: Particle, delta: number) {  
   *        // do something with the particle
   *   }
   * }
   * 
   * const system = gameObject.getComponent(ParticleSystem);
   * system.addBehaviour(new MyBehaviour());
   * ```
  */
  addBehaviour(e) {
    return this._particleSystem ? (e instanceof xr && (e.system = this), Xs && console.debug("Add custom ParticleSystem Behaviour", e), this._particleSystem.addBehavior(e), !0) : !1;
  }
  /** Remove a custom quarks behaviour from the particle system. **/
  removeBehaviour(e) {
    if (!this._particleSystem)
      return !1;
    const t = this._particleSystem.behaviors, i = t.indexOf(e);
    return i !== -1 && ((L() || Xs) && console.debug("Remove custom ParticleSystem Behaviour", i, e), t.splice(i, 1)), !0;
  }
  /** Removes all behaviours from the particle system  
   * **Note:** this will also remove the default behaviours like SizeBehaviour, ColorBehaviour etc.
   */
  removeAllBehaviours() {
    return this._particleSystem ? (this._particleSystem.behaviors.length = 0, !0) : !1;
  }
  /** Get the underlying three.quarks particle system behaviours. This can be used to fully customize the behaviour of the particles. */
  get behaviours() {
    return this._particleSystem ? this._particleSystem.behaviors : null;
  }
  /** Get access to the underlying quarks particle system if you need more control  
   * @link https://github.com/Alchemist0823/three.quarks
   */
  get particleSystem() {
    return this._particleSystem ?? null;
  }
  _renderer;
  _batchSystem;
  _particleSystem;
  _interface;
  // private _system!: System;
  // private _emitter: Emitter;
  // private _size!: SizeBehaviour;
  _container;
  _time = 0;
  _isPlaying = !0;
  _isUsedAsSubsystem = !1;
  _didPreWarm = !1;
  /** called from deserialization */
  set bursts(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      if (!(i instanceof Xp)) {
        const n = new Xp();
        ya(n, i), e[t] = n;
      }
    }
    this._bursts = e;
  }
  _bursts;
  /** called from deserialization */
  set subEmitterSystems(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      if (!(i instanceof Kp)) {
        const n = new Kp();
        ya(n, i), e[t] = n;
      }
    }
    Xs && e.length > 0 && console.log("SubEmitters: ", e, this), this._subEmitterSystems = e;
  }
  _subEmitterSystems;
  /** @internal */
  onAfterDeserialize(e) {
    if (this._subEmitterSystems && Array.isArray(this._subEmitterSystems))
      for (const t of this._subEmitterSystems)
        t._deserialize(this.context, this.gameObject);
  }
  /** @internal */
  awake() {
    if (this._worldPositionFrame = -1, this._renderer = this.gameObject.getComponent(fn), !this.main)
      throw new Error("Not Supported: ParticleSystem needs a serialized MainModule. Creating new particle systems at runtime is currently not supported.");
    this._container = new M(), this._container.matrixAutoUpdate = !1, this.context.scene.add(this._container), this._batchSystem = new ES(), this._batchSystem.name = this.gameObject.name, this._container.add(this._batchSystem), this._interface = new vT(this), this._particleSystem = new AS(this._interface), this._particleSystem.addBehavior(new gT(this)), this._particleSystem.addBehavior(new bT(this)), this._particleSystem.addBehavior(new fT(this)), this._particleSystem.addBehavior(new pT(this)), this._particleSystem.addBehavior(new _T(this)), this._particleSystem.addBehavior(new yT(this)), this._batchSystem.addSystem(this._particleSystem);
    const e = this._particleSystem.emitter;
    this.context.scene.add(e), this.inheritVelocity.system && this.inheritVelocity.system !== this && (this.inheritVelocity = this.inheritVelocity.clone()), this.inheritVelocity.awake(this), Xs && (console.log(this), this.gameObject.add(new mi(1)));
  }
  /** @internal */
  start() {
    this.addSubParticleSystems(), this.updateLayers(), this.renderer.particleMesh instanceof H && this._interface.renderMode == as.Mesh && We.assignMeshLOD(this.renderer.particleMesh, 0).then((e) => {
      e && this.particleSystem && this._interface.renderMode == as.Mesh && (this.particleSystem.instancingGeometry = e);
    });
  }
  /** @internal */
  onDestroy() {
    this._container?.removeFromParent(), this._batchSystem?.removeFromParent(), this._particleSystem?.emitter.removeFromParent(), this._particleSystem?.dispose();
  }
  /** @internal */
  onEnable() {
    this.main && (this.inheritVelocity && (this.inheritVelocity.system = this), this._batchSystem && (this._batchSystem.visible = !0), this.playOnAwake && this.play(), this._isPlaying = this.playOnAwake);
  }
  onDisable() {
    this._batchSystem && (this._batchSystem.visible = !1);
  }
  /** @internal */
  onBeforeRender() {
    this.main && (this._didPreWarm === !1 && this.main?.prewarm === !0 && (this._didPreWarm = !0, this.preWarm()), this.onUpdate(), this.onSimulate(this.deltaTime));
  }
  preWarm() {
    if (!this.emission?.enabled || this.emission.rateOverTime.getMax() <= 0) return;
    const t = 1 / 60, i = this.main.duration, n = this.main.startLifetime.getMax(), r = Math.min(Math.max(i, n) / Math.max(0.01, this.main.simulationSpeed), 1e3), a = Math.ceil(r / t), l = Date.now();
    Xs && console.log(`Particles ${this.name} - Prewarm for ${a} frames (${r} sec). Duration: ${i}, Lifetime: ${n}`);
    for (let c = 0; c < a && !(this.currentParticles >= this.maxParticles); c++) {
      const h = Date.now() - l;
      if (h > 2e3) {
        console.warn(`Particles ${this.name} - Prewarm took too long. Aborting: ${h}`);
        break;
      }
      this.onUpdate(), this.onSimulate(t);
    }
  }
  _lastBatchesCount = -1;
  onSimulate(e) {
    if (this._batchSystem) {
      let t = this.context.time.frameCount % 60 === 0;
      this._lastBatchesCount !== this._batchSystem.batches.length && (this._lastBatchesCount = this._batchSystem.batches.length, t = !0), t && this.updateLayers(), this._batchSystem.update(e);
    }
    this._time += e, this._time > this.duration && (this._time = 0);
  }
  updateLayers() {
    if (this._batchSystem)
      for (let e = 0; e < this._batchSystem.batches.length; e++) {
        const t = this._batchSystem.batches[e];
        t.layers.disableAll();
        const i = this.layer;
        t.layers.mask = 1 << i;
      }
  }
  // private lastMaterialVersion: number = -1;
  onUpdate() {
    if (this._bursts && (this.emission.bursts = this._bursts, delete this._bursts), !this._isPlaying) return;
    const e = this.context.mainCamera;
    if (e) {
      const n = $e(e);
      this._cameraScale = n.x;
    }
    const t = !this.worldspace, i = this.gameObject;
    if (be(i, this.__worldQuaternion), this._worldQuaternionInverted.copy(this.__worldQuaternion).invert(), $e(this.gameObject, this._worldScale), t && this._container && this.gameObject?.parent) {
      const n = nw(this, Yp);
      this._container.matrix.makeScale(n.x, n.y, n.z), this._container.matrix.makeRotationFromQuaternion(this.__worldQuaternion), this._container.matrix.setPosition(this.worldPos), this._container.matrix.scale(this.gameObject.scale);
    }
    this.emission.system = this, this._interface.update(), this.shape.onUpdate(this, this.context, this.main.simulationSpace, this.gameObject), this.noise.update(this.context), this.inheritVelocity?.update(this.context), this.velocityOverLifetime.update(this);
  }
  addSubParticleSystems() {
    if (this._subEmitterSystems && this._particleSystem)
      for (const e of this._subEmitterSystems) {
        e.particleSystem && (e.particleSystem.__internalAwake ? e.particleSystem.__internalAwake() : L() && console.warn("SubParticleSystem serialization issue(?)", e.particleSystem, e));
        const t = e.particleSystem?._particleSystem;
        if (t) {
          e.particleSystem._isUsedAsSubsystem = !0;
          const i = new iw(this, this._particleSystem, e.particleSystem, t);
          i.emitterType = e.type, i.emitterProbability = e.emitProbability, this._particleSystem.addBehavior(i);
        } else Xs && console.warn("Could not add SubParticleSystem", e, this);
      }
  }
};
ze([
  u(Pg)
], Dt.prototype, "colorOverLifetime");
ze([
  u(qt)
], Dt.prototype, "main");
ze([
  u(So)
], Dt.prototype, "emission");
ze([
  u(Va)
], Dt.prototype, "sizeOverLifetime");
ze([
  u(Jv)
], Dt.prototype, "shape");
ze([
  u(ve)
], Dt.prototype, "noise");
ze([
  u(Ne)
], Dt.prototype, "trails");
ze([
  u(Ve)
], Dt.prototype, "velocityOverLifetime");
ze([
  u(yt)
], Dt.prototype, "limitVelocityOverLifetime");
ze([
  u(tw)
], Dt.prototype, "inheritVelocity");
ze([
  u(Ic)
], Dt.prototype, "colorBySpeed");
ze([
  u(Xt)
], Dt.prototype, "textureSheetAnimation");
ze([
  u(Hn)
], Dt.prototype, "rotationOverLifetime");
ze([
  u(un)
], Dt.prototype, "rotationBySpeed");
ze([
  u(Ci)
], Dt.prototype, "sizeBySpeed");
let wd = Dt;
class Kp {
  particleSystem;
  emitProbability = 1;
  properties;
  type;
  _deserialize(e, t) {
    const i = this.particleSystem;
    if (i instanceof wd) return;
    let n = "";
    i && typeof i.guid == "string" && (n = i.guid, this.particleSystem = S.findByGuid(n, t)), Xs && !(this.particleSystem instanceof wd) && console.warn("Could not find particle system for sub emitter", n, t, this);
  }
}
function nw(s, e) {
  if (e.set(1, 1, 1), s.gameObject.parent && s.localspace)
    switch (s.main.scalingMode) {
      case qp.Local:
        e = $e(s.gameObject.parent, e), e.x = 1 / e.x, e.y = 1 / e.y, e.z = 1 / e.z;
        break;
      default:
        if (!s.unsupported_scaling_mode) {
          s.unsupported_scaling_mode = !0;
          const t = "ParticleSystem scale mode " + qp[s.main.scalingMode] + " is not supported";
          L() && ge(t), console.warn(t, s.name, s);
        }
        e = $e(s.gameObject, e);
        break;
    }
  return e;
}
class uc extends T {
  _didAssignPlayerColor = !1;
  onEnable() {
    this.context.connection.beginListen(ee.JoinedRoom, this.tryAssignColor), this._didAssignPlayerColor || this.startCoroutine(this.waitForConnection());
  }
  onDisable() {
    this.context.connection.stopListen(ee.JoinedRoom, this.tryAssignColor);
  }
  *waitForConnection() {
    for (; !this.destroyed && this.activeAndEnabled && (yield T0(0.2), !this.tryAssignColor()); )
      ;
  }
  tryAssignColor = () => {
    const e = S.getComponentInParent(this.gameObject, Mn);
    if (e && e.owner)
      return this._didAssignPlayerColor = !0, this.assignUserColor(e.owner), !0;
    const t = S.getComponentInParent(this.gameObject, je);
    return t?.connectionId ? (this._didAssignPlayerColor = !0, this.assignUserColor(t.connectionId), !0) : !1;
  };
  assignUserColor(e) {
    const t = uc.hashCode(e), i = uc.colorFromHashCode(t);
    if (this.gameObject.type === "Mesh") {
      const n = this.gameObject;
      this.assignColor(i, e, n);
    } else if (this.gameObject.children)
      for (const n of this.gameObject.children) {
        const o = n;
        o.material && o.material.color && this.assignColor(i, e, o);
      }
  }
  assignColor(e, t, i) {
    let n = i.material;
    n && (n._playerMaterial !== t && (n = n.clone(), n._playerMaterial = t, i.material = n), n.color = e);
  }
  static hashCode(e) {
    var t = 0, i, n;
    if (e.length === 0) return t;
    for (i = 0; i < e.length; i++)
      n = e.charCodeAt(i), t = (t << 5) - t + n, t |= 0;
    return t;
  }
  static colorFromHashCode(e) {
    const t = (e & 16711680) >> 16, i = (e & 65280) >> 8, n = e & 255;
    return new se(t / 255, i / 255, n / 255);
  }
}
const Ll = w("debugpost");
let Zp = null;
function xT(s) {
  Zp = s;
}
function sw(s) {
  let e = s.gameObject;
  for (; e; ) {
    for (const t of Fm(e))
      if (t.isPostProcessingManager === !0)
        return t;
    e = e.parent;
  }
  return null;
}
function ST(s) {
  let e = sw(s);
  if (!e)
    if (Zp) {
      Ll && console.warn("Adding postprocessing manager to the scene.");
      const t = s.scene;
      e = An(t, Zp);
    } else
      L() && console.warn("No post processing manager found");
  return e;
}
const lt = {
  /** Used to render effects at the start of the post-processing chain */
  AT_START: -1e4,
  NormalPass: 0,
  DepthDownsamplingPass: 10,
  SSAO: 20,
  SMAA: 30,
  TiltShift: 40,
  DepthOfField: 50,
  ChromaticAberration: 60,
  Bloom: 70,
  Vignette: 80,
  Pixelation: 90,
  ToneMapping: 100,
  HueSaturation: 110,
  BrightnessContrast: 120,
  Sharpening: 130,
  /** Used to render effects at the end of the post-processing chain, e.g. for final adjustments or overlays. */
  AT_END: 1e4
};
let Ge = null;
function CT(s) {
  Ll === "verbose" && console.debug("Before ordering effects", [...s]), Ge || (Ge = /* @__PURE__ */ new Map(), Ge.set(R.POSTPROCESSING.MODULE.NormalPass, lt.NormalPass), Ge.set(R.POSTPROCESSING.MODULE.DepthDownsamplingPass, lt.DepthDownsamplingPass), Ge.set(R.POSTPROCESSING.MODULE.SMAAEffect, lt.SMAA), Ge.set(R.POSTPROCESSING.MODULE.SSAOEffect, lt.SSAO), Ge.set(R.POSTPROCESSING_AO.MODULE.N8AOPostPass, lt.SSAO), Ge.set(R.POSTPROCESSING_AO.MODULE.N8AOPass, lt.SSAO), Ge.set(R.POSTPROCESSING.MODULE.TiltShiftEffect, lt.TiltShift), Ge.set(R.POSTPROCESSING.MODULE.DepthOfFieldEffect, lt.DepthOfField), Ge.set(R.POSTPROCESSING.MODULE.ChromaticAberrationEffect, lt.ChromaticAberration), Ge.set(R.POSTPROCESSING.MODULE.BloomEffect, lt.Bloom), Ge.set(R.POSTPROCESSING.MODULE.SelectiveBloomEffect, lt.Bloom), Ge.set(R.POSTPROCESSING.MODULE.VignetteEffect, lt.Vignette), Ge.set(R.POSTPROCESSING.MODULE.PixelationEffect, lt.Pixelation), Ge.set(R.POSTPROCESSING.MODULE.ToneMappingEffect, lt.ToneMapping), Ge.set(R.POSTPROCESSING.MODULE.HueSaturationEffect, lt.HueSaturation), Ge.set(R.POSTPROCESSING.MODULE.BrightnessContrastEffect, lt.BrightnessContrast)), s.sort((e, t) => {
    const i = typeof e.priority == "number" ? e.priority : Ge.get(e.effect.constructor) ?? Number.NEGATIVE_INFINITY, n = typeof t.priority == "number" ? t.priority : Ge.get(t.effect.constructor) ?? Number.NEGATIVE_INFINITY;
    return i === Number.NEGATIVE_INFINITY ? (Ll && console.warn("Unknown effect found: ", e.constructor.name, e), 1) : n === Number.NEGATIVE_INFINITY ? (Ll && console.warn("Unknown effect found: ", t.constructor.name, t), -1) : i - n;
  }), Ll === "verbose" && console.debug("After ordering effects", [...s]);
}
var PT = Object.defineProperty, OT = Object.getOwnPropertyDescriptor, ow = (s, e, t, i) => {
  for (var n = OT(e, t), o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && PT(e, t, n), n;
};
const kT = w("debugpost");
class B {
  isVolumeParameter = !0;
  constructor(e) {
    e !== void 0 && this.initialize(e);
  }
  _isInitialized = !1;
  get isInitialized() {
    return this._isInitialized;
  }
  initialize(e) {
    e !== void 0 && (this._value = e, this._defaultValue = e, this._valueRaw = e, this._isInitialized = !0);
  }
  get overrideState() {
    return this._active;
  }
  set overrideState(e) {
    if (this._active === e) return;
    this._active = e;
    const t = e ? this._valueRaw : this._defaultValue;
    this.processValue(t, !0);
  }
  _active = !0;
  get value() {
    return this._valueRaw;
  }
  set value(e) {
    this.isInitialized || this.initialize(e), this.processValue(e, !1);
  }
  _value;
  _valueRaw;
  set defaultValue(e) {
    this._defaultValue = e;
  }
  _defaultValue = void 0;
  /** enforce the value to be set and onValueChanged to be called if assigned */
  __init() {
    this.processValue(this._valueRaw, !0);
  }
  /** called to modify a changing value before it is saved */
  valueProcessor;
  /** called when a value has changed (with the final value) */
  onValueChanged;
  processValue(e, t) {
    if (e == null || !t && this.testIfValueChanged(e) === !1)
      return;
    const i = this._value;
    kT && typeof i == "number" && typeof e == "number" && (i?.toFixed(4), e?.toFixed(4)), !this._active && this._defaultValue !== void 0 ? (this._value = this._defaultValue, e = this._defaultValue, this._valueRaw = e) : (this._valueRaw = e, this._active && this.valueProcessor && (e = this.valueProcessor(e)), this._value = e), this.onValueChanged && this.onValueChanged(e, i, this);
  }
  testIfValueChanged(e) {
    return this._valueRaw !== e;
  }
}
ow([
  u()
], B.prototype, "overrideState");
ow([
  u()
], B.prototype, "value");
class MT extends Xi {
  constructor() {
    super([B]);
  }
  onSerialize(e, t) {
  }
  onDeserialize(e, t) {
    const i = t.target, n = t.path;
    let o;
    if (i && n && (o = i[n]), (typeof o != "object" || typeof o == "object" && o.isVolumeParameter !== !0) && (o = new B()), typeof e == "object" && "value" in e) {
      const r = e.value;
      o.initialize(r), o.overrideState = e.overrideState;
    } else
      o.value = e;
    return o;
  }
}
new MT();
var RT = Object.defineProperty, TT = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && RT(e, t, n), n;
};
const Gf = w("debugpost");
class ot extends T {
  get isPostProcessingEffect() {
    return !0;
  }
  /**
   * The order of this effect. The higher the order the later the effect will be applied in the post processing stack.
   * This can be used to control the order of effects when multiple effects are applied.  
   * It is recommended to use the PostProcessingEffectOrder constant to order your custom effects before or after built-in effects.  
   * @default `undefined` (no specific order set, will be applied in the order of registration)
   * 
   * @example
   * ```typescript
   * import { PostProcessingEffectOrder } from "@needle-tools/engine"
   * 
   * export class MyCustomEffect extends PostProcessingEffect {
   *    order: PostProcessingEffectOrder.Bloom + 1; // render after bloom
   *    // This will ensure that the effect is applied after the bloom effect in the post processing stack.
   *    // ... the rest of your effect code
   * }
   * ```
   */
  order = void 0;
  constructor(e = void 0) {
    if (super(), e)
      for (const t of Object.keys(e)) {
        const i = e[t], n = this[t];
        n instanceof B ? n.initialize(i) : n !== void 0 && (this[t] = i);
      }
  }
  active = !0;
  _manager = null;
  onEnable() {
    super.onEnable(), Gf && console.warn("Enable", this.constructor.name + (this.__internalDidAwakeAndStart ? "" : " (awake)")), this.__internalDidAwakeAndStart && (this.active = !0), this.onEffectEnabled();
  }
  onDisable() {
    super.onDisable(), Gf && console.warn("Disable", this.constructor.name), this._manager?.removeEffect(this), this.active = !1;
  }
  onEffectEnabled(e) {
    e && e.isPostProcessingManager === !0 ? this._manager = e : this._manager || (this._manager = ST(this)), this._manager.addEffect(this), this._manager.dirty = !0;
  }
  /** override to initialize bindings on parameters */
  init() {
  }
  /** previously created effect (if any) */
  _result;
  _postprocessingContext = null;
  get postprocessingContext() {
    return this._postprocessingContext;
  }
  /** Apply post settings. Make sure to call super.apply() if you also create an effect */
  apply(e) {
    return this._postprocessingContext = e, this._result || (this.initParameters(), this._result = this.onCreateEffect?.call(this)), this._result && this.initParameters(), this._result;
  }
  /** Reset previously set values (e.g. when adjusting settings on the renderer like Tonemapping) */
  unapply() {
  }
  dispose() {
    Gf && console.warn("DISPOSE", this), this._result && (Array.isArray(this._result) ? this._result.forEach((e) => e.dispose()) : this._result.dispose()), this._result = void 0;
  }
  initParameters() {
    const e = Object.keys(this);
    for (const t of e) {
      const i = this[t];
      i instanceof B && i.__init();
    }
  }
  // TODO this is currently not used for post processing effects that are part of Volume stacks,
  // since these handle that already.
  onEditorModification(e) {
    const t = e.propertyName;
    if (this[t] instanceof B) {
      const i = e.value;
      return this[t].value = i, !0;
    }
  }
}
TT([
  u()
], ot.prototype, "active");
var ET = Object.defineProperty, AT = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && ET(e, t, n), n;
};
const IT = w("debugpost"), Jp = {};
function pn(s, e) {
  Jp[s] = e;
}
function LT(s) {
  return s.__type in Jp ? Jp[s.__type] : (IT && s.__type && console.warn("Unknown postprocessing type", s.__type, s), ot);
}
class kg {
  components = [];
  /**
   * call init on all components 
   * @hidden
   **/
  __init(e) {
    this.components?.forEach((t) => {
      t.gameObject === void 0 && e.gameObject.addComponent(t), t.init();
    });
  }
  addEffect(e) {
    this.components.push(e);
  }
  removeEffect(e) {
    const t = this.components.indexOf(e);
    t >= 0 && this.components.splice(t, 1);
  }
}
AT([
  Ma([(s) => LT(s), ot])
], kg.prototype, "components");
var DT = Object.defineProperty, jT = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && DT(e, t, n), n;
};
const BT = w("debugpost");
class Cu extends ot {
  get typeName() {
    return "Antialiasing";
  }
  preset = new B(2);
  // 2 is HIGH: https://github.com/pmndrs/postprocessing/blob/main/src/enums/SMAAPreset.js#L14
  onCreateEffect() {
    const e = new R.POSTPROCESSING.MODULE.SMAAEffect({
      preset: this.preset?.value ?? R.POSTPROCESSING.MODULE.SMAAPreset.HIGH,
      edgeDetectionMode: R.POSTPROCESSING.MODULE.EdgeDetectionMode.LUMA
      // Keep predication mode disabled (default) since it looks better
      // predicationMode: MODULES.POSTPROCESSING.MODULE.PredicationMode.DEPTH,
    });
    return this.preset.onValueChanged = (t) => {
      BT && console.log("Antialiasing preset changed to", t), e.applyPreset(t);
    }, e;
  }
}
jT([
  u(B)
], Cu.prototype, "preset");
pn("Antialiasing", Cu);
var FT = Object.defineProperty, Mg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && FT(e, t, n), n;
};
const Pu = class rw extends ot {
  /** Whether to use selective bloom by default */
  static useSelectiveBloom = !1;
  get typeName() {
    return "Bloom";
  }
  threshold = new B(0.9);
  intensity = new B(1);
  scatter = new B(0.7);
  /**
   * Set to true to use selective bloom when the effect gets created.
   * @default false
   */
  selectiveBloom;
  init() {
    this.threshold.valueProcessor = (e) => e, this.intensity.valueProcessor = (e) => e, this.scatter.valueProcessor = (e) => e;
  }
  onCreateEffect() {
    let e;
    if (this.selectiveBloom == null && (this.selectiveBloom = rw.useSelectiveBloom), this.selectiveBloom) {
      const t = e = new R.POSTPROCESSING.MODULE.SelectiveBloomEffect(this.context.scene, this.context.mainCamera, {
        blendFunction: R.POSTPROCESSING.MODULE.BlendFunction.ADD,
        mipmapBlur: !0,
        luminanceThreshold: this.threshold.value,
        luminanceSmoothing: this.scatter.value,
        radius: 0.85,
        // default value
        intensity: this.intensity.value
      });
      t.inverted = !0;
    } else
      e = new R.POSTPROCESSING.MODULE.BloomEffect({
        blendFunction: R.POSTPROCESSING.MODULE.BlendFunction.ADD,
        mipmapBlur: !0,
        luminanceThreshold: this.threshold.value,
        luminanceSmoothing: this.scatter.value,
        radius: 0.85,
        // default value
        intensity: this.intensity.value
      });
    return this.intensity.onValueChanged = (t) => {
      e.intensity = t;
    }, this.threshold.onValueChanged = (t) => {
      e.luminanceMaterial.threshold = Math.pow(t, 2.2);
    }, this.scatter.onValueChanged = (t) => {
      e.luminancePass.enabled = !0, e.luminanceMaterial.smoothing = t, e.mipmapBlurPass && (e.mipmapBlurPass.radius = gs.lerp(0.1, 0.9, t));
    }, e;
  }
};
Mg([
  u(B)
], Pu.prototype, "threshold");
Mg([
  u(B)
], Pu.prototype, "intensity");
Mg([
  u(B)
], Pu.prototype, "scatter");
let Rg = Pu;
pn("Bloom", Rg);
var zT = Object.defineProperty, UT = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && zT(e, t, n), n;
};
class Ou extends ot {
  get typeName() {
    return "ChromaticAberration";
  }
  intensity = new B(0);
  onCreateEffect() {
    const e = new R.POSTPROCESSING.MODULE.ChromaticAberrationEffect();
    return e.offset = new J(0, 0), e.radialModulation = !0, e.modulationOffset = 0.15, this.intensity.valueProcessor = (t) => t * 0.02, this.intensity.onValueChanged = (t) => {
      e.offset.x = -t, e.offset.y = t;
    }, e;
  }
}
UT([
  u(B)
], Ou.prototype, "intensity");
pn("ChromaticAberration", Ou);
var Dl = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Neutral = 1] = "Neutral", s[s.ACES = 2] = "ACES", s[s.AgX = 3] = "AgX", s[s.KhronosNeutral = 4] = "KhronosNeutral", s))(Dl || {});
const V_ = /* @__PURE__ */ new Map();
function qf(s) {
  switch (s) {
    case 0:
      return pm;
    case 1:
      return fm;
    case 2:
      return jd;
    case 3:
      return Dd;
    case 4:
      return ha;
    default:
      return V_.has(s) || (V_.set(s, !0), console.warn("[Postprocessing] Unknown tone mapping mode", s)), ha;
  }
}
function NT(s) {
  switch (s) {
    case pm:
      return 0;
    case jd:
      return 2;
    case Dd:
      return 3;
    case ha:
      return 1;
    case fm:
      return 1;
    default:
      return 0;
  }
}
function Wh(s) {
  switch (s) {
    case pm:
      return R.POSTPROCESSING.MODULE.ToneMappingMode.LINEAR;
    case jd:
      return R.POSTPROCESSING.MODULE.ToneMappingMode.ACES_FILMIC;
    case Dd:
      return R.POSTPROCESSING.MODULE.ToneMappingMode.AGX;
    case ha:
      return R.POSTPROCESSING.MODULE.ToneMappingMode.NEUTRAL;
    case fm:
      return R.POSTPROCESSING.MODULE.ToneMappingMode.REINHARD;
    default:
      return R.POSTPROCESSING.MODULE.ToneMappingMode.LINEAR;
  }
}
var $T = Object.defineProperty, aw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && $T(e, t, n), n;
};
const Xf = w("debugpost");
class hr extends ot {
  get typeName() {
    return "ToneMapping";
  }
  mode = new B(void 0);
  exposure = new B(1);
  /** Set the tonemapping mode to e.g. "agx" */
  setMode(e) {
    const t = Dl[e];
    return t === void 0 ? (console.error("[PostProcessing] Invalid ToneMapping mode", e), this) : (this.mode.value = t, this);
  }
  get isToneMapping() {
    return !0;
  }
  onEffectEnabled() {
    const e = sw(this);
    e && super.onEffectEnabled(e);
  }
  _tonemappingEffect = null;
  onCreateEffect() {
    if (this.mode.isInitialized == !1) {
      const i = NT(this.context.renderer.toneMapping);
      Xf && console.log("[PostProcessing] Initializing ToneMapping mode to renderer.toneMapping", this.context.renderer.toneMapping + " → " + i), this.mode.initialize(i);
    }
    this._tonemappingEffect?.dispose();
    const e = qf(this.mode.value), t = this._tonemappingEffect = new R.POSTPROCESSING.MODULE.ToneMappingEffect({
      mode: Wh(e)
    });
    return this.mode.onValueChanged = (i) => {
      if (typeof i == "string")
        i = A0(i), t.mode = Wh(i);
      else {
        const n = qf(i);
        t.mode = Wh(n);
      }
      t.name = "ToneMapping (" + Dl[i] + ")", Xf && console.log("[PostProcessing] ToneMapping mode changed to", Dl[i], e, t.mode);
    }, Xf && console.log("[PostProcessing] Use ToneMapping", Dl[this.mode.value], e, t.mode, "renderer.tonemapping: " + this.context.renderer.toneMapping), t;
  }
  onBeforeRender() {
    if (this._tonemappingEffect && this.postprocessingContext?.handler.getEffectIsActive(this._tonemappingEffect) && (this.mode.overrideState && (this.context.renderer.toneMapping = qf(this.mode.value)), this.exposure.overrideState && this.exposure.value !== void 0)) {
      const e = Math.max(0, this.exposure.value);
      this.context.renderer.toneMappingExposure = e;
    }
  }
}
aw([
  u(B)
], hr.prototype, "mode");
aw([
  u(B)
], hr.prototype, "exposure");
pn("Tonemapping", hr);
var WT = Object.defineProperty, ku = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && WT(e, t, n), n;
};
class Sr extends ot {
  get typeName() {
    return "ColorAdjustments";
  }
  /**
   * Whether values for contrast, hueshift or saturation are remapped to a different range.
   */
  remap = !0;
  postExposure = new B(1);
  contrast = new B(0);
  hueShift = new B(0);
  saturation = new B(0);
  init() {
    this.postExposure.valueProcessor = (e) => (this.remap && (e = Math.pow(2, e)), e), this.contrast.valueProcessor = (e) => {
      if (!this.remap) return e;
      let t = 1;
      return e > 0 ? t = 200 : e < 0 && (t = 100), e / t;
    }, this.contrast.defaultValue = 0, this.hueShift.valueProcessor = (e) => this.remap ? Math.PI * e / 180 : e, this.hueShift.defaultValue = 0, this.saturation.valueProcessor = (e) => this.remap ? e < 0 ? e / 100 : e / (100 * Math.PI) : e, this.saturation.defaultValue = 0;
  }
  onCreateEffect() {
    const e = [];
    let t = this.postprocessingContext?.components.find((o) => o instanceof hr);
    t || (t = new hr(), this.postprocessingContext?.components.push(t)), this.postExposure.onValueChanged = (o) => {
      this.postExposure.overrideState && t ? t.exposure.value = o : console.warn("[PostProcessing] PostExposure is set to override but no ToneMappingEffect found in the postprocessing stack. Please add a ToneMappingEffect to your postprocessing stack to use PostExposure.");
    };
    const i = new R.POSTPROCESSING.MODULE.BrightnessContrastEffect();
    this.contrast.onValueChanged = (o) => i.contrast = o;
    const n = new R.POSTPROCESSING.MODULE.HueSaturationEffect();
    return this.hueShift.onValueChanged = (o) => n.hue = o, this.saturation.onValueChanged = (o) => n.saturation = o, e.push(i), e.push(n), e;
  }
}
ku([
  u(B)
], Sr.prototype, "postExposure");
ku([
  u(B)
], Sr.prototype, "contrast");
ku([
  u(B)
], Sr.prototype, "hueShift");
ku([
  u(B)
], Sr.prototype, "saturation");
pn("ColorAdjustments", Sr);
var VT = Object.defineProperty, Cr = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && VT(e, t, n), n;
};
const HT = w("debugpost");
class Gn extends ot {
  get typeName() {
    return "DepthOfField";
  }
  mode;
  focusDistance = new B(1);
  focalLength = new B(0.2);
  aperture = new B(20);
  gaussianMaxRadius = new B();
  resolutionScale = new B(1 / window.devicePixelRatio);
  bokehScale = new B();
  init() {
    this.focalLength.valueProcessor = (t) => {
      const i = t / 300;
      return j.lerp(2, 0.01, i);
    };
    const e = 20;
    this.aperture.valueProcessor = (t) => {
      const i = 1 - t / 32;
      return j.lerp(1, e, i);
    };
  }
  onCreateEffect() {
    if (this.mode === 0) {
      HT && console.warn("DepthOfField: Mode is set to Off");
      return;
    }
    const e = new R.POSTPROCESSING.MODULE.DepthOfFieldEffect(this.context.mainCamera, {
      worldFocusRange: 0.2,
      focalLength: 1,
      bokehScale: 20,
      resolutionScale: this.resolutionScale.value
    });
    return this.focusDistance.onValueChanged = (t) => {
      e.cocMaterial.worldFocusDistance = t;
    }, this.focalLength.onValueChanged = (t) => e.cocMaterial.worldFocusRange = t, this.aperture.onValueChanged = (t) => e.bokehScale = t, this.resolutionScale && (this.resolutionScale.onValueChanged = (t) => e.resolution.scale = t), [e];
  }
  unapply() {
  }
}
Cr([
  u()
], Gn.prototype, "mode");
Cr([
  u(B)
], Gn.prototype, "focusDistance");
Cr([
  u(B)
], Gn.prototype, "focalLength");
Cr([
  u(B)
], Gn.prototype, "aperture");
Cr([
  u(B)
], Gn.prototype, "gaussianMaxRadius");
Cr([
  u(B)
], Gn.prototype, "resolutionScale");
Cr([
  u(B)
], Gn.prototype, "bokehScale");
pn("DepthOfField", Gn);
class xd extends ot {
  effect;
  constructor(e) {
    super(), this.effect = e;
  }
  get typeName() {
    return this.effect.constructor.name;
  }
  onCreateEffect() {
    return this.effect;
  }
}
var GT = Object.defineProperty, qT = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && GT(e, t, n), n;
};
class Mu extends ot {
  get typeName() {
    return "PixelationEffect";
  }
  granularity = new B(10);
  onCreateEffect() {
    const e = new R.POSTPROCESSING.MODULE.PixelationEffect();
    return this.granularity.onValueChanged = (t) => {
      e.granularity = t;
    }, e;
  }
}
qT([
  u(B)
], Mu.prototype, "granularity");
pn("PixelationEffect", Mu);
var XT = Object.defineProperty, Lc = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && XT(e, t, n), n;
};
class Co extends ot {
  get typeName() {
    return "ScreenSpaceAmbientOcclusion";
  }
  intensity = new B(2);
  falloff = new B(1);
  samples = new B(9);
  color = new B(new se(0, 0, 0));
  luminanceInfluence = new B(0.7);
  onBeforeRender() {
    if (this._ssao && this.context.mainCamera instanceof pe) {
      const e = this.context.mainCamera.far - this.context.mainCamera.near;
      this._ssao.ssaoMaterial.worldDistanceFalloff = e * 0.01, this._ssao.ssaoMaterial.worldDistanceThreshold = this.context.mainCamera.far;
    }
  }
  _ssao;
  onCreateEffect() {
    const e = this.context.mainCamera, t = new R.POSTPROCESSING.MODULE.NormalPass(this.context.scene, e), i = new R.POSTPROCESSING.MODULE.DepthDownsamplingPass({
      normalBuffer: t.texture,
      resolutionScale: 0.5
    }), n = this._ssao = new R.POSTPROCESSING.MODULE.SSAOEffect(e, t.texture, {
      normalDepthBuffer: i.texture,
      worldDistanceThreshold: 1,
      // when it starts to fade out
      worldDistanceFalloff: 1,
      // smoothness of cutoff
      worldProximityThreshold: 0.1,
      worldProximityFalloff: 2,
      intensity: 1,
      blendFunction: R.POSTPROCESSING.MODULE.BlendFunction.MULTIPLY,
      luminanceInfluence: 0.5
    });
    this.intensity.onValueChanged = (r) => {
      n.intensity = r;
    }, this.falloff.onValueChanged = (r) => {
      n.ssaoMaterial.radius = r * 0.1;
    }, this.samples.onValueChanged = (r) => {
      n.ssaoMaterial.samples = r;
    }, this.color.onValueChanged = (r) => {
      n.color || (n.color = new se()), n.color.copy(r);
    }, this.luminanceInfluence.onValueChanged = (r) => {
      n.luminanceInfluence = r;
    };
    const o = new Array();
    return o.push(t), o.push(i), o.push(n), o;
  }
}
Lc([
  u(B)
], Co.prototype, "intensity");
Lc([
  u(B)
], Co.prototype, "falloff");
Lc([
  u(B)
], Co.prototype, "samples");
Lc([
  u(B)
], Co.prototype, "color");
Lc([
  u(B)
], Co.prototype, "luminanceInfluence");
pn("ScreenSpaceAmbientOcclusion", Co);
var QT = Object.defineProperty, Pr = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && QT(e, t, n), n;
};
const YT = w("debugN8AO");
var em = /* @__PURE__ */ ((s) => (s[s.Performance = 0] = "Performance", s[s.Low = 1] = "Low", s[s.Medium = 2] = "Medium", s[s.High = 3] = "High", s[s.Ultra = 4] = "Ultra", s))(em || {});
class qn extends ot {
  get typeName() {
    return "ScreenSpaceAmbientOcclusionN8";
  }
  get pass() {
    return this._ssao;
  }
  gammaCorrection = !0;
  aoRadius = new B(1);
  falloff = new B(1);
  intensity = new B(1);
  color = new B(new se(0, 0, 0));
  screenspaceRadius = !1;
  quality = 2;
  _ssao;
  onValidate() {
    this._ssao && (this._ssao.setQualityMode(em[this.quality]), this._ssao.configuration.gammaCorrection = this.gammaCorrection, this._ssao.configuration.screenSpaceRadius = this.screenspaceRadius);
  }
  onCreateEffect() {
    const e = this.context.mainCamera, t = this.context.domWidth, i = this.context.domHeight, n = this._ssao = new R.POSTPROCESSING_AO.MODULE.N8AOPostPass(
      this.context.scene,
      e,
      t,
      i
    );
    n.name = "SSAO_N8";
    const o = em[this.quality];
    n.setQualityMode(o), n.configuration.transparencyAware = !1;
    const r = new Dn(t, i);
    return n.configuration.beautyRenderTarget = r, n.configuration.autoRenderBeauty = !1, n.configuration.gammaCorrection = this.gammaCorrection, n.configuration.screenSpaceRadius = this.screenspaceRadius, YT && (n.enableDebugMode(), console.log(n), setInterval(() => {
      console.log("SSAO", n.lastTime);
    }, 1e3), setInterval(() => {
      console.log("SSAO", n.enabled, { ssao: n, autoRenderBeauty: n.configuration.autoRenderBeauty });
    }, 4e3)), this.intensity.onValueChanged = (a) => {
      n.configuration.intensity = a;
    }, this.falloff.onValueChanged = (a) => {
      n.configuration.distanceFalloff = a;
    }, this.aoRadius.onValueChanged = (a) => {
      n.configuration.aoRadius = a;
    }, this.color.onValueChanged = (a) => {
      n.color || (n.color = new se()), n.configuration.color.copy(a);
    }, n;
  }
}
Pr([
  It(),
  u()
], qn.prototype, "gammaCorrection");
Pr([
  u(B)
], qn.prototype, "aoRadius");
Pr([
  u(B)
], qn.prototype, "falloff");
Pr([
  u(B)
], qn.prototype, "intensity");
Pr([
  u(B)
], qn.prototype, "color");
Pr([
  It(),
  u()
], qn.prototype, "screenspaceRadius");
Pr([
  It(),
  u()
], qn.prototype, "quality");
pn("ScreenSpaceAmbientOcclusionN8", qn);
var KT = Object.defineProperty, ZT = Object.getOwnPropertyDescriptor, lw = (s, e, t, i) => {
  for (var n = ZT(e, t), o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && KT(e, t, n), n;
};
class Ru extends ot {
  get typeName() {
    return "Sharpening";
  }
  order = lt.Sharpening;
  _effect;
  onCreateEffect() {
    return this._effect ??= new (JT())(), this.effect;
  }
  get effect() {
    return this._effect;
  }
  set amount(e) {
    this._amount = e, this._effect && (this._effect.uniforms.get("amount").value = e);
  }
  get amount() {
    return this._effect ? this._effect.uniforms.get("amount").value : this._amount;
  }
  _amount = 1;
  set radius(e) {
    this._radius = e, this._effect && (this._effect.uniforms.get("radius").value = e);
  }
  get radius() {
    return this._effect ? this._effect.uniforms.get("radius").value : this._radius;
  }
  _radius = 1;
  // @serializable()
  // set threshold(value: number) {
  //     this.effect.uniforms.get("threshold")!.value = value;
  // }
  // get threshold() {
  //     return this.effect.uniforms.get("threshold")!.value;
  // }
}
lw([
  u()
], Ru.prototype, "amount");
lw([
  u()
], Ru.prototype, "radius");
function JT() {
  const s = `
      void mainSupport() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `, e = `
    uniform sampler2D tDiffuse;
    uniform float amount;
    uniform float radius;
    
    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        float tx = 1.0 / resolution.x;
        float ty = 1.0 / resolution.y;
        vec2 texelSize = vec2(tx, ty);
    
        vec4 blurred = vec4(0.0);
        float total = 0.0;
    
        for (float x = -radius; x <= radius; x++) {
            for (float y = -radius; y <= radius; y++) {
                vec2 offset = vec2(x, y) * texelSize;
                vec4 diffuse = texture2D(tDiffuse, uv + offset);
                float weight = exp(-length(offset) * amount);
                blurred += diffuse * weight;
                total += weight;
            }
        }
    
        if (total > 0.0) {
            blurred /= total;
        }
    
        // Calculate the sharpened color using inputColor
        vec4 sharp = inputColor + clamp(inputColor - blurred, 0.0, 1.0) * amount;
        // Keep original alpha
        sharp.a = inputColor.a;
    
        // Ensure the sharp color does not go below 0 or above 1
        // This means: sharpening must happen AFTER tonemapping.
        sharp = clamp(sharp, 0.0, 1.0);
    
        outputColor = sharp;
    }
    
    `;
  class t extends R.POSTPROCESSING.MODULE.Effect {
    constructor() {
      super("Sharpening", e, {
        vertexShader: s,
        blendFunction: R.POSTPROCESSING.MODULE.BlendFunction.NORMAL,
        uniforms: /* @__PURE__ */ new Map([
          ["amount", new zi(1)],
          ["radius", new zi(1)]
          // ["threshold", new Uniform(0)],
        ]),
        attributes: US.CONVOLUTION
      });
    }
  }
  return t;
}
var eE = Object.defineProperty, Ha = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && eE(e, t, n), n;
};
class Ls extends ot {
  get typeName() {
    return "TiltShiftEffect";
  }
  offset = new B(0);
  rotation = new B(0);
  focusArea = new B(0.4);
  feather = new B(0.3);
  kernelSize = new B(2);
  resolutionScale = new B(1 / window.devicePixelRatio);
  init() {
    this.offset.defaultValue = 0, this.rotation.defaultValue = 0, this.focusArea.defaultValue = 0.4, this.feather.defaultValue = 0.3, this.kernelSize.defaultValue = R.POSTPROCESSING.MODULE.KernelSize.MEDIUM, this.resolutionScale.defaultValue = 1 / window.devicePixelRatio;
  }
  onCreateEffect() {
    const e = new R.POSTPROCESSING.MODULE.TiltShiftEffect({
      kernelSize: R.POSTPROCESSING.MODULE.KernelSize.VERY_LARGE,
      offset: this.offset.value,
      rotation: this.rotation.value,
      focusArea: this.focusArea.value,
      feather: this.feather.value
    });
    return this.offset.onValueChanged = (t) => e.offset = t, this.rotation.onValueChanged = (t) => e.rotation = t, this.focusArea.onValueChanged = (t) => e.focusArea = t, this.feather.onValueChanged = (t) => e.feather = t, this.kernelSize.onValueChanged = (t) => e.blurPass.kernelSize = t, this.resolutionScale.onValueChanged = (t) => e.resolution.scale = t / window.devicePixelRatio, e;
  }
}
Ha([
  u(B)
], Ls.prototype, "offset");
Ha([
  u(B)
], Ls.prototype, "rotation");
Ha([
  u(B)
], Ls.prototype, "focusArea");
Ha([
  u(B)
], Ls.prototype, "feather");
Ha([
  u(B)
], Ls.prototype, "kernelSize");
Ha([
  u(B)
], Ls.prototype, "resolutionScale");
pn("TiltShiftEffect", Ls);
var tE = Object.defineProperty, Tg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && tE(e, t, n), n;
};
class Ga extends ot {
  get typeName() {
    return "Vignette";
  }
  color = new B({ r: 0, g: 0, b: 0, a: 1 });
  intensity = new B(0);
  center = new B({ x: 0.5, y: 0.5 });
  init() {
    this.color.defaultValue = { r: 0, g: 0, b: 0, a: 1 }, this.intensity.defaultValue = 0, this.center.defaultValue = { x: 0.5, y: 0.5 };
  }
  onCreateEffect() {
    const e = new R.POSTPROCESSING.MODULE.VignetteEffect();
    return this.intensity.onValueChanged = (t) => {
      e.offset = t, this.updateDarkness(e);
    }, this.color.onValueChanged = (t) => {
      this.updateDarkness(e);
    }, e;
  }
  updateDarkness(e) {
    const t = this.intensity.value;
    e.darkness = t;
  }
}
Tg([
  u(B)
], Ga.prototype, "color");
Tg([
  u(B)
], Ga.prototype, "intensity");
Tg([
  u(B)
], Ga.prototype, "center");
pn("Vignette", Ga);
globalThis.NEEDLE_USE_POSTPROCESSING = globalThis.NEEDLE_USE_POSTPROCESSING !== void 0 ? globalThis.NEEDLE_USE_POSTPROCESSING : !0;
const es = w("debugpost"), Qf = Symbol("needle:postprocessing-handler"), cl = Symbol("needle:previous-autoclear-state"), hl = Symbol("needle:previous-tone-mapping");
class cw {
  _composer = null;
  _lastVolumeComponents;
  _effects = [];
  /**
   * Returns true if a specific effect is currently active in the post processing stack.
   */
  getEffectIsActive(e) {
    return e ? this._isActive && this._effects.some((t) => t.effect === e) : !1;
  }
  get isActive() {
    return this._isActive;
  }
  get composer() {
    return this._composer;
  }
  _isActive = !1;
  context;
  constructor(e) {
    this.context = e;
  }
  apply(e) {
    return this._isActive = !0, this.onApply(this.context, e);
  }
  unapply(e = !0) {
    if (es && console.log("Unapplying postprocessing effects"), this._isActive = !1, this._lastVolumeComponents) {
      for (const n of this._lastVolumeComponents)
        n.unapply();
      this._lastVolumeComponents.length = 0;
    }
    const t = this.context;
    t[Qf] === this && (delete t[Qf], typeof t.renderer[cl] == "boolean" && (t.renderer.autoClear = t.renderer[cl]), typeof t.renderer[hl] == "number" && (t.renderer.toneMapping = t.renderer[hl])), this._composer?.removeAllPasses(), e && this._composer?.dispose(), t.composer === this._composer && (t.composer = null), this.handleDevicePixelRatio();
  }
  dispose() {
    this.unapply(!0);
    for (const e of this._effects)
      e.effect.dispose();
    this._effects.length = 0, this._composer = null;
  }
  async onApply(e, t) {
    if (!t) return;
    await Promise.all([
      R.POSTPROCESSING.load(),
      R.POSTPROCESSING_AO.load()
      // import("./Effects/Sharpening.effect")
    ]), e[Qf] = this, es && console.log("Apply Postprocessing Effects", t), this._lastVolumeComponents = [...t], this._effects.length = 0;
    const i = {
      handler: this,
      components: this._lastVolumeComponents
    };
    for (let n = 0; n < this._lastVolumeComponents.length; n++) {
      const o = this._lastVolumeComponents[n];
      if (o.context = e, o.apply) {
        if (o.active) {
          let r = function(c, h) {
            return h ? (h instanceof R.POSTPROCESSING.MODULE.Effect || h instanceof R.POSTPROCESSING.MODULE.Pass || console.warn(`PostprocessingEffect ${c} created neither Effect nor Pass - this might be caused by a bundler error or false import. Below you find some possible solutions:
- If you create custom effect try creating it like this: 'new NEEDLE_ENGINE_MODULES.POSTPROCESSING.MODULE.Effect(...)' instead of 'new Effect(...)'`), !0) : !1;
          };
          if (!e.mainCameraComponent) {
            console.error("No camera in scene found or available yet - can not create postprocessing effects");
            return;
          }
          const a = o.apply(i);
          if (!a) continue;
          const l = o.typeName || o.constructor.name;
          if (Array.isArray(a))
            for (const c of a)
              r(l, c) && this._effects.push({
                effect: c,
                typeName: o.typeName,
                priority: o.order
              });
          else {
            if (!r(l, a)) continue;
            this._effects.push({
              effect: a,
              typeName: o.typeName,
              priority: o.order
            });
          }
        }
      } else
        o.active && ge("Volume component is not a VolumeComponent: " + o.__type);
    }
    this.applyEffects(e);
  }
  _anyPassHasDepth = !1;
  _anyPassHasNormal = !1;
  _hasSmaaEffect = !1;
  get anyPassHasDepth() {
    return this._anyPassHasDepth;
  }
  get anyPassHasNormal() {
    return this._anyPassHasNormal;
  }
  get hasSmaaEffect() {
    return this._hasSmaaEffect;
  }
  _customInputBuffer = null;
  _customInputBufferId = 0;
  _multisampling = 0;
  set multisampling(e) {
    this._multisampling = e;
  }
  get multisampling() {
    return this._multisampling;
  }
  /** Build composer passes */
  applyEffects(e) {
    if (this._anyPassHasDepth = !1, this._anyPassHasNormal = !1, this._hasSmaaEffect = !1, this._effects.length <= 0)
      return;
    const t = e.mainCameraComponent, i = e.renderer, n = e.scene, o = t.threeCamera;
    if (typeof i[cl] == "boolean" && (i.autoClear = i[cl]), i[cl] = i.autoClear, typeof i[hl] == "number" && (i.toneMapping = i[hl]), i[hl] = i.toneMapping, i.toneMapping != Gh && !this._effects.find((h) => h instanceof R.POSTPROCESSING.MODULE.ToneMappingEffect)) {
      const h = new R.POSTPROCESSING.MODULE.ToneMappingEffect();
      h.name = `ToneMapping (${i.toneMapping})`, h.mode = Wh(i.toneMapping), this._effects.push({
        typeName: "ToneMapping",
        effect: h,
        priority: lt.ToneMapping
      });
    }
    this._composer || (this._composer = new R.POSTPROCESSING.MODULE.EffectComposer(i, {
      frameBufferType: Vu,
      stencilBuffer: !0
    })), e.composer && e.composer !== this._composer && console.warn("There's already an active EffectComposer in your scene: replacing it with a new one. This might cause unexpected behaviour. Make sure to only use one PostprocessingManager/Volume in your scene."), e.composer = this._composer;
    const r = e.composer;
    r.setMainCamera(o), r.setRenderer(i), r.setMainScene(n), r.autoRenderToScreen = !0, r.multisampling = 0;
    for (const h of r.passes)
      h.dispose();
    r.removeAllPasses();
    const a = new R.POSTPROCESSING.MODULE.RenderPass(n, o);
    a.name = "RenderPass", a.mainScene = n, r.addPass(a);
    const l = a.render;
    this._customInputBuffer?.dispose(), this._customInputBuffer = null, a.render = (h, d, f, p, g) => {
      d && (d.samples = 0, f && (f.samples = 0), (!this._customInputBuffer || this._customInputBuffer.width !== d.width || this._customInputBuffer.height !== d.height || this._customInputBuffer.samples !== this._multisampling || this._customInputBuffer.texture.format !== d.texture.format || this._customInputBuffer.texture.type !== Vu) && (this._customInputBuffer?.dispose(), this._customInputBuffer = new Dn(d.width, d.height, {
        format: d.texture.format,
        type: Vu,
        depthBuffer: d.depthBuffer,
        depthTexture: d.depthTexture ? new ub(d.width, d.height) : void 0,
        stencilBuffer: d.stencilBuffer,
        samples: Math.max(0, this._multisampling),
        minFilter: d.texture.minFilter ?? Xh,
        magFilter: d.texture.magFilter ?? Xh,
        generateMipmaps: d.texture.generateMipmaps
      }), this._customInputBufferId++, this._customInputBuffer.texture.name = `CustomInputBuffer-${this._customInputBufferId}`, this._customInputBuffer.depthTexture && d.depthTexture && (this._customInputBuffer.depthTexture.format = d.depthTexture.format, this._customInputBuffer.depthTexture.type = d.depthTexture.type), this._customInputBuffer.samples > 0 && (this._customInputBuffer.ignoreDepthForMultisampleCopy = !1), es && console.warn(`[PostProcessing] Input buffer created with size ${this._customInputBuffer.width}x${this._customInputBuffer.height} and samples ${this._customInputBuffer.samples}`)), l.call(a, h, this._customInputBuffer, f, p, g), sr.blit(this._customInputBuffer.texture, d, {
        renderer: h,
        depthTexture: this._customInputBuffer.depthTexture,
        depthWrite: !0,
        depthTest: !0
      }));
    };
    try {
      CT(this._effects);
      let h = !1, d = null;
      for (let g = this._effects.length - 1; g >= 0; g--) {
        const _ = this._effects[g].effect;
        if (_ instanceof R.POSTPROCESSING.MODULE.ToneMappingEffect) {
          if (h) {
            es && console.warn(`[PostProcessing] Found multiple tonemapping effects in the scene: ${_.name} and ${d?.name}. Only the last one added will be used.`), this._effects.splice(g, 1);
            continue;
          }
          d = _, h = !0;
        }
      }
      const f = [];
      let p = !1;
      for (let g = 0; g < this._effects.length; g++) {
        const m = this._effects[g].effect;
        if (m instanceof R.POSTPROCESSING.MODULE.SMAAEffect ? this._hasSmaaEffect = !0 : m instanceof R.POSTPROCESSING.MODULE.NormalPass && (this._anyPassHasNormal = !0), !(m instanceof R.POSTPROCESSING.MODULE.ToneMappingEffect && d !== m))
          if (m instanceof R.POSTPROCESSING.MODULE.Effect) {
            const v = m.getAttributes(), y = R.POSTPROCESSING.MODULE.EffectAttribute.CONVOLUTION;
            v & y && (es && console.log("[PostProcessing] Convolution effect: " + m.name), p && (es && console.log("[PostProcessing] → Merging effects [" + f.map((x) => x.name).join(", ") + "]"), this.createPassForMergeableEffects(f, r, o, n)), p = !0), f.push(m);
          } else m instanceof R.POSTPROCESSING.MODULE.Pass ? (p = !1, this.createPassForMergeableEffects(f, r, o, n), m.renderToScreen = !1, r.addPass(m)) : (p = !1, this.createPassForMergeableEffects(f, r, o, n), r.addPass(m));
      }
      this.createPassForMergeableEffects(f, r, o, n);
    } catch (h) {
      console.error("Error while applying postprocessing effects", h), r.passes.forEach((d) => d.dispose()), r.removeAllPasses();
    }
    let c = !1;
    for (let h = r.passes.length - 1; h >= 0; h--) {
      const d = r.passes[h];
      let f = !1, p = !1;
      d.enabled && (c || (f = !0, p = !0), c = !0), d.renderToScreen = p, d?.configuration !== void 0 ? d.configuration.gammaCorrection = f : "autosetGamma" in d && (d.autosetGamma = f), this._anyPassHasDepth ||= d.needsDepthTexture;
    }
    this.handleDevicePixelRatio(), es && console.log("[PostProcessing] Passes →", [...r.passes], `
---------------------------------
• ` + r.passes.map((h) => h.name || h.constructor.name + "*").join(`
• `) + `
`), es && this._onCreateEffectsDebug(this._composer, o);
  }
  /** Should be called before `composer.addPass()` to create an effect pass with all previously collected effects that can be merged up to that point */
  createPassForMergeableEffects(e, t, i, n) {
    if (e.length > 0) {
      const o = new R.POSTPROCESSING.MODULE.EffectPass(i, ...e);
      o.name = e.map((r) => r.name).join(", "), o.mainScene = n, o.enabled = !0, o.renderToScreen = !1, t.addPass(o), e.length = 0;
    }
  }
  handleDevicePixelRatio() {
    typeof this.context.devicePixelRatio == "number" && this.context.requestSizeUpdate();
  }
  _menuEntry = null;
  _passIndices = null;
  _onCreateEffectsDebug(e, t) {
    if (es === "passes") {
      const i = new R.POSTPROCESSING.MODULE.DepthEffect({
        blendFunction: R.POSTPROCESSING.MODULE.BlendFunction.NORMAL,
        inverted: !0
      });
      i.name = "Depth Effect";
      const n = new R.POSTPROCESSING.MODULE.EffectPass(t, i);
      if (n.name = "Depth Effect Pass", n.enabled = !1, e.passes.push(n), this._passIndices !== null) {
        const r = [e.passes[0]];
        this._passIndices.length > 0 && r.push(
          ...this._passIndices.filter((a) => a !== 0).map((a) => e.passes[a]).filter((a) => a)
        ), r.length > 0 && console.log("[PostProcessing] Passes (selected) →", r), e.passes.length = 0;
        for (const a of r)
          a.enabled = !0, a.renderToScreen = !1, e.addPass(a);
      }
      const o = this.context.menu;
      if (o && this._passIndices === null) {
        this._menuEntry && this._menuEntry.remove();
        const r = document.createElement("select");
        r.multiple = !0;
        const a = document.createElement("option");
        a.innerText = "Final Output", a.value = "-1", r.appendChild(a);
        for (const l of e.passes) {
          const c = document.createElement("option");
          c.innerText = l.name, c.value = `${e.passes.indexOf(l)}`, c.title = l.name, r.appendChild(c);
        }
        o.appendChild(r), this._menuEntry = r, r.addEventListener("change", () => {
          const l = Array.from(r.selectedOptions).map((c) => parseInt(c.value));
          l.length === 1 && l[0] === -1 ? this._passIndices = null : this._passIndices = l, this.applyEffects(this.context);
        });
      }
    }
  }
}
var iE = Object.defineProperty, hw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && iE(e, t, n), n;
};
const Bo = w("debugpost");
class Dc extends T {
  get isPostProcessingManager() {
    return !0;
  }
  /** Currently active postprocessing effects */
  get effects() {
    return this._activeEffects;
  }
  get dirty() {
    return this._isDirty;
  }
  set dirty(e) {
    this._isDirty = e;
  }
  sharedProfile;
  multisampling = "auto";
  /**
   * Add a post processing effect to the stack and schedules the effect stack to be re-created.  
   */
  addEffect(e) {
    let t = e;
    return t instanceof ot || (t = new xd(t), typeof e.order == "number" && (t.order = e.order)), t.gameObject === void 0 && this.gameObject.addComponent(t), this._effects.includes(t) || (this._effects.push(t), this._isDirty = !0), e;
  }
  /**
   * Remove a post processing effect from the stack and schedules the effect stack to be re-created.
   */
  removeEffect(e) {
    let t = -1;
    if (e instanceof ot ? t = this._effects.indexOf(e) : t = this._effects.findIndex((i) => i instanceof xd && i.effect === e), t !== -1)
      return this._effects.splice(t, 1), this._isDirty = !0, e;
    if (e instanceof ot) {
      const i = this.sharedProfile?.components?.indexOf(e);
      i !== void 0 && i !== -1 && (this._isDirty = !0, this.sharedProfile?.components?.splice(i, 1));
    }
    return e;
  }
  _postprocessing;
  _activeEffects = [];
  _effects = [];
  /**
   * When dirty the post processing effects will be re-applied
   */
  markDirty() {
    this._isDirty = !0;
  }
  /** @internal */
  awake() {
    Bo && (console.log("PostprocessingManager Awake", this), console.log("Press P to toggle post processing"), window.addEventListener("keydown", (e) => {
      e.key === "p" && (this.enabled = !this.enabled, Be("Toggle PostProcessing " + this.name + ": Enabled=" + this.enabled), this.markDirty());
    })), this.sharedProfile?.__init(this);
  }
  _componentEnabledTime = -1;
  _multisampleAutoChangeTime = 0;
  _multisampleAutoDecreaseTime = 0;
  /** @internal */
  onEnable() {
    this._componentEnabledTime = this.context.time.realtimeSinceStartup, this._isDirty = !0;
  }
  /** @internal */
  onDisable() {
    this._postprocessing?.unapply(), this._isDirty = !1;
  }
  /** @internal */
  onBeforeRender() {
    if (!this.context.isInXR && (this.context.mainCamera && this._isDirty && this.apply(), this.context.composer && this._postprocessing && this._postprocessing.composer === this.context.composer)) {
      if (this.context.renderer.getContext().isContextLost() && this.context.renderer.forceContextRestore(), this.context.composer.getRenderer() !== this.context.renderer && this.context.composer.setRenderer(this.context.renderer), this.context.composer.setMainScene(this.context.scene), this.multisampling === "auto")
        if (this._postprocessing && this._postprocessing.hasSmaaEffect)
          this._postprocessing.multisampling !== 0 && (this._postprocessing.multisampling = 0, (Bo || L()) && console.log(`[PostProcessing] multisampling is disabled because it's set to 'auto' on your PostprocessingManager/Volume component that also has an SMAA effect.

If you need multisampling consider changing 'auto' to a fixed value (e.g. 4).`));
        else {
          const e = this.context.time.realtimeSinceStartup - this._multisampleAutoChangeTime;
          if (this.context.time.realtimeSinceStartup - this._componentEnabledTime > 2 && e > 0.5) {
            const t = this._postprocessing.multisampling;
            if (this._postprocessing.multisampling > 0 && this.context.time.smoothedFps <= 50) {
              this._multisampleAutoChangeTime = this.context.time.realtimeSinceStartup, this._multisampleAutoDecreaseTime = this.context.time.realtimeSinceStartup;
              let i = this._postprocessing.multisampling * 0.5;
              i = Math.floor(i), i != this._postprocessing.multisampling && (this._postprocessing.multisampling = i), Bo && console.debug(`[PostProcessing] Reduced multisampling from ${t} to ${this._postprocessing.multisampling}`);
            } else if (e > 1 && this.context.time.smoothedFps >= 59 && this._postprocessing.multisampling < this.context.renderer.capabilities.maxSamples && this.context.time.realtimeSinceStartup - this._multisampleAutoDecreaseTime > 10) {
              this._multisampleAutoChangeTime = this.context.time.realtimeSinceStartup;
              let i = this._postprocessing.multisampling <= 0 ? 1 : this._postprocessing.multisampling * 2;
              i = Math.floor(i), i !== this._postprocessing.multisampling && (this._postprocessing.multisampling = i), Bo && console.debug(`[PostProcessing] Increased multisampling from ${t} to ${this._postprocessing.multisampling}`);
            }
          }
        }
      else {
        const e = Math.max(0, Math.min(this.multisampling, this.context.renderer.capabilities.maxSamples));
        e !== this._postprocessing.multisampling && (this._postprocessing.multisampling = e);
      }
      if (this.context.mainCamera) {
        const e = this.context.composer.passes;
        for (const t of e)
          if (t.mainCamera && t.mainCamera !== this.context.mainCamera) {
            this.context.composer.setMainCamera(this.context.mainCamera);
            break;
          }
      }
    }
  }
  /** @internal */
  onDestroy() {
    this._postprocessing?.dispose();
  }
  _lastApplyTime;
  _rapidApplyCount = 0;
  _isDirty = !1;
  apply() {
    if (Bo && console.log(`Apply PostProcessing "${this.name || "unnamed"}"`), L() && (this._lastApplyTime !== void 0 && Date.now() - this._lastApplyTime < 100 && (this._rapidApplyCount++, this._rapidApplyCount === 5 && console.warn("Detected rapid post processing modifications - this might be a bug", this)), this._lastApplyTime = Date.now()), this._isDirty = !1, this._activeEffects.length = 0, this.sharedProfile?.components) {
      const e = this.sharedProfile.components;
      for (const t of e)
        t.active && t.enabled && !this._activeEffects.includes(t) && this._activeEffects.push(t);
    }
    for (const e of this._effects)
      e.active && e.enabled && !this._activeEffects.includes(e) && this._activeEffects.push(e);
    this._activeEffects.length > 0 ? (this._postprocessing || (this._postprocessing = new cw(this.context)), this._postprocessing.apply(this._activeEffects)?.then(() => {
      this.activeAndEnabled && (this._applyPostQueue(), this._postprocessing ? (this.multisampling === "auto" ? this._postprocessing.multisampling = X.isMobileDevice() ? 2 : 4 : this._postprocessing.multisampling = Math.max(0, Math.min(this.multisampling, this.context.renderer.capabilities.maxSamples)), Bo && console.debug(`[PostProcessing] Set multisampling to ${this._postprocessing.multisampling} (Is Mobile: ${X.isMobileDevice()})`)) : Bo && console.warn("[PostProcessing] No composer found"));
    })) : this._postprocessing?.unapply(!1);
  }
  _applyPostQueue() {
    if (this._modificationQueue) {
      for (const e of this._modificationQueue.values()) this.onEditorModification(e);
      this._modificationQueue.clear();
    }
  }
  /** called from needle editor sync package if its active */
  onEditorModification(e) {
    if (e.propertyName.startsWith("postprocessing.")) {
      if (!this._postprocessing)
        return this._modificationQueue || (this._modificationQueue = /* @__PURE__ */ new Map()), this._modificationQueue.set(e.propertyName, e), !0;
      if (!this._activeEffects?.length) return;
      const t = e.propertyName.split(".");
      if (t.length === 3 || t.length === 4) {
        const i = t[1], n = t[2];
        for (const o of this._activeEffects)
          if (o.typeName?.toLowerCase() === i.toLowerCase()) {
            if (n === "active") {
              o.active = e.value, this.scheduleRecreate();
              return;
            }
            if (!Sh.has(i)) {
              const r = new Array();
              Sh.set(i, r);
              const a = Object.keys(o);
              for (const l of a)
                o[l] instanceof B && r.push(l);
            }
            if (Sh.has(i)) {
              const r = n.toLowerCase(), a = Sh.get(i);
              for (const l of a)
                if (l.toLowerCase() === r) {
                  const c = o[l];
                  c instanceof B && (t.length === 4 && t[3] === "active" ? (c.overrideState = e.value, this.scheduleRecreate()) : c && c.value !== void 0 && (c.value = e.value));
                  return;
                }
            }
            console.warn("Unknown modification", n);
            return;
          }
      }
      return !0;
    }
    return !1;
  }
  _modificationQueue;
  _recreateId = -1;
  scheduleRecreate() {
    const e = ++this._recreateId;
    setTimeout(() => {
      e === this._recreateId && (this.onDisable(), this.onEnable());
    }, 200);
  }
}
hw([
  Ma(kg)
], Dc.prototype, "sharedProfile");
hw([
  Ma()
], Dc.prototype, "multisampling");
const Sh = /* @__PURE__ */ new Map();
xT(Dc);
async function Eg(s) {
  const { NeedleEngineWebComponent: e } = await Promise.resolve().then(() => IA);
  e.observedAttributes.includes(s) || e.observedAttributes.push(s);
}
var nE = Object.defineProperty, _t = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && nE(e, t, n), n;
};
const kt = w("debugsceneswitcher"), sE = w("sceneswitcher:clearscene"), Vh = "scene";
Eg(Vh);
const Ns = Promise.resolve(!1);
class Ze extends T {
  autoLoadFirstScene = !0;
  scenes = [];
  loadingScene;
  queryParameterName = "scene";
  useSceneName = !0;
  clamp = !0;
  useHistory = !0;
  useKeyboard = !0;
  useSwipe = !0;
  useSceneLighting = !0;
  useSceneBackground = !0;
  preloadNext = 1;
  preloadPrevious = 1;
  preloadConcurrent = 2;
  createMenuButtons = !1;
  /** The index of the currently loaded and active scene */
  get currentIndex() {
    return this._currentIndex;
  }
  /** Get the progress of the currently loading scene. This is undefined if no scene is loading  
   * You can also subscribe to the loading event by adding an event listener to the scene switcher.  
   * For example like this `sceneSwitcher.addEventListeneer("progress", (e) => {...})`
   */
  get currentLoadingProgress() {
    return this._currentLoadingProgress;
  }
  /** The currently loading scene. This is undefined if no scene is loading. */
  get currentlyLoadingScene() {
    return this._currentlyLoadingScene;
  }
  /**
   * The currently loaded scene. This is undefined if no scene is loaded.
   */
  get currentlyLoadedScene() {
    return this._currentScene;
  }
  sceneLoadingStart = new me();
  sceneLoadingProgress = new me();
  sceneLoaded = new me();
  _currentIndex = -1;
  _currentScene = void 0;
  _engineElementOverserver = void 0;
  _preloadScheduler;
  _menuButtons;
  /** @internal */
  awake() {
    this.scenes === void 0 && (this.scenes = []);
    for (const e of this.scenes)
      e && !e.hasUrl && e.asset instanceof M ? S.remove(e.asset) : e instanceof M && S.remove(e);
    kt && console.log("SceneSwitcher", this);
  }
  /** @internal */
  async onEnable() {
    if (globalThis.addEventListener("popstate", this.onPopState), this.context.input.addEventListener(De.KeyDown, this.onInputKeyDown), this.context.input.addEventListener(De.PointerMove, this.onInputPointerMove), this.context.input.addEventListener(De.PointerUp, this.onInputPointerUp), this._engineElementOverserver || (this._engineElementOverserver = new MutationObserver((e) => {
      for (const t of e)
        if (t.type === "attributes" && t.attributeName === Vh) {
          const i = this.context.domElement.getAttribute(Vh);
          i !== null && this.trySelectSceneFromValue(i);
        }
    })), this._engineElementOverserver.observe(this.context.domElement, {
      attributes: !0
    }), this._preloadScheduler || (this._preloadScheduler = new oE(this)), this._preloadScheduler.maxLoadAhead = this.preloadNext, this._preloadScheduler.maxLoadBehind = this.preloadPrevious, this._preloadScheduler.maxConcurrent = this.preloadConcurrent, this._preloadScheduler.begin(2e3), this.autoLoadFirstScene && this._currentIndex === -1 && !await this.tryLoadFromQueryParam()) {
      const e = this.context.domElement.getAttribute(Vh);
      try {
        (e === null || !await this.trySelectSceneFromValue(e)) && this._currentIndex === -1 && this.select(0);
      } finally {
      }
    }
    this.createMenuButtons && (this._menuButtons ??= [], this._menuButtons.push(this.context.menu.appendChild({
      label: "Previous",
      icon: "arrow_back_ios",
      onClick: () => this.selectPrev(),
      priority: -1005,
      class: "row2"
    })), this._menuButtons.push(this.context.menu.appendChild({
      label: "Next",
      icon: "arrow_forward_ios",
      iconSide: "right",
      onClick: () => this.selectNext(),
      priority: -1e3,
      class: "row2"
    })));
  }
  /** @internal */
  onDisable() {
    if (globalThis.removeEventListener("popstate", this.onPopState), this.context.input.removeEventListener(De.KeyDown, this.onInputKeyDown), this.context.input.removeEventListener(De.PointerMove, this.onInputPointerMove), this.context.input.removeEventListener(De.PointerUp, this.onInputPointerUp), this._preloadScheduler?.stop(), this._menuButtons) {
      for (const e of this._menuButtons)
        e.remove();
      this._menuButtons = void 0;
    }
  }
  onPopState = async (e) => {
    if (!this.useHistory) return;
    const t = this.useHistory;
    try {
      this.useHistory = !1;
      let i = !1;
      if (this.queryParameterName && (i = await this.tryLoadFromQueryParam()), !i) {
        const n = e?.state;
        if (n && n.startsWith(this.guid)) {
          const o = n.substr(this.guid.length + 2);
          kt && console.log("PopState", o), await this.trySelectSceneFromValue(o);
        }
      }
    } finally {
      this.useHistory = t;
    }
  };
  normalizedSwipeThresholdX = 0.1;
  _didSwipe = !1;
  onInputPointerMove = (e) => {
    if (this.useSwipe && !this._didSwipe && e.button === 0 && e.pointerType === "touch" && this.context.input.getPointerPressedCount() === 1) {
      const t = this.context.input.getPointerPositionDelta(e.button);
      if (t) {
        const i = t.x / this.context.domWidth;
        i >= this.normalizedSwipeThresholdX ? (this._didSwipe = !0, this.selectPrev()) : i <= -this.normalizedSwipeThresholdX && (this._didSwipe = !0, this.selectNext());
      }
    }
  };
  onInputPointerUp = (e) => {
    e.button === 0 && (this._didSwipe = !1);
  };
  onInputKeyDown = (e) => {
    if (!this.useKeyboard || !this.scenes) return;
    const t = e.key.toLowerCase();
    if (!t) return;
    const i = parseInt(t) - 1;
    if (i >= 0) {
      this.trySelectSceneFromValue(i);
      return;
    }
    switch (t) {
      case "arrowright":
      case "d":
        this.selectNext();
        break;
      case "arrowleft":
      case "a":
        this.selectPrev();
        break;
    }
  };
  /**
   * Add a scene to the SceneSwitcher.     
   * If the scene is already added it will be added again.
   * @param urlOrAssetReference The url of the scene or an AssetReference to the scene  
   * @returns The AssetReference of the scene that was added
   * @example
   * ```ts
   * // adding a scene:
   * sceneSwitcher.addScene("scene1.glb");
   * // add another scene and load it:
   * const scene2 = sceneSwitcher.addScene("scene2.glb");
   * sceneSwitcher.switchScene(scene2).then(res => { console.log("Scene loaded", res); });
   * ```
   */
  addScene(e) {
    if (typeof e == "string") {
      let t = this.context.addressables.findAssetReference(e);
      return t || (t = new ie(e), this.context.addressables.registerAssetReference(t)), this.scenes.push(t), t;
    }
    return this.scenes.push(e), e;
  }
  /**
   * Load the next scene in the scenes array ({@link this.currentIndex} + 1)  
   * If the current scene is the last scene in the array and {@link this.clamp} is disabled then the first scene will be loaded.
   * @returns a promise that resolves to true if the scene was loaded successfully    
   */
  selectNext() {
    return this.select(this._currentIndex + 1);
  }
  /**
   * Load the previous scene in the scenes array ({@link this.currentIndex} - 1)  
   * If the current scene is the first scene in the array and {@link this.clamp} is disabled then the last scene will be loaded.
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  selectPrev() {
    return this.select(this._currentIndex - 1);
  }
  /**
   * Load a scene by its index in the scenes array.
   * @param index The index of the scene or a string that represents the scene uri (if the url is not known to the SceneSwitcher it will try to load the scene by its uri but it won't be added to the current scenes array. Use {@link addScene} to add a scene to the SceneSwitcher)  
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  select(e) {
    if (kt && console.log("select", e), typeof e == "object" && console.warn('Switching to "' + e + '" might not work. Please either use an index or a AssetReference (not a scene reference)'), typeof e == "string") {
      const i = this.scenes?.find((n) => n.url === e);
      if (!i) {
        const n = ie.getOrCreate(this.sourceId ?? "", e, this.context);
        return this.switchScene(n);
      }
      if (i) e = this.scenes?.indexOf(i);
      else return Ns;
    }
    if (!this.scenes?.length) return Ns;
    if (e < 0) {
      if (this.clamp) return Ns;
      e = this.scenes.length - 1;
    } else if (e >= this.scenes.length) {
      if (this.clamp) return Ns;
      e = 0;
    }
    const t = this.scenes[e];
    return this.switchScene(t);
  }
  /**
   * Unload the currently loaded scene.
   */
  unload() {
    return this.__lastSwitchScene = void 0, this.__lastSwitchScenePromise = void 0, this.__unloadCurrentScene();
  }
  /**
   * Reload the last scene that was loaded
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  async reload() {
    if (this.__lastSwitchScene) {
      const e = this.__lastSwitchScene;
      return this.__lastSwitchScene = void 0, this.switchScene(e);
    }
    return !1;
  }
  // this is the scene that was requested last
  __lastSwitchScene;
  __lastSwitchScenePromise;
  /**
   * Switch to a scene by its AssetReference.  
   * If the scene is already loaded it will be unloaded and the new scene will be loaded.  
   * If the scene is already loading it will wait for the scene to be loaded.  
   * If the scene is already loaded and the same scene is requested again it will return the same promise that was returned the first time the scene was requested.  
   * @param scene The AssetReference of the scene to switch to
   * @returns a promise that resolves to true if the scene was loaded successfully
   * @example
   * ```ts
   * const myAssetReference = new AssetReference("scene1.glb");
   * sceneSwitcher.switchScene(myAssetReference).then(res => { console.log("Scene loaded", res); });
   * ```
   */
  async switchScene(e) {
    if (!(e instanceof ie)) {
      const i = typeof e;
      if (i === "string")
        return this.select(e);
      if (i === "number")
        return this.select(e);
      if (e && e instanceof M) {
        const n = this.scenes?.indexOf(e);
        e = new ie(e.name, void 0, e), n >= 0 && (this.scenes[n] = e);
      } else
        return console.warn(`[SceneSwitcher] Can't switch to scene of type ${i}`), !1;
    }
    return e.url === this.sourceId ? (console.warn("[SceneSwitcher] Can't load own scene - prevent recursive loading", this.sourceId), !1) : this.__lastSwitchScene === e && this.__lastSwitchScenePromise ? this.__lastSwitchScenePromise : (this.__lastSwitchScene = e, this.__lastSwitchScenePromise = this.__internalSwitchScene(e), await this.__lastSwitchScenePromise);
  }
  async __unloadCurrentScene() {
    const e = this._currentScene;
    if (this._currentScene = void 0, e) {
      kt && console.log("UNLOAD", e.url, "HasURL?: " + e.hasUrl);
      const t = this.tryGetSceneEventListener(e.asset);
      if (t?.sceneClosing) {
        const i = t.sceneClosing();
        i instanceof Promise && await i;
      }
      e.hasUrl ? e.unload() : e.asset instanceof M && S.remove(e.asset);
    }
  }
  _currentlyLoadingScene;
  /** @internal */
  async __internalSwitchScene(e) {
    await this.__unloadCurrentScene();
    const t = this._currentIndex = this.scenes?.indexOf(e) ?? -1;
    try {
      this._currentlyLoadingScene = e, this._currentLoadingProgress = new ProgressEvent("progress", { loaded: 0, total: 1 });
      const i = new CustomEvent("loadscene-start", { detail: { scene: e, switcher: this, index: t } });
      this.dispatchEvent(i), this.sceneLoadingStart?.invoke(i.detail), await this.onStartLoading(), await e.loadAssetAsync((o, r) => {
        if (kt) {
          const a = r.loaded / r.total, l = "[" + "=".repeat(Math.floor(a * 20)) + "-".repeat(20 - Math.floor(a * 20)) + "]";
          console.debug(`[SceneSwitcher] Download ${(a * 100).toFixed(1)} % ${l}`, e.url);
        }
        this._currentLoadingProgress = r, this.dispatchEvent(r), this.sceneLoadingProgress?.invoke(r);
      }).catch(console.error), await this.onEndLoading();
      const n = new CustomEvent("loadscene-finished", { detail: { scene: e, switcher: this, index: t } });
      if (this.dispatchEvent(n), this._currentLoadingProgress = void 0, this._currentlyLoadingScene = void 0, n.defaultPrevented)
        return kt && console.warn("Adding loaded scene prevented:", e, n), !1;
      if (!e.asset)
        return kt && console.warn("Failed loading scene:", e), !1;
      if (this._currentIndex === t) {
        if (kt && console.log("ADD", e.url), this._currentScene = e, sE) {
          const a = this.context.mainCameraComponent?.gameObject || this.context.mainCamera;
          a?.removeFromParent();
          const l = this.gameObject.removeFromParent();
          Wi(this.context.scene, !0, !0), this.context.scene = new gi(), this.context.scene.add(l), a && this.context.scene.add(a);
        }
        if (S.add(e.asset, this.gameObject), this.useSceneLighting && this.context.sceneLighting.enable(e), this.useSceneBackground) {
          const a = this.context.lightmaps.tryGetSkybox(e.url);
          a ? (a.mapping = _s, this.context.scene.background = a) : kt && console.warn("SceneSwitcher: Can't find skybox for scene " + e.url);
        }
        if (this.useHistory && t >= 0) {
          let a = t.toString();
          if (this.useSceneName && (e instanceof M ? a = e.name : e.url && (a = H_(e.url))), this.queryParameterName?.length)
            Yh(this.queryParameterName, a, this.useHistory);
          else {
            const l = history.state, c = this.guid + "::" + t;
            l !== c && history.pushState(c, "unused", location.href);
          }
        }
        const o = this.tryGetSceneEventListener(e.asset);
        if (o?.sceneOpened) {
          const a = o.sceneOpened(this);
          a instanceof Promise && await a;
        }
        const r = new CustomEvent("scene-opened", { detail: { scene: e, switcher: this, index: t } });
        return this.dispatchEvent(r), this.sceneLoaded?.invoke(this), !0;
      }
    } catch (i) {
      console.error(i);
    }
    return !1;
  }
  preload(e) {
    if (e >= 0 && e < this.scenes.length) {
      const t = this.scenes[e];
      if (t instanceof ie)
        return t.preload();
    }
    return Ns;
  }
  tryLoadFromQueryParam() {
    if (!this.queryParameterName?.length) return Ns;
    const e = w(this.queryParameterName);
    return typeof e == "boolean" ? Ns : this.trySelectSceneFromValue(e);
  }
  /** try to select a scene from a string or index */
  trySelectSceneFromValue(e) {
    if (typeof e == "string") {
      const t = parseInt(e);
      if (t >= 0 && t < this.scenes.length)
        return this.select(t);
      {
        const i = e.toLowerCase();
        for (let n = 0; n < this.scenes.length; n++) {
          const o = this.scenes[n];
          if (!o) continue;
          if ((o instanceof M ? o.name : H_(o.url)).toLowerCase().includes(i))
            return this.select(n);
        }
      }
    } else if (typeof e == "number" && e >= 0 && e < this.scenes.length)
      return this.select(e);
    return rn() && console.warn('Can not find scene: "' + e + '"', this), Ns;
  }
  _lastLoadingScene = void 0;
  _loadingScenePromise = void 0;
  _isCurrentlyLoading = !1;
  _currentLoadingProgress = void 0;
  async onStartLoading() {
    if (this._isCurrentlyLoading = !0, this.loadingScene && (this._lastLoadingScene !== this.loadingScene && (this._loadingScenePromise = void 0), this._lastLoadingScene = this.loadingScene, this._loadingScenePromise || (this._loadingScenePromise = this.loadingScene?.loadAssetAsync().then((e) => e != null)), await this._loadingScenePromise, this._isCurrentlyLoading && this.loadingScene?.asset)) {
      kt && console.log("Add loading scene", this.loadingScene.url, this.loadingScene.asset);
      const e = this.loadingScene.asset;
      S.add(e, this.gameObject);
      const t = this.tryGetSceneEventListener(e);
      if (t?.sceneOpened) {
        const i = t.sceneOpened(this);
        i instanceof Promise && await i;
      }
    }
    if (this._isCurrentlyLoading) {
      const e = this.tryGetSceneEventListener(this.gameObject);
      if (e && e.sceneOpened) {
        const t = e.sceneOpened(this);
        t instanceof Promise && await t;
      }
    }
  }
  async onEndLoading() {
    if (this._isCurrentlyLoading = !1, this.loadingScene?.asset) {
      kt && console.log("Remove loading scene", this.loadingScene.url);
      const e = this.loadingScene.asset, t = this.tryGetSceneEventListener(e);
      if (typeof t?.sceneClosing == "function") {
        const i = t.sceneClosing();
        i instanceof Promise && await i;
      }
      S.remove(e);
    }
    if (!this._isCurrentlyLoading) {
      const e = this.tryGetSceneEventListener(this.gameObject);
      if (e && e.sceneClosing) {
        const t = e.sceneClosing();
        t instanceof Promise && await t;
      }
    }
  }
  tryGetSceneEventListener(e, t = 0) {
    if (!e)
      return null;
    const i = S.foreachComponent(e, (n) => {
      const o = n;
      if (o.sceneClosing || o.sceneOpened) return o;
    });
    if (t === 0 && !i && e.children.length)
      for (const n of e.children) {
        const o = this.tryGetSceneEventListener(n, t + 1);
        if (o) return o;
      }
    return i || null;
  }
}
_t([
  u()
], Ze.prototype, "autoLoadFirstScene");
_t([
  u(ie)
], Ze.prototype, "scenes");
_t([
  u(ie)
], Ze.prototype, "loadingScene");
_t([
  u()
], Ze.prototype, "queryParameterName");
_t([
  u()
], Ze.prototype, "useSceneName");
_t([
  u()
], Ze.prototype, "clamp");
_t([
  u()
], Ze.prototype, "useHistory");
_t([
  u()
], Ze.prototype, "useKeyboard");
_t([
  u()
], Ze.prototype, "useSwipe");
_t([
  u()
], Ze.prototype, "useSceneLighting");
_t([
  u()
], Ze.prototype, "useSceneBackground");
_t([
  u()
], Ze.prototype, "preloadNext");
_t([
  u()
], Ze.prototype, "preloadPrevious");
_t([
  u()
], Ze.prototype, "preloadConcurrent");
_t([
  u()
], Ze.prototype, "createMenuButtons");
_t([
  u(me)
], Ze.prototype, "sceneLoadingStart");
_t([
  u(me)
], Ze.prototype, "sceneLoadingProgress");
_t([
  u(me)
], Ze.prototype, "sceneLoaded");
function H_(s) {
  const t = s.split("/").pop()?.split(".").shift();
  return t?.length ? t : s;
}
class oE {
  /** Maximum number of scenes to preload ahead of the current scene */
  maxLoadAhead;
  /** Maximum number of scenes to preload behind the current scene */
  maxLoadBehind;
  /** Maximum number of scenes that can be preloaded concurrently */
  maxConcurrent;
  _isRunning = !1;
  _switcher;
  _loadTasks = [];
  _maxConcurrentLoads = 1;
  /**
   * Creates a new PreLoadScheduler instance
   * @param rooms The SceneSwitcher that this scheduler belongs to
   * @param ahead Number of scenes to preload ahead of current scene
   * @param behind Number of scenes to preload behind current scene
   * @param maxConcurrent Maximum number of concurrent preloads allowed
   */
  constructor(e, t = 1, i = 1, n = 2) {
    this._switcher = e, this.maxLoadAhead = t, this.maxLoadBehind = i, this.maxConcurrent = n;
  }
  /**
   * Starts the preloading process after a specified delay
   * @param delay Time in milliseconds to wait before starting preload
   */
  begin(e) {
    if (this._isRunning) return;
    kt && console.log("Preload begin", { delay: e }), this._isRunning = !0;
    let t = -10, i, n;
    const o = this._switcher.scenes, r = Date.now() + e, a = setInterval(() => {
      if (this.allLoaded() && (kt && console.log("All scenes (pre-)loaded"), this.stop()), !this._isRunning) {
        clearInterval(a);
        return;
      }
      if (Date.now() < r || this.canLoadNewScene() === !1) return;
      (t === -10 || t !== this._switcher.currentIndex) && (t = this._switcher.currentIndex, n = 0, i = 0);
      const l = n % 2 === 0;
      l && (i += 1), n += 1;
      const c = l ? this.maxLoadAhead : this.maxLoadBehind;
      if (i > c) return;
      const h = l ? t + i : t - i;
      if (!(h < 0) && !(h < 0 || h >= o.length) && !this._loadTasks.some((d) => d.index === h)) {
        const d = o[h];
        kt && console.log("Preload scene", { roomIndex: h, searchForward: l, lastRoom: t, currentIndex: this._switcher.currentIndex, tasks: this._loadTasks.length }, d?.url), new rE(h, d, this._loadTasks);
      }
    }, 200);
  }
  /**
   * Stops the preloading process
   */
  stop() {
    this._isRunning = !1;
  }
  /**
   * Checks if a new scene can be loaded based on current load limits
   * @returns True if a new scene can be loaded, false otherwise
   */
  canLoadNewScene() {
    return this._loadTasks.length < this._maxConcurrentLoads;
  }
  /**
   * Checks if all scenes in the SceneSwitcher have been loaded
   * @returns True if all scenes are loaded, false otherwise
   */
  allLoaded() {
    if (this._switcher.scenes) {
      for (const e of this._switcher.scenes)
        if (e?.isLoaded && e.isLoaded() === !1)
          return !1;
    }
    return !0;
  }
}
class rE {
  /** The index of the scene in the scenes array */
  index;
  /** The AssetReference to be loaded */
  asset;
  /** The collection of active load tasks this task belongs to */
  tasks;
  /**
   * Creates a new LoadTask and begins loading immediately
   * @param index The index of the scene in the scenes array
   * @param asset The AssetReference to preload
   * @param tasks The collection of active load tasks
   */
  constructor(e, t, i) {
    this.index = e, this.asset = t, this.tasks = i, i.push(this), this.awaitLoading();
  }
  /**
   * Asynchronously loads the asset and removes this task from the active tasks list when complete
   */
  async awaitLoading() {
    this.asset && !this.asset.isLoaded() && (kt && console.log("Preload start: " + this.asset.url, this.index), await this.asset.preload(), kt && console.log("Preload finished: " + this.asset.url, this.index));
    const e = this.tasks.indexOf(this);
    e >= 0 && this.tasks.splice(e, 1);
  }
}
function aE() {
  return new Promise((s, e) => {
    const i = () => {
      i != null && (document.removeEventListener("pointerdown", i), document.removeEventListener("click", i), document.removeEventListener("dragstart", i), document.removeEventListener("touchstart", i), s());
    };
    document.addEventListener("pointerdown", i), document.addEventListener("click", i), document.addEventListener("dragstart", i), document.addEventListener("touchstart", i);
  });
}
async function lE(s) {
  await aE(), s();
}
var cE = Object.defineProperty, hE = Object.getOwnPropertyDescriptor, Pi = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? hE(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && cE(e, t, n), n;
};
const at = w("debugvideo");
var dw = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.AdjustHeight = 1] = "AdjustHeight", s[s.AdjustWidth = 2] = "AdjustWidth", s))(dw || {}), uw = /* @__PURE__ */ ((s) => (s[s.VideoClip = 0] = "VideoClip", s[s.Url = 1] = "Url", s))(uw || {}), fw = /* @__PURE__ */ ((s) => (s[s.CameraFarPlane = 0] = "CameraFarPlane", s[s.CameraNearPlane = 1] = "CameraNearPlane", s[s.RenderTexture = 2] = "RenderTexture", s[s.MaterialOverride = 3] = "MaterialOverride", s))(fw || {});
class pt extends T {
  playOnAwake = !0;
  aspectMode = 0;
  clip = null;
  source = 1;
  get url() {
    return this._url;
  }
  /**
   * The video clip to play. 
   */
  set url(e) {
    const i = this._url !== e;
    this.__didAwake ? i && this.setClipURL(e ?? "") : this._url = e;
  }
  _url = null;
  renderMode;
  targetMaterialProperty;
  targetMaterialRenderer;
  targetTexture;
  time = 0;
  _playbackSpeed = 1;
  get playbackSpeed() {
    return this._videoElement?.playbackRate ?? this._playbackSpeed;
  }
  /**
   * Set the video playback speed. Increasing this value will speed up the video, decreasing it will slow it down.
   */
  set playbackSpeed(e) {
    this._playbackSpeed = e, this._videoElement && (this._videoElement.playbackRate = e);
  }
  _isLooping = !1;
  get isLooping() {
    return this._videoElement?.loop ?? this._isLooping;
  }
  set isLooping(e) {
    this._isLooping = e, this._videoElement && (this._videoElement.loop = e);
  }
  /**
   * @returns the current time of the video in seconds
   */
  get currentTime() {
    return this._videoElement?.currentTime ?? this.time;
  }
  /**
   * set the current time of the video in seconds
   */
  set currentTime(e) {
    this._videoElement ? this._videoElement.currentTime = e : this.time = e;
  }
  /**
   * @returns true if the video is currently playing
   */
  get isPlaying() {
    const e = this._videoElement;
    if (e) {
      if (e.currentTime > 0 && !e.paused && !e.ended && e.readyState > e.HAVE_CURRENT_DATA)
        return !0;
      if (e.srcObject && e.srcObject.active)
        return !0;
    }
    return !1;
  }
  get crossOrigin() {
    return this._videoElement?.crossOrigin ?? this._crossOrigin;
  }
  set crossOrigin(e) {
    this._crossOrigin = e, this._videoElement && (e !== null ? this._videoElement.setAttribute("crossorigin", e) : this._videoElement.removeAttribute("crossorigin"));
  }
  /**
   * the material that is used to render the video
   */
  get videoMaterial() {
    return !this._videoMaterial && !this.create(!1) ? null : this._videoMaterial;
  }
  /**
   * the video texture that is used to render the video
   */
  get videoTexture() {
    return !this._videoTexture && !this.create(!1) ? null : this._videoTexture;
  }
  /**
   * the HTMLVideoElement that is used to play the video
   */
  get videoElement() {
    return !this._videoElement && !this.create(!1) ? null : this._videoElement;
  }
  /**
   * Request the browser to enter picture in picture mode
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Picture-in-Picture_API
   * @returns the promise returned by the browser
   */
  requestPictureInPicture() {
    return this._videoElement ? this._videoElement.requestPictureInPicture() : null;
  }
  /**
   * @returns true if the video is muted
   */
  get muted() {
    return this._videoElement?.muted ?? this._muted;
  }
  /**
   * set the video to be muted
   */
  set muted(e) {
    this._muted = e, this._videoElement && (this._videoElement.muted = e);
  }
  _muted = !1;
  /**
   * The current video clip that is being played
   */
  get currentVideo() {
    return this.clip;
  }
  set audioOutputMode(e) {
    e !== this._audioOutputMode && (e === 1 && L() && console.warn("VideoAudioOutputMode.AudioSource is not yet implemented"), this._audioOutputMode = e, this.updateVideoElementSettings());
  }
  get audioOutputMode() {
    return this._audioOutputMode;
  }
  _audioOutputMode = 2;
  /** Set this to false to pause video playback while the tab is not active 
   * @default true
  */
  playInBackground = !0;
  _crossOrigin = "anonymous";
  _videoElement = null;
  _videoTexture = null;
  _videoMaterial = null;
  _isPlaying = !1;
  wasPlaying = !1;
  /** ensure's the video element has been created and will start loading the clip */
  preloadVideo() {
    at && console.log("Video Preload: " + this.name, this.clip), this.create(!1);
  }
  /** @deprecated use `preloadVideo()` */
  preload() {
    this.preloadVideo();
  }
  /** Set a new video stream  
   * starts to play automatically if the videoplayer hasnt been active before and playOnAwake is true */
  setVideo(e) {
    this.clip = e, this.source = 0, this._videoElement ? (this._videoElement.srcObject = e, this._isPlaying && this.play(), this.updateAspect()) : this.create(this.playOnAwake);
  }
  setClipURL(e) {
    this._url !== e && (this._url = e, this.source = 1, at && console.log("set url", e), this._videoElement ? e.endsWith(".m3u8") || e.includes(".m3u") ? this.ensureM3UCanBePlayed() : (this._videoElement.src = e, this._isPlaying && (this.stop(), this.play())) : this.create(this.playOnAwake));
  }
  /** @internal */
  onEnable() {
    at && console.log("VideoPlayer.onEnable", uw[this.source], this.clip, this.url, this), window.addEventListener("visibilitychange", this.visibilityChanged), this.playOnAwake === !0 ? this.create(!0) : this.preloadVideo(), this.screenspace ? this._overlay?.start() : this._overlay?.stop();
  }
  /** @internal */
  onDisable() {
    window.removeEventListener("visibilitychange", this.visibilityChanged), this._overlay?.stop(), this.pause();
  }
  visibilityChanged = (e) => {
    switch (document.visibilityState) {
      case "hidden":
        this.playInBackground || (this.wasPlaying = this._isPlaying, this.pause());
        break;
      case "visible":
        this.wasPlaying && !this._isPlaying && this.play();
        break;
    }
  };
  /** @internal */
  onDestroy() {
    this._videoElement && (this.videoElement?.remove(), this._videoElement = null), this._videoTexture && (this._videoTexture.dispose(), this._videoTexture = null);
  }
  _receivedInput = !1;
  /**
   * @internal
   */
  constructor() {
    super(), lE(() => {
      this._receivedInput = !0, this.updateVideoElementSettings();
    }), this._targetObjects = [], w("videoscreenspace") && window.addEventListener("keydown", (e) => {
      e.key === "f" && (this.screenspace = !this.screenspace);
    });
  }
  /** start playing the video source */
  play() {
    if (this._videoElement || this.create(!1), !this._videoElement) {
      at && console.warn("Can not play: no video element found", this);
      return;
    }
    if (!(this._isPlaying && !this._videoElement?.ended && !this._videoElement?.paused)) {
      if (this._isPlaying = !0, this._receivedInput || (this._videoElement.muted = !0), this.handleBeginPlaying(!1), this.shouldUseM3U) {
        this.ensureM3UCanBePlayed();
        return;
      }
      at && console.log("Video Play()", this.clip, this._videoElement, this.time), this._videoElement.currentTime = this.time, this._videoElement.play().catch((e) => {
        console.log(e), at && console.error("Error playing video", e, "CODE=" + e.code, this.videoElement?.src, this), setTimeout(() => {
          this._isPlaying && !this.destroyed && this.activeAndEnabled && this.play();
        }, 1e3);
      }), at && console.log("play", this._videoElement, this.time);
    }
  }
  /**
   * Stop the video playback. This will reset the video to the beginning
   */
  stop() {
    this._isPlaying = !1, this.time = 0, this._videoElement && (this._videoElement.currentTime = 0, this._videoElement.pause(), at && console.log("STOP", this));
  }
  /**
   * Pause the video playback
   */
  pause() {
    this.time = this._videoElement?.currentTime ?? 0, this._isPlaying = !1, this._videoElement?.pause(), at && console.log("PAUSE", this, this.currentTime);
  }
  /** create the video element and assign the video source url or stream */
  create(e) {
    let t;
    switch (this.source) {
      case 0:
        t = this.clip;
        break;
      case 1:
        t = this.url, !t?.length && typeof this.clip == "string" && (t = this.clip);
        break;
    }
    return t ? (this._videoElement || (at && console.warn("Create VideoElement", this), this._videoElement = this.createVideoElement(), this.context.domElement.shadowRoot.prepend(this._videoElement), this.updateVideoElementStyles()), typeof t == "string" ? (at && console.log("Set Video src", t), this._videoElement.src = t) : (at && console.log("Set Video srcObject", t), this._videoElement.srcObject = t), this._videoTexture || (this._videoTexture = new Xx(this._videoElement)), this._videoTexture.flipY = !1, this._videoTexture.colorSpace = Cs, e && this.handleBeginPlaying(e), at && console.log("Video: handle playing done...", t, e), !0) : (at && console.warn("No video source set", this), !1);
  }
  updateAspect() {
    this.aspectMode !== 0 && this.startCoroutine(this.updateAspectImpl());
  }
  _overlay = null;
  /**
   * If true the video will be rendered in screenspace mode and overlayed on top of the scene.
   * Alternatively you can also request the video to be played in PictureInPicture mode by calling `requestPictureInPicture()`
   */
  get screenspace() {
    return this._overlay?.enabled ?? !1;
  }
  set screenspace(e) {
    if (e) {
      if (!this._videoTexture) return;
      this._overlay || (this._overlay = new dE(this.context)), this._overlay.add(this._videoTexture);
    } else this._overlay?.remove(this._videoTexture);
    this._overlay && (this._overlay.enabled = e);
  }
  _targetObjects;
  createVideoElement() {
    const e = document.createElement("video");
    return this._crossOrigin && e.setAttribute("crossorigin", this._crossOrigin), at && console.log("created video element", e), e;
  }
  handleBeginPlaying(e) {
    if (!this.activeAndEnabled || !this._videoElement) return;
    this._targetObjects.length = 0;
    let t = this.gameObject;
    switch (this.renderMode) {
      case 3:
        t = this.targetMaterialRenderer?.gameObject, t || (t = S.getComponent(this.gameObject, Hi)?.gameObject);
        break;
      case 2:
        console.error("VideoPlayer renderTexture not implemented yet. Please use material override instead");
        return;
    }
    if (!t) {
      console.error("Missing target for video material renderer", this.name, fw[this.renderMode], this);
      return;
    }
    const i = t.material;
    if (i) {
      this._targetObjects.push(t), i !== this._videoMaterial && (this._videoMaterial = i.clone(), t.material = this._videoMaterial);
      const n = "map", o = this._videoMaterial;
      if (!this.targetMaterialProperty)
        o[n] = this._videoTexture;
      else
        switch (this.targetMaterialProperty) {
          default:
            o[n] = this._videoTexture;
            break;
        }
    } else {
      console.warn("Can not play video, no material found, this might be a multimaterial case which is not supported yet");
      return;
    }
    this.updateVideoElementSettings(), this.updateVideoElementStyles(), e && (this.shouldUseM3U && this.ensureM3UCanBePlayed(), this.play());
  }
  updateVideoElementSettings() {
    if (!this._videoElement) return;
    this._videoElement.loop = this._isLooping, this._videoElement.currentTime = this.currentTime, this._videoElement.playbackRate = this._playbackSpeed, this._videoElement.playsInline = !0;
    let e = !this._receivedInput || this.audioOutputMode === 0;
    !e && this._muted && (e = !0), this._videoElement.muted = e, this.playOnAwake && (this._videoElement.autoplay = !0);
  }
  updateVideoElementStyles() {
    this._videoElement && (this._videoElement.style.userSelect = "none", this._videoElement.style.visibility = "hidden", this._videoElement.style.display = "none", this.updateAspect());
  }
  _updateAspectRoutineId = -1;
  *updateAspectImpl() {
    const e = ++this._updateAspectRoutineId, t = void 0, i = this.clip;
    for (; e === this._updateAspectRoutineId && this.aspectMode !== 0 && this.clip && i === this.clip && this._isPlaying; ) {
      if (!i || typeof i == "string")
        return;
      let n;
      for (const o of i.getVideoTracks()) {
        const r = o.getSettings();
        if (r && r.width && r.height) {
          n = r.width / r.height;
          break;
        } else
          n = this.context.renderer.domElement.clientWidth / this.context.renderer.domElement.clientHeight;
      }
      if (n === void 0) {
        for (let o = 0; o < 10; o++)
          yield;
        if (!this.isPlaying) break;
        continue;
      }
      if (t === n) {
        yield;
        continue;
      }
      for (const o of this._targetObjects) {
        let r = 1;
        if (o.parent) {
          const a = $e(o.parent);
          r = a.x / a.y;
        }
        switch (this.aspectMode) {
          case 1:
            o.scale.y = 1 / n * o.scale.x * r;
            break;
          case 2:
            o.scale.x = n * o.scale.y * r;
            break;
        }
      }
      for (let o = 0; o < 3; o++)
        yield;
    }
  }
  get shouldUseM3U() {
    return this.url != null && (this.url.endsWith(".m3u8") || this.url.endsWith(".m3u")) && this.source === 1;
  }
  ensureM3UCanBePlayed() {
    if (!this.shouldUseM3U) return;
    let e = document.head.querySelector("script[data-hls_library]");
    e ? globalThis.Hls ? this.onHlsAvailable() : e.addEventListener("load", this.onHlsAvailable) : (at && console.log("HLS: load script"), e = document.createElement("script"), e.dataset.hls_library = "hls.js", e.src = "https://cdn.jsdelivr.net/npm/hls.js@1", e.addEventListener("load", this.onHlsAvailable), document.head.append(e));
  }
  _hls;
  onHlsAvailable = () => {
    at && console.log("HLS: available", this.clip), !(!this.shouldUseM3U || !this.url) && (this._hls || (this._hls = new Hls()), this.videoElement.autoplay = !0, this._hls.loadSource(this.url), this._hls.attachMedia(this.videoElement), this._videoElement?.play(), at && console.log("HLS: loaded", this.clip));
  };
}
Pi([
  u()
], pt.prototype, "playOnAwake", 2);
Pi([
  u()
], pt.prototype, "aspectMode", 2);
Pi([
  u(URL)
], pt.prototype, "clip", 2);
Pi([
  u()
], pt.prototype, "source", 2);
Pi([
  u(URL)
], pt.prototype, "url", 1);
Pi([
  u()
], pt.prototype, "renderMode", 2);
Pi([
  u()
], pt.prototype, "targetMaterialProperty", 2);
Pi([
  u(Hi)
], pt.prototype, "targetMaterialRenderer", 2);
Pi([
  u(Te)
], pt.prototype, "targetTexture", 2);
Pi([
  u()
], pt.prototype, "time", 2);
Pi([
  u()
], pt.prototype, "playbackSpeed", 1);
Pi([
  u()
], pt.prototype, "isLooping", 1);
Pi([
  u()
], pt.prototype, "audioOutputMode", 1);
class dE {
  context;
  constructor(e) {
    this.context = e, this._input = new uE(this);
  }
  get enabled() {
    return this._isInScreenspaceMode;
  }
  set enabled(e) {
    e ? this.start() : this.stop();
  }
  add(e) {
    this._videos.indexOf(e) === -1 && this._videos.push(e);
  }
  remove(e) {
    if (!e) return;
    const t = this._videos.indexOf(e);
    t >= 0 && this._videos.splice(t, 1);
  }
  start() {
    if (this._isInScreenspaceMode || this._videos.length < 0) return;
    const e = this._videos[this._videos.length - 1];
    if (!e) return;
    if (this._isInScreenspaceMode = !0, !this._screenspaceModeQuad) {
      if (this._screenspaceModeQuad = Oa.createPrimitive(ma.Quad, {
        material: new fE(e)
      }), !this._screenspaceModeQuad) return;
      this._screenspaceModeQuad.geometry.scale(2, 2, 2);
    }
    const t = this._screenspaceModeQuad;
    this.context.scene.add(t), this.updateScreenspaceMaterialUniforms();
    const i = t.material;
    i?.reset(), this._input?.enable(i);
  }
  stop() {
    this._isInScreenspaceMode = !1, this._screenspaceModeQuad && (this._input?.disable(), this._screenspaceModeQuad.removeFromParent());
  }
  updateScreenspaceMaterialUniforms() {
    const e = this._screenspaceModeQuad?.material;
    e && (e.screenAspect = this.context.domElement.clientWidth / this.context.domElement.clientHeight);
  }
  _videos = [];
  _screenspaceModeQuad;
  _isInScreenspaceMode = !1;
  _input;
}
class uE {
  _onResizeScreenFn;
  _onKeyUpFn;
  _onMouseWheelFn;
  context;
  overlay;
  constructor(e) {
    this.overlay = e, this.context = e.context;
  }
  _material;
  enable(e) {
    this._material = e, window.addEventListener("resize", this._onResizeScreenFn = () => {
      this.overlay.updateScreenspaceMaterialUniforms();
    }), window.addEventListener("keyup", this._onKeyUpFn = (n) => {
      n.key === "Escape" && this.overlay.stop();
    }), window.addEventListener("wheel", this._onMouseWheelFn = (n) => {
      this.overlay.enabled && (e.zoom += n.deltaY * 5e-4, n.preventDefault());
    }, { passive: !1 });
    const t = new J();
    window.addEventListener("mousemove", (n) => {
      if (this.overlay.enabled && this.context.input.getPointerPressed(0)) {
        const o = new J(n.movementX, n.movementY);
        o.x /= this.context.domElement.clientWidth, o.y /= this.context.domElement.clientHeight, t.set(o.x, o.y), t.multiplyScalar(e.zoom / -this.context.time.deltaTime * 0.01), e.offset = e.offset.add(t);
      }
    }), window.addEventListener("pointermove", (n) => {
      this.overlay.enabled && this.context.input.getPointerPressed(0) && this.context.input.getTouchesPressedCount() === 1 && (t.set(n.movementX, n.movementY), t.multiplyScalar(e.zoom * -this.context.time.deltaTime * 0.05), e.offset = e.offset.add(t));
    });
    let i = 0;
    window.addEventListener("touchstart", (n) => {
      if (n.touches.length < 2) {
        this.context.time.time - i < 0.3 && this.overlay.stop(), i = this.context.time.time;
        return;
      }
      this._isPinching = !0, this._lastPinch = 0;
    }), window.addEventListener("touchmove", (n) => {
      if (!this._isPinching || !this._material) return;
      const o = n.touches[0], r = n.touches[1], a = o.clientX - r.clientX, l = o.clientY - r.clientY, c = Math.sqrt(a * a + l * l);
      if (this._lastPinch !== 0) {
        const h = c - this._lastPinch;
        this._material.zoom -= h * 4e-3;
      }
      this._lastPinch = c;
    }), window.addEventListener("touchend", () => {
      this._isPinching = !1;
    });
  }
  _isPinching = !1;
  _lastPinch = 0;
  disable() {
    this._onResizeScreenFn && (window.removeEventListener("resize", this._onResizeScreenFn), this._onResizeScreenFn = void 0), this._onKeyUpFn && (window.removeEventListener("keyup", this._onKeyUpFn), this._onKeyUpFn = void 0), this._onMouseWheelFn && (window.removeEventListener("wheel", this._onMouseWheelFn), this._onMouseWheelFn = void 0);
  }
}
class fE extends Ln {
  set screenAspect(e) {
    this.uniforms.screenAspect.value = e, this.needsUpdate = !0;
  }
  set offset(e) {
    const t = this.uniforms.offsetScale.value;
    t.x = e.x, t.y = e.y, this.uniforms.offsetScale.value = t, this.needsUpdate = !0;
  }
  _offset = new J();
  get offset() {
    const e = this.uniforms.offsetScale.value;
    return this._offset.set(e.x, e.y), this._offset;
  }
  set zoom(e) {
    const t = this.uniforms.offsetScale.value;
    e < 1e-3 && (e = 1e-3), t.z = e, this.needsUpdate = !0;
  }
  get zoom() {
    return this.uniforms.offsetScale.value.z;
  }
  reset() {
    this.offset = this.offset.set(0, 0), this.zoom = 1, this.needsUpdate = !0;
  }
  // maxZoom : number = 10
  constructor(e) {
    super(), this.uniforms = {
      map: { value: e },
      screenAspect: { value: 1 },
      offsetScale: { value: new de(0, 0, 1, 1) }
    }, this.vertexShader = `
        uniform sampler2D map;
        uniform float screenAspect;
        uniform vec4 offsetScale;
        varying vec2 vUv;

        void main() {

            gl_Position = vec4( position , 1.0 );
            vUv = uv;
            vUv.y = 1. - vUv.y;

            // fit into screen
            ivec2 res = textureSize(map, 0);
            float videoAspect = float(res.x) / float(res.y);
            float aspect = videoAspect / screenAspect;
            if(aspect >= 1.0) 
            {
                vUv.y = vUv.y * aspect;
                float offset = (1. - aspect) * .5;
                vUv.y = vUv.y + offset;
            }
            else
            {
                vUv.x = vUv.x / aspect;
                float offset = (1. - 1. / aspect) * .5;
                vUv.x = vUv.x + offset;
            }

            vUv.x -= .5;
            vUv.y -= .5;

            vUv.x *= offsetScale.z;
            vUv.y *= offsetScale.z;
            vUv.x += offsetScale.x;
            vUv.y += offsetScale.y;

            vUv.x += .5;
            vUv.y += .5;
        }

        `, this.fragmentShader = `
        uniform sampler2D map;
        varying vec2 vUv;
        void main() {
            if(vUv.x < 0. || vUv.x > 1. || vUv.y < 0. || vUv.y > 1.)
                gl_FragColor = vec4(0., 0., 0., 1.);
            else
            {
                vec4 texcolor = texture2D(map, vUv);
                gl_FragColor = texcolor;
            }
        }
        `;
  }
}
var pE = Object.defineProperty, mE = Object.getOwnPropertyDescriptor, jc = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? mE(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && pE(e, t, n), n;
};
const vt = w("debugscreensharing");
var pw = /* @__PURE__ */ ((s) => (s[s.Screen = 0] = "Screen", s[s.Camera = 1] = "Camera", s[s.Canvas = 2] = "Canvas", s[s.Microphone = 3] = "Microphone", s))(pw || {});
class Or extends T {
  allowStartOnClick = !0;
  /** @internal */
  onPointerEnter() {
    this.context.connection.allowEditing != !1 && this.allowStartOnClick && this.context.input.setCursor("pointer");
  }
  /** @internal */
  onPointerExit() {
    this.context.connection.allowEditing != !1 && this.allowStartOnClick && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerClick(e) {
    if (this.context.connection.allowEditing != !1 && this.allowStartOnClick && !(e && e.pointerId !== 0)) {
      if (this.isReceiving && this.videoPlayer?.isPlaying) {
        this.videoPlayer && (this.videoPlayer.screenspace = !this.videoPlayer.screenspace);
        return;
      }
      if (this.isSending) {
        this.close();
        return;
      }
      this.share();
    }
  }
  autoConnect = !1;
  set videoPlayer(e) {
    this._videoPlayer && (this.isSending || this.isReceiving) && this._videoPlayer.stop(), this._videoPlayer = e, this._videoPlayer && this._currentStream && (this.isSending || this.isReceiving) && this._videoPlayer.setVideo(this._currentStream);
  }
  get videoPlayer() {
    return this._videoPlayer;
  }
  _videoPlayer;
  _audioSource;
  /**
   * When enabled the video will be displayed in the screenspace of the VideoPlayer component.
   */
  get screenspace() {
    return this.videoPlayer?.screenspace ?? !1;
  }
  set screenspace(e) {
    this.videoPlayer && (this.videoPlayer.screenspace = e);
  }
  device = "Screen";
  deviceName;
  /**
   * Filter which device should be chosen for sharing by id or label.  
   * Assign a method to this property to manually filter the available devices.  
   */
  deviceFilter;
  /**
   * the current stream that is being shared or received  
   * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream
   */
  get currentScream() {
    return this._currentStream;
  }
  get currentMode() {
    return this._currentMode;
  }
  /**
   * @returns true if the component is currently sending a stream
   */
  get isSending() {
    return this._currentStream?.active && this._currentMode === 1;
  }
  /**
   * @returns true if the component is currently receiving a stream
   */
  get isReceiving() {
    if (this._currentMode === 2) {
      if (!this._currentStream || this._currentStream.active === !1) return !1;
      const e = this._currentStream.getTracks();
      for (const t of e)
        if (t.readyState === "live") return !0;
    }
    return !1;
  }
  get requiresVideoPlayer() {
    return this.device !== "Microphone";
  }
  _net;
  _requestOpen = !1;
  _currentStream = null;
  _currentMode = 0;
  /** @internal */
  awake() {
    typeof this.device == "number" && (this.device = pw[this.device]), vt && console.log("Screensharing", this.name, this), ln.registerWaitForAllowAudio(() => {
      this._videoPlayer && this._currentStream && this._currentMode === 2 && (this._videoPlayer.playInBackground = !0, this._videoPlayer.setVideo(this._currentStream));
    }), this._net = new tu(this);
  }
  /** @internal */
  onEnable() {
    this._net?.enable(), this._net?.addEventListener(ps.StreamReceived, this.onReceiveStream), this._net?.addEventListener(ps.StreamEnded, this.onCallEnded), this.context.connection.beginListen(ee.JoinedRoom, this.onJoinedRoom), this.autoConnect && Os(1e3).then(() => (this.enabled && this.autoConnect && !this.isReceiving && !this.isSending && this.context.connection.isInRoom && this.share(), 0));
  }
  /** @internal */
  onDisable() {
    this._net?.removeEventListener(ps.StreamReceived, this.onReceiveStream), this._net?.removeEventListener(ps.StreamEnded, this.onCallEnded), this.context.connection.stopListen(ee.JoinedRoom, this.onJoinedRoom), this._net?.disable(), this.close();
  }
  onJoinedRoom = async () => {
    await Os(1e3), this.autoConnect && !this.isSending && !this.isReceiving && this.context.connection.isInRoom && this.share();
  };
  _ensureVideoPlayer() {
    const e = new pt();
    e.aspectMode = dw.AdjustWidth, S.addComponent(this.gameObject, e), this._videoPlayer = e;
  }
  _activeShareRequest = null;
  /** Call to begin screensharing */
  async share(e) {
    return this._activeShareRequest ? this._activeShareRequest : (this._activeShareRequest = this.internalShare(e), this._activeShareRequest.then(() => this._activeShareRequest = null));
  }
  async internalShare(e) {
    if (this.context.connection.isInRoom === !1) {
      console.warn("Can not start screensharing: requires network connection"), L() && ge("Can not start screensharing: requires network connection. Add a SyncedRoom component or join a room first.");
      return;
    }
    if (e?.device && (this.device = e.device), !this.videoPlayer && this.requiresVideoPlayer && (this._videoPlayer || (this._videoPlayer = S.getComponent(this.gameObject, pt) ?? void 0), this.videoPlayer || this._ensureVideoPlayer(), !this.videoPlayer)) {
      console.warn("Can not share video without a videoPlayer assigned");
      return;
    }
    this._requestOpen = !0;
    try {
      const t = e?.constraints ?? {
        echoCancellation: !0,
        autoGainControl: !1
      }, i = {
        video: t,
        audio: t
      }, n = i.video;
      switch (n !== void 0 && typeof n != "boolean" && (n.width || (n.width = { max: 1920 }), n.height || (n.height = { max: 1920 }), n.aspectRatio || (n.aspectRatio = { ideal: 1.7777777778 }), n.frameRate || (n.frameRate = { ideal: 24 }), n.facingMode || (n.facingMode = { ideal: "user" })), this.device) {
        // Capture a connected camera
        case "Camera":
          this.tryShareUserCamera(i, e);
          break;
        // capture any screen, will show a popup
        case "Screen":
          {
            if (!navigator.mediaDevices.getDisplayMedia) {
              console.error("No getDisplayMedia support");
              return;
            }
            const a = await navigator.mediaDevices.getDisplayMedia(i);
            this._requestOpen ? this.setStream(
              a,
              1
              /* Sending */
            ) : ms(a);
          }
          break;
        // capture the canvas meaning the threejs view
        case "Canvas":
          const r = this.context.renderer.domElement.captureStream(0);
          this.setStream(
            r,
            1
            /* Sending */
          );
          break;
        case "Microphone":
          {
            if (!navigator.mediaDevices.getUserMedia) {
              console.error("No getDisplayMedia support");
              return;
            }
            i.video = !1;
            const a = await navigator.mediaDevices.getUserMedia(i);
            this._requestOpen ? this.setStream(
              a,
              1
              /* Sending */
            ) : ms(a);
          }
          break;
        default:
          console.error("Can not start screen sharing: Unknown device type", this.device);
      }
    } catch (t) {
      if (t.name === "NotAllowedError") {
        console.log("Selection cancelled"), this._requestOpen = !1;
        return;
      }
      console.error("Error opening video", t);
    }
  }
  close() {
    this._requestOpen = !1, this._currentStream && (vt && console.warn("Close current stream / disposing resources, stream was active?", this._currentStream.active), this._net?.stopSendingStream(this._currentStream), ms(this._currentStream), this._currentMode = 0, this._currentStream = null);
  }
  setStream(e, t) {
    if (e === this._currentStream || (this.close(), !e)) return;
    this._currentStream = e, this._requestOpen = !0, this._currentMode = t;
    const i = this.device !== "Microphone", n = t === 1;
    i ? (this._videoPlayer || this._ensureVideoPlayer(), this._videoPlayer ? this._videoPlayer.setVideo(e) : console.error("No video player assigned for video stream")) : (this._audioSource || (this._audioSource = new ln(), this._audioSource.spatialBlend = 0, this._audioSource.volume = 1, this.gameObject.addComponent(this._audioSource)), n || (vt && console.log("PLAY", e.getAudioTracks()), this._audioSource.volume = 1, this._audioSource?.play(e))), n && this._net?.startSendingStream(e), n && (this._videoPlayer && (this._videoPlayer.muted = !0), this._audioSource?.stop());
    for (const o of e.getTracks())
      o.addEventListener("ended", () => {
        vt && console.log("Track ended", o), this.close();
      }), vt && o.kind === "video" && console.log(n ? "Video →" : "Video ←", o.getSettings());
  }
  onReceiveStream = (e) => {
    e.stream?.active === !0 && this.setStream(
      e.stream,
      2
      /* Receiving */
    );
  };
  onCallEnded = (e) => {
    vt && console.log("CALL ENDED", this.isReceiving, this?.screenspace), this.isReceiving && (this.screenspace = !1);
  };
  async tryShareUserCamera(e, t) {
    const i = (await navigator.mediaDevices.enumerateDevices()).filter((o) => o.kind === "videoinput");
    vt && console.log(`Request camera. These are your kind:videoinput devices:
`, i);
    let n = !1;
    for (const o of i)
      try {
        if (!this._requestOpen) {
          vt && console.log("Camera selection cancelled");
          break;
        }
        if (o.kind !== "videoinput") {
          vt && console.log("Skipping non-video device", o);
          continue;
        }
        const r = o.deviceId;
        if (t?.deviceId != null || t?.deviceFilter != null) {
          if (t?.deviceId !== void 0 && r !== t.deviceId) {
            vt && console.log("Skipping device due to options.deviceId: " + o.label + "; " + o.deviceId);
            continue;
          }
          if (t?.deviceFilter && t.deviceFilter(o) === !1) {
            vt && console.log("Skipping device due to options.deviceFilter: " + o.label + "; " + o.deviceId);
            continue;
          }
        } else if (this.deviceFilter)
          if (this.deviceFilter(o) === !1) {
            vt && console.log("Skipping device due to ScreenShare.deviceFilter: " + o.label + "; " + o.deviceId);
            continue;
          } else vt && console.log("Selected device by filter", o);
        else if (this.deviceName) {
          const c = o.label.toLowerCase(), h = this.deviceName.toLowerCase(), d = c.includes(h), f = o.deviceId === this.deviceName;
          if (!d && !f) {
            vt && console.log("Skipping device due to ScreenShare.deviceName: " + o.label + "; " + o.deviceId);
            continue;
          } else vt && console.log("Selected device by name", o);
        }
        e.video !== !1 && ((typeof e.video > "u" || typeof e.video == "boolean") && (e.video = {}), e.video.deviceId = r), n = !0;
        const l = await navigator.mediaDevices.getUserMedia(e).catch((c) => (console.error("Failed to get user media", c), null));
        if (l === null)
          continue;
        this._requestOpen ? (this.setStream(
          l,
          1
          /* Sending */
        ), vt && console.log("Selected camera", o)) : (ms(l), vt && console.log("Camera selection cancelled"));
        break;
      } catch (r) {
        if (r.message === "Failed to allocate videosource" || r.message === "Could not start video source") {
          ge("Failed to start video: Try another camera (Code " + r.code + ")"), console.warn(r);
          continue;
        } else
          console.error("Failed to get user media", r.message, r.code, r);
      }
    !n && L() && (ge("No camera found for sharing. Please connect a camera (see console for more information)"), console.warn("No camera found for sharing. Please connect a camera", i, this.deviceName, "Using deviceFilter? " + this.deviceFilter != null, "Using options? " + t != null, "Using deviceName? " + this.deviceName != null, "Using options.deviceId? " + t?.deviceId != null, "Using options.deviceFilter? " + t?.deviceFilter != null));
  }
  // private _cameraSelectionWindow : Window | null = null;
  // private openWindowToSelectCamera(){
  // }
}
jc([
  u()
], Or.prototype, "allowStartOnClick", 2);
jc([
  u()
], Or.prototype, "autoConnect", 2);
jc([
  u(pt)
], Or.prototype, "videoPlayer", 1);
jc([
  u()
], Or.prototype, "device", 2);
jc([
  u()
], Or.prototype, "deviceName", 2);
var gE = Object.defineProperty, mw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && gE(e, t, n), n;
};
class Tu extends T {
  mode = 0;
  shadowColor = new oe(0, 0, 0, 1);
  targetMesh;
  /** @internal */
  start() {
    if (this.gameObject instanceof H)
      this.gameObject instanceof H && this.gameObject.material && (this.gameObject.material = this.gameObject.material.clone(), this.targetMesh = this.gameObject, this.targetMesh.receiveShadow = !0);
    else {
      const e = Oa.createPrimitive(ma.Quad, {
        name: "ShadowCatcher",
        material: new ct({
          // HACK heuristic to get approx. the same colors out as with the current default ShadowCatcher material
          // not clear why this is needed; assumption is that the Renderer component does something we're not respecting here
          color: 10066329,
          roughness: 1,
          metalness: 0,
          transparent: !0
        })
      });
      e.receiveShadow = !0, e.geometry.rotateX(-Math.PI / 2), this.gameObject.add(e), this.targetMesh = e;
    }
    if (!this.targetMesh) {
      console.warn("ShadowCatcher: no mesh to apply shadow catching to. Groups are currently not supported.");
      return;
    }
    switch (this.targetMesh.layers.set(2), this.mode) {
      case 0:
        this.applyShadowMaterial();
        break;
      case 1:
        this.applyLightBlendMaterial();
        break;
      case 2:
        this.applyOccluderMaterial();
        break;
    }
  }
  // Custom blending, diffuse-only lighting blended onto the scene additively.
  // Works great for Point Lights and spot lights, 
  // doesn't work for directional lights (since they're lighting up everything else).
  // Works even better with an additional black-ish gradient to darken parts of the AR scene
  // so that lights become more visible on bright surfaces.
  applyLightBlendMaterial() {
    if (!this.targetMesh) return;
    const e = this.targetMesh.material;
    e.blending = pb, this.applyMaterialOptions(e), e.onBeforeCompile = (t) => {
      t.fragmentShader = t.fragmentShader.replace(
        "vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;",
        `vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
            // diffuse-only lighting with overdrive to somewhat compensate
            // for the loss of indirect lighting and to make it more visible.
            vec3 direct = (reflectedLight.directDiffuse + reflectedLight.directSpecular) * 6.6;
            float max = max(direct.r, max(direct.g, direct.b));
            
            // early out - we're simply returning direct lighting and some alpha based on it so it can 
            // be blended onto the scene.
            gl_FragColor = vec4(direct, max);
            return;
            `
      );
    }, e.userData.isLightBlendMaterial = !0;
  }
  // ShadowMaterial: only does a mask; shadowed areas are fully black.
  // doesn't take light attenuation into account.
  // works great for Directional Lights.
  applyShadowMaterial() {
    if (this.targetMesh)
      if (this.targetMesh.material.type !== "ShadowMaterial") {
        const e = new ob();
        e.color = this.shadowColor, e.opacity = this.shadowColor.alpha, this.applyMaterialOptions(e), this.targetMesh.material = e, e.userData.isShadowCatcherMaterial = !0;
      } else {
        const e = this.targetMesh.material;
        e.color = this.shadowColor, e.opacity = this.shadowColor.alpha, this.applyMaterialOptions(e), e.userData.isShadowCatcherMaterial = !0;
      }
  }
  applyOccluderMaterial() {
    if (this.targetMesh) {
      let e = this.targetMesh.material;
      if (!e) {
        const t = new we();
        this.targetMesh.material = t, e = t;
      }
      e.depthWrite = !0, e.stencilWrite = !0, e.colorWrite = !1, this.gameObject.renderOrder = -100;
    }
  }
  applyMaterialOptions(e) {
    e && (e.depthWrite = !1, e.stencilWrite = !1);
  }
}
mw([
  u()
], Tu.prototype, "mode");
mw([
  u(oe)
], Tu.prototype, "shadowColor");
const Ch = /* @__PURE__ */ new Map();
function yE(s, e) {
  if (Ch.has(s))
    return Ch.get(s);
  const t = new URL(s, window.location.href), i = _E(t, e);
  return Ch.set(s, i), i.finally(() => {
    Ch.delete(s);
  }), i;
}
async function _E(s, e) {
  if (!s) return Promise.resolve(null);
  const t = s.pathname, i = s.toString().toLowerCase().includes("pmrem") || s.searchParams.get("pmrem") != null, n = t.endsWith(".exr"), o = t.endsWith(".hdr"), r = t.endsWith(".ktx2");
  let a;
  if (n)
    a = new gm();
  else if (o)
    a = new bb();
  else if (r) {
    const { ktx2Loader: d } = mm(e);
    a = d;
  } else
    a = new Jl();
  const l = s.toString();
  return await a.loadAsync(l).then((d) => {
    if (d) {
      const f = t.lastIndexOf("/");
      d.name = t.substring(f >= 0 ? f + 1 : 0), i && (d.mapping = mb), a instanceof Jl && (d.colorSpace = Cs);
    }
    return d;
  }).catch((d) => (console.warn("Failed to load texture from url:", s), null));
}
var bE = Object.defineProperty, Bc = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && bE(e, t, n), n;
};
const Kt = w("debugskybox");
Eg("background-image");
Eg("environment-image");
function G_(s, e, t, i, n) {
  if (e === "transparent" || e?.startsWith("rgb") || e?.startsWith("#"))
    return console.warn(`Needle Engine: Invalid ${n} value (${e}). Did you mean to set background-color instead?`), null;
  const o = new Ag();
  o.allowDrop = !1, o.allowNetworking = !1, o.background = t, o.environment = i, S.addComponent(s.scene, o);
  const r = (a) => {
    typeof a == "string" && (Kt && console.log(n, "CHANGED TO", a), o.setSkybox(a));
  };
  return iC(s.domElement, n, r), o.addEventListener("destroy", () => {
    Kt && console.log("Destroyed attribute remote skybox", n), nC(s.domElement, n, r);
  }), o.setSkybox(e);
}
const Sd = new Array();
he.registerCallback(ce.ContextCreationStart, (s) => {
  const e = s.context, t = e.domElement.getAttribute("background-image"), i = e.domElement.getAttribute("environment-image"), n = t === i;
  if (t && !n) {
    Kt && console.log("Creating remote skybox to load " + t);
    const o = G_(e, t, !0, !1, "background-image");
    o && Sd.push(o);
  }
  if (i) {
    Kt && console.log("Creating remote environment to load " + i);
    const o = G_(e, i, n, !0, "environment-image");
    o && Sd.push(o);
  }
});
he.registerCallback(ce.ContextCreationStart, () => Promise.all(Sd).finally(() => {
  Sd.length = 0;
}));
const dr = class extends T {
  url;
  allowDrop = !0;
  background = !0;
  environment = !0;
  allowNetworking = !0;
  _prevUrl;
  _prevLoadedEnvironment;
  _prevEnvironment = null;
  _prevBackground = null;
  /** @internal */
  onEnable() {
    this.setSkybox(this.url), this.registerDropEvents();
  }
  /** @internal */
  onDisable() {
    this.context.scene.environment === this._prevLoadedEnvironment && (this.context.scene.environment = this._prevEnvironment, ui.backgroundShouldBeTransparent(this.context) || (this.context.scene.background = this._prevBackground), this._prevLoadedEnvironment = void 0), this.unregisterDropEvents(), this.context.mainCameraComponent?.applyClearFlags();
  }
  urlChangedSyncField() {
    this.allowNetworking && this.url && (this.isRemoteTexture(this.url) ? this.setSkybox(this.url) : Kt && console.warn(`RemoteSkybox: Not setting skybox: ${this.url} is not a remote texture. If you want to set a local texture, set allowNetworking to false.`));
  }
  /**
   * Set the skybox from a given url
   * @param url The url of the skybox image
   * @param name Define name of the file with extension if it isn't apart of the url
   * @returns Whether the skybox was successfully set
   */
  async setSkybox(e, t) {
    if (!this.activeAndEnabled || (e = vE(e, this.environment, this.background), !e)) return !1;
    if (t ??= e, this.isValidTextureType(t) || console.warn('Potentially invalid skybox URL: "' + t + '" on ' + (this.name || this.gameObject?.name || "context")), Kt && console.log("Set remote skybox url: " + e), this._prevUrl === e && this._prevLoadedEnvironment)
      return this.apply(), !0;
    this._prevLoadedEnvironment?.dispose(), this._prevLoadedEnvironment = void 0, this._prevUrl = e;
    const i = await yE(e, this.context.renderer);
    return i ? !this.enabled || this.destroyed ? (Kt && console.warn("RemoteSkybox: Component is disabled or destroyed"), !1) : this._prevUrl !== e ? (Kt && console.warn("RemoteSkybox: URL changed while loading texture, aborting setSkybox"), !1) : (this.url = e, this._prevLoadedEnvironment = i, this.apply(), !0) : (Kt && console.warn("RemoteSkybox: Failed to load texture from url", e), !1);
  }
  apply() {
    const e = this._prevLoadedEnvironment;
    if (e && (e instanceof Qx || e instanceof Yx || e.mapping == mb || (e.mapping = Kx, e.needsUpdate = !0), !this.destroyed)) {
      if (!this.context) {
        console.warn("RemoteSkybox: Context is not available - can not apply skybox.");
        return;
      }
      this.context.scene.background !== e && (this._prevBackground = this.context.scene.background), this.context.scene.environment !== e && (this._prevEnvironment = this.context.scene.environment), Kt && console.log("Set remote skybox", this.url, !ui.backgroundShouldBeTransparent(this.context)), this.environment && (this.context.scene.environment = e), this.background && !ui.backgroundShouldBeTransparent(this.context) && (this.context.scene.background = e), this.context.mainCameraComponent?.backgroundBlurriness !== void 0 && (this.context.scene.backgroundBlurriness = this.context.mainCameraComponent.backgroundBlurriness);
    }
  }
  validProtocols = ["file:", "blob:", "data:"];
  validTextureTypes = [".ktx2", ".hdr", ".exr", ".jpg", ".jpeg", ".png"];
  isRemoteTexture(e) {
    return e.startsWith("http://") || e.startsWith("https://");
  }
  isValidTextureType(e) {
    for (const t of this.validTextureTypes)
      if (e.includes(t)) return !0;
    for (const t of this.validProtocols)
      if (e.startsWith(t)) return !0;
    return !1;
  }
  registerDropEvents() {
    this.unregisterDropEvents(), this.context.domElement.addEventListener("dragover", this.onDragOverEvent), this.context.domElement.addEventListener("drop", this.onDrop);
  }
  unregisterDropEvents() {
    this.context.domElement.removeEventListener("dragover", this.onDragOverEvent), this.context.domElement.removeEventListener("drop", this.onDrop);
  }
  onDragOverEvent = (e) => {
    if (this.allowDrop && e.dataTransfer)
      for (const t of e.dataTransfer.types)
        (t === "text/uri-list" || t === "Files") && e.preventDefault();
  };
  onDrop = (e) => {
    if (this.allowDrop && e.dataTransfer) {
      for (const t of e.dataTransfer.types)
        if (Kt && console.log(t), t === "text/uri-list") {
          const i = e.dataTransfer.getData(t);
          Kt && console.log(t, i);
          let n = new RegExp(/polyhaven.com\/asset_img\/.+?\/(?<name>.+)\.png/).exec(i)?.groups?.name;
          if (n || (n = new RegExp(/polyhaven\.com\/a\/(?<name>.+)/).exec(i)?.groups?.name), Kt && console.log(n), n) {
            const o = "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/" + n + "_1k.exr";
            console.log(`[Remote Skybox] Setting skybox from url: ${o}`), e.preventDefault(), this.setSkybox(o);
            break;
          } else if (this.isValidTextureType(i)) {
            console.log("[Remote Skybox] Setting skybox from url: " + i), e.preventDefault(), this.setSkybox(i);
            break;
          } else {
            console.warn(`[RemoteSkybox] Unknown url ${i}. If you want to load a skybox from a url, make sure it is a valid image url. Url must end with${this.validTextureTypes.join(", ")}.`);
            const o = new CustomEvent("dropped-unknown-url", {
              detail: {
                sender: this,
                event: e,
                url: i,
                apply: (r) => {
                  e.preventDefault(), this.setSkybox(r);
                }
              }
            });
            this.dispatchEvent(o);
          }
        } else if (t == "Files") {
          const i = e.dataTransfer.files.item(0);
          if (Kt && console.log(t, i), !i) continue;
          if (!this.isValidTextureType(i.name)) {
            console.warn(`[RemoteSkybox]: File "${i.name}" is not supported. Supported files are ${this.validTextureTypes.join(", ")}`);
            return;
          }
          e.preventDefault(), this.setSkybox(i.name);
          break;
        }
    }
  };
};
Bc([
  Lv(dr.prototype.urlChangedSyncField),
  u(URL)
], dr.prototype, "url");
Bc([
  u()
], dr.prototype, "allowDrop");
Bc([
  u()
], dr.prototype, "background");
Bc([
  u()
], dr.prototype, "environment");
Bc([
  u()
], dr.prototype, "allowNetworking");
let Ag = dr;
function vE(s, e, t) {
  if (s == null) return null;
  const i = e && !t;
  switch (s.toLowerCase()) {
    case "studio":
      return i ? "https://cdn.needle.tools/static/skybox/modelviewer-Neutral-small.pmrem4x4.ktx2?pmrem" : "https://cdn.needle.tools/static/skybox/modelviewer-Neutral.pmrem4x4.ktx2?pmrem";
    case "blurred-skybox":
      return i ? "https://cdn.needle.tools/static/skybox/blurred-skybox-small.pmrem4x4.ktx2?pmrem" : "https://cdn.needle.tools/static/skybox/blurred-skybox.pmrem4x4.ktx2?pmrem";
    case "quicklook-ar":
      return i ? "https://cdn.needle.tools/static/skybox/QuickLook-ARMode-small.pmrem4x4.ktx2?pmrem" : "https://cdn.needle.tools/static/skybox/QuickLook-ARMode.pmrem4x4.ktx2?pmrem";
    case "quicklook":
      return i ? "https://cdn.needle.tools/static/skybox/QuickLook-ObjectMode-small.pmrem4x4.ktx2?pmrem" : "https://cdn.needle.tools/static/skybox/QuickLook-ObjectMode.pmrem4x4.ktx2?pmrem";
  }
  return s;
}
var wE = Object.defineProperty, Eu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && wE(e, t, n), n;
};
const Fc = class gw extends T {
  target = null;
  followFactor = 0.1;
  rotateFactor = 0.1;
  positionAxes = xl.All;
  flipForward = !1;
  static _invertForward = new $().setFromAxisAngle(new b(0, 1, 0), Math.PI);
  _firstUpdate = !0;
  /**
   * Update the position and rotation of the GameObject to follow the target.
   */
  onBeforeRender() {
    this.updateNow(!1);
  }
  updateNow(e) {
    if (!(!this.target || this.target === this.gameObject)) {
      if (this.followFactor > 0) {
        const t = Z(this.target), i = this._firstUpdate || e ? 1 : j.clamp01(this.context.time.deltaTime * this.followFactor), n = this.worldPosition;
        this.positionAxes & xl.X && (n.x = j.lerp(n.x, t.x, i)), this.positionAxes & xl.Y && (n.y = j.lerp(n.y, t.y, i)), this.positionAxes & xl.Z && (n.z = j.lerp(n.z, t.z, i)), this.worldPosition = n;
      }
      if (this.rotateFactor > 0) {
        const t = be(this.target);
        this.flipForward && t.premultiply(gw._invertForward);
        const i = this._firstUpdate || e ? 1 : j.clamp01(this.context.time.deltaTime * this.rotateFactor);
        this.worldQuaternion = this.worldQuaternion.slerp(t, i);
      }
      this._firstUpdate = !1;
    }
  }
};
Eu([
  u(M)
], Fc.prototype, "target");
Eu([
  u()
], Fc.prototype, "followFactor");
Eu([
  u()
], Fc.prototype, "rotateFactor");
Eu([
  u()
], Fc.prototype, "positionAxes");
let Ig = Fc;
var xE = Object.defineProperty, zc = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && xE(e, t, n), n;
};
const ql = w("debugspatialtrigger"), q_ = new ao(), X_ = new ao();
function SE(s, e) {
  return q_.mask = s, X_.mask = e, q_.test(X_);
}
class xs extends T {
  triggerMask = 0;
  onEnter;
  onStay;
  onExit;
  /** 
   * Initializes the receiver and logs debug info if enabled
   * @internal
   */
  start() {
    ql && console.log(this.name, this.triggerMask, this);
  }
  /**
   * Checks for intersections with spatial triggers and fires appropriate events
   * Handles enter, stay, and exit events for all relevant triggers
   * @internal
   */
  update() {
    this.currentIntersected.length = 0;
    for (const e of Lg.triggers)
      SE(e.triggerMask, this.triggerMask) && e.test(this.gameObject) && this.currentIntersected.push(e);
    for (let e = this.lastIntersected.length - 1; e >= 0; e--) {
      const t = this.lastIntersected[e];
      this.currentIntersected.indexOf(t) < 0 && (this.onExitTrigger(t), this.lastIntersected.splice(e, 1));
    }
    for (const e of this.currentIntersected)
      this.lastIntersected.indexOf(e) < 0 && this.onEnterTrigger(e), this.onStayTrigger(e);
    this.lastIntersected.length = 0, this.lastIntersected.push(...this.currentIntersected);
  }
  /** Array of triggers currently intersecting with this receiver */
  currentIntersected = [];
  /** Array of triggers that intersected with this receiver in the previous frame */
  lastIntersected = [];
  /**
   * Handles trigger enter events.
   * @param trigger The spatial trigger that was entered
   */
  onEnterTrigger(e) {
    ql && console.log("ENTER TRIGGER", this.name, e.name, this, e), e.raiseOnEnterEvent(this), this.onEnter?.invoke();
  }
  /**
   * Handles trigger exit events.
   * @param trigger The spatial trigger that was exited
   */
  onExitTrigger(e) {
    ql && console.log("EXIT TRIGGER", this.name, e.name), e.raiseOnExitEvent(this), this.onExit?.invoke();
  }
  /**
   * Handles trigger stay events.
   * @param trigger The spatial trigger that the receiver is staying in
   */
  onStayTrigger(e) {
    e.raiseOnStayEvent(this), this.onStay?.invoke();
  }
}
zc([
  u()
], xs.prototype, "triggerMask");
zc([
  u(me)
], xs.prototype, "onEnter");
zc([
  u(me)
], xs.prototype, "onStay");
zc([
  u(me)
], xs.prototype, "onExit");
const yw = class Hh extends T {
  /** Global registry of all active spatial triggers in the scene */
  static triggers = [];
  triggerMask;
  /** Box helper component used to visualize and calculate the trigger area */
  boxHelper;
  /**
   * Initializes the trigger and logs debug info if enabled
   */
  start() {
    ql && console.log(this.name, this.triggerMask, this);
  }
  /**
   * Registers this trigger in the global registry and sets up debug visualization if enabled
   */
  onEnable() {
    Hh.triggers.push(this), this.boxHelper || (this.boxHelper = S.addComponent(this.gameObject, Ct), this.boxHelper?.showHelper(null, ql));
  }
  /**
   * Removes this trigger from the global registry when disabled
   */
  onDisable() {
    Hh.triggers.splice(Hh.triggers.indexOf(this), 1);
  }
  /**
   * Tests if an object is inside this trigger's box
   * @param obj The object to test against this trigger
   * @returns True if the object is inside the trigger box
   */
  test(e) {
    return this.boxHelper ? this.boxHelper.isInBox(e) ?? !1 : !1;
  }
  // private args: SpatialTriggerEventArgs = new SpatialTriggerEventArgs();
  /**
   * Raises the onEnter event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that entered this trigger
   */
  raiseOnEnterEvent(e) {
    S.foreachComponent(this.gameObject, (t) => {
      t !== e && t instanceof xs && t.onEnterTrigger(this);
    }, !1);
  }
  /**
   * Raises the onStay event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that is staying in this trigger
   */
  raiseOnStayEvent(e) {
    S.foreachComponent(this.gameObject, (t) => {
      t !== e && t instanceof xs && t.onStayTrigger(this);
    }, !1);
  }
  /**
   * Raises the onExit event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that exited this trigger
   */
  raiseOnExitEvent(e) {
    S.foreachComponent(this.gameObject, (t) => {
      t !== e && t instanceof xs && t.onExitTrigger(this);
    }, !1);
  }
};
zc([
  u()
], yw.prototype, "triggerMask");
let Lg = yw;
var CE = Object.defineProperty, PE = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && CE(e, t, n), n;
};
const di = w("debugspectator");
class Dg extends T {
  /** Reference to the Camera component on this GameObject */
  cam = null;
  useKeys = !0;
  _mode = 0;
  /** Gets the current spectator perspective mode */
  get mode() {
    return this._mode;
  }
  /** Sets the current spectator perspective mode */
  set mode(e) {
    this._mode = e;
  }
  /** Returns whether this user is currently spectating another user */
  get isSpectating() {
    return this._handler?.currentTarget !== void 0;
  }
  /**
   * Checks if this instance is spectating the user with the given ID
   * @param userId The user ID to check
   * @returns True if spectating the specified user, false otherwise
   */
  isSpectatingUser(e) {
    return this.target?.userId === e;
  }
  /**
   * Checks if the user with the specified ID is following this user
   * @param userId The user ID to check
   * @returns True if the specified user is following this user, false otherwise
   */
  isFollowedBy(e) {
    return this.followers?.includes(e);
  }
  /** List of user IDs that are currently following the user */
  get followers() {
    return this._networking.followers;
  }
  /** Stops the current spectating session */
  stopSpectating() {
    if (this.context.isInXR) {
      this.followSelf();
      return;
    }
    this.target = void 0;
  }
  /** Gets the local player's connection ID */
  get localId() {
    return this.context.connection.connectionId ?? "local";
  }
  /** 
   * Sets the player view to follow
   * @param target The PlayerView to follow, or undefined to stop spectating
   */
  set target(e) {
    if (this._handler) {
      const t = this._handler.currentTarget?.userId, i = this.context.players.getPlayerView(this.localId);
      e === void 0 || this.context.isInXR === !1 && i?.currentObject === e.currentObject ? this._handler.currentTarget !== void 0 && (this._handler.disable(), S.setActive(this.gameObject, !1), this.orbit && (this.orbit.enabled = !0), this._networking.onSpectatedObjectChanged(e, t)) : this._handler.currentTarget !== e && (this._handler.set(e), S.setActive(this.gameObject, !0), this.orbit && (this.orbit.enabled = !1), this._networking.onSpectatedObjectChanged(e, t));
    }
  }
  /** Gets the currently followed player view */
  get target() {
    return this._handler?.currentTarget;
  }
  /** Sends a network request for all users to follow this player */
  requestAllFollowMe() {
    this._networking.onRequestFollowMe();
  }
  /** Determines if the camera is spectating the local player */
  get isSpectatingSelf() {
    return this.isSpectating && this.target?.currentObject === this.context.players.getPlayerView(this.localId)?.currentObject;
  }
  // private currentViewport : Vector4 = new Vector4();
  // private currentScissor : Vector4 = new Vector4();
  // private currentScissorTest : boolean = false;
  orbit = null;
  _handler;
  eventSub_WebXRRequestStartEvent = null;
  eventSub_WebXRStartEvent = null;
  eventSub_WebXREndEvent = null;
  _debug;
  _networking;
  awake() {
    if (this._debug = new ME(this.context, this), this._networking = new EE(this.context, this), this._networking.awake(), S.setActive(this.gameObject, !1), this.cam = S.getComponent(this.gameObject, ui), !this.cam) {
      console.warn("SpectatorCamera: Spectator camera needs camera component on the same object.", this);
      return;
    }
    !this._handler && this.cam && (this._handler = new OE(this.context, this.cam, this)), this.orbit = S.getComponent(this.context.mainCamera, ye);
  }
  onDestroy() {
    this.stopSpectating(), this._handler?.destroy(), this._networking?.destroy();
  }
  /**
   * Checks if the current platform supports spectator mode
   * @returns True if the platform is supported, false otherwise
   */
  isSupportedPlatform() {
    const e = window.navigator.userAgent, t = /Windows|MacOS/.test(e), i = /Windows NT/.test(e) && /Edg/.test(e) && !/Win64/.test(e);
    return t && !i;
  }
  /**
   * Called before entering WebXR mode
   * @param _evt The WebXR event
   */
  onBeforeXR(e) {
    this.isSupportedPlatform() && S.setActive(this.gameObject, !0);
  }
  /**
   * Called when entering WebXR mode
   * @param _evt The WebXR event
   */
  onEnterXR(e) {
    this.isSupportedPlatform() && (di && console.log(this.context.mainCamera), this.context.mainCamera && this.followSelf());
  }
  /**
   * Called when exiting WebXR mode
   * @param _evt The WebXR event
   */
  onLeaveXR(e) {
    this.context.removeCamera(this.cam), S.setActive(this.gameObject, !1), this.orbit && (this.orbit.enabled = !0), this._handler?.set(void 0), this._handler?.disable(), this.isSpectatingSelf && this.stopSpectating();
  }
  /**
   * Sets the target to follow the local player
   */
  followSelf() {
    this.target = this.context.players.getPlayerView(this.context.connection.connectionId), this.target || (this.context.players.setPlayerView(this.localId, this.context.mainCamera, Zo.Headset), this.target = this.context.players.getPlayerView(this.localId)), di && console.log("Follow self", this.target);
  }
  // TODO: only show Spectator cam for DesktopVR;
  // don't show for AR, don't show on Quest
  // TODO: properly align cameras on enter/exit VR, seems currently spectator cam breaks alignment
  /**
   * Called after the main rendering pass to render the spectator view
   */
  onAfterRender() {
    if (!this.cam) return;
    const e = this.context.renderer, t = e.xr.enabled;
    if (!e.xr.isPresenting && !this._handler?.currentTarget) return;
    this._handler?.update(this._mode);
    const i = e.getRenderTarget();
    let n = null;
    const o = e.state;
    if (!i) {
      if (!e.state.bindFramebuffer || !o.bindXRFramebuffer)
        return;
      n = e._framebuffer, o.bindXRFramebuffer(null);
    }
    this.setAvatarFlagsBeforeRender();
    const r = this.context.mainCameraComponent;
    if (r) {
      const c = r.backgroundColor;
      c && e.setClearColor(c, c.alpha), this.cam.backgroundColor = c, this.cam.clearFlags = r.clearFlags, this.cam.nearClipPlane = r.nearClipPlane, this.cam.farClipPlane = r.farClipPlane;
    } else
      e.setClearColor(new se(1, 1, 1));
    e.setRenderTarget(null), e.xr.enabled = !1;
    const a = this.cam?.threeCamera;
    this.context.updateAspect(a);
    const l = e.xr.isPresenting;
    e.xr.isPresenting = !1, e.setSize(this.context.domWidth, this.context.domHeight), e.render(this.context.scene, a), e.xr.isPresenting = l, e.xr.enabled = t, i ? e.setRenderTarget(i) : o.bindXRFramebuffer && o.bindXRFramebuffer(n), this.resetAvatarFlags();
  }
  /**
   * Updates avatar visibility flags for rendering in spectator mode
   */
  setAvatarFlagsBeforeRender() {
    const e = this._mode === 0;
    for (const t of je.instances)
      if (t.avatar && "isLocalAvatar" in t.avatar && "flags" in t.avatar) {
        let i = us.All;
        this.isSpectatingSelf && (i = e && t.avatar.isLocalAvatar ? us.FirstPerson : us.ThirdPerson);
        const n = t.avatar.flags;
        if (!n) continue;
        for (const o of n)
          o.UpdateVisible(i);
      }
  }
  /**
   * Restores avatar visibility flags after spectator rendering
   */
  resetAvatarFlags() {
    for (const e of je.instances)
      if (e.avatar && "flags" in e.avatar) {
        const t = e.avatar.flags;
        if (!t) continue;
        for (const i of t)
          "isLocalAvatar" in e.avatar && e.avatar?.isLocalAvatar ? i.UpdateVisible(us.FirstPerson) : i.UpdateVisible(us.ThirdPerson);
      }
  }
}
PE([
  u()
], Dg.prototype, "useKeys");
class OE {
  context;
  cam;
  spectator;
  follow;
  target;
  view;
  currentObject;
  /** Gets the currently targeted player view */
  get currentTarget() {
    return this.view;
  }
  constructor(e, t, i) {
    this.context = e, this.cam = t, this.spectator = i;
  }
  /**
   * Sets the target player view to follow
   * @param view The PlayerView to follow
   */
  set(e) {
    const t = e?.currentObject;
    if (!t) {
      this.spectator.stopSpectating();
      return;
    }
    t !== this.currentObject && (this.currentObject = t, this.view = e, this.follow || (this.follow = S.addComponent(this.cam.gameObject, Ig)), this.target || (this.target = new M()), t.add(this.target), this.follow.enabled = !0, this.follow.target = this.target, di && console.log("FOLLOW", t), this.context.isInXR ? this.context.removeCamera(this.cam) : this.context.setCurrentCamera(this.cam));
  }
  /** Disables the spectator following behavior */
  disable() {
    di && console.log("STOP FOLLOW", this.currentObject), this.view = void 0, this.currentObject = void 0, this.context.removeCamera(this.cam), this.follow && (this.follow.enabled = !1);
  }
  /** Cleans up resources used by the handler */
  destroy() {
    this.target?.removeFromParent(), this.follow && S.destroy(this.follow);
  }
  /**
   * Updates the camera position and orientation based on the spectator mode
   * @param mode The current spectator mode (first or third person)
   */
  update(e) {
    if (this.currentTarget?.isConnected === !1 || this.currentTarget?.removed === !0) {
      di && console.log("Target disconnected or timeout", this.currentTarget), this.spectator.stopSpectating();
      return;
    }
    this.currentTarget && this.currentTarget?.currentObject !== this.currentObject && (di && console.log("Target changed", this.currentObject, "to", this.currentTarget.currentObject), this.set(this.currentTarget));
    const t = this.context.mainCamera;
    if (t) {
      const n = this.cam.threeCamera;
      (n.near !== t.near || n.far !== t.far) && (n.near = t.near, n.far = t.far, n.updateProjectionMatrix());
    }
    const i = this.follow?.target;
    if (!(!i || !this.follow)) {
      switch (e) {
        case 0:
          this.view?.viewDevice !== Zo.Browser ? (this.follow.followFactor = 5, this.follow.rotateFactor = 5) : (this.follow.followFactor = 50, this.follow.rotateFactor = 50), i.position.set(0, 0, 0);
          break;
        case 1:
          this.follow.followFactor = 3, this.follow.rotateFactor = 2, i.position.set(0, 0.5, 1.5);
          break;
      }
      this.follow.flipForward = !1, this.view?.viewDevice !== Zo.Browser ? i.quaternion.copy(kE) : i.quaternion.identity();
    }
  }
}
const kE = new $().setFromAxisAngle(new b(0, 1, 0), Math.PI);
class ME {
  context;
  spectator;
  constructor(e, t) {
    this.context = e, this.spectator = t, console.log("[Spectator Camera] Click other avatars or cameras to follow them. Press ESC to exit spectator mode."), this.context.domElement.addEventListener("keydown", (n) => {
      if (!this.spectator.useKeys) return;
      n.key === "Escape" && this.spectator.stopSpectating();
    });
    let i = 0;
    this.context.input.addEventListener(De.PointerDown, (n) => {
      i = this.context.time.time;
    }), this.context.input.addEventListener(De.PointerUp, (n) => {
      const o = this.context.time.time - i;
      o > 1 ? this.spectator.stopSpectating() : this.context.input.getPointerClicked(0) && o < 0.3 && this.trySelectObject();
    });
  }
  /**
   * Attempts to select an avatar to spectate through raycasting
   */
  trySelectObject() {
    const e = new mr();
    e.setMask(16777215);
    const t = this.context.physics.raycast(e);
    if (di && console.log(...t), t?.length)
      for (const i of t) {
        if (i.distance < 0.2) continue;
        const n = i.object, o = S.getComponentInParent(n, je), r = o?.connectionId;
        if (r) {
          const a = this.context.players.getPlayerView(r);
          this.spectator.target = a, di && console.log("spectate", r, o);
          break;
        }
      }
  }
}
class RE {
  /** The user ID that is following */
  guid;
  dontSave = !0;
  /** The user ID being followed */
  targetUserId;
  /** Indicates if the user stopped following */
  stoppedFollowing;
  constructor(e, t, i) {
    this.guid = e, this.targetUserId = t, this.stoppedFollowing = i;
  }
}
class TE {
  guid;
  userId;
  constructor(e, t) {
    this.guid = e.guid, this.userId = t;
  }
}
class EE {
  /** List of user IDs currently following this player */
  followers = [];
  context;
  spectator;
  _followerEventMethod;
  _requestFollowMethod;
  _joinedRoomMethod;
  constructor(e, t) {
    this.context = e, this.spectator = t, this._followerEventMethod = this.onFollowerEvent.bind(this), this._requestFollowMethod = this.onRequestFollowEvent.bind(this), this._joinedRoomMethod = this.onUserJoinedRoom.bind(this);
  }
  /**
   * Initializes network event listeners
   */
  awake() {
    this.context.connection.beginListen("spectator-follower-changed", this._followerEventMethod), this.context.connection.beginListen("spectator-request-follow", this._requestFollowMethod), this.context.connection.beginListen(ee.JoinedRoom, this._joinedRoomMethod), this.context.domElement.addEventListener("keydown", (e) => {
      this.spectator.useKeys && (e.key === "f" ? this.onRequestFollowMe() : e.key === "Escape" && this.onRequestFollowMe(!0));
    });
  }
  /**
   * Removes network event listeners
   */
  destroy() {
    this.context.connection.stopListen("spectator-follower-changed", this._followerEventMethod), this.context.connection.stopListen("spectator-request-follow", this._requestFollowMethod), this.context.connection.stopListen(ee.JoinedRoom, this._joinedRoomMethod);
  }
  /**
   * Notifies other users about spectating target changes
   * @param target The new target being spectated
   * @param _prevId The previous target's user ID
   */
  onSpectatedObjectChanged(e, t) {
    if (di && console.log(this.context.connection.connectionId, "onSpectatedObjectChanged", e, t), this.context.connection.connectionId) {
      const i = e?.userId === void 0, n = i ? t : e?.userId, o = new RE(this.context.connection.connectionId, n, i);
      this.context.connection.send("spectator-follower-changed", o);
    }
  }
  /**
   * Requests other users to follow this player or stop following
   * @param stop Whether to request users to stop following
   */
  onRequestFollowMe(e = !1) {
    if (di && console.log("Request follow", this.context.connection.connectionId), this.context.connection.connectionId) {
      this.spectator.stopSpectating();
      const t = e ? void 0 : this.context.connection.connectionId, i = new TE(this.spectator, t);
      this.context.connection.send("spectator-request-follow", i);
    }
  }
  /**
   * Handles room join events
   */
  onUserJoinedRoom() {
    w("followme") && this.onRequestFollowMe();
  }
  /**
   * Processes follower status change events from the network
   * @param evt The follower change event data
   */
  onFollowerEvent(e) {
    const t = e.targetUserId, i = e.guid;
    if (di && console.log(e), t === this.context.connection.connectionId)
      if (e.stoppedFollowing) {
        const n = this.followers.indexOf(i);
        n !== -1 && (this.followers.splice(n, 1), this.removeDisconnectedFollowers(), console.log(i, "unfollows you", this.followers.length));
      } else
        this.followers.includes(i) || (this.followers.push(i), this.removeDisconnectedFollowers(), console.log(i, "follows you", this.followers.length));
  }
  /**
   * Removes followers that are no longer connected to the room
   */
  removeDisconnectedFollowers() {
    for (let e = this.followers.length - 1; e >= 0; e--) {
      const t = this.followers[e];
      this.context.connection.userIsInRoom(t) === !1 && this.followers.splice(e, 1);
    }
  }
  _lastRequestFollowUser;
  /**
   * Handles follow requests from other users
   * @param evt The follow request event
   * @returns True if the request was handled successfully
   */
  onRequestFollowEvent(e) {
    if (this._lastRequestFollowUser = e, e.userId === this.context.connection.connectionId)
      this.spectator.stopSpectating();
    else if (e.userId === void 0)
      this.spectator.stopSpectating();
    else {
      const t = this.context.players.getPlayerView(e.userId);
      if (t)
        this.spectator.target = t;
      else
        return di && console.warn("Could not find view", e.userId), this.enforceFollow(), !1;
    }
    return !0;
  }
  _enforceFollowInterval;
  /**
   * Periodically retries following a user if the initial attempt failed
   */
  enforceFollow() {
    this._enforceFollowInterval || (this._enforceFollowInterval = setInterval(() => {
      this._lastRequestFollowUser === void 0 || this._lastRequestFollowUser.userId && this.spectator.isFollowedBy(this._lastRequestFollowUser.userId) ? (clearInterval(this._enforceFollowInterval), this._enforceFollowInterval = void 0) : (di && console.log("REQUEST FOLLOW AGAIN", this._lastRequestFollowUser.userId), this.onRequestFollowEvent(this._lastRequestFollowUser));
    }, 1e3));
  }
}
class Cn {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsSyncedCameraModel(e, t) {
    return (t || new Cn()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsSyncedCameraModel(e, t) {
    return e.setPosition(e.position() + Cb), (t || new Cn()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  userId(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  guid(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  dontSave() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  pos(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? (e || new Jo()).__init(this.bb_pos + t, this.bb) : null;
  }
  rot(e) {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? (e || new Jo()).__init(this.bb_pos + t, this.bb) : null;
  }
  static startSyncedCameraModel(e) {
    e.startObject(5);
  }
  static addUserId(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addGuid(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static addDontSave(e, t) {
    e.addFieldInt8(2, +t, 0);
  }
  static addPos(e, t) {
    e.addFieldStruct(3, t, 0);
  }
  static addRot(e, t) {
    e.addFieldStruct(4, t, 0);
  }
  static endSyncedCameraModel(e) {
    return e.endObject();
  }
  static finishSyncedCameraModelBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedSyncedCameraModelBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
var AE = Object.defineProperty, IE = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && AE(e, t, n), n;
};
const Cd = "SCAM";
t0(Cd, Cn.getRootAsSyncedCameraModel);
const si = new _m();
class LE {
  userId;
  guid;
  // dontSave: boolean = true;
  // pos: { x: number, y: number, z: number } = { x: 0, y: 0, z: 0 };
  // rot: { x: number, y: number, z: number } = { x: 0, y: 0, z: 0 };
  constructor(e, t) {
    this.guid = t, this.userId = e;
  }
  send(e, t) {
    if (e) {
      si.clear();
      const i = si.createString(this.guid), n = si.createString(this.userId);
      Cn.startSyncedCameraModel(si), Cn.addGuid(si, i), Cn.addUserId(si, n);
      const o = Z(e), r = xm(e);
      Cn.addPos(si, Jo.createVec3(si, o.x, o.y, o.z)), Cn.addRot(si, Jo.createVec3(si, r.x, r.y, r.z));
      const a = Cn.endSyncedCameraModel(si);
      si.finish(a, Cd), t.sendBinary(si.asUint8Array());
    }
  }
}
const _w = class tm extends T {
  static instances = [];
  getCameraObject(e) {
    const t = this.userToCamMap[e];
    return t ? this.remoteCams[t].obj : null;
  }
  cameraPrefab = null;
  _lastWorldPosition;
  _lastWorldQuaternion;
  _model = null;
  _needsUpdate = !0;
  _lastUpdateTime = 0;
  remoteCams = {};
  userToCamMap = {};
  _camTimeoutInSeconds = 10;
  _receiveCallback = null;
  /** @internal */
  async awake() {
    this._lastWorldPosition = this.worldPosition.clone(), this._lastWorldQuaternion = this.worldQuaternion.clone(), this.cameraPrefab && ("uri" in this.cameraPrefab && (this.cameraPrefab = await this.cameraPrefab.instantiate(this.gameObject)), this.cameraPrefab && "isObject3D" in this.cameraPrefab && (this.cameraPrefab.visible = !1));
  }
  /** @internal */
  onEnable() {
    this._receiveCallback = this.context.connection.beginListenBinary(Cd, this.onReceivedRemoteCameraInfoBin.bind(this));
  }
  /** @internal */
  onDisable() {
    this.context.connection.stopListenBinary(Cd, this._receiveCallback);
  }
  /** @internal */
  update() {
    for (const n in this.remoteCams) {
      const o = this.remoteCams[n], r = this.context.time.realtimeSinceStartup - o.lastUpdate;
      if (!o || r > this._camTimeoutInSeconds) {
        L() && console.log("Remote cam timeout", n), o?.obj && S.destroy(o.obj), delete this.remoteCams[n], o && delete this.userToCamMap[o.userId], tm.instances.push(o), this.context.players.removePlayerView(o.userId, Zo.Browser);
        continue;
      }
    }
    if (this.context.isInXR) return;
    const e = this.context.mainCamera;
    if (e === null) {
      this.enabled = !1;
      return;
    }
    if (!this.context.connection.isConnected || this.context.connection.connectionId === null) return;
    this._model === null && (this._model = new LE(this.context.connection.connectionId, this.context.connection.connectionId + "_camera"));
    const t = Z(e), i = be(e);
    (t.distanceTo(this._lastWorldPosition) > 1e-3 || i.angleTo(this._lastWorldQuaternion) > 0.01) && (this._needsUpdate = !0), this._lastWorldPosition.copy(t), this._lastWorldQuaternion.copy(i), !((!this._needsUpdate || this.context.time.frameCount % 2 !== 0) && !(this.context.time.realtimeSinceStartup - this._lastUpdateTime > this._camTimeoutInSeconds * 0.5)) && (this._lastUpdateTime = this.context.time.realtimeSinceStartup, this._needsUpdate = !1, this._model.send(e, this.context.connection), this.context.isInXR || this.context.players.setPlayerView(this.context.connection.connectionId, e, Zo.Browser));
  }
  onReceivedRemoteCameraInfoBin(e) {
    const t = e.guid();
    if (!t) return;
    const i = e.userId();
    if (!i || !this.context.connection.userIsInRoom(i) || !this.cameraPrefab) return;
    let n = this.remoteCams[t];
    if (!n)
      if ("isObject3D" in this.cameraPrefab) {
        const l = new Nn();
        l.context = this.context;
        const c = S.instantiate(this.cameraPrefab, l);
        n = this.remoteCams[t] = { obj: c, lastUpdate: this.context.time.realtimeSinceStartup, userId: i }, n.obj.visible = !0, this.gameObject.add(c), this.userToCamMap[i] = t, tm.instances.push(n);
        const h = S.getOrAddComponent(c, je);
        h.connectionId = i, h.avatar = c;
      } else
        return;
    const o = n.obj;
    this.context.players.setPlayerView(i, o, Zo.Browser), n.lastUpdate = this.context.time.realtimeSinceStartup, sn.markDirty(o);
    const r = e.pos();
    r && ua(o, r.x(), r.y(), r.z());
    const a = e.rot();
    a && $d(o, a.x(), a.y(), a.z());
  }
};
IE([
  u([M, ie])
], _w.prototype, "cameraPrefab");
let bw = _w;
var DE = Object.defineProperty, jE = Object.getOwnPropertyDescriptor, Po = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? jE(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && DE(e, t, n), n;
};
const Yf = "view", Kf = w("debugsyncedroom");
class Xn extends T {
  roomName = "";
  urlParameterName = "room";
  joinRandomRoom;
  requireRoomParameter = !1;
  autoRejoin = !0;
  createJoinButton = !0;
  createViewOnlyButton = !1;
  /**
   * Get current room name from the URL parameter or the view parameter.
   */
  get currentRoomName() {
    const e = w(Yf);
    return e || w(this.urlParameterName);
  }
  _lastJoinedRoom;
  set roomPrefix(e) {
    this._roomPrefix = e;
  }
  get roomPrefix() {
    return this._roomPrefix;
  }
  _roomPrefix = "";
  /** @internal */
  awake() {
    this.joinRandomRoom === void 0 && this.roomName?.length <= 0 && (this.joinRandomRoom = !0), Kf && console.log(`SyncedRoom roomName:${this.roomName}, urlParamName:${this.urlParameterName}, joinRandomRoom:${this.joinRandomRoom}`);
  }
  /** @internal */
  onEnable() {
    const e = w(Yf);
    if (e && typeof e == "string" && e.length > 0) {
      console.log("Join as viewer"), this.context.connection.joinRoom(e, !0);
      return;
    }
    if (this.tryJoinRoom(), this.createJoinButton) {
      const t = this.createRoomButton();
      this.context.menu.appendChild(t);
    }
    this.createViewOnlyButton && this.onEnableViewOnlyButton();
  }
  /** @internal */
  onDisable() {
    this._roomButton?.remove(), this.onDisableViewOnlyButton(), this.roomName && this.roomName.length > 0 && this.context.connection.leaveRoom(this.roomName);
  }
  /** @internal */
  onDestroy() {
    this.destroyRoomButton();
  }
  /** Will generate a random room name, set it as an URL parameter and attempt to join the room */
  tryJoinRandomRoom() {
    this.setRandomRoomUrlParameter(), this.tryJoinRoom();
  }
  /** Try to join the currently set roomName */
  tryJoinRoom(e = 0) {
    e === void 0 && (e = 0);
    let t = !1;
    if (this.urlParameterName?.length > 0) {
      const i = w(this.urlParameterName);
      if (i && (typeof i == "string" || typeof i == "number")) {
        t = !0;
        const n = JS(i.toString());
        this.roomName = n;
      } else if (this.joinRandomRoom && (console.log("No room name found in url, generating random one"), this.setRandomRoomUrlParameter(), e < 1))
        return this.tryJoinRoom(e + 1);
    } else
      this.joinRandomRoom && (this.roomName === null || this.roomName === void 0 || this.roomName.length <= 0) && (this.roomName = this.generateRoomName());
    return this.requireRoomParameter && !t ? ((Kf || L()) && console.warn('[SyncedRoom] Missing required room parameter "' + this.urlParameterName + `" in url - will not connect.
To allow joining a room without a query parameter you can set "requireRoomParameter" to false.`), !1) : (this.context.connection.isConnected || this.context.connection.connect(), this._lastJoinedRoom = this.roomName, this._roomPrefix && (this.roomName = this._roomPrefix + this.roomName), this.roomName.length <= 0 ? (console.warn(`[SyncedRoom] Room name is not set so we can not join a networked room.
Please choose one of the following options to fix this:
A) Set a room name in the SyncedRoom component
B) Set a room name in the URL parameter "?` + this.urlParameterName + `=my_room"
C) Set "joinRandomRoom" to true`), !1) : (Kf && console.log("Join " + this.roomName), this._userWantsToBeInARoom = !0, this.context.connection.joinRoom(this.roomName), !0));
  }
  _lastPingTime = 0;
  _lastRoomTime = -1;
  _userWantsToBeInARoom = !1;
  /** @internal */
  update() {
    this.context.connection.isConnected && (this.context.time.time - this._lastPingTime > 3 && (this._lastPingTime = this.context.time.time, this.context.connection.sendPing()), this.context.connection.isInRoom && (this._lastRoomTime = this.context.time.time)), this._lastRoomTime > 0 && this.context.time.time - this._lastRoomTime > 0.3 && (this._lastRoomTime = -1, this.autoRejoin ? this._userWantsToBeInARoom && (console.log("Disconnected from networking backend - attempt reconnecting now"), this.tryJoinRoom()) : L() && console.warn("You are not connected to a room anymore (possibly because the tab was inactive for too long and the server kicked you?)"));
  }
  /**
   * Get the URL to view the current room in view only mode.
   */
  getViewOnlyUrl() {
    if (this.context.connection.isConnected && this.context.connection.currentRoomViewId) {
      const e = window.location.search, t = new URLSearchParams(e);
      return t.has(this.urlParameterName) && t.delete(this.urlParameterName), t.set(Yf, this.context.connection.currentRoomViewId), window.location.origin + window.location.pathname + "?" + t.toString();
    }
    return null;
  }
  setRandomRoomUrlParameter() {
    const e = Fd(), t = this.generateRoomName();
    w(this.urlParameterName) ? e.set(this.urlParameterName, t) : e.append(this.urlParameterName, t), Mb(t, e);
  }
  generateRoomName() {
    let e = "";
    for (let t = 0; t < 6; t++)
      e += Math.floor(Math.random() * 10).toFixed(0);
    return e;
  }
  _roomButton;
  _roomButtonIconJoin;
  _roomButtonIconLeave;
  createRoomButton() {
    if (this._roomButton)
      return this._roomButton;
    const e = document.createElement("button");
    return this._roomButton = e, e.classList.add("create-room-button"), e.setAttribute("priority", "90"), e.onclick = () => {
      if (this.context.connection.isInRoom)
        this.urlParameterName && Yh(this.urlParameterName, null), this.context.connection.leaveRoom(), this._userWantsToBeInARoom = !1;
      else {
        if (this.urlParameterName) {
          const t = w(this.urlParameterName);
          (!t || t === !0) && (this._lastJoinedRoom ? Yh(this.urlParameterName, this._lastJoinedRoom) : this.setRandomRoomUrlParameter());
        }
        this.tryJoinRoom();
      }
    }, this._roomButtonIconJoin = Mt("group"), this._roomButtonIconLeave = Mt("group_off"), this.updateRoomButtonState(), this.context.connection.beginListen(ee.JoinedRoom, this.updateRoomButtonState), this.context.connection.beginListen(ee.LeftRoom, this.updateRoomButtonState), e;
  }
  updateRoomButtonState = () => {
    this._roomButton && (this.context.connection.isInRoom ? (this._roomButton.title = "Leave the networked room", this._roomButton.textContent = "Leave Room", this._roomButtonIconJoin?.remove(), this._roomButton.prepend(this._roomButtonIconLeave)) : (this._roomButton.title = "Create or join a networked room", this._roomButton.textContent = "Join Room", this._roomButtonIconLeave?.remove(), this._roomButton.prepend(this._roomButtonIconJoin)));
  };
  destroyRoomButton() {
    this.context.connection.stopListen(ee.JoinedRoom, this.updateRoomButtonState), this.context.connection.stopListen(ee.LeftRoom, this.updateRoomButtonState);
  }
  _viewOnlyButton;
  onEnableViewOnlyButton() {
    this.context.connection.isConnected ? this.onCreateViewOnlyButton() : (this.context.connection.stopListen(ee.JoinedRoom, this.onCreateViewOnlyButton), this.context.connection.beginListen(ee.JoinedRoom, this.onCreateViewOnlyButton));
  }
  onDisableViewOnlyButton() {
    this.context.connection.stopListen(ee.JoinedRoom, this.onCreateViewOnlyButton), this._viewOnlyButton?.remove();
  }
  onCreateViewOnlyButton = () => {
    if (!this._viewOnlyButton) {
      const e = document.createElement("button");
      this._viewOnlyButton = e, e.classList.add("view-only-button"), e.setAttribute("priority", "90"), e.onclick = () => {
        const t = this.getViewOnlyUrl();
        t?.length ? navigator.canShare({ url: t }) ? navigator.share({ url: t })?.catch((i) => {
          console.warn(i);
        }) : (navigator.clipboard.writeText(t), Be("View only URL copied to clipboard")) : ge("Could not create view only URL");
      }, e.title = "Copy the view only URL: A page accessed by the view only URL can not be modified by visiting users.", e.textContent = "Share View URL", e.prepend(Mt("visibility"));
    }
    this.context.menu.appendChild(this._viewOnlyButton);
  };
}
Po([
  u()
], Xn.prototype, "roomName", 2);
Po([
  u()
], Xn.prototype, "urlParameterName", 2);
Po([
  u()
], Xn.prototype, "joinRandomRoom", 2);
Po([
  u()
], Xn.prototype, "requireRoomParameter", 2);
Po([
  u()
], Xn.prototype, "autoRejoin", 2);
Po([
  u()
], Xn.prototype, "createJoinButton", 2);
Po([
  u()
], Xn.prototype, "createViewOnlyButton", 2);
Po([
  u()
], Xn.prototype, "roomPrefix", 1);
function BE() {
  const s = w("testwindowcount") || 0;
  s && s > 0 && FE(s);
}
function FE(s) {
  if (w("testwindow")) return null;
  const e = new URL(window.location.href);
  ny(e.searchParams, Ok, 1), ny(e.searchParams, "testwindow", 1);
  const t = e.toString(), i = [];
  window.onbeforeunload = () => {
    for (const l of i) l.close();
  };
  const n = 0.05, o = 128;
  let r = 0, a = 0;
  for (let l = 0; l < s; l++) {
    r * o + o * 0.01 >= window.innerWidth && (a += 1, r = 0);
    const c = r * (o * (1 + n)) + window.screenLeft, h = a * (o * (1 + n)) + window.screenTop + 90 + 60 * a;
    r += 1;
    const d = window.open(t, "test window " + l, `popup=yes width=${o} height=${o} top=${h} left=${c}`);
    if (!d) {
      console.warn("Failed to open window");
      continue;
    }
    i.push(d), d.onload = () => {
      d.onbeforeunload = () => {
        for (let f = 0; f < i.length; f++) {
          const p = i[f];
          p !== d && p.close();
        }
        i.length = 0;
      };
    };
  }
  return i;
}
class vw extends T {
  awake() {
    BE();
  }
}
class ww extends T {
  transformsPerFrame = 10;
  interval = 0;
  useFlatbuffers = !0;
  awake() {
    if (this.useFlatbuffers)
      this.context.connection.beginListenBinary(lc, (e) => {
      });
    else {
      this.models = [];
      for (let e = 0; e < this.transformsPerFrame; e++)
        this.models.push(new zE(this.context.connection.connectionId + "_simulatedTransform_" + e, this));
    }
  }
  builder = null;
  models = null;
  update() {
    if (this.context.connection.isConnected) {
      if (this.useFlatbuffers) {
        if (!this.context.connection.connectionId || this.context.time.frameCount % this.interval !== 0) return;
        this.builder === null && (this.builder = new _m(1024));
        const e = this.builder;
        for (let t = 0; t < this.transformsPerFrame; t++) {
          e.clear();
          const i = W0(this.context.connection.connectionId, this);
          this.context.connection.sendBinary(i);
        }
      } else if (this.models)
        for (let e = 0; e < this.models.length; e++) {
          const t = this.models[e];
          t.dontSave = !0, t.update(this, null), this.context.connection.send("TestSimulateUserData-" + e, t);
        }
    }
  }
}
class zE {
  guid;
  fast = !1;
  position;
  rotation;
  // scale : { x : number, y : number, z : number } | undefined = undefined;
  velocity = void 0;
  dontSave;
  isValid() {
    return this.fast !== void 0 || this.position !== void 0 || this.rotation !== void 0 || this.velocity !== void 0;
  }
  constructor(e, t) {
    this.guid = e, this.position = { x: 0, y: 0, z: 0 }, this.rotation = { x: 0, y: 0, z: 0, w: 0 }, this.update(t, null);
  }
  static temp = new b();
  update(e, t) {
    const i = e.worldPosition;
    this.position.x = i.x, this.position.y = i.y, this.position.z = i.z;
    const n = e.worldQuaternion;
    if (this.rotation.x = n.x, this.rotation.y = n.y, this.rotation.z = n.z, this.rotation.w = n.w, this.fast = !1, t) {
      const o = t.getVelocity();
      this.velocity === void 0 && (this.velocity = { x: 0, y: 0, z: 0 }), this.velocity.x = o.x, this.velocity.y = o.y, this.velocity.z = o.z;
    }
  }
}
var UE = Object.defineProperty, Au = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && UE(e, t, n), n;
};
const NE = w("debugsignals");
class jg {
  guid;
}
Au([
  u()
], jg.prototype, "guid");
class Iu {
  signal;
  reaction;
}
Au([
  u(jg)
], Iu.prototype, "signal");
Au([
  u(me)
], Iu.prototype, "reaction");
const xw = class os extends T {
  static receivers = {};
  static invoke(e) {
    if (os.receivers[e]) {
      const t = os.receivers[e];
      if (!t) return;
      for (const i of t)
        i.invoke(e);
    }
  }
  events;
  /** @internal */
  awake() {
    NE && console.log("SignalReceiver awake", this);
  }
  /** @internal */
  onEnable() {
    if (this.events)
      for (const e of this.events)
        os.receivers[e.signal.guid] || (os.receivers[e.signal.guid] = []), os.receivers[e.signal.guid].push(this);
  }
  /** @internal */
  onDisable() {
    if (this.events) {
      for (const e of this.events)
        if (os.receivers[e.signal.guid]) {
          const t = os.receivers[e.signal.guid].indexOf(this);
          t >= 0 && os.receivers[e.signal.guid].splice(t, 1);
        }
    }
  }
  invoke(e) {
    if (!this.events || !Array.isArray(this.events)) return;
    const t = typeof e == "object" ? e.guid : e;
    for (const i of this.events)
      if (i.signal.guid === t)
        try {
          if (i.reaction) {
            if (!i.reaction.invoke) {
              console.warn("Missing invoke - possibly a serialization error", i, this);
              continue;
            }
          } else {
            console.warn("Missing reaction for signal", i, this);
            continue;
          }
          i.reaction.invoke();
        } catch (n) {
          console.error(n);
        }
  }
  // onDeserialize(key: string, value: any): any | void
  // {
  //     switch(key){
  //         case "events":
  //             console.log(value);
  //             const evt = eventListSerializer;
  //             for(const e in value){
  //             }
  //             break;
  //     }
  // }
};
Au([
  u(Iu)
], xw.prototype, "events");
let Lu = xw;
var Di = /* @__PURE__ */ ((s) => (s.Activation = "ActivationTrack", s.Animation = "AnimationTrack", s.Audio = "AudioTrack", s.Control = "ControlTrack", s.Marker = "MarkerTrack", s.Signal = "SignalTrack", s))(Di || {}), rs = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Hold = 1] = "Hold", s[s.Loop = 2] = "Loop", s[s.PingPong = 3] = "PingPong", s[s.Continue = 4] = "Continue", s))(rs || {}), Sw = /* @__PURE__ */ ((s) => (s.Signal = "SignalEmitter", s))(Sw || {});
const Rn = w("debugtimeline");
class Du {
  director;
  track;
  get muted() {
    return this.track.muted;
  }
  set muted(e) {
    e !== this.track.muted && (this.track.muted = e, this.onMuteChanged?.call(this));
  }
  *forEachClip(e = !1) {
    if (this.track?.clips)
      if (e)
        for (let t = this.track.clips.length - 1; t >= 0; t--)
          yield this.track.clips[t];
      else
        for (const t of this.track.clips)
          yield t;
  }
  getClipTime(e, t) {
    return t.clipIn + (e - t.start) * t.timeScale;
  }
  getClipTimeNormalized(e, t) {
    return (e - t.start) / t.duration;
  }
  evaluateWeight(e, t, i, n = !0) {
    if (t < 0 || t >= i.length) return 0;
    const o = i[t];
    if (n || e >= o.start && e <= o.end) {
      let r = 1;
      if (o.easeInDuration > 0) {
        const a = Math.min((e - o.start) / o.easeInDuration, 1);
        r *= a;
      }
      if (o.easeOutDuration > 0) {
        const a = Math.min((o.end - e) / o.easeOutDuration, 1);
        r *= a;
      }
      return r;
    }
    return 0;
  }
}
class $E {
  clip;
  rootPositionOffset;
  rootQuaternionOffset;
  get hasOffsets() {
    return this.rootPositionOffset !== void 0 || this.rootQuaternionOffset !== void 0;
  }
  // not necessary
  rootStartPosition;
  rootEndPosition;
  rootStartQuaternion;
  rootEndQuaternion;
  constructor(e) {
    const t = e.getClip();
    this.clip = t;
    const i = e.getRoot(), n = i.name + ".position", o = i.name + ".quaternion";
    Rn && console.log(t.name, t.tracks, n);
    for (const r of t.tracks)
      if (!(r.times.length <= 0)) {
        if (r.name.endsWith(n))
          this.rootStartPosition = new b().fromArray(r.values, 0), this.rootEndPosition = new b().fromArray(r.values, r.values.length - 3), this.rootPositionOffset = this.rootEndPosition.clone().sub(this.rootStartPosition), Rn && console.log(this.rootPositionOffset);
        else if (r.name.endsWith(o) && (this.rootStartQuaternion = new $().fromArray(r.values, 0), this.rootEndQuaternion = new $().fromArray(r.values, r.values.length - 4), this.rootQuaternionOffset = this.rootEndQuaternion.clone().multiply(this.rootStartQuaternion), Rn)) {
          const a = new Rt().setFromQuaternion(this.rootQuaternionOffset);
          console.log("ROT", a);
        }
      }
  }
}
class Bg extends Du {
  /** @internal */
  models = [];
  /** @internal */
  trackOffset;
  /** The object that is being animated. */
  target;
  /** The AnimationMixer, should be shared with the animator if an animator is bound */
  mixer;
  clips = [];
  actions = [];
  /**
   * You can use the weight to blend the timeline animation tracks with multiple animation tracks on the same object.
   * @default 1
   */
  weight = 1;
  /** holds data/info about clips differences */
  _actionOffsets = [];
  _didBind = !1;
  _animator = null;
  onDisable() {
    this.mixer?.stopAllAction();
  }
  onDestroy() {
    this.director.context.animations.unregisterAnimationMixer(this.mixer);
  }
  // Using this callback instead of onEnable etc 
  // because we want to re-enable the animator when the director is at the end and wrap mode is set to none
  // in which case the director is stopped (but not disabled)
  // which means we want to notify the object that it's not animated anymore
  // and the animator can then take over
  onStateChanged() {
    this._animator && l_(this._animator.gameObject, this, this.director.isPlaying);
  }
  createHooks(e, t) {
    if (t.tracks?.length <= 0) {
      console.warn("No tracks in AnimationClip", t);
      return;
    }
    const i = t.tracks[0].name.split("."), n = i[i.length - 2], o = n + ".position", r = n + ".quaternion";
    let a = !1, l = !1;
    for (const c of t.tracks)
      c.name.endsWith(o) ? (a = !0, this.createPositionInterpolant(t, e, c)) : c.name.endsWith(r) && (l = !0, this.createRotationInterpolant(t, e, c));
    if (!a || !l) {
      const c = this.mixer?.getRoot(), h = t.tracks[0], d = h.name.lastIndexOf("."), f = h.name.substring(0, d), p = f.substring(f.lastIndexOf(".") + 1), g = c.getObjectByName(p);
      if (g)
        if (a) {
          if (!l) {
            const _ = t.tracks[0].name.substring(0, d) + ".quaternion";
            Rn && console.warn("Create quaternion track", p, g);
            const m = g.quaternion, v = new Jx(_, [0, t.duration], [m.x, m.y, m.z, m.w, m.x, m.y, m.z, m.w]);
            t.tracks.push(v), this.createRotationInterpolant(t, e, v);
          }
        } else {
          const _ = f + ".position";
          Rn && console.warn("Create position track", p, g);
          const m = g.position, v = new Zx(_, [0, t.duration], [m.x, m.y, m.z, m.x, m.y, m.z]);
          t.tracks.push(v), this.createPositionInterpolant(t, e, v);
        }
    }
  }
  bind() {
    if (!this._didBind) {
      this._didBind = !0, Rn && console.log(this.models), this.mixer ? this.target = this.mixer.getRoot() : console.warn("No mixer was assigned to animation track");
      for (const e of this.actions) {
        const t = new $E(e);
        this._actionOffsets.push(t);
      }
      this.target && (this._animator = S.getComponent(this.target, At) ?? null, this._animator && l_(this._animator.gameObject, this, !0));
      for (const e of this.models) {
        const t = e.asset, i = t.position, n = t.rotation;
        i && i.x !== void 0 && (i.isVector3 || (t.position = new b(i.x, i.y, i.z)), n.isQuaternion || (t.rotation = new $(n.x, n.y, n.z, n.w)));
      }
      this.ensureTrackOffsets();
    }
  }
  ensureTrackOffsets() {
    if (this.trackOffset) {
      const e = this.trackOffset.position;
      e && (e.isVector3 || (this.trackOffset.position = new b(e.x, e.y, e.z)));
      const t = this.trackOffset.rotation;
      t && (t.isQuaternion || (this.trackOffset.rotation = new $(t.x, t.y, t.z, t.w)));
    }
  }
  _useclipOffsets = !0;
  _totalOffsetPosition = new b();
  _totalOffsetRotation = new $();
  _totalOffsetPosition2 = new b();
  _totalOffsetRotation2 = new $();
  _summedPos = new b();
  _tempPos = new b();
  _summedRot = new $();
  _tempRot = new $();
  _clipRotQuat = new $();
  evaluate(e) {
    if (this.track.muted || !this.mixer) return;
    this.bind(), this._totalOffsetPosition.set(0, 0, 0), this._totalOffsetRotation.set(0, 0, 0, 1), this._totalOffsetPosition2.set(0, 0, 0), this._totalOffsetRotation2.set(0, 0, 0, 1);
    let t = 0, i = 0, n = !1, o = !1, r = 0;
    for (let a = 0; a < this.clips.length; a++) {
      const l = this.models[a], c = this.actions[a], h = l.asset;
      c.weight = 0;
      const d = e >= l.start && e <= l.end, f = l.preExtrapolationMode, p = l.postExtrapolationMode, g = a < this.clips.length - 1 ? this.models[a + 1] : null;
      let _ = d, m = !1;
      if (!_ && !n && l.end < e && p !== rs.None ? (!g || g.start > e) && (_ = !0, n = !0) : a == 0 && !_ && !o && l.start > e && f !== rs.None && (!g || g.start < e) && (_ = !0, m = !0, o = !0), _) {
        let v = this.weight;
        v *= this.evaluateWeight(e, a, this.models, _), v *= this.director.weight;
        let y = d;
        if (m)
          switch (f) {
            case rs.Hold:
              break;
            case rs.Loop:
              e += l.start, y = !0;
              break;
            default:
              e += l.start, y = !0;
              break;
          }
        let x = this.getClipTime(e, l), I = 0;
        const O = h.duration;
        if (m && f === rs.Hold && (x = 0), y) {
          if (h.loop)
            for (I += Math.floor(x / (O + 1e-6)); x > O; )
              x -= O;
        } else if (!d && n)
          switch (p) {
            case rs.Hold:
              x = this.getClipTime(l.end, l);
              break;
            case rs.Loop:
              x %= O;
              break;
            case rs.PingPong:
              const z = Math.floor(x / O) % 2 !== 0;
              x %= O, z && (x = O - x);
              break;
          }
        l.reversed === !0 ? c.time = c.getClip().duration - x : c.time = x, c.timeScale = 0;
        const k = Math.max(0, v);
        if (c.weight = k, r += k, c.clampWhenFinished = !1, c.isRunning() || c.play(), this._useclipOffsets) {
          const E = t == 0 ? this._totalOffsetPosition : this._totalOffsetPosition2, z = t == 0 ? this._totalOffsetRotation : this._totalOffsetRotation2;
          t < 1 && (i = 1 - v), t += 1;
          const D = this._summedPos.set(0, 0, 0), V = this._tempPos.set(0, 0, 0), q = this._summedRot.identity(), A = this._tempRot.identity(), U = h.rotation;
          U && (this._clipRotQuat.identity(), this._clipRotQuat.slerp(U, v));
          const W = this._actionOffsets[a];
          if (W.hasOffsets)
            for (let ne = 0; ne < I; ne++)
              W.rootPositionOffset ? V.copy(W.rootPositionOffset) : V.set(0, 0, 0), V.applyQuaternion(q), this._clipRotQuat && V.applyQuaternion(this._clipRotQuat), W.rootQuaternionOffset && (A.copy(W.rootQuaternionOffset), q.multiply(A)), D.add(V);
          this._clipRotQuat && z.multiply(this._clipRotQuat), z.multiply(q), h.position && D.add(h.position), E.add(D);
        }
      }
    }
    if (this._useclipOffsets && (this._totalOffsetPosition.lerp(this._totalOffsetPosition2, i), this._totalOffsetRotation.slerp(this._totalOffsetRotation2, i)), this.__mixerError === void 0 && (Rn || L()) && this._animator?.runtimeAnimatorController?.mixer && this.mixer !== this._animator?.runtimeAnimatorController?.mixer && (this.__mixerError = !0, console.error("AnimationTrack mixer is not shared with the animator controller - this might result in the timeline to not animate properly. Please report a bug to the Needle Engine team!", this)), this._animator?.runtimeAnimatorController) {
      const a = Math.max(0, 1 - r);
      this._animator?.runtimeAnimatorController?.update(a);
    } else
      this.mixer.update(e);
  }
  createRotationInterpolant(e, t, i) {
    const n = i.createInterpolant.bind(i), o = new $();
    this.ensureTrackOffsets();
    const r = this.trackOffset?.rotation;
    i.createInterpolant = () => {
      const a = n(), l = a.evaluate.bind(a);
      return a.evaluate = (c) => {
        const h = l(c);
        if (o.set(h[0], h[1], h[2], h[3]), o.premultiply(this._totalOffsetRotation), r && o.premultiply(r), this.director.animationCallbackReceivers)
          for (const d of this.director.animationCallbackReceivers)
            d?.onTimelineRotation?.call(d, this.director, this.target, c, o);
        return h[0] = o.x, h[1] = o.y, h[2] = o.z, h[3] = o.w, h;
      }, a;
    };
  }
  createPositionInterpolant(e, t, i) {
    const n = i.createInterpolant.bind(i), o = new b();
    this.ensureTrackOffsets();
    const r = this.trackOffset?.rotation, a = this.trackOffset?.position;
    let l;
    i.createInterpolant = () => {
      const c = n(), h = c.evaluate.bind(c);
      return c.evaluate = (d) => {
        const f = h(d);
        if (o.set(f[0], f[1], f[2]), t.removeStartOffset && (l === void 0 ? (l = null, l = this._actionOffsets.find((p) => p.clip === e)?.rootStartPosition?.clone()) : l?.isVector3 && o.sub(l)), o.applyQuaternion(this._totalOffsetRotation), o.add(this._totalOffsetPosition), r && o.applyQuaternion(r), a && (o.x -= a.x, o.y += a.y, o.z += a.z), this.director.animationCallbackReceivers)
          for (const p of this.director.animationCallbackReceivers)
            p?.onTimelinePosition?.call(p, this.director, this.target, d, o);
        return f[0] = o.x, f[1] = o.y, f[2] = o.z, f;
      }, c;
    };
  }
}
const WE = w("mutetimeline");
class to extends Du {
  models = [];
  listener;
  audio = [];
  audioContextTimeOffset = [];
  lastTime = 0;
  audioSource;
  _audioLoader = null;
  getAudioFilePath(e) {
    const t = this.director.sourceId;
    return fr(t, e);
  }
  onAllowAudioChanged(e) {
    for (let t = 0; t < this.models.length; t++) {
      const i = this.models[t];
      this.audio[t].setVolume(e ? i.asset.volume : 0);
    }
  }
  addModel(e) {
    const t = new eS(this.listener);
    this.audio.push(t);
    const i = e;
    i._didTriggerPlay = !1, this.models.push(i);
  }
  onDisable() {
    for (const e of this.audio)
      e.isPlaying && e.stop();
    for (const e of this.models)
      e._didTriggerPlay = !1;
  }
  onDestroy() {
    for (const e of this.audio)
      e.source && e?.disconnect();
    this.audio.length = 0;
  }
  onMuteChanged() {
    if (this.muted)
      for (let e = 0; e < this.audio.length; e++) {
        const t = this.audio[e];
        t?.isPlaying && t.stop();
      }
  }
  stop() {
    for (let e = 0; e < this.audio.length; e++) {
      const t = this.audio[e];
      t?.isPlaying && t.stop();
    }
    for (const e of this.models)
      e._didTriggerPlay = !1;
  }
  _playableDirectorResumed = !1;
  onPauseChanged() {
    for (let e = 0; e < this.audio.length; e++) {
      const t = this.audio[e];
      t?.isPlaying && t.stop();
    }
    this._playableDirectorResumed = this.director.isPlaying;
  }
  evaluate(e) {
    if (WE || this.track.muted || this.director.speed < 0)
      return;
    const t = this.director.context.application.muted, i = this._playableDirectorResumed;
    this._playableDirectorResumed = !1;
    const n = t ? 0.1 : 0;
    for (let o = 0; o < this.models.length; o++) {
      const r = this.models[o], a = this.audio[o], l = r.asset;
      if ((!a || !a.buffer) && this.isInTimeRange(r, e - 1, e + 1) && this.handleAudioLoading(r, a), ln.userInteractionRegistered !== !1 && !(a === null || !a.buffer))
        if (a.playbackRate = this.director.context.time.timeScale * this.director.speed, a.loop = l.loop, e >= r.start && e <= r.end && e < this.director.duration) {
          if (!a.isPlaying || !this.director.isPlaying)
            (i || !r._didTriggerPlay && this.lastTime < e) && (r.duration * r.timeScale > 0.3 ? a.offset = r.clipIn + (e - r.start) * r.timeScale : a.offset = 0, Rn && console.log("Timeline Audio (" + this.track.name + ") play with offset " + a.offset + " - " + r.asset.clip), a.play(n), r._didTriggerPlay = !0);
          else {
            const h = r.clipIn + (e - r.start) * r.timeScale, d = a.context.currentTime - a._startedAt + a.offset;
            Math.abs(h - d) > 0.3 && (a.offset = h, a.stop(), a.play(n));
          }
          let c = l.volume;
          if (this.track.volume !== void 0 && (c *= this.track.volume), t && (c = 0), r.easeInDuration > 0) {
            const h = Math.min((e - r.start) / r.easeInDuration, 1);
            c *= h;
          }
          if (r.easeOutDuration > 0) {
            const h = Math.min((r.end - e) / r.easeOutDuration, 1);
            c *= h;
          }
          a.setVolume(c * this.director.weight);
        } else
          r._didTriggerPlay = !1, this.director.isPlaying && a.isPlaying && a.stop();
    }
    this.lastTime = e;
  }
  /** Call to load audio buffer for a specific time in the track. Can be used to preload the timeline audio */
  loadAudio(e, t = 0, i = 0) {
    let n = null;
    const o = e - i, r = e + t;
    for (const a of this.models)
      if (this.isInTimeRange(a, o, r)) {
        const l = this.audio[this.models.indexOf(a)], c = this.handleAudioLoading(a, l);
        c !== null && (n === null && (n = []), n.push(c));
      }
    return n !== null ? Promise.all(n) : null;
  }
  isInTimeRange(e, t, i) {
    return t <= e.start && i >= e.end || t >= e.start && t <= e.end || i >= e.start && i <= e.end;
  }
  static _audioBuffers = /* @__PURE__ */ new Map();
  static dispose() {
    to._audioBuffers.clear();
  }
  handleAudioLoading(e, t) {
    this._audioLoader || (this._audioLoader = new sp());
    const i = this.getAudioFilePath(e.asset.clip);
    if (to._audioBuffers.get(i)) {
      const o = to._audioBuffers.get(i);
      return o.then((r) => {
        r && t.setBuffer(r);
      }), o;
    }
    Rn && console.warn("LOAD audio track", i, this.director.sourceId);
    const n = new Promise((o, r) => {
      this._audioLoader.load(
        i,
        (a) => {
          t.setBuffer(a), o(a);
        },
        void 0,
        (a) => {
          console.error("Error loading audio", a), o(null);
        }
      );
    });
    return to._audioBuffers.set(i, n), n;
  }
}
class Pd extends Du {
  models = [];
  didTrigger = [];
  receivers = [];
  // TODO: test when timeline signals are being reset in Unity
  // onEnable() {
  //     for (let i = 0; i < this.didTrigger?.length; i++) {
  //         this.didTrigger[i] = false;
  //     }
  // }
  // private _lastTime: number = -1;
  evaluate(e) {
    if (this.track.muted) return;
    const t = this.director.context.time.deltaTime * 1.5;
    for (let i = 0; i < this.models.length; i++) {
      const n = this.models[i], o = this.didTrigger[i], r = n.time - e;
      let a = !1;
      if (n.retroActive)
        a = r <= 1e-6;
      else {
        const l = Math.abs(r);
        (l === 0 || l >= 1e-5 && l < t) && (a = !0);
      }
      if (a) {
        if (!o)
          if (Rn && console.log("Trigger signal", e, n.time, n), this.didTrigger[i] = !0, this.receivers?.length <= 0)
            Lu.invoke(n.asset);
          else
            for (const l of this.receivers)
              l && l.invoke(n.asset);
      } else
        n.emitOnce || (this.didTrigger[i] = !1);
    }
  }
}
class Fg extends Du {
  models = [];
  timelines = [];
  resolveSourceObjects(e) {
    for (let t = this.models.length - 1; t >= 0; t--) {
      const n = this.models[t].asset;
      if (!n.sourceObject || typeof n.sourceObject != "object") {
        console.log("no source object, removing model", t, n), this.models.splice(t, 1);
        continue;
      } else {
        const o = S.getComponent(n.sourceObject, fc);
        this.timelines.push(o), o && n.updateDirector && (o.playOnAwake = !1);
      }
    }
  }
  _previousActiveModel = null;
  evaluate(e) {
    this._previousActiveModel = null;
    for (let t = 0; t < this.models.length; t++) {
      const i = this.models[t], n = i.asset;
      if (e >= i.start && e <= i.end) {
        this._previousActiveModel = i;
        const o = this.getClipTime(e, i);
        if (n.controlActivation) {
          const r = n.sourceObject;
          r.visible = !0;
        }
        if (n.updateDirector) {
          const r = this.timelines[t];
          r && (r.isPlaying && r.pause(), r.time = o, r.evaluate());
        }
      } else {
        const o = this._previousActiveModel?.asset;
        if (n.controlActivation) {
          const r = n.sourceObject;
          o?.sourceObject !== r && (r.visible = !1);
        }
      }
    }
  }
}
var VE = Object.defineProperty, Cw = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && VE(e, t, n), n;
};
const ts = w("debugtimeline"), zg = class im extends T {
  static createTrackFunctions = {};
  static registerCreateTrack(e, t) {
    this.createTrackFunctions[e] = t;
  }
  playableAsset;
  playOnAwake;
  extrapolationMode = 1;
  /** @returns true if the timeline is currently playing */
  get isPlaying() {
    return this._isPlaying;
  }
  /** @returns true if the timeline is currently paused */
  get isPaused() {
    return this._isPaused;
  }
  /** the current time of the timeline */
  get time() {
    return this._time;
  }
  set time(e) {
    typeof e == "number" && !Number.isNaN(e) ? this._time = e : (ts || rn()) && console.error("INVALID TIMELINE.TIME VALUE", e, this.name);
  }
  /** the duration of the timeline */
  get duration() {
    return this._duration;
  }
  set duration(e) {
    this._duration = e;
  }
  /** the weight of the timeline. Set to a value below 1 to blend with other timelines */
  get weight() {
    return this._weight;
  }
  set weight(e) {
    this._weight = e;
  }
  /** the playback speed of the timeline */
  get speed() {
    return this._speed;
  }
  set speed(e) {
    this._speed = e;
  }
  /** When enabled the timeline will wait for audio tracks to load at the current time before starting to play */
  waitForAudio = !0;
  _visibilityChangeEvt;
  _clonedPlayableAsset = !1;
  _speed = 1;
  /** @internal */
  awake() {
    ts && console.log(this, this.playableAsset?.tracks), this.rebuildGraph(), !this.isValid() && (ts || L()) && (ts ? console.warn("PlayableDirector is not valid", "Asset?", this.playableAsset, "Tracks:", this.playableAsset?.tracks, "IsArray?", Array.isArray(this.playableAsset?.tracks), this) : this.playableAsset?.tracks?.length ? console.warn("PlayableDirector is not valid") : console.warn("PlayableDirector has no tracks"));
  }
  /** @internal */
  onEnable() {
    for (const e of this._audioTracks)
      e.onEnable?.();
    for (const e of this._customTracks)
      e.onEnable?.();
    for (const e of this._animationTracks)
      e.onEnable?.();
    this.playOnAwake && this.play(), this._visibilityChangeEvt || (this._visibilityChangeEvt = () => {
      switch (document.visibilityState) {
        case "hidden":
          this.setAudioTracksAllowPlaying(!1);
          break;
        case "visible":
          this.setAudioTracksAllowPlaying(!0);
          break;
      }
    }), window.addEventListener("visibilitychange", this._visibilityChangeEvt);
  }
  /** @internal */
  onDisable() {
    this.stop();
    for (const e of this._audioTracks)
      e.onDisable?.();
    for (const e of this._customTracks)
      e.onDisable?.();
    for (const e of this._animationTracks)
      e.onDisable?.();
    this._visibilityChangeEvt && window.removeEventListener("visibilitychange", this._visibilityChangeEvt);
  }
  /** @internal */
  onDestroy() {
    for (const e of this._allTracks)
      for (const t of e)
        t.onDestroy?.();
  }
  /** @internal */
  rebuildGraph() {
    this.isValid() && (this.resolveBindings(), this.updateTimelineDuration(), this.setupAndCreateTrackHandlers());
  }
  /**
   * Play the timeline from the current time.  
   * If the timeline is already playing this method does nothing.
   */
  async play() {
    if (!this.isValid()) return;
    const e = this._isPaused == !0;
    if (this._isPaused = !1, !this._isPlaying) {
      if (this._isPlaying = !0, e && this.invokePauseChangedMethodsOnTracks(), this.waitForAudio) {
        const t = [];
        for (const i of this._audioTracks) {
          const n = i.loadAudio(this._time, 1, 0);
          n && t.push(n);
        }
        if (t.length > 0 && (await Promise.all(t), !this._isPlaying))
          return;
        for (; this._audioTracks.length > 0 && this._isPlaying && !ln.userInteractionRegistered && this.waitForAudio; )
          await Os(200);
      }
      this.invokeStateChangedMethodsOnTracks(), this._internalUpdateRoutine = this.startCoroutine(this.internalUpdate(), xe.LateUpdate);
    }
  }
  /**
   * Pause the timeline.
   */
  pause() {
    this.isValid() && (this._isPlaying = !1, !this._isPaused && (this._isPaused = !0, this.internalEvaluate(), this.invokePauseChangedMethodsOnTracks(), this.invokeStateChangedMethodsOnTracks()));
  }
  /**
   * Stop the timeline.
   */
  stop() {
    this._isStopping = !0;
    for (const i of this._audioTracks) i.stop();
    const e = this._isPaused == !0, t = this._isPlaying;
    this._isPlaying && (this._time = 0, this._isPlaying = !1, this._isPaused = !1, this.internalEvaluate(), e && this.invokePauseChangedMethodsOnTracks()), this._isPlaying = !1, this._isPaused = !1, e && !t && this.invokePauseChangedMethodsOnTracks(), t && this.invokeStateChangedMethodsOnTracks(), this._internalUpdateRoutine && this.stopCoroutine(this._internalUpdateRoutine), this._internalUpdateRoutine = null, this._isStopping = !1;
  }
  /**
   * Evaluate the timeline at the current time. This is useful when you want to manually update the timeline e.g. when the timeline is paused and you set `time` to a new value.
   */
  evaluate() {
    this.internalEvaluate(!0);
  }
  /**
   * @returns true if the timeline is valid and has tracks
   */
  isValid() {
    return this.playableAsset && this.playableAsset.tracks && Array.isArray(this.playableAsset.tracks);
  }
  /** Iterates over all tracks of the timeline
   * @returns all tracks of the timeline
   */
  *forEachTrack() {
    for (const e of this._allTracks)
      for (const t of e)
        yield t;
  }
  /**
   * @returns all animation tracks of the timeline
   */
  get animationTracks() {
    return this._animationTracks;
  }
  /**
   * @returns all audio tracks of the timeline
   */
  get audioTracks() {
    return this._audioTracks;
  }
  _guidsMap;
  /** @internal */
  resolveGuids(e) {
    this._guidsMap = e;
  }
  // INTERNALS
  _isPlaying = !1;
  _internalUpdateRoutine;
  _isPaused = !1;
  /** internal, true during the time stop() is being processed */
  _isStopping = !1;
  _time = 0;
  _duration = 0;
  _weight = 1;
  _animationTracks = [];
  _audioTracks = [];
  _signalTracks = [];
  _controlTracks = [];
  _customTracks = [];
  _allTracks = [
    this._animationTracks,
    this._audioTracks,
    this._signalTracks,
    this._controlTracks,
    this._customTracks
  ];
  /** should be called after evaluate if the director was playing */
  invokePauseChangedMethodsOnTracks() {
    for (const e of this.forEachTrack())
      e.onPauseChanged?.call(e);
  }
  invokeStateChangedMethodsOnTracks() {
    for (const e of this.forEachTrack())
      e.onStateChanged?.call(e, this._isPlaying);
  }
  *internalUpdate() {
    for (; this._isPlaying && this.activeAndEnabled; )
      !this._isPaused && this._isPlaying && (this._time += this.context.time.deltaTime * this.speed, this.internalEvaluate()), yield;
  }
  /**
   * PlayableDirector lifecycle should always call this instead of "evaluate"
   * @param called_by_user If true the evaluation is called by the user (e.g. via evaluate())
   */
  internalEvaluate(e = !1) {
    if (!this.isValid()) return;
    let t = this._time;
    switch (this.extrapolationMode) {
      case 0:
        this._speed > 0 ? t = Math.min(t, this._duration) : this._speed < 0 && (t = Math.max(t, 0)), this._time = t;
        break;
      case 1:
        t %= this._duration, this._time = t;
        break;
      case 2:
        if (t > this._duration) {
          this.stop();
          return;
        }
        break;
    }
    const i = this._time;
    for (const n of this.playableAsset.tracks)
      if (!n.muted)
        switch (n.type) {
          case Di.Activation:
            if (!e && !this._isPlaying) continue;
            for (let o = 0; o < n.outputs.length; o++) {
              const r = n.outputs[o];
              if (typeof r == "object") {
                let a = !1;
                if (n.clips)
                  for (const c of n.clips)
                    c.start <= i && i <= c.end && (a = !0);
                const l = r;
                l.visible !== void 0 && l.visible !== a && (l.visible = a, ts && console.warn(this.name, "set ActivationTrack-" + o, l.name, a, i));
              }
            }
            break;
        }
    if (!this._isStopping)
      for (const n of this._animationTracks)
        n.evaluate(i);
    for (const n of this._audioTracks)
      n.evaluate(i);
    for (const n of this._signalTracks)
      n.evaluate(i);
    for (const n of this._controlTracks)
      n.evaluate(i);
    for (const n of this._customTracks)
      n.evaluate(i);
  }
  resolveBindings() {
    if (this._clonedPlayableAsset || (this._clonedPlayableAsset = !0, this.playableAsset = zd(this.playableAsset)), !this.playableAsset || !this.playableAsset.tracks) return;
    const e = this.findRoot(this.gameObject);
    for (const t of this.playableAsset.tracks) {
      for (let i = t.outputs.length - 1; i >= 0; i--) {
        let n = t.outputs[i];
        if (typeof n == "string") {
          this._guidsMap && this._guidsMap[n] && (n = this._guidsMap[n]);
          const o = S.findByGuid(n, e);
          o === null || typeof o != "object" ? (t.outputs.splice(i, 1), console.warn("Failed to resolve binding", n, t.name, t.type)) : (ts && console.log("Resolved binding", n, "to", o), t.outputs[i] = o);
        } else if (n === null) {
          if (t.outputs.splice(i, 1), im.createTrackFunctions[t.type])
            continue;
          t.type !== Di.Audio && t.type !== Di.Control && t.type !== Di.Marker && t.type !== Di.Signal && console.warn("Missing binding", n, t.name, t.type, this.name, this.playableAsset.name);
        }
      }
      if (t.type === Di.Control && t.clips)
        for (let i = 0; i < t.clips.length; i++) {
          const n = t.clips[i];
          let o = n.asset.sourceObject;
          if (typeof o == "string") {
            this._guidsMap && this._guidsMap[o] && (o = this._guidsMap[o]);
            const r = S.findByGuid(o, e);
            r === null || typeof r != "object" ? console.warn("Failed to resolve sourceObject binding", o, t.name, n) : (ts && console.log("Resolved binding", o, "to", r), n.asset.sourceObject = r);
          }
        }
    }
  }
  findRoot(e) {
    return e.parent ? this.findRoot(e.parent) : e;
  }
  updateTimelineDuration() {
    if (this._duration = 0, !(!this.playableAsset || !this.playableAsset.tracks)) {
      for (const e of this.playableAsset.tracks)
        if (e.muted !== !0) {
          if (e.clips)
            for (const t of e.clips)
              t.end > this._duration && (this._duration = t.end);
          if (e.markers)
            for (const t of e.markers)
              t.time > this._duration && (this._duration = t.time + 1e-3);
        }
    }
  }
  setupAndCreateTrackHandlers() {
    if (this._animationTracks.length = 0, this._audioTracks.length = 0, this._signalTracks.length = 0, !this.playableAsset) return;
    let e = S.findObjectOfType(Js, this.context);
    for (const t of this.playableAsset.tracks) {
      const i = t.type, n = im.createTrackFunctions[i];
      if (n != null) {
        const o = n(this, t);
        if (typeof o.evaluate == "function") {
          o.director = this, o.track = t, this._customTracks.push(o);
          continue;
        }
      }
      if (t.type === Di.Animation) {
        if (!t.clips || t.clips.length <= 0) {
          ts && console.warn("Animation track has no clips", t);
          continue;
        }
        for (let o = t.outputs.length - 1; o >= 0; o--) {
          let r = t.outputs[o];
          if (r instanceof M) {
            const l = S.getOrAddComponent(r, At);
            l && (r = l);
          }
          const a = r?.gameObject?.animations;
          if (a) {
            const l = new Bg();
            l.trackOffset = t.trackOffset, l.director = this, l.track = t;
            for (let c = 0; c < t.clips.length; c++) {
              const h = t.clips[c], d = h.asset;
              if (!d) {
                console.error(`Timeline ${this.name}: clip #${c} on track "${t.name}" has no animation data`);
                continue;
              }
              const f = d.clip;
              let p = f;
              if ((typeof p == "string" || typeof p == "number") && (p = a.find((_) => _.name === f)), ts && console.log(d, f, "→", p), !p) {
                console.warn("Could not find animationClip for model", h, t.name, this.name, this.playableAsset?.name, a, r);
                continue;
              }
              r instanceof At && r.runtimeAnimatorController && (r.__internalDidAwakeAndStart || r.initializeRuntimeAnimatorController(), r.runtimeAnimatorController.mixer || r.runtimeAnimatorController.bind(r), l.mixer = r.runtimeAnimatorController.mixer), l.mixer || (l.mixer = new dm(r.gameObject), this.context.animations.registerAnimationMixer(l.mixer)), l.clips.push(p), l.mixer.uncacheAction(p), l.createHooks(h.asset, p);
              const g = l.mixer.clipAction(p);
              l.actions.push(g), l.models.push(h);
            }
            this._animationTracks.push(l);
          }
        }
      } else if (t.type === Di.Audio) {
        if (!t.clips || t.clips.length <= 0) continue;
        const o = new to();
        o.director = this, o.track = t, o.audioSource = t.outputs.find((r) => r instanceof ln), this._audioTracks.push(o), e || (e = this.context.mainCameraComponent?.gameObject.addComponent(Js)), o.listener = e.listener;
        for (let r = 0; r < t.clips.length; r++) {
          const a = t.clips[r];
          o.addModel(a);
        }
      } else if (t.type === Di.Marker) {
        const o = new Pd();
        if (o.director = this, o.track = t, t.markers)
          for (const r of t.markers)
            switch (r.type) {
              case Sw.Signal:
                o.models.push(r), o.didTrigger.push(!1);
                break;
            }
        if (o !== null && o.models.length > 0) {
          const r = S.getComponent(this.gameObject, Lu);
          r && (o.receivers.push(r), this._signalTracks.push(o));
        }
      } else if (t.type === Di.Signal) {
        const o = new Pd();
        if (o.director = this, o.track = t, t.markers)
          for (const r of t.markers)
            o.models.push(r), o.didTrigger.push(!1);
        for (const r of t.outputs)
          o.receivers.push(r);
        this._signalTracks.push(o);
      } else if (t.type === Di.Control) {
        const o = new Fg();
        if (o.director = this, o.track = t, t.clips)
          for (const r of t.clips)
            o.models.push(r);
        o.resolveSourceObjects(this.context), this._controlTracks.push(o);
      }
    }
  }
  setAudioTracksAllowPlaying(e) {
    for (const t of this._audioTracks)
      t.onAllowAudioChanged(e);
  }
  /** Experimental support for overriding timeline animation data (position or rotation) */
  animationCallbackReceivers = [];
  /** Experimental: Receive callbacks for timeline animation. Allows modification of final value */
  registerAnimationCallback(e) {
    this.animationCallbackReceivers.push(e);
  }
  /** Experimental: Unregister callbacks for timeline animation. Allows modification of final value */
  unregisterAnimationCallback(e) {
    const t = this.animationCallbackReceivers.indexOf(e);
    t !== -1 && this.animationCallbackReceivers.splice(t, 1);
  }
};
Cw([
  u()
], zg.prototype, "playOnAwake");
Cw([
  u()
], zg.prototype, "extrapolationMode");
let fc = zg;
var HE = Object.defineProperty, ju = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && HE(e, t, n), n;
};
class qa extends T {
  isGizmo = !1;
  translationSnap = 1;
  rotationSnapAngle = 15;
  scaleSnap = 0.25;
  /**
   * Gets the underlying three.js {@link TransformControls} instance.
   * @returns The TransformControls instance or undefined if not initialized.
   */
  get control() {
    return this._control;
  }
  _control;
  orbit;
  /** @internal */
  onEnable() {
    if (!(this.isGizmo && !mc) && this.context.mainCamera && (this._control || (this._control = new xS(this.context.mainCamera, this.context.renderer.domElement), this._control.enabled = !0, this._control.getRaycaster().layers.set(2), this._control.size = 1, ("_root" in this._control ? this._control._root : this._control).traverse((t) => {
      const i = t;
      if (i.layers.set(2), i) {
        const n = i.material;
        n && (n.opacity = 0.3);
      }
    }), this.orbit = S.getComponentInParent(this.context.mainCamera, ye) ?? void 0), this._control)) {
      const e = this._control.getHelper();
      this.context.scene.add(e), this._control.attach(this.gameObject), this._control?.addEventListener("dragging-changed", this.onControlChangedEvent), window.addEventListener("keydown", this.windowKeyDownListener), window.addEventListener("keyup", this.windowKeyUpListener);
    }
  }
  /** @internal */
  onDisable() {
    this._control?.getHelper()?.removeFromParent(), this._control?.removeEventListener("dragging-changed", this.onControlChangedEvent), window.removeEventListener("keydown", this.windowKeyDownListener), window.removeEventListener("keyup", this.windowKeyUpListener);
  }
  /**
   * Enables grid snapping for transform operations according to set snap values.
   * This applies the translationSnap, rotationSnapAngle, and scaleSnap properties to the controls.
   */
  enableSnapping() {
    this._control && (this._control.setTranslationSnap(this.translationSnap), this._control.setRotationSnap(gs.degToRad(this.rotationSnapAngle)), this._control.setScaleSnap(this.scaleSnap));
  }
  /**
   * Disables grid snapping for transform operations.
   * Removes all snapping constraints from the transform controls.
   */
  disableSnapping() {
    this._control && (this._control.setTranslationSnap(null), this._control.setRotationSnap(null), this._control.setScaleSnap(null));
  }
  /**
   * Event handler for when dragging state changes.
   * Disables orbit controls during dragging and requests ownership of the transform if it's synchronized.
   * @param event The drag change event
   */
  onControlChangedEvent = (e) => {
    const t = this.orbit;
    if (t && (t.enabled = !e.value), e.value) {
      const i = this.gameObject.getComponentInParent(Fn);
      i && (i.fastMode = !0, i.requestOwnership());
    } else {
      const i = this.gameObject.getComponentInParent(Fn);
      i && (i.fastMode = !1);
    }
  };
  /**
   * Handles keyboard shortcuts for transform operations:
   * - Q: Toggle local/world space
   * - W: Translation mode
   * - E: Rotation mode
   * - R: Scale mode
   * - Shift: Enable snapping (while held)
   * - +/-: Adjust gizmo size
   * - X/Y/Z: Toggle visibility of respective axis
   * - Spacebar: Toggle controls enabled state
   * @param event The keyboard event
   */
  windowKeyDownListener = (e) => {
    if (this.enabled && this._control)
      switch (e.keyCode) {
        case 81:
          this._control.setSpace(this._control.space === "local" ? "world" : "local");
          break;
        case 16:
          this.enableSnapping();
          break;
        case 87:
          this._control.setMode("translate");
          break;
        case 69:
          this._control.setMode("rotate");
          break;
        case 82:
          this._control.setMode("scale");
          break;
        case 187:
        case 107:
          this._control.setSize(this._control.size + 0.1);
          break;
        case 189:
        case 109:
          this._control.setSize(Math.max(this._control.size - 0.1, 0.1));
          break;
        case 88:
          this._control.showX = !this._control.showX;
          break;
        case 89:
          this._control.showY = !this._control.showY;
          break;
        case 90:
          this._control.showZ = !this._control.showZ;
          break;
        case 32:
          this._control.enabled = !this._control.enabled;
          break;
      }
  };
  /**
   * Handles keyboard key release events.
   * Currently only handles releasing Shift key to disable snapping.
   * @param event The keyboard event
   */
  windowKeyUpListener = (e) => {
    if (this.enabled)
      switch (e.keyCode) {
        case 16:
          this.disableSnapping();
          break;
      }
  };
}
ju([
  u()
], qa.prototype, "isGizmo");
ju([
  u()
], qa.prototype, "translationSnap");
ju([
  u()
], qa.prototype, "rotationSnapAngle");
ju([
  u()
], qa.prototype, "scaleSnap");
var GE = Object.defineProperty, qE = Object.getOwnPropertyDescriptor, Bu = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? qE(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && GE(e, t, n), n;
};
class Ug {
  texture = null;
  rect;
}
Bu([
  u(Te)
], Ug.prototype, "texture", 2);
let Uc = class extends _u {
  set image(e) {
    this.sprite || (this.sprite = new Ug()), this.sprite.texture = e, this.onAfterCreated();
  }
  get image() {
    return this.sprite ? this.sprite.texture : null;
  }
  get sprite() {
    return this._sprite;
  }
  set sprite(e) {
    this._sprite !== e && (this._sprite = e, this.onAfterCreated());
  }
  _sprite;
  pixelsPerUnitMultiplier = 1;
  isBuiltinSprite() {
    const e = this.sprite;
    switch (e?.texture?.name) {
      case "InputFieldBackground":
      case "UISprite":
      case "Background":
      case "Knob":
        return !0;
    }
    return !e?.texture?.name?.length && e?.texture?.image?.width === 32 && e?.texture?.image?.height === 32;
  }
  onBeforeCreate(e) {
    super.onBeforeCreate(e), this.isBuiltinSprite() && (e.borderRadius = 5 / this.pixelsPerUnitMultiplier, this.sprite?.texture?.name === "Knob" && (e.borderRadius = 999));
  }
  onAfterCreated() {
    this.__didAwake && (super.onAfterCreated(), !this.isBuiltinSprite() && this.setTexture(this.sprite?.texture));
  }
};
Bu([
  u(Ug)
], Uc.prototype, "sprite", 1);
Bu([
  u()
], Uc.prototype, "pixelsPerUnitMultiplier", 2);
class Ng extends _u {
  get mainTexture() {
    return this._mainTexture;
  }
  set mainTexture(e) {
    this._mainTexture !== e && (this._mainTexture = e, this.onAfterCreated());
  }
  _mainTexture;
  onAfterCreated() {
    this.__didAwake && (super.onAfterCreated(), this.setTexture(this.mainTexture));
  }
}
Bu([
  u(Te)
], Ng.prototype, "mainTexture", 1);
var XE = Object.defineProperty, QE = Object.getOwnPropertyDescriptor, Oi = (s, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? QE(e, t) : e, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = (i ? r(e, t, n) : r(n)) || n);
  return i && n && XE(e, t, n), n;
};
const Fo = w("debugbutton");
class Oo {
  colorMultiplier;
  disabledColor;
  fadeDuration;
  highlightedColor;
  normalColor;
  pressedColor;
  selectedColor;
}
Oi([
  u()
], Oo.prototype, "colorMultiplier", 2);
Oi([
  u(oe)
], Oo.prototype, "disabledColor", 2);
Oi([
  u()
], Oo.prototype, "fadeDuration", 2);
Oi([
  u(oe)
], Oo.prototype, "highlightedColor", 2);
Oi([
  u(oe)
], Oo.prototype, "normalColor", 2);
Oi([
  u(oe)
], Oo.prototype, "pressedColor", 2);
Oi([
  u(oe)
], Oo.prototype, "selectedColor", 2);
class YE {
  disabledTrigger;
  highlightedTrigger;
  normalTrigger;
  pressedTrigger;
  selectedTrigger;
}
class ko extends T {
  /**
   * Invokes the onClick event
   */
  click() {
    this.onClick?.invoke();
  }
  onClick = new me();
  _isHovered = 0;
  onPointerEnter(e) {
    const t = e.event.pointerType === "mouse" && e.button === 0;
    t && (this._isHovered += 1), Fo && console.warn("Button Enter", t, this._isHovered, this.animationTriggers?.highlightedTrigger, this.animator), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.highlightedTrigger) : this.transition === 1 && this.colors && this._image?.setState("hovered"), t && this.context.input.setCursor("pointer"));
  }
  onPointerExit() {
    this._isHovered -= 1, this._isHovered < 0 && (this._isHovered = 0), Fo && console.log("Button Exit", this._isHovered, this.animationTriggers?.highlightedTrigger, this.animator), this.interactable && (this._isHovered > 0 || (this._isHovered = 0, this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.normalTrigger) : this.transition === 1 && this.colors && this._image?.setState("normal"), this.context.input.unsetCursor("pointer")));
  }
  onPointerDown(e) {
    Fo && console.log("Button Down", this.animationTriggers?.highlightedTrigger, this.animator), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.pressedTrigger) : this.transition === 1 && this.colors && this._image?.setState("pressed"));
  }
  onPointerUp(e) {
    Fo && console.warn("Button Up", this.animationTriggers?.highlightedTrigger, this.animator, this._isHovered), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this._isHovered ? this.animationTriggers.highlightedTrigger : this.animationTriggers.normalTrigger) : this.transition === 1 && this.colors && this._image?.setState(this._isHovered ? "hovered" : "normal"));
  }
  onPointerClick(e) {
    if (this.interactable && !(e.button !== 0 && e.event.pointerType === km.Mouse) && (Fo && (console.warn("Button Click", this.onClick), Be("CLICKED button " + this.name + " at " + this.context.time.frameCount)), this.onClick && this.onClick.listenerCount > 0 && (this.onClick.invoke(), e.use(), Fo))) {
      const t = this.gameObject.worldPosition;
      t.add(this.gameObject.worldUp.multiplyScalar(1 + Math.random() * 0.5)), F.DrawLabel(t, "CLICK:" + Date.now(), 0.1, 1 + Math.random() * 0.5);
    }
  }
  colors;
  transition;
  animationTriggers;
  animator;
  set interactable(e) {
    this._interactable = e, this._image && (this._image.setInteractable(e), e ? this._image.setState("normal") : this._image.setState("disabled"));
  }
  get interactable() {
    return this._interactable;
  }
  _interactable = !0;
  set_interactable(e) {
    this.interactable = e;
  }
  awake() {
    super.awake(), Fo && console.log(this), this._isInit = !1, this.init();
  }
  start() {
    this._image?.setInteractable(this.interactable), this.gameObject.getComponentInParent(Sa) || this.gameObject.addComponent(Gm);
  }
  onEnable() {
    super.onEnable();
  }
  onDestroy() {
    this._isHovered && this.context.input.unsetCursor("pointer");
  }
  _requestedAnimatorTrigger;
  *setAnimatorTriggerAtEndOfFrame(e) {
    this._requestedAnimatorTrigger = e, yield, yield, this._requestedAnimatorTrigger == e && this.animator?.setTrigger(e);
  }
  _isInit = !1;
  _image;
  init() {
    this._isInit || (this._isInit = !0, this._image = S.getComponent(this.gameObject, Uc), this._image && (this.stateSetup(this._image), this.interactable ? this._image.setState("normal") : this._image.setState("disabled")));
  }
  stateSetup(e) {
    e.setInteractable(this.interactable);
    const t = this.getFinalColor(e.color, this.colors?.normalColor), i = {
      state: "normal",
      attributes: {
        backgroundColor: t,
        backgroundOpacity: t.alpha
      }
    };
    e.setupState(i);
    const n = this.getFinalColor(e.color, this.colors?.highlightedColor), o = {
      state: "hovered",
      attributes: {
        backgroundColor: n,
        backgroundOpacity: n.alpha
      }
    };
    e.setupState(o);
    const r = this.getFinalColor(e.color, this.colors?.pressedColor), a = {
      state: "pressed",
      attributes: {
        backgroundColor: r,
        backgroundOpacity: r.alpha
      }
    };
    e.setupState(a);
    const l = this.getFinalColor(e.color, this.colors?.selectedColor), c = {
      state: "selected",
      attributes: {
        backgroundColor: l,
        backgroundOpacity: l.alpha
      }
    };
    e.setupState(c);
    const h = this.getFinalColor(e.color, this.colors?.disabledColor), d = {
      state: "disabled",
      attributes: {
        backgroundColor: h,
        // @marwie, this disabled alpha property doesn't seem to have the opacity requested in unity
        backgroundOpacity: h.alpha
      }
    };
    e.setupState(d);
  }
  getFinalColor(e, t) {
    return t ? e.clone().multiply(t).convertLinearToSRGB() : e.clone().convertLinearToSRGB();
  }
}
Oi([
  u(me)
], ko.prototype, "onClick", 2);
Oi([
  u(Oo)
], ko.prototype, "colors", 2);
Oi([
  u()
], ko.prototype, "transition", 2);
Oi([
  u(YE)
], ko.prototype, "animationTriggers", 2);
Oi([
  u(At)
], ko.prototype, "animator", 2);
Oi([
  u()
], ko.prototype, "interactable", 1);
var KE = Object.defineProperty, Fu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && KE(e, t, n), n;
};
const $s = w("debuginputfield"), Nc = class Q extends T {
  get text() {
    return this.textComponent?.text ?? "";
  }
  set text(e) {
    this.textComponent && (this.textComponent.text = e, this.placeholder && (e.length > 0 ? this.placeholder.gameObject.visible = !1 : this.placeholder.gameObject.visible = !0));
  }
  get isFocused() {
    return Q.active === this;
  }
  textComponent;
  placeholder;
  onValueChanged;
  onEndEdit;
  static active = null;
  static activeTime = -1;
  static htmlField = null;
  static htmlFieldFocused = !1;
  inputEventFn;
  _iosEventFn;
  start() {
    $s && console.log(this.name, this);
  }
  onEnable() {
    Q.htmlField || (Q.htmlField = document.createElement("input"), Q.htmlField.style.width = "0px", Q.htmlField.style.height = "0px", Q.htmlField.style.padding = "0px", Q.htmlField.style.border = "none", Q.htmlField.style.overflow = "hidden", Q.htmlField.style.caretColor = "transparent", Q.htmlField.style.outline = "none", Q.htmlField.classList.add("ar"), Q.htmlField.onfocus = () => Q.htmlFieldFocused = !0, Q.htmlField.onblur = () => Q.htmlFieldFocused = !1, document.body.append(Q.htmlField)), this.inputEventFn || (this.inputEventFn = this.onInput.bind(this)), Q.htmlField.addEventListener("keyup", this.inputEventFn), this.placeholder && this.textComponent?.text.length && S.setActive(this.placeholder.gameObject, !1), X.isiOS() && (this._iosEventFn = this.processInputOniOS.bind(this), window.addEventListener("click", this._iosEventFn));
  }
  onDisable() {
    Q.htmlField?.removeEventListener("keyup", this.inputEventFn), this.onDeselected(), this._iosEventFn && window.removeEventListener("click", this._iosEventFn);
  }
  /** Clear the input field if it's currently active */
  clear() {
    Q.active === this && Q.htmlField ? (Q.htmlField.value = "", this.setTextFromInputField()) : (this.textComponent && (this.textComponent.text = ""), this.placeholder && S.setActive(this.placeholder.gameObject, !0));
  }
  /** Select the input field, set it active to receive keyboard input */
  select() {
    this.onSelected();
  }
  /** Deselect the input field, stop receiving keyboard input */
  deselect() {
    this.onDeselected();
  }
  onPointerEnter(e) {
    e.event.pointerType === "mouse" && e.button === 0 && this.context.input.setCursor("text");
  }
  onPointerExit(e) {
    this.context.input.unsetCursor("text");
  }
  onPointerClick(e) {
    $s && console.log("CLICK", e, Q.active), Q.activeTime = this.context.time.time, Q.active !== this && this.startCoroutine(this.activeLoop(), xe.LateUpdate), this.selectInputField();
  }
  *activeLoop() {
    for (this.onSelected(); Q.active === this && !(this.context.input.getPointerClicked(0) && this.context.time.time - Q.activeTime > 0.2); )
      this.setTextFromInputField(), yield;
    this.onDeselected();
  }
  onSelected() {
    if (Q.active !== this && ($s && console.log("Select", this.name, this, Q.htmlField, this.context.isInXR, this.context.arOverlayElement, this.textComponent?.text, Q.htmlField?.value), Q.active?.onDeselected(), Q.active = this, this.placeholder && S.setActive(this.placeholder.gameObject, !1), Q.htmlField)) {
      if (Q.htmlField.value = this.textComponent?.text || "", $s && console.log("set input field value", Q.htmlField.value), this.context.isInXR) {
        const e = this.context.arOverlayElement;
        e && e.append(Q.htmlField);
      }
      this.selectInputField();
    }
  }
  onDeselected() {
    Q.active === this && (Q.active = null, $s && console.log("Deselect", this.name, this), Q.htmlField && (Q.htmlField.blur(), document.body.append(Q.htmlField)), this.placeholder && (!this.textComponent || this.textComponent.text.length <= 0) && S.setActive(this.placeholder.gameObject, !0), Q.htmlField && this.onEndEdit?.invoke(Q.htmlField.value));
  }
  // @Marwie, I can provide this fix. But the issue seems to comes from Raycaster+EventSystem
  // As we rollout InputField, and no others elements is behind raycast,
  // ThreeMeshUI.update is not called.
  update() {
    Q.active === this && this.textComponent?.markDirty();
  }
  onInput(e) {
    if (Q.active === this) {
      if ($s && console.log(e.code, e, Q.htmlField?.value, this.textComponent?.text), e.code === "Escape" || e.code === "Enter") {
        this.onDeselected();
        return;
      }
      Q.htmlField && (this.textComponent && (this.setTextFromInputField(), this.placeholder && S.setActive(this.placeholder.gameObject, this.textComponent.text.length <= 0)), this.selectInputField());
    }
  }
  setTextFromInputField() {
    if (this.textComponent && Q.htmlField) {
      const e = this.textComponent.text, t = Q.htmlField.value, i = this.textComponent.text !== Q.htmlField.value;
      this.textComponent.text = Q.htmlField.value, i && ($s && console.log("[InputField] value changed:", t, e), this.onValueChanged?.invoke(t, e));
    }
  }
  selectInputField() {
    Q.htmlField && ($s && console.log("Focus Inputfield", Q.htmlFieldFocused), Q.htmlField.setSelectionRange(Q.htmlField.value.length, Q.htmlField.value.length), X.isiOS() ? Q.htmlField.focus({ preventScroll: !0 }) : setTimeout(() => Q.htmlField?.focus(), 1));
  }
  processInputOniOS() {
    const e = this.context.physics.raycast();
    if (!e.length) return;
    const i = e[0].object, n = qm(i);
    (n?.gameObject === this.gameObject || n?.gameObject.parent === this.gameObject) && this.selectInputField();
  }
  // private static _lastDeletionTime: number = 0;
  // private static _lastKeyInputTime: number = 0;
  // TODO: support modifiers, refactor to not use backspace as string etc
  // private handleKey(key: string | null) {
  //     if (!this.textComponent) return;
  //     if (!key) return;
  //     InputField._lastKey = key || "";
  //     const text = this.textComponent.text;
  //     if (debug)
  //         console.log(key, text);
  //     switch (key) {
  //         case "Backspace":
  //             this.deleteLetter();
  //             break;
  //         default:
  //             this.appendLetter(key);
  //             break;
  //     }
  // }
  // private appendLetter(key: string | null) {
  //     if (this.textComponent && key) {
  //         const timeSinceLastInput = this.context.time.time - InputField._lastKeyInputTime;
  //         if (key.length === 1 && (this.context.input.getKeyDown() === key || timeSinceLastInput > .1)) {
  //             this.textComponent.text += key;
  //             InputField._lastKeyInputTime = this.context.time.time;
  //         }
  //     }
  // }
  // private deleteLetter() {
  //     if (this.textComponent) {
  //         const text = this.textComponent.text;
  //         if (text.length > 0 && this.context.time.time - InputField._lastDeletionTime > 0.05) {
  //             this.textComponent.text = text.slice(0, -1);
  //             InputField._lastDeletionTime = this.context.time.time;
  //         }
  //     }
  // }
};
Fu([
  u(Gt)
], Nc.prototype, "textComponent");
Fu([
  u(Gt)
], Nc.prototype, "placeholder");
Fu([
  u(me)
], Nc.prototype, "onValueChanged");
Fu([
  u(me)
], Nc.prototype, "onEndEdit");
let Pw = Nc;
var ZE = Object.defineProperty, Ow = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && ZE(e, t, n), n;
};
class zu extends T {
  id = null;
  keepAspect = !1;
  _object = null;
  onEnable() {
    if (this._object) {
      this.gameObject.add(this._object);
      return;
    }
    if (!this.id || !this.context.mainCamera) return;
    const e = document.getElementById(this.id);
    if (!e) {
      console.warn('Could not find element with id "' + this.id + '"');
      return;
    }
    e.style.display = "block", e.style.visibility = "hidden";
    const t = new SS();
    t.listenToPointerEvents(this.context.renderer, this.context.mainCamera), this.gameObject.add(t);
    const i = new CS(e);
    t.add(i), i.visible = !1;
    const n = i.material;
    n.transparent = !0, setTimeout(() => {
      i.visible = !0;
      const o = xm(this.gameObject).clone();
      $d(this.gameObject, 0, 0, 0), this.gameObject.updateMatrixWorld();
      const r = new pi();
      r.setFromObject(t), this.setWorldRotation(o.x, o.y, o.z);
      const a = r.max.x - r.min.x, l = r.max.y - r.min.y;
      if (this.keepAspect) {
        const h = a / l;
        a > l ? i.scale.set(1 / a, 1 / l / h, 1) : i.scale.set(1 / a * h, 1 / l, 1);
      } else
        i.scale.set(1 / a, 1 / l, 1);
      const c = this.gameObject.scale;
      i.scale.multiply(c);
    }, 1);
  }
  onDisable() {
    this._object?.removeFromParent();
  }
}
Ow([
  u()
], zu.prototype, "id");
Ow([
  u()
], zu.prototype, "keepAspect");
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JE = {
  topLight: {
    intensity: 500,
    position: [0.418, 16.199, 0.3]
  },
  room: {
    position: [-0.757, 13.219, 0.717],
    scale: [31.713, 28.305, 28.591]
  },
  boxes: [
    {
      position: [-10.906, 2.009, 1.846],
      rotation: -0.195,
      scale: [2.328, 7.905, 4.651]
    },
    {
      position: [-5.607, -0.754, -0.758],
      rotation: 0.994,
      scale: [1.97, 1.534, 3.955]
    },
    {
      position: [6.167, 0.857, 7.803],
      rotation: 0.561,
      scale: [3.927, 6.285, 3.687]
    },
    {
      position: [-2.017, 0.018, 6.124],
      rotation: 0.333,
      scale: [2.002, 4.566, 2.064]
    },
    {
      position: [2.291, -0.756, -2.621],
      rotation: -0.286,
      scale: [1.546, 1.552, 1.496]
    },
    {
      position: [-2.193, -0.369, -5.547],
      rotation: 0.516,
      scale: [3.875, 3.487, 2.986]
    }
  ],
  lights: [
    {
      intensity: 50,
      position: [-16.116, 14.37, 8.208],
      scale: [0.1, 2.428, 2.739]
    },
    {
      intensity: 50,
      position: [-16.109, 18.021, -8.207],
      scale: [0.1, 2.425, 2.751]
    },
    {
      intensity: 17,
      position: [14.904, 12.198, -1.832],
      scale: [0.15, 4.265, 6.331]
    },
    {
      intensity: 43,
      position: [-0.462, 8.89, 14.52],
      scale: [4.38, 5.441, 0.088]
    },
    {
      intensity: 20,
      position: [3.235, 11.486, -12.541],
      scale: [2.5, 2, 0.1]
    },
    {
      intensity: 100,
      position: [0, 20, 0],
      scale: [1, 0.1, 1]
    }
  ]
}, eA = {
  topLight: {
    intensity: 400,
    position: [0.5, 14, 0.5]
  },
  room: {
    position: [0, 13.2, 0],
    scale: [31.5, 28.5, 31.5]
  },
  boxes: [
    {
      position: [-10.906, -1, 1.846],
      rotation: -0.195,
      scale: [2.328, 7.905, 4.651]
    },
    {
      position: [-5.607, -0.754, -0.758],
      rotation: 0.994,
      scale: [1.97, 1.534, 3.955]
    },
    {
      position: [6.167, -0.16, 7.803],
      rotation: 0.561,
      scale: [3.927, 6.285, 3.687]
    },
    {
      position: [-2.017, 0.018, 6.124],
      rotation: 0.333,
      scale: [2.002, 4.566, 2.064]
    },
    {
      position: [2.291, -0.756, -2.621],
      rotation: -0.286,
      scale: [1.546, 1.552, 1.496]
    },
    {
      position: [-2.193, -0.369, -5.547],
      rotation: 0.516,
      scale: [3.875, 3.487, 2.986]
    }
  ],
  lights: [
    {
      intensity: 80,
      position: [-14, 10, 8],
      scale: [0.1, 2.5, 2.5]
    },
    {
      intensity: 80,
      position: [-14, 14, -4],
      scale: [0.1, 2.5, 2.5]
    },
    {
      intensity: 23,
      position: [14, 12, 0],
      scale: [0.1, 5, 5]
    },
    {
      intensity: 16,
      position: [0, 9, 14],
      scale: [5, 5, 0.1]
    },
    {
      intensity: 80,
      position: [7, 8, -14],
      scale: [2.5, 2.5, 0.1]
    },
    {
      intensity: 80,
      position: [-7, 16, -14],
      scale: [2.5, 2.5, 0.1]
    },
    {
      intensity: 1,
      position: [0, 20, 0],
      scale: [0.1, 0.1, 0.1]
    }
  ]
};
class $g extends gi {
  constructor(e) {
    super(), this.position.y = -3.5;
    const t = new la();
    t.deleteAttribute("uv");
    const i = new ct({ metalness: 0, side: Bd }), n = new ct({ metalness: 0 }), o = e == "legacy" ? JE : eA, r = new lm(16777215, o.topLight.intensity, 28, 2);
    r.position.set(...o.topLight.position), this.add(r);
    const a = new H(t, i);
    a.position.set(...o.room.position), a.scale.set(...o.room.scale), this.add(a);
    for (const l of o.boxes) {
      const c = new H(t, n);
      c.position.set(...l.position), c.rotation.set(0, l.rotation, 0), c.scale.set(...l.scale), this.add(c);
    }
    for (const l of o.lights) {
      const c = new H(t, this.createAreaLightMaterial(l.intensity));
      c.position.set(...l.position), c.scale.set(...l.scale), this.add(c);
    }
  }
  createAreaLightMaterial(e) {
    const t = new we();
    return t.color.setScalar(e), t;
  }
}
var tA = Object.defineProperty, Uu = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && tA(e, t, n), n;
};
const $c = class kw extends T {
  target;
  invertForward = !1;
  keepUpDirection = !0;
  copyTargetRotation = !1;
  static flipYQuat = new $().setFromAxisAngle(new b(0, 1, 0), Math.PI);
  /** @internal */
  onBeforeRender() {
    let e = this.target;
    if (e || (e = this.context.mainCamera), !e) return;
    let t = this.copyTargetRotation;
    (this.context.isInVR || this.context.isInPassThrough) && (t = !1), Nd(this.gameObject, e, this.keepUpDirection, t), this.invertForward && this.gameObject.quaternion.multiply(kw.flipYQuat);
  }
  /** @internal */
  createBehaviours(e, t, i) {
    if (t.uuid === this.gameObject.uuid) {
      let n = t;
      if (this.keepUpDirection) {
        const r = st.createEmptyParent(t);
        n = r;
        const a = this.invertForward ? -1 : 1;
        r.setMatrix(r.getMatrix().multiply(new te().makeRotationZ(Math.PI / 2 * a))), t.setMatrix(t.getMatrix().multiply(new te().makeRotationZ(-Math.PI / 2 * a)));
      }
      const o = new Et(
        "lookat " + this.name,
        Vt.sceneStartTrigger(),
        fe.lookAtCameraAction(
          n,
          void 0,
          this.invertForward ? Fi.back : Fi.forward,
          this.keepUpDirection ? Fi.up : Fi.zero
        )
      );
      e.addBehavior(o);
    }
  }
};
Uu([
  u(M)
], $c.prototype, "target");
Uu([
  u()
], $c.prototype, "invertForward");
Uu([
  u()
], $c.prototype, "keepUpDirection");
Uu([
  u()
], $c.prototype, "copyTargetRotation");
let Mw = $c;
var iA = Object.defineProperty, Wg = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && iA(e, t, n), n;
};
class Wc extends T {
  url;
  mode = 0;
  clickable = !0;
  /**
   * Opens the URL in a new tab or window.
   */
  async open() {
    if (!this.url) {
      console.warn("OpenURL: URL is not set, can't open.", this);
      return;
    }
    this._validateUrl();
    let e = this.url;
    switch (!e.startsWith("mailto:") && e.includes("@") && (e = "mailto:" + e), L() && Be("Open URL: " + e), this.mode) {
      case 0:
        X.isSafari(), globalThis.open(e, "_blank");
        break;
      case 1:
        X.isSafari() && X.isiOS() ? globalThis.open(e, "_top") : globalThis.open(e, "_self");
        break;
      case 2:
        X.isSafari() ? globalThis.open(e, "_top") : globalThis.open(e, "_new");
        break;
    }
  }
  /** @internal */
  start() {
    this.gameObject.getComponentInParent(Vi) || this.gameObject.addComponent(Vi);
  }
  /** @internal */
  onPointerEnter(e) {
    !e.used && this.clickable && this.context.input.setCursor("pointer");
  }
  /** @internal */
  onPointerExit() {
    this.clickable && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerClick(e) {
    this.clickable && !e.used && this.url?.length && this.open();
  }
  _validateUrl() {
    this.url && this.url.startsWith("www.") && (L() && console.warn("URL is not valid, adding https:// to the start of the URL", this.url), this.url = "https://" + this.url);
  }
}
Wg([
  u()
], Wc.prototype, "url");
Wg([
  u()
], Wc.prototype, "mode");
Wg([
  u()
], Wc.prototype, "clickable");
var nA = Object.defineProperty, Xa = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && nA(e, t, n), n;
};
class Mo extends T {
  // override active and enabled here so that we always receive xr update events
  get activeAndEnabled() {
    return !0;
  }
  side = "none";
  controller = !0;
  hands = !1;
  controlVisibility = !0;
  useGripSpace = !1;
  resetTransformAfterXRSession = !0;
  _startPosition = new b();
  _startRotation = new $();
  _startScale = new b();
  /** @internal */
  onEnterXR(e) {
    this._startPosition.copy(this.gameObject.position), this._startRotation.copy(this.gameObject.quaternion), this._startScale.copy(this.gameObject.scale);
  }
  /** @internal */
  onUpdateXR(e) {
    if (!this.enabled) return;
    const t = e.xr.getController(this.side);
    if (t) {
      if (t.hand && !this.hands) {
        this.controlVisibility && (this.gameObject.visible = !1);
        return;
      } else if (!this.controller) {
        this.controlVisibility && (this.gameObject.visible = !1);
        return;
      }
      this.controlVisibility && (this.gameObject.visible = !0), this.useGripSpace || t.targetRayMode === "transient-pointer" ? (this.gameObject.worldPosition = t.gripWorldPosition, this.gameObject.worldQuaternion = t.gripWorldQuaternion, this.gameObject.worldScale = G(t.xr.rigScale, t.xr.rigScale, t.xr.rigScale).multiply(this._startScale)) : (this.gameObject.worldPosition = t.rayWorldPosition, this.gameObject.worldQuaternion = t.rayWorldQuaternion, this.gameObject.worldScale = G(t.xr.rigScale, t.xr.rigScale, t.xr.rigScale).multiply(this._startScale));
    }
  }
  /** @internal */
  onLeaveXR(e) {
    this.resetTransformAfterXRSession && (this.gameObject.position.copy(this._startPosition), this.gameObject.quaternion.copy(this._startRotation), this.gameObject.scale.copy(this._startScale));
  }
}
Xa([
  u()
], Mo.prototype, "side");
Xa([
  u()
], Mo.prototype, "controller");
Xa([
  u()
], Mo.prototype, "hands");
Xa([
  u()
], Mo.prototype, "controlVisibility");
Xa([
  u()
], Mo.prototype, "useGripSpace");
Xa([
  u()
], Mo.prototype, "resetTransformAfterXRSession");
function Rw(s, e) {
  const t = s.xr.getFrame();
  if (!t)
    return console.warn("No XRFrame available"), !1;
  const i = t.session.enabledFeatures;
  if (i && !i.some((o) => o === "camera-access"))
    return console.error(`No camera feed available - please request the 'camera-access' feature before starting WebXR or add the ARCameraBackground component to your scene.

Example to request camera-access in global scope:
NeedleXRSession.onSessionRequestStart(evt => {
    evt.init.optionalFeatures = evt.init.optionalFeatures || [];
    evt.init.optionalFeatures.push('camera-access');
});
`), L() && Wd("No camera feed available - please request the 'camera-access' feature before starting WebXR or add the ARCameraBackground component to your scene"), !1;
  const n = t.getViewerPose(s.xr.getReferenceSpace());
  if (n)
    for (const o of n.views)
      if ("camera" in o && o.camera) {
        let r = s.xr.getBinding();
        if (r || (r = new XRWebGLBinding(t.session, s.getContext())), r) {
          let a = null;
          if ("getCameraImage" in r) {
            sA(s, e);
            const l = s.properties.get(e);
            if (l)
              return a = r.getCameraImage(o.camera), l.__webglTexture = a, !0;
            console.warn("No texture properties found for target texture");
          }
        } else
          console.error(o.camera, s.xr);
      } else
        console.error("NO CAMERA IN VIEW");
  else
    console.error(s.xr.getReferenceSpace(), t);
  return !1;
}
const Q_ = /* @__PURE__ */ new WeakMap();
function sA(s, e) {
  const t = Q_.get(e) || /* @__PURE__ */ new WeakSet();
  if (t.has(s))
    return;
  t.add(s), Q_.set(e, t), console.debug("Initialize texture for camera feed");
  const i = new we(), n = new Un(), o = new gi();
  o.add(new H(n, i));
  const r = new pe();
  i.map = e, s.render(o, r);
}
function dL(s, e, t, i = "image/webp", n) {
  return Tw({ context: s, width: e, height: t, mimeType: i, camera: n });
}
function Tw(s) {
  s || (s = {});
  const { transparent: e = !1 } = s;
  let { mimeType: t, context: i, width: n, height: o, camera: r } = s;
  if (!i && (i = he.Current, !i))
    return console.error("Can not save screenshot: No needle-engine context found or provided."), null;
  if (!r && (r = i.mainCamera, !r))
    return console.error("No camera found"), null;
  const a = i.renderer, l = a.xr.enabled && a.xr.isPresenting;
  if (l && i.currentFrameEvent != xe.EarlyUpdate)
    return console.warn("Screenshot: defer to access XR frame"), new Promise((E) => {
      ks((z) => {
        const D = Tw(s);
        E(D);
      }, xe.EarlyUpdate, { once: !0 });
    });
  const c = a.domElement, h = c.width, d = c.height;
  n || (n = h), o || (o = d);
  const f = n, p = o;
  let g = window.devicePixelRatio || 1, _ = 1;
  i.devicePixelRatio === "auto" || i.devicePixelRatio === "manual" ? _ = 1 : _ = i.devicePixelRatio / window.devicePixelRatio, g *= _, n /= g, o /= g, n = Math.floor(n), o = Math.floor(o), a.xr.isPresenting && a.xr.getFrame();
  const m = a.xr.enabled;
  a.xr.enabled = !1, a.xr.isPresenting = !1, c.style.width = `${n}px`, c.style.height = `${o}px`;
  const v = a.getRenderTarget(), y = a.getClearColor(new se()), x = a.getClearAlpha(), I = i.scene.background, O = "aspect" in r ? r.aspect : null;
  try {
    const k = s.render_events !== !1, E = new Array();
    k && (gc(i.scene, Hi, E), E.forEach((A) => {
      if (A?.onBeforeRender(), A.isInstancingActive && A.instances)
        for (let U = 0; U < A.instances?.length; U++) {
          const W = A.instances[U];
          hs(W.object, !0);
        }
    })), e && (i.scene.background = null, a.setClearColor(0, 0)), s.background && (i.scene.background = null, a.setClearColor(s.background), s.background instanceof oe && a.setClearAlpha(s.background.a)), e && a.setClearAlpha(0), a.setSize(n, o, !1), "cam" in r && (r = r.threeCamera), r instanceof pe && (r.aspect = n / o, r.updateProjectionMatrix());
    const z = "type" in s && s.type === "texture";
    let D = null;
    z && (D = new Dn(n, o, {
      wrapS: Qg,
      wrapT: Qg,
      format: 1023
    }), a.setRenderTarget(D));
    let V = c;
    if (l ? (D && console.error('Taking XR screenshots with { type: "texture" } is currently not supported.'), V = Od.compositeWithCameraImage({
      width: f,
      height: p,
      scene: i.scene,
      camera: r,
      renderer: a
    })) : i.renderNow(r || null), r instanceof pe && O != null && (r.aspect = O, r.updateProjectionMatrix()), k && E.forEach((A) => A.onAfterRender()), !t && "download_filename" in s && s.download_filename)
      switch (s.download_filename.split(".").pop()?.toLowerCase()) {
        case "png":
          t = "image/png";
          break;
        case "jpg":
        case "jpeg":
          t = "image/jpeg";
          break;
        case "webp":
          t = "image/webp";
          break;
      }
    if (e && s.trim === !0) {
      const A = oA(V);
      A && (V = A);
    }
    if ("type" in s) {
      if (s.type === "texture")
        return D ? (s.target && (s.target.image = D?.texture.image, s.target.needsUpdate = !0), D.texture.offset.set(0, -1), D.texture.needsUpdate = !0, D.texture) : (console.error("No target texture found"), null);
      if (s.type === "blob")
        return new Promise((U, W) => {
          V.toBlob((ne) => {
            U(ne);
          }, t);
        });
      if (s.type === "share")
        return new Promise((U, W) => {
          V.toBlob((ne) => {
            if (ne && "share" in navigator) {
              let re = "file_type" in s && s.file_type || t;
              t || (re = "image/png");
              const ue = re?.split("/")[1] || "png", Se = new File([ne], "filename" in s ? s.filename || `screenshot.${ue}` : `screenshot.${ue}`, { type: re });
              return navigator.share({
                title: "title" in s ? s.title : void 0,
                text: "text" in s ? s.text : void 0,
                url: "url" in s ? s.url : void 0,
                files: [Se]
              }).catch((Je) => {
                console.warn("User cancelled share", Je.message);
              }).finally(() => {
                U({ blob: ne, shared: !0 });
              });
            }
            return {
              blob: ne,
              shared: !1
            };
          }, t);
        });
    }
    const q = V.toDataURL(t);
    if ("download_filename" in s && s.download_filename) {
      let A = s.download_filename;
      if (X.isMobileDevice() && typeof window < "u") {
        const U = A + "_screenshots", W = A.split("."), ne = W.pop()?.toLowerCase();
        let re = 0;
        localStorage.getItem(U) && (re = parseInt(sessionStorage.getItem(U) || "0")), re > 0 && (A = `${W.join()}-${re}.${ne}`), re += 1, sessionStorage.setItem(U, re.toString());
      }
      rA(q, A);
    }
    return q;
  } finally {
    a.setRenderTarget(v), i.scene.background = I, a.setSize(h, d, !1), a.setClearColor(y, x), O != null && r instanceof pe && (r.aspect = O, r.updateProjectionMatrix()), a.xr.enabled = m, a.xr.isPresenting = l, l || i.updateSize(!0);
  }
  return null;
}
function oA(s) {
  if (!("document" in globalThis)) return null;
  const e = document.createElement("canvas");
  e.width = s.width, e.height = s.height;
  const t = e.getContext("2d");
  if (!t) return null;
  t.drawImage(s, 0, 0);
  const i = e.width, n = e.height, r = t.getImageData(0, 0, i, n).data;
  let a = n, l = i, c = 0, h = 0;
  for (let _ = 0; _ < n; _++)
    for (let m = 0; m < i; m++) {
      const v = (_ * i + m) * 4;
      r[v + 3] !== 0 && (m < l && (l = m), m > h && (h = m), _ < a && (a = _), _ > c && (c = _));
    }
  const d = h - l + 1, f = c - a + 1, p = document.createElement("canvas"), g = p.getContext("2d");
  return g ? (p.width = d, p.height = f, g.drawImage(e, l, a, d, f, 0, 0, d, f), p) : null;
}
let dl = null;
function rA(s, e) {
  if (s) {
    if (!s.startsWith("data:image")) {
      console.error("Can not save image: Data url is not an image", s);
      return;
    }
    dl || (dl = document.createElement("a")), dl.href = s, dl.download = e, dl.click();
  }
}
var Od;
((s) => {
  let e = null, t = null, i = null, n = null, o = null;
  function r(c) {
    const { renderer: h, width: d, height: f } = c, p = h.xr.enabled, g = h.getRenderTarget(), _ = h.autoClear, m = d, v = f, y = d / f;
    (!i || i.width !== m || i.height !== v) && (i ??= new Dn(m, v, { colorSpace: Cs }), i.width = m, i.height = v, i.samples = 4, i.texture.repeat.y = -1, i.texture.offset.y = 1), (!o || o.width !== m || o.height !== v) && (o = document.createElement("canvas"), o.width = m, o.height = v, o.style.position = "fixed", o.style.top = "0px", o.style.right = "0px", o.style.width = "300px", o.style.height = `${300 / y}px`, o.style.zIndex = "1000", o.style.pointerEvents = "none", o.style.opacity = "1.0", o.style.willChange = "contents"), e || (e = l({
      defines: {
        DECODE_VIDEO_TEXTURE: !0
      }
    })), t || (t = l()), n || (n = new Te()), h.xr.updateCamera(c.camera), h.xr.enabled = !1, h.autoClear = !1, h.clear(), h.setSize(m, v), h.setRenderTarget(i), Rw(c.renderer, n) || console.error("Could not update texture from XR frame");
    const I = S.findObjectOfType(Nu);
    return I ? I.setTexture(n) : (e.setTexture(n), h.render(e, c.camera)), h.clearDepth(), h.setSize(m, v), h.render(c.scene, c.camera), h.setRenderTarget(null), t.setTexture(i.texture), h.render(t, c.camera), o.getContext("2d", { alpha: !1 }).drawImage(h.domElement, 0, 0, o.width, o.height), h.setRenderTarget(g), h.xr.enabled = p, h.autoClear = _, o;
  }
  s.compositeWithCameraImage = r;
  const a = (
    /* glsl */
    `
uniform sampler2D t2D;
varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );

    #ifdef DECODE_VIDEO_TEXTURE

        // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
        texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    #endif

    gl_FragColor = texColor;
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`
  );
  function l(c) {
    const h = c?.material || new Ln({
      name: "BackgroundMaterial",
      uniforms: gb.clone(Qh.background.uniforms),
      vertexShader: Qh.background.vertexShader,
      fragmentShader: a,
      defines: c?.defines,
      side: co,
      depthTest: !1,
      depthWrite: !1,
      fog: !1
    });
    Object.defineProperty(h, "map", {
      get: function() {
        return this.threeTexture;
      }
    });
    const d = new H(new Un(2, 2), h);
    return cp(d, !1), d.geometry.deleteAttribute("normal"), d.renderOrder = -1e6, d.setTexture = function(f) {
      h.uniforms.t2D.value = f;
    }, d;
  }
  s.makeFullscreenPlane = l;
})(Od || (Od = {}));
var aA = Object.defineProperty, lA = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && aA(e, t, n), n;
};
const Y_ = w("debugarcamera");
class Nu extends T {
  /** @internal */
  onBeforeXR(e, t) {
    e === "immersive-ar" && (t.optionalFeatures = t.optionalFeatures || [], t.optionalFeatures.push("camera-access"), Y_ && console.warn("Requesting camera-access"));
  }
  /** @internal */
  onEnterXR(e) {
    e.xr.mode === "immersive-ar" && (this.backgroundPlane && (this.context.scene.add(this.backgroundPlane), this.backgroundPlane.visible = !1), this.backgroundPlane && this.context.scene.add(this.backgroundPlane), this.context.pre_render_callbacks.push(this.preRender));
  }
  /** @internal */
  onLeaveXR(e) {
    this.backgroundPlane && this.backgroundPlane.removeFromParent();
    const t = this.context.pre_render_callbacks.indexOf(this.preRender);
    t >= 0 && this.context.pre_render_callbacks.splice(t, 1);
  }
  backgroundTint = new oe(1, 1, 1, 1);
  get background() {
    return this.backgroundPlane;
  }
  backgroundPlane;
  threeTexture;
  forceTextureInitialization = (function() {
    const e = new we(), t = new Un(), i = new gi();
    i.add(new H(t, e));
    const n = new pe();
    return function(r, a) {
      e.map = a, r.render(i, n), Y_ && console.warn("Force texture initialization");
    };
  })();
  /** @internal */
  preRender = () => {
    if (!this || !this.gameObject) return;
    if (this.context.renderer.xr.getFrame()) {
      if (!this.threeTexture && this.context.renderer && (this.threeTexture = new Te(), this.forceTextureInitialization(this.context.renderer, this.threeTexture)), this.backgroundPlane === void 0) {
        const i = this.backgroundTint;
        this.backgroundPlane = Od.makeFullscreenPlane({
          material: new Ln({
            name: "BackgroundMaterial",
            uniforms: {
              ...gb.clone(Qh.background.uniforms),
              tint: { value: new de(i.r, i.g, i.b, i.a) }
            },
            vertexShader: Qh.background.vertexShader,
            fragmentShader: cA,
            side: yi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          })
        });
      }
      this.backgroundPlane.parent !== this.scene && this.scene.add(this.backgroundPlane), this.backgroundPlane.material instanceof Ln && this.backgroundPlane.material.uniforms.tint.value.set(this.backgroundTint.r, this.backgroundTint.g, this.backgroundTint.b, this.backgroundTint.a), this.updateFromFrame();
    }
  };
  /** @internal */
  onBeforeRender(e) {
    this.updateFromFrame();
  }
  updateFromFrame() {
    this.threeTexture && this.context.xr?.mode === "immersive-ar" && (Rw(this.context.renderer, this.threeTexture), this.setTexture(this.threeTexture));
  }
  setTexture(e) {
    this.backgroundPlane && (this.threeTexture = e, this.backgroundPlane.setTexture(this.threeTexture), this.backgroundPlane.visible = !0);
  }
}
lA([
  u(oe)
], Nu.prototype, "backgroundTint");
const cA = (
  /* glsl */
  `
uniform sampler2D t2D;
uniform vec4 tint;

varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );
    texColor.w = 1.0;

    // inline sRGB decode
    texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    gl_FragColor = texColor * tint;

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`
);
var hA = Object.defineProperty, Ro = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && hA(e, t, n), n;
};
const kd = w("debugimagetracking");
class pc {
  get url() {
    return this._trackedImage.image ?? "";
  }
  get widthInMeters() {
    return this._trackedImage.widthInMeters ?? void 0;
  }
  get bitmap() {
    return this._bitmap;
  }
  get model() {
    return this._trackedImage;
  }
  measuredSize;
  state;
  /** Copy the image position to a vector */
  getPosition(e) {
    return this.ensureTransformData(), e.copy(this._position), e;
  }
  /** Copy the image rotation to a quaternion */
  getQuaternion(e) {
    return this.ensureTransformData(), e.copy(this._rotation), e;
  }
  applyToObject(e, t = void 0) {
    this.ensureTransformData();
    const i = e.position.distanceToSquared(this._position) / 0.05 + e.quaternion.angleTo(this._rotation) / 0.05;
    t && (t *= Math.max(1, i)), t === void 0 || t >= 1 ? (e.position.copy(this._position), e.quaternion.copy(this._rotation)) : (t = Math.max(0, Math.min(1, t)), e.position.lerp(this._position, t), e.quaternion.slerp(this._rotation, t));
  }
  static _positionBuffer = new $i(() => new b(), 20);
  static _rotationBuffer = new $i(() => new $(), 20);
  _position;
  _rotation;
  ensureTransformData() {
    if (!this._position) {
      this._position = pc._positionBuffer.get(), this._rotation = pc._rotationBuffer.get();
      const e = this._pose.transform, t = K.active.convertSpace(e);
      this._position.copy(t?.position), this._rotation.copy(t?.quaternion);
    }
  }
  _trackingComponent;
  _trackedImage;
  _bitmap;
  _pose;
  constructor(e, t, i, n, o, r) {
    this._trackingComponent = e, this._trackedImage = t, this._bitmap = i, this.measuredSize = n, this.state = o, this._pose = r;
  }
}
class To {
  image;
  widthInMeters = 0.25;
  object;
  createObjectInstance = !1;
  imageDoesNotMove = !1;
  hideWhenTrackingIsLost = !0;
}
Ro([
  u(URL)
], To.prototype, "image");
Ro([
  u()
], To.prototype, "widthInMeters");
Ro([
  u(ie)
], To.prototype, "object");
Ro([
  u()
], To.prototype, "createObjectInstance");
Ro([
  u()
], To.prototype, "imageDoesNotMove");
Ro([
  u()
], To.prototype, "hideWhenTrackingIsLost");
class dA {
  constructor(e, t) {
    this.exporter = e, this.component = t, kd && console.log(this), this.exporter.anchoringType = "image";
  }
  isImageTrackingExtension = !0;
  get extensionName() {
    return "image-tracking";
  }
  // set during export
  shouldExport = !0;
  filename = "marker.png";
  imageModel = null;
  onBeforeBuildDocument(e) {
    const t = this.exporter.extensions.filter((i) => {
      const n = i;
      return n.isImageTrackingExtension && n.component.activeAndEnabled && n.component.trackedImages?.length > 0;
    }).indexOf(this);
    this.shouldExport = t === 0, this.shouldExport && this.component.trackedImages?.length > 1 && (kd || L()) && (ge("USDZ: Only one tracked image is supported."), console.warn("USDZ: Only one tracked image is supported. Will choose the first one in the trackedImages list"));
  }
  onAfterHierarchy(e, t) {
    if (!this.shouldExport) return;
    const i = X.getiOSVersion(), r = (i ? parseInt(i.split(".")[0]) : 18) >= 18 ? 1 : 100;
    t.beginBlock('def Preliminary_ReferenceImage "AnchoringReferenceImage"'), t.appendLine("uniform asset image = @image_tracking/" + this.filename + "@"), t.appendLine("uniform double physicalWidth = " + (this.imageModel.widthInMeters * r).toFixed(8)), t.closeBlock();
  }
  async onAfterSerialize(e) {
    if (!this.shouldExport) return;
    const t = this.imageModel, i = Xl.get(t.image), r = await (await (await WM(i)).convertToBlob({ type: "image/png" })).arrayBuffer();
    e.files["image_tracking/" + this.filename] = new Uint8Array(r);
  }
  onExportObject(e, t, i) {
    if (!this.shouldExport) return;
    const n = this.component;
    if (!n || !n.trackedImages?.length || !n.activeAndEnabled) return;
    const o = n.trackedImages[0];
    if (o.object?.asset === e) {
      this.imageModel = o;
      const { scale: r, target: a } = this.exporter.getARScaleAndTarget();
      let l = e;
      const c = new te();
      if (e !== a)
        for (; l && l.parent && l.parent !== a; )
          l = l.parent, c.premultiply(l.matrix);
      const h = c.clone().invert();
      t.setMatrix(h.scale(new b(r, r, r)));
    }
  }
}
class $u extends T {
  trackedImages = [];
  smooth = !0;
  trackedImageIndexMap = /* @__PURE__ */ new Map();
  /** @returns true if image tracking is supported on this device. This may return false at runtime if the user's browser did not enable webxr incubations */
  get supported() {
    return this._supported;
  }
  _supported = !0;
  awake() {
    if (kd && console.log(this), !!this.trackedImages)
      for (const e of this.trackedImages)
        e.image && uA(e.image);
  }
  onEnable() {
    ws.beforeExport.addEventListener(this.onBeforeUSDZExport);
  }
  onDisable() {
    ws.beforeExport.removeEventListener(this.onBeforeUSDZExport);
  }
  onBeforeUSDZExport = (e) => {
    this.activeAndEnabled && this.trackedImages?.length && e.exporter.extensions.push(new dA(e.exporter, this));
  };
  onBeforeXR(e, t) {
    if (this.trackedImages) {
      t.optionalFeatures = t.optionalFeatures || [], t.optionalFeatures.includes("image-tracking") || t.optionalFeatures.push("image-tracking"), t.trackedImages = [];
      for (const i of this.trackedImages)
        if (i.image?.length && i.widthInMeters > 0) {
          const n = Xl.get(i.image);
          n && (this.trackedImageIndexMap.set(t.trackedImages.length, i), t.trackedImages.push({
            image: n,
            widthInMeters: i.widthInMeters
          }));
        }
    }
  }
  onEnterXR(e) {
    if (this.trackedImages) {
      for (const t of this.trackedImages)
        if (t.object?.asset) {
          const i = t.object.asset;
          i.userData || (i.userData = {});
          const n = {
            visible: i.visible,
            parent: i.parent,
            matrix: i.matrix.clone()
          };
          i.userData["image-tracking"] = n;
        }
    }
    for (const t of this.imageToObjectMap.values())
      t.frames = 0;
  }
  onLeaveXR(e) {
    if (!this.supported && X.isAndroidDevice() && ge(this.webXRIncubationsWarning), this.trackedImages) {
      for (const t of this.trackedImages)
        if (t.object?.asset) {
          const i = t.object.asset;
          if (i.userData) {
            const n = i.userData["image-tracking"];
            n && (i.visible = n.visible, n.parent?.add(i), i.matrix.copy(n.matrix), i.matrix.decompose(i.position, i.quaternion, i.scale)), delete i.userData["image-tracking"];
          }
        }
    }
  }
  imageToObjectMap = /* @__PURE__ */ new Map();
  currentImages = [];
  webXRIncubationsWarning = `Image tracking is currently not supported on this device. On Chrome for Android, you can enable the <a target="_blank" href="#" onclick="() => console.log('I')">chrome://flags/#webxr-incubations</a> flag.`;
  onUpdateXR(e) {
    this.currentImages.length = 0;
    const t = e.xr.frame;
    if (!t) return;
    if ("getImageTrackingResults" in t) {
      if (e.xr.session.enabledFeatures?.includes("image-tracking") === !1)
        return;
      if (t.session && typeof t.getImageTrackingResults == "function") {
        const n = t.getImageTrackingResults();
        if (n.length > 0) {
          const o = this.context.renderer.xr.getReferenceSpace();
          if (o) {
            for (const r of n) {
              const a = r.trackingState, l = r.index, c = this.trackedImageIndexMap.get(l);
              if (c) {
                const h = t.getPose(r.imageSpace, o), d = new pc(this, c, r.image, r.measuredSize, a, h);
                this.currentImages.push(d);
              } else
                kd && console.warn("No tracked image for index", l);
            }
            if (this.currentImages.length > 0)
              try {
                this.dispatchEvent(new CustomEvent("image-tracking", { detail: this.currentImages })), this.onImageTrackingUpdate(this.currentImages);
              } catch (r) {
                console.error(r);
              }
          }
        }
      }
    } else {
      this.didPrintWarning || (this.didPrintWarning = !0, console.log(this.webXRIncubationsWarning)), this._supported = !1, ge(this.webXRIncubationsWarning);
      return;
    }
    const i = 1e3;
    for (const [n, o] of this.imageToObjectMap) {
      if (!o.object || !n || n.hideWhenTrackingIsLost === !1) continue;
      let r = !1;
      for (const a of this.currentImages)
        if (a.model === n) {
          const l = Date.now() - o.lastTrackingTime;
          if (n.imageDoesNotMove || a.state === "tracked" || l <= i) {
            r = !0;
            break;
          }
        }
      r || S.setActive(o.object, !1);
    }
  }
  onImageTrackingUpdate = (e) => {
    const t = K.active;
    if (t)
      for (const i of e) {
        const n = i.model, o = i.state === "tracked";
        if (!n.object) continue;
        let r = this.imageToObjectMap.get(n);
        if (r === void 0)
          r = { object: null, frames: 0, lastTrackingTime: Date.now() }, this.imageToObjectMap.set(n, r), n.object.loadAssetAsync().then((a) => {
            if (n.createObjectInstance && a && (a = S.instantiate(a)), a) {
              r.object = a;
              for (const l of a.getComponentsInChildren(Hi))
                l.setInstancingEnabled(!1);
              t.rig ? (t.rig.gameObject.add(a), i.applyToObject(a), a.activeSelf || S.setActive(a, !0)) : console.warn("XRImageTracking: missing XRRig");
            }
          });
        else {
          if (r.frames++, o && (r.lastTrackingTime = Date.now()), n.imageDoesNotMove && r.frames > 10 || !r.object) continue;
          t.rig && (t.rig.gameObject.add(r.object), i.applyToObject(r.object, this.smooth ? this.context.time.deltaTimeUnscaled * 3 : void 0), r.object.activeSelf || S.setActive(r.object, !0));
        }
      }
  };
}
Ro([
  u(To)
], $u.prototype, "trackedImages");
Ro([
  u()
], $u.prototype, "smooth");
const Xl = /* @__PURE__ */ new Map(), Ph = /* @__PURE__ */ new Map();
async function uA(s) {
  if (Xl.has(s))
    return Ph.has(s) ? Ph.get(s) : Promise.resolve(!0);
  const e = new Promise((t) => {
    Xl.set(s, null);
    const i = document.createElement("img");
    i.src = s, i.addEventListener("load", async () => {
      const n = await createImageBitmap(i);
      Xl.set(s, n), t(!0);
    });
  });
  return Ph.set(s, e), e.finally(() => {
    Ph.delete(s);
  }), e;
}
var fA = Object.defineProperty, Qa = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && fA(e, t, n), n;
};
const zo = w("debugplanetracking");
class Eo extends T {
  dataTemplate;
  occluder = !0;
  initiateRoomCaptureIfNoData = !0;
  usePlaneData = !0;
  useMeshData = !0;
  runInVR = !0;
  /**
   * Returns all tracked planes
   */
  get trackedPlanes() {
    return this._allPlanes.values();
  }
  get trackedMeshes() {
    return this._allMeshes.values();
  }
  /** @internal */
  onBeforeXR(e, t) {
    e === "immersive-vr" && !this.runInVR || (t.optionalFeatures = t.optionalFeatures || [], this.usePlaneData && !t.optionalFeatures.includes("plane-detection") && t.optionalFeatures.push("plane-detection"), this.useMeshData && !t.optionalFeatures.includes("mesh-detection") && t.optionalFeatures.push("mesh-detection"));
  }
  /** @internal */
  onEnterXR(e) {
    for (const t of this._allPlanes.keys())
      this.removeData(t, this._allPlanes);
    for (const t of this._allMeshes.keys())
      this.removeData(t, this._allMeshes);
  }
  onLeaveXR(e) {
    for (const t of this._allPlanes.keys())
      this.removeData(t, this._allPlanes);
    for (const t of this._allMeshes.keys())
      this.removeData(t, this._allMeshes);
  }
  /** @internal */
  onUpdateXR(e) {
    if (!this.runInVR && e.xr.isVR) return;
    const t = e.xr.rig;
    if (!t) {
      console.warn("No XR rig found, cannot parent tracked planes to it");
      return;
    }
    const i = e.xr.frame;
    if (!this.context.renderer.xr.getReferenceSpace()) return;
    const r = i.detectedPlanes, a = i.detectedMeshes, l = r !== void 0 && r.size > 0, c = a !== void 0 && a.size > 0;
    if (this.initiateRoomCaptureIfNoData && (!l && !c && this.firstTimeNoPlanesDetected < -10 && (this.firstTimeNoPlanesDetected = Date.now()), (l || c) && (this.firstTimeNoPlanesDetected = -1), this.firstTimeNoPlanesDetected > 0 && Date.now() - this.firstTimeNoPlanesDetected > 2500 && "initiateRoomCapture" in i.session && (i.session.initiateRoomCapture(), this.firstTimeNoPlanesDetected = -1)), r !== void 0 && this.processFrameData(e.xr, t.gameObject, i, r, this._allPlanes), a !== void 0 && this.processFrameData(e.xr, t.gameObject, i, a, this._allMeshes), zo) {
      const h = this.context.mainCameraComponent.gameObject.worldPosition;
      for (const d of this._allPlanes.values())
        !d.mesh || !d.mesh.visible || (this.bounds.makeEmpty(), d.mesh.traverse((f) => {
          f instanceof H && this.bounds.expandByObject(f);
        }), this.bounds.getCenter(this.center), this.labelOffset.copy(h).sub(this.center).normalize().multiplyScalar(0.1), F.DrawLabel(
          this.center.add(this.labelOffset),
          (d.xrData.semanticLabel || "plane").toUpperCase() + `
` + d.xrData.lastChangedTime.toFixed(2),
          0.02
        ));
    }
  }
  bounds = new pi();
  center = new b();
  labelOffset = new b();
  removeData(e, t) {
    const i = t.get(e);
    if (!i) return;
    t.delete(e), zo && console.log("Plane no longer tracked, id=" + i.id), i.mesh && (i.mesh.removeFromParent(), i.mesh.traverse((o) => {
      const r = o.userData.normalsHelper;
      r ? (r.dispose(), r.removeFromParent()) : zo && console.warn("No normals helper found for mesh", i.mesh);
    }), Wi(i.mesh, !0, !0));
    const n = new CustomEvent("plane-tracking", {
      detail: {
        type: "plane-removed",
        context: i
      }
    });
    this.dispatchEvent(n);
  }
  _dataId = 1;
  _allPlanes = /* @__PURE__ */ new Map();
  _allMeshes = /* @__PURE__ */ new Map();
  firstTimeNoPlanesDetected = -100;
  makeOccluder = (e, t, i = !1) => {
    if (t) {
      if (t instanceof Array) {
        for (const n of t)
          this.makeOccluder(e, n, i);
        return;
      }
      !i && !t.name.toLowerCase().includes("occlu") || (t.colorWrite = !1, t.depthTest = !0, t.depthWrite = !0, t.transparent = !1, t.polygonOffset = !0, t.polygonOffsetFactor = 1, t.polygonOffsetUnits = 0.1, e.renderOrder = -1e3);
    }
  };
  processFrameData(e, t, i, n, o) {
    const a = this.context.renderer.xr.getReferenceSpace();
    if (a) {
      for (const l of o.keys())
        n.has(l) || this.removeData(l, o);
      for (const l of n) {
        const c = "planeSpace" in l ? l.planeSpace : "meshSpace" in l ? l.meshSpace : void 0;
        if (!c) continue;
        const h = i.getPose(c, a);
        let d;
        if (o.has(l)) {
          const f = o.get(l);
          if (d = f.mesh, f.timestamp < l.lastChangedTime) {
            if (f.timestamp = l.lastChangedTime, f.mesh) {
              const g = this.createGeometry(l);
              if (f.mesh instanceof H)
                f.mesh.geometry.dispose(), f.mesh.geometry = g, this.makeOccluder(f.mesh, f.mesh.material);
              else if (f.mesh instanceof io)
                for (const _ of f.mesh.children)
                  _ instanceof H && (_.geometry.dispose(), _.geometry = g, this.makeOccluder(_, _.material));
              if (f.collider) {
                const _ = f.mesh;
                f.collider.sharedMesh = _, f.collider.convex = this.checkIfContextShouldBeConvex(_, f.xrData), f.collider.onDisable(), f.collider.onEnable();
              }
              zo && (console.log("Plane updated, id=" + f.id, f), f.mesh.traverse((_) => {
                if (!(_ instanceof H)) return;
                const m = _.userData.normalsHelper;
                m && m.update();
              }));
            }
            const p = new CustomEvent("plane-tracking", {
              detail: {
                type: "plane-updated",
                context: f
              }
            });
            this.dispatchEvent(p);
          }
        } else {
          if (!this.dataTemplate) {
            const f = new H();
            zo ? f.material = new tS() : this.occluder ? (f.material = new we(), this.makeOccluder(f, f.material, !0)) : f.material = new we({ wireframe: !0, opacity: 0.5, transparent: !0, color: 3355443 }), this.dataTemplate = new ie("", "", f);
          }
          if (!this.dataTemplate.asset)
            this.dataTemplate.loadAssetAsync();
          else {
            const f = S.instantiate(this.dataTemplate.asset);
            if (f.name = "xr-tracked-plane", d = f, Ub(f, !1), f instanceof H)
              Re(f.geometry), f.geometry = this.createGeometry(l), this.makeOccluder(f, f.material, this.occluder && !this.dataTemplate);
            else if (f instanceof io)
              for (const _ of f.children)
                _ instanceof H && (Re(_.geometry), _.geometry = this.createGeometry(l), this.makeOccluder(_, _.material, this.occluder && !this.dataTemplate));
            const p = f.getComponent(br);
            if (p) {
              const _ = f;
              p.sharedMesh = _, p.convex = this.checkIfContextShouldBeConvex(_, l), p.onDisable(), p.onEnable();
            }
            f.matrixAutoUpdate = !1, f.matrixWorldNeedsUpdate = !0, t.add(f);
            const g = {
              id: this._dataId++,
              xrData: l,
              timestamp: l.lastChangedTime,
              mesh: f,
              collider: p
            };
            o.set(l, g), zo && console.log("New plane detected, id=" + g.id, g, { hasCollider: !!p, isGroup: f instanceof io });
            try {
              const _ = new CustomEvent("plane-tracking", {
                detail: {
                  type: "plane-added",
                  context: g
                }
              });
              this.dispatchEvent(_);
            } catch (_) {
              console.error(_);
            }
          }
        }
        d && (h ? (d.visible = !0, d.matrix.fromArray(h.transform.matrix), d.matrix.premultiply(this._flipForwardMatrix)) : d.visible = !1, zo && d.traverse((f) => {
          if (f instanceof H)
            if (f.userData.normalsHelper)
              f.userData.normalsHelper.update();
            else {
              const p = new PS(f, 0.05, 255);
              p.layers.disableAll(), p.layers.set(2), this.context.scene.add(p), f.userData.normalsHelper = p;
            }
        }));
      }
    }
  }
  _flipForwardMatrix = new te().makeRotationY(Math.PI);
  // heuristic to determine if a collider should be convex or not - 
  // the "global mesh" should be non-convex, other meshes should be
  checkIfContextShouldBeConvex(e, t) {
    if (!e) return !0;
    if (e) {
      const i = new pi();
      i.expandByObject(e);
      const n = new b();
      i.getSize(n);
      let o = !0;
      return n.x > 2 && n.y > 2 && n.z > 1.5 && (o = !1), o && "semanticLabel" in t && t.semanticLabel === "wall" && (o = !0), o;
    }
    return !0;
  }
  createGeometry(e) {
    return "polygon" in e ? this.createPlaneGeometry(e.polygon) : "vertices" in e && "indices" in e ? this.createMeshGeometry(e.vertices, e.indices) : new Tn();
  }
  // we cache vertices-to-geometry, because it looks like when we get an update sometimes the geometry stays the same.
  // so we don't want to re-create the geometry every time.
  _verticesCache = /* @__PURE__ */ new Map();
  createMeshGeometry(e, t) {
    const i = e.toString() + "_" + t.toString();
    if (this._verticesCache.has(i))
      return this._verticesCache.get(i);
    const n = new Tn();
    n.setIndex(new ht(t, 1)), n.setAttribute("position", new ht(e, 3));
    const o = Array();
    for (let r = 0; r < e.length; r += 3)
      o.push(e[r], e[r + 2]);
    return n.setAttribute("uv", new ht(e, 3)), n.computeVertexNormals(), this._verticesCache.set(i, n), n;
  }
  createPlaneGeometry(e) {
    const t = new Tn(), i = [], n = [];
    e.forEach((f) => {
      i.push(f.x, f.y, f.z), n.push(f.x, f.z);
    });
    const o = new b(i[0], i[1], i[2]), r = new b(i[3], i[4], i[5]), a = new b(i[6], i[7], i[8]), l = new b(), c = new b();
    l.subVectors(r, o), c.subVectors(a, o), l.cross(c), l.normalize();
    const h = [];
    for (let f = 0; f < i.length / 3; f++)
      h.push(l.x, l.y, l.z);
    const d = [];
    for (let f = 2; f < e.length; ++f)
      d.push(0, f - 1, f);
    return t.setAttribute("position", new ht(new Float32Array(i), 3)), t.setAttribute("uv", new ht(new Float32Array(n), 2)), t.setAttribute("normal", new ht(new Float32Array(h), 3)), t.setIndex(d), t.computeBoundingBox(), t.computeBoundingSphere(), t;
  }
}
Qa([
  u(ie)
], Eo.prototype, "dataTemplate");
Qa([
  u()
], Eo.prototype, "occluder");
Qa([
  u()
], Eo.prototype, "initiateRoomCaptureIfNoData");
Qa([
  u()
], Eo.prototype, "usePlaneData");
Qa([
  u()
], Eo.prototype, "useMeshData");
Qa([
  u()
], Eo.prototype, "runInVR");
var pA = Object.defineProperty, mA = (s, e, t, i) => {
  for (var n = void 0, o = s.length - 1, r; o >= 0; o--)
    (r = s[o]) && (n = r(e, t, n) || n);
  return n && pA(e, t, n), n;
};
const K_ = w("debugwebxr");
class Vg extends T {
  priority = 0;
  get isActive() {
    return this.activeAndEnabled && this.gameObject.visible;
  }
  /** 
   * Sets this rig to be the active XR rig (needs to be called during an active XR session) 
   * Note that this might modify the priority of this rig to be the highest.
  */
  setAsActiveXRRig() {
    K.active?.setRigActive(this);
  }
  /** 
   * Sets the priority of the rig.
   */
  setPriority(e) {
    this.priority = e;
  }
  /** @internal */
  awake() {
    if (K_) {
      const e = new M();
      e.position.y += 0.5, this.gameObject.add(e);
      const t = e.addNewComponent(Ua);
      t && (t.isGizmo = !1);
      const i = new mi(0.5);
      this.gameObject.add(i);
    }
  }
  isXRRig() {
    return !0;
  }
  supportsXR(e) {
    return !0;
  }
  _startScale;
  /** @internal */
  onEnterXR(e) {
    this._startScale = this.gameObject.scale.clone(), e.xr.addRig(this), K_ && console.log("WebXR: add Rig", this.name, this.priority);
  }
  /** @internal */
  onLeaveXR(e) {
    e.xr.removeRig(this), this._startScale && this.gameObject && this.gameObject.scale.copy(this._startScale);
  }
}
mA([
  u()
], Vg.prototype, "priority");
class gA extends T {
  toggleKey = "KeyP";
  update() {
    this.context.input.isKeyDown(this.toggleKey) && this.context.domElement.classList.toggle("presentation-mode");
  }
}
P.add("AlignmentConstraint", Zd);
P.add("Animation", bi);
P.add("Animator", At);
P.add("AudioListener", Js);
P.add("AudioSource", ln);
P.add("Avatar_Brain_LookAt", pd);
P.add("Avatar_MouthShapes", iu);
P.add("Avatar_MustacheShake", q0);
P.add("AvatarBlink_Simple", Ta);
P.add("AvatarEyeLook_Rotation", K0);
P.add("AxesHelper", vc);
P.add("BasicIKConstraint", Z0);
P.add("BoxHelperComponent", Ct);
P.add("Camera", ui);
P.add("CharacterController", Ea);
P.add("CharacterControllerInput", mo);
P.add("Collider", wi);
P.add("SphereCollider", wc);
P.add("BoxCollider", Jm);
P.add("MeshCollider", br);
P.add("CapsuleCollider", ho);
P.add("ContactShadows", ou);
P.add("LogStats", ev);
P.add("DeleteBox", er);
P.add("Deletable", iv);
P.add("DeviceFlag", eg);
P.add("DragControls", Gr);
P.add("DropListener", yo);
P.add("Duplicatable", rv);
P.add("EventListEvent", Hm);
P.add("EventTrigger", sg);
P.add("GltfExportBox", _v);
P.add("GltfExport", bv);
P.add("VariantAction", Rv);
P.add("ChangeTransformOnClick", Da);
P.add("ChangeMaterialOnClick", Tv);
P.add("SetActiveOnClick", Ev);
P.add("HideOnStart", tn);
P.add("EmphasizeOnClick", Cc);
P.add("PlayAudioOnClick", rr);
P.add("PlayAnimationOnClick", _d);
P.add("PreliminaryAction", Pc);
P.add("PreliminaryTrigger", du);
P.add("VisibilityAction", uu);
P.add("TapGestureTrigger", Av);
P.add("USDZExporter", ws);
P.add("Fog", Mc);
P.add("BoxGizmo", Ua);
P.add("GridHelper", Rc);
P.add("GroundProjectedEnv", Ms);
P.add("UsageMarker", ru);
P.add("Interactable", tv);
P.add("FixedJoint", Yv);
P.add("HingeJoint", bu);
P.add("Light", Yi);
P.add("LODGroup", vu);
P.add("LookAtConstraint", Ra);
P.add("NeedleMenu", Es);
P.add("NestedGltf", Sg);
P.add("Networking", Kv);
P.add("OffsetConstraint", Na);
P.add("CameraTargetReachedEvent", fd);
P.add("OrbitControls", ye);
P.add("ParticleSystemRenderer", fn);
P.add("ParticleSystem", wd);
P.add("PlayerColor", uc);
P.add("Antialiasing", Cu);
P.add("BloomEffect", Rg);
P.add("ChromaticAberration", Ou);
P.add("ColorAdjustments", Sr);
P.add("DepthOfField", Gn);
P.add("EffectWrapper", xd);
P.add("PixelationEffect", Mu);
P.add("ScreenSpaceAmbientOcclusion", Co);
P.add("ScreenSpaceAmbientOcclusionN8", qn);
P.add("SharpeningEffect", Ru);
P.add("TiltShiftEffect", Ls);
P.add("ToneMappingEffect", hr);
P.add("Vignette", Ga);
P.add("Volume", Dc);
P.add("ReflectionProbe", yd);
P.add("Renderer", Hi);
P.add("MeshRenderer", lu);
P.add("SkinnedMeshRenderer", gv);
P.add("Rigidbody", ft);
P.add("SceneSwitcher", Ze);
P.add("ScreenCapture", Or);
P.add("ShadowCatcher", Tu);
P.add("RemoteSkybox", Ag);
P.add("SmoothFollow", Ig);
P.add("SpatialTriggerReceiver", xs);
P.add("SpatialTrigger", Lg);
P.add("SpectatorCamera", Dg);
P.add("SpriteRenderer", xi);
P.add("SyncedCamera", bw);
P.add("SyncedRoom", Xn);
P.add("SyncedTransform", Fn);
P.add("TestRunner", vw);
P.add("TestSimulateUserData", ww);
P.add("PlayableDirector", fc);
P.add("SignalReceiver", Lu);
P.add("AnimationTrackHandler", Bg);
P.add("AudioTrackHandler", to);
P.add("SignalTrackHandler", Pd);
P.add("ControlTrackHandler", Fg);
P.add("TransformGizmo", qa);
P.add("BaseUIComponent", hn);
P.add("UIRootComponent", gu);
P.add("Button", ko);
P.add("Canvas", hc);
P.add("CanvasGroup", cr);
P.add("EventSystem", Jt);
P.add("Graphic", yu);
P.add("MaskableGraphic", _u);
P.add("Image", Uc);
P.add("RawImage", Ng);
P.add("InputField", Pw);
P.add("VerticalLayoutGroup", Vv);
P.add("HorizontalLayoutGroup", Hv);
P.add("GridLayoutGroup", Gv);
P.add("Outline", kc);
P.add("ObjectRaycaster", Vi);
P.add("GraphicRaycaster", Gm);
P.add("SpatialGrabRaycaster", Ca);
P.add("RectTransform", zn);
P.add("SpatialHtml", zu);
P.add("Text", Gt);
P.add("EnvironmentScene", $g);
P.add("LookAt", Mw);
P.add("OpenURL", Wc);
P.add("VideoPlayer", pt);
P.add("Voip", _r);
P.add("Avatar", lr);
P.add("XRControllerFollow", Mo);
P.add("XRControllerModel", uo);
P.add("XRControllerMovement", Gi);
P.add("TeleportTarget", fg);
P.add("WebARCameraBackground", Nu);
P.add("WebARSessionRoot", Ni);
P.add("WebXR", pg);
P.add("AvatarMarker", je);
P.add("WebXRImageTracking", $u);
P.add("WebXRPlaneTracking", Eo);
P.add("XRRig", Vg);
P.add("XRFlag", nn);
P.add("PlayerSync", jv);
P.add("PlayerState", Mn);
P.add("PresentationMode", gA);
const Ql = dt, yA = w("debugtypestore");
yA && console.log(P);
function _A(s, e) {
  const i = gP(s, e);
  return i !== void 0 ? i : null;
}
const bA = new mP(), Zf = Symbol("deserialize-queue");
async function vA(s, e, t, i = null, n) {
  if (!t) {
    console.debug("Can not create component instances: gltf is null");
    return;
  }
  let o = i;
  typeof o == "number" && (o = new Tt(i));
  const r = e.indexOf("?");
  e = r === -1 ? e : e.substring(0, r);
  const a = new b0(t.scene);
  a.gltfId = e, a.context = s, a.gltf = t, a.nodeToObject = n?.nodeToObjectMap, a.implementationInformation = bA;
  let l = s[Zf];
  if (l || (l = s[Zf] = []), t.scenes)
    for (const c of t.scenes)
      await om(a, c, l);
  if (t.children)
    for (const c of t.children)
      await om(a, c, l);
  s.new_scripts_pre_setup_callbacks.push(() => {
    const c = s[Zf];
    if (c) {
      for (const h of c)
        wA(h, a);
      c.length = 0;
    }
    if (o) {
      const h = {}, d = [];
      sm(t, o, h, d);
      for (const f of t.scenes)
        sm(f, o, h, d);
      for (const f of d)
        f.resolveGuids(h);
    }
  });
}
const nm = Symbol("original-component-name"), Dr = /* @__PURE__ */ new Map();
function sm(s, e, t, i) {
  if (e === null || !s) return;
  const n = s.guid, o = s.guid;
  o?.length && (Dr.has(o) || (Ql && console.log('Creating InstanceIdProvider with key "' + o + '" for object ' + s.name), Dr.set(o, new Tt(o))));
  const r = o && Dr.get(o) || e;
  if (s.guid = r.generateUUID(), n && n !== "invalid" && (t[n] = s.guid), s && s.userData && s.userData.components)
    for (const a of s.userData.components) {
      if (a === null) continue;
      const l = a.guid;
      l ? Dr.has(l) || (Ql && console.log('Creating InstanceIdProvider with key "' + l + '" for component ' + a[nm]), Dr.set(l, new Tt(l))) : Ql && console.warn("Can not create IdProvider: component " + a[nm] + " has no guid", a.guid);
      const c = Dr.get(l) || e, h = a.guid;
      a.guid = c.generateUUID(), h && h !== "invalid" && (t[h] = a.guid), a.resolveGuids && i.push(a);
    }
  if (s.children)
    for (const a of s.children)
      sm(a, e, t, i);
}
const ul = [];
async function om(s, e, t, i) {
  if (!e) return;
  const n = e.userData;
  if (n) {
    const o = n.builtin_components;
    if (o && o.length > 0)
      for (const r of o)
        try {
          if (r === null) continue;
          const a = P.get(r.name);
          if (a != null) {
            const l = new a();
            l.sourceId = s.gltfId, ya(l, r, s.implementationInformation), l.context = s.context, "guid" in r && (l[Mh] = r.guid), l[nm] = r.name, ta(e, l, !1), t.push({ instance: l, compData: r, obj: e }), l.isCamera && s.context && s.context.mainCamera === null && l.tag === "MainCamera" && s.context.setCurrentCamera(l), s.context?.physics?.engine?.isInitialized === !1 && (l.isCollider || l.isRigidbody) && s.context?.physics.engine?.initialize();
          } else
            Ql && console.debug("unknown component: " + r.name), ul.includes(r.name) || ul.push(r.name);
        } catch (a) {
          console.error(r.name + " - " + a.message, a);
        }
    if (ul.length > 0) {
      const r = ul.join(", ");
      console.warn("unknown components: " + r), ul.length = 0, rn() && Be(`<strong>Unknown components in scene</strong>:

${r}

This could mean you forgot to add a npmdef to your ExportInfo
<a href="https://engine.needle.tools/docs/project_structure.html#creating-and-installing-a-npmdef" target="_blank">documentation</a>`, Ui.Warn);
    }
  }
  if (e.children)
    for (const o of e.children)
      await om(s, o, t);
}
function wA(s, e) {
  const { instance: t, compData: i, obj: n } = s;
  e.object = n, e.target = t, xp(t, i, e), Ql && console.debug("add " + i.name, i, t);
}
class Ew {
  createBuiltinComponents(e, t, i, n, o) {
    return vA(e, t, i, n, o);
  }
  writeBuiltinComponentData(e, t) {
    return _A(e, t);
  }
  parseSync(e, t, i, n) {
    return SA(e, t, i, n);
  }
  loadSync(e, t, i, n, o) {
    return Lw(e, t, i, n, o);
  }
}
Xb(Ew);
const Aw = w("printGltf") || w("printgltf"), xA = w("debugfileformat");
async function Iw(s, e) {
  const t = await qk(s, { useExtension: !0 }) || "unknown";
  xA && console.debug(`Determined file type: '${t}' for url '${s}'`, { registeredModelLoaderCallbacks: qr });
  for (const i of qr) {
    const { callback: n } = i, o = n({ context: e, url: s, mimetype: t });
    if (o instanceof Promise && await o, o)
      return console.debug(`Using custom loader (${i.name || "unnamed"}) for ${t} at '${s}'`), o;
  }
  switch (t) {
    case "unsupported":
      return null;
    default:
    case "unknown": {
      console.warn(`Unknown file type (${t}). Needle Engine will fallback to the GLTFLoader - To support more model formats please create a Needle loader plugin.
Use import { NeedleEngineModelLoader } from "@needle-tools/engine" namespace to register your loader.`, s);
      const i = new Ps();
      return await Fp(i, e, s), i;
    }
    case "model/fbx":
    case "model/vnd.autodesk.fbx":
      return new Sb();
    case "model/obj":
      return new ym();
    case "model/vnd.usdz+zip":
    case "model/vnd.usd+zip":
    case "model/vnd.usda+zip":
      return console.warn(t.toUpperCase() + " files are not supported."), null;
    case "model/gltf+json":
    case "model/gltf-binary":
    case "model/vrm": {
      const i = new Ps();
      return await Fp(i, e, s), i;
    }
  }
}
function uL(s, e) {
  return Lw(e?.context || N.Current, s, s, e?.seed || null, e?.onprogress);
}
async function SA(s, e, t, i) {
  typeof t != "string" && (console.warn("Parse gltf binary without path, this might lead to errors in resolving extensions. Please provide the source path of the gltf/glb file", t, typeof t), t = ""), Aw && console.log("Parse glTF", t);
  const n = await Iw(t, s);
  if (!n)
    return;
  const { componentsExtension: o } = Dw(n, s);
  if (n instanceof ym) {
    typeof e != "string" && (e = new TextDecoder().decode(e));
    const a = n.parse(e);
    return await Yl(n, s, t, a, i, o);
  }
  if (!(n instanceof Ps)) {
    if (n.parse === void 0) {
      console.error("Loader does not support parse");
      return;
    }
    const a = n.parse(e, t);
    return await Yl(n, s, t, a, i, o);
  }
  return new Promise((a, l) => {
    try {
      let c = t.split("?")[0].trimEnd();
      const h = c.split("/");
      h.length > 0 && h[h.length - 1] !== "" && h.pop(), c = h.join("/"), c.endsWith("/") || (c += "/"), n.resourcePath = c, n.parse(e, "", async (d) => {
        const f = await Yl(n, s, t, d, i, o);
        a(f);
      }, (d) => {
        console.error('Loading asset at "' + t + `" failed
`, d), a(void 0);
      });
    } catch (c) {
      console.error(c), l(c);
    }
  });
}
async function Lw(s, e, t, i, n) {
  PA(e);
  const o = await Iw(e, s);
  if (!o)
    return;
  const { componentsExtension: r } = Dw(o, s);
  if (!(o instanceof Ps)) {
    const a = await o.loadAsync(e, n);
    return await Yl(o, s, e, a, i, r);
  }
  return new Promise((a, l) => {
    try {
      o.load(e, async (c) => {
        const h = await Yl(o, s, t, c, i, r);
        a(h);
      }, (c) => {
        n?.call(o, c);
      }, (c) => {
        console.error('Loading asset at "' + e + `" failed
`, c), a(void 0);
      });
    } catch (c) {
      console.error(c), l(c);
    }
  });
}
function Dw(s, e) {
  const t = uv(s);
  return s instanceof Ps && $m(s, e), { componentsExtension: t };
}
async function Yl(s, e, t, i, n, o) {
  if (Aw && console.warn("Loaded", t, i), i == null)
    return console.error(`Loaded model is null '${t}' - please make sure the loader is registered correctly`), {
      scene: new M(),
      animations: [],
      scenes: []
    };
  if (typeof i != "object")
    return console.error(`Loaded model is not an object '${t}' - please make sure the loader is registered correctly`), {
      scene: new M(),
      animations: [],
      scenes: []
    };
  if (i instanceof M)
    i = {
      scene: i,
      animations: i.animations,
      scenes: [i]
    };
  else if (i instanceof Tn) {
    const r = new ct({
      color: new se(14540253)
    }), a = new H(i, r);
    i = {
      scene: a,
      animations: [],
      scenes: [a]
    };
  } else Array.isArray(i.scenes) === !1 && console.error(`[Needle Engine] The loaded model object does not have a scenes property '${t}' - please make sure the loader is registered correctly and three.js is not imported multiple times.`);
  return t.includes("?") && (t = t.split("?")[0]), OA(s, i), gk(i) && (yM(t, i, e), await jn().createBuiltinComponents(e, t, i, n, o || void 0)), await CA(i.scene, e, e.mainCamera), i;
}
async function CA(s, e, t) {
  t || (t = e.mainCamera);
  try {
    t ? await e.renderer.compileAsync(s, t, e.scene).catch((i) => {
      console.warn(i.message);
    }) : Q1(s, e);
  } catch (i) {
    console.warn(i?.message || i);
  }
}
function PA(s) {
  if (new URL(s, window.location.href).href.startsWith("file://")) {
    const t = `Hi - it looks like you are trying to load a local file which will not work. You need to use a webserver to serve your files.
Please refer to the documentation on <a href="https://fwd.needle.tools/needle-engine/docs/local-server">https://docs.needle.tools</a> or ask for help in our <a href="https://discord.needle.tools">discord community</a>`;
    Be(t), console.warn(t);
  }
}
function OA(s, e) {
  if ("scenes" in e) {
    for (const t of e.scenes)
      if (t && !t.animations?.length)
        for (const i of e.animations)
          t.animations.includes(i) || t.animations.push(i);
  }
  if (s instanceof Sb || s instanceof ym) {
    let t = e;
    t instanceof M || (t = e.scene || e.scenes.find((i) => i)), t.traverse((i) => {
      const n = i;
      n?.isMesh && Nb(n, n.material);
    });
  }
}
const fl = w("debugoverlay"), jw = "ar", kA = "quit-ar";
class MA {
  get ARContainer() {
    return this.arContainer;
  }
  arContainer = null;
  currentSession = null;
  _createdAROnlyElements = [];
  _reparentedObjects = [];
  contentElement = null;
  originalDomOverlayParent = null;
  requestEndAR = () => {
    this.onRequestedEndAR();
  };
  onBegin(e, t, i) {
    if (this.currentSession = i, this.arContainer = t, X.isMozillaXR()) {
      const n = e.domElement.children;
      for (let o = 0; o < n?.length; o++) {
        const r = n[o];
        if (!r || r === this.arContainer) return;
        this._reparentedObjects.push({ el: r, previousParent: r.parentElement }), this.arContainer?.appendChild(r);
      }
      t ? (this.originalDomOverlayParent = t.parentNode, this.originalDomOverlayParent && (console.log("Reparent DOM Overlay to body", t, t.style.display), t.style.display = "", t.style.visibility = "", document.body.appendChild(t))) : console.warn("WebXRViewer: No DOM Overlay found");
    }
    this.ensureQuitARButton(this.arContainer);
  }
  onEnd(e) {
    for (const t of this._createdAROnlyElements)
      t.remove && t.remove();
    for (const t of this._reparentedObjects) {
      const i = t.el;
      t.previousParent?.appendChild(i);
    }
    this._reparentedObjects.length = 0, X.isMozillaXR() && setTimeout(() => {
      const t = e.renderer.domElement;
      t && e.domElement.shadowRoot?.prepend(t);
      const i = document.querySelectorAll("*");
      for (var n = 0; n < i.length; n++) {
        const o = i[n];
        o && o._displayChanged !== void 0 && o._displayWas !== void 0 && (o.style.display = o._displayWas);
      }
    }, 10);
  }
  createOverlayContainer(e) {
    if (this.contentElement) return this.contentElement;
    fl && console.log("Setup overlay container");
    const t = e.shadowRoot.querySelector(".content");
    this.contentElement = t;
    const i = e.shadowRoot.querySelector(".overlay-content");
    return i && t.appendChild(i), fl && !X.isMobileDevice() && this.ensureQuitARButton(t), t;
  }
  onRequestedEndAR() {
    this.currentSession && (this.currentSession.end(), this.currentSession = null);
  }
  ensureQuitARButton(e) {
    const t = document.createElement("slot");
    t.setAttribute("name", "quit-ar"), this.appendElement(t, e), this._createdAROnlyElements.push(t), t.style.pointerEvents = "auto";
    const i = document.querySelector(`.${kA}`);
    if (i) {
      i.addEventListener("click", this.requestEndAR), fl && i.addEventListener("click", () => console.log("Clicked quit-ar button"));
      return;
    }
    t.addEventListener("click", this.requestEndAR), fl && t.addEventListener("click", () => console.log("Clicked fallback close button"));
    const n = document.createElement("div");
    n.style.cssText = `
            position: fixed;
            top: 0;
            right: 0;
            z-index: 600;
            pointer-events: all;
        `, this.appendElement(n, t);
    var o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o.classList.add("quit-ar-button"), o.setAttribute("width", "40px"), o.setAttribute("height", "40px"), o.style.cssText = `
            background: rgba(255, 255, 255, .4);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,.3);
            outline: 1px solid rgba(255, 255, 255, .6);
            display: flex;
            justify-content: center;
            align-items: center;
        `, n.appendChild(o);
    var r = document.createElementNS("http://www.w3.org/2000/svg", "path");
    r.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), r.setAttribute("stroke", "#000000"), r.setAttribute("stroke-width", "2px"), r.style.cssText = `
            /**filter: drop-shadow(0 0px 1.2px rgba(0,0,0,.7));**/
        `, o.appendChild(r), fl && console.log("Created fallback close button", o, e);
  }
  appendElement(e, t) {
    return t.shadowRoot ? t.shadowRoot.appendChild(e) : t.appendChild(e);
  }
}
const Ho = w("debugloading"), pl = w("debugloadingrendering"), Z_ = w("debuglicense");
class fL {
  className;
  additionalClasses;
}
let ml = 0, J_;
function Bw(s) {
  Ho && console.log(s.progress.loaded.toFixed(0) + "/" + s.progress.total.toFixed(0), s);
  const e = s.count, t = s.progress.total;
  t === 0 || t === void 0 ? (J_ !== s.name && (ml = 0), J_ = s.name, ml += (1 - ml) * 1e-3, Ho && ge("Loading " + s.name + " did not report total size")) : ml = s.progress.loaded / t;
  const i = s.index / e + ml / e;
  return j.clamp01(i);
}
class Md {
  static LoadingContainerClassName = "loading";
  // the raw progress
  loadingProgress = 0;
  /** Usually the NeedleEngineHTMLElement */
  _element;
  _progress = 0;
  _allowCustomLoadingElement = !0;
  _loadingElement;
  _loadingTextContainer = null;
  _loadingBar = null;
  _messageContainer = null;
  _loadingElementOptions;
  /**
   * Creates a new loading view
   * @param owner the element that will contain the loading view (should be the NeedleEngineHTMLElement)
   */
  constructor(e, t) {
    this._element = e, this._loadingElementOptions = t;
  }
  async onLoadingBegin(e) {
    const t = this._element.shadowRoot || this._element;
    if (Ho && console.warn("Begin Loading"), !this._loadingElement) {
      for (let i = 0; i < t.children.length; i++) {
        const n = t.children[i];
        if (n.classList.contains(Md.LoadingContainerClassName)) {
          if (!this._allowCustomLoadingElement) {
            Ho && console.warn("Remove custom loading container"), t.removeChild(n);
            continue;
          }
          this._loadingElement = this.createLoadingElement(n);
        }
      }
      this._loadingElement || (this._loadingElement = this.createLoadingElement());
    }
    this._progress = 0, this.loadingProgress = 0, this._loadingElement.style.display = "flex", t.appendChild(this._loadingElement), this.smoothProgressLoop(), this.setMessage(e ?? "");
  }
  onLoadingUpdate(e, t) {
    if (!this._loadingElement?.parentNode)
      return;
    let i = 0;
    typeof e == "number" ? i = e : ("index" in e && (i = Bw(e)), !t && "name" in e && this.setMessage("loading " + e.name)), this.loadingProgress = i, t && this.setMessage(t), this.updateDisplay();
  }
  onLoadingFinished() {
    Ho && console.warn("Finished Loading"), pl || (this.loadingProgress = 1, this.onDoneLoading());
  }
  setMessage(e) {
    this._messageContainer && (this._messageContainer.innerText = e);
  }
  _progressLoop;
  smoothProgressLoop() {
    if (this._progressLoop) return;
    let e = 1 / 12;
    pl && (e = 1 / 500, typeof pl == "number" && (e *= pl)), this._progressLoop = setInterval(() => {
      this.loadingProgress >= 0.95 && !pl && (e = 0.9), this._progress = j.lerp(this._progress, this.loadingProgress, e * this.loadingProgress), this.updateDisplay();
    }, e);
  }
  onDoneLoading() {
    this._loadingElement && (Ho && console.log("Hiding loading element"), this._loadingElement.style.display = "none", this._loadingElement.remove()), this._progressLoop && clearInterval(this._progressLoop), this._progressLoop = null;
  }
  updateDisplay() {
    const e = this._progress, t = (e * 100).toFixed(0) + "%";
    this._loadingBar && (this._loadingBar.style.width = e * 100 + "%"), this._loadingTextContainer && (this._loadingTextContainer.textContent = t);
  }
  createLoadingElement(e) {
    Ho && !e && console.log("Creating loading element"), this._loadingElement = e || document.createElement("div");
    let t = this._element.getAttribute("loading-style");
    (!t || t === "auto") && (window.matchMedia("(prefers-color-scheme: dark)").matches ? t = "dark" : t = "light");
    const i = bs();
    if (!e) {
      this._loadingElement.style.position = "absolute", this._loadingElement.style.width = "100%", this._loadingElement.style.height = "100%", this._loadingElement.style.left = "0", this._loadingElement.style.top = "0";
      const f = this._element.getAttribute("loading-background");
      f ? this._loadingElement.style.background = f : this._loadingElement.style.backgroundColor = "transparent", this._loadingElement.style.display = "flex", this._loadingElement.style.alignItems = "center", this._loadingElement.style.justifyContent = "center", this._loadingElement.style.zIndex = "0", this._loadingElement.style.flexDirection = "column", this._loadingElement.style.pointerEvents = "none", this._loadingElement.style.color = "white", this._loadingElement.style.fontFamily = 'system-ui, Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', this._loadingElement.style.fontSize = "1rem", t === "light" ? this._loadingElement.style.color = "rgba(0,0,0,.6)" : this._loadingElement.style.color = "rgba(255,255,255,.3)";
    }
    const n = this._loadingElementOptions?.className ?? Md.LoadingContainerClassName;
    if (this._loadingElement.classList.add(n), this._loadingElementOptions?.additionalClasses)
      for (const f of this._loadingElementOptions.additionalClasses)
        this._loadingElement.classList.add(f);
    const o = document.createElement("div");
    this._loadingElement.appendChild(o);
    const r = document.createElement("img"), a = 120;
    if (r.style.width = `${a}px`, r.style.height = `${a}px`, r.style.paddingTop = "20px", r.style.paddingBottom = "10px", r.style.margin = "0px", r.style.userSelect = "none", r.style.objectFit = "contain", r.style.transition = "transform 1.5s ease-out, opacity .3s ease-in-out", r.style.transform = "translateY(30px)", r.style.opacity = "0.05", setTimeout(() => {
      r.style.opacity = "1", r.style.transform = "translateY(0px)";
    }, 1), r.src = kb, i && this._element) {
      const f = this._element.getAttribute("loading-logo-src");
      f && (r.src = f);
    }
    o.appendChild(r);
    const l = document.createElement("div");
    l.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        opacity: 0;
        transition: opacity 1s ease-in-out 4s;
        `, setTimeout(() => {
      l.style.opacity = "1";
    }, 1), this._loadingElement.appendChild(l);
    const c = document.createElement("div"), h = 100;
    c.style.display = "flex", c.style.width = h + "%", c.style.height = "3px", c.style.position = "absolute", c.style.left = "0", c.style.bottom = "0px", c.style.opacity = "0", c.style.transition = "opacity 1s ease-in-out 2s", setTimeout(() => {
      c.style.opacity = "1";
    }, 1), t === "light" ? c.style.backgroundColor = "rgba(0,0,0,.2)" : c.style.backgroundColor = "rgba(255,255,255,.2)", this._loadingElement.appendChild(c), this._loadingBar = document.createElement("div"), c.appendChild(this._loadingBar);
    const d = function(f) {
      return j.lerp(0, h, f) + "%";
    };
    if (this._loadingBar.style.background = "#66A22F", this._loadingBar.style.backgroundAttachment = "fixed", this._loadingBar.style.width = "0%", this._loadingBar.style.height = "100%", i && this._element) {
      const f = this._element.getAttribute("primary-color"), p = this._element.getAttribute("secondary-color");
      f && p ? this._loadingBar.style.background = `linear-gradient(90deg, ${f} ${d(0)}, ${p} ${d(1)})` : f ? this._loadingBar.style.background = f : p && (this._loadingBar.style.background = p);
    }
    return this.handleRuntimeLicense(this._loadingElement), this._loadingElement;
  }
  async handleRuntimeLicense(e) {
    let t = vs();
    if (t) return;
    Z_ && console.log("Loading UI has commercial license?", t);
    const i = document.createElement("div");
    i.style.paddingTop = ".6em", i.style.fontSize = ".8em", i.style.textTransform = "uppercase", i.innerText = `NEEDLE ENGINE NON COMMERCIAL VERSION
CLICK HERE TO GET A LICENSE`, i.style.cursor = "pointer", i.style.userSelect = "none", i.style.textAlign = "center", i.style.pointerEvents = "all", i.addEventListener("click", () => window.open("https://needle.tools/pricing", "_self")), i.style.opacity = "0", e.appendChild(i), !L() && xa && (Z_ && console.log("Waiting for runtime license check"), await xa, t = vs()), !t && (i.style.transition = "opacity .5s ease-in-out", i.style.opacity = "1");
  }
}
Xb(Ew);
const Pe = w("debugwebcomponent"), eb = "needle-engine", Fw = "vr", zw = "desktop", RA = [jw, Fw, zw], gl = "ar-session-active", yl = "desktop-session-active", TA = [
  "public-key",
  "version",
  "hash",
  "src",
  "camera-controls",
  "loadstart",
  "progress",
  "loadfinished",
  "dracoDecoderPath",
  "dracoDecoderType",
  "ktx2DecoderPath",
  "tone-mapping",
  "tone-mapping-exposure",
  "background-blurriness",
  "background-color",
  "environment-intensity"
];
class Uw extends HTMLElement {
  static get observedAttributes() {
    return TA;
  }
  get loadingProgress01() {
    return this._loadingProgress01;
  }
  get loadingFinished() {
    return this.loadingProgress01 > 0.999;
  }
  /**
   * If set to false the camera controls are disabled. Default is true.  
   * @type {boolean | null}
   * @memberof NeedleEngineAttributes
   * @example
   * <needle-engine camera-controls="false"></needle-engine>
   * @example
   * <needle-engine camera-controls="true"></needle-engine>
   * @example
   * <needle-engine camera-controls></needle-engine>
   * @example
   * <needle-engine></needle-engine>
   * @returns {boolean | null} if the attribute is not set it returns null
   */
  get cameraControls() {
    const e = this.getAttribute("camera-controls");
    return e == null ? null : !(e === null || e === "False" || e === "false" || e === "0" || e === "none");
  }
  /**
   * Get the current context for this web component instance. The context is created when the src attribute is set and the loading has finished.  
   * The context is disposed when the needle engine is removed from the document (you can prevent this by setting the keep-alive attribute to true).  
   * @returns {Promise<Context>} a promise that resolves to the context when the loading has finished
   */
  getContext() {
    return new Promise((e, t) => {
      if (this._context && this.loadingFinished)
        e(this._context);
      else {
        const i = () => {
          this.removeEventListener("loadfinished", i), this._context && this.loadingFinished && e(this._context);
        };
        this.addEventListener("loadfinished", i);
      }
    });
  }
  /**
   * Get the context that is created when the src attribute is set and the loading has finished.
   */
  get context() {
    return this._context;
  }
  _context;
  _overlay_ar;
  _loadingProgress01 = 0;
  _loadingView;
  _previousSrc = null;
  /** set to true after <needle-engine> did load completely at least once. Set to false when <needle-engine> is removed from the document */
  _didFullyLoad = !1;
  constructor() {
    super(), this._overlay_ar = new MA(), this.addEventListener("ready", this.onReady), I0(), this.attachShadow({ mode: "open" });
    const e = document.createElement("template");
    e.innerHTML = `<style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

    :host {
        position: absolute;
        display: block;
        width: max(600px, 100%);
        height: max(300px, 100%);
        touch-action: none;

        -webkit-tap-highlight-color: transparent;
    }

    @media (max-width: 600px) {
        :host {
            width: 100%;
        }
    }
    @media (max-height: 300px) {
        :host {
            height: 100%;
        }
    }

    :host > div.canvas-wrapper {
        width: 100%;
        height: 100%;
    }

    :host canvas {   
        position: absolute;
        user-select: none;
        -webkit-user-select: none;

        /** allow touch panning but no pinch zoom **/
        /** but this doesnt work yet: 
         * touch-action: pan-x, pan-y;
         **/
        
        -webkit-touch-callout: none;
        -webkit-user-drag: none;
        -webkit-user-modify: none;

        left: 0;
        top: 0;
    }
    :host .content {
        position: absolute;
        top: 0;
        width: 100%;
        height: 100%;
        visibility: visible;
        z-index: 500; /* < must be less than the webxr buttons element */
        pointer-events: none;
    }
    :host .overlay-content {
        position: absolute;
        user-select: auto;
        pointer-events: all;
    }
    :host slot[name="quit-ar"]:hover {
        cursor: pointer;
    }
    :host .quit-ar-button {
        position: absolute;
        // top: env(titlebar-area-y); /** this doesnt work **/
        top: 60px; /** camera access needs a bit more space **/
        right: 20px;
        z-index: 9999;
    }
</style>
<div class="canvas-wrapper"> <!-- this wrapper is necessary for WebXR https://github.com/meta-quest/immersive-web-emulator/issues/55 -->
    <canvas></canvas>
</div>
<div class="content">
    <slot class="overlay-content"></slot>
</div>
`, this.shadowRoot && this.shadowRoot.appendChild(e.content.cloneNode(!0)), this._context = new N({ domElement: this }), this.addEventListener("error", this.onError);
  }
  /**
   * @internal
   */
  async connectedCallback() {
    if (Pe && console.log("<needle-engine> connected"), this.setPublicKey(), this.setVersion(), (this.getAttribute("tabindex") === null || this.getAttribute("tabindex") === void 0) && this.setAttribute("tabindex", "0"), this.addEventListener("xr-session-started", this.onXRSessionStarted), this.onSetupDesktop(), !this.getAttribute("src")) {
      const t = globalThis["needle:codegen_files"];
      Pe && console.log('src is null, trying to load from globalThis["needle:codegen_files"]', t), t && (Pe && console.log('globalThis["needle:codegen_files"]', t), this.setAttribute("src", t));
    }
    Pe && console.log("src", this.getAttribute("src"));
    const e = this._loadId;
    setTimeout(() => {
      this.isConnected !== !1 && e === this._loadId && this.onLoad();
    }, 1);
  }
  /**
   * @internal
   */
  disconnectedCallback() {
    this.removeEventListener("xr-session-started", this.onXRSessionStarted), this._didFullyLoad = !1;
    const e = this.getAttribute("keep-alive"), t = e == null || e?.length > 0 && e !== "true" && e !== "1";
    Pe && console.warn('<needle-engine> disconnected, keep-alive: "' + e + '"', typeof e, "Dispose=", t), t ? (Pe && console.warn("<needle-engine> dispose"), this._context?.dispose(), this._context = null, this._lastSourceFiles = null, this._loadId += 1) : Pe && console.warn("<needle-engine> is not disposed because keep-alive is set");
  }
  /**
   * @internal
   */
  attributeChangedCallback(e, t, i) {
    switch (Pe && console.log("attributeChangedCallback", e, t, i), e) {
      case "src":
        Pe && console.warn(`<needle-engine src>
changed from "`, t, '" to "', i, '"'), this.onLoad();
        break;
      case "hash":
        this._context && (this._context.hash = i);
        break;
      case "loadstart":
      case "progress":
      case "loadfinished":
        typeof i == "string" && i.length > 0 && (Pe && console.log(e + " attribute changed", i), this.registerEventFromAttribute(e, i));
        break;
      case "dracoDecoderPath":
        Pe && console.log("dracoDecoderPath", i), i_(i);
        break;
      case "dracoDecoderType":
        i === "wasm" || i === "js" ? (Pe && console.log("dracoDecoderType", i), n_(i)) : console.error("Invalid dracoDecoderType", i, "expected js or wasm");
        break;
      case "ktx2DecoderPath":
        Pe && console.log("ktx2DecoderPath", i), s_(i);
        break;
      case "tonemapping":
      case "tone-mapping": {
        this.applyAttributes();
        break;
      }
      case "tone-mapping-exposure": {
        this.applyAttributes();
        break;
      }
      case "background-blurriness": {
        this.applyAttributes();
        break;
      }
      case "environment-intensity": {
        this.applyAttributes();
        break;
      }
      case "public-key": {
        i != bl && this.setPublicKey();
        break;
      }
      case "version": {
        i != En && this.setVersion();
        break;
      }
    }
  }
  /** The tonemapping setting configured as an attribute on the <needle-engine> component */
  get toneMapping() {
    return this.getAttribute("tonemapping") || this.getAttribute("tone-mapping");
  }
  _loadId = 0;
  _abortController = null;
  _lastSourceFiles = null;
  _createContextPromise = null;
  async onLoad() {
    if (!this.isConnected) return;
    if (this._context || (Pe && console.warn("Create new context"), this._context = new N({ domElement: this })), !this._context) {
      console.error("Needle Engine: Context not initialized");
      return;
    }
    const e = this.getSourceFiles();
    if (!this.checkIfSourceHasChanged(e, this._lastSourceFiles))
      return;
    this._abortController && (Pe && console.warn("Abort previous loading process"), this._abortController.abort(), this._abortController = null), this._lastSourceFiles = e;
    const t = ++this._loadId;
    if ((e == null || e.length <= 0) && (Pe && console.warn("Clear scene", e), this._context.clear(), t !== this._loadId))
      return;
    const i = this.getAttribute("alias");
    this.classList.add("loading");
    const n = vs();
    this.ensureLoadStartIsRegistered();
    let o = this.dispatchEvent(new CustomEvent("loadstart", {
      detail: {
        context: this._context,
        alias: i
      },
      cancelable: !0
    }));
    if (n) {
      const g = this.getAttribute("hide-loading-overlay");
      g != null && g !== "0" && (o = !1);
    }
    o === !1 && !n && (L() || (o = !0), console.warn("Needle Engine: You need a commercial license to override the default loading view. Visit https://needle.tools/pricing"), L() && ge('You need a <a target="_blank" href="https://needle.tools/pricing">commercial license</a> to override the default loading view. This will not work in production.')), !this._loadingView && o && (this._loadingView = new Md(this)), o && (this._didFullyLoad !== !0 ? this._loadingView?.onLoadingBegin("begin load") : setTimeout(() => {
      this._loadingView && this._loadingProgress01 < 0.3 && this._loadId === t && this._loadingView.onLoadingBegin("begin load");
    }, 300)), Pe && console.warn(`--------------
Needle Engine: Begin loading ` + t + `
`, e), this.onBeforeBeginLoading();
    const r = [], a = {
      context: this._context,
      name: "",
      progress: {},
      index: 0,
      count: e.length,
      totalProgress01: this._loadingProgress01
    }, l = new CustomEvent("progress", { detail: a }), c = new Array(), h = new AbortController();
    this._abortController = h;
    const d = {
      files: e,
      abortSignal: h.signal,
      onLoadingProgress: (g) => {
        if (Pe && console.debug("Loading progress: ", g), h.signal.aborted) return;
        const _ = g.index;
        !c[_] && g.name && (c[_] = EA(g.name)), g.name = c[_], o && this._loadingView?.onLoadingUpdate(g), a.name = g.name, a.progress = g.progress, this._loadingProgress01 = Bw(g), a.totalProgress01 = this._loadingProgress01, this.dispatchEvent(l);
      },
      onLoadingFinished: (g, _, m) => {
        Pe && console.debug(`Finished loading "${_}" (aborted? ${h.signal.aborted})`), !h.signal.aborted && m && r.push({
          src: _,
          file: m
        });
      }
    };
    AA(this);
    const f = this.getAttribute("hash");
    f != null && (this._context.hash = f), this._context.alias = i, this._createContextPromise = this._context.create(d);
    const p = await this._createContextPromise;
    if (this.applyAttributes(), Pe && console.warn(`--------------
Needle Engine: finished loading ` + t + `
`, e, `Aborted? ${h.signal.aborted}`), h.signal.aborted) {
      console.log("Loading finished but aborted...");
      return;
    }
    if (this._loadId !== t) {
      console.log("Load id changed during loading process");
      return;
    }
    this._loadingProgress01 = 1, o && p && this._loadingView?.onLoadingUpdate(1, "creating scene"), this._didFullyLoad = !0, this.classList.remove("loading"), this.classList.add("loading-finished"), this.dispatchEvent(new CustomEvent("loadfinished", {
      detail: {
        context: this._context,
        src: i,
        loadedFiles: r
      }
    }));
  }
  applyAttributes() {
    if (this._context?.renderer) {
      const n = A0(this.toneMapping);
      n !== void 0 && (this._context.renderer.toneMapping = n);
      const o = this.getAttribute("tone-mapping-exposure");
      if (o != null) {
        const r = parseFloat(o);
        isNaN(r) || (this._context.renderer.toneMappingExposure = r);
      }
    }
    const e = this.getAttribute("background-blurriness");
    if (e != null) {
      const n = parseFloat(e);
      !isNaN(n) && this._context && (this._context.scene.backgroundBlurriness = n);
    }
    const t = this.getAttribute("environment-intensity");
    if (t != null && this._context) {
      const n = parseFloat(t);
      !isNaN(n) && this._context && (this._context.scene.environmentIntensity = n);
    }
    const i = this.getAttribute("background-color");
    if (this._context?.renderer && typeof i == "string" && i.length > 0) {
      const n = oe.fromColorRepresentation(i);
      Pe && console.debug("<needle-engine> background-color changed, str:", i, "→", n), this._context.renderer.setClearColor(n, n.alpha), this.context.scene.background = null;
    }
  }
  onXRSessionStarted = () => {
    const e = this.context.xrSessionMode;
    e === "immersive-ar" ? this.onEnterAR(this.context.xrSession) : e === "immersive-vr" && this.onEnterVR(this.context.xrSession), this.context.xrSession?.addEventListener("end", () => {
      this.dispatchEvent(new CustomEvent("xr-session-ended", { detail: { session: this.context.xrSession, context: this._context, sessionMode: e } })), e === "immersive-ar" ? this.onExitAR(this.context.xrSession) : e === "immersive-vr" && this.onExitVR(this.context.xrSession);
    });
  };
  /** called by the context when the first frame has been rendered */
  onReady = () => this._loadingView?.onLoadingFinished();
  onError = () => this._loadingView?.setMessage("Loading failed!");
  getSourceFiles() {
    const e = this.getAttribute("src");
    if (!e) return [];
    let t;
    Array.isArray(e) ? t = e : e.startsWith("[") && e.endsWith("]") ? t = JSON.parse(e) : e.includes(",") ? t = e.split(",") : t = [e];
    for (let i = t.length - 1; i >= 0; i--) {
      const n = t[i];
      (n === "null" || n === "undefined" || n?.length <= 0) && t.splice(i, 1);
    }
    return t;
  }
  checkIfSourceHasChanged(e, t) {
    if (e?.length !== t?.length || e == null && t !== null || e !== null && t == null) return !0;
    if (e !== null && t !== null) {
      for (let i = 0; i < e?.length; i++)
        if (e[i] !== t[i]) return !0;
    }
    return !1;
  }
  _previouslyRegisteredMap = /* @__PURE__ */ new Map();
  ensureLoadStartIsRegistered() {
    const e = this.getAttribute("loadstart");
    e && this.registerEventFromAttribute("loadstart", e);
  }
  registerEventFromAttribute(e, t) {
    const i = this._previouslyRegisteredMap.get(e);
    if (i && (this._previouslyRegisteredMap.delete(e), this.removeEventListener(e, i)), typeof t == "string" && t.length > 0)
      try {
        const n = (0, eval)(t);
        typeof n == "function" && (this._previouslyRegisteredMap.set(e, n), this.addEventListener(e, (o) => n?.call(globalThis, this._context, o)));
      } catch (n) {
        console.error("Error registering event " + e + '="' + t + `" failed with the following error:
`, n);
      }
  }
  setPublicKey() {
    bl && bl.length > 0 && this.setAttribute("public-key", bl);
  }
  setVersion() {
    En.length > 0 && this.setAttribute("version", En);
  }
  /**
   * @internal
   */
  getAROverlayContainer() {
    return this._overlay_ar.createOverlayContainer(this);
  }
  /**
   * @internal
   */
  getVROverlayContainer() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      if (t.classList.contains("vr"))
        return t;
    }
    return null;
  }
  /**
   * @internal
   */
  onEnterAR(e) {
    this.onSetupAR();
    const t = this.getAROverlayContainer();
    this._overlay_ar.onBegin(this._context, t, e), this.dispatchEvent(new CustomEvent("enter-ar", { detail: { session: e, context: this._context, htmlContainer: this._overlay_ar?.ARContainer } }));
  }
  /**
   * @internal
   */
  onExitAR(e) {
    this._overlay_ar.onEnd(this._context), this.onSetupDesktop(), this.dispatchEvent(new CustomEvent("exit-ar", { detail: { session: e, context: this._context, htmlContainer: this._overlay_ar?.ARContainer } }));
  }
  /**
   * @internal
   */
  onEnterVR(e) {
    this.onSetupVR(), this.dispatchEvent(new CustomEvent("enter-vr", { detail: { session: e, context: this._context } }));
  }
  /**
   * @internal
   */
  onExitVR(e) {
    this.onSetupDesktop(), this.dispatchEvent(new CustomEvent("exit-vr", { detail: { session: e, context: this._context } }));
  }
  onSetupAR() {
    this.classList.add(gl), this.classList.remove(yl);
    const e = this.getAROverlayContainer();
    Pe && console.warn("onSetupAR:", e), e && (e.classList.add(gl), e.classList.remove(yl)), this.foreachHtmlElement((t) => this.setupElementsForMode(t, jw));
  }
  onSetupVR() {
    this.classList.remove(gl), this.classList.remove(yl), this.foreachHtmlElement((e) => this.setupElementsForMode(e, Fw));
  }
  onSetupDesktop() {
    this.classList.remove(gl), this.classList.add(yl);
    const e = this.getAROverlayContainer();
    e && (e.classList.remove(gl), e.classList.add(yl)), this.foreachHtmlElement((t) => this.setupElementsForMode(t, zw));
  }
  setupElementsForMode(e, t, i = null) {
    if (e === this._context?.renderer?.domElement || e.id === "VRButton" || e.id === "ARButton") return;
    if (e.classList.contains(t))
      e.style.visibility = "visible", e.style.display === "none" && (e.style.display = "block");
    else
      for (const o of RA)
        e.classList.contains(o) && (e.style.visibility = "hidden", e.style.display = "none");
  }
  foreachHtmlElement(e) {
    for (let t = 0; t < this.children.length; t++) {
      const i = this.children[t];
      i.style && e(i);
    }
  }
  onBeforeBeginLoading() {
    const e = this.getAttribute("dracoDecoderPath");
    e && (Pe && console.log("using custom draco decoder path", e), i_(e));
    const t = this.getAttribute("dracoDecoderType");
    t && (Pe && console.log("using custom draco decoder type", t), n_(t));
    const i = this.getAttribute("ktx2DecoderPath");
    i && (Pe && console.log("using custom ktx2 decoder path", i), s_(i));
  }
}
typeof window < "u" && !window.customElements.get(eb) && window.customElements.define(eb, Uw);
function EA(s) {
  if (s.startsWith("blob:"))
    return "blob";
  const e = s.split("/");
  let t = e[e.length - 1];
  const i = t.indexOf("?");
  i > 0 && (t = t.substring(0, i));
  const n = t.indexOf("=");
  n > 0 && (t = t.substring(n));
  const o = t.split(".").pop(), a = o ? ["glb", "gltf", "usdz", "usd", "fbx", "obj", "mtl"].indexOf(o.toLowerCase()) : -1;
  if (o && a >= 0 && (t = t.substring(0, t.length - o.length - 1)), t = decodeURIComponent(t), t.length > 3) {
    let l = "", c = !1;
    const h = ["(", ")", "[", "]", "{", "}", ":", ";", ",", ".", "!", "?"];
    for (let d = 0; d < t.length; d++) {
      let f = t[d];
      (f === "_" || f === "-") && (f = " "), !(f === " " && l.length <= 0 || h.includes(f) || (l.length === 0 && (f = f.toUpperCase()), c && f === " ")) && (c && (f = f.toUpperCase()), c = !1, l += f, f === " " && (c = !0));
    }
    return L() && t !== l && console.debug('Generated display name: "' + t + '" → "' + l + '"'), l.trim();
  }
  return L() && console.debug("Loading: use default name", t), t;
}
function AA(s) {
  B0((e) => {
    const t = s.getAttribute("loading-blur");
    if (t !== null && t !== "0" && e.domElement === s) {
      const i = e.lodsManager.manager?.awaitLoading({
        frames: 5,
        signal: AbortSignal.timeout(1e4),
        // Limit how long the page can be blurred
        maxPromisesPerObject: 1
      }).catch((r) => {
      });
      let n = "20px";
      t.endsWith("px") && (n = t);
      const o = 170;
      if (e.scene.background === null) {
        const r = s, a = e.renderer.domElement, l = a.style.filter, c = a.style.overflow;
        a.style.filter += `blur(${n})`, r.style.overflow = "hidden", i?.then(() => {
          const h = a.animate([
            {
              filter: "blur(0px)"
            }
          ], { duration: o, easing: "ease-in" });
          h.onfinish = () => {
            a.style.filter = l, r.style.overflow = c;
          };
        });
      } else {
        const r = document.createElement("div");
        e.domElement.prepend(r), r.style.cssText = "position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none", r.style.backdropFilter = `blur(${n})`, i?.then(() => {
          const a = r.animate([
            {
              backdropFilter: "blur(0px)",
              opacity: 0
            }
          ], { duration: o, easing: "ease-in" });
          a.onfinish = () => {
            r.remove();
          };
        });
      }
    }
  }, { once: !0 });
}
const IA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NeedleEngineWebComponent: Uw
}, Symbol.toStringTag, { value: "Module" }));
function LA() {
  Bn.registerWaitForInteraction(() => {
    const s = iS.getContext();
    s.addEventListener("statechange", () => {
      setTimeout(() => {
        const e = s.state;
        (e === "suspended" || e === "interrupted") && s.resume().then(() => {
          console.log("AudioContext resumed successfully");
        }).catch((t) => {
          console.log("Failed to resume AudioContext: " + t);
        });
      }, 500);
    });
  });
}
setTimeout(LA, 1e3);
const Qe = w("debugphysics"), Jf = w("debugcolliderplacement"), ep = w("debugcollisions"), DA = w("showcolliders"), Oh = w("debugraycasts"), Yt = Symbol("needle component"), Ft = Symbol("physics body"), tb = Symbol("rigidbody");
globalThis.NEEDLE_USE_RAPIER = globalThis.NEEDLE_USE_RAPIER !== void 0 ? globalThis.NEEDLE_USE_RAPIER : !0;
Qe && console.log("Use Rapier", !0, globalThis.NEEDLE_USE_RAPIER);
he.registerCallback(ce.ContextCreationStart, (s) => {
  Qe && console.log("Register rapier physics backend"), s.context.physics.engine = new Kl(s.context);
});
class Kl {
  debugRenderColliders = !1;
  debugRenderRaycasts = !1;
  removeBody(e) {
    if (!e) return;
    this.validate();
    const t = e[Ft];
    if (e[Ft] = null, t && this.world) {
      const i = this.objects.findIndex((n) => n === e);
      if (i >= 0) {
        const n = this.bodies[i];
        if (this.bodies.splice(i, 1), this.objects.splice(i, 1), n instanceof R.RAPIER_PHYSICS.MODULE.Collider) {
          const o = n;
          this.world?.removeCollider(o, !0);
          const r = o.parent();
          r && r.numColliders() <= 0 && (r[Yt] || this.world?.removeRigidBody(r));
        } else n instanceof R.RAPIER_PHYSICS.MODULE.RigidBody && (n.numColliders() <= 0 ? this.world?.removeRigidBody(n) : L() && (n.did_log_removing || setTimeout(() => {
          n.numColliders() > 0 && (n.did_log_removing = !0, console.warn("RapierPhysics: removing rigidbody with colliders from the physics world is not possible right now, please remove the colliders first"));
        }, 1)));
      }
    }
  }
  updateBody(e, t, i) {
    if (this.validate(), !!this.enabled && !(e.destroyed || !e.gameObject) && !(!t && !i))
      if (e.isCollider === !0)
        console.warn("TODO: implement updating collider position");
      else {
        const n = e, o = n[Ft];
        o && this.syncPhysicsBody(n.gameObject, o, t, i);
      }
  }
  updateProperties(e) {
    if (this.validate(), e.isCollider) {
      const t = e, i = t[Ft];
      i && (this.internalUpdateColliderProperties(t, i), t.sharedMaterial && this.updatePhysicsMaterial(t));
    } else {
      const t = e, i = this.internal_getRigidbody(t);
      i && this.internalUpdateRigidbodyProperties(t, i);
    }
  }
  addForce(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.addForce(t, i) : console.warn("Rigidbody doesn't exist: can not apply force (does your object with the Rigidbody have a collider?)");
  }
  addImpulse(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.applyImpulse(t, i) : console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  getLinearVelocity(e) {
    this.validate();
    const t = this.internal_getRigidbody(e);
    return t ? t.linvel() : null;
  }
  getAngularVelocity(e) {
    this.validate();
    const t = this.internal_getRigidbody(e);
    return t ? t.angvel() : null;
  }
  resetForces(e, t) {
    this.validate(), this.internal_getRigidbody(e)?.resetForces(t);
  }
  resetTorques(e, t) {
    this.validate(), this.internal_getRigidbody(e)?.resetTorques(t);
  }
  applyImpulse(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.applyImpulse(t, i) : console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  wakeup(e) {
    this.validate();
    const t = this.internal_getRigidbody(e);
    t ? t.wakeUp() : console.warn("Rigidbody doesn't exist: can not wake up (does your object with the Rigidbody have a collider?)");
  }
  isSleeping(e) {
    return this.validate(), this.internal_getRigidbody(e)?.isSleeping();
  }
  setAngularVelocity(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.setAngvel(t, i) : console.warn("Rigidbody doesn't exist: can not set angular velocity (does your object with the Rigidbody have a collider?)");
  }
  setLinearVelocity(e, t, i) {
    this.validate();
    const n = this.internal_getRigidbody(e);
    n ? n.setLinvel(t, i) : console.warn("Rigidbody doesn't exist: can not set linear velocity (does your object with the Rigidbody have a collider?)");
  }
  context;
  _initializePromise;
  _isInitialized = !1;
  constructor(e) {
    this.context = e;
  }
  get isInitialized() {
    return this._isInitialized;
  }
  async initialize() {
    return this._initializePromise || (this._initializePromise = this.internalInitialization()), this._initializePromise;
  }
  async internalInitialization() {
    return w("__nophysics") ? (console.warn("Physics are disabled"), !1) : (Qe && console.log("Initialize rapier physics engine"), this._hasCreatedWorld ? (console.error("Invalid call to create physics world: world is already created"), !0) : (this._hasCreatedWorld = !0, R.RAPIER_PHYSICS.MAYBEMODULE == null && (Qe && console.trace("Loading rapier physics engine"), await (await R.RAPIER_PHYSICS.load()).init()), Qe && console.log("Physics engine initialized, creating world..."), this._world = new R.RAPIER_PHYSICS.MODULE.World(this._gravity), this.rapierRay = new R.RAPIER_PHYSICS.MODULE.Ray({ x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 }), this.enabled = !0, this._isInitialized = !0, Qe && console.log("Physics world created"), !0));
  }
  /** Check is the physics engine has been initialized and the call can be made */
  validate() {
    this._isInitialized || Qe && (this._lastWarnTime = this._lastWarnTime ?? 0, Date.now() - this._lastWarnTime > 1e3 && (this._lastWarnTime = Date.now(), console.warn("Physics engine is not initialized")));
  }
  rapierRay;
  raycastVectorsBuffer = new $i(() => new b(), 10);
  raycast(e, t, i) {
    if (!this._isInitialized)
      return console.log("Physics engine is not initialized"), null;
    let n = i?.maxDistance, o = i?.solid;
    n === void 0 && (n = 1 / 0), o === void 0 && (o = !0);
    const r = this.getPhysicsRay(this.rapierRay, e, t);
    if (!r) return null;
    (this.debugRenderRaycasts || Oh) && F.DrawRay(r.origin, r.dir, 255, 1);
    const a = this.world?.castRay(r, n, o, i?.queryFilterFlags, i?.filterGroups, void 0, void 0, (l) => {
      const c = l[Yt];
      return i?.filterPredicate ? i.filterPredicate(c) : i?.useIgnoreRaycastLayer !== !1 ? !c?.gameObject.layers.isEnabled(2) : !0;
    });
    if (a) {
      const l = r.pointAt(a.timeOfImpact), c = this.raycastVectorsBuffer.get();
      return c.set(l.x, l.y, l.z), { point: c, collider: a.collider[Yt] };
    }
    return null;
  }
  raycastAndGetNormal(e, t, i) {
    if (!this._isInitialized)
      return null;
    let n = i?.maxDistance, o = i?.solid;
    n === void 0 && (n = 1 / 0), o === void 0 && (o = !0);
    const r = this.getPhysicsRay(this.rapierRay, e, t);
    if (!r) return null;
    (this.debugRenderRaycasts || Oh) && F.DrawRay(r.origin, r.dir, 255, 1);
    const a = this.world?.castRayAndGetNormal(r, n, o, i?.queryFilterFlags, i?.filterGroups, void 0, void 0, (l) => {
      const c = l[Yt];
      return i?.filterPredicate ? i.filterPredicate(c) : i?.useIgnoreRaycastLayer !== !1 ? !c?.gameObject.layers.isEnabled(2) : !0;
    });
    if (a) {
      const l = r.pointAt(a.timeOfImpact), c = a.normal, h = this.raycastVectorsBuffer.get(), d = this.raycastVectorsBuffer.get();
      return h.set(l.x, l.y, l.z), d.set(c.x, c.y, c.z), { point: h, normal: d, collider: a.collider[Yt] };
    }
    return null;
  }
  getPhysicsRay(e, t, i) {
    const n = this.context?.mainCamera;
    if (t === void 0) {
      const a = this.context?.input.getPointerPosition(0);
      if (a) t = a;
      else return null;
    }
    if (t.z === void 0) {
      if (!n)
        return console.error("Can not perform raycast from 2d point - no main camera found"), null;
      const a = this.raycastVectorsBuffer.get();
      a.x = t.x, a.y = t.y, a.z = 0, (a.x > 1 || a.y > 1 || a.y < -1 || a.x < -1) && (Qe && console.warn("Converting screenspace to raycast space", a), this.context?.input.convertScreenspaceToRaycastSpace(a)), a.unproject(n), t = a;
    }
    const o = t;
    e.origin.x = o.x, e.origin.y = o.y, e.origin.z = o.z;
    const r = this.raycastVectorsBuffer.get();
    if (i)
      r.set(i.x, i.y, i.z);
    else {
      if (!n)
        return console.error("Can not perform raycast - no camera found"), null;
      r.set(e.origin.x, e.origin.y, e.origin.z);
      const a = Z(n);
      r.sub(a);
    }
    return r.normalize(), e.dir.x = r.x, e.dir.y = r.y, e.dir.z = r.z, e;
  }
  rapierSphere = null;
  rapierBox = null;
  rapierColliderArray = [];
  rapierIdentityRotation = { x: 0, y: 0, z: 0, w: 1 };
  rapierForwardVector = { x: 0, y: 0, z: 1 };
  /** Precice sphere overlap detection using rapier against colliders
   * @param point center of the sphere in worldspace
   * @param radius radius of the sphere
   * @returns array of colliders that overlap with the sphere. Note: they currently only contain the collider and the gameobject
   */
  sphereOverlap(e, t) {
    return this.rapierSphere ??= new R.RAPIER_PHYSICS.MODULE.Ball(t), this.rapierSphere.radius = t, (this.debugRenderRaycasts || Oh) && F.DrawWireSphere(e, t, 3359999, 1), this.shapeOverlap(e, this.rapierIdentityRotation, this.rapierSphere);
  }
  /** box overlap detection using rapier against colliders
   * @param point center of the box in worldspace
   * @param size size of the box
   * @param rotation quaternion representation of the rotation in world space
   * @returns array of colliders that overlap with the box. Note: they currently only contain the collider and the gameobject
   */
  boxOverlap(e, t, i = null) {
    return i === null && (i = this.rapierIdentityRotation), this.rapierBox ??= new R.RAPIER_PHYSICS.MODULE.Cuboid(1, 1, 1), this.rapierBox.halfExtents.x = t.x * 0.5, this.rapierBox.halfExtents.y = t.y * 0.5, this.rapierBox.halfExtents.z = t.z * 0.5, (this.debugRenderRaycasts || Oh) && F.DrawWireBox(e, t, 3359999, 1, !0, i), this.shapeOverlap(e, i, this.rapierBox);
  }
  shapeOverlap(e, t, i) {
    return this.rapierColliderArray.length = 0, this._isInitialized ? this.world ? (this.world.intersectionsWithShape(
      e,
      t,
      i,
      (n) => {
        const o = n[Yt], r = new vk(o.gameObject, o);
        return this.rapierColliderArray.push(r), !0;
      },
      // TODO: it seems as QueryFilterFlags.EXCLUDE_SENSORS also excludes DYNAMIC Rigidbodies (only if they're set to kinematic)
      void 0,
      // QueryFilterFlags.EXCLUDE_SENSORS, 
      void 0,
      void 0,
      void 0,
      (n) => n.isSensor() ? !1 : n[Yt].gameObject.layers.isEnabled(2) == !1
    ), this.rapierColliderArray) : this.rapierColliderArray : this.rapierColliderArray;
  }
  // physics simulation
  enabled = !1;
  /** Get access to the rapier world */
  get world() {
    return this._world;
  }
  _tempPosition = new b();
  _tempQuaternion = new $();
  _tempScale = new b();
  _tempMatrix = new te();
  static _didLoadPhysicsEngine = !1;
  _isUpdatingPhysicsWorld = !1;
  get isUpdating() {
    return this._isUpdatingPhysicsWorld;
  }
  _world;
  _hasCreatedWorld = !1;
  eventQueue;
  collisionHandler;
  objects = [];
  bodies = [];
  _meshCache = /* @__PURE__ */ new Map();
  _gravity = { x: 0, y: -9.81, z: 0 };
  get gravity() {
    return this.world?.gravity ?? this._gravity;
  }
  set gravity(e) {
    this.world ? this.world.gravity = e : this._gravity = e;
  }
  clearCaches() {
    this._meshCache.clear(), this.eventQueue?.raw && this.eventQueue?.free(), this.world?.bodies && this.world?.free();
  }
  async addBoxCollider(e, t) {
    if (this._isInitialized || await this.initialize(), !e.activeAndEnabled) return;
    if (!this.enabled) {
      Qe && console.warn("Physics are disabled");
      return;
    }
    const i = e.gameObject, n = $e(i, this._tempPosition).multiply(t);
    n.multiplyScalar(0.5), n.x < 0 && (n.x = Math.abs(n.x)), n.y < 0 && (n.y = Math.abs(n.y)), n.z < 0 && (n.z = Math.abs(n.z));
    const o = 1e-7;
    n.x < o && (n.x = o), n.y < o && (n.y = o), n.z < o && (n.z = o);
    const r = R.RAPIER_PHYSICS.MODULE.ColliderDesc.cuboid(n.x, n.y, n.z);
    this.createCollider(e, r);
  }
  async addSphereCollider(e) {
    if (this._isInitialized || await this.initialize(), !e.activeAndEnabled) return;
    if (!this.enabled) {
      Qe && console.warn("Physics are disabled");
      return;
    }
    const t = R.RAPIER_PHYSICS.MODULE.ColliderDesc.ball(0.5);
    this.createCollider(e, t), this.updateProperties(e);
  }
  async addCapsuleCollider(e, t, i) {
    if (this._isInitialized || await this.initialize(), !e.activeAndEnabled) return;
    if (!this.enabled) {
      Qe && console.warn("Physics are disabled");
      return;
    }
    const n = e.gameObject, o = $e(n, this._tempPosition);
    o.x = Math.abs(o.x), o.y = Math.abs(o.y);
    const r = i * o.x;
    t = Math.max(t, r * 2);
    const a = j.clamp(t * 0.5 * o.y - i * o.x, 0, Number.MAX_SAFE_INTEGER), l = R.RAPIER_PHYSICS.MODULE.ColliderDesc.capsule(a, r);
    this.createCollider(e, l);
  }
  async addMeshCollider(e, t, i, n) {
    let o = t.geometry;
    if (!o) {
      Qe && console.warn("Missing mesh geometry", t.name);
      return;
    }
    o.index?.array?.length || (console.warn(`Your MeshCollider is missing vertices or indices in the assined mesh "${t.name}". Consider providing an indexed geometry.`), o = OS(o));
    let r = null;
    const a = o.getAttribute("position");
    if (a instanceof db) {
      const d = a.count;
      r = new Float32Array(d * 3);
      for (let f = 0; f < d; f++) {
        const p = a.getX(f), g = a.getY(f), _ = a.getZ(f);
        r[f * 3] = p, r[f * 3 + 1] = g, r[f * 3 + 2] = _;
      }
    } else
      r = a.array;
    if (await this.initialize(), !this.enabled) {
      Qe && console.warn("Physics are disabled");
      return;
    }
    if (!e.activeAndEnabled) return;
    const l = o.index?.array, c = e.gameObject.worldScale.clone();
    if (n && c.multiply(n), Math.abs(c.x - 1) > 1e-4 || Math.abs(c.y - 1) > 1e-4 || Math.abs(c.z - 1) > 1e-4) {
      const d = `${o.uuid}_${c.x}_${c.y}_${c.z}_${i}`;
      if (this._meshCache.has(d))
        Qe && console.warn("Use cached mesh collider"), r = this._meshCache.get(d);
      else {
        (Qe || L()) && console.debug(`[Performance] Your MeshCollider "${e.name}" is scaled: consider applying the scale to the collider mesh instead (${c.x}, ${c.y}, ${c.z})`);
        const f = new Float32Array(r.length);
        for (let p = 0; p < r.length; p += 3)
          f[p] = r[p] * c.x, f[p + 1] = r[p + 1] * c.y, f[p + 2] = r[p + 2] * c.z;
        r = f, this._meshCache.set(d, f);
      }
    }
    const h = i ? R.RAPIER_PHYSICS.MODULE.ColliderDesc.convexHull(r) : R.RAPIER_PHYSICS.MODULE.ColliderDesc.trimesh(r, l);
    h && this.createCollider(e, h);
  }
  updatePhysicsMaterial(e) {
    if (!e) return;
    const t = e.sharedMaterial, i = e[Ft];
    if (i && t) {
      if (t.bounciness !== void 0 && i.setRestitution(t.bounciness), t.bounceCombine !== void 0)
        switch (t.bounceCombine) {
          case wt.Average:
            i.setRestitutionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case wt.Maximum:
            i.setRestitutionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case wt.Minimum:
            i.setRestitutionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case wt.Multiply:
            i.setRestitutionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      if (t.dynamicFriction !== void 0 && i.setFriction(t.dynamicFriction), t.frictionCombine !== void 0)
        switch (t.frictionCombine) {
          case wt.Average:
            i.setFrictionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case wt.Maximum:
            i.setFrictionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case wt.Minimum:
            i.setFrictionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case wt.Multiply:
            i.setFrictionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
    }
  }
  /** Get the rapier body for a Needle component */
  getBody(e) {
    return e ? e[Ft] : null;
  }
  /** Get the Needle Engine component for a rapier object */
  getComponent(e) {
    return e ? e[Yt] : null;
  }
  createCollider(e, t) {
    if (!this.world) throw new Error("Physics world not initialized");
    const i = this._tempMatrix;
    let n;
    e.attachedRigidbody ? n = this.getRigidbody(e, this._tempMatrix) : (Qe && console.log("Create collider without rigidbody", e.name), i.makeRotationFromQuaternion(be(e.gameObject)), i.setPosition(Z(e.gameObject))), i.decompose(this._tempPosition, this._tempQuaternion, this._tempScale), this.tryApplyCenter(e, this._tempPosition), t.setTranslation(this._tempPosition.x, this._tempPosition.y, this._tempPosition.z), t.setRotation(this._tempQuaternion), t.setSensor(e.isTrigger);
    const o = e.sharedMaterial;
    if (o) {
      if (o.bounciness !== void 0 && t.setRestitution(o.bounciness), o.bounceCombine !== void 0)
        switch (o.bounceCombine) {
          case wt.Average:
            t.setRestitutionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case wt.Maximum:
            t.setRestitutionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case wt.Minimum:
            t.setRestitutionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case wt.Multiply:
            t.setRestitutionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      if (o.dynamicFriction !== void 0 && t.setFriction(o.dynamicFriction), o.frictionCombine !== void 0)
        switch (o.frictionCombine) {
          case wt.Average:
            t.setFrictionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case wt.Maximum:
            t.setFrictionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case wt.Minimum:
            t.setFrictionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case wt.Multiply:
            t.setFrictionCombineRule(R.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
    }
    e.attachedRigidbody?.autoMass === !1 && (t.setDensity(1e-6), t.setMass(1e-6));
    try {
      const r = this.world.createCollider(t, n);
      return r[Yt] = e, e[Ft] = r, r.setActiveEvents(R.RAPIER_PHYSICS.MODULE.ActiveEvents.COLLISION_EVENTS), r.setActiveCollisionTypes(R.RAPIER_PHYSICS.MODULE.ActiveCollisionTypes.ALL), this.objects.push(e), this.bodies.push(r), this.updateColliderCollisionGroups(e), r;
    } catch (r) {
      return console.error('Error creating collider "' + e.name + `"
Error:`, r), null;
    }
  }
  /**
   * Updates the collision groups of a collider.
   * 
   * @param collider - The collider to update.
   */
  updateColliderCollisionGroups(e) {
    const t = e[Ft], i = e.membership;
    let n = 0;
    if (i == null)
      n = 65535;
    else
      for (let a = 0; a < i.length; a++) {
        const l = i[a];
        l > 31 ? console.error(`Rapier only supports 32 layers, layer ${l} is not supported`) : n |= 1 << Math.floor(l);
      }
    const o = e.filter;
    let r = 0;
    if (o == null)
      r = 65535;
    else
      for (let a = 0; a < o.length; a++) {
        const l = o[a];
        l > 31 ? console.error(`Rapier only supports 32 layers, layer ${l} is not supported`) : r |= 1 << Math.floor(l);
      }
    t.setCollisionGroups(n << 16 | r);
  }
  getRigidbody(e, t) {
    if (!this.world) throw new Error("Physics world not initialized");
    let i = null;
    if (e.attachedRigidbody) {
      const n = e.attachedRigidbody;
      if (i = n[Ft], !i) {
        const o = n.isKinematic && !Jf;
        Qe && console.log("Create rigidbody", o);
        const r = o ? R.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased() : R.RAPIER_PHYSICS.MODULE.RigidBodyDesc.dynamic(), a = Z(e.attachedRigidbody.gameObject);
        r.setTranslation(a.x, a.y, a.z), r.setRotation(be(e.attachedRigidbody.gameObject)), r.centerOfMass = new R.RAPIER_PHYSICS.MODULE.Vector3(n.centerOfMass.x, n.centerOfMass.y, n.centerOfMass.z), i = this.world.createRigidBody(r), this.bodies.push(i), this.objects.push(n);
      }
      i[Yt] = n, n[Ft] = i, this.internalUpdateRigidbodyProperties(n, i), this.getRigidbodyRelativeMatrix(e.gameObject, n.gameObject, t), e[tb] = i;
    } else {
      const n = R.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased(), o = Z(e.gameObject);
      n.setTranslation(o.x, o.y, o.z), n.setRotation(be(e.gameObject)), i = this.world.createRigidBody(n), t.identity(), i[Yt] = null;
    }
    return i;
  }
  internal_getRigidbody(e) {
    return e.isCollider === !0 ? e[tb] : e[Ft];
  }
  internalUpdateColliderProperties(e, t) {
    const i = t.shape;
    let n = !1;
    switch (i.type) {
      // Sphere Collider
      case R.RAPIER_PHYSICS.MODULE.ShapeType.Ball: {
        const f = i, p = e, g = e.gameObject, _ = $e(g, this._tempPosition), m = Math.abs(p.radius * _.x);
        n = f.radius !== m, f.radius = m, n && t.setShape(f);
        break;
      }
      case R.RAPIER_PHYSICS.MODULE.ShapeType.Cuboid:
        const o = i, r = e, a = e.gameObject, l = $e(a, this._tempPosition), c = Math.abs(r.size.x * 0.5 * l.x), h = Math.abs(r.size.y * 0.5 * l.y), d = Math.abs(r.size.z * 0.5 * l.z);
        n = o.halfExtents.x !== c || o.halfExtents.y !== h || o.halfExtents.z !== d, o.halfExtents.x = c, o.halfExtents.y = h, o.halfExtents.z = d, n && t.setShape(o);
        break;
    }
    if (n) {
      const o = e.attachedRigidbody;
      o?.autoMass && this.getBody(o)?.recomputeMassPropertiesFromColliders();
    }
    this.updateColliderCollisionGroups(e), e.isTrigger !== t.isSensor() && t.setSensor(e.isTrigger);
  }
  internalUpdateRigidbodyProperties(e, t) {
    if (t.enableCcd(e.collisionDetectionMode !== Vm.Discrete), t.setLinearDamping(e.drag), t.setAngularDamping(e.angularDrag), t.setGravityScale(e.useGravity ? e.gravityScale : 0, !0), e.dominanceGroup <= 127 && e.dominanceGroup >= -127 ? t.setDominanceGroup(Math.floor(e.dominanceGroup)) : t.setDominanceGroup(0), e.autoMass) {
      t.setAdditionalMass(0, !1);
      for (let i = 0; i < t.numColliders(); i++)
        t.collider(i).setDensity(1);
      t.recomputeMassPropertiesFromColliders();
    } else {
      t.setAdditionalMass(e.mass, !1);
      for (let i = 0; i < t.numColliders(); i++)
        t.collider(i).setDensity(1e-7);
      t.recomputeMassPropertiesFromColliders();
    }
    t.setEnabledRotations(!e.lockRotationX, !e.lockRotationY, !e.lockRotationZ, !1), t.setEnabledTranslations(!e.lockPositionX, !e.lockPositionY, !e.lockPositionZ, !1), e.isKinematic ? t.setBodyType(R.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased, !1) : t.setBodyType(R.RAPIER_PHYSICS.MODULE.RigidBodyType.Dynamic, !1);
  }
  // private _lastStepTime: number | undefined = 0;
  lines;
  step(e) {
    if (this.world && this.enabled) {
      if (this._isUpdatingPhysicsWorld = !0, this.eventQueue || (this.eventQueue = new R.RAPIER_PHYSICS.MODULE.EventQueue(!1)), e === void 0 || e <= 0) {
        this._isUpdatingPhysicsWorld = !1;
        return;
      } else e !== void 0 && (this.world.timestep = j.lerp(this.world.timestep, e, 0.8));
      try {
        this.world.step(this.eventQueue);
      } catch (t) {
        console.warn("Error running physics step", t);
      }
      this._isUpdatingPhysicsWorld = !1;
    }
  }
  postStep() {
    this.world && this.enabled && (this._isUpdatingPhysicsWorld = !0, this.syncObjects(), this._isUpdatingPhysicsWorld = !1, this.eventQueue && !this.collisionHandler && (this.collisionHandler = new jA(this.world, this.eventQueue)), this.collisionHandler && (this.collisionHandler.handleCollisionEvents(), this.collisionHandler.update()), this.updateDebugRendering(this.world));
  }
  updateDebugRendering(e) {
    if (Qe || Jf || DA || this.debugRenderColliders === !0) {
      if (!this.lines) {
        const i = new hb({
          color: 7855479,
          fog: !1
          // vertexColors: VertexColors
        }), n = new Tn();
        this.lines = new cb(n, i), this.lines.layers.disableAll(), this.lines.layers.enable(2);
      }
      this.lines.parent !== this.context?.scene && this.context?.scene.add(this.lines);
      const t = e.debugRender();
      this.lines.geometry.setAttribute("position", new ht(t.vertices, 3)), this.lines.geometry.setAttribute("color", new ht(t.colors, 4)), (this.context.time.frame % 30 === 0 || this.lines.geometry.boundingSphere?.radius === 0) && this.lines.geometry.computeBoundingSphere();
    } else
      this.lines && this.context?.scene.remove(this.lines);
  }
  /** sync rendered objects with physics world (except for colliders without rigidbody) */
  syncObjects() {
    if (!Jf)
      for (let e = 0; e < this.bodies.length; e++) {
        const t = this.objects[e], i = this.bodies[e], n = t;
        if (n?.isCollider === !0 && !n.attachedRigidbody) {
          const l = i.parent();
          l ? this.syncPhysicsBody(t.gameObject, l, !0, !0) : this.syncPhysicsBody(t.gameObject, i, !0, !0);
          continue;
        }
        const o = i.translation(), r = i.rotation();
        if (Number.isNaN(o.x) || Number.isNaN(r.x)) {
          !n.__COLLIDER_NAN && L() && (console.warn("Collider has NaN values", n.name, n.gameObject, i), n.__COLLIDER_NAN = !0);
          continue;
        }
        const a = t.center;
        if (a && a.isVector3) {
          this._tempQuaternion.set(r.x, r.y, r.z, r.w);
          const l = this._tempPosition.copy(a).applyQuaternion(this._tempQuaternion), c = $e(t.gameObject);
          l.multiply(c), o.x -= l.x, o.y -= l.y, o.z -= l.z;
        }
        ua(t.gameObject, o.x, o.y, o.z), Bb(t.gameObject, r.x, r.y, r.z, r.w);
      }
  }
  syncPhysicsBody(e, t, i, n) {
    if (t instanceof R.RAPIER_PHYSICS.MODULE.RigidBody) {
      const o = Z(e, this._tempPosition), r = be(e, this._tempQuaternion);
      switch (t.bodyType()) {
        case R.RAPIER_PHYSICS.MODULE.RigidBodyType.Fixed:
        case R.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased:
        case R.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicVelocityBased:
          i && t.setNextKinematicTranslation(o), n && t.setNextKinematicRotation(r);
          break;
        default:
          i && t.setTranslation(o, !1), n && t.setRotation(r, !1);
          break;
      }
    } else if (t instanceof R.RAPIER_PHYSICS.MODULE.Collider) {
      e.matrixWorldNeedsUpdate && e.updateWorldMatrix(!0, !1), e.matrixWorld.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
      const o = this._tempPosition, r = this._tempQuaternion, a = t[Yt];
      if (this.tryApplyCenter(a, o), i) {
        const l = t.translation();
        (l.x !== o.x || l.y !== o.y || l.z !== o.z) && t.setTranslation(o);
      }
      if (n) {
        const l = t.rotation();
        (l.x !== r.x || l.y !== r.y || l.z !== r.z || l.w !== r.w) && t.setRotation(r);
      }
    }
  }
  _tempCenterPos = new b();
  _tempCenterVec = new b();
  _tempCenterQuaternion = new $();
  tryApplyCenter(e, t) {
    const i = e.center;
    i && e.gameObject && (i.x !== 0 || i.y !== 0 || i.z !== 0) && (this._tempCenterPos.x = i.x, this._tempCenterPos.y = i.y, this._tempCenterPos.z = i.z, $e(e.gameObject, this._tempCenterVec), this._tempCenterPos.multiply(this._tempCenterVec), e.attachedRigidbody ? this._tempCenterPos.applyQuaternion(e.gameObject.quaternion) : (be(e.gameObject, this._tempCenterQuaternion), this._tempCenterPos.applyQuaternion(this._tempCenterQuaternion)), t.x += this._tempCenterPos.x, t.y += this._tempCenterPos.y, t.z += this._tempCenterPos.z);
  }
  static _matricesBuffer = [];
  getRigidbodyRelativeMatrix(e, t, i, n) {
    if (n === void 0 && (n = Kl._matricesBuffer, n.length = 0), e === t) {
      const o = $e(e, this._tempPosition);
      i.makeScale(o.x, o.y, o.z);
      for (let r = n.length - 1; r >= 0; r--)
        i.multiply(n[r]);
      return i;
    }
    return n.push(e.matrix), e.parent && this.getRigidbodyRelativeMatrix(e.parent, t, i, n), i;
  }
  static centerConnectionPos = { x: 0, y: 0, z: 0 };
  static centerConnectionRot = { x: 0, y: 0, z: 0, w: 1 };
  addFixedJoint(e, t) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const i = e[Ft], n = t[Ft];
    this.calculateJointRelativeMatrices(e.gameObject, t.gameObject, this._tempMatrix), this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const o = R.RAPIER_PHYSICS.MODULE.JointData.fixed(
      Kl.centerConnectionPos,
      Kl.centerConnectionRot,
      this._tempPosition,
      this._tempQuaternion
    ), r = this.world.createImpulseJoint(o, i, n, !0);
    Qe && console.log("ADD FIXED JOINT", r);
  }
  /** The joint prevents any relative movement between two rigid-bodies, except for relative rotations along one axis. This is typically used to simulate wheels, fans, etc. They are characterized by one local anchor as well as one local axis on each rigid-body. */
  addHingeJoint(e, t, i, n) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const o = e[Ft], r = t[Ft];
    this.calculateJointRelativeMatrices(e.gameObject, t.gameObject, this._tempMatrix), this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const a = R.RAPIER_PHYSICS.MODULE.JointData.revolute(i, this._tempPosition, n), l = this.world.createImpulseJoint(a, o, r, !0);
    Qe && console.log("ADD HINGE JOINT", l);
  }
  calculateJointRelativeMatrices(e, t, i) {
    e.updateWorldMatrix(!0, !1), t.updateWorldMatrix(!0, !1);
    const n = e.matrixWorld, o = t.matrixWorld;
    n.elements[0] = 1, n.elements[5] = 1, n.elements[10] = 1, o.elements[0] = 1, o.elements[5] = 1, o.elements[10] = 1, i.copy(o).premultiply(n.invert()).invert();
  }
}
class jA {
  world;
  eventQueue;
  constructor(e, t) {
    this.world = e, this.eventQueue = t;
  }
  activeCollisions = [];
  activeCollisionsStay = [];
  activeTriggers = [];
  handleCollisionEvents() {
    this.eventQueue && this.world && this.eventQueue.drainCollisionEvents((e, t, i) => {
      const n = this.world.getCollider(e), o = this.world.getCollider(t);
      if (!n || !o) return;
      const r = n[Yt], a = o[Yt];
      ep && console.log("EVT", r.name, a.name, i, n, o), r && a && (i ? (this.onCollisionStarted(r, n, a, o), this.onCollisionStarted(a, o, r, n)) : (this.onCollisionEnded(r, a), this.onCollisionEnded(a, r)));
    });
  }
  update() {
    this.onHandleCollisionStay();
  }
  onCollisionStarted(e, t, i, n) {
    let o = null;
    if (e.isTrigger || i.isTrigger)
      ba(e.gameObject, (r) => {
        r.onTriggerEnter && !r.destroyed && r.onTriggerEnter(i), this.activeTriggers.push({ collider: e, component: r, otherCollider: i });
      });
    else {
      const r = e.gameObject;
      this.world.contactPair(t, n, (a, l) => {
        ba(r, (c) => {
          if (c.destroyed) return;
          const h = c.onCollisionEnter || c.onCollisionStay || c.onCollisionExit;
          if (h || ep) {
            if (!o) {
              const d = [], f = a.normal();
              i instanceof br && i.convex && (f.x = -f.x, f.y = -f.y, f.z = -f.z);
              for (let p = 0; p < a.numSolverContacts(); p++) {
                const g = a.solverContactPoint(p), _ = a.contactImpulse(p);
                if (g) {
                  const m = a.contactDist(p), v = a.solverContactFriction(p), y = a.solverContactTangentVelocity(p), x = new _k(g, m, f, _, v, y);
                  d.push(x), ep && F.DrawDirection(g, f, 16711680, 3, !0);
                }
              }
              o = new bk(r, i, d);
            }
            if (h) {
              const d = { collider: e, component: c, collision: o };
              this.activeCollisions.push(d), c.onCollisionStay && this.activeCollisionsStay.push(d), c.onCollisionEnter?.call(c, o);
            }
          }
        });
      });
    }
  }
  onHandleCollisionStay() {
    for (const e of this.activeCollisionsStay) {
      const t = e.component;
      if (!t.destroyed && t.activeAndEnabled && t.onCollisionStay) {
        if (e.collision.collider.destroyed) continue;
        const i = e.collision;
        t.onCollisionStay(i);
      }
    }
    for (const e of this.activeTriggers) {
      const t = e.component;
      if (!t.destroyed && t.activeAndEnabled && t.onTriggerStay) {
        const i = e.otherCollider;
        if (i.destroyed) continue;
        t.onTriggerStay(i);
      }
    }
  }
  onCollisionEnded(e, t) {
    if (!(e.destroyed || t.destroyed)) {
      for (let i = 0; i < this.activeCollisions.length; i++) {
        const n = this.activeCollisions[i], o = n.collider;
        if (o.destroyed || n.collision.collider.destroyed) {
          this.activeCollisions.splice(i, 1), i--;
          continue;
        }
        if (o === e && n.collision.collider === t) {
          const r = n.component;
          if (this.activeCollisions.splice(i, 1), i--, r.activeAndEnabled && r.onCollisionExit) {
            const a = n.collision;
            r.onCollisionExit(a);
          }
        }
      }
      for (let i = 0; i < this.activeCollisionsStay.length; i++) {
        const n = this.activeCollisionsStay[i], o = n.collider;
        if (o.destroyed || n.collision.collider.destroyed) {
          this.activeCollisionsStay.splice(i, 1), i--;
          continue;
        }
        if (o === e && n.collision.collider === t) {
          const r = n.component;
          if (this.activeCollisionsStay.splice(i, 1), i--, r.activeAndEnabled && r.onCollisionExit) {
            const a = n.collision;
            r.onCollisionExit(a);
          }
        }
      }
      for (let i = 0; i < this.activeTriggers.length; i++) {
        const n = this.activeTriggers[i], o = n.collider;
        if (o.destroyed || n.otherCollider.destroyed) {
          this.activeTriggers.splice(i, 1), i--;
          continue;
        }
        if (o === e && n.otherCollider === t) {
          const r = n.component;
          if (this.activeTriggers.splice(i, 1), i--, r.activeAndEnabled && r.onTriggerExit) {
            const a = n.otherCollider;
            r.onTriggerExit(a);
          }
        }
      }
    }
  }
}
class pL {
  /**
   * Use this method to quickly setup a scene to compare multiple models.  
   * @example
   * ```ts
   * const files = [
   *    "https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb",
   *   "https://threejs.org/examples/models/gltf/Lantern/glTF-Binary/Lantern.glb",
   * ];
   * const { scene, camera } = await TestUtils.createComparisonScene({ files });
   * // this could now be assigned to the Needle Engine Context
   * context.scene = scene;
   * context.mainCamera = camera;
   * ```
   */
  static async createComparisonScene(e) {
    const { files: t } = e, n = await Promise.all(t.map((m) => new ie(m).loadAssetAsync())), o = new gi();
    let r = 0;
    for (const m of n)
      if (m instanceof M) {
        m.position.y = r, o.add(m);
        const v = _i([m]);
        r += v.getSize(new b()).y, r += 0.1;
      }
    const a = new pe(20);
    o.add(a);
    const l = e.environment || "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/studio_small_09_1k.exr";
    {
      let m = null;
      if (l.endsWith(".hdr")) {
        const v = (await import("./three-examples-CNexix3E.js").then((y) => y.RGBELoader$1)).RGBELoader;
        m = new v();
      } else if (l.endsWith(".exr")) {
        const v = (await import("./three-examples-CNexix3E.js").then((y) => y.EXRLoader$1)).EXRLoader;
        m = new v();
      }
      if (m) {
        const v = await m.loadAsync(l).catch((y) => (console.error(y), null));
        v && (v.mapping = _s, v.needsUpdate = !0, o.background = v, o.environment = v, o.backgroundBlurriness = 0.75);
      } else console.warn("Unsupported environment map format", l);
    }
    const c = _i(o.children), h = c.getCenter(new b()), d = c.getSize(new b()), p = Math.max(d.x, d.y, d.z) / (2 * Math.tan(Math.PI * a.fov / 360));
    a.position.set(h.x, h.y, p), a.lookAt(h);
    const g = new vb(a, e.domElement || document.body);
    g.target = h, g.update();
    const _ = (e.domElement || document.body).getBoundingClientRect();
    return a.aspect = _.width / _.height, a.updateProjectionMatrix(), {
      scene: o,
      camera: a
    };
  }
}
let rm = 0;
function ib(s) {
  s ? rm++ : rm--;
}
function mL() {
  return rm > 0;
}
const BA = {
  binary: !0,
  animations: !0
};
async function gL(s) {
  if (!s.context)
    throw new Error("No context provided to exportAsGLTF");
  s.scene || (s.scene = s.context.scene);
  const e = {
    ...BA,
    ...s
  }, { context: t } = e, i = new wb();
  i.register((a) => new pv(a)), i.register((a) => new tM(a)), i.register((a) => new lv(a)), fv(i, e.context);
  const n = {
    binary: e.binary,
    animations: zA(t, e.scene, [])
  }, o = new FA();
  console.debug("Exporting GLTF", n), o.onBeforeExport(e), ib(!0);
  const r = await i.parseAsync(e.scene, n).catch((a) => (console.error(a), null));
  if (ib(!1), o.onAfterExport(e), !r)
    throw new Error("Failed to export GLTF");
  if (e.downloadAs != null) {
    let a = null;
    if (r instanceof ArrayBuffer ? a = new Blob([r], { type: "application/octet-stream" }) : console.error("Can not download GLTF as a blob", r), a) {
      const l = URL.createObjectURL(a), c = document.createElement("a");
      c.href = l;
      let h = e.downloadAs;
      !h.endsWith(".glb") && !h.endsWith(".gltf") && (h += e.binary ? ".glb" : ".gltf"), c.download = h, c.click();
    }
  }
  return r;
}
const nb = Symbol("needle:weight");
class FA {
  _undo = [];
  onBeforeExport(e) {
    e.context.animations.mixers.forEach((t) => {
      const i = rc.tryGetActionsFromMixer(t);
      if (i)
        for (let n = 0; n < i.length; n++) {
          const o = i[n];
          o[nb] = o.weight, o.weight = 0, this._undo.push(() => {
            o.weight = o[nb];
          });
        }
      t.update(0);
    }), e.context.scene.traverse((t) => {
      if (!jp(t)) {
        const i = t.parent;
        i && (t.removeFromParent(), this._undo.push(() => i.add(t)));
      }
    });
  }
  onAfterExport(e) {
    this._undo.forEach((t) => t()), this._undo.length = 0;
  }
}
function zA(s, e, t) {
  s.animations.mixers.forEach((n) => {
    const o = rc.tryGetActionsFromMixer(n);
    if (o)
      for (let r = 0; r < o.length; r++) {
        const l = o[r].getClip();
        t.push(l);
      }
  }), Array.isArray(e) || (e = [e]);
  for (const n of e)
    rc.tryGetAnimationClipsFromObjectHierarchy(n, t);
  const i = new Set(t);
  return Array.from(i);
}
const sb = "needle-button", tp = L();
class UA extends HTMLElement {
  static observedAttributes = ["ar", "vr", "quicklook"];
  constructor() {
    super(), this.removeEventListener("click", this.#r), this.addEventListener("click", this.#r);
  }
  attributeChangedCallback(e, t, i) {
    this.#a();
  }
  #t;
  #n;
  /** These are the default styles that can be overridden by the user from the outside by styling <needle-button> */
  #s;
  /** This is the button that was generated using one of the factories */
  #e;
  /** If AR or VR is requested we create and use the webxr button factory to create a button with default behaviour */
  #i;
  #o;
  #a() {
    if (this.#e?.remove(), this.getAttribute("ar") != null)
      this.#i ??= new ir(), this.#e = this.#i.createARButton();
    else if (this.getAttribute("vr") != null)
      this.#i ??= new ir(), this.#e = this.#i.createVRButton();
    else if (this.getAttribute("quicklook") != null)
      this.#i ??= new ir(), this.#e = this.#i.createQuicklookButton();
    else {
      tp ? console.warn("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.") : console.debug("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.");
      return;
    }
    this.#t ??= this.attachShadow({ mode: "open" }), this.#n ??= document.createElement("slot"), this.#s ??= document.createElement("style"), this.#s.innerHTML = `
            button {
                all: initial;
                cursor: inherit;
                color: inherit;
                font-family: inherit;
                gap: inherit;
                white-space: nowrap;
            }
        `, this.getAttribute("unstyled") != null || (this.#s.innerHTML += `
            :host {
                display: inline-block;
                background: rgba(255, 255, 255, .8);
                backdrop-filter: blur(10px);
                width: fit-content;
                transition: background .2s;

                cursor: pointer;
                padding: 0.4rem .5rem;
                border-radius: 0.8rem;
                color: black;
                background: rgba(245, 245, 245, .8);
                outline: rgba(0,0,0,.05) 1px solid;
            }
            :host(:hover) {
                background: rgba(255, 255, 255, 1);
                transition: background .2s;
            }
            slot {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: .5rem;
            }
`), this.#n.innerHTML = this.#e.innerHTML, this.#n.style.cssText = "display: flex; align-items: center; justify-content: center;", this.#e.innerHTML = this.#n.outerHTML, this.#t.innerHTML = this.#e.outerHTML, this.#t.prepend(this.#s), cd(Rp, { element: this.#t }), this.#o?.disconnect(), this.#o ??= new MutationObserver(() => this.#l()), this.#o.observe(this.#e, { attributes: !0 }), tp && console.log("Needle Button updated");
  }
  #l() {
    this.#e && (this.#e.style.display === "none" ? this.style.display = "none" : this.style.display === "none" && (this.style.display = ""));
  }
  #r = (e) => {
    tp && console.log("Needle Button clicked"), !e.defaultPrevented && this.#e && this.#e.click();
  };
}
typeof window < "u" && !window.customElements.get(sb) && window.customElements.define(sb, UA);
const _l = w("debugavatar");
class Nw {
  /** The root object of the avatar model */
  root;
  /** The head object of the avatar model */
  head;
  /** The left hand object of the avatar model, if available */
  leftHand;
  /** The right hand object of the avatar model, if available */
  rigthHand;
  /**
   * Checks if the avatar model has a valid configuration.
   * An avatar is considered valid if it has a head.
   * @returns Whether the avatar has a valid setup
   */
  get isValid() {
    return this.head !== null && this.head !== void 0;
  }
  /**
   * Creates a new avatar model.
   * @param root The root object of the avatar
   * @param head The head object of the avatar
   * @param leftHand The left hand object of the avatar
   * @param rigthHand The right hand object of the avatar
   */
  constructor(e, t, i, n) {
    this.root = e, this.head = t, this.leftHand = i, this.rigthHand = n, this.root?.traverse((o) => o.layers.set(2));
  }
}
class NA {
  avatarRegistryUrl = null;
  // private loader: GLTFLoader | null;
  // private avatarModelCache: Map<string, AvatarModel | null> = new Map<string, AvatarModel | null>();
  /**
   * Retrieves or creates a new avatar instance from an ID or existing Object3D.
   * @param context The application context
   * @param avatarId Either a string ID to load an avatar or an existing Object3D to use as avatar
   * @returns Promise resolving to an AvatarModel if successful, or null if failed
   */
  async getOrCreateNewAvatarInstance(e, t) {
    if (!t)
      return console.error("Can not create avatar: failed to provide id or root object"), null;
    let i = null;
    if (typeof t == "string") {
      if (i = await this.loadAvatar(e, t), !i) {
        const o = new Nn();
        i = S.instantiate(ec(t, e.scene), o);
      }
    } else i = t;
    if (!i)
      return null;
    const n = this.findAvatar(i);
    return n.isValid ? (_l && console.log("[Custom Avatar] valid config", t, _l ? n : ""), n) : (console.warn("[Custom Avatar] config isn't valid", t, _l ? n : ""), null);
  }
  /**
   * Loads an avatar model from a file or registry using the provided ID.
   * @param context The engine context
   * @param avatarId The ID of the avatar to load
   * @returns Promise resolving to the loaded avatar's Object3D, or null if failed
   */
  async loadAvatar(e, t) {
    if (console.assert(t != null && typeof t == "string", "Avatar id must not be null"), t.length <= 0 || !t) return null;
    if (_l && console.log("[Custom Avatar] " + t + ", loading..."), t.endsWith(".glb") || (t += ".glb"), this.avatarRegistryUrl === null) {
      const n = await fetch("./" + t);
      let o = null;
      if (n.ok) {
        const a = await n.blob();
        a && (o = await a.arrayBuffer());
      }
      return o ? (await jn().parseSync(e, o, null, 0))?.scene ?? null : null;
    }
    const i = new Ps();
    return $m(i, e), new Promise((n, o) => {
      const r = this.avatarRegistryUrl + "/" + t;
      i.load(
        r,
        async (a) => {
          await jn().createBuiltinComponents(e, r, a, null, void 0), n(a.scene);
        },
        (a) => {
          _l && console.log("[Custom Avatar] " + a.loaded / a.total * 100 + "% loaded of " + a.total / 1024 + "kB");
        },
        (a) => {
          console.error("[Custom Avatar] Error when loading: " + a), n(null);
        }
      );
    });
  }
  /**
   * Caches an avatar model for reuse.
   * @param _id The ID to associate with the model
   * @param _model The avatar model to cache
   */
  cacheModel(e, t) {
  }
  /**
   * Analyzes an Object3D to find avatar parts (head, hands) based on naming conventions.
   * @param obj The Object3D to search for avatar parts
   * @returns A structured AvatarModel with references to found parts
   */
  findAvatar(e) {
    const t = e;
    let i = t;
    i.children.length == 1 && (i = e.children[0]);
    let n = this.findAvatarPart(i, ["head"]);
    const o = this.findAvatarPart(i, ["left", "hand"]), r = this.findAvatarPart(i, ["right", "hand"]);
    if (!n) {
      n = t;
      const l = new b();
      new pi().setFromObject(n).getSize(l);
      const c = Math.max(l.x, l.y, l.z);
      console.warn("[Custom Avatar] Normalizing head scale, it's too big: " + c + " meters! Should be < 0.3m"), c > 0.3 && n.scale.multiplyScalar(1 / c * 0.3);
    }
    return new Nw(t, n, o, r);
  }
  /**
   * Recursively searches for an avatar part by name within an Object3D hierarchy.
   * @param obj The Object3D to search within
   * @param searchString Array of strings that should all be present in the object name
   * @returns The found Object3D part or null if not found
   */
  findAvatarPart(e, t) {
    const i = e.name.toLowerCase();
    let n = !0;
    for (const o of t) {
      if (!n) break;
      i.indexOf(o) === -1 && (n = !1);
    }
    if (n) return e;
    if (e.children)
      for (const o of e.children) {
        const r = this.findAvatarPart(o, t);
        if (r) return r;
      }
    return null;
  }
  /**
   * Handles HTTP response errors from avatar loading operations.
   * @param response The fetch API response to check
   * @returns The response if it was ok
   * @throws Error with status text if response was not ok
   */
  handleCustomAvatarErrors(e) {
    if (!e.ok)
      throw Error(e.statusText);
    return e;
  }
}
class $A {
  get extensionName() {
    return "DocumentExtension";
  }
  onAfterBuildDocument(e) {
  }
}
class WA {
}
const yL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionBuilder: fe,
  ActionCollection: ZM,
  ActionModel: ai,
  AlignmentConstraint: Zd,
  Animation: bi,
  AnimationCurve: Su,
  AnimationExtension: lg,
  AnimationTrackHandler: Bg,
  Animator: At,
  AnimatorController: on,
  Antialiasing: Cu,
  AudioExtension: La,
  AudioListener: Js,
  AudioSource: ln,
  AudioTrackHandler: to,
  Avatar: lr,
  AvatarBlink_Simple: Ta,
  AvatarEyeLook_Rotation: K0,
  AvatarLoader: NA,
  AvatarMarker: je,
  AvatarModel: Nw,
  Avatar_Brain_LookAt: pd,
  Avatar_MouthShapes: iu,
  Avatar_MustacheShake: q0,
  Avatar_POI: oa,
  AxesHelper: vc,
  BaseUIComponent: hn,
  BasicIKConstraint: Z0,
  BehaviorExtension: Bv,
  BehaviorModel: Et,
  BloomEffect: Rg,
  BoxCollider: Jm,
  BoxGizmo: Ua,
  BoxHelperComponent: Ct,
  Button: ko,
  CallInfo: Qs,
  Camera: ui,
  CameraTargetReachedEvent: fd,
  Canvas: hc,
  CanvasGroup: cr,
  CapsuleCollider: ho,
  ChangeMaterialOnClick: Tv,
  ChangeTransformOnClick: Da,
  CharacterController: Ea,
  CharacterControllerInput: mo,
  ChromaticAberration: Ou,
  Collider: wi,
  ColorAdjustments: Sr,
  ColorBySpeedModule: Ic,
  ColorOverLifetimeModule: Pg,
  ContactShadows: ou,
  ControlTrackHandler: Fg,
  CustomBranding: za,
  Deletable: iv,
  DeleteBox: er,
  DepthOfField: Gn,
  DeviceFlag: eg,
  DocumentExtension: $A,
  DragControls: Gr,
  DropListener: yo,
  Duplicatable: rv,
  EffectWrapper: xd,
  EmissionModule: So,
  EmphasizeOnClick: Cc,
  EnvironmentScene: $g,
  EventList: me,
  EventListEvent: Hm,
  EventSystem: Jt,
  EventTrigger: sg,
  FieldWithDefault: xM,
  FixedJoint: Yv,
  Fog: Mc,
  GltfExport: bv,
  GltfExportBox: _v,
  Gradient: $a,
  Graphic: yu,
  GraphicRaycaster: Gm,
  GridHelper: Rc,
  GridLayoutGroup: Gv,
  GroundProjectedEnv: Ms,
  GroupActionModel: Xr,
  HideOnStart: tn,
  HingeJoint: bu,
  HorizontalLayoutGroup: Hv,
  Image: Uc,
  InheritVelocityModule: tw,
  InputField: Pw,
  InstanceHandle: ra,
  InstancingHandler: Pa,
  Interactable: tv,
  Keyframe: fi,
  LODGroup: vu,
  LODModel: Ec,
  Light: Yi,
  LimitVelocityOverLifetimeModule: yt,
  LogStats: ev,
  LookAt: Mw,
  LookAtConstraint: Ra,
  MainModule: qt,
  MaskableGraphic: _u,
  MeshCollider: br,
  MeshRenderer: lu,
  MinMaxCurve: Y,
  MinMaxGradient: Wa,
  NeedleMenu: Es,
  NestedGltf: Sg,
  Networking: Kv,
  NoiseModule: ve,
  ObjectRaycaster: Vi,
  OffsetConstraint: Na,
  OpenURL: Wc,
  OrbitControls: ye,
  Outline: kc,
  Padding: Fa,
  ParticleBurst: Xp,
  ParticleSubEmitter: iw,
  ParticleSystem: wd,
  ParticleSystemRenderer: fn,
  PhysicsExtension: Fv,
  PixelationEffect: Mu,
  PlayAnimationOnClick: _d,
  PlayAudioOnClick: rr,
  PlayableDirector: fc,
  PlayerColor: uc,
  PointerEventData: eu,
  PostProcessingHandler: cw,
  PreliminaryAction: Pc,
  PreliminaryTrigger: du,
  RawImage: Ng,
  Rect: PR,
  RectTransform: zn,
  ReflectionProbe: yd,
  RegisteredAnimationInfo: qo,
  RemoteSkybox: Ag,
  Renderer: Hi,
  RendererLightmap: zp,
  Rigidbody: ft,
  RotationBySpeedModule: un,
  RotationOverLifetimeModule: Hn,
  SceneSwitcher: Ze,
  ScreenCapture: Or,
  ScreenSpaceAmbientOcclusion: Co,
  ScreenSpaceAmbientOcclusionN8: qn,
  SetActiveOnClick: Ev,
  ShadowCatcher: Tu,
  ShapeModule: Jv,
  SharpeningEffect: Ru,
  SignalAsset: jg,
  SignalReceiver: Lu,
  SignalReceiverEvent: Iu,
  SignalTrackHandler: Pd,
  Size: CR,
  SizeBySpeedModule: Ci,
  SizeOverLifetimeModule: Va,
  SkinnedMeshRenderer: gv,
  SmoothFollow: Ig,
  SpatialGrabRaycaster: Ca,
  SpatialHtml: zu,
  SpatialTrigger: Lg,
  SpatialTriggerReceiver: xs,
  SpectatorCamera: Dg,
  SphereCollider: wc,
  Sprite: _o,
  SpriteData: Hl,
  SpriteRenderer: xi,
  SpriteSheet: cc,
  SubEmitterSystem: Kp,
  SyncedCamera: bw,
  SyncedRoom: Xn,
  SyncedTransform: Fn,
  TapGestureTrigger: Av,
  TeleportTarget: fg,
  TestRunner: vw,
  TestSimulateUserData: ww,
  Text: Gt,
  TextBuilder: Wv,
  TextExtension: gg,
  TextureSheetAnimationModule: Xt,
  TiltShiftEffect: Ls,
  ToneMappingEffect: hr,
  TrailModule: Ne,
  TransformData: Ue,
  TransformGizmo: qa,
  TriggerBuilder: Vt,
  TriggerModel: tr,
  UIRaycastUtils: V0,
  UIRootComponent: gu,
  USDZExporter: ws,
  USDZText: Ml,
  USDZUIExtension: Qv,
  UsageMarker: ru,
  VariantAction: Rv,
  VelocityOverLifetimeModule: Ve,
  VerticalLayoutGroup: Vv,
  VideoPlayer: pt,
  Vignette: Ga,
  VisibilityAction: uu,
  Voip: _r,
  Volume: Dc,
  VolumeParameter: B,
  VolumeProfile: kg,
  WebARCameraBackground: Nu,
  WebARSessionRoot: Ni,
  WebXR: pg,
  WebXRImageTracking: $u,
  WebXRImageTrackingModel: To,
  WebXRPlaneTracking: Eo,
  WebXRTrackedImage: pc,
  XRControllerFollow: Mo,
  XRControllerModel: uo,
  XRControllerMovement: Gi,
  XRFlag: nn,
  XRRig: Vg,
  XRState: Zt,
  __Ignore: WA
}, Symbol.toStringTag, { value: "Module" })), Rd = w("debugmissingcamera");
he.registerCallback(ce.MissingCamera, (s) => {
  Rd && console.warn("Creating missing camera");
  const e = s.context.scene, t = new pe();
  t.name = "Default Fallback Camera", e.add(t);
  const i = new ui();
  if (i.sourceId = s.files?.[0]?.src ?? "unknown", i.fieldOfView = 35, s.context.domElement.getAttribute("transparent") != null)
    i.clearFlags = sa.Uninitialized;
  else if (s.context.domElement.getAttribute("background-image")?.length || s.context.lightmaps.tryGetSkybox(i.sourceId))
    i.clearFlags = sa.Skybox;
  else {
    if (i.clearFlags = sa.SolidColor, !s.context.domElement.getAttribute("background-color")) {
      let a = "#efefef";
      typeof window !== void 0 && window.matchMedia("(prefers-color-scheme: dark)").matches && (a = "#1f1f1f"), e.background = new se(a);
    }
    if (!e.environment) {
      const a = new nS(s.context.renderer), l = new $g("neutral");
      e.environment = a.fromScene(l, 0.025).texture;
    }
  }
  const o = ta(t, i, !0);
  return t.position.x = 0, t.position.y = 1, t.position.z = 2, s.context.domElement?.cameraControls != !1 && $w(s.context, o), o;
});
he.registerCallback(ce.ContextCreated, (s) => {
  if (!s.context.mainCamera) {
    Rd && console.log("Will not auto-fit because a default camera exists");
    return;
  }
  if (s.context.domElement?.cameraControls == !0) {
    if (vC(s.context.mainCamera)?.isCameraController == !0) {
      Rd && console.log("Will not auto-fit because a camera controller exists");
      return;
    }
    $w(s.context);
  }
});
function $w(s, e) {
  e = e ?? s.mainCameraComponent;
  const t = e?.gameObject;
  if (Rd && console.log("Creating default camera controls", e?.name), t) {
    const i = Gd(t, ye);
    i.sourceId = e?.sourceId ?? "unknown";
    const n = s.domElement.getAttribute("auto-rotate");
    if (i.autoRotate = n != null && n != "0" && n?.toLowerCase() != "false", i.autoRotateSpeed = 0.5, i.autoFit = !0, i.autoRotate && n) {
      const o = parseFloat(n);
      isNaN(o) || (i.autoRotateSpeed = o);
    }
  } else
    console.warn("Missing camera object, can not add orbit controls");
}
he.registerCallback(ce.ContextCreated, (s) => {
  const e = s.context.domElement.getAttribute("autoplay");
  if (e !== void 0 && (e === "" || e === "true" || e === "1") && s.files)
    for (const t of s.files)
      S.foreachComponent(t.file.scene, (n) => {
        if (n.enabled !== !1) {
          if (n instanceof bi && n.playAutomatically || n instanceof At || n instanceof fc && n.playOnAwake === !0)
            return !0;
          if (n instanceof bi)
            return n.playAutomatically = !0, !0;
          if (n instanceof fc)
            return n.playOnAwake = !0, !0;
        }
      }, !0) !== !0 && rc.autoplayAnimations(t.file);
});
class VA extends jS {
  constructor() {
    super(new Worker(URL.createObjectURL(new Blob(["import '" + `${new URL('./generateMeshBVH.worker-2qGLkQjg.js', import.meta.url).toString()}` + "';"], { type: 'text/javascript' })), { type: "module" })), this.name = "GenerateMeshBVHWorker";
  }
  runTask(e, t, i = {}) {
    return new Promise((n, o) => {
      if (t.getAttribute("position").isInterleavedBufferAttribute || t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.");
      e.onerror = (c) => {
        o(new Error(`[GenerateMeshBVHWorker] ${c.message || "Unknown error. Please check the server console. If you're using vite try adding 'three-mesh-bvh' to 'optimizeDeps.exclude' in your vite.config.js"}`));
      }, e.onmessage = (c) => {
        const { data: h } = c;
        if (h.error)
          o(new Error(h.error)), e.onmessage = null;
        else if (h.serialized) {
          const { serialized: d, position: f } = h, p = BS.deserialize(d, t, { setIndex: !1 }), g = Object.assign({
            setBoundingBox: !0
          }, i);
          if (t.attributes.position.array = f, d.index)
            if (t.index)
              t.index.array = d.index;
            else {
              const _ = new ht(d.index, 1, !1);
              t.setIndex(_);
            }
          g.setBoundingBox && (t.boundingBox = p.getBoundingBox(new pi())), i.onProgress && i.onProgress(h.progress), n(p), e.onmessage = null;
        } else i.onProgress && i.onProgress(h.progress);
      };
      const r = t.index ? t.index.array : null, a = t.attributes.position.array, l = [a];
      r && l.push(r), e.postMessage({
        index: r,
        position: a,
        options: {
          ...i,
          onProgress: null,
          includedProgressCallback: !!i.onProgress,
          groups: [...t.groups]
        }
      }, l.map((c) => c.buffer).filter((c) => typeof SharedArrayBuffer > "u" || !(c instanceof SharedArrayBuffer)));
    });
  }
}
const HA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GenerateMeshBVHWorker: VA
}, Symbol.toStringTag, { value: "Module" }));
export {
  iL as $physicsKey,
  fe as ActionBuilder,
  ZM as ActionCollection,
  ai as ActionModel,
  BP as Addressables,
  Zd as AlignmentConstraint,
  Ul as AmbientMode,
  bi as Animation,
  Su as AnimationCurve,
  lg as AnimationExtension,
  Bg as AnimationTrackHandler,
  rc as AnimationUtils,
  At as Animator,
  Uo as AnimatorConditionMode,
  on as AnimatorController,
  N0 as AnimatorControllerParameterType,
  sh as AnimatorStateInfo,
  Cu as Antialiasing,
  Bn as Application,
  z1 as AssetDatabase,
  ie as AssetReference,
  La as AudioExtension,
  Js as AudioListener,
  ln as AudioSource,
  to as AudioTrackHandler,
  lr as Avatar,
  Ta as AvatarBlink_Simple,
  K0 as AvatarEyeLook_Rotation,
  NA as AvatarLoader,
  je as AvatarMarker,
  Nw as AvatarModel,
  pd as Avatar_Brain_LookAt,
  iu as Avatar_MouthShapes,
  q0 as Avatar_MustacheShake,
  oa as Avatar_POI,
  xl as Axes,
  vc as AxesHelper,
  Gb as BUILD_TIME,
  hn as BaseUIComponent,
  Z0 as BasicIKConstraint,
  Bv as BehaviorExtension,
  Et as BehaviorModel,
  wa as BlobStorage,
  Rg as BloomEffect,
  Jm as BoxCollider,
  Ua as BoxGizmo,
  Ct as BoxHelperComponent,
  ko as Button,
  On as ButtonsFactory,
  Sk as CallDirection,
  Qs as CallInfo,
  ui as Camera,
  fd as CameraTargetReachedEvent,
  hc as Canvas,
  cr as CanvasGroup,
  ho as CapsuleCollider,
  Tv as ChangeMaterialOnClick,
  Da as ChangeTransformOnClick,
  Ea as CharacterController,
  mo as CharacterControllerInput,
  Ou as ChromaticAberration,
  $i as CircularBuffer,
  sa as ClearFlags,
  rs as ClipExtrapolation,
  wi as Collider,
  bk as Collision,
  Vm as CollisionDetectionMode,
  Sr as ColorAdjustments,
  Ic as ColorBySpeedModule,
  Pg as ColorOverLifetimeModule,
  XI as Component,
  T as Component$1,
  Em as ComponentLifecycleEvents,
  yL as Components,
  v1 as ConnectionEvents,
  _k as ContactPoint,
  ou as ContactShadows,
  N as Context,
  NI as ContextArgs,
  ce as ContextEvent,
  he as ContextRegistry,
  Fg as ControlTrackHandler,
  za as CustomBranding,
  Me as CustomShader,
  kp as DefaultReflectionMode,
  iv as Deletable,
  er as DeleteBox,
  Gn as DepthOfField,
  eg as DeviceFlag,
  X as DeviceUtilities,
  $A as DocumentExtension,
  Gr as DragControls,
  nv as DragMode,
  yo as DropListener,
  rv as Duplicatable,
  xd as EffectWrapper,
  So as EmissionModule,
  Cc as EmphasizeOnClick,
  Md as EngineLoadingView,
  $g as EnvironmentScene,
  me as EventList,
  Hm as EventListEvent,
  Jt as EventSystem,
  sg as EventTrigger,
  xM as FieldWithDefault,
  na as FileReference,
  NP as FileReferenceSerializer,
  nL as FileSpawnModel,
  Hk as File_Event,
  Yv as FixedJoint,
  Mc as Fog,
  xe as FrameEvent,
  Sm as GENERATOR,
  S as GameObject,
  F as Gizmos,
  bv as GltfExport,
  _v as GltfExportBox,
  $a as Gradient,
  yu as Graphic,
  Gm as GraphicRaycaster,
  sr as Graphics,
  Rc as GridHelper,
  Gv as GridLayoutGroup,
  Ms as GroundProjectedEnv,
  Xr as GroupActionModel,
  Xm as HideFlags,
  tn as HideOnStart,
  bu as HingeJoint,
  Hv as HorizontalLayoutGroup,
  jI as HostData,
  Uc as Image,
  ia as ImageReference,
  UP as ImageReferenceSerializer,
  tw as InheritVelocityModule,
  a1 as Input,
  li as InputEventQueue,
  De as InputEvents,
  Pw as InputField,
  ra as InstanceHandle,
  Pa as InstancingHandler,
  sn as InstancingUtil,
  K1 as InstantiateEvent,
  Tt as InstantiateIdProvider,
  Nn as InstantiateOptions,
  tv as Interactable,
  Od as InternalScreenshotUtils,
  TI as JoinedRoomResponse,
  kI as KeyEventArgs,
  fi as Keyframe,
  vu as LODGroup,
  Ec as LODModel,
  EI as LeftRoomResponse,
  Yi as Light,
  nO as LightData,
  yt as LimitVelocityOverLifetimeModule,
  fL as LoadingElementOptions,
  ev as LogStats,
  Ui as LogType,
  Mw as LookAt,
  Ra as LookAtConstraint,
  R as MODULES,
  qt as MainModule,
  Sw as MarkerType,
  _u as MaskableGraphic,
  j as Mathf,
  br as MeshCollider,
  lu as MeshRenderer,
  Y as MinMaxCurve,
  Wa as MinMaxGradient,
  nd as NEEDLE_ENGINE_FEATURE_FLAGS,
  qc as NEKeyboardEvent,
  Ws as NEPointerEvent,
  UA as NeedleButtonElement,
  y_ as NeedleEngineModelLoader,
  Uw as NeedleEngineWebComponent,
  Es as NeedleMenu,
  ef as NeedlePatchesKey,
  Zb as NeedleXRController,
  K as NeedleXRSession,
  S1 as NeedleXRSync,
  I1 as NeedleXRUtils,
  Sg as NestedGltf,
  x1 as NetworkConnection,
  ps as NetworkedStreamEvents,
  tu as NetworkedStreams,
  Kv as Networking,
  eP as NewInstanceModel,
  ve as NoiseModule,
  Vi as ObjectRaycaster,
  Oa as ObjectUtils,
  Na as OffsetConstraint,
  Yu as OneEuroFilter,
  Db as OneEuroFilterXYZ,
  Wc as OpenURL,
  ye as OrbitControls,
  kc as Outline,
  w1 as OwnershipEvent,
  i0 as OwnershipModel,
  bl as PUBLIC_KEY,
  Fa as Padding,
  Xp as ParticleBurst,
  iw as ParticleSubEmitter,
  wd as ParticleSystem,
  xr as ParticleSystemBaseBehaviour,
  fn as ParticleSystemRenderer,
  Gp as ParticleSystemShapeType,
  eo as PeerHandle,
  y1 as PeerNetworking,
  nc as Physics,
  Fv as PhysicsExtension,
  wt as PhysicsMaterialCombine,
  Mu as PixelationEffect,
  _d as PlayAnimationOnClick,
  rr as PlayAudioOnClick,
  fc as PlayableDirector,
  uc as PlayerColor,
  Mn as PlayerState,
  fR as PlayerStateEvent,
  jv as PlayerSync,
  XP as PlayerView,
  QP as PlayerViewManager,
  eu as PointerEventData,
  km as PointerType,
  ot as PostProcessingEffect,
  lt as PostProcessingEffectOrder,
  cw as PostProcessingHandler,
  Pc as PreliminaryAction,
  du as PreliminaryTrigger,
  Wo as PreviewHelper,
  ma as PrimitiveType,
  le as Progress,
  Tb as PromiseAllWithErrors,
  ry as PromiseErrorResult,
  oe as RGBAColor,
  Kl as RapierPhysics,
  Ng as RawImage,
  mr as RaycastOptions,
  PR as Rect,
  zn as RectTransform,
  yd as ReflectionProbe,
  qo as RegisteredAnimationInfo,
  Ag as RemoteSkybox,
  fs as RenderTexture,
  ek as RenderTextureSerializer,
  Hi as Renderer,
  iO as RendererData,
  zp as RendererLightmap,
  ft as Rigidbody,
  qe as RigidbodyConstraints,
  ee as RoomEvents,
  un as RotationBySpeedModule,
  Hn as RotationOverLifetimeModule,
  Bp as SceneLightSettings,
  Ze as SceneSwitcher,
  Or as ScreenCapture,
  Co as ScreenSpaceAmbientOcclusion,
  qn as ScreenSpaceAmbientOcclusionN8,
  vn as SendQueue,
  b0 as SerializationContext,
  Ev as SetActiveOnClick,
  Tu as ShadowCatcher,
  Jv as ShapeModule,
  vk as ShapeOverlapResult,
  Ru as SharpeningEffect,
  jg as SignalAsset,
  Lu as SignalReceiver,
  Iu as SignalReceiverEvent,
  Pd as SignalTrackHandler,
  CR as Size,
  Ci as SizeBySpeedModule,
  Va as SizeOverLifetimeModule,
  gv as SkinnedMeshRenderer,
  Ig as SmoothFollow,
  Ca as SpatialGrabRaycaster,
  zu as SpatialHtml,
  Lg as SpatialTrigger,
  xs as SpatialTriggerReceiver,
  Dg as SpectatorCamera,
  wc as SphereCollider,
  s0 as SphereIntersection,
  _o as Sprite,
  Hl as SpriteData,
  xi as SpriteRenderer,
  cc as SpriteSheet,
  YI as StateMachineBehaviour,
  H0 as StreamEndedEvent,
  wk as StreamReceivedEvent,
  Kp as SubEmitterSystem,
  bw as SyncedCamera,
  Xn as SyncedRoom,
  Fn as SyncedTransform,
  Av as TapGestureTrigger,
  fg as TeleportTarget,
  vw as TestRunner,
  pL as TestSceneUtils,
  ww as TestSimulateUserData,
  Gt as Text,
  Wv as TextBuilder,
  gg as TextExtension,
  Xt as TextureSheetAnimationModule,
  Ls as TiltShiftEffect,
  sO as Time,
  hr as ToneMappingEffect,
  Du as TrackHandler,
  Di as TrackType,
  Ne as TrailModule,
  Ue as TransformData,
  qa as TransformGizmo,
  Vt as TriggerBuilder,
  tr as TriggerModel,
  P as TypeStore,
  V0 as UIRaycastUtils,
  gu as UIRootComponent,
  Sv as USDDocument,
  st as USDObject,
  jM as USDWriter,
  ws as USDZExporter,
  FM as USDZExporter$1,
  Ml as USDZText,
  Qv as USDZUIExtension,
  tk as UriSerializer,
  ru as UsageMarker,
  AI as UserJoinedOrLeftRoomModel,
  En as VERSION,
  Rv as VariantAction,
  Ve as VelocityOverLifetimeModule,
  Vv as VerticalLayoutGroup,
  pt as VideoPlayer,
  Zo as ViewDevice,
  Ga as Vignette,
  uu as VisibilityAction,
  _r as Voip,
  Dc as Volume,
  B as VolumeParameter,
  kg as VolumeProfile,
  FI as WaitForFrames,
  WP as WaitForPromise,
  T0 as WaitForSeconds,
  so as Watch,
  Nu as WebARCameraBackground,
  Ni as WebARSessionRoot,
  pg as WebXR,
  ir as WebXRButtonFactory,
  $u as WebXRImageTracking,
  To as WebXRImageTrackingModel,
  Eo as WebXRPlaneTracking,
  pc as WebXRTrackedImage,
  Mo as XRControllerFollow,
  uo as XRControllerModel,
  Gi as XRControllerMovement,
  nn as XRFlag,
  Vg as XRRig,
  Zt as XRState,
  us as XRStateFlag,
  WA as __Ignore,
  $1 as __internalNotifyObjectDestroyed,
  oo as activeInHierarchyFieldName,
  iC as addAttributeChangeCallback,
  An as addComponent,
  sL as addCustomExtensionPlugin,
  ta as addNewComponent,
  Cm as addPatch,
  jm as apply,
  qI as applyHMRChanges,
  CP as applyPrototypeExtensions,
  J1 as beginListenDestroy,
  iP as beginListenInstantiate,
  e0 as binaryIdentifierCasts,
  UI as build_scene_functions,
  Br as builtinComponentKeyName,
  Bw as calculateProgress01,
  gI as clearMessages,
  JI as colorSerializer,
  hP as compareAssociation,
  _f as componentSerializer,
  jC as copyTexture,
  AO as createMotion,
  oi as debugNet,
  Yc as debugOwner,
  UM as decompressGpuTexture,
  zd as deepClone,
  Os as delay,
  Ud as delayForFrames,
  xp as deserializeObject,
  Wi as destroy,
  TP as destroyComponentInstance,
  Gk as determineMimeTypeFromExtension,
  Re as disposeObjectResources,
  ms as disposeStream,
  Mh as editorGuidKeyName,
  Yr as enableSpatialConsole,
  eL as euler,
  tL as eventListSerializer,
  gL as exportAsGLTF,
  O0 as findByGuid,
  Qd as findObjectOfType,
  EP as findObjectsOfType,
  l0 as findResourceUsers,
  UC as fitObjectIntoVolume,
  ba as foreachComponent,
  Fm as foreachComponentEnumerator,
  vI as forward,
  oC as generateQRCode,
  tP as generateSeed,
  _i as getBoundingBox,
  vC as getCameraController,
  ka as getComponent,
  Xd as getComponentInChildren,
  ad as getComponentInParent,
  qd as getComponents,
  gc as getComponentsInChildren,
  Dm as getComponentsInParent,
  OM as getFormattedDate,
  Mt as getIconElement,
  Zy as getIconTexture,
  jn as getLoader,
  Gd as getOrAddComponent,
  w as getParam,
  wI as getParentHierarchyPath,
  nI as getPath,
  MI as getPeerOptions,
  g1 as getPeerjsInstance,
  DI as getResourceUserCount,
  OC as getTempColor,
  bn as getTempQuaternion,
  G as getTempVector,
  Fd as getUrlParams,
  zC as getVisibleInCustomShadowRendering,
  AC as getWorldDirection,
  Fb as getWorldEuler,
  Z as getWorldPosition,
  be as getWorldQuaternion,
  xm as getWorldRotation,
  $e as getWorldScale,
  vs as hasCommercialLicense,
  Kd as hasIndieLicense,
  Lp as hasPointerEventComponent,
  bs as hasProLicense,
  XC as hideDebugConsole,
  WM as imageToCanvas,
  va as instantiate,
  yM as invokeLoadedImportPluginHooks,
  r1 as invokeXRSessionEnd,
  o1 as invokeXRSessionStart,
  AP as isActiveInHierarchy,
  yc as isActiveSelf,
  lI as isAndroidDevice,
  DC as isAnimationAction,
  yk as isComponent,
  JA as isDebugMode,
  sI as isDesktop,
  _a as isDestroyed,
  L as isDevEnvironment,
  LI as isDisposed,
  mL as isExporting,
  gk as isGLTFModel,
  NS as isHostedOnGlitch,
  r_ as isHotReloadEnabled,
  GI as isHotReloading,
  rI as isIPad,
  aO as isIconElement,
  rn as isLocalNetwork,
  hI as isMacOS,
  oI as isMobileDevice,
  cI as isMozillaXR,
  fI as isQuest,
  U1 as isResourceTrackingEnabled,
  uI as isSafari,
  Bm as isUsingInstancing,
  dI as isiOS,
  aI as isiPad,
  uL as loadAsset,
  yE as loadPMREM,
  Lw as loadSync,
  hp as logHierarchy,
  _I as lookAtInverse,
  Nd as lookAtObject,
  bI as lookAtScreenPoint,
  tI as makeId,
  ZS as makeIdFromRandomWords,
  cn as makeNameSafe,
  IP as markAsInstancedRendered,
  pI as microphonePermissionsGranted,
  ZA as nameof,
  YS as nameofFactory,
  YO as objectSerializer,
  OI as offXRSessionEnd,
  PI as offXRSessionStart,
  HI as onAfterRender,
  VI as onBeforeRender,
  $I as onClear,
  WI as onDestroy,
  wO as onInitialized,
  B0 as onStart,
  xO as onUpdate,
  Kb as onXRSessionEnd,
  Om as onXRSessionStart,
  SA as parseSync,
  NC as placeOnSurface,
  Nb as postprocessFBXMaterials,
  ZI as prefix,
  KS as pushState,
  iI as randomNumber,
  t0 as registerBinaryType,
  Um as registerComponent,
  uv as registerComponentExtension,
  pn as registerCustomEffectType,
  fv as registerExportExtensions,
  Fp as registerExtensions,
  CO as registerHotReloadType,
  Xb as registerLoader,
  sP as registerPrefabProvider,
  PP as registerPrototypeExtensions,
  BI as registerType,
  eC as relativePathPrefix,
  nC as removeAttributeChangeCallback,
  S0 as removeComponent,
  oL as removeCustomImportExtensionType,
  CI as removePatch,
  fr as resolveUrl,
  JS as sanitizeString,
  rA as saveImage,
  dL as screenshot,
  Tw as screenshot2,
  p0 as sendDestroyed,
  u as serializable,
  gP as serializeObject,
  Ma as serializeable,
  Ih as setActive,
  dC as setAllowBalloonMessages,
  mI as setAllowOverlayMessages,
  cp as setAutoFitEnabled,
  cy as setCameraController,
  LP as setDestroyed,
  SI as setDevEnvironment,
  N1 as setDisposable,
  el as setDontDestroy,
  ny as setOrAddParamsToUrl,
  eI as setParam,
  Yh as setParamWithoutReload,
  RI as setPeerOptions,
  II as setResourceTrackingEnabled,
  Mb as setState,
  Ub as setVisibleInCustomShadowRendering,
  zb as setWorldEuler,
  ut as setWorldPosition,
  ua as setWorldPositionXYZ,
  an as setWorldQuaternion,
  Bb as setWorldQuaternionXYZW,
  LC as setWorldRotation,
  $d as setWorldRotationXYZ,
  tc as setWorldScale,
  Wd as showBalloonError,
  Be as showBalloonMessage,
  ge as showBalloonWarning,
  Vb as showDebugConsole,
  yI as slerp,
  Hd as syncDestroy,
  Lv as syncField,
  m0 as syncInstantiate,
  xI as textureToCanvas,
  p1 as tryCastBinary,
  Xk as tryDetermineMimetypeFromBinary,
  qk as tryDetermineMimetypeFromURL,
  ec as tryFindObject,
  m1 as tryGetGuid,
  PO as unregisterHotReloadType,
  Rb as unwatchWrite,
  wC as useForAutoFit,
  It as validate,
  bm as watchWrite
};
