import { PlaneGeometry as zo, ShaderChunk as Ga, Object3D as Oo, Layers as Ur, MeshBasicMaterial as Ts, DoubleSide as Fn, AdditiveBlending as Bo, InstancedBufferAttribute as we, DynamicDrawUsage as gt, InstancedBufferGeometry as ja, Uniform$1 as Vt, ShaderMaterial as Dn, BufferGeometry as Pi, BufferAttribute as Mt, Mesh as hs, MeshStandardMaterial as $a, MeshPhysicalMaterial as qa, Triangle as Ue, Vector3 as N, Plane as Io, Line3 as me, Vector2 as Ke, Sphere as No, Matrix4 as Gt, Box3 as te, BackSide as Xa, REVISION as Ha, FrontSide as Cs, BatchedMesh as Wa, Ray as Ya, Matrix3 as Za, Vector4 as us, SkinnedMesh as Ka, InterpolateDiscrete as Qa, InterpolateLinear as Uo, AnimationClip as tc, QuaternionKeyframeTrack as ec, ColorKeyframeTrack as ic, VectorKeyframeTrack as rc, NumberKeyframeTrack as nc, PropertyBinding as Ms } from "./three-BRSLmpyi.js";
const ot = {
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function Fo(n) {
  const t = await fetch(n);
  if (t.ok)
    return t.json();
  throw new Error(t.statusText);
}
async function sc(n) {
  return await Fo(`${n}/profilesList.json`);
}
async function Ou(n, t, e = null, i = !0) {
  if (!n)
    throw new Error("No xrInputSource supplied");
  const r = await sc(t);
  let s;
  if (n.profiles.some((c) => {
    const l = r[c];
    return l && (s = {
      profileId: c,
      profilePath: `${t}/${l.path}`,
      deprecated: !!l.deprecated
    }), !!s;
  }), !s) {
    if (!e)
      throw new Error("No matching profile name found");
    const c = r[e];
    if (!c)
      throw new Error(`No matching profile name found and default profile "${e}" missing.`);
    s = {
      profileId: e,
      profilePath: `${t}/${c.path}`,
      deprecated: !!c.deprecated
    };
  }
  const a = await Fo(s.profilePath);
  let o;
  if (i) {
    let c;
    if (n.handedness === "any" ? c = a.layouts[Object.keys(a.layouts)[0]] : c = a.layouts[n.handedness], !c)
      throw new Error(
        `No matching handedness, ${n.handedness}, in profile ${s.profileId}`
      );
    c.assetPath && (o = s.profilePath.replace("profile.json", c.assetPath));
  }
  return { profile: a, assetPath: o };
}
const oc = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: ot.ComponentState.DEFAULT
};
function ac(n = 0, t = 0) {
  let e = n, i = t;
  if (Math.sqrt(n * n + t * t) > 1) {
    const a = Math.atan2(t, n);
    e = Math.cos(a), i = Math.sin(a);
  }
  return {
    normalizedXAxis: e * 0.5 + 0.5,
    normalizedYAxis: i * 0.5 + 0.5
  };
}
class cc {
  constructor(t) {
    this.componentProperty = t.componentProperty, this.states = t.states, this.valueNodeName = t.valueNodeName, this.valueNodeProperty = t.valueNodeProperty, this.valueNodeProperty === ot.VisualResponseProperty.TRANSFORM && (this.minNodeName = t.minNodeName, this.maxNodeName = t.maxNodeName), this.value = 0, this.updateFromComponent(oc);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: t,
    yAxis: e,
    button: i,
    state: r
  }) {
    const { normalizedXAxis: s, normalizedYAxis: a } = ac(t, e);
    switch (this.componentProperty) {
      case ot.ComponentProperty.X_AXIS:
        this.value = this.states.includes(r) ? s : 0.5;
        break;
      case ot.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(r) ? a : 0.5;
        break;
      case ot.ComponentProperty.BUTTON:
        this.value = this.states.includes(r) ? i : 0;
        break;
      case ot.ComponentProperty.STATE:
        this.valueNodeProperty === ot.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(r) : this.value = this.states.includes(r) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class lc {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(t, e) {
    if (!t || !e || !e.visualResponses || !e.gamepadIndices || Object.keys(e.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = t, this.type = e.type, this.rootNodeName = e.rootNodeName, this.touchPointNodeName = e.touchPointNodeName, this.visualResponses = {}, Object.keys(e.visualResponses).forEach((i) => {
      const r = new cc(e.visualResponses[i]);
      this.visualResponses[i] = r;
    }), this.gamepadIndices = Object.assign({}, e.gamepadIndices), this.values = {
      state: ot.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(t) {
    if (this.values.state = ot.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && t.buttons.length > this.gamepadIndices.button) {
      const e = t.buttons[this.gamepadIndices.button];
      this.values.button = e.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, e.pressed || this.values.button === 1 ? this.values.state = ot.ComponentState.PRESSED : (e.touched || this.values.button > ot.ButtonTouchThreshold) && (this.values.state = ot.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && t.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = t.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === ot.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > ot.AxisTouchThreshold && (this.values.state = ot.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && t.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = t.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === ot.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > ot.AxisTouchThreshold && (this.values.state = ot.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((e) => {
      e.updateFromComponent(this.values);
    });
  }
}
class Bu {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(t, e, i) {
    if (!t)
      throw new Error("No xrInputSource supplied");
    if (!e)
      throw new Error("No profile supplied");
    this.xrInputSource = t, this.assetUrl = i, this.id = e.profileId, this.layoutDescription = e.layouts[t.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((r) => {
      const s = this.layoutDescription.components[r];
      this.components[r] = new lc(r, s);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const t = [];
    return Object.values(this.components).forEach((e) => {
      t.push(e.data);
    }), t;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((t) => {
      t.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const on = 2, Zt = 4, de = 4, hc = 4, be = new Int32Array(2), Ps = new Float32Array(be.buffer), ws = new Float64Array(be.buffer), ur = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
class ye {
  constructor(t, e) {
    this.low = t | 0, this.high = e | 0;
  }
  static create(t, e) {
    return t == 0 && e == 0 ? ye.ZERO : new ye(t, e);
  }
  toFloat64() {
    return (this.low >>> 0) + this.high * 4294967296;
  }
  equals(t) {
    return this.low == t.low && this.high == t.high;
  }
}
ye.ZERO = new ye(0, 0);
var Ln;
(function(n) {
  n[n.UTF8_BYTES = 1] = "UTF8_BYTES", n[n.UTF16_STRING = 2] = "UTF16_STRING";
})(Ln || (Ln = {}));
class Gr {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(t) {
    this.bytes_ = t, this.position_ = 0;
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(t) {
    return new Gr(new Uint8Array(t));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(t) {
    this.position_ = t;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(t) {
    return this.readUint8(t) << 24 >> 24;
  }
  readUint8(t) {
    return this.bytes_[t];
  }
  readInt16(t) {
    return this.readUint16(t) << 16 >> 16;
  }
  readUint16(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8;
  }
  readInt32(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24;
  }
  readUint32(t) {
    return this.readInt32(t) >>> 0;
  }
  readInt64(t) {
    return new ye(this.readInt32(t), this.readInt32(t + 4));
  }
  readUint64(t) {
    return new ye(this.readUint32(t), this.readUint32(t + 4));
  }
  readFloat32(t) {
    return be[0] = this.readInt32(t), Ps[0];
  }
  readFloat64(t) {
    return be[ur ? 0 : 1] = this.readInt32(t), be[ur ? 1 : 0] = this.readInt32(t + 4), ws[0];
  }
  writeInt8(t, e) {
    this.bytes_[t] = e;
  }
  writeUint8(t, e) {
    this.bytes_[t] = e;
  }
  writeInt16(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;
  }
  writeUint16(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;
  }
  writeInt32(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;
  }
  writeUint32(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;
  }
  writeInt64(t, e) {
    this.writeInt32(t, e.low), this.writeInt32(t + 4, e.high);
  }
  writeUint64(t, e) {
    this.writeUint32(t, e.low), this.writeUint32(t + 4, e.high);
  }
  writeFloat32(t, e) {
    Ps[0] = e, this.writeInt32(t, be[0]);
  }
  writeFloat64(t, e) {
    ws[0] = e, this.writeInt32(t, be[ur ? 0 : 1]), this.writeInt32(t + 4, be[ur ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + Zt + de)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let t = "";
    for (let e = 0; e < de; e++)
      t += String.fromCharCode(this.readInt8(this.position_ + Zt + e));
    return t;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(t, e) {
    const i = t - this.readInt32(t);
    return e < this.readInt16(i) ? this.readInt16(i + e) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, e) {
    return t.bb_pos = e + this.readInt32(e), t.bb = this, t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as
   * the "optionalEncoding" argument. This is useful for avoiding conversion to
   * and from UTF-16 when the data will just be packaged back up in another
   * FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(t, e) {
    t += this.readInt32(t);
    const i = this.readInt32(t);
    let r = "", s = 0;
    if (t += Zt, e === Ln.UTF8_BYTES)
      return this.bytes_.subarray(t, t + i);
    for (; s < i; ) {
      let a;
      const o = this.readUint8(t + s++);
      if (o < 192)
        a = o;
      else {
        const c = this.readUint8(t + s++);
        if (o < 224)
          a = (o & 31) << 6 | c & 63;
        else {
          const l = this.readUint8(t + s++);
          if (o < 240)
            a = (o & 15) << 12 | (c & 63) << 6 | l & 63;
          else {
            const h = this.readUint8(t + s++);
            a = (o & 7) << 18 | (c & 63) << 12 | (l & 63) << 6 | h & 63;
          }
        }
      }
      a < 65536 ? r += String.fromCharCode(a) : (a -= 65536, r += String.fromCharCode((a >> 10) + 55296, (a & 1023) + 56320));
    }
    return r;
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(t, e) {
    return typeof t == "string" ? this.__string(e) : this.__union(t, e);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(t) {
    return t + this.readInt32(t);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(t) {
    return t + this.readInt32(t) + Zt;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(t) {
    return this.readInt32(t + this.readInt32(t));
  }
  __has_identifier(t) {
    if (t.length != de)
      throw new Error("FlatBuffers: file identifier must be length " + de);
    for (let e = 0; e < de; e++)
      if (t.charCodeAt(e) != this.readInt8(this.position() + Zt + e))
        return !1;
    return !0;
  }
  /**
   * A helper function to avoid generated code depending on this file directly.
   */
  createLong(t, e) {
    return ye.create(t, e);
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(t, e) {
    const i = [];
    for (let r = 0; r < e; ++r)
      t(r) !== null && i.push(t(r));
    return i;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(t, e) {
    const i = [];
    for (let r = 0; r < e; ++r) {
      const s = t(r);
      s !== null && i.push(s.unpack());
    }
    return i;
  }
}
class Do {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(t) {
    this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null;
    let e;
    t ? e = t : e = 1024, this.bb = Gr.allocate(e), this.space = e;
  }
  clear() {
    this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(t) {
    this.force_defaults = t;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(t, e) {
    t > this.minalign && (this.minalign = t);
    const i = ~(this.bb.capacity() - this.space + e) + 1 & t - 1;
    for (; this.space < i + t + e; ) {
      const r = this.bb.capacity();
      this.bb = Do.growByteBuffer(this.bb), this.space += this.bb.capacity() - r;
    }
    this.pad(i);
  }
  pad(t) {
    for (let e = 0; e < t; e++)
      this.bb.writeInt8(--this.space, 0);
  }
  writeInt8(t) {
    this.bb.writeInt8(this.space -= 1, t);
  }
  writeInt16(t) {
    this.bb.writeInt16(this.space -= 2, t);
  }
  writeInt32(t) {
    this.bb.writeInt32(this.space -= 4, t);
  }
  writeInt64(t) {
    this.bb.writeInt64(this.space -= 8, t);
  }
  writeFloat32(t) {
    this.bb.writeFloat32(this.space -= 4, t);
  }
  writeFloat64(t) {
    this.bb.writeFloat64(this.space -= 8, t);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the the buffer.
   */
  addInt8(t) {
    this.prep(1, 0), this.writeInt8(t);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the the buffer.
   */
  addInt16(t) {
    this.prep(2, 0), this.writeInt16(t);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the the buffer.
   */
  addInt32(t) {
    this.prep(4, 0), this.writeInt32(t);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the the buffer.
   */
  addInt64(t) {
    this.prep(8, 0), this.writeInt64(t);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the the buffer.
   */
  addFloat32(t) {
    this.prep(4, 0), this.writeFloat32(t);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the the buffer.
   */
  addFloat64(t) {
    this.prep(8, 0), this.writeFloat64(t);
  }
  addFieldInt8(t, e, i) {
    (this.force_defaults || e != i) && (this.addInt8(e), this.slot(t));
  }
  addFieldInt16(t, e, i) {
    (this.force_defaults || e != i) && (this.addInt16(e), this.slot(t));
  }
  addFieldInt32(t, e, i) {
    (this.force_defaults || e != i) && (this.addInt32(e), this.slot(t));
  }
  addFieldInt64(t, e, i) {
    (this.force_defaults || !e.equals(i)) && (this.addInt64(e), this.slot(t));
  }
  addFieldFloat32(t, e, i) {
    (this.force_defaults || e != i) && (this.addFloat32(e), this.slot(t));
  }
  addFieldFloat64(t, e, i) {
    (this.force_defaults || e != i) && (this.addFloat64(e), this.slot(t));
  }
  addFieldOffset(t, e, i) {
    (this.force_defaults || e != i) && (this.addOffset(e), this.slot(t));
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(t, e, i) {
    e != i && (this.nested(e), this.slot(t));
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(t) {
    if (t != this.offset())
      throw new Error("FlatBuffers: struct must be serialized inline.");
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested)
      throw new Error("FlatBuffers: object serialization must not be nested.");
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(t) {
    this.vtable !== null && (this.vtable[t] = this.offset());
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(t) {
    const e = t.capacity();
    if (e & 3221225472)
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    const i = e << 1, r = Gr.allocate(i);
    return r.setPosition(i - e), r.bytes().set(t.bytes(), i - e), r;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(t) {
    this.prep(Zt, 0), this.writeInt32(this.offset() - t + Zt);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(t) {
    this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = t;
    for (let e = 0; e < t; e++)
      this.vtable[e] = 0;
    this.isNested = !0, this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested)
      throw new Error("FlatBuffers: endObject called without startObject");
    this.addInt32(0);
    const t = this.offset();
    let e = this.vtable_in_use - 1;
    for (; e >= 0 && this.vtable[e] == 0; e--)
      ;
    const i = e + 1;
    for (; e >= 0; e--)
      this.addInt16(this.vtable[e] != 0 ? t - this.vtable[e] : 0);
    const r = 2;
    this.addInt16(t - this.object_start);
    const s = (i + r) * on;
    this.addInt16(s);
    let a = 0;
    const o = this.space;
    t: for (e = 0; e < this.vtables.length; e++) {
      const c = this.bb.capacity() - this.vtables[e];
      if (s == this.bb.readInt16(c)) {
        for (let l = on; l < s; l += on)
          if (this.bb.readInt16(o + l) != this.bb.readInt16(c + l))
            continue t;
        a = this.vtables[e];
        break;
      }
    }
    return a ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, a - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(t, e, i) {
    const r = i ? hc : 0;
    if (e) {
      const s = e;
      if (this.prep(this.minalign, Zt + de + r), s.length != de)
        throw new Error("FlatBuffers: file identifier must be length " + de);
      for (let a = de - 1; a >= 0; a--)
        this.writeInt8(s.charCodeAt(a));
    }
    this.prep(this.minalign, Zt + r), this.addOffset(t), r && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(t, e) {
    this.finish(t, e, !0);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(t, e) {
    const i = this.bb.capacity() - t, r = i - this.bb.readInt32(i);
    if (!(this.bb.readInt16(r + e) != 0))
      throw new Error("FlatBuffers: field " + e + " must be set");
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(t, e, i) {
    this.notNested(), this.vector_num_elems = e, this.prep(Zt, t * e), this.prep(i, t * e);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    return this.writeInt32(this.vector_num_elems), this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(t) {
    if (!t)
      return 0;
    if (this.string_maps || (this.string_maps = /* @__PURE__ */ new Map()), this.string_maps.has(t))
      return this.string_maps.get(t);
    const e = this.createString(t);
    return this.string_maps.set(t, e), e;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(t) {
    if (!t)
      return 0;
    let e;
    if (t instanceof Uint8Array)
      e = t;
    else {
      e = [];
      let i = 0;
      for (; i < t.length; ) {
        let r;
        const s = t.charCodeAt(i++);
        if (s < 55296 || s >= 56320)
          r = s;
        else {
          const a = t.charCodeAt(i++);
          r = (s << 10) + a + -56613888;
        }
        r < 128 ? e.push(r) : (r < 2048 ? e.push(r >> 6 & 31 | 192) : (r < 65536 ? e.push(r >> 12 & 15 | 224) : e.push(r >> 18 & 7 | 240, r >> 12 & 63 | 128), e.push(r >> 6 & 63 | 128)), e.push(r & 63 | 128));
      }
    }
    this.addInt8(0), this.startVector(1, e.length, 1), this.bb.setPosition(this.space -= e.length);
    for (let i = 0, r = this.space, s = this.bb.bytes(); i < e.length; i++)
      s[r++] = e[i];
    return this.endVector();
  }
  /**
   * A helper function to avoid generated code depending on this file directly.
   */
  createLong(t, e) {
    return ye.create(t, e);
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(t) {
    return t === null ? 0 : typeof t == "string" ? this.createString(t) : t.pack(this);
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(t) {
    const e = [];
    for (let i = 0; i < t.length; ++i) {
      const r = t[i];
      if (r !== null)
        e.push(this.createObjectOffset(r));
      else
        throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
    }
    return e;
  }
  createStructOffsetList(t, e) {
    return e(this, t.length), this.createObjectOffsetList(t), this.endVector();
  }
}
function Kr(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var an = { exports: {} }, Es;
function ks() {
  return Es || (Es = 1, (function(n) {
    var t = {};
    t.useBlobBuilder = (function() {
      try {
        return new Blob([]), !1;
      } catch {
        return !0;
      }
    })(), t.useArrayBufferView = !t.useBlobBuilder && (function() {
      try {
        return new Blob([new Uint8Array([])]).size === 0;
      } catch {
        return !0;
      }
    })(), n.exports.binaryFeatures = t;
    var e = n.exports.BlobBuilder;
    typeof window < "u" && (e = n.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder);
    function i() {
      this._pieces = [], this._parts = [];
    }
    i.prototype.append = function(r) {
      typeof r == "number" ? this._pieces.push(r) : (this.flush(), this._parts.push(r));
    }, i.prototype.flush = function() {
      if (this._pieces.length > 0) {
        var r = new Uint8Array(this._pieces);
        t.useArrayBufferView || (r = r.buffer), this._parts.push(r), this._pieces = [];
      }
    }, i.prototype.getBuffer = function() {
      if (this.flush(), t.useBlobBuilder) {
        for (var r = new e(), s = 0, a = this._parts.length; s < a; s++)
          r.append(this._parts[s]);
        return r.getBlob();
      } else
        return new Blob(this._parts);
    }, n.exports.BufferBuilder = i;
  })(an)), an.exports;
}
var cn, Rs;
function uc() {
  if (Rs) return cn;
  Rs = 1;
  var n = ks().BufferBuilder, t = ks().binaryFeatures, e = {
    unpack: function(o) {
      var c = new i(o);
      return c.unpack();
    },
    pack: function(o) {
      var c = new r();
      c.pack(o);
      var l = c.getBuffer();
      return l;
    }
  };
  cn = e;
  function i(o) {
    this.index = 0, this.dataBuffer = o, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength;
  }
  i.prototype.unpack = function() {
    var o = this.unpack_uint8();
    if (o < 128)
      return o;
    if ((o ^ 224) < 32)
      return (o ^ 224) - 32;
    var c;
    if ((c = o ^ 160) <= 15)
      return this.unpack_raw(c);
    if ((c = o ^ 176) <= 15)
      return this.unpack_string(c);
    if ((c = o ^ 144) <= 15)
      return this.unpack_array(c);
    if ((c = o ^ 128) <= 15)
      return this.unpack_map(c);
    switch (o) {
      case 192:
        return null;
      case 193:
        return;
      case 194:
        return !1;
      case 195:
        return !0;
      case 202:
        return this.unpack_float();
      case 203:
        return this.unpack_double();
      case 204:
        return this.unpack_uint8();
      case 205:
        return this.unpack_uint16();
      case 206:
        return this.unpack_uint32();
      case 207:
        return this.unpack_uint64();
      case 208:
        return this.unpack_int8();
      case 209:
        return this.unpack_int16();
      case 210:
        return this.unpack_int32();
      case 211:
        return this.unpack_int64();
      case 212:
        return;
      case 213:
        return;
      case 214:
        return;
      case 215:
        return;
      case 216:
        return c = this.unpack_uint16(), this.unpack_string(c);
      case 217:
        return c = this.unpack_uint32(), this.unpack_string(c);
      case 218:
        return c = this.unpack_uint16(), this.unpack_raw(c);
      case 219:
        return c = this.unpack_uint32(), this.unpack_raw(c);
      case 220:
        return c = this.unpack_uint16(), this.unpack_array(c);
      case 221:
        return c = this.unpack_uint32(), this.unpack_array(c);
      case 222:
        return c = this.unpack_uint16(), this.unpack_map(c);
      case 223:
        return c = this.unpack_uint32(), this.unpack_map(c);
    }
  }, i.prototype.unpack_uint8 = function() {
    var o = this.dataView[this.index] & 255;
    return this.index++, o;
  }, i.prototype.unpack_uint16 = function() {
    var o = this.read(2), c = (o[0] & 255) * 256 + (o[1] & 255);
    return this.index += 2, c;
  }, i.prototype.unpack_uint32 = function() {
    var o = this.read(4), c = ((o[0] * 256 + o[1]) * 256 + o[2]) * 256 + o[3];
    return this.index += 4, c;
  }, i.prototype.unpack_uint64 = function() {
    var o = this.read(8), c = ((((((o[0] * 256 + o[1]) * 256 + o[2]) * 256 + o[3]) * 256 + o[4]) * 256 + o[5]) * 256 + o[6]) * 256 + o[7];
    return this.index += 8, c;
  }, i.prototype.unpack_int8 = function() {
    var o = this.unpack_uint8();
    return o < 128 ? o : o - 256;
  }, i.prototype.unpack_int16 = function() {
    var o = this.unpack_uint16();
    return o < 32768 ? o : o - 65536;
  }, i.prototype.unpack_int32 = function() {
    var o = this.unpack_uint32();
    return o < Math.pow(2, 31) ? o : o - Math.pow(2, 32);
  }, i.prototype.unpack_int64 = function() {
    var o = this.unpack_uint64();
    return o < Math.pow(2, 63) ? o : o - Math.pow(2, 64);
  }, i.prototype.unpack_raw = function(o) {
    if (this.length < this.index + o)
      throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + o + " " + this.length);
    var c = this.dataBuffer.slice(this.index, this.index + o);
    return this.index += o, c;
  }, i.prototype.unpack_string = function(o) {
    for (var c = this.read(o), l = 0, h = "", u, f; l < o; )
      u = c[l], u < 128 ? (h += String.fromCharCode(u), l++) : (u ^ 192) < 32 ? (f = (u ^ 192) << 6 | c[l + 1] & 63, h += String.fromCharCode(f), l += 2) : (f = (u & 15) << 12 | (c[l + 1] & 63) << 6 | c[l + 2] & 63, h += String.fromCharCode(f), l += 3);
    return this.index += o, h;
  }, i.prototype.unpack_array = function(o) {
    for (var c = new Array(o), l = 0; l < o; l++)
      c[l] = this.unpack();
    return c;
  }, i.prototype.unpack_map = function(o) {
    for (var c = {}, l = 0; l < o; l++) {
      var h = this.unpack(), u = this.unpack();
      c[h] = u;
    }
    return c;
  }, i.prototype.unpack_float = function() {
    var o = this.unpack_uint32(), c = o >> 31, l = (o >> 23 & 255) - 127, h = o & 8388607 | 8388608;
    return (c === 0 ? 1 : -1) * h * Math.pow(2, l - 23);
  }, i.prototype.unpack_double = function() {
    var o = this.unpack_uint32(), c = this.unpack_uint32(), l = o >> 31, h = (o >> 20 & 2047) - 1023, u = o & 1048575 | 1048576, f = u * Math.pow(2, h - 20) + c * Math.pow(2, h - 52);
    return (l === 0 ? 1 : -1) * f;
  }, i.prototype.read = function(o) {
    var c = this.index;
    if (c + o <= this.length)
      return this.dataView.subarray(c, c + o);
    throw new Error("BinaryPackFailure: read index out of range");
  };
  function r() {
    this.bufferBuilder = new n();
  }
  r.prototype.getBuffer = function() {
    return this.bufferBuilder.getBuffer();
  }, r.prototype.pack = function(o) {
    var c = typeof o;
    if (c === "string")
      this.pack_string(o);
    else if (c === "number")
      Math.floor(o) === o ? this.pack_integer(o) : this.pack_double(o);
    else if (c === "boolean")
      o === !0 ? this.bufferBuilder.append(195) : o === !1 && this.bufferBuilder.append(194);
    else if (c === "undefined")
      this.bufferBuilder.append(192);
    else if (c === "object")
      if (o === null)
        this.bufferBuilder.append(192);
      else {
        var l = o.constructor;
        if (l == Array)
          this.pack_array(o);
        else if (l == Blob || l == File || o instanceof Blob || o instanceof File)
          this.pack_bin(o);
        else if (l == ArrayBuffer)
          t.useArrayBufferView ? this.pack_bin(new Uint8Array(o)) : this.pack_bin(o);
        else if ("BYTES_PER_ELEMENT" in o)
          t.useArrayBufferView ? this.pack_bin(new Uint8Array(o.buffer)) : this.pack_bin(o.buffer);
        else if (l == Object || l.toString().startsWith("class"))
          this.pack_object(o);
        else if (l == Date)
          this.pack_string(o.toString());
        else if (typeof o.toBinaryPack == "function")
          this.bufferBuilder.append(o.toBinaryPack());
        else
          throw new Error('Type "' + l.toString() + '" not yet supported');
      }
    else
      throw new Error('Type "' + c + '" not yet supported');
    this.bufferBuilder.flush();
  }, r.prototype.pack_bin = function(o) {
    var c = o.length || o.byteLength || o.size;
    if (c <= 15)
      this.pack_uint8(160 + c);
    else if (c <= 65535)
      this.bufferBuilder.append(218), this.pack_uint16(c);
    else if (c <= 4294967295)
      this.bufferBuilder.append(219), this.pack_uint32(c);
    else
      throw new Error("Invalid length");
    this.bufferBuilder.append(o);
  }, r.prototype.pack_string = function(o) {
    var c = a(o);
    if (c <= 15)
      this.pack_uint8(176 + c);
    else if (c <= 65535)
      this.bufferBuilder.append(216), this.pack_uint16(c);
    else if (c <= 4294967295)
      this.bufferBuilder.append(217), this.pack_uint32(c);
    else
      throw new Error("Invalid length");
    this.bufferBuilder.append(o);
  }, r.prototype.pack_array = function(o) {
    var c = o.length;
    if (c <= 15)
      this.pack_uint8(144 + c);
    else if (c <= 65535)
      this.bufferBuilder.append(220), this.pack_uint16(c);
    else if (c <= 4294967295)
      this.bufferBuilder.append(221), this.pack_uint32(c);
    else
      throw new Error("Invalid length");
    for (var l = 0; l < c; l++)
      this.pack(o[l]);
  }, r.prototype.pack_integer = function(o) {
    if (o >= -32 && o <= 127)
      this.bufferBuilder.append(o & 255);
    else if (o >= 0 && o <= 255)
      this.bufferBuilder.append(204), this.pack_uint8(o);
    else if (o >= -128 && o <= 127)
      this.bufferBuilder.append(208), this.pack_int8(o);
    else if (o >= 0 && o <= 65535)
      this.bufferBuilder.append(205), this.pack_uint16(o);
    else if (o >= -32768 && o <= 32767)
      this.bufferBuilder.append(209), this.pack_int16(o);
    else if (o >= 0 && o <= 4294967295)
      this.bufferBuilder.append(206), this.pack_uint32(o);
    else if (o >= -2147483648 && o <= 2147483647)
      this.bufferBuilder.append(210), this.pack_int32(o);
    else if (o >= -9223372036854776e3 && o <= 9223372036854776e3)
      this.bufferBuilder.append(211), this.pack_int64(o);
    else if (o >= 0 && o <= 18446744073709552e3)
      this.bufferBuilder.append(207), this.pack_uint64(o);
    else
      throw new Error("Invalid integer");
  }, r.prototype.pack_double = function(o) {
    var c = 0;
    o < 0 && (c = 1, o = -o);
    var l = Math.floor(Math.log(o) / Math.LN2), h = o / Math.pow(2, l) - 1, u = Math.floor(h * Math.pow(2, 52)), f = Math.pow(2, 32), d = c << 31 | l + 1023 << 20 | u / f & 1048575, y = u % f;
    this.bufferBuilder.append(203), this.pack_int32(d), this.pack_int32(y);
  }, r.prototype.pack_object = function(o) {
    var c = Object.keys(o), l = c.length;
    if (l <= 15)
      this.pack_uint8(128 + l);
    else if (l <= 65535)
      this.bufferBuilder.append(222), this.pack_uint16(l);
    else if (l <= 4294967295)
      this.bufferBuilder.append(223), this.pack_uint32(l);
    else
      throw new Error("Invalid length");
    for (var h in o)
      o.hasOwnProperty(h) && (this.pack(h), this.pack(o[h]));
  }, r.prototype.pack_uint8 = function(o) {
    this.bufferBuilder.append(o);
  }, r.prototype.pack_uint16 = function(o) {
    this.bufferBuilder.append(o >> 8), this.bufferBuilder.append(o & 255);
  }, r.prototype.pack_uint32 = function(o) {
    var c = o & 4294967295;
    this.bufferBuilder.append((c & 4278190080) >>> 24), this.bufferBuilder.append((c & 16711680) >>> 16), this.bufferBuilder.append((c & 65280) >>> 8), this.bufferBuilder.append(c & 255);
  }, r.prototype.pack_uint64 = function(o) {
    var c = o / Math.pow(2, 32), l = o % Math.pow(2, 32);
    this.bufferBuilder.append((c & 4278190080) >>> 24), this.bufferBuilder.append((c & 16711680) >>> 16), this.bufferBuilder.append((c & 65280) >>> 8), this.bufferBuilder.append(c & 255), this.bufferBuilder.append((l & 4278190080) >>> 24), this.bufferBuilder.append((l & 16711680) >>> 16), this.bufferBuilder.append((l & 65280) >>> 8), this.bufferBuilder.append(l & 255);
  }, r.prototype.pack_int8 = function(o) {
    this.bufferBuilder.append(o & 255);
  }, r.prototype.pack_int16 = function(o) {
    this.bufferBuilder.append((o & 65280) >> 8), this.bufferBuilder.append(o & 255);
  }, r.prototype.pack_int32 = function(o) {
    this.bufferBuilder.append(o >>> 24 & 255), this.bufferBuilder.append((o & 16711680) >>> 16), this.bufferBuilder.append((o & 65280) >>> 8), this.bufferBuilder.append(o & 255);
  }, r.prototype.pack_int64 = function(o) {
    var c = Math.floor(o / Math.pow(2, 32)), l = o % Math.pow(2, 32);
    this.bufferBuilder.append((c & 4278190080) >>> 24), this.bufferBuilder.append((c & 16711680) >>> 16), this.bufferBuilder.append((c & 65280) >>> 8), this.bufferBuilder.append(c & 255), this.bufferBuilder.append((l & 4278190080) >>> 24), this.bufferBuilder.append((l & 16711680) >>> 16), this.bufferBuilder.append((l & 65280) >>> 8), this.bufferBuilder.append(l & 255);
  };
  function s(o) {
    var c = o.charCodeAt(0);
    return c <= 2047 ? "00" : c <= 65535 ? "000" : c <= 2097151 ? "0000" : c <= 67108863 ? "00000" : "000000";
  }
  function a(o) {
    return o.length > 600 ? new Blob([o]).size : o.replace(/[^\u0000-\u007F]/g, s).length;
  }
  return cn;
}
var fc = uc();
const As = /* @__PURE__ */ Kr(fc);
let Lo = !0, Vo = !0;
function bi(n, t, e) {
  const i = n.match(t);
  return i && i.length >= e && parseInt(i[e], 10);
}
function ri(n, t, e) {
  if (!n.RTCPeerConnection)
    return;
  const i = n.RTCPeerConnection.prototype, r = i.addEventListener;
  i.addEventListener = function(a, o) {
    if (a !== t)
      return r.apply(this, arguments);
    const c = (l) => {
      const h = e(l);
      h && (o.handleEvent ? o.handleEvent(h) : o(h));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = /* @__PURE__ */ new Map()), this._eventMap[t].set(o, c), r.apply(this, [
      a,
      c
    ]);
  };
  const s = i.removeEventListener;
  i.removeEventListener = function(a, o) {
    if (a !== t || !this._eventMap || !this._eventMap[t])
      return s.apply(this, arguments);
    if (!this._eventMap[t].has(o))
      return s.apply(this, arguments);
    const c = this._eventMap[t].get(o);
    return this._eventMap[t].delete(o), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, s.apply(this, [
      a,
      c
    ]);
  }, Object.defineProperty(i, "on" + t, {
    get() {
      return this["_on" + t];
    },
    set(a) {
      this["_on" + t] && (this.removeEventListener(
        t,
        this["_on" + t]
      ), delete this["_on" + t]), a && this.addEventListener(
        t,
        this["_on" + t] = a
      );
    },
    enumerable: !0,
    configurable: !0
  });
}
function dc(n) {
  return typeof n != "boolean" ? new Error("Argument type: " + typeof n + ". Please use a boolean.") : (Lo = n, n ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function pc(n) {
  return typeof n != "boolean" ? new Error("Argument type: " + typeof n + ". Please use a boolean.") : (Vo = !n, "adapter.js deprecation warnings " + (n ? "disabled" : "enabled"));
}
function fs() {
  if (typeof window == "object") {
    if (Lo)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function Qr(n, t) {
  Vo && console.warn(n + " is deprecated, please use " + t + " instead.");
}
function mc(n) {
  const t = { browser: null, version: null };
  if (typeof n > "u" || !n.navigator)
    return t.browser = "Not a browser.", t;
  const { navigator: e } = n;
  if (e.mozGetUserMedia)
    t.browser = "firefox", t.version = bi(
      e.userAgent,
      /Firefox\/(\d+)\./,
      1
    );
  else if (e.webkitGetUserMedia || n.isSecureContext === !1 && n.webkitRTCPeerConnection && !n.RTCIceGatherer)
    t.browser = "chrome", t.version = bi(
      e.userAgent,
      /Chrom(e|ium)\/(\d+)\./,
      2
    );
  else if (e.mediaDevices && e.userAgent.match(/Edge\/(\d+).(\d+)$/))
    t.browser = "edge", t.version = bi(
      e.userAgent,
      /Edge\/(\d+).(\d+)$/,
      2
    );
  else if (n.RTCPeerConnection && e.userAgent.match(/AppleWebKit\/(\d+)\./))
    t.browser = "safari", t.version = bi(
      e.userAgent,
      /AppleWebKit\/(\d+)\./,
      1
    ), t.supportsUnifiedPlan = n.RTCRtpTransceiver && "currentDirection" in n.RTCRtpTransceiver.prototype;
  else
    return t.browser = "Not a supported browser.", t;
  return t;
}
function zs(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function Jo(n) {
  return zs(n) ? Object.keys(n).reduce(function(t, e) {
    const i = zs(n[e]), r = i ? Jo(n[e]) : n[e], s = i && !Object.keys(r).length;
    return r === void 0 || s ? t : Object.assign(t, { [e]: r });
  }, {}) : n;
}
function Vn(n, t, e) {
  !t || e.has(t.id) || (e.set(t.id, t), Object.keys(t).forEach((i) => {
    i.endsWith("Id") ? Vn(n, n.get(t[i]), e) : i.endsWith("Ids") && t[i].forEach((r) => {
      Vn(n, n.get(r), e);
    });
  }));
}
function Os(n, t, e) {
  const i = e ? "outbound-rtp" : "inbound-rtp", r = /* @__PURE__ */ new Map();
  if (t === null)
    return r;
  const s = [];
  return n.forEach((a) => {
    a.type === "track" && a.trackIdentifier === t.id && s.push(a);
  }), s.forEach((a) => {
    n.forEach((o) => {
      o.type === i && o.trackId === a.id && Vn(n, o, r);
    });
  }), r;
}
const Bs = fs;
function Go(n, t) {
  const e = n && n.navigator;
  if (!e.mediaDevices)
    return;
  const i = function(o) {
    if (typeof o != "object" || o.mandatory || o.optional)
      return o;
    const c = {};
    return Object.keys(o).forEach((l) => {
      if (l === "require" || l === "advanced" || l === "mediaSource")
        return;
      const h = typeof o[l] == "object" ? o[l] : { ideal: o[l] };
      h.exact !== void 0 && typeof h.exact == "number" && (h.min = h.max = h.exact);
      const u = function(f, d) {
        return f ? f + d.charAt(0).toUpperCase() + d.slice(1) : d === "deviceId" ? "sourceId" : d;
      };
      if (h.ideal !== void 0) {
        c.optional = c.optional || [];
        let f = {};
        typeof h.ideal == "number" ? (f[u("min", l)] = h.ideal, c.optional.push(f), f = {}, f[u("max", l)] = h.ideal, c.optional.push(f)) : (f[u("", l)] = h.ideal, c.optional.push(f));
      }
      h.exact !== void 0 && typeof h.exact != "number" ? (c.mandatory = c.mandatory || {}, c.mandatory[u("", l)] = h.exact) : ["min", "max"].forEach((f) => {
        h[f] !== void 0 && (c.mandatory = c.mandatory || {}, c.mandatory[u(f, l)] = h[f]);
      });
    }), o.advanced && (c.optional = (c.optional || []).concat(o.advanced)), c;
  }, r = function(o, c) {
    if (t.version >= 61)
      return c(o);
    if (o = JSON.parse(JSON.stringify(o)), o && typeof o.audio == "object") {
      const l = function(h, u, f) {
        u in h && !(f in h) && (h[f] = h[u], delete h[u]);
      };
      o = JSON.parse(JSON.stringify(o)), l(o.audio, "autoGainControl", "googAutoGainControl"), l(o.audio, "noiseSuppression", "googNoiseSuppression"), o.audio = i(o.audio);
    }
    if (o && typeof o.video == "object") {
      let l = o.video.facingMode;
      l = l && (typeof l == "object" ? l : { ideal: l });
      const h = t.version < 66;
      if (l && (l.exact === "user" || l.exact === "environment" || l.ideal === "user" || l.ideal === "environment") && !(e.mediaDevices.getSupportedConstraints && e.mediaDevices.getSupportedConstraints().facingMode && !h)) {
        delete o.video.facingMode;
        let u;
        if (l.exact === "environment" || l.ideal === "environment" ? u = ["back", "rear"] : (l.exact === "user" || l.ideal === "user") && (u = ["front"]), u)
          return e.mediaDevices.enumerateDevices().then((f) => {
            f = f.filter((y) => y.kind === "videoinput");
            let d = f.find((y) => u.some((_) => y.label.toLowerCase().includes(_)));
            return !d && f.length && u.includes("back") && (d = f[f.length - 1]), d && (o.video.deviceId = l.exact ? { exact: d.deviceId } : { ideal: d.deviceId }), o.video = i(o.video), Bs("chrome: " + JSON.stringify(o)), c(o);
          });
      }
      o.video = i(o.video);
    }
    return Bs("chrome: " + JSON.stringify(o)), c(o);
  }, s = function(o) {
    return t.version >= 64 ? o : {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[o.name] || o.name,
      message: o.message,
      constraint: o.constraint || o.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, a = function(o, c, l) {
    r(o, (h) => {
      e.webkitGetUserMedia(h, c, (u) => {
        l && l(s(u));
      });
    });
  };
  if (e.getUserMedia = a.bind(e), e.mediaDevices.getUserMedia) {
    const o = e.mediaDevices.getUserMedia.bind(e.mediaDevices);
    Object.getOwnPropertyDescriptor(e.mediaDevices, "getUserMedia")?.writable && (e.mediaDevices.getUserMedia = function(c) {
      return r(c, (l) => o(l).then((h) => {
        if (l.audio && !h.getAudioTracks().length || l.video && !h.getVideoTracks().length)
          throw h.getTracks().forEach((u) => {
            u.stop();
          }), new DOMException("", "NotFoundError");
        return h;
      }, (h) => Promise.reject(s(h))));
    });
  }
}
function yc(n, t) {
  if (!(n.navigator.mediaDevices && "getDisplayMedia" in n.navigator.mediaDevices) && n.navigator.mediaDevices) {
    if (typeof t != "function") {
      console.error("shimGetDisplayMedia: getSourceId argument is not a function");
      return;
    }
    n.navigator.mediaDevices.getDisplayMedia = function(i) {
      return t(i).then((r) => {
        const s = i.video && i.video.width, a = i.video && i.video.height, o = i.video && i.video.frameRate;
        return i.video = {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: r,
            maxFrameRate: o || 3
          }
        }, s && (i.video.mandatory.maxWidth = s), a && (i.video.mandatory.maxHeight = a), n.navigator.mediaDevices.getUserMedia(i);
      });
    };
  }
}
function jo(n) {
  n.MediaStream = n.MediaStream || n.webkitMediaStream;
}
function $o(n) {
  if (typeof n == "object" && n.RTCPeerConnection && !("ontrack" in n.RTCPeerConnection.prototype)) {
    Object.defineProperty(n.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(e) {
        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e);
      },
      enumerable: !0,
      configurable: !0
    });
    const t = n.RTCPeerConnection.prototype.setRemoteDescription;
    n.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (i) => {
        i.stream.addEventListener("addtrack", (r) => {
          let s;
          n.RTCPeerConnection.prototype.getReceivers ? s = this.getReceivers().find((o) => o.track && o.track.id === r.track.id) : s = { track: r.track };
          const a = new Event("track");
          a.track = r.track, a.receiver = s, a.transceiver = { receiver: s }, a.streams = [i.stream], this.dispatchEvent(a);
        }), i.stream.getTracks().forEach((r) => {
          let s;
          n.RTCPeerConnection.prototype.getReceivers ? s = this.getReceivers().find((o) => o.track && o.track.id === r.id) : s = { track: r };
          const a = new Event("track");
          a.track = r, a.receiver = s, a.transceiver = { receiver: s }, a.streams = [i.stream], this.dispatchEvent(a);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments);
    };
  } else
    ri(n, "track", (t) => (t.transceiver || Object.defineProperty(
      t,
      "transceiver",
      { value: { receiver: t.receiver } }
    ), t));
}
function qo(n) {
  if (typeof n == "object" && n.RTCPeerConnection && !("getSenders" in n.RTCPeerConnection.prototype) && "createDTMFSender" in n.RTCPeerConnection.prototype) {
    const t = function(r, s) {
      return {
        track: s,
        get dtmf() {
          return this._dtmf === void 0 && (s.kind === "audio" ? this._dtmf = r.createDTMFSender(s) : this._dtmf = null), this._dtmf;
        },
        _pc: r
      };
    };
    if (!n.RTCPeerConnection.prototype.getSenders) {
      n.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const r = n.RTCPeerConnection.prototype.addTrack;
      n.RTCPeerConnection.prototype.addTrack = function(o, c) {
        let l = r.apply(this, arguments);
        return l || (l = t(this, o), this._senders.push(l)), l;
      };
      const s = n.RTCPeerConnection.prototype.removeTrack;
      n.RTCPeerConnection.prototype.removeTrack = function(o) {
        s.apply(this, arguments);
        const c = this._senders.indexOf(o);
        c !== -1 && this._senders.splice(c, 1);
      };
    }
    const e = n.RTCPeerConnection.prototype.addStream;
    n.RTCPeerConnection.prototype.addStream = function(s) {
      this._senders = this._senders || [], e.apply(this, [s]), s.getTracks().forEach((a) => {
        this._senders.push(t(this, a));
      });
    };
    const i = n.RTCPeerConnection.prototype.removeStream;
    n.RTCPeerConnection.prototype.removeStream = function(s) {
      this._senders = this._senders || [], i.apply(this, [s]), s.getTracks().forEach((a) => {
        const o = this._senders.find((c) => c.track === a);
        o && this._senders.splice(this._senders.indexOf(o), 1);
      });
    };
  } else if (typeof n == "object" && n.RTCPeerConnection && "getSenders" in n.RTCPeerConnection.prototype && "createDTMFSender" in n.RTCPeerConnection.prototype && n.RTCRtpSender && !("dtmf" in n.RTCRtpSender.prototype)) {
    const t = n.RTCPeerConnection.prototype.getSenders;
    n.RTCPeerConnection.prototype.getSenders = function() {
      const i = t.apply(this, []);
      return i.forEach((r) => r._pc = this), i;
    }, Object.defineProperty(n.RTCRtpSender.prototype, "dtmf", {
      get() {
        return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
      }
    });
  }
}
function Xo(n) {
  if (!n.RTCPeerConnection)
    return;
  const t = n.RTCPeerConnection.prototype.getStats;
  n.RTCPeerConnection.prototype.getStats = function() {
    const [i, r, s] = arguments;
    if (arguments.length > 0 && typeof i == "function")
      return t.apply(this, arguments);
    if (t.length === 0 && (arguments.length === 0 || typeof i != "function"))
      return t.apply(this, []);
    const a = function(c) {
      const l = {};
      return c.result().forEach((u) => {
        const f = {
          id: u.id,
          timestamp: u.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[u.type] || u.type
        };
        u.names().forEach((d) => {
          f[d] = u.stat(d);
        }), l[f.id] = f;
      }), l;
    }, o = function(c) {
      return new Map(Object.keys(c).map((l) => [l, c[l]]));
    };
    if (arguments.length >= 2) {
      const c = function(l) {
        r(o(a(l)));
      };
      return t.apply(this, [
        c,
        i
      ]);
    }
    return new Promise((c, l) => {
      t.apply(this, [
        function(h) {
          c(o(a(h)));
        },
        l
      ]);
    }).then(r, s);
  };
}
function Ho(n) {
  if (!(typeof n == "object" && n.RTCPeerConnection && n.RTCRtpSender && n.RTCRtpReceiver))
    return;
  if (!("getStats" in n.RTCRtpSender.prototype)) {
    const e = n.RTCPeerConnection.prototype.getSenders;
    e && (n.RTCPeerConnection.prototype.getSenders = function() {
      const s = e.apply(this, []);
      return s.forEach((a) => a._pc = this), s;
    });
    const i = n.RTCPeerConnection.prototype.addTrack;
    i && (n.RTCPeerConnection.prototype.addTrack = function() {
      const s = i.apply(this, arguments);
      return s._pc = this, s;
    }), n.RTCRtpSender.prototype.getStats = function() {
      const s = this;
      return this._pc.getStats().then((a) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        Os(a, s.track, !0)
      ));
    };
  }
  if (!("getStats" in n.RTCRtpReceiver.prototype)) {
    const e = n.RTCPeerConnection.prototype.getReceivers;
    e && (n.RTCPeerConnection.prototype.getReceivers = function() {
      const r = e.apply(this, []);
      return r.forEach((s) => s._pc = this), r;
    }), ri(n, "track", (i) => (i.receiver._pc = i.srcElement, i)), n.RTCRtpReceiver.prototype.getStats = function() {
      const r = this;
      return this._pc.getStats().then((s) => Os(s, r.track, !1));
    };
  }
  if (!("getStats" in n.RTCRtpSender.prototype && "getStats" in n.RTCRtpReceiver.prototype))
    return;
  const t = n.RTCPeerConnection.prototype.getStats;
  n.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof n.MediaStreamTrack) {
      const i = arguments[0];
      let r, s, a;
      return this.getSenders().forEach((o) => {
        o.track === i && (r ? a = !0 : r = o);
      }), this.getReceivers().forEach((o) => (o.track === i && (s ? a = !0 : s = o), o.track === i)), a || r && s ? Promise.reject(new DOMException(
        "There are more than one sender or receiver for the track.",
        "InvalidAccessError"
      )) : r ? r.getStats() : s ? s.getStats() : Promise.reject(new DOMException(
        "There is no sender or receiver for the track.",
        "InvalidAccessError"
      ));
    }
    return t.apply(this, arguments);
  };
}
function Wo(n) {
  n.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((a) => this._shimmedLocalStreams[a][0]);
  };
  const t = n.RTCPeerConnection.prototype.addTrack;
  n.RTCPeerConnection.prototype.addTrack = function(a, o) {
    if (!o)
      return t.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const c = t.apply(this, arguments);
    return this._shimmedLocalStreams[o.id] ? this._shimmedLocalStreams[o.id].indexOf(c) === -1 && this._shimmedLocalStreams[o.id].push(c) : this._shimmedLocalStreams[o.id] = [o, c], c;
  };
  const e = n.RTCPeerConnection.prototype.addStream;
  n.RTCPeerConnection.prototype.addStream = function(a) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, a.getTracks().forEach((l) => {
      if (this.getSenders().find((u) => u.track === l))
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
    });
    const o = this.getSenders();
    e.apply(this, arguments);
    const c = this.getSenders().filter((l) => o.indexOf(l) === -1);
    this._shimmedLocalStreams[a.id] = [a].concat(c);
  };
  const i = n.RTCPeerConnection.prototype.removeStream;
  n.RTCPeerConnection.prototype.removeStream = function(a) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[a.id], i.apply(this, arguments);
  };
  const r = n.RTCPeerConnection.prototype.removeTrack;
  n.RTCPeerConnection.prototype.removeTrack = function(a) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, a && Object.keys(this._shimmedLocalStreams).forEach((o) => {
      const c = this._shimmedLocalStreams[o].indexOf(a);
      c !== -1 && this._shimmedLocalStreams[o].splice(c, 1), this._shimmedLocalStreams[o].length === 1 && delete this._shimmedLocalStreams[o];
    }), r.apply(this, arguments);
  };
}
function Yo(n, t) {
  if (!n.RTCPeerConnection)
    return;
  if (n.RTCPeerConnection.prototype.addTrack && t.version >= 65)
    return Wo(n);
  const e = n.RTCPeerConnection.prototype.getLocalStreams;
  n.RTCPeerConnection.prototype.getLocalStreams = function() {
    const h = e.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, h.map((u) => this._reverseStreams[u.id]);
  };
  const i = n.RTCPeerConnection.prototype.addStream;
  n.RTCPeerConnection.prototype.addStream = function(h) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, h.getTracks().forEach((u) => {
      if (this.getSenders().find((d) => d.track === u))
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
    }), !this._reverseStreams[h.id]) {
      const u = new n.MediaStream(h.getTracks());
      this._streams[h.id] = u, this._reverseStreams[u.id] = h, h = u;
    }
    i.apply(this, [h]);
  };
  const r = n.RTCPeerConnection.prototype.removeStream;
  n.RTCPeerConnection.prototype.removeStream = function(h) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r.apply(this, [this._streams[h.id] || h]), delete this._reverseStreams[this._streams[h.id] ? this._streams[h.id].id : h.id], delete this._streams[h.id];
  }, n.RTCPeerConnection.prototype.addTrack = function(h, u) {
    if (this.signalingState === "closed")
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    const f = [].slice.call(arguments, 1);
    if (f.length !== 1 || !f[0].getTracks().find((_) => _ === h))
      throw new DOMException(
        "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
        "NotSupportedError"
      );
    if (this.getSenders().find((_) => _.track === h))
      throw new DOMException(
        "Track already exists.",
        "InvalidAccessError"
      );
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const y = this._streams[u.id];
    if (y)
      y.addTrack(h), Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    else {
      const _ = new n.MediaStream([h]);
      this._streams[u.id] = _, this._reverseStreams[_.id] = u, this.addStream(_);
    }
    return this.getSenders().find((_) => _.track === h);
  };
  function s(l, h) {
    let u = h.sdp;
    return Object.keys(l._reverseStreams || []).forEach((f) => {
      const d = l._reverseStreams[f], y = l._streams[d.id];
      u = u.replace(
        new RegExp(y.id, "g"),
        d.id
      );
    }), new RTCSessionDescription({
      type: h.type,
      sdp: u
    });
  }
  function a(l, h) {
    let u = h.sdp;
    return Object.keys(l._reverseStreams || []).forEach((f) => {
      const d = l._reverseStreams[f], y = l._streams[d.id];
      u = u.replace(
        new RegExp(d.id, "g"),
        y.id
      );
    }), new RTCSessionDescription({
      type: h.type,
      sdp: u
    });
  }
  ["createOffer", "createAnswer"].forEach(function(l) {
    const h = n.RTCPeerConnection.prototype[l], u = { [l]() {
      const f = arguments;
      return arguments.length && typeof arguments[0] == "function" ? h.apply(this, [
        (y) => {
          const _ = s(this, y);
          f[0].apply(null, [_]);
        },
        (y) => {
          f[1] && f[1].apply(null, y);
        },
        arguments[2]
      ]) : h.apply(this, arguments).then((y) => s(this, y));
    } };
    n.RTCPeerConnection.prototype[l] = u[l];
  });
  const o = n.RTCPeerConnection.prototype.setLocalDescription;
  n.RTCPeerConnection.prototype.setLocalDescription = function() {
    return !arguments.length || !arguments[0].type ? o.apply(this, arguments) : (arguments[0] = a(this, arguments[0]), o.apply(this, arguments));
  };
  const c = Object.getOwnPropertyDescriptor(
    n.RTCPeerConnection.prototype,
    "localDescription"
  );
  Object.defineProperty(
    n.RTCPeerConnection.prototype,
    "localDescription",
    {
      get() {
        const l = c.get.apply(this);
        return l.type === "" ? l : s(this, l);
      }
    }
  ), n.RTCPeerConnection.prototype.removeTrack = function(h) {
    if (this.signalingState === "closed")
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    if (!h._pc)
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(h._pc === this))
      throw new DOMException(
        "Sender was not created by this connection.",
        "InvalidAccessError"
      );
    this._streams = this._streams || {};
    let f;
    Object.keys(this._streams).forEach((d) => {
      this._streams[d].getTracks().find((_) => h.track === _) && (f = this._streams[d]);
    }), f && (f.getTracks().length === 1 ? this.removeStream(this._reverseStreams[f.id]) : f.removeTrack(h.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function Jn(n, t) {
  !n.RTCPeerConnection && n.webkitRTCPeerConnection && (n.RTCPeerConnection = n.webkitRTCPeerConnection), n.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(e) {
    const i = n.RTCPeerConnection.prototype[e], r = { [e]() {
      return arguments[0] = new (e === "addIceCandidate" ? n.RTCIceCandidate : n.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);
    } };
    n.RTCPeerConnection.prototype[e] = r[e];
  });
}
function Zo(n, t) {
  ri(n, "negotiationneeded", (e) => {
    const i = e.target;
    if (!((t.version < 72 || i.getConfiguration && i.getConfiguration().sdpSemantics === "plan-b") && i.signalingState !== "stable"))
      return e;
  });
}
const Is = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fixNegotiationNeeded: Zo,
  shimAddTrackRemoveTrack: Yo,
  shimAddTrackRemoveTrackWithNative: Wo,
  shimGetDisplayMedia: yc,
  shimGetSendersWithDtmf: qo,
  shimGetStats: Xo,
  shimGetUserMedia: Go,
  shimMediaStream: jo,
  shimOnTrack: $o,
  shimPeerConnection: Jn,
  shimSenderReceiverGetStats: Ho
}, Symbol.toStringTag, { value: "Module" }));
function gc(n, t) {
  let e = !1;
  return n = JSON.parse(JSON.stringify(n)), n.filter((i) => {
    if (i && (i.urls || i.url)) {
      let r = i.urls || i.url;
      i.url && !i.urls && Qr("RTCIceServer.url", "RTCIceServer.urls");
      const s = typeof r == "string";
      return s && (r = [r]), r = r.filter((a) => {
        if (a.indexOf("stun:") === 0)
          return !1;
        const o = a.startsWith("turn") && !a.startsWith("turn:[") && a.includes("transport=udp");
        return o && !e ? (e = !0, !0) : o && !e;
      }), delete i.url, i.urls = s ? r[0] : r, !!r.length;
    }
  });
}
var ln = { exports: {} }, Ns;
function Ko() {
  return Ns || (Ns = 1, (function(n) {
    var t = {};
    t.generateIdentifier = function() {
      return Math.random().toString(36).substr(2, 10);
    }, t.localCName = t.generateIdentifier(), t.splitLines = function(e) {
      return e.trim().split(`
`).map(function(i) {
        return i.trim();
      });
    }, t.splitSections = function(e) {
      var i = e.split(`
m=`);
      return i.map(function(r, s) {
        return (s > 0 ? "m=" + r : r).trim() + `\r
`;
      });
    }, t.getDescription = function(e) {
      var i = t.splitSections(e);
      return i && i[0];
    }, t.getMediaSections = function(e) {
      var i = t.splitSections(e);
      return i.shift(), i;
    }, t.matchPrefix = function(e, i) {
      return t.splitLines(e).filter(function(r) {
        return r.indexOf(i) === 0;
      });
    }, t.parseCandidate = function(e) {
      var i;
      e.indexOf("a=candidate:") === 0 ? i = e.substring(12).split(" ") : i = e.substring(10).split(" ");
      for (var r = {
        foundation: i[0],
        component: parseInt(i[1], 10),
        protocol: i[2].toLowerCase(),
        priority: parseInt(i[3], 10),
        ip: i[4],
        address: i[4],
        // address is an alias for ip.
        port: parseInt(i[5], 10),
        // skip parts[6] == 'typ'
        type: i[7]
      }, s = 8; s < i.length; s += 2)
        switch (i[s]) {
          case "raddr":
            r.relatedAddress = i[s + 1];
            break;
          case "rport":
            r.relatedPort = parseInt(i[s + 1], 10);
            break;
          case "tcptype":
            r.tcpType = i[s + 1];
            break;
          case "ufrag":
            r.ufrag = i[s + 1], r.usernameFragment = i[s + 1];
            break;
          default:
            r[i[s]] = i[s + 1];
            break;
        }
      return r;
    }, t.writeCandidate = function(e) {
      var i = [];
      i.push(e.foundation), i.push(e.component), i.push(e.protocol.toUpperCase()), i.push(e.priority), i.push(e.address || e.ip), i.push(e.port);
      var r = e.type;
      return i.push("typ"), i.push(r), r !== "host" && e.relatedAddress && e.relatedPort && (i.push("raddr"), i.push(e.relatedAddress), i.push("rport"), i.push(e.relatedPort)), e.tcpType && e.protocol.toLowerCase() === "tcp" && (i.push("tcptype"), i.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (i.push("ufrag"), i.push(e.usernameFragment || e.ufrag)), "candidate:" + i.join(" ");
    }, t.parseIceOptions = function(e) {
      return e.substr(14).split(" ");
    }, t.parseRtpMap = function(e) {
      var i = e.substr(9).split(" "), r = {
        payloadType: parseInt(i.shift(), 10)
        // was: id
      };
      return i = i[0].split("/"), r.name = i[0], r.clockRate = parseInt(i[1], 10), r.channels = i.length === 3 ? parseInt(i[2], 10) : 1, r.numChannels = r.channels, r;
    }, t.writeRtpMap = function(e) {
      var i = e.payloadType;
      e.preferredPayloadType !== void 0 && (i = e.preferredPayloadType);
      var r = e.channels || e.numChannels || 1;
      return "a=rtpmap:" + i + " " + e.name + "/" + e.clockRate + (r !== 1 ? "/" + r : "") + `\r
`;
    }, t.parseExtmap = function(e) {
      var i = e.substr(9).split(" ");
      return {
        id: parseInt(i[0], 10),
        direction: i[0].indexOf("/") > 0 ? i[0].split("/")[1] : "sendrecv",
        uri: i[1]
      };
    }, t.writeExtmap = function(e) {
      return "a=extmap:" + (e.id || e.preferredId) + (e.direction && e.direction !== "sendrecv" ? "/" + e.direction : "") + " " + e.uri + `\r
`;
    }, t.parseFmtp = function(e) {
      for (var i = {}, r, s = e.substr(e.indexOf(" ") + 1).split(";"), a = 0; a < s.length; a++)
        r = s[a].trim().split("="), i[r[0].trim()] = r[1];
      return i;
    }, t.writeFmtp = function(e) {
      var i = "", r = e.payloadType;
      if (e.preferredPayloadType !== void 0 && (r = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
        var s = [];
        Object.keys(e.parameters).forEach(function(a) {
          e.parameters[a] ? s.push(a + "=" + e.parameters[a]) : s.push(a);
        }), i += "a=fmtp:" + r + " " + s.join(";") + `\r
`;
      }
      return i;
    }, t.parseRtcpFb = function(e) {
      var i = e.substr(e.indexOf(" ") + 1).split(" ");
      return {
        type: i.shift(),
        parameter: i.join(" ")
      };
    }, t.writeRtcpFb = function(e) {
      var i = "", r = e.payloadType;
      return e.preferredPayloadType !== void 0 && (r = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function(s) {
        i += "a=rtcp-fb:" + r + " " + s.type + (s.parameter && s.parameter.length ? " " + s.parameter : "") + `\r
`;
      }), i;
    }, t.parseSsrcMedia = function(e) {
      var i = e.indexOf(" "), r = {
        ssrc: parseInt(e.substr(7, i - 7), 10)
      }, s = e.indexOf(":", i);
      return s > -1 ? (r.attribute = e.substr(i + 1, s - i - 1), r.value = e.substr(s + 1)) : r.attribute = e.substr(i + 1), r;
    }, t.parseSsrcGroup = function(e) {
      var i = e.substr(13).split(" ");
      return {
        semantics: i.shift(),
        ssrcs: i.map(function(r) {
          return parseInt(r, 10);
        })
      };
    }, t.getMid = function(e) {
      var i = t.matchPrefix(e, "a=mid:")[0];
      if (i)
        return i.substr(6);
    }, t.parseFingerprint = function(e) {
      var i = e.substr(14).split(" ");
      return {
        algorithm: i[0].toLowerCase(),
        // algorithm is case-sensitive in Edge.
        value: i[1]
      };
    }, t.getDtlsParameters = function(e, i) {
      var r = t.matchPrefix(
        e + i,
        "a=fingerprint:"
      );
      return {
        role: "auto",
        fingerprints: r.map(t.parseFingerprint)
      };
    }, t.writeDtlsParameters = function(e, i) {
      var r = "a=setup:" + i + `\r
`;
      return e.fingerprints.forEach(function(s) {
        r += "a=fingerprint:" + s.algorithm + " " + s.value + `\r
`;
      }), r;
    }, t.parseCryptoLine = function(e) {
      var i = e.substr(9).split(" ");
      return {
        tag: parseInt(i[0], 10),
        cryptoSuite: i[1],
        keyParams: i[2],
        sessionParams: i.slice(3)
      };
    }, t.writeCryptoLine = function(e) {
      return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + (typeof e.keyParams == "object" ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + `\r
`;
    }, t.parseCryptoKeyParams = function(e) {
      if (e.indexOf("inline:") !== 0)
        return null;
      var i = e.substr(7).split("|");
      return {
        keyMethod: "inline",
        keySalt: i[0],
        lifeTime: i[1],
        mkiValue: i[2] ? i[2].split(":")[0] : void 0,
        mkiLength: i[2] ? i[2].split(":")[1] : void 0
      };
    }, t.writeCryptoKeyParams = function(e) {
      return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "");
    }, t.getCryptoParameters = function(e, i) {
      var r = t.matchPrefix(
        e + i,
        "a=crypto:"
      );
      return r.map(t.parseCryptoLine);
    }, t.getIceParameters = function(e, i) {
      var r = t.matchPrefix(
        e + i,
        "a=ice-ufrag:"
      )[0], s = t.matchPrefix(
        e + i,
        "a=ice-pwd:"
      )[0];
      return r && s ? {
        usernameFragment: r.substr(12),
        password: s.substr(10)
      } : null;
    }, t.writeIceParameters = function(e) {
      return "a=ice-ufrag:" + e.usernameFragment + `\r
a=ice-pwd:` + e.password + `\r
`;
    }, t.parseRtpParameters = function(e) {
      for (var i = {
        codecs: [],
        headerExtensions: [],
        fecMechanisms: [],
        rtcp: []
      }, r = t.splitLines(e), s = r[0].split(" "), a = 3; a < s.length; a++) {
        var o = s[a], c = t.matchPrefix(
          e,
          "a=rtpmap:" + o + " "
        )[0];
        if (c) {
          var l = t.parseRtpMap(c), h = t.matchPrefix(
            e,
            "a=fmtp:" + o + " "
          );
          switch (l.parameters = h.length ? t.parseFmtp(h[0]) : {}, l.rtcpFeedback = t.matchPrefix(
            e,
            "a=rtcp-fb:" + o + " "
          ).map(t.parseRtcpFb), i.codecs.push(l), l.name.toUpperCase()) {
            case "RED":
            case "ULPFEC":
              i.fecMechanisms.push(l.name.toUpperCase());
              break;
          }
        }
      }
      return t.matchPrefix(e, "a=extmap:").forEach(function(u) {
        i.headerExtensions.push(t.parseExtmap(u));
      }), i;
    }, t.writeRtpDescription = function(e, i) {
      var r = "";
      r += "m=" + e + " ", r += i.codecs.length > 0 ? "9" : "0", r += " UDP/TLS/RTP/SAVPF ", r += i.codecs.map(function(a) {
        return a.preferredPayloadType !== void 0 ? a.preferredPayloadType : a.payloadType;
      }).join(" ") + `\r
`, r += `c=IN IP4 0.0.0.0\r
`, r += `a=rtcp:9 IN IP4 0.0.0.0\r
`, i.codecs.forEach(function(a) {
        r += t.writeRtpMap(a), r += t.writeFmtp(a), r += t.writeRtcpFb(a);
      });
      var s = 0;
      return i.codecs.forEach(function(a) {
        a.maxptime > s && (s = a.maxptime);
      }), s > 0 && (r += "a=maxptime:" + s + `\r
`), r += `a=rtcp-mux\r
`, i.headerExtensions && i.headerExtensions.forEach(function(a) {
        r += t.writeExtmap(a);
      }), r;
    }, t.parseRtpEncodingParameters = function(e) {
      var i = [], r = t.parseRtpParameters(e), s = r.fecMechanisms.indexOf("RED") !== -1, a = r.fecMechanisms.indexOf("ULPFEC") !== -1, o = t.matchPrefix(e, "a=ssrc:").map(function(f) {
        return t.parseSsrcMedia(f);
      }).filter(function(f) {
        return f.attribute === "cname";
      }), c = o.length > 0 && o[0].ssrc, l, h = t.matchPrefix(e, "a=ssrc-group:FID").map(function(f) {
        var d = f.substr(17).split(" ");
        return d.map(function(y) {
          return parseInt(y, 10);
        });
      });
      h.length > 0 && h[0].length > 1 && h[0][0] === c && (l = h[0][1]), r.codecs.forEach(function(f) {
        if (f.name.toUpperCase() === "RTX" && f.parameters.apt) {
          var d = {
            ssrc: c,
            codecPayloadType: parseInt(f.parameters.apt, 10)
          };
          c && l && (d.rtx = { ssrc: l }), i.push(d), s && (d = JSON.parse(JSON.stringify(d)), d.fec = {
            ssrc: c,
            mechanism: a ? "red+ulpfec" : "red"
          }, i.push(d));
        }
      }), i.length === 0 && c && i.push({
        ssrc: c
      });
      var u = t.matchPrefix(e, "b=");
      return u.length && (u[0].indexOf("b=TIAS:") === 0 ? u = parseInt(u[0].substr(7), 10) : u[0].indexOf("b=AS:") === 0 ? u = parseInt(u[0].substr(5), 10) * 1e3 * 0.95 - 2e3 * 8 : u = void 0, i.forEach(function(f) {
        f.maxBitrate = u;
      })), i;
    }, t.parseRtcpParameters = function(e) {
      var i = {}, r = t.matchPrefix(e, "a=ssrc:").map(function(o) {
        return t.parseSsrcMedia(o);
      }).filter(function(o) {
        return o.attribute === "cname";
      })[0];
      r && (i.cname = r.value, i.ssrc = r.ssrc);
      var s = t.matchPrefix(e, "a=rtcp-rsize");
      i.reducedSize = s.length > 0, i.compound = s.length === 0;
      var a = t.matchPrefix(e, "a=rtcp-mux");
      return i.mux = a.length > 0, i;
    }, t.parseMsid = function(e) {
      var i, r = t.matchPrefix(e, "a=msid:");
      if (r.length === 1)
        return i = r[0].substr(7).split(" "), { stream: i[0], track: i[1] };
      var s = t.matchPrefix(e, "a=ssrc:").map(function(a) {
        return t.parseSsrcMedia(a);
      }).filter(function(a) {
        return a.attribute === "msid";
      });
      if (s.length > 0)
        return i = s[0].value.split(" "), { stream: i[0], track: i[1] };
    }, t.parseSctpDescription = function(e) {
      var i = t.parseMLine(e), r = t.matchPrefix(e, "a=max-message-size:"), s;
      r.length > 0 && (s = parseInt(r[0].substr(19), 10)), isNaN(s) && (s = 65536);
      var a = t.matchPrefix(e, "a=sctp-port:");
      if (a.length > 0)
        return {
          port: parseInt(a[0].substr(12), 10),
          protocol: i.fmt,
          maxMessageSize: s
        };
      var o = t.matchPrefix(e, "a=sctpmap:");
      if (o.length > 0) {
        var c = t.matchPrefix(e, "a=sctpmap:")[0].substr(10).split(" ");
        return {
          port: parseInt(c[0], 10),
          protocol: c[1],
          maxMessageSize: s
        };
      }
    }, t.writeSctpDescription = function(e, i) {
      var r = [];
      return e.protocol !== "DTLS/SCTP" ? r = [
        "m=" + e.kind + " 9 " + e.protocol + " " + i.protocol + `\r
`,
        `c=IN IP4 0.0.0.0\r
`,
        "a=sctp-port:" + i.port + `\r
`
      ] : r = [
        "m=" + e.kind + " 9 " + e.protocol + " " + i.port + `\r
`,
        `c=IN IP4 0.0.0.0\r
`,
        "a=sctpmap:" + i.port + " " + i.protocol + ` 65535\r
`
      ], i.maxMessageSize !== void 0 && r.push("a=max-message-size:" + i.maxMessageSize + `\r
`), r.join("");
    }, t.generateSessionId = function() {
      return Math.random().toString().substr(2, 21);
    }, t.writeSessionBoilerplate = function(e, i, r) {
      var s, a = i !== void 0 ? i : 2;
      e ? s = e : s = t.generateSessionId();
      var o = r || "thisisadapterortc";
      return `v=0\r
o=` + o + " " + s + " " + a + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
    }, t.writeMediaSection = function(e, i, r, s) {
      var a = t.writeRtpDescription(e.kind, i);
      if (a += t.writeIceParameters(
        e.iceGatherer.getLocalParameters()
      ), a += t.writeDtlsParameters(
        e.dtlsTransport.getLocalParameters(),
        r === "offer" ? "actpass" : "active"
      ), a += "a=mid:" + e.mid + `\r
`, e.direction ? a += "a=" + e.direction + `\r
` : e.rtpSender && e.rtpReceiver ? a += `a=sendrecv\r
` : e.rtpSender ? a += `a=sendonly\r
` : e.rtpReceiver ? a += `a=recvonly\r
` : a += `a=inactive\r
`, e.rtpSender) {
        var o = "msid:" + s.id + " " + e.rtpSender.track.id + `\r
`;
        a += "a=" + o, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + o, e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + o, a += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + `\r
`);
      }
      return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + t.localCName + `\r
`, e.rtpSender && e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + t.localCName + `\r
`), a;
    }, t.getDirection = function(e, i) {
      for (var r = t.splitLines(e), s = 0; s < r.length; s++)
        switch (r[s]) {
          case "a=sendrecv":
          case "a=sendonly":
          case "a=recvonly":
          case "a=inactive":
            return r[s].substr(2);
        }
      return i ? t.getDirection(i) : "sendrecv";
    }, t.getKind = function(e) {
      var i = t.splitLines(e), r = i[0].split(" ");
      return r[0].substr(2);
    }, t.isRejected = function(e) {
      return e.split(" ", 2)[1] === "0";
    }, t.parseMLine = function(e) {
      var i = t.splitLines(e), r = i[0].substr(2).split(" ");
      return {
        kind: r[0],
        port: parseInt(r[1], 10),
        protocol: r[2],
        fmt: r.slice(3).join(" ")
      };
    }, t.parseOLine = function(e) {
      var i = t.matchPrefix(e, "o=")[0], r = i.substr(2).split(" ");
      return {
        username: r[0],
        sessionId: r[1],
        sessionVersion: parseInt(r[2], 10),
        netType: r[3],
        addressType: r[4],
        address: r[5]
      };
    }, t.isValidSDP = function(e) {
      if (typeof e != "string" || e.length === 0)
        return !1;
      for (var i = t.splitLines(e), r = 0; r < i.length; r++)
        if (i[r].length < 2 || i[r].charAt(1) !== "=")
          return !1;
      return !0;
    }, n.exports = t;
  })(ln)), ln.exports;
}
var hn, Us;
function vc() {
  if (Us) return hn;
  Us = 1;
  var n = Ko();
  function t(c) {
    return {
      inboundrtp: "inbound-rtp",
      outboundrtp: "outbound-rtp",
      candidatepair: "candidate-pair",
      localcandidate: "local-candidate",
      remotecandidate: "remote-candidate"
    }[c.type] || c.type;
  }
  function e(c, l, h, u, f) {
    var d = n.writeRtpDescription(c.kind, l);
    if (d += n.writeIceParameters(
      c.iceGatherer.getLocalParameters()
    ), d += n.writeDtlsParameters(
      c.dtlsTransport.getLocalParameters(),
      h === "offer" ? "actpass" : f || "active"
    ), d += "a=mid:" + c.mid + `\r
`, c.rtpSender && c.rtpReceiver ? d += `a=sendrecv\r
` : c.rtpSender ? d += `a=sendonly\r
` : c.rtpReceiver ? d += `a=recvonly\r
` : d += `a=inactive\r
`, c.rtpSender) {
      var y = c.rtpSender._initialTrackId || c.rtpSender.track.id;
      c.rtpSender._initialTrackId = y;
      var _ = "msid:" + (u ? u.id : "-") + " " + y + `\r
`;
      d += "a=" + _, d += "a=ssrc:" + c.sendEncodingParameters[0].ssrc + " " + _, c.sendEncodingParameters[0].rtx && (d += "a=ssrc:" + c.sendEncodingParameters[0].rtx.ssrc + " " + _, d += "a=ssrc-group:FID " + c.sendEncodingParameters[0].ssrc + " " + c.sendEncodingParameters[0].rtx.ssrc + `\r
`);
    }
    return d += "a=ssrc:" + c.sendEncodingParameters[0].ssrc + " cname:" + n.localCName + `\r
`, c.rtpSender && c.sendEncodingParameters[0].rtx && (d += "a=ssrc:" + c.sendEncodingParameters[0].rtx.ssrc + " cname:" + n.localCName + `\r
`), d;
  }
  function i(c, l) {
    var h = !1;
    return c = JSON.parse(JSON.stringify(c)), c.filter(function(u) {
      if (u && (u.urls || u.url)) {
        var f = u.urls || u.url;
        u.url && !u.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead.");
        var d = typeof f == "string";
        return d && (f = [f]), f = f.filter(function(y) {
          var _ = y.indexOf("turn:") === 0 && y.indexOf("transport=udp") !== -1 && y.indexOf("turn:[") === -1 && !h;
          return _ ? (h = !0, !0) : y.indexOf("stun:") === 0 && l >= 14393 && y.indexOf("?transport=udp") === -1;
        }), delete u.url, u.urls = d ? f[0] : f, !!f.length;
      }
    });
  }
  function r(c, l) {
    var h = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: []
    }, u = function(d, y) {
      d = parseInt(d, 10);
      for (var _ = 0; _ < y.length; _++)
        if (y[_].payloadType === d || y[_].preferredPayloadType === d)
          return y[_];
    }, f = function(d, y, _, p) {
      var m = u(d.parameters.apt, _), v = u(y.parameters.apt, p);
      return m && v && m.name.toLowerCase() === v.name.toLowerCase();
    };
    return c.codecs.forEach(function(d) {
      for (var y = 0; y < l.codecs.length; y++) {
        var _ = l.codecs[y];
        if (d.name.toLowerCase() === _.name.toLowerCase() && d.clockRate === _.clockRate) {
          if (d.name.toLowerCase() === "rtx" && d.parameters && _.parameters.apt && !f(
            d,
            _,
            c.codecs,
            l.codecs
          ))
            continue;
          _ = JSON.parse(JSON.stringify(_)), _.numChannels = Math.min(
            d.numChannels,
            _.numChannels
          ), h.codecs.push(_), _.rtcpFeedback = _.rtcpFeedback.filter(function(p) {
            for (var m = 0; m < d.rtcpFeedback.length; m++)
              if (d.rtcpFeedback[m].type === p.type && d.rtcpFeedback[m].parameter === p.parameter)
                return !0;
            return !1;
          });
          break;
        }
      }
    }), c.headerExtensions.forEach(function(d) {
      for (var y = 0; y < l.headerExtensions.length; y++) {
        var _ = l.headerExtensions[y];
        if (d.uri === _.uri) {
          h.headerExtensions.push(_);
          break;
        }
      }
    }), h;
  }
  function s(c, l, h) {
    return {
      offer: {
        setLocalDescription: ["stable", "have-local-offer"],
        setRemoteDescription: ["stable", "have-remote-offer"]
      },
      answer: {
        setLocalDescription: ["have-remote-offer", "have-local-pranswer"],
        setRemoteDescription: ["have-local-offer", "have-remote-pranswer"]
      }
    }[l][c].indexOf(h) !== -1;
  }
  function a(c, l) {
    var h = c.getRemoteCandidates().find(function(u) {
      return l.foundation === u.foundation && l.ip === u.ip && l.port === u.port && l.priority === u.priority && l.protocol === u.protocol && l.type === u.type;
    });
    return h || c.addRemoteCandidate(l), !h;
  }
  function o(c, l) {
    var h = new Error(l);
    return h.name = c, h.code = {
      NotSupportedError: 9,
      InvalidStateError: 11,
      InvalidAccessError: 15,
      TypeError: void 0,
      OperationError: void 0
    }[c], h;
  }
  return hn = function(c, l) {
    function h(p, m) {
      m.addTrack(p), m.dispatchEvent(new c.MediaStreamTrackEvent(
        "addtrack",
        { track: p }
      ));
    }
    function u(p, m) {
      m.removeTrack(p), m.dispatchEvent(new c.MediaStreamTrackEvent(
        "removetrack",
        { track: p }
      ));
    }
    function f(p, m, v, g) {
      var b = new Event("track");
      b.track = m, b.receiver = v, b.transceiver = { receiver: v }, b.streams = g, c.setTimeout(function() {
        p._dispatchEvent("track", b);
      });
    }
    var d = function(p) {
      var m = this, v = document.createDocumentFragment();
      if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(b) {
        m[b] = v[b].bind(v);
      }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", p = JSON.parse(JSON.stringify(p || {})), this.usingBundle = p.bundlePolicy === "max-bundle", p.rtcpMuxPolicy === "negotiate")
        throw o(
          "NotSupportedError",
          "rtcpMuxPolicy 'negotiate' is not supported"
        );
      switch (p.rtcpMuxPolicy || (p.rtcpMuxPolicy = "require"), p.iceTransportPolicy) {
        case "all":
        case "relay":
          break;
        default:
          p.iceTransportPolicy = "all";
          break;
      }
      switch (p.bundlePolicy) {
        case "balanced":
        case "max-compat":
        case "max-bundle":
          break;
        default:
          p.bundlePolicy = "balanced";
          break;
      }
      if (p.iceServers = i(p.iceServers || [], l), this._iceGatherers = [], p.iceCandidatePoolSize)
        for (var g = p.iceCandidatePoolSize; g > 0; g--)
          this._iceGatherers.push(new c.RTCIceGatherer({
            iceServers: p.iceServers,
            gatherPolicy: p.iceTransportPolicy
          }));
      else
        p.iceCandidatePoolSize = 0;
      this._config = p, this.transceivers = [], this._sdpSessionId = n.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1;
    };
    Object.defineProperty(d.prototype, "localDescription", {
      configurable: !0,
      get: function() {
        return this._localDescription;
      }
    }), Object.defineProperty(d.prototype, "remoteDescription", {
      configurable: !0,
      get: function() {
        return this._remoteDescription;
      }
    }), d.prototype.onicecandidate = null, d.prototype.onaddstream = null, d.prototype.ontrack = null, d.prototype.onremovestream = null, d.prototype.onsignalingstatechange = null, d.prototype.oniceconnectionstatechange = null, d.prototype.onconnectionstatechange = null, d.prototype.onicegatheringstatechange = null, d.prototype.onnegotiationneeded = null, d.prototype.ondatachannel = null, d.prototype._dispatchEvent = function(p, m) {
      this._isClosed || (this.dispatchEvent(m), typeof this["on" + p] == "function" && this["on" + p](m));
    }, d.prototype._emitGatheringStateChange = function() {
      var p = new Event("icegatheringstatechange");
      this._dispatchEvent("icegatheringstatechange", p);
    }, d.prototype.getConfiguration = function() {
      return this._config;
    }, d.prototype.getLocalStreams = function() {
      return this.localStreams;
    }, d.prototype.getRemoteStreams = function() {
      return this.remoteStreams;
    }, d.prototype._createTransceiver = function(p, m) {
      var v = this.transceivers.length > 0, g = {
        track: null,
        iceGatherer: null,
        iceTransport: null,
        dtlsTransport: null,
        localCapabilities: null,
        remoteCapabilities: null,
        rtpSender: null,
        rtpReceiver: null,
        kind: p,
        mid: null,
        sendEncodingParameters: null,
        recvEncodingParameters: null,
        stream: null,
        associatedRemoteMediaStreams: [],
        wantReceive: !0
      };
      if (this.usingBundle && v)
        g.iceTransport = this.transceivers[0].iceTransport, g.dtlsTransport = this.transceivers[0].dtlsTransport;
      else {
        var b = this._createIceAndDtlsTransports();
        g.iceTransport = b.iceTransport, g.dtlsTransport = b.dtlsTransport;
      }
      return m || this.transceivers.push(g), g;
    }, d.prototype.addTrack = function(p, m) {
      if (this._isClosed)
        throw o(
          "InvalidStateError",
          "Attempted to call addTrack on a closed peerconnection."
        );
      var v = this.transceivers.find(function(x) {
        return x.track === p;
      });
      if (v)
        throw o("InvalidAccessError", "Track already exists.");
      for (var g, b = 0; b < this.transceivers.length; b++)
        !this.transceivers[b].track && this.transceivers[b].kind === p.kind && (g = this.transceivers[b]);
      return g || (g = this._createTransceiver(p.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(m) === -1 && this.localStreams.push(m), g.track = p, g.stream = m, g.rtpSender = new c.RTCRtpSender(
        p,
        g.dtlsTransport
      ), g.rtpSender;
    }, d.prototype.addStream = function(p) {
      var m = this;
      if (l >= 15025)
        p.getTracks().forEach(function(g) {
          m.addTrack(g, p);
        });
      else {
        var v = p.clone();
        p.getTracks().forEach(function(g, b) {
          var x = v.getTracks()[b];
          g.addEventListener("enabled", function(S) {
            x.enabled = S.enabled;
          });
        }), v.getTracks().forEach(function(g) {
          m.addTrack(g, v);
        });
      }
    }, d.prototype.removeTrack = function(p) {
      if (this._isClosed)
        throw o(
          "InvalidStateError",
          "Attempted to call removeTrack on a closed peerconnection."
        );
      if (!(p instanceof c.RTCRtpSender))
        throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
      var m = this.transceivers.find(function(b) {
        return b.rtpSender === p;
      });
      if (!m)
        throw o(
          "InvalidAccessError",
          "Sender was not created by this connection."
        );
      var v = m.stream;
      m.rtpSender.stop(), m.rtpSender = null, m.track = null, m.stream = null;
      var g = this.transceivers.map(function(b) {
        return b.stream;
      });
      g.indexOf(v) === -1 && this.localStreams.indexOf(v) > -1 && this.localStreams.splice(this.localStreams.indexOf(v), 1), this._maybeFireNegotiationNeeded();
    }, d.prototype.removeStream = function(p) {
      var m = this;
      p.getTracks().forEach(function(v) {
        var g = m.getSenders().find(function(b) {
          return b.track === v;
        });
        g && m.removeTrack(g);
      });
    }, d.prototype.getSenders = function() {
      return this.transceivers.filter(function(p) {
        return !!p.rtpSender;
      }).map(function(p) {
        return p.rtpSender;
      });
    }, d.prototype.getReceivers = function() {
      return this.transceivers.filter(function(p) {
        return !!p.rtpReceiver;
      }).map(function(p) {
        return p.rtpReceiver;
      });
    }, d.prototype._createIceGatherer = function(p, m) {
      var v = this;
      if (m && p > 0)
        return this.transceivers[0].iceGatherer;
      if (this._iceGatherers.length)
        return this._iceGatherers.shift();
      var g = new c.RTCIceGatherer({
        iceServers: this._config.iceServers,
        gatherPolicy: this._config.iceTransportPolicy
      });
      return Object.defineProperty(
        g,
        "state",
        { value: "new", writable: !0 }
      ), this.transceivers[p].bufferedCandidateEvents = [], this.transceivers[p].bufferCandidates = function(b) {
        var x = !b.candidate || Object.keys(b.candidate).length === 0;
        g.state = x ? "completed" : "gathering", v.transceivers[p].bufferedCandidateEvents !== null && v.transceivers[p].bufferedCandidateEvents.push(b);
      }, g.addEventListener(
        "localcandidate",
        this.transceivers[p].bufferCandidates
      ), g;
    }, d.prototype._gather = function(p, m) {
      var v = this, g = this.transceivers[m].iceGatherer;
      if (!g.onlocalcandidate) {
        var b = this.transceivers[m].bufferedCandidateEvents;
        this.transceivers[m].bufferedCandidateEvents = null, g.removeEventListener(
          "localcandidate",
          this.transceivers[m].bufferCandidates
        ), g.onlocalcandidate = function(x) {
          if (!(v.usingBundle && m > 0)) {
            var S = new Event("icecandidate");
            S.candidate = { sdpMid: p, sdpMLineIndex: m };
            var T = x.candidate, P = !T || Object.keys(T).length === 0;
            if (P)
              (g.state === "new" || g.state === "gathering") && (g.state = "completed");
            else {
              g.state === "new" && (g.state = "gathering"), T.component = 1, T.ufrag = g.getLocalParameters().usernameFragment;
              var M = n.writeCandidate(T);
              S.candidate = Object.assign(
                S.candidate,
                n.parseCandidate(M)
              ), S.candidate.candidate = M, S.candidate.toJSON = function() {
                return {
                  candidate: S.candidate.candidate,
                  sdpMid: S.candidate.sdpMid,
                  sdpMLineIndex: S.candidate.sdpMLineIndex,
                  usernameFragment: S.candidate.usernameFragment
                };
              };
            }
            var C = n.getMediaSections(v._localDescription.sdp);
            P ? C[S.candidate.sdpMLineIndex] += `a=end-of-candidates\r
` : C[S.candidate.sdpMLineIndex] += "a=" + S.candidate.candidate + `\r
`, v._localDescription.sdp = n.getDescription(v._localDescription.sdp) + C.join("");
            var E = v.transceivers.every(function(w) {
              return w.iceGatherer && w.iceGatherer.state === "completed";
            });
            v.iceGatheringState !== "gathering" && (v.iceGatheringState = "gathering", v._emitGatheringStateChange()), P || v._dispatchEvent("icecandidate", S), E && (v._dispatchEvent("icecandidate", new Event("icecandidate")), v.iceGatheringState = "complete", v._emitGatheringStateChange());
          }
        }, c.setTimeout(function() {
          b.forEach(function(x) {
            g.onlocalcandidate(x);
          });
        }, 0);
      }
    }, d.prototype._createIceAndDtlsTransports = function() {
      var p = this, m = new c.RTCIceTransport(null);
      m.onicestatechange = function() {
        p._updateIceConnectionState(), p._updateConnectionState();
      };
      var v = new c.RTCDtlsTransport(m);
      return v.ondtlsstatechange = function() {
        p._updateConnectionState();
      }, v.onerror = function() {
        Object.defineProperty(
          v,
          "state",
          { value: "failed", writable: !0 }
        ), p._updateConnectionState();
      }, {
        iceTransport: m,
        dtlsTransport: v
      };
    }, d.prototype._disposeIceAndDtlsTransports = function(p) {
      var m = this.transceivers[p].iceGatherer;
      m && (delete m.onlocalcandidate, delete this.transceivers[p].iceGatherer);
      var v = this.transceivers[p].iceTransport;
      v && (delete v.onicestatechange, delete this.transceivers[p].iceTransport);
      var g = this.transceivers[p].dtlsTransport;
      g && (delete g.ondtlsstatechange, delete g.onerror, delete this.transceivers[p].dtlsTransport);
    }, d.prototype._transceive = function(p, m, v) {
      var g = r(
        p.localCapabilities,
        p.remoteCapabilities
      );
      m && p.rtpSender && (g.encodings = p.sendEncodingParameters, g.rtcp = {
        cname: n.localCName,
        compound: p.rtcpParameters.compound
      }, p.recvEncodingParameters.length && (g.rtcp.ssrc = p.recvEncodingParameters[0].ssrc), p.rtpSender.send(g)), v && p.rtpReceiver && g.codecs.length > 0 && (p.kind === "video" && p.recvEncodingParameters && l < 15019 && p.recvEncodingParameters.forEach(function(b) {
        delete b.rtx;
      }), p.recvEncodingParameters.length ? g.encodings = p.recvEncodingParameters : g.encodings = [{}], g.rtcp = {
        compound: p.rtcpParameters.compound
      }, p.rtcpParameters.cname && (g.rtcp.cname = p.rtcpParameters.cname), p.sendEncodingParameters.length && (g.rtcp.ssrc = p.sendEncodingParameters[0].ssrc), p.rtpReceiver.receive(g));
    }, d.prototype.setLocalDescription = function(p) {
      var m = this;
      if (["offer", "answer"].indexOf(p.type) === -1)
        return Promise.reject(o(
          "TypeError",
          'Unsupported type "' + p.type + '"'
        ));
      if (!s(
        "setLocalDescription",
        p.type,
        m.signalingState
      ) || m._isClosed)
        return Promise.reject(o(
          "InvalidStateError",
          "Can not set local " + p.type + " in state " + m.signalingState
        ));
      var v, g;
      if (p.type === "offer")
        v = n.splitSections(p.sdp), g = v.shift(), v.forEach(function(x, S) {
          var T = n.parseRtpParameters(x);
          m.transceivers[S].localCapabilities = T;
        }), m.transceivers.forEach(function(x, S) {
          m._gather(x.mid, S);
        });
      else if (p.type === "answer") {
        v = n.splitSections(m._remoteDescription.sdp), g = v.shift();
        var b = n.matchPrefix(
          g,
          "a=ice-lite"
        ).length > 0;
        v.forEach(function(x, S) {
          var T = m.transceivers[S], P = T.iceGatherer, M = T.iceTransport, C = T.dtlsTransport, E = T.localCapabilities, w = T.remoteCapabilities, k = n.isRejected(x) && n.matchPrefix(x, "a=bundle-only").length === 0;
          if (!k && !T.rejected) {
            var R = n.getIceParameters(
              x,
              g
            ), z = n.getDtlsParameters(
              x,
              g
            );
            b && (z.role = "server"), (!m.usingBundle || S === 0) && (m._gather(T.mid, S), M.state === "new" && M.start(
              P,
              R,
              b ? "controlling" : "controlled"
            ), C.state === "new" && C.start(z));
            var U = r(
              E,
              w
            );
            m._transceive(
              T,
              U.codecs.length > 0,
              !1
            );
          }
        });
      }
      return m._localDescription = {
        type: p.type,
        sdp: p.sdp
      }, p.type === "offer" ? m._updateSignalingState("have-local-offer") : m._updateSignalingState("stable"), Promise.resolve();
    }, d.prototype.setRemoteDescription = function(p) {
      var m = this;
      if (["offer", "answer"].indexOf(p.type) === -1)
        return Promise.reject(o(
          "TypeError",
          'Unsupported type "' + p.type + '"'
        ));
      if (!s(
        "setRemoteDescription",
        p.type,
        m.signalingState
      ) || m._isClosed)
        return Promise.reject(o(
          "InvalidStateError",
          "Can not set remote " + p.type + " in state " + m.signalingState
        ));
      var v = {};
      m.remoteStreams.forEach(function(M) {
        v[M.id] = M;
      });
      var g = [], b = n.splitSections(p.sdp), x = b.shift(), S = n.matchPrefix(
        x,
        "a=ice-lite"
      ).length > 0, T = n.matchPrefix(
        x,
        "a=group:BUNDLE "
      ).length > 0;
      m.usingBundle = T;
      var P = n.matchPrefix(
        x,
        "a=ice-options:"
      )[0];
      return P ? m.canTrickleIceCandidates = P.substr(14).split(" ").indexOf("trickle") >= 0 : m.canTrickleIceCandidates = !1, b.forEach(function(M, C) {
        var E = n.splitLines(M), w = n.getKind(M), k = n.isRejected(M) && n.matchPrefix(M, "a=bundle-only").length === 0, R = E[0].substr(2).split(" ")[2], z = n.getDirection(M, x), U = n.parseMsid(M), L = n.getMid(M) || n.generateIdentifier();
        if (k || w === "application" && (R === "DTLS/SCTP" || R === "UDP/DTLS/SCTP")) {
          m.transceivers[C] = {
            mid: L,
            kind: w,
            protocol: R,
            rejected: !0
          };
          return;
        }
        !k && m.transceivers[C] && m.transceivers[C].rejected && (m.transceivers[C] = m._createTransceiver(w, !0));
        var I, H, K, rt, tt, mt, yt, nt, W, $ = n.parseRtpParameters(M), ie, jt;
        k || (ie = n.getIceParameters(
          M,
          x
        ), jt = n.getDtlsParameters(
          M,
          x
        ), jt.role = "client"), yt = n.parseRtpEncodingParameters(M);
        var $t = n.parseRtcpParameters(M), qt = n.matchPrefix(
          M,
          "a=end-of-candidates",
          x
        ).length > 0, xt = n.matchPrefix(M, "a=candidate:").map(function(Y) {
          return n.parseCandidate(Y);
        }).filter(function(Y) {
          return Y.component === 1;
        });
        if ((p.type === "offer" || p.type === "answer") && !k && T && C > 0 && m.transceivers[C] && (m._disposeIceAndDtlsTransports(C), m.transceivers[C].iceGatherer = m.transceivers[0].iceGatherer, m.transceivers[C].iceTransport = m.transceivers[0].iceTransport, m.transceivers[C].dtlsTransport = m.transceivers[0].dtlsTransport, m.transceivers[C].rtpSender && m.transceivers[C].rtpSender.setTransport(
          m.transceivers[0].dtlsTransport
        ), m.transceivers[C].rtpReceiver && m.transceivers[C].rtpReceiver.setTransport(
          m.transceivers[0].dtlsTransport
        )), p.type === "offer" && !k) {
          I = m.transceivers[C] || m._createTransceiver(w), I.mid = L, I.iceGatherer || (I.iceGatherer = m._createIceGatherer(
            C,
            T
          )), xt.length && I.iceTransport.state === "new" && (qt && (!T || C === 0) ? I.iceTransport.setRemoteCandidates(xt) : xt.forEach(function(Y) {
            a(I.iceTransport, Y);
          })), nt = c.RTCRtpReceiver.getCapabilities(w), l < 15019 && (nt.codecs = nt.codecs.filter(
            function(Y) {
              return Y.name !== "rtx";
            }
          )), mt = I.sendEncodingParameters || [{
            ssrc: (2 * C + 2) * 1001
          }];
          var Bt = !1;
          if (z === "sendrecv" || z === "sendonly") {
            if (Bt = !I.rtpReceiver, tt = I.rtpReceiver || new c.RTCRtpReceiver(I.dtlsTransport, w), Bt) {
              var bt;
              W = tt.track, U && U.stream === "-" || (U ? (v[U.stream] || (v[U.stream] = new c.MediaStream(), Object.defineProperty(v[U.stream], "id", {
                get: function() {
                  return U.stream;
                }
              })), Object.defineProperty(W, "id", {
                get: function() {
                  return U.track;
                }
              }), bt = v[U.stream]) : (v.default || (v.default = new c.MediaStream()), bt = v.default)), bt && (h(W, bt), I.associatedRemoteMediaStreams.push(bt)), g.push([W, tt, bt]);
            }
          } else I.rtpReceiver && I.rtpReceiver.track && (I.associatedRemoteMediaStreams.forEach(function(Y) {
            var Xt = Y.getTracks().find(function(se) {
              return se.id === I.rtpReceiver.track.id;
            });
            Xt && u(Xt, Y);
          }), I.associatedRemoteMediaStreams = []);
          I.localCapabilities = nt, I.remoteCapabilities = $, I.rtpReceiver = tt, I.rtcpParameters = $t, I.sendEncodingParameters = mt, I.recvEncodingParameters = yt, m._transceive(
            m.transceivers[C],
            !1,
            Bt
          );
        } else if (p.type === "answer" && !k) {
          I = m.transceivers[C], H = I.iceGatherer, K = I.iceTransport, rt = I.dtlsTransport, tt = I.rtpReceiver, mt = I.sendEncodingParameters, nt = I.localCapabilities, m.transceivers[C].recvEncodingParameters = yt, m.transceivers[C].remoteCapabilities = $, m.transceivers[C].rtcpParameters = $t, xt.length && K.state === "new" && ((S || qt) && (!T || C === 0) ? K.setRemoteCandidates(xt) : xt.forEach(function(Y) {
            a(I.iceTransport, Y);
          })), (!T || C === 0) && (K.state === "new" && K.start(
            H,
            ie,
            "controlling"
          ), rt.state === "new" && rt.start(jt));
          var re = r(
            I.localCapabilities,
            I.remoteCapabilities
          ), ne = re.codecs.filter(function(Y) {
            return Y.name.toLowerCase() === "rtx";
          }).length;
          !ne && I.sendEncodingParameters[0].rtx && delete I.sendEncodingParameters[0].rtx, m._transceive(
            I,
            z === "sendrecv" || z === "recvonly",
            z === "sendrecv" || z === "sendonly"
          ), tt && (z === "sendrecv" || z === "sendonly") ? (W = tt.track, U ? (v[U.stream] || (v[U.stream] = new c.MediaStream()), h(W, v[U.stream]), g.push([W, tt, v[U.stream]])) : (v.default || (v.default = new c.MediaStream()), h(W, v.default), g.push([W, tt, v.default]))) : delete I.rtpReceiver;
        }
      }), m._dtlsRole === void 0 && (m._dtlsRole = p.type === "offer" ? "active" : "passive"), m._remoteDescription = {
        type: p.type,
        sdp: p.sdp
      }, p.type === "offer" ? m._updateSignalingState("have-remote-offer") : m._updateSignalingState("stable"), Object.keys(v).forEach(function(M) {
        var C = v[M];
        if (C.getTracks().length) {
          if (m.remoteStreams.indexOf(C) === -1) {
            m.remoteStreams.push(C);
            var E = new Event("addstream");
            E.stream = C, c.setTimeout(function() {
              m._dispatchEvent("addstream", E);
            });
          }
          g.forEach(function(w) {
            var k = w[0], R = w[1];
            C.id === w[2].id && f(m, k, R, [C]);
          });
        }
      }), g.forEach(function(M) {
        M[2] || f(m, M[0], M[1], []);
      }), c.setTimeout(function() {
        m && m.transceivers && m.transceivers.forEach(function(M) {
          M.iceTransport && M.iceTransport.state === "new" && M.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), M.iceTransport.addRemoteCandidate({}));
        });
      }, 4e3), Promise.resolve();
    }, d.prototype.close = function() {
      this.transceivers.forEach(function(p) {
        p.iceTransport && p.iceTransport.stop(), p.dtlsTransport && p.dtlsTransport.stop(), p.rtpSender && p.rtpSender.stop(), p.rtpReceiver && p.rtpReceiver.stop();
      }), this._isClosed = !0, this._updateSignalingState("closed");
    }, d.prototype._updateSignalingState = function(p) {
      this.signalingState = p;
      var m = new Event("signalingstatechange");
      this._dispatchEvent("signalingstatechange", m);
    }, d.prototype._maybeFireNegotiationNeeded = function() {
      var p = this;
      this.signalingState !== "stable" || this.needNegotiation === !0 || (this.needNegotiation = !0, c.setTimeout(function() {
        if (p.needNegotiation) {
          p.needNegotiation = !1;
          var m = new Event("negotiationneeded");
          p._dispatchEvent("negotiationneeded", m);
        }
      }, 0));
    }, d.prototype._updateIceConnectionState = function() {
      var p, m = {
        new: 0,
        closed: 0,
        checking: 0,
        connected: 0,
        completed: 0,
        disconnected: 0,
        failed: 0
      };
      if (this.transceivers.forEach(function(g) {
        g.iceTransport && !g.rejected && m[g.iceTransport.state]++;
      }), p = "new", m.failed > 0 ? p = "failed" : m.checking > 0 ? p = "checking" : m.disconnected > 0 ? p = "disconnected" : m.new > 0 ? p = "new" : m.connected > 0 ? p = "connected" : m.completed > 0 && (p = "completed"), p !== this.iceConnectionState) {
        this.iceConnectionState = p;
        var v = new Event("iceconnectionstatechange");
        this._dispatchEvent("iceconnectionstatechange", v);
      }
    }, d.prototype._updateConnectionState = function() {
      var p, m = {
        new: 0,
        closed: 0,
        connecting: 0,
        connected: 0,
        completed: 0,
        disconnected: 0,
        failed: 0
      };
      if (this.transceivers.forEach(function(g) {
        g.iceTransport && g.dtlsTransport && !g.rejected && (m[g.iceTransport.state]++, m[g.dtlsTransport.state]++);
      }), m.connected += m.completed, p = "new", m.failed > 0 ? p = "failed" : m.connecting > 0 ? p = "connecting" : m.disconnected > 0 ? p = "disconnected" : m.new > 0 ? p = "new" : m.connected > 0 && (p = "connected"), p !== this.connectionState) {
        this.connectionState = p;
        var v = new Event("connectionstatechange");
        this._dispatchEvent("connectionstatechange", v);
      }
    }, d.prototype.createOffer = function() {
      var p = this;
      if (p._isClosed)
        return Promise.reject(o(
          "InvalidStateError",
          "Can not call createOffer after close"
        ));
      var m = p.transceivers.filter(function(S) {
        return S.kind === "audio";
      }).length, v = p.transceivers.filter(function(S) {
        return S.kind === "video";
      }).length, g = arguments[0];
      if (g) {
        if (g.mandatory || g.optional)
          throw new TypeError(
            "Legacy mandatory/optional constraints not supported."
          );
        g.offerToReceiveAudio !== void 0 && (g.offerToReceiveAudio === !0 ? m = 1 : g.offerToReceiveAudio === !1 ? m = 0 : m = g.offerToReceiveAudio), g.offerToReceiveVideo !== void 0 && (g.offerToReceiveVideo === !0 ? v = 1 : g.offerToReceiveVideo === !1 ? v = 0 : v = g.offerToReceiveVideo);
      }
      for (p.transceivers.forEach(function(S) {
        S.kind === "audio" ? (m--, m < 0 && (S.wantReceive = !1)) : S.kind === "video" && (v--, v < 0 && (S.wantReceive = !1));
      }); m > 0 || v > 0; )
        m > 0 && (p._createTransceiver("audio"), m--), v > 0 && (p._createTransceiver("video"), v--);
      var b = n.writeSessionBoilerplate(
        p._sdpSessionId,
        p._sdpSessionVersion++
      );
      p.transceivers.forEach(function(S, T) {
        var P = S.track, M = S.kind, C = S.mid || n.generateIdentifier();
        S.mid = C, S.iceGatherer || (S.iceGatherer = p._createIceGatherer(
          T,
          p.usingBundle
        ));
        var E = c.RTCRtpSender.getCapabilities(M);
        l < 15019 && (E.codecs = E.codecs.filter(
          function(k) {
            return k.name !== "rtx";
          }
        )), E.codecs.forEach(function(k) {
          k.name === "H264" && k.parameters["level-asymmetry-allowed"] === void 0 && (k.parameters["level-asymmetry-allowed"] = "1"), S.remoteCapabilities && S.remoteCapabilities.codecs && S.remoteCapabilities.codecs.forEach(function(R) {
            k.name.toLowerCase() === R.name.toLowerCase() && k.clockRate === R.clockRate && (k.preferredPayloadType = R.payloadType);
          });
        }), E.headerExtensions.forEach(function(k) {
          var R = S.remoteCapabilities && S.remoteCapabilities.headerExtensions || [];
          R.forEach(function(z) {
            k.uri === z.uri && (k.id = z.id);
          });
        });
        var w = S.sendEncodingParameters || [{
          ssrc: (2 * T + 1) * 1001
        }];
        P && l >= 15019 && M === "video" && !w[0].rtx && (w[0].rtx = {
          ssrc: w[0].ssrc + 1
        }), S.wantReceive && (S.rtpReceiver = new c.RTCRtpReceiver(
          S.dtlsTransport,
          M
        )), S.localCapabilities = E, S.sendEncodingParameters = w;
      }), p._config.bundlePolicy !== "max-compat" && (b += "a=group:BUNDLE " + p.transceivers.map(function(S) {
        return S.mid;
      }).join(" ") + `\r
`), b += `a=ice-options:trickle\r
`, p.transceivers.forEach(function(S, T) {
        b += e(
          S,
          S.localCapabilities,
          "offer",
          S.stream,
          p._dtlsRole
        ), b += `a=rtcp-rsize\r
`, S.iceGatherer && p.iceGatheringState !== "new" && (T === 0 || !p.usingBundle) && (S.iceGatherer.getLocalCandidates().forEach(function(P) {
          P.component = 1, b += "a=" + n.writeCandidate(P) + `\r
`;
        }), S.iceGatherer.state === "completed" && (b += `a=end-of-candidates\r
`));
      });
      var x = new c.RTCSessionDescription({
        type: "offer",
        sdp: b
      });
      return Promise.resolve(x);
    }, d.prototype.createAnswer = function() {
      var p = this;
      if (p._isClosed)
        return Promise.reject(o(
          "InvalidStateError",
          "Can not call createAnswer after close"
        ));
      if (!(p.signalingState === "have-remote-offer" || p.signalingState === "have-local-pranswer"))
        return Promise.reject(o(
          "InvalidStateError",
          "Can not call createAnswer in signalingState " + p.signalingState
        ));
      var m = n.writeSessionBoilerplate(
        p._sdpSessionId,
        p._sdpSessionVersion++
      );
      p.usingBundle && (m += "a=group:BUNDLE " + p.transceivers.map(function(b) {
        return b.mid;
      }).join(" ") + `\r
`), m += `a=ice-options:trickle\r
`;
      var v = n.getMediaSections(
        p._remoteDescription.sdp
      ).length;
      p.transceivers.forEach(function(b, x) {
        if (!(x + 1 > v)) {
          if (b.rejected) {
            b.kind === "application" ? b.protocol === "DTLS/SCTP" ? m += `m=application 0 DTLS/SCTP 5000\r
` : m += "m=application 0 " + b.protocol + ` webrtc-datachannel\r
` : b.kind === "audio" ? m += `m=audio 0 UDP/TLS/RTP/SAVPF 0\r
a=rtpmap:0 PCMU/8000\r
` : b.kind === "video" && (m += `m=video 0 UDP/TLS/RTP/SAVPF 120\r
a=rtpmap:120 VP8/90000\r
`), m += `c=IN IP4 0.0.0.0\r
a=inactive\r
a=mid:` + b.mid + `\r
`;
            return;
          }
          if (b.stream) {
            var S;
            b.kind === "audio" ? S = b.stream.getAudioTracks()[0] : b.kind === "video" && (S = b.stream.getVideoTracks()[0]), S && l >= 15019 && b.kind === "video" && !b.sendEncodingParameters[0].rtx && (b.sendEncodingParameters[0].rtx = {
              ssrc: b.sendEncodingParameters[0].ssrc + 1
            });
          }
          var T = r(
            b.localCapabilities,
            b.remoteCapabilities
          ), P = T.codecs.filter(function(M) {
            return M.name.toLowerCase() === "rtx";
          }).length;
          !P && b.sendEncodingParameters[0].rtx && delete b.sendEncodingParameters[0].rtx, m += e(
            b,
            T,
            "answer",
            b.stream,
            p._dtlsRole
          ), b.rtcpParameters && b.rtcpParameters.reducedSize && (m += `a=rtcp-rsize\r
`);
        }
      });
      var g = new c.RTCSessionDescription({
        type: "answer",
        sdp: m
      });
      return Promise.resolve(g);
    }, d.prototype.addIceCandidate = function(p) {
      var m = this, v;
      return p && !(p.sdpMLineIndex !== void 0 || p.sdpMid) ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function(g, b) {
        if (m._remoteDescription)
          if (!p || p.candidate === "")
            for (var x = 0; x < m.transceivers.length && !(!m.transceivers[x].rejected && (m.transceivers[x].iceTransport.addRemoteCandidate({}), v = n.getMediaSections(m._remoteDescription.sdp), v[x] += `a=end-of-candidates\r
`, m._remoteDescription.sdp = n.getDescription(m._remoteDescription.sdp) + v.join(""), m.usingBundle)); x++)
              ;
          else {
            var S = p.sdpMLineIndex;
            if (p.sdpMid) {
              for (var T = 0; T < m.transceivers.length; T++)
                if (m.transceivers[T].mid === p.sdpMid) {
                  S = T;
                  break;
                }
            }
            var P = m.transceivers[S];
            if (P) {
              if (P.rejected)
                return g();
              var M = Object.keys(p.candidate).length > 0 ? n.parseCandidate(p.candidate) : {};
              if (M.protocol === "tcp" && (M.port === 0 || M.port === 9) || M.component && M.component !== 1)
                return g();
              if ((S === 0 || S > 0 && P.iceTransport !== m.transceivers[0].iceTransport) && !a(P.iceTransport, M))
                return b(o(
                  "OperationError",
                  "Can not add ICE candidate"
                ));
              var C = p.candidate.trim();
              C.indexOf("a=") === 0 && (C = C.substr(2)), v = n.getMediaSections(m._remoteDescription.sdp), v[S] += "a=" + (M.type ? C : "end-of-candidates") + `\r
`, m._remoteDescription.sdp = n.getDescription(m._remoteDescription.sdp) + v.join("");
            } else
              return b(o(
                "OperationError",
                "Can not add ICE candidate"
              ));
          }
        else return b(o(
          "InvalidStateError",
          "Can not add ICE candidate without a remote description"
        ));
        g();
      });
    }, d.prototype.getStats = function(p) {
      if (p && p instanceof c.MediaStreamTrack) {
        var m = null;
        if (this.transceivers.forEach(function(g) {
          g.rtpSender && g.rtpSender.track === p ? m = g.rtpSender : g.rtpReceiver && g.rtpReceiver.track === p && (m = g.rtpReceiver);
        }), !m)
          throw o("InvalidAccessError", "Invalid selector.");
        return m.getStats();
      }
      var v = [];
      return this.transceivers.forEach(function(g) {
        [
          "rtpSender",
          "rtpReceiver",
          "iceGatherer",
          "iceTransport",
          "dtlsTransport"
        ].forEach(function(b) {
          g[b] && v.push(g[b].getStats());
        });
      }), Promise.all(v).then(function(g) {
        var b = /* @__PURE__ */ new Map();
        return g.forEach(function(x) {
          x.forEach(function(S) {
            b.set(S.id, S);
          });
        }), b;
      });
    };
    var y = [
      "RTCRtpSender",
      "RTCRtpReceiver",
      "RTCIceGatherer",
      "RTCIceTransport",
      "RTCDtlsTransport"
    ];
    y.forEach(function(p) {
      var m = c[p];
      if (m && m.prototype && m.prototype.getStats) {
        var v = m.prototype.getStats;
        m.prototype.getStats = function() {
          return v.apply(this).then(function(g) {
            var b = /* @__PURE__ */ new Map();
            return Object.keys(g).forEach(function(x) {
              g[x].type = t(g[x]), b.set(x, g[x]);
            }), b;
          });
        };
      }
    });
    var _ = ["createOffer", "createAnswer"];
    return _.forEach(function(p) {
      var m = d.prototype[p];
      d.prototype[p] = function() {
        var v = arguments;
        return typeof v[0] == "function" || typeof v[1] == "function" ? m.apply(this, [arguments[2]]).then(function(g) {
          typeof v[0] == "function" && v[0].apply(null, [g]);
        }, function(g) {
          typeof v[1] == "function" && v[1].apply(null, [g]);
        }) : m.apply(this, arguments);
      };
    }), _ = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"], _.forEach(function(p) {
      var m = d.prototype[p];
      d.prototype[p] = function() {
        var v = arguments;
        return typeof v[1] == "function" || typeof v[2] == "function" ? m.apply(this, arguments).then(function() {
          typeof v[1] == "function" && v[1].apply(null);
        }, function(g) {
          typeof v[2] == "function" && v[2].apply(null, [g]);
        }) : m.apply(this, arguments);
      };
    }), ["getStats"].forEach(function(p) {
      var m = d.prototype[p];
      d.prototype[p] = function() {
        var v = arguments;
        return typeof v[1] == "function" ? m.apply(this, arguments).then(function() {
          typeof v[1] == "function" && v[1].apply(null);
        }) : m.apply(this, arguments);
      };
    }), d;
  }, hn;
}
var _c = vc();
const xc = /* @__PURE__ */ Kr(_c);
function Qo(n) {
  const t = n && n.navigator, e = function(r) {
    return {
      name: { PermissionDeniedError: "NotAllowedError" }[r.name] || r.name,
      message: r.message,
      constraint: r.constraint,
      toString() {
        return this.name;
      }
    };
  }, i = t.mediaDevices.getUserMedia.bind(t.mediaDevices);
  Object.getOwnPropertyDescriptor(t.mediaDevices, "getUserMedia")?.writable && (t.mediaDevices.getUserMedia = function(r) {
    return i(r).catch((s) => Promise.reject(e(s)));
  });
}
function ta(n) {
  "getDisplayMedia" in n.navigator && n.navigator.mediaDevices && (n.navigator.mediaDevices && "getDisplayMedia" in n.navigator.mediaDevices || (n.navigator.mediaDevices.getDisplayMedia = n.navigator.getDisplayMedia.bind(n.navigator)));
}
function Gn(n, t) {
  if (n.RTCIceGatherer && (n.RTCIceCandidate || (n.RTCIceCandidate = function(r) {
    return r;
  }), n.RTCSessionDescription || (n.RTCSessionDescription = function(r) {
    return r;
  }), t.version < 15025)) {
    const i = Object.getOwnPropertyDescriptor(
      n.MediaStreamTrack.prototype,
      "enabled"
    );
    Object.defineProperty(n.MediaStreamTrack.prototype, "enabled", {
      set(r) {
        i.set.call(this, r);
        const s = new Event("enabled");
        s.enabled = r, this.dispatchEvent(s);
      }
    });
  }
  n.RTCRtpSender && !("dtmf" in n.RTCRtpSender.prototype) && Object.defineProperty(n.RTCRtpSender.prototype, "dtmf", {
    get() {
      return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new n.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf;
    }
  }), n.RTCDtmfSender && !n.RTCDTMFSender && (n.RTCDTMFSender = n.RTCDtmfSender);
  const e = xc(
    n,
    t.version
  );
  n.RTCPeerConnection = function(r) {
    return r && r.iceServers && (r.iceServers = gc(
      r.iceServers,
      t.version
    ), fs("ICE servers after filtering:", r.iceServers)), new e(r);
  }, n.RTCPeerConnection.prototype = e.prototype;
}
function ea(n) {
  n.RTCRtpSender && !("replaceTrack" in n.RTCRtpSender.prototype) && (n.RTCRtpSender.prototype.replaceTrack = n.RTCRtpSender.prototype.setTrack);
}
const Fs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shimGetDisplayMedia: ta,
  shimGetUserMedia: Qo,
  shimPeerConnection: Gn,
  shimReplaceTrack: ea
}, Symbol.toStringTag, { value: "Module" }));
function ia(n, t) {
  const e = n && n.navigator, i = n && n.MediaStreamTrack;
  if (e.getUserMedia = function(r, s, a) {
    Qr(
      "navigator.getUserMedia",
      "navigator.mediaDevices.getUserMedia"
    ), e.mediaDevices.getUserMedia(r).then(s, a);
  }, !(t.version > 55 && "autoGainControl" in e.mediaDevices.getSupportedConstraints())) {
    const r = function(a, o, c) {
      o in a && !(c in a) && (a[c] = a[o], delete a[o]);
    }, s = e.mediaDevices.getUserMedia.bind(e.mediaDevices);
    if (Object.getOwnPropertyDescriptor(e.mediaDevices, "getUserMedia")?.writable && (e.mediaDevices.getUserMedia = function(a) {
      return typeof a == "object" && typeof a.audio == "object" && (a = JSON.parse(JSON.stringify(a)), r(a.audio, "autoGainControl", "mozAutoGainControl"), r(a.audio, "noiseSuppression", "mozNoiseSuppression")), s(a);
    }), i && i.prototype.getSettings) {
      const a = i.prototype.getSettings;
      i.prototype.getSettings = function() {
        const o = a.apply(this, arguments);
        return r(o, "mozAutoGainControl", "autoGainControl"), r(o, "mozNoiseSuppression", "noiseSuppression"), o;
      };
    }
    if (i && i.prototype.applyConstraints) {
      const a = i.prototype.applyConstraints;
      i.prototype.applyConstraints = function(o) {
        return this.kind === "audio" && typeof o == "object" && (o = JSON.parse(JSON.stringify(o)), r(o, "autoGainControl", "mozAutoGainControl"), r(o, "noiseSuppression", "mozNoiseSuppression")), a.apply(this, [o]);
      };
    }
  }
}
function bc(n, t) {
  n.navigator.mediaDevices && "getDisplayMedia" in n.navigator.mediaDevices || n.navigator.mediaDevices && (n.navigator.mediaDevices.getDisplayMedia = function(i) {
    if (!(i && i.video)) {
      const r = new DOMException("getDisplayMedia without video constraints is undefined");
      return r.name = "NotFoundError", r.code = 8, Promise.reject(r);
    }
    return i.video === !0 ? i.video = { mediaSource: t } : i.video.mediaSource = t, n.navigator.mediaDevices.getUserMedia(i);
  });
}
function ra(n) {
  typeof n == "object" && n.RTCTrackEvent && "receiver" in n.RTCTrackEvent.prototype && !("transceiver" in n.RTCTrackEvent.prototype) && Object.defineProperty(n.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return { receiver: this.receiver };
    }
  });
}
function jn(n, t) {
  if (typeof n != "object" || !(n.RTCPeerConnection || n.mozRTCPeerConnection))
    return;
  !n.RTCPeerConnection && n.mozRTCPeerConnection && (n.RTCPeerConnection = n.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(r) {
    const s = n.RTCPeerConnection.prototype[r], a = { [r]() {
      return arguments[0] = new (r === "addIceCandidate" ? n.RTCIceCandidate : n.RTCSessionDescription)(arguments[0]), s.apply(this, arguments);
    } };
    n.RTCPeerConnection.prototype[r] = a[r];
  });
  const e = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }, i = n.RTCPeerConnection.prototype.getStats;
  n.RTCPeerConnection.prototype.getStats = function() {
    const [s, a, o] = arguments;
    return i.apply(this, [s || null]).then((c) => {
      if (t.version < 53 && !a)
        try {
          c.forEach((l) => {
            l.type = e[l.type] || l.type;
          });
        } catch (l) {
          if (l.name !== "TypeError")
            throw l;
          c.forEach((h, u) => {
            c.set(u, Object.assign({}, h, {
              type: e[h.type] || h.type
            }));
          });
        }
      return c;
    }).then(a, o);
  };
}
function na(n) {
  if (!(typeof n == "object" && n.RTCPeerConnection && n.RTCRtpSender) || n.RTCRtpSender && "getStats" in n.RTCRtpSender.prototype)
    return;
  const t = n.RTCPeerConnection.prototype.getSenders;
  t && (n.RTCPeerConnection.prototype.getSenders = function() {
    const r = t.apply(this, []);
    return r.forEach((s) => s._pc = this), r;
  });
  const e = n.RTCPeerConnection.prototype.addTrack;
  e && (n.RTCPeerConnection.prototype.addTrack = function() {
    const r = e.apply(this, arguments);
    return r._pc = this, r;
  }), n.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function sa(n) {
  if (!(typeof n == "object" && n.RTCPeerConnection && n.RTCRtpSender) || n.RTCRtpSender && "getStats" in n.RTCRtpReceiver.prototype)
    return;
  const t = n.RTCPeerConnection.prototype.getReceivers;
  t && (n.RTCPeerConnection.prototype.getReceivers = function() {
    const i = t.apply(this, []);
    return i.forEach((r) => r._pc = this), i;
  }), ri(n, "track", (e) => (e.receiver._pc = e.srcElement, e)), n.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function oa(n) {
  !n.RTCPeerConnection || "removeStream" in n.RTCPeerConnection.prototype || (n.RTCPeerConnection.prototype.removeStream = function(e) {
    Qr("removeStream", "removeTrack"), this.getSenders().forEach((i) => {
      i.track && e.getTracks().includes(i.track) && this.removeTrack(i);
    });
  });
}
function aa(n) {
  n.DataChannel && !n.RTCDataChannel && (n.RTCDataChannel = n.DataChannel);
}
function ca(n) {
  if (!(typeof n == "object" && n.RTCPeerConnection))
    return;
  const t = n.RTCPeerConnection.prototype.addTransceiver;
  t && (n.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    const i = arguments[1], r = i && "sendEncodings" in i;
    r && i.sendEncodings.forEach((a) => {
      if ("rid" in a && !/^[a-z0-9]{0,16}$/i.test(a.rid))
        throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in a && !(parseFloat(a.scaleResolutionDownBy) >= 1))
        throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in a && !(parseFloat(a.maxFramerate) >= 0))
        throw new RangeError("max_framerate must be >= 0.0");
    });
    const s = t.apply(this, arguments);
    if (r) {
      const { sender: a } = s, o = a.getParameters();
      (!("encodings" in o) || // Avoid being fooled by patched getParameters() below.
      o.encodings.length === 1 && Object.keys(o.encodings[0]).length === 0) && (o.encodings = i.sendEncodings, a.sendEncodings = i.sendEncodings, this.setParametersPromises.push(
        a.setParameters(o).then(() => {
          delete a.sendEncodings;
        }).catch(() => {
          delete a.sendEncodings;
        })
      ));
    }
    return s;
  });
}
function la(n) {
  if (!(typeof n == "object" && n.RTCRtpSender))
    return;
  const t = n.RTCRtpSender.prototype.getParameters;
  t && (n.RTCRtpSender.prototype.getParameters = function() {
    const i = t.apply(this, arguments);
    return "encodings" in i || (i.encodings = [].concat(this.sendEncodings || [{}])), i;
  });
}
function ha(n) {
  if (!(typeof n == "object" && n.RTCPeerConnection))
    return;
  const t = n.RTCPeerConnection.prototype.createOffer;
  n.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t.apply(this, arguments);
  };
}
function ua(n) {
  if (!(typeof n == "object" && n.RTCPeerConnection))
    return;
  const t = n.RTCPeerConnection.prototype.createAnswer;
  n.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t.apply(this, arguments);
  };
}
const Ds = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shimAddTransceiver: ca,
  shimCreateAnswer: ua,
  shimCreateOffer: ha,
  shimGetDisplayMedia: bc,
  shimGetParameters: la,
  shimGetUserMedia: ia,
  shimOnTrack: ra,
  shimPeerConnection: jn,
  shimRTCDataChannel: aa,
  shimReceiverGetStats: sa,
  shimRemoveStream: oa,
  shimSenderGetStats: na
}, Symbol.toStringTag, { value: "Module" }));
function fa(n) {
  if (!(typeof n != "object" || !n.RTCPeerConnection)) {
    if ("getLocalStreams" in n.RTCPeerConnection.prototype || (n.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in n.RTCPeerConnection.prototype)) {
      const t = n.RTCPeerConnection.prototype.addTrack;
      n.RTCPeerConnection.prototype.addStream = function(i) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(i) || this._localStreams.push(i), i.getAudioTracks().forEach((r) => t.call(
          this,
          r,
          i
        )), i.getVideoTracks().forEach((r) => t.call(
          this,
          r,
          i
        ));
      }, n.RTCPeerConnection.prototype.addTrack = function(i, ...r) {
        return r && r.forEach((s) => {
          this._localStreams ? this._localStreams.includes(s) || this._localStreams.push(s) : this._localStreams = [s];
        }), t.apply(this, arguments);
      };
    }
    "removeStream" in n.RTCPeerConnection.prototype || (n.RTCPeerConnection.prototype.removeStream = function(e) {
      this._localStreams || (this._localStreams = []);
      const i = this._localStreams.indexOf(e);
      if (i === -1)
        return;
      this._localStreams.splice(i, 1);
      const r = e.getTracks();
      this.getSenders().forEach((s) => {
        r.includes(s.track) && this.removeTrack(s);
      });
    });
  }
}
function da(n) {
  if (!(typeof n != "object" || !n.RTCPeerConnection) && ("getRemoteStreams" in n.RTCPeerConnection.prototype || (n.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in n.RTCPeerConnection.prototype))) {
    Object.defineProperty(n.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(e) {
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = (i) => {
          i.streams.forEach((r) => {
            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(r))
              return;
            this._remoteStreams.push(r);
            const s = new Event("addstream");
            s.stream = r, this.dispatchEvent(s);
          });
        });
      }
    });
    const t = n.RTCPeerConnection.prototype.setRemoteDescription;
    n.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const i = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(r) {
        r.streams.forEach((s) => {
          if (i._remoteStreams || (i._remoteStreams = []), i._remoteStreams.indexOf(s) >= 0)
            return;
          i._remoteStreams.push(s);
          const a = new Event("addstream");
          a.stream = s, i.dispatchEvent(a);
        });
      }), t.apply(i, arguments);
    };
  }
}
function pa(n) {
  if (typeof n != "object" || !n.RTCPeerConnection)
    return;
  const t = n.RTCPeerConnection.prototype, e = t.createOffer, i = t.createAnswer, r = t.setLocalDescription, s = t.setRemoteDescription, a = t.addIceCandidate;
  t.createOffer = function(l, h) {
    const u = arguments.length >= 2 ? arguments[2] : arguments[0], f = e.apply(this, [u]);
    return h ? (f.then(l, h), Promise.resolve()) : f;
  }, t.createAnswer = function(l, h) {
    const u = arguments.length >= 2 ? arguments[2] : arguments[0], f = i.apply(this, [u]);
    return h ? (f.then(l, h), Promise.resolve()) : f;
  };
  let o = function(c, l, h) {
    const u = r.apply(this, [c]);
    return h ? (u.then(l, h), Promise.resolve()) : u;
  };
  t.setLocalDescription = o, o = function(c, l, h) {
    const u = s.apply(this, [c]);
    return h ? (u.then(l, h), Promise.resolve()) : u;
  }, t.setRemoteDescription = o, o = function(c, l, h) {
    const u = a.apply(this, [c]);
    return h ? (u.then(l, h), Promise.resolve()) : u;
  }, t.addIceCandidate = o;
}
function ma(n) {
  const t = n && n.navigator;
  if (t.mediaDevices && t.mediaDevices.getUserMedia) {
    const e = t.mediaDevices, i = e.getUserMedia.bind(e);
    t.mediaDevices.getUserMedia = (r) => i(ya(r));
  }
  !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = (function(i, r, s) {
    t.mediaDevices.getUserMedia(i).then(r, s);
  }).bind(t));
}
function ya(n) {
  return n && n.video !== void 0 ? Object.assign(
    {},
    n,
    { video: Jo(n.video) }
  ) : n;
}
function ga(n) {
  if (!n.RTCPeerConnection)
    return;
  const t = n.RTCPeerConnection;
  n.RTCPeerConnection = function(i, r) {
    if (i && i.iceServers) {
      const s = [];
      for (let a = 0; a < i.iceServers.length; a++) {
        let o = i.iceServers[a];
        !o.hasOwnProperty("urls") && o.hasOwnProperty("url") ? (Qr("RTCIceServer.url", "RTCIceServer.urls"), o = JSON.parse(JSON.stringify(o)), o.urls = o.url, delete o.url, s.push(o)) : s.push(i.iceServers[a]);
      }
      i.iceServers = s;
    }
    return new t(i, r);
  }, n.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(n.RTCPeerConnection, "generateCertificate", {
    get() {
      return t.generateCertificate;
    }
  });
}
function va(n) {
  typeof n == "object" && n.RTCTrackEvent && "receiver" in n.RTCTrackEvent.prototype && !("transceiver" in n.RTCTrackEvent.prototype) && Object.defineProperty(n.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return { receiver: this.receiver };
    }
  });
}
function _a(n) {
  const t = n.RTCPeerConnection.prototype.createOffer;
  n.RTCPeerConnection.prototype.createOffer = function(i) {
    if (i) {
      typeof i.offerToReceiveAudio < "u" && (i.offerToReceiveAudio = !!i.offerToReceiveAudio);
      const r = this.getTransceivers().find((a) => a.receiver.track.kind === "audio");
      i.offerToReceiveAudio === !1 && r ? r.direction === "sendrecv" ? r.setDirection ? r.setDirection("sendonly") : r.direction = "sendonly" : r.direction === "recvonly" && (r.setDirection ? r.setDirection("inactive") : r.direction = "inactive") : i.offerToReceiveAudio === !0 && !r && this.addTransceiver("audio"), typeof i.offerToReceiveVideo < "u" && (i.offerToReceiveVideo = !!i.offerToReceiveVideo);
      const s = this.getTransceivers().find((a) => a.receiver.track.kind === "video");
      i.offerToReceiveVideo === !1 && s ? s.direction === "sendrecv" ? s.setDirection ? s.setDirection("sendonly") : s.direction = "sendonly" : s.direction === "recvonly" && (s.setDirection ? s.setDirection("inactive") : s.direction = "inactive") : i.offerToReceiveVideo === !0 && !s && this.addTransceiver("video");
    }
    return t.apply(this, arguments);
  };
}
function xa(n) {
  typeof n != "object" || n.AudioContext || (n.AudioContext = n.webkitAudioContext);
}
const Ls = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shimAudioContext: xa,
  shimCallbacksAPI: pa,
  shimConstraints: ya,
  shimCreateOfferLegacy: _a,
  shimGetUserMedia: ma,
  shimLocalStreamsAPI: fa,
  shimRTCIceServerUrls: ga,
  shimRemoteStreamsAPI: da,
  shimTrackEventTransceiver: va
}, Symbol.toStringTag, { value: "Module" }));
var Sc = Ko();
const Fr = /* @__PURE__ */ Kr(Sc);
function Dr(n) {
  if (!n.RTCIceCandidate || n.RTCIceCandidate && "foundation" in n.RTCIceCandidate.prototype)
    return;
  const t = n.RTCIceCandidate;
  n.RTCIceCandidate = function(i) {
    if (typeof i == "object" && i.candidate && i.candidate.indexOf("a=") === 0 && (i = JSON.parse(JSON.stringify(i)), i.candidate = i.candidate.substr(2)), i.candidate && i.candidate.length) {
      const r = new t(i), s = Fr.parseCandidate(i.candidate), a = Object.assign(
        r,
        s
      );
      return a.toJSON = function() {
        return {
          candidate: a.candidate,
          sdpMid: a.sdpMid,
          sdpMLineIndex: a.sdpMLineIndex,
          usernameFragment: a.usernameFragment
        };
      }, a;
    }
    return new t(i);
  }, n.RTCIceCandidate.prototype = t.prototype, ri(n, "icecandidate", (e) => (e.candidate && Object.defineProperty(e, "candidate", {
    value: new n.RTCIceCandidate(e.candidate),
    writable: "false"
  }), e));
}
function Si(n, t) {
  if (!n.RTCPeerConnection)
    return;
  "sctp" in n.RTCPeerConnection.prototype || Object.defineProperty(n.RTCPeerConnection.prototype, "sctp", {
    get() {
      return typeof this._sctp > "u" ? null : this._sctp;
    }
  });
  const e = function(o) {
    if (!o || !o.sdp)
      return !1;
    const c = Fr.splitSections(o.sdp);
    return c.shift(), c.some((l) => {
      const h = Fr.parseMLine(l);
      return h && h.kind === "application" && h.protocol.indexOf("SCTP") !== -1;
    });
  }, i = function(o) {
    const c = o.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (c === null || c.length < 2)
      return -1;
    const l = parseInt(c[1], 10);
    return l !== l ? -1 : l;
  }, r = function(o) {
    let c = 65536;
    return t.browser === "firefox" && (t.version < 57 ? o === -1 ? c = 16384 : c = 2147483637 : t.version < 60 ? c = t.version === 57 ? 65535 : 65536 : c = 2147483637), c;
  }, s = function(o, c) {
    let l = 65536;
    t.browser === "firefox" && t.version === 57 && (l = 65535);
    const h = Fr.matchPrefix(
      o.sdp,
      "a=max-message-size:"
    );
    return h.length > 0 ? l = parseInt(h[0].substr(19), 10) : t.browser === "firefox" && c !== -1 && (l = 2147483637), l;
  }, a = n.RTCPeerConnection.prototype.setRemoteDescription;
  n.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, t.browser === "chrome" && t.version >= 76) {
      const { sdpSemantics: c } = this.getConfiguration();
      c === "plan-b" && Object.defineProperty(this, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
        enumerable: !0,
        configurable: !0
      });
    }
    if (e(arguments[0])) {
      const c = i(arguments[0]), l = r(c), h = s(arguments[0], c);
      let u;
      l === 0 && h === 0 ? u = Number.POSITIVE_INFINITY : l === 0 || h === 0 ? u = Math.max(l, h) : u = Math.min(l, h);
      const f = {};
      Object.defineProperty(f, "maxMessageSize", {
        get() {
          return u;
        }
      }), this._sctp = f;
    }
    return a.apply(this, arguments);
  };
}
function Ti(n) {
  if (!(n.RTCPeerConnection && "createDataChannel" in n.RTCPeerConnection.prototype))
    return;
  function t(i, r) {
    const s = i.send;
    i.send = function() {
      const o = arguments[0], c = o.length || o.size || o.byteLength;
      if (i.readyState === "open" && r.sctp && c > r.sctp.maxMessageSize)
        throw new TypeError("Message too large (can send a maximum of " + r.sctp.maxMessageSize + " bytes)");
      return s.apply(i, arguments);
    };
  }
  const e = n.RTCPeerConnection.prototype.createDataChannel;
  n.RTCPeerConnection.prototype.createDataChannel = function() {
    const r = e.apply(this, arguments);
    return t(r, this), r;
  }, ri(n, "datachannel", (i) => (t(i.channel, i.target), i));
}
function $n(n) {
  if (!n.RTCPeerConnection || "connectionState" in n.RTCPeerConnection.prototype)
    return;
  const t = n.RTCPeerConnection.prototype;
  Object.defineProperty(t, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(e) {
      this._onconnectionstatechange && (this.removeEventListener(
        "connectionstatechange",
        this._onconnectionstatechange
      ), delete this._onconnectionstatechange), e && this.addEventListener(
        "connectionstatechange",
        this._onconnectionstatechange = e
      );
    },
    enumerable: !0,
    configurable: !0
  }), ["setLocalDescription", "setRemoteDescription"].forEach((e) => {
    const i = t[e];
    t[e] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (r) => {
        const s = r.target;
        if (s._lastConnectionState !== s.connectionState) {
          s._lastConnectionState = s.connectionState;
          const a = new Event("connectionstatechange", r);
          s.dispatchEvent(a);
        }
        return r;
      }, this.addEventListener(
        "iceconnectionstatechange",
        this._connectionstatechangepoly
      )), i.apply(this, arguments);
    };
  });
}
function qn(n, t) {
  if (!n.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605)
    return;
  const e = n.RTCPeerConnection.prototype.setRemoteDescription;
  n.RTCPeerConnection.prototype.setRemoteDescription = function(r) {
    if (r && r.sdp && r.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const s = r.sdp.split(`
`).filter((a) => a.trim() !== "a=extmap-allow-mixed").join(`
`);
      n.RTCSessionDescription && r instanceof n.RTCSessionDescription ? arguments[0] = new n.RTCSessionDescription({
        type: r.type,
        sdp: s
      }) : r.sdp = s;
    }
    return e.apply(this, arguments);
  };
}
function Lr(n, t) {
  if (!(n.RTCPeerConnection && n.RTCPeerConnection.prototype))
    return;
  const e = n.RTCPeerConnection.prototype.addIceCandidate;
  !e || e.length === 0 || (n.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
const Tc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  removeExtmapAllowMixed: qn,
  shimAddIceCandidateNullOrEmpty: Lr,
  shimConnectionState: $n,
  shimMaxMessageSize: Si,
  shimRTCIceCandidate: Dr,
  shimSendThrowTypeError: Ti
}, Symbol.toStringTag, { value: "Module" }));
function Cc({ window: n } = {}, t = {
  shimChrome: !0,
  shimFirefox: !0,
  shimEdge: !0,
  shimSafari: !0
}) {
  const e = fs, i = mc(n), r = {
    browserDetails: i,
    commonShim: Tc,
    extractVersion: bi,
    disableLog: dc,
    disableWarnings: pc
  };
  switch (i.browser) {
    case "chrome":
      if (!Is || !Jn || !t.shimChrome)
        return e("Chrome shim is not included in this adapter release."), r;
      if (i.version === null)
        return e("Chrome shim can not determine version, not shimming."), r;
      e("adapter.js shimming chrome."), r.browserShim = Is, Lr(n, i), Go(n, i), jo(n), Jn(n, i), $o(n), Yo(n, i), qo(n), Xo(n), Ho(n), Zo(n, i), Dr(n), $n(n), Si(n, i), Ti(n), qn(n, i);
      break;
    case "firefox":
      if (!Ds || !jn || !t.shimFirefox)
        return e("Firefox shim is not included in this adapter release."), r;
      e("adapter.js shimming firefox."), r.browserShim = Ds, Lr(n, i), ia(n, i), jn(n, i), ra(n), oa(n), na(n), sa(n), aa(n), ca(n), la(n), ha(n), ua(n), Dr(n), $n(n), Si(n, i), Ti(n);
      break;
    case "edge":
      if (!Fs || !Gn || !t.shimEdge)
        return e("MS edge shim is not included in this adapter release."), r;
      e("adapter.js shimming edge."), r.browserShim = Fs, Qo(n), ta(n), Gn(n, i), ea(n), Si(n, i), Ti(n);
      break;
    case "safari":
      if (!Ls || !t.shimSafari)
        return e("Safari shim is not included in this adapter release."), r;
      e("adapter.js shimming safari."), r.browserShim = Ls, Lr(n, i), ga(n), _a(n), pa(n), fa(n), da(n), va(n), ma(n), xa(n), Dr(n), Si(n, i), Ti(n), qn(n, i);
      break;
    default:
      e("Unsupported browser!");
      break;
  }
  return r;
}
const Vs = Cc({ window: typeof window > "u" ? void 0 : window });
function ee(n, t, e, i) {
  Object.defineProperty(n, t, { get: e, set: i, enumerable: !0, configurable: !0 });
}
var un = (
  //@ts-ignore
  Vs.default || Vs
), hi = new /** @class */
((function() {
  function n() {
    this.isIOS = [
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform), this.supportedBrowsers = [
      "firefox",
      "chrome",
      "safari"
    ], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605;
  }
  return n.prototype.isWebRTCSupported = function() {
    return typeof RTCPeerConnection < "u";
  }, n.prototype.isBrowserSupported = function() {
    var t = this.getBrowser(), e = this.getVersion(), i = this.supportedBrowsers.includes(t);
    return i ? t === "chrome" ? e >= this.minChromeVersion : t === "firefox" ? e >= this.minFirefoxVersion : t === "safari" ? !this.isIOS && e >= this.minSafariVersion : !1 : !1;
  }, n.prototype.getBrowser = function() {
    return un.browserDetails.browser;
  }, n.prototype.getVersion = function() {
    return un.browserDetails.version || 0;
  }, n.prototype.isUnifiedPlanSupported = function() {
    var t = this.getBrowser(), e = un.browserDetails.version || 0;
    if (t === "chrome" && e < this.minChromeVersion) return !1;
    if (t === "firefox" && e >= this.minFirefoxVersion) return !0;
    if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return !1;
    var i, r = !1;
    try {
      i = new RTCPeerConnection(), i.addTransceiver("audio"), r = !0;
    } catch {
    } finally {
      i && i.close();
    }
    return r;
  }, n.prototype.toString = function() {
    return `Supports:
    browser:`.concat(this.getBrowser(), `
    version:`).concat(this.getVersion(), `
    isIOS:`).concat(this.isIOS, `
    isWebRTCSupported:`).concat(this.isWebRTCSupported(), `
    isBrowserSupported:`).concat(this.isBrowserSupported(), `
    isUnifiedPlanSupported:`).concat(this.isUnifiedPlanSupported());
  }, n;
})())(), Js = {
  iceServers: [
    {
      urls: "stun:stun.l.google.com:19302"
    },
    {
      urls: [
        "turn:eu-0.turn.peerjs.com:3478",
        "turn:us-0.turn.peerjs.com:3478"
      ],
      username: "peerjs",
      credential: "peerjsp"
    }
  ],
  sdpSemantics: "unified-plan"
}, Mc = (
  /** @class */
  (function() {
    function n() {
      this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443, this.chunkedBrowsers = {
        Chrome: 1,
        chrome: 1
      }, this.chunkedMTU = 16300, this.defaultConfig = Js, this.browser = hi.getBrowser(), this.browserVersion = hi.getVersion(), this.supports = (function() {
        var t = {
          browser: hi.isBrowserSupported(),
          webRTC: hi.isWebRTCSupported(),
          audioVideo: !1,
          data: !1,
          binaryBlob: !1,
          reliable: !1
        };
        if (!t.webRTC) return t;
        var e;
        try {
          e = new RTCPeerConnection(Js), t.audioVideo = !0;
          var i = void 0;
          try {
            i = e.createDataChannel("_PEERJSTEST", {
              ordered: !0
            }), t.data = !0, t.reliable = !!i.ordered;
            try {
              i.binaryType = "blob", t.binaryBlob = !hi.isIOS;
            } catch {
            }
          } catch {
          } finally {
            i && i.close();
          }
        } catch {
        } finally {
          e && e.close();
        }
        return t;
      })(), this.pack = As.pack, this.unpack = As.unpack, this._dataCount = 1;
    }
    return n.prototype.noop = function() {
    }, n.prototype.validateId = function(t) {
      return !t || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(t);
    }, n.prototype.chunk = function(t) {
      for (var e = [], i = t.size, r = Math.ceil(i / D.chunkedMTU), s = 0, a = 0; a < i; ) {
        var o = Math.min(i, a + D.chunkedMTU), c = t.slice(a, o), l = {
          __peerData: this._dataCount,
          n: s,
          data: c,
          total: r
        };
        e.push(l), a = o, s++;
      }
      return this._dataCount++, e;
    }, n.prototype.blobToArrayBuffer = function(t, e) {
      var i = new FileReader();
      return i.onload = function(r) {
        r.target && e(r.target.result);
      }, i.readAsArrayBuffer(t), i;
    }, n.prototype.binaryStringToArrayBuffer = function(t) {
      for (var e = new Uint8Array(t.length), i = 0; i < t.length; i++) e[i] = t.charCodeAt(i) & 255;
      return e.buffer;
    }, n.prototype.randomToken = function() {
      return Math.random().toString(36).slice(2);
    }, n.prototype.isSecure = function() {
      return location.protocol === "https:";
    }, n;
  })()
), D = new Mc(), ba = {};
ee(ba, "Peer", () => Wn, (n) => Wn = n);
var lr = {}, Pc = Object.prototype.hasOwnProperty, _t = "~";
function Ri() {
}
Object.create && (Ri.prototype = /* @__PURE__ */ Object.create(null), new Ri().__proto__ || (_t = !1));
function wc(n, t, e) {
  this.fn = n, this.context = t, this.once = e || !1;
}
function Sa(n, t, e, i, r) {
  if (typeof e != "function") throw new TypeError("The listener must be a function");
  var s = new wc(e, i || n, r), a = _t ? _t + t : t;
  return n._events[a] ? n._events[a].fn ? n._events[a] = [
    n._events[a],
    s
  ] : n._events[a].push(s) : (n._events[a] = s, n._eventsCount++), n;
}
function Vr(n, t) {
  --n._eventsCount === 0 ? n._events = new Ri() : delete n._events[t];
}
function dt() {
  this._events = new Ri(), this._eventsCount = 0;
}
dt.prototype.eventNames = function() {
  var t = [], e, i;
  if (this._eventsCount === 0) return t;
  for (i in e = this._events) Pc.call(e, i) && t.push(_t ? i.slice(1) : i);
  return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(e)) : t;
};
dt.prototype.listeners = function(t) {
  var e = _t ? _t + t : t, i = this._events[e];
  if (!i) return [];
  if (i.fn) return [
    i.fn
  ];
  for (var r = 0, s = i.length, a = new Array(s); r < s; r++) a[r] = i[r].fn;
  return a;
};
dt.prototype.listenerCount = function(t) {
  var e = _t ? _t + t : t, i = this._events[e];
  return i ? i.fn ? 1 : i.length : 0;
};
dt.prototype.emit = function(t, e, i, r, s, a) {
  var o = _t ? _t + t : t;
  if (!this._events[o]) return !1;
  var c = this._events[o], l = arguments.length, h, u;
  if (c.fn) {
    switch (c.once && this.removeListener(t, c.fn, void 0, !0), l) {
      case 1:
        return c.fn.call(c.context), !0;
      case 2:
        return c.fn.call(c.context, e), !0;
      case 3:
        return c.fn.call(c.context, e, i), !0;
      case 4:
        return c.fn.call(c.context, e, i, r), !0;
      case 5:
        return c.fn.call(c.context, e, i, r, s), !0;
      case 6:
        return c.fn.call(c.context, e, i, r, s, a), !0;
    }
    for (u = 1, h = new Array(l - 1); u < l; u++) h[u - 1] = arguments[u];
    c.fn.apply(c.context, h);
  } else {
    var f = c.length, d;
    for (u = 0; u < f; u++)
      switch (c[u].once && this.removeListener(t, c[u].fn, void 0, !0), l) {
        case 1:
          c[u].fn.call(c[u].context);
          break;
        case 2:
          c[u].fn.call(c[u].context, e);
          break;
        case 3:
          c[u].fn.call(c[u].context, e, i);
          break;
        case 4:
          c[u].fn.call(c[u].context, e, i, r);
          break;
        default:
          if (!h) for (d = 1, h = new Array(l - 1); d < l; d++) h[d - 1] = arguments[d];
          c[u].fn.apply(c[u].context, h);
      }
  }
  return !0;
};
dt.prototype.on = function(t, e, i) {
  return Sa(this, t, e, i, !1);
};
dt.prototype.once = function(t, e, i) {
  return Sa(this, t, e, i, !0);
};
dt.prototype.removeListener = function(t, e, i, r) {
  var s = _t ? _t + t : t;
  if (!this._events[s]) return this;
  if (!e)
    return Vr(this, s), this;
  var a = this._events[s];
  if (a.fn)
    a.fn === e && (!r || a.once) && (!i || a.context === i) && Vr(this, s);
  else {
    for (var o = 0, c = [], l = a.length; o < l; o++) (a[o].fn !== e || r && !a[o].once || i && a[o].context !== i) && c.push(a[o]);
    c.length ? this._events[s] = c.length === 1 ? c[0] : c : Vr(this, s);
  }
  return this;
};
dt.prototype.removeAllListeners = function(t) {
  var e;
  return t ? (e = _t ? _t + t : t, this._events[e] && Vr(this, e)) : (this._events = new Ri(), this._eventsCount = 0), this;
};
dt.prototype.off = dt.prototype.removeListener;
dt.prototype.addListener = dt.prototype.on;
dt.prefixed = _t;
dt.EventEmitter = dt;
lr = dt;
var O = {};
ee(O, "LogLevel", () => St, (n) => St = n);
ee(O, "default", () => Gs, (n) => Gs = n);
var Ee = function(n, t) {
  var e = typeof Symbol == "function" && n[Symbol.iterator];
  if (!e) return n;
  var i = e.call(n), r, s = [], a;
  try {
    for (; (t === void 0 || t-- > 0) && !(r = i.next()).done; ) s.push(r.value);
  } catch (o) {
    a = {
      error: o
    };
  } finally {
    try {
      r && !r.done && (e = i.return) && e.call(i);
    } finally {
      if (a) throw a.error;
    }
  }
  return s;
}, ke = function(n, t, e) {
  if (e || arguments.length === 2)
    for (var i = 0, r = t.length, s; i < r; i++) (s || !(i in t)) && (s || (s = Array.prototype.slice.call(t, 0, i)), s[i] = t[i]);
  return n.concat(s || Array.prototype.slice.call(t));
}, Ec = "PeerJS: ", St;
(function(n) {
  n[n.Disabled = 0] = "Disabled", n[n.Errors = 1] = "Errors", n[n.Warnings = 2] = "Warnings", n[n.All = 3] = "All";
})(St || (St = {}));
var kc = (
  /** @class */
  (function() {
    function n() {
      this._logLevel = St.Disabled;
    }
    return Object.defineProperty(n.prototype, "logLevel", {
      get: function() {
        return this._logLevel;
      },
      set: function(t) {
        this._logLevel = t;
      },
      enumerable: !1,
      configurable: !0
    }), n.prototype.log = function() {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      this._logLevel >= St.All && this._print.apply(this, ke([
        St.All
      ], Ee(t), !1));
    }, n.prototype.warn = function() {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      this._logLevel >= St.Warnings && this._print.apply(this, ke([
        St.Warnings
      ], Ee(t), !1));
    }, n.prototype.error = function() {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      this._logLevel >= St.Errors && this._print.apply(this, ke([
        St.Errors
      ], Ee(t), !1));
    }, n.prototype.setLogFunction = function(t) {
      this._print = t;
    }, n.prototype._print = function(t) {
      for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
      var r = ke([
        Ec
      ], Ee(e), !1);
      for (var s in r) r[s] instanceof Error && (r[s] = "(" + r[s].name + ") " + r[s].message);
      t >= St.All ? console.log.apply(console, ke([], Ee(r), !1)) : t >= St.Warnings ? console.warn.apply(console, ke([
        "WARNING"
      ], Ee(r), !1)) : t >= St.Errors && console.error.apply(console, ke([
        "ERROR"
      ], Ee(r), !1));
    }, n;
  })()
), Gs = new kc(), Ta = {};
ee(Ta, "Socket", () => js, (n) => js = n);
var Jt;
(function(n) {
  n.Data = "data", n.Media = "media";
})(Jt || (Jt = {}));
var Q;
(function(n) {
  n.BrowserIncompatible = "browser-incompatible", n.Disconnected = "disconnected", n.InvalidID = "invalid-id", n.InvalidKey = "invalid-key", n.Network = "network", n.PeerUnavailable = "peer-unavailable", n.SslUnavailable = "ssl-unavailable", n.ServerError = "server-error", n.SocketError = "socket-error", n.SocketClosed = "socket-closed", n.UnavailableID = "unavailable-id", n.WebRTC = "webrtc";
})(Q || (Q = {}));
var fe;
(function(n) {
  n.Binary = "binary", n.BinaryUTF8 = "binary-utf8", n.JSON = "json";
})(fe || (fe = {}));
var pe;
(function(n) {
  n.Message = "message", n.Disconnected = "disconnected", n.Error = "error", n.Close = "close";
})(pe || (pe = {}));
var ut;
(function(n) {
  n.Heartbeat = "HEARTBEAT", n.Candidate = "CANDIDATE", n.Offer = "OFFER", n.Answer = "ANSWER", n.Open = "OPEN", n.Error = "ERROR", n.IdTaken = "ID-TAKEN", n.InvalidKey = "INVALID-KEY", n.Leave = "LEAVE", n.Expire = "EXPIRE";
})(ut || (ut = {}));
var ds = {};
ds = JSON.parse('{"name":"peerjs","version":"1.4.7","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz Stückler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","Sören Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}');
var Rc = /* @__PURE__ */ (function() {
  var n = function(t, e) {
    return n = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (i[s] = r[s]);
    }, n(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
})(), Ac = function(n, t) {
  var e = typeof Symbol == "function" && n[Symbol.iterator];
  if (!e) return n;
  var i = e.call(n), r, s = [], a;
  try {
    for (; (t === void 0 || t-- > 0) && !(r = i.next()).done; ) s.push(r.value);
  } catch (o) {
    a = {
      error: o
    };
  } finally {
    try {
      r && !r.done && (e = i.return) && e.call(i);
    } finally {
      if (a) throw a.error;
    }
  }
  return s;
}, zc = function(n, t, e) {
  if (e || arguments.length === 2)
    for (var i = 0, r = t.length, s; i < r; i++) (s || !(i in t)) && (s || (s = Array.prototype.slice.call(t, 0, i)), s[i] = t[i]);
  return n.concat(s || Array.prototype.slice.call(t));
}, Oc = function(n) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && n[t], i = 0;
  if (e) return e.call(n);
  if (n && typeof n.length == "number") return {
    next: function() {
      return n && i >= n.length && (n = void 0), {
        value: n && n[i++],
        done: !n
      };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, js = (
  /** @class */
  (function(n) {
    Rc(t, n);
    function t(e, i, r, s, a, o) {
      o === void 0 && (o = 5e3);
      var c = n.call(this) || this;
      c.pingInterval = o, c._disconnected = !0, c._messagesQueue = [];
      var l = e ? "wss://" : "ws://";
      return c._baseUrl = l + i + ":" + r + s + "peerjs?key=" + a, c;
    }
    return t.prototype.start = function(e, i) {
      var r = this;
      this._id = e;
      var s = "".concat(this._baseUrl, "&id=").concat(e, "&token=").concat(i);
      this._socket || !this._disconnected || (this._socket = new WebSocket(s + "&version=" + ds.version), this._disconnected = !1, this._socket.onmessage = function(a) {
        var o;
        try {
          o = JSON.parse(a.data), O.default.log("Server message received:", o);
        } catch {
          O.default.log("Invalid server message", a.data);
          return;
        }
        r.emit(pe.Message, o);
      }, this._socket.onclose = function(a) {
        r._disconnected || (O.default.log("Socket closed.", a), r._cleanup(), r._disconnected = !0, r.emit(pe.Disconnected));
      }, this._socket.onopen = function() {
        r._disconnected || (r._sendQueuedMessages(), O.default.log("Socket open"), r._scheduleHeartbeat());
      });
    }, t.prototype._scheduleHeartbeat = function() {
      var e = this;
      this._wsPingTimer = setTimeout(function() {
        e._sendHeartbeat();
      }, this.pingInterval);
    }, t.prototype._sendHeartbeat = function() {
      if (!this._wsOpen()) {
        O.default.log("Cannot send heartbeat, because socket closed");
        return;
      }
      var e = JSON.stringify({
        type: ut.Heartbeat
      });
      this._socket.send(e), this._scheduleHeartbeat();
    }, t.prototype._wsOpen = function() {
      return !!this._socket && this._socket.readyState === 1;
    }, t.prototype._sendQueuedMessages = function() {
      var e, i, r = zc([], Ac(this._messagesQueue), !1);
      this._messagesQueue = [];
      try {
        for (var s = Oc(r), a = s.next(); !a.done; a = s.next()) {
          var o = a.value;
          this.send(o);
        }
      } catch (c) {
        e = {
          error: c
        };
      } finally {
        try {
          a && !a.done && (i = s.return) && i.call(s);
        } finally {
          if (e) throw e.error;
        }
      }
    }, t.prototype.send = function(e) {
      if (!this._disconnected) {
        if (!this._id) {
          this._messagesQueue.push(e);
          return;
        }
        if (!e.type) {
          this.emit(pe.Error, "Invalid message");
          return;
        }
        if (this._wsOpen()) {
          var i = JSON.stringify(e);
          this._socket.send(i);
        }
      }
    }, t.prototype.close = function() {
      this._disconnected || (this._cleanup(), this._disconnected = !0);
    }, t.prototype._cleanup = function() {
      this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer);
    }, t;
  })(lr.EventEmitter)
), Xn = {};
ee(Xn, "MediaConnection", () => Xs, (n) => Xs = n);
var ps = {};
ee(ps, "Negotiator", () => $s, (n) => $s = n);
var jr = function() {
  return jr = Object.assign || function(n) {
    for (var t, e = 1, i = arguments.length; e < i; e++) {
      t = arguments[e];
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, jr.apply(this, arguments);
}, fr = function(n, t, e, i) {
  function r(s) {
    return s instanceof e ? s : new e(function(a) {
      a(s);
    });
  }
  return new (e || (e = Promise))(function(s, a) {
    function o(h) {
      try {
        l(i.next(h));
      } catch (u) {
        a(u);
      }
    }
    function c(h) {
      try {
        l(i.throw(h));
      } catch (u) {
        a(u);
      }
    }
    function l(h) {
      h.done ? s(h.value) : r(h.value).then(o, c);
    }
    l((i = i.apply(n, t || [])).next());
  });
}, dr = function(n, t) {
  var e = {
    label: 0,
    sent: function() {
      if (s[0] & 1) throw s[1];
      return s[1];
    },
    trys: [],
    ops: []
  }, i, r, s, a;
  return a = {
    next: o(0),
    throw: o(1),
    return: o(2)
  }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(h) {
      return c([
        l,
        h
      ]);
    };
  }
  function c(l) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; e; ) try {
      if (i = 1, r && (s = l[0] & 2 ? r.return : l[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, l[1])).done) return s;
      switch (r = 0, s && (l = [
        l[0] & 2,
        s.value
      ]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return e.label++, {
            value: l[1],
            done: !1
          };
        case 5:
          e.label++, r = l[1], l = [
            0
          ];
          continue;
        case 7:
          l = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            e = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            e.label = l[1];
            break;
          }
          if (l[0] === 6 && e.label < s[1]) {
            e.label = s[1], s = l;
            break;
          }
          if (s && e.label < s[2]) {
            e.label = s[2], e.ops.push(l);
            break;
          }
          s[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      l = t.call(n, e);
    } catch (h) {
      l = [
        6,
        h
      ], r = 0;
    } finally {
      i = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return {
      value: l[0] ? l[1] : void 0,
      done: !0
    };
  }
}, $s = (
  /** @class */
  (function() {
    function n(t) {
      this.connection = t;
    }
    return n.prototype.startConnection = function(t) {
      var e = this._startPeerConnection();
      if (this.connection.peerConnection = e, this.connection.type === Jt.Media && t._stream && this._addTracksToConnection(t._stream, e), t.originator) {
        if (this.connection.type === Jt.Data) {
          var i = this.connection, r = {
            ordered: !!t.reliable
          }, s = e.createDataChannel(i.label, r);
          i.initialize(s);
        }
        this._makeOffer();
      } else this.handleSDP("OFFER", t.sdp);
    }, n.prototype._startPeerConnection = function() {
      O.default.log("Creating RTCPeerConnection.");
      var t = new RTCPeerConnection(this.connection.provider.options.config);
      return this._setupListeners(t), t;
    }, n.prototype._setupListeners = function(t) {
      var e = this, i = this.connection.peer, r = this.connection.connectionId, s = this.connection.type, a = this.connection.provider;
      O.default.log("Listening for ICE candidates."), t.onicecandidate = function(o) {
        !o.candidate || !o.candidate.candidate || (O.default.log("Received ICE candidates for ".concat(i, ":"), o.candidate), a.socket.send({
          type: ut.Candidate,
          payload: {
            candidate: o.candidate,
            type: s,
            connectionId: r
          },
          dst: i
        }));
      }, t.oniceconnectionstatechange = function() {
        switch (t.iceConnectionState) {
          case "failed":
            O.default.log("iceConnectionState is failed, closing connections to " + i), e.connection.emit("error", new Error("Negotiation of connection to " + i + " failed.")), e.connection.close();
            break;
          case "closed":
            O.default.log("iceConnectionState is closed, closing connections to " + i), e.connection.emit("error", new Error("Connection to " + i + " closed.")), e.connection.close();
            break;
          case "disconnected":
            O.default.log("iceConnectionState changed to disconnected on the connection with " + i);
            break;
          case "completed":
            t.onicecandidate = D.noop;
            break;
        }
        e.connection.emit("iceStateChanged", t.iceConnectionState);
      }, O.default.log("Listening for data channel"), t.ondatachannel = function(o) {
        O.default.log("Received data channel");
        var c = o.channel, l = a.getConnection(i, r);
        l.initialize(c);
      }, O.default.log("Listening for remote stream"), t.ontrack = function(o) {
        O.default.log("Received remote stream");
        var c = o.streams[0], l = a.getConnection(i, r);
        if (l.type === Jt.Media) {
          var h = l;
          e._addStreamToMediaConnection(c, h);
        }
      };
    }, n.prototype.cleanup = function() {
      O.default.log("Cleaning up PeerConnection to " + this.connection.peer);
      var t = this.connection.peerConnection;
      if (t) {
        this.connection.peerConnection = null, t.onicecandidate = t.oniceconnectionstatechange = t.ondatachannel = t.ontrack = function() {
        };
        var e = t.signalingState !== "closed", i = !1;
        if (this.connection.type === Jt.Data) {
          var r = this.connection, s = r.dataChannel;
          s && (i = !!s.readyState && s.readyState !== "closed");
        }
        (e || i) && t.close();
      }
    }, n.prototype._makeOffer = function() {
      return fr(this, void 0, Promise, function() {
        var t, e, i, r, s, a, o;
        return dr(this, function(c) {
          switch (c.label) {
            case 0:
              t = this.connection.peerConnection, e = this.connection.provider, c.label = 1;
            case 1:
              return c.trys.push([
                1,
                7,
                ,
                8
              ]), [
                4,
                t.createOffer(this.connection.options.constraints)
              ];
            case 2:
              i = c.sent(), O.default.log("Created offer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (i.sdp = this.connection.options.sdpTransform(i.sdp) || i.sdp), c.label = 3;
            case 3:
              return c.trys.push([
                3,
                5,
                ,
                6
              ]), [
                4,
                t.setLocalDescription(i)
              ];
            case 4:
              return c.sent(), O.default.log("Set localDescription:", i, "for:".concat(this.connection.peer)), r = {
                sdp: i,
                type: this.connection.type,
                connectionId: this.connection.connectionId,
                metadata: this.connection.metadata,
                browser: D.browser
              }, this.connection.type === Jt.Data && (s = this.connection, r = jr(jr({}, r), {
                label: s.label,
                reliable: s.reliable,
                serialization: s.serialization
              })), e.socket.send({
                type: ut.Offer,
                payload: r,
                dst: this.connection.peer
              }), [
                3,
                6
              ];
            case 5:
              return a = c.sent(), a != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" && (e.emitError(Q.WebRTC, a), O.default.log("Failed to setLocalDescription, ", a)), [
                3,
                6
              ];
            case 6:
              return [
                3,
                8
              ];
            case 7:
              return o = c.sent(), e.emitError(Q.WebRTC, o), O.default.log("Failed to createOffer, ", o), [
                3,
                8
              ];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype._makeAnswer = function() {
      return fr(this, void 0, Promise, function() {
        var t, e, i, r, s;
        return dr(this, function(a) {
          switch (a.label) {
            case 0:
              t = this.connection.peerConnection, e = this.connection.provider, a.label = 1;
            case 1:
              return a.trys.push([
                1,
                7,
                ,
                8
              ]), [
                4,
                t.createAnswer()
              ];
            case 2:
              i = a.sent(), O.default.log("Created answer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (i.sdp = this.connection.options.sdpTransform(i.sdp) || i.sdp), a.label = 3;
            case 3:
              return a.trys.push([
                3,
                5,
                ,
                6
              ]), [
                4,
                t.setLocalDescription(i)
              ];
            case 4:
              return a.sent(), O.default.log("Set localDescription:", i, "for:".concat(this.connection.peer)), e.socket.send({
                type: ut.Answer,
                payload: {
                  sdp: i,
                  type: this.connection.type,
                  connectionId: this.connection.connectionId,
                  browser: D.browser
                },
                dst: this.connection.peer
              }), [
                3,
                6
              ];
            case 5:
              return r = a.sent(), e.emitError(Q.WebRTC, r), O.default.log("Failed to setLocalDescription, ", r), [
                3,
                6
              ];
            case 6:
              return [
                3,
                8
              ];
            case 7:
              return s = a.sent(), e.emitError(Q.WebRTC, s), O.default.log("Failed to create answer, ", s), [
                3,
                8
              ];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.handleSDP = function(t, e) {
      return fr(this, void 0, Promise, function() {
        var i, r, s, a;
        return dr(this, function(o) {
          switch (o.label) {
            case 0:
              e = new RTCSessionDescription(e), i = this.connection.peerConnection, r = this.connection.provider, O.default.log("Setting remote description", e), s = this, o.label = 1;
            case 1:
              return o.trys.push([
                1,
                5,
                ,
                6
              ]), [
                4,
                i.setRemoteDescription(e)
              ];
            case 2:
              return o.sent(), O.default.log("Set remoteDescription:".concat(t, " for:").concat(this.connection.peer)), t !== "OFFER" ? [
                3,
                4
              ] : [
                4,
                s._makeAnswer()
              ];
            case 3:
              o.sent(), o.label = 4;
            case 4:
              return [
                3,
                6
              ];
            case 5:
              return a = o.sent(), r.emitError(Q.WebRTC, a), O.default.log("Failed to setRemoteDescription, ", a), [
                3,
                6
              ];
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.handleCandidate = function(t) {
      return fr(this, void 0, Promise, function() {
        var e, i, r, s, a, o;
        return dr(this, function(c) {
          switch (c.label) {
            case 0:
              O.default.log("handleCandidate:", t), e = t.candidate, i = t.sdpMLineIndex, r = t.sdpMid, s = this.connection.peerConnection, a = this.connection.provider, c.label = 1;
            case 1:
              return c.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                s.addIceCandidate(new RTCIceCandidate({
                  sdpMid: r,
                  sdpMLineIndex: i,
                  candidate: e
                }))
              ];
            case 2:
              return c.sent(), O.default.log("Added ICE candidate for:".concat(this.connection.peer)), [
                3,
                4
              ];
            case 3:
              return o = c.sent(), a.emitError(Q.WebRTC, o), O.default.log("Failed to handleCandidate, ", o), [
                3,
                4
              ];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype._addTracksToConnection = function(t, e) {
      if (O.default.log("add tracks from stream ".concat(t.id, " to peer connection")), !e.addTrack) return O.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored.");
      t.getTracks().forEach(function(i) {
        e.addTrack(i, t);
      });
    }, n.prototype._addStreamToMediaConnection = function(t, e) {
      O.default.log("add stream ".concat(t.id, " to media connection ").concat(e.connectionId)), e.addStream(t);
    }, n;
  })()
), ms = {};
ee(ms, "BaseConnection", () => qs, (n) => qs = n);
var Bc = /* @__PURE__ */ (function() {
  var n = function(t, e) {
    return n = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (i[s] = r[s]);
    }, n(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
})(), qs = (
  /** @class */
  (function(n) {
    Bc(t, n);
    function t(e, i, r) {
      var s = n.call(this) || this;
      return s.peer = e, s.provider = i, s.options = r, s._open = !1, s.metadata = r.metadata, s;
    }
    return Object.defineProperty(t.prototype, "open", {
      get: function() {
        return this._open;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  })(lr.EventEmitter)
), Ic = /* @__PURE__ */ (function() {
  var n = function(t, e) {
    return n = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (i[s] = r[s]);
    }, n(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
})(), $r = function() {
  return $r = Object.assign || function(n) {
    for (var t, e = 1, i = arguments.length; e < i; e++) {
      t = arguments[e];
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, $r.apply(this, arguments);
}, Nc = function(n) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && n[t], i = 0;
  if (e) return e.call(n);
  if (n && typeof n.length == "number") return {
    next: function() {
      return n && i >= n.length && (n = void 0), {
        value: n && n[i++],
        done: !n
      };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Xs = (
  /** @class */
  (function(n) {
    Ic(t, n);
    function t(e, i, r) {
      var s = n.call(this, e, i, r) || this;
      return s._localStream = s.options._stream, s.connectionId = s.options.connectionId || t.ID_PREFIX + D.randomToken(), s._negotiator = new ps.Negotiator(s), s._localStream && s._negotiator.startConnection({
        _stream: s._localStream,
        originator: !0
      }), s;
    }
    return Object.defineProperty(t.prototype, "type", {
      get: function() {
        return Jt.Media;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "localStream", {
      get: function() {
        return this._localStream;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "remoteStream", {
      get: function() {
        return this._remoteStream;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.addStream = function(e) {
      O.default.log("Receiving stream", e), this._remoteStream = e, n.prototype.emit.call(this, "stream", e);
    }, t.prototype.handleMessage = function(e) {
      var i = e.type, r = e.payload;
      switch (e.type) {
        case ut.Answer:
          this._negotiator.handleSDP(i, r.sdp), this._open = !0;
          break;
        case ut.Candidate:
          this._negotiator.handleCandidate(r.candidate);
          break;
        default:
          O.default.warn("Unrecognized message type:".concat(i, " from peer:").concat(this.peer));
          break;
      }
    }, t.prototype.answer = function(e, i) {
      var r, s;
      if (i === void 0 && (i = {}), this._localStream) {
        O.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?");
        return;
      }
      this._localStream = e, i && i.sdpTransform && (this.options.sdpTransform = i.sdpTransform), this._negotiator.startConnection($r($r({}, this.options._payload), {
        _stream: e
      }));
      var a = this.provider._getMessages(this.connectionId);
      try {
        for (var o = Nc(a), c = o.next(); !c.done; c = o.next()) {
          var l = c.value;
          this.handleMessage(l);
        }
      } catch (h) {
        r = {
          error: h
        };
      } finally {
        try {
          c && !c.done && (s = o.return) && s.call(o);
        } finally {
          if (r) throw r.error;
        }
      }
      this._open = !0;
    }, t.prototype.close = function() {
      this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, n.prototype.emit.call(this, "close"));
    }, t.ID_PREFIX = "mc_", t;
  })(ms.BaseConnection)
), Hn = {};
ee(Hn, "DataConnection", () => Ws, (n) => Ws = n);
var Ca = {};
ee(Ca, "EncodingQueue", () => Hs, (n) => Hs = n);
var Uc = /* @__PURE__ */ (function() {
  var n = function(t, e) {
    return n = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (i[s] = r[s]);
    }, n(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
})(), Hs = (
  /** @class */
  (function(n) {
    Uc(t, n);
    function t() {
      var e = n.call(this) || this;
      return e.fileReader = new FileReader(), e._queue = [], e._processing = !1, e.fileReader.onload = function(i) {
        e._processing = !1, i.target && e.emit("done", i.target.result), e.doNextTask();
      }, e.fileReader.onerror = function(i) {
        O.default.error("EncodingQueue error:", i), e._processing = !1, e.destroy(), e.emit("error", i);
      }, e;
    }
    return Object.defineProperty(t.prototype, "queue", {
      get: function() {
        return this._queue;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "size", {
      get: function() {
        return this.queue.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "processing", {
      get: function() {
        return this._processing;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.enque = function(e) {
      this.queue.push(e), !this.processing && this.doNextTask();
    }, t.prototype.destroy = function() {
      this.fileReader.abort(), this._queue = [];
    }, t.prototype.doNextTask = function() {
      this.size !== 0 && (this.processing || (this._processing = !0, this.fileReader.readAsArrayBuffer(this.queue.shift())));
    }, t;
  })(lr.EventEmitter)
), Fc = /* @__PURE__ */ (function() {
  var n = function(t, e) {
    return n = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (i[s] = r[s]);
    }, n(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
})(), Dc = function(n) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && n[t], i = 0;
  if (e) return e.call(n);
  if (n && typeof n.length == "number") return {
    next: function() {
      return n && i >= n.length && (n = void 0), {
        value: n && n[i++],
        done: !n
      };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Ws = (
  /** @class */
  (function(n) {
    Fc(t, n);
    function t(e, i, r) {
      var s = n.call(this, e, i, r) || this;
      return s.stringify = JSON.stringify, s.parse = JSON.parse, s._buffer = [], s._bufferSize = 0, s._buffering = !1, s._chunkedData = {}, s._encodingQueue = new Ca.EncodingQueue(), s.connectionId = s.options.connectionId || t.ID_PREFIX + D.randomToken(), s.label = s.options.label || s.connectionId, s.serialization = s.options.serialization || fe.Binary, s.reliable = !!s.options.reliable, s._encodingQueue.on("done", function(a) {
        s._bufferedSend(a);
      }), s._encodingQueue.on("error", function() {
        O.default.error("DC#".concat(s.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC")), s.close();
      }), s._negotiator = new ps.Negotiator(s), s._negotiator.startConnection(s.options._payload || {
        originator: !0
      }), s;
    }
    return Object.defineProperty(t.prototype, "type", {
      get: function() {
        return Jt.Data;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "dataChannel", {
      get: function() {
        return this._dc;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "bufferSize", {
      get: function() {
        return this._bufferSize;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.initialize = function(e) {
      this._dc = e, this._configureDataChannel();
    }, t.prototype._configureDataChannel = function() {
      var e = this;
      (!D.supports.binaryBlob || D.supports.reliable) && (this.dataChannel.binaryType = "arraybuffer"), this.dataChannel.onopen = function() {
        O.default.log("DC#".concat(e.connectionId, " dc connection success")), e._open = !0, e.emit("open");
      }, this.dataChannel.onmessage = function(i) {
        O.default.log("DC#".concat(e.connectionId, " dc onmessage:"), i.data), e._handleDataMessage(i);
      }, this.dataChannel.onclose = function() {
        O.default.log("DC#".concat(e.connectionId, " dc closed for:"), e.peer), e.close();
      };
    }, t.prototype._handleDataMessage = function(e) {
      var i = this, r = e.data, s = r.constructor, a = this.serialization === fe.Binary || this.serialization === fe.BinaryUTF8, o = r;
      if (a) {
        if (s === Blob) {
          D.blobToArrayBuffer(r, function(l) {
            var h = D.unpack(l);
            i.emit("data", h);
          });
          return;
        } else if (s === ArrayBuffer) o = D.unpack(r);
        else if (s === String) {
          var c = D.binaryStringToArrayBuffer(r);
          o = D.unpack(c);
        }
      } else this.serialization === fe.JSON && (o = this.parse(r));
      if (o.__peerData) {
        this._handleChunk(o);
        return;
      }
      n.prototype.emit.call(this, "data", o);
    }, t.prototype._handleChunk = function(e) {
      var i = e.__peerData, r = this._chunkedData[i] || {
        data: [],
        count: 0,
        total: e.total
      };
      if (r.data[e.n] = e.data, r.count++, this._chunkedData[i] = r, r.total === r.count) {
        delete this._chunkedData[i];
        var s = new Blob(r.data);
        this._handleDataMessage({
          data: s
        });
      }
    }, t.prototype.close = function() {
      this._buffer = [], this._bufferSize = 0, this._chunkedData = {}, this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this._dc = null), this._encodingQueue && (this._encodingQueue.destroy(), this._encodingQueue.removeAllListeners(), this._encodingQueue = null), this.open && (this._open = !1, n.prototype.emit.call(this, "close"));
    }, t.prototype.send = function(e, i) {
      if (!this.open) {
        n.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages."));
        return;
      }
      if (this.serialization === fe.JSON) this._bufferedSend(this.stringify(e));
      else if (this.serialization === fe.Binary || this.serialization === fe.BinaryUTF8) {
        var r = D.pack(e);
        if (!i && r.size > D.chunkedMTU) {
          this._sendChunks(r);
          return;
        }
        D.supports.binaryBlob ? this._bufferedSend(r) : this._encodingQueue.enque(r);
      } else this._bufferedSend(e);
    }, t.prototype._bufferedSend = function(e) {
      (this._buffering || !this._trySend(e)) && (this._buffer.push(e), this._bufferSize = this._buffer.length);
    }, t.prototype._trySend = function(e) {
      var i = this;
      if (!this.open) return !1;
      if (this.dataChannel.bufferedAmount > t.MAX_BUFFERED_AMOUNT)
        return this._buffering = !0, setTimeout(function() {
          i._buffering = !1, i._tryBuffer();
        }, 50), !1;
      try {
        this.dataChannel.send(e);
      } catch (r) {
        return O.default.error("DC#:".concat(this.connectionId, " Error when sending:"), r), this._buffering = !0, this.close(), !1;
      }
      return !0;
    }, t.prototype._tryBuffer = function() {
      if (this.open && this._buffer.length !== 0) {
        var e = this._buffer[0];
        this._trySend(e) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer());
      }
    }, t.prototype._sendChunks = function(e) {
      var i, r, s = D.chunk(e);
      O.default.log("DC#".concat(this.connectionId, " Try to send ").concat(s.length, " chunks..."));
      try {
        for (var a = Dc(s), o = a.next(); !o.done; o = a.next()) {
          var c = o.value;
          this.send(c, !0);
        }
      } catch (l) {
        i = {
          error: l
        };
      } finally {
        try {
          o && !o.done && (r = a.return) && r.call(a);
        } finally {
          if (i) throw i.error;
        }
      }
    }, t.prototype.handleMessage = function(e) {
      var i = e.payload;
      switch (e.type) {
        case ut.Answer:
          this._negotiator.handleSDP(e.type, i.sdp);
          break;
        case ut.Candidate:
          this._negotiator.handleCandidate(i.candidate);
          break;
        default:
          O.default.warn("Unrecognized message type:", e.type, "from peer:", this.peer);
          break;
      }
    }, t.ID_PREFIX = "dc_", t.MAX_BUFFERED_AMOUNT = 8388608, t;
  })(ms.BaseConnection)
), Ma = {};
ee(Ma, "API", () => Ks, (n) => Ks = n);
var Ys = function(n, t, e, i) {
  function r(s) {
    return s instanceof e ? s : new e(function(a) {
      a(s);
    });
  }
  return new (e || (e = Promise))(function(s, a) {
    function o(h) {
      try {
        l(i.next(h));
      } catch (u) {
        a(u);
      }
    }
    function c(h) {
      try {
        l(i.throw(h));
      } catch (u) {
        a(u);
      }
    }
    function l(h) {
      h.done ? s(h.value) : r(h.value).then(o, c);
    }
    l((i = i.apply(n, t || [])).next());
  });
}, Zs = function(n, t) {
  var e = {
    label: 0,
    sent: function() {
      if (s[0] & 1) throw s[1];
      return s[1];
    },
    trys: [],
    ops: []
  }, i, r, s, a;
  return a = {
    next: o(0),
    throw: o(1),
    return: o(2)
  }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(h) {
      return c([
        l,
        h
      ]);
    };
  }
  function c(l) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; e; ) try {
      if (i = 1, r && (s = l[0] & 2 ? r.return : l[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, l[1])).done) return s;
      switch (r = 0, s && (l = [
        l[0] & 2,
        s.value
      ]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return e.label++, {
            value: l[1],
            done: !1
          };
        case 5:
          e.label++, r = l[1], l = [
            0
          ];
          continue;
        case 7:
          l = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            e = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            e.label = l[1];
            break;
          }
          if (l[0] === 6 && e.label < s[1]) {
            e.label = s[1], s = l;
            break;
          }
          if (s && e.label < s[2]) {
            e.label = s[2], e.ops.push(l);
            break;
          }
          s[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      l = t.call(n, e);
    } catch (h) {
      l = [
        6,
        h
      ], r = 0;
    } finally {
      i = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return {
      value: l[0] ? l[1] : void 0,
      done: !0
    };
  }
}, Ks = (
  /** @class */
  (function() {
    function n(t) {
      this._options = t;
    }
    return n.prototype._buildRequest = function(t) {
      var e = this._options.secure ? "https" : "http", i = this._options, r = i.host, s = i.port, a = i.path, o = i.key, c = new URL("".concat(e, "://").concat(r, ":").concat(s).concat(a).concat(o, "/").concat(t));
      return c.searchParams.set("ts", "".concat(Date.now()).concat(Math.random())), c.searchParams.set("version", ds.version), fetch(c.href, {
        referrerPolicy: this._options.referrerPolicy
      });
    }, n.prototype.retrieveId = function() {
      return Ys(this, void 0, Promise, function() {
        var t, e, i;
        return Zs(this, function(r) {
          switch (r.label) {
            case 0:
              return r.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                this._buildRequest("id")
              ];
            case 1:
              if (t = r.sent(), t.status !== 200) throw new Error("Error. Status:".concat(t.status));
              return [
                2,
                t.text()
              ];
            case 2:
              throw e = r.sent(), O.default.error("Error retrieving ID", e), i = "", this._options.path === "/" && this._options.host !== D.CLOUD_HOST && (i = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), new Error("Could not get an ID from the server." + i);
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.listAllPeers = function() {
      return Ys(this, void 0, Promise, function() {
        var t, e, i;
        return Zs(this, function(r) {
          switch (r.label) {
            case 0:
              return r.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                this._buildRequest("peers")
              ];
            case 1:
              if (t = r.sent(), t.status !== 200)
                throw t.status === 401 ? (e = "", this._options.host === D.CLOUD_HOST ? e = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : e = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", new Error("It doesn't look like you have permission to list peers IDs. " + e)) : new Error("Error. Status:".concat(t.status));
              return [
                2,
                t.json()
              ];
            case 2:
              throw i = r.sent(), O.default.error("Error retrieving list peers", i), new Error("Could not get list peers from the server." + i);
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n;
  })()
), Lc = /* @__PURE__ */ (function() {
  var n = function(t, e) {
    return n = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (i[s] = r[s]);
    }, n(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
})(), wi = function() {
  return wi = Object.assign || function(n) {
    for (var t, e = 1, i = arguments.length; e < i; e++) {
      t = arguments[e];
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, wi.apply(this, arguments);
}, ui = function(n) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && n[t], i = 0;
  if (e) return e.call(n);
  if (n && typeof n.length == "number") return {
    next: function() {
      return n && i >= n.length && (n = void 0), {
        value: n && n[i++],
        done: !n
      };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Vc = function(n, t) {
  var e = typeof Symbol == "function" && n[Symbol.iterator];
  if (!e) return n;
  var i = e.call(n), r, s = [], a;
  try {
    for (; (t === void 0 || t-- > 0) && !(r = i.next()).done; ) s.push(r.value);
  } catch (o) {
    a = {
      error: o
    };
  } finally {
    try {
      r && !r.done && (e = i.return) && e.call(i);
    } finally {
      if (a) throw a.error;
    }
  }
  return s;
}, Wn = (
  /** @class */
  (function(n) {
    Lc(t, n);
    function t(e, i) {
      var r = n.call(this) || this;
      r._id = null, r._lastServerId = null, r._destroyed = !1, r._disconnected = !1, r._open = !1, r._connections = /* @__PURE__ */ new Map(), r._lostMessages = /* @__PURE__ */ new Map();
      var s;
      return e && e.constructor == Object ? i = e : e && (s = e.toString()), i = wi({
        debug: 0,
        host: D.CLOUD_HOST,
        port: D.CLOUD_PORT,
        path: "/",
        key: t.DEFAULT_KEY,
        token: D.randomToken(),
        config: D.defaultConfig,
        referrerPolicy: "strict-origin-when-cross-origin"
      }, i), r._options = i, r._options.host === "/" && (r._options.host = window.location.hostname), r._options.path && (r._options.path[0] !== "/" && (r._options.path = "/" + r._options.path), r._options.path[r._options.path.length - 1] !== "/" && (r._options.path += "/")), r._options.secure === void 0 && r._options.host !== D.CLOUD_HOST ? r._options.secure = D.isSecure() : r._options.host == D.CLOUD_HOST && (r._options.secure = !0), r._options.logFunction && O.default.setLogFunction(r._options.logFunction), O.default.logLevel = r._options.debug || 0, r._api = new Ma.API(i), r._socket = r._createServerConnection(), !D.supports.audioVideo && !D.supports.data ? (r._delayedAbort(Q.BrowserIncompatible, "The current browser does not support WebRTC"), r) : s && !D.validateId(s) ? (r._delayedAbort(Q.InvalidID, 'ID "'.concat(s, '" is invalid')), r) : (s ? r._initialize(s) : r._api.retrieveId().then(function(a) {
        return r._initialize(a);
      }).catch(function(a) {
        return r._abort(Q.ServerError, a);
      }), r);
    }
    return Object.defineProperty(t.prototype, "id", {
      /**
       * The brokering ID of this peer
       */
      get: function() {
        return this._id;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "options", {
      get: function() {
        return this._options;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "open", {
      get: function() {
        return this._open;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "socket", {
      get: function() {
        return this._socket;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "connections", {
      /**
       * A hash of all connections associated with this peer, keyed by the remote peer's ID.
       * @deprecated
       * Return type will change from Object to Map<string,[]>
       */
      get: function() {
        var e, i, r = /* @__PURE__ */ Object.create(null);
        try {
          for (var s = ui(this._connections), a = s.next(); !a.done; a = s.next()) {
            var o = Vc(a.value, 2), c = o[0], l = o[1];
            r[c] = l;
          }
        } catch (h) {
          e = {
            error: h
          };
        } finally {
          try {
            a && !a.done && (i = s.return) && i.call(s);
          } finally {
            if (e) throw e.error;
          }
        }
        return r;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "destroyed", {
      /**
       * true if this peer and all of its connections can no longer be used.
       */
      get: function() {
        return this._destroyed;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "disconnected", {
      /**
       * false if there is an active connection to the PeerServer.
       */
      get: function() {
        return this._disconnected;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._createServerConnection = function() {
      var e = this, i = new Ta.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);
      return i.on(pe.Message, function(r) {
        e._handleMessage(r);
      }), i.on(pe.Error, function(r) {
        e._abort(Q.SocketError, r);
      }), i.on(pe.Disconnected, function() {
        e.disconnected || (e.emitError(Q.Network, "Lost connection to server."), e.disconnect());
      }), i.on(pe.Close, function() {
        e.disconnected || e._abort(Q.SocketClosed, "Underlying socket is already closed.");
      }), i;
    }, t.prototype._initialize = function(e) {
      this._id = e, this.socket.start(e, this._options.token);
    }, t.prototype._handleMessage = function(e) {
      var i, r, s = e.type, a = e.payload, o = e.src;
      switch (s) {
        case ut.Open:
          this._lastServerId = this.id, this._open = !0, this.emit("open", this.id);
          break;
        case ut.Error:
          this._abort(Q.ServerError, a.msg);
          break;
        case ut.IdTaken:
          this._abort(Q.UnavailableID, 'ID "'.concat(this.id, '" is taken'));
          break;
        case ut.InvalidKey:
          this._abort(Q.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid'));
          break;
        case ut.Leave:
          O.default.log("Received leave message from ".concat(o)), this._cleanupPeer(o), this._connections.delete(o);
          break;
        case ut.Expire:
          this.emitError(Q.PeerUnavailable, "Could not connect to peer ".concat(o));
          break;
        case ut.Offer:
          var y = a.connectionId, _ = this.getConnection(o, y);
          if (_ && (_.close(), O.default.warn("Offer received for existing Connection ID:".concat(y))), a.type === Jt.Media) {
            var c = new Xn.MediaConnection(o, this, {
              connectionId: y,
              _payload: a,
              metadata: a.metadata
            });
            _ = c, this._addConnection(o, _), this.emit("call", c);
          } else if (a.type === Jt.Data) {
            var l = new Hn.DataConnection(o, this, {
              connectionId: y,
              _payload: a,
              metadata: a.metadata,
              label: a.label,
              serialization: a.serialization,
              reliable: a.reliable
            });
            _ = l, this._addConnection(o, _), this.emit("connection", l);
          } else {
            O.default.warn("Received malformed connection type:".concat(a.type));
            return;
          }
          var h = this._getMessages(y);
          try {
            for (var u = ui(h), f = u.next(); !f.done; f = u.next()) {
              var d = f.value;
              _.handleMessage(d);
            }
          } catch (p) {
            i = {
              error: p
            };
          } finally {
            try {
              f && !f.done && (r = u.return) && r.call(u);
            } finally {
              if (i) throw i.error;
            }
          }
          break;
        default:
          if (!a) {
            O.default.warn("You received a malformed message from ".concat(o, " of type ").concat(s));
            return;
          }
          var y = a.connectionId, _ = this.getConnection(o, y);
          _ && _.peerConnection ? _.handleMessage(e) : y ? this._storeMessage(y, e) : O.default.warn("You received an unrecognized message:", e);
          break;
      }
    }, t.prototype._storeMessage = function(e, i) {
      this._lostMessages.has(e) || this._lostMessages.set(e, []), this._lostMessages.get(e).push(i);
    }, t.prototype._getMessages = function(e) {
      var i = this._lostMessages.get(e);
      return i ? (this._lostMessages.delete(e), i) : [];
    }, t.prototype.connect = function(e, i) {
      if (i === void 0 && (i = {}), this.disconnected) {
        O.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(Q.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
        return;
      }
      var r = new Hn.DataConnection(e, this, i);
      return this._addConnection(e, r), r;
    }, t.prototype.call = function(e, i, r) {
      if (r === void 0 && (r = {}), this.disconnected) {
        O.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(Q.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
        return;
      }
      if (!i) {
        O.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`.");
        return;
      }
      var s = new Xn.MediaConnection(e, this, wi(wi({}, r), {
        _stream: i
      }));
      return this._addConnection(e, s), s;
    }, t.prototype._addConnection = function(e, i) {
      O.default.log("add connection ".concat(i.type, ":").concat(i.connectionId, " to peerId:").concat(e)), this._connections.has(e) || this._connections.set(e, []), this._connections.get(e).push(i);
    }, t.prototype._removeConnection = function(e) {
      var i = this._connections.get(e.peer);
      if (i) {
        var r = i.indexOf(e);
        r !== -1 && i.splice(r, 1);
      }
      this._lostMessages.delete(e.connectionId);
    }, t.prototype.getConnection = function(e, i) {
      var r, s, a = this._connections.get(e);
      if (!a) return null;
      try {
        for (var o = ui(a), c = o.next(); !c.done; c = o.next()) {
          var l = c.value;
          if (l.connectionId === i) return l;
        }
      } catch (h) {
        r = {
          error: h
        };
      } finally {
        try {
          c && !c.done && (s = o.return) && s.call(o);
        } finally {
          if (r) throw r.error;
        }
      }
      return null;
    }, t.prototype._delayedAbort = function(e, i) {
      var r = this;
      setTimeout(function() {
        r._abort(e, i);
      }, 0);
    }, t.prototype._abort = function(e, i) {
      O.default.error("Aborting!"), this.emitError(e, i), this._lastServerId ? this.disconnect() : this.destroy();
    }, t.prototype.emitError = function(e, i) {
      O.default.error("Error:", i);
      var r;
      typeof i == "string" ? r = new Error(i) : r = i, r.type = e, this.emit("error", r);
    }, t.prototype.destroy = function() {
      this.destroyed || (O.default.log("Destroy peer with ID:".concat(this.id)), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close"));
    }, t.prototype._cleanup = function() {
      var e, i;
      try {
        for (var r = ui(this._connections.keys()), s = r.next(); !s.done; s = r.next()) {
          var a = s.value;
          this._cleanupPeer(a), this._connections.delete(a);
        }
      } catch (o) {
        e = {
          error: o
        };
      } finally {
        try {
          s && !s.done && (i = r.return) && i.call(r);
        } finally {
          if (e) throw e.error;
        }
      }
      this.socket.removeAllListeners();
    }, t.prototype._cleanupPeer = function(e) {
      var i, r, s = this._connections.get(e);
      if (s)
        try {
          for (var a = ui(s), o = a.next(); !o.done; o = a.next()) {
            var c = o.value;
            c.close();
          }
        } catch (l) {
          i = {
            error: l
          };
        } finally {
          try {
            o && !o.done && (r = a.return) && r.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
    }, t.prototype.disconnect = function() {
      if (!this.disconnected) {
        var e = this.id;
        O.default.log("Disconnect peer with ID:".concat(e)), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = e, this._id = null, this.emit("disconnected", e);
      }
    }, t.prototype.reconnect = function() {
      if (this.disconnected && !this.destroyed)
        O.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId)), this._disconnected = !1, this._initialize(this._lastServerId);
      else {
        if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed.");
        if (!this.disconnected && !this.open)
          O.default.error("In a hurry? We're still trying to make the initial connection!");
        else throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!"));
      }
    }, t.prototype.listAllPeers = function(e) {
      var i = this;
      e === void 0 && (e = function(r) {
      }), this._api.listAllPeers().then(function(r) {
        return e(r);
      }).catch(function(r) {
        return i._abort(Q.ServerError, r);
      });
    }, t.DEFAULT_KEY = "peerjs", t;
  })(lr.EventEmitter)
), Jc = ba.Peer;
const Iu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get Peer() {
    return Wn;
  },
  default: Jc,
  util: D
}, Symbol.toStringTag, { value: "Module" })), Gc = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function jc(n) {
  return typeof n == "string" && Gc.test(n);
}
const ht = [];
for (let n = 0; n < 256; ++n)
  ht.push((n + 256).toString(16).slice(1));
function $c(n, t = 0) {
  return ht[n[t + 0]] + ht[n[t + 1]] + ht[n[t + 2]] + ht[n[t + 3]] + "-" + ht[n[t + 4]] + ht[n[t + 5]] + "-" + ht[n[t + 6]] + ht[n[t + 7]] + "-" + ht[n[t + 8]] + ht[n[t + 9]] + "-" + ht[n[t + 10]] + ht[n[t + 11]] + ht[n[t + 12]] + ht[n[t + 13]] + ht[n[t + 14]] + ht[n[t + 15]];
}
function qc(n) {
  if (!jc(n))
    throw TypeError("Invalid UUID");
  let t;
  const e = new Uint8Array(16);
  return e[0] = (t = parseInt(n.slice(0, 8), 16)) >>> 24, e[1] = t >>> 16 & 255, e[2] = t >>> 8 & 255, e[3] = t & 255, e[4] = (t = parseInt(n.slice(9, 13), 16)) >>> 8, e[5] = t & 255, e[6] = (t = parseInt(n.slice(14, 18), 16)) >>> 8, e[7] = t & 255, e[8] = (t = parseInt(n.slice(19, 23), 16)) >>> 8, e[9] = t & 255, e[10] = (t = parseInt(n.slice(24, 36), 16)) / 1099511627776 & 255, e[11] = t / 4294967296 & 255, e[12] = t >>> 24 & 255, e[13] = t >>> 16 & 255, e[14] = t >>> 8 & 255, e[15] = t & 255, e;
}
function Xc(n) {
  n = unescape(encodeURIComponent(n));
  const t = [];
  for (let e = 0; e < n.length; ++e)
    t.push(n.charCodeAt(e));
  return t;
}
const Hc = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", Wc = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function Yc(n, t, e) {
  function i(r, s, a, o) {
    var c;
    if (typeof r == "string" && (r = Xc(r)), typeof s == "string" && (s = qc(s)), ((c = s) === null || c === void 0 ? void 0 : c.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let l = new Uint8Array(16 + r.length);
    if (l.set(s), l.set(r, s.length), l = e(l), l[6] = l[6] & 15 | t, l[8] = l[8] & 63 | 128, a) {
      o = o || 0;
      for (let h = 0; h < 16; ++h)
        a[o + h] = l[h];
      return a;
    }
    return $c(l);
  }
  try {
    i.name = n;
  } catch {
  }
  return i.DNS = Hc, i.URL = Wc, i;
}
function Zc(n, t, e, i) {
  switch (n) {
    case 0:
      return t & e ^ ~t & i;
    case 1:
      return t ^ e ^ i;
    case 2:
      return t & e ^ t & i ^ e & i;
    case 3:
      return t ^ e ^ i;
  }
}
function fn(n, t) {
  return n << t | n >>> 32 - t;
}
function Kc(n) {
  const t = [1518500249, 1859775393, 2400959708, 3395469782], e = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof n == "string") {
    const a = unescape(encodeURIComponent(n));
    n = [];
    for (let o = 0; o < a.length; ++o)
      n.push(a.charCodeAt(o));
  } else Array.isArray(n) || (n = Array.prototype.slice.call(n));
  n.push(128);
  const i = n.length / 4 + 2, r = Math.ceil(i / 16), s = new Array(r);
  for (let a = 0; a < r; ++a) {
    const o = new Uint32Array(16);
    for (let c = 0; c < 16; ++c)
      o[c] = n[a * 64 + c * 4] << 24 | n[a * 64 + c * 4 + 1] << 16 | n[a * 64 + c * 4 + 2] << 8 | n[a * 64 + c * 4 + 3];
    s[a] = o;
  }
  s[r - 1][14] = (n.length - 1) * 8 / Math.pow(2, 32), s[r - 1][14] = Math.floor(s[r - 1][14]), s[r - 1][15] = (n.length - 1) * 8 & 4294967295;
  for (let a = 0; a < r; ++a) {
    const o = new Uint32Array(80);
    for (let d = 0; d < 16; ++d)
      o[d] = s[a][d];
    for (let d = 16; d < 80; ++d)
      o[d] = fn(o[d - 3] ^ o[d - 8] ^ o[d - 14] ^ o[d - 16], 1);
    let c = e[0], l = e[1], h = e[2], u = e[3], f = e[4];
    for (let d = 0; d < 80; ++d) {
      const y = Math.floor(d / 20), _ = fn(c, 5) + Zc(y, l, h, u) + f + t[y] + o[d] >>> 0;
      f = u, u = h, h = fn(l, 30) >>> 0, l = c, c = _;
    }
    e[0] = e[0] + c >>> 0, e[1] = e[1] + l >>> 0, e[2] = e[2] + h >>> 0, e[3] = e[3] + u >>> 0, e[4] = e[4] + f >>> 0;
  }
  return [e[0] >> 24 & 255, e[0] >> 16 & 255, e[0] >> 8 & 255, e[0] & 255, e[1] >> 24 & 255, e[1] >> 16 & 255, e[1] >> 8 & 255, e[1] & 255, e[2] >> 24 & 255, e[2] >> 16 & 255, e[2] >> 8 & 255, e[2] & 255, e[3] >> 24 & 255, e[3] >> 16 & 255, e[3] >> 8 & 255, e[3] & 255, e[4] >> 24 & 255, e[4] >> 16 & 255, e[4] >> 8 & 255, e[4] & 255];
}
const Nu = Yc("v5", 80, Kc);
var dn = { exports: {} }, pn = { exports: {} }, Qs;
function Qc() {
  return Qs || (Qs = 1, (function() {
    var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = {
      // Bit-wise rotation left
      rotl: function(e, i) {
        return e << i | e >>> 32 - i;
      },
      // Bit-wise rotation right
      rotr: function(e, i) {
        return e << 32 - i | e >>> i;
      },
      // Swap big-endian to little-endian and vice versa
      endian: function(e) {
        if (e.constructor == Number)
          return t.rotl(e, 8) & 16711935 | t.rotl(e, 24) & 4278255360;
        for (var i = 0; i < e.length; i++)
          e[i] = t.endian(e[i]);
        return e;
      },
      // Generate an array of any length of random bytes
      randomBytes: function(e) {
        for (var i = []; e > 0; e--)
          i.push(Math.floor(Math.random() * 256));
        return i;
      },
      // Convert a byte array to big-endian 32-bit words
      bytesToWords: function(e) {
        for (var i = [], r = 0, s = 0; r < e.length; r++, s += 8)
          i[s >>> 5] |= e[r] << 24 - s % 32;
        return i;
      },
      // Convert big-endian 32-bit words to a byte array
      wordsToBytes: function(e) {
        for (var i = [], r = 0; r < e.length * 32; r += 8)
          i.push(e[r >>> 5] >>> 24 - r % 32 & 255);
        return i;
      },
      // Convert a byte array to a hex string
      bytesToHex: function(e) {
        for (var i = [], r = 0; r < e.length; r++)
          i.push((e[r] >>> 4).toString(16)), i.push((e[r] & 15).toString(16));
        return i.join("");
      },
      // Convert a hex string to a byte array
      hexToBytes: function(e) {
        for (var i = [], r = 0; r < e.length; r += 2)
          i.push(parseInt(e.substr(r, 2), 16));
        return i;
      },
      // Convert a byte array to a base-64 string
      bytesToBase64: function(e) {
        for (var i = [], r = 0; r < e.length; r += 3)
          for (var s = e[r] << 16 | e[r + 1] << 8 | e[r + 2], a = 0; a < 4; a++)
            r * 8 + a * 6 <= e.length * 8 ? i.push(n.charAt(s >>> 6 * (3 - a) & 63)) : i.push("=");
        return i.join("");
      },
      // Convert a base-64 string to a byte array
      base64ToBytes: function(e) {
        e = e.replace(/[^A-Z0-9+\/]/ig, "");
        for (var i = [], r = 0, s = 0; r < e.length; s = ++r % 4)
          s != 0 && i.push((n.indexOf(e.charAt(r - 1)) & Math.pow(2, -2 * s + 8) - 1) << s * 2 | n.indexOf(e.charAt(r)) >>> 6 - s * 2);
        return i;
      }
    };
    pn.exports = t;
  })()), pn.exports;
}
var mn, to;
function eo() {
  if (to) return mn;
  to = 1;
  var n = {
    // UTF-8 encoding
    utf8: {
      // Convert a string to a byte array
      stringToBytes: function(t) {
        return n.bin.stringToBytes(unescape(encodeURIComponent(t)));
      },
      // Convert a byte array to a string
      bytesToString: function(t) {
        return decodeURIComponent(escape(n.bin.bytesToString(t)));
      }
    },
    // Binary encoding
    bin: {
      // Convert a string to a byte array
      stringToBytes: function(t) {
        for (var e = [], i = 0; i < t.length; i++)
          e.push(t.charCodeAt(i) & 255);
        return e;
      },
      // Convert a byte array to a string
      bytesToString: function(t) {
        for (var e = [], i = 0; i < t.length; i++)
          e.push(String.fromCharCode(t[i]));
        return e.join("");
      }
    }
  };
  return mn = n, mn;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var yn, io;
function tl() {
  if (io) return yn;
  io = 1, yn = function(e) {
    return e != null && (n(e) || t(e) || !!e._isBuffer);
  };
  function n(e) {
    return !!e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
  }
  function t(e) {
    return typeof e.readFloatLE == "function" && typeof e.slice == "function" && n(e.slice(0, 0));
  }
  return yn;
}
var ro;
function el() {
  return ro || (ro = 1, (function() {
    var n = Qc(), t = eo().utf8, e = tl(), i = eo().bin, r = function(s, a) {
      s.constructor == String ? a && a.encoding === "binary" ? s = i.stringToBytes(s) : s = t.stringToBytes(s) : e(s) ? s = Array.prototype.slice.call(s, 0) : !Array.isArray(s) && s.constructor !== Uint8Array && (s = s.toString());
      for (var o = n.bytesToWords(s), c = s.length * 8, l = 1732584193, h = -271733879, u = -1732584194, f = 271733878, d = 0; d < o.length; d++)
        o[d] = (o[d] << 8 | o[d] >>> 24) & 16711935 | (o[d] << 24 | o[d] >>> 8) & 4278255360;
      o[c >>> 5] |= 128 << c % 32, o[(c + 64 >>> 9 << 4) + 14] = c;
      for (var y = r._ff, _ = r._gg, p = r._hh, m = r._ii, d = 0; d < o.length; d += 16) {
        var v = l, g = h, b = u, x = f;
        l = y(l, h, u, f, o[d + 0], 7, -680876936), f = y(f, l, h, u, o[d + 1], 12, -389564586), u = y(u, f, l, h, o[d + 2], 17, 606105819), h = y(h, u, f, l, o[d + 3], 22, -1044525330), l = y(l, h, u, f, o[d + 4], 7, -176418897), f = y(f, l, h, u, o[d + 5], 12, 1200080426), u = y(u, f, l, h, o[d + 6], 17, -1473231341), h = y(h, u, f, l, o[d + 7], 22, -45705983), l = y(l, h, u, f, o[d + 8], 7, 1770035416), f = y(f, l, h, u, o[d + 9], 12, -1958414417), u = y(u, f, l, h, o[d + 10], 17, -42063), h = y(h, u, f, l, o[d + 11], 22, -1990404162), l = y(l, h, u, f, o[d + 12], 7, 1804603682), f = y(f, l, h, u, o[d + 13], 12, -40341101), u = y(u, f, l, h, o[d + 14], 17, -1502002290), h = y(h, u, f, l, o[d + 15], 22, 1236535329), l = _(l, h, u, f, o[d + 1], 5, -165796510), f = _(f, l, h, u, o[d + 6], 9, -1069501632), u = _(u, f, l, h, o[d + 11], 14, 643717713), h = _(h, u, f, l, o[d + 0], 20, -373897302), l = _(l, h, u, f, o[d + 5], 5, -701558691), f = _(f, l, h, u, o[d + 10], 9, 38016083), u = _(u, f, l, h, o[d + 15], 14, -660478335), h = _(h, u, f, l, o[d + 4], 20, -405537848), l = _(l, h, u, f, o[d + 9], 5, 568446438), f = _(f, l, h, u, o[d + 14], 9, -1019803690), u = _(u, f, l, h, o[d + 3], 14, -187363961), h = _(h, u, f, l, o[d + 8], 20, 1163531501), l = _(l, h, u, f, o[d + 13], 5, -1444681467), f = _(f, l, h, u, o[d + 2], 9, -51403784), u = _(u, f, l, h, o[d + 7], 14, 1735328473), h = _(h, u, f, l, o[d + 12], 20, -1926607734), l = p(l, h, u, f, o[d + 5], 4, -378558), f = p(f, l, h, u, o[d + 8], 11, -2022574463), u = p(u, f, l, h, o[d + 11], 16, 1839030562), h = p(h, u, f, l, o[d + 14], 23, -35309556), l = p(l, h, u, f, o[d + 1], 4, -1530992060), f = p(f, l, h, u, o[d + 4], 11, 1272893353), u = p(u, f, l, h, o[d + 7], 16, -155497632), h = p(h, u, f, l, o[d + 10], 23, -1094730640), l = p(l, h, u, f, o[d + 13], 4, 681279174), f = p(f, l, h, u, o[d + 0], 11, -358537222), u = p(u, f, l, h, o[d + 3], 16, -722521979), h = p(h, u, f, l, o[d + 6], 23, 76029189), l = p(l, h, u, f, o[d + 9], 4, -640364487), f = p(f, l, h, u, o[d + 12], 11, -421815835), u = p(u, f, l, h, o[d + 15], 16, 530742520), h = p(h, u, f, l, o[d + 2], 23, -995338651), l = m(l, h, u, f, o[d + 0], 6, -198630844), f = m(f, l, h, u, o[d + 7], 10, 1126891415), u = m(u, f, l, h, o[d + 14], 15, -1416354905), h = m(h, u, f, l, o[d + 5], 21, -57434055), l = m(l, h, u, f, o[d + 12], 6, 1700485571), f = m(f, l, h, u, o[d + 3], 10, -1894986606), u = m(u, f, l, h, o[d + 10], 15, -1051523), h = m(h, u, f, l, o[d + 1], 21, -2054922799), l = m(l, h, u, f, o[d + 8], 6, 1873313359), f = m(f, l, h, u, o[d + 15], 10, -30611744), u = m(u, f, l, h, o[d + 6], 15, -1560198380), h = m(h, u, f, l, o[d + 13], 21, 1309151649), l = m(l, h, u, f, o[d + 4], 6, -145523070), f = m(f, l, h, u, o[d + 11], 10, -1120210379), u = m(u, f, l, h, o[d + 2], 15, 718787259), h = m(h, u, f, l, o[d + 9], 21, -343485551), l = l + v >>> 0, h = h + g >>> 0, u = u + b >>> 0, f = f + x >>> 0;
      }
      return n.endian([l, h, u, f]);
    };
    r._ff = function(s, a, o, c, l, h, u) {
      var f = s + (a & o | ~a & c) + (l >>> 0) + u;
      return (f << h | f >>> 32 - h) + a;
    }, r._gg = function(s, a, o, c, l, h, u) {
      var f = s + (a & c | o & ~c) + (l >>> 0) + u;
      return (f << h | f >>> 32 - h) + a;
    }, r._hh = function(s, a, o, c, l, h, u) {
      var f = s + (a ^ o ^ c) + (l >>> 0) + u;
      return (f << h | f >>> 32 - h) + a;
    }, r._ii = function(s, a, o, c, l, h, u) {
      var f = s + (o ^ (a | ~c)) + (l >>> 0) + u;
      return (f << h | f >>> 32 - h) + a;
    }, r._blocksize = 16, r._digestsize = 16, dn.exports = function(s, a) {
      if (s == null)
        throw new Error("Illegal argument " + s);
      var o = n.wordsToBytes(r(s, a));
      return a && a.asBytes ? o : a && a.asString ? i.bytesToString(o) : n.bytesToHex(o);
    };
  })()), dn.exports;
}
var il = el();
const Uu = /* @__PURE__ */ Kr(il), ft = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let no = 1234567;
const Pa = Math.PI / 180, wa = 180 / Math.PI;
function rl() {
  const n = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (ft[n & 255] + ft[n >> 8 & 255] + ft[n >> 16 & 255] + ft[n >> 24 & 255] + "-" + ft[t & 255] + ft[t >> 8 & 255] + "-" + ft[t >> 16 & 15 | 64] + ft[t >> 24 & 255] + "-" + ft[e & 63 | 128] + ft[e >> 8 & 255] + "-" + ft[e >> 16 & 255] + ft[e >> 24 & 255] + ft[i & 255] + ft[i >> 8 & 255] + ft[i >> 16 & 255] + ft[i >> 24 & 255]).toLowerCase();
}
function Yt(n, t, e) {
  return Math.max(t, Math.min(e, n));
}
function Ea(n, t) {
  return (n % t + t) % t;
}
function nl(n, t, e, i, r) {
  return i + (n - t) * (r - i) / (e - t);
}
function sl(n, t, e) {
  return n !== t ? (e - n) / (t - n) : 0;
}
function ka(n, t, e) {
  return (1 - e) * n + e * t;
}
function ol(n, t, e, i) {
  return ka(n, t, 1 - Math.exp(-e * i));
}
function al(n, t = 1) {
  return t - Math.abs(Ea(n, t * 2) - t);
}
function cl(n, t, e) {
  return n <= t ? 0 : n >= e ? 1 : (n = (n - t) / (e - t), n * n * (3 - 2 * n));
}
function ll(n, t, e) {
  return n <= t ? 0 : n >= e ? 1 : (n = (n - t) / (e - t), n * n * n * (n * (n * 6 - 15) + 10));
}
function hl(n, t) {
  return n + Math.floor(Math.random() * (t - n + 1));
}
function ul(n, t) {
  return n + Math.random() * (t - n);
}
function fl(n) {
  return n * (0.5 - Math.random());
}
function dl(n) {
  n !== void 0 && (no = n);
  let t = no += 1831565813;
  return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function pl(n) {
  return n * Pa;
}
function ml(n) {
  return n * wa;
}
function yl(n) {
  return (n & n - 1) === 0 && n !== 0;
}
function gl(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function vl(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function _l(n, t, e, i, r) {
  const s = Math.cos, a = Math.sin, o = s(e / 2), c = a(e / 2), l = s((t + i) / 2), h = a((t + i) / 2), u = s((t - i) / 2), f = a((t - i) / 2), d = s((i - t) / 2), y = a((i - t) / 2);
  switch (r) {
    case "XYX":
      n.set(o * h, c * u, c * f, o * l);
      break;
    case "YZY":
      n.set(c * f, o * h, c * u, o * l);
      break;
    case "ZXZ":
      n.set(c * u, c * f, o * h, o * l);
      break;
    case "XZX":
      n.set(o * h, c * y, c * d, o * l);
      break;
    case "YXY":
      n.set(c * d, o * h, c * y, o * l);
      break;
    case "ZYZ":
      n.set(c * y, c * d, o * h, o * l);
      break;
    default:
      console.warn("../math.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function xl(n, t) {
  switch (t.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function bl(n, t) {
  switch (t.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const ni = {
  DEG2RAD: Pa,
  RAD2DEG: wa,
  generateUUID: rl,
  clamp: Yt,
  euclideanModulo: Ea,
  mapLinear: nl,
  inverseLerp: sl,
  lerp: ka,
  damp: ol,
  pingpong: al,
  smoothstep: cl,
  smootherstep: ll,
  randInt: hl,
  randFloat: ul,
  randFloatSpread: fl,
  seededRandom: dl,
  degToRad: pl,
  radToDeg: ml,
  isPowerOfTwo: yl,
  ceilPowerOfTwo: gl,
  floorPowerOfTwo: vl,
  setQuaternionFromProperEuler: _l,
  normalize: bl,
  denormalize: xl
};
class G {
  constructor(t = 0, e = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = i, this._w = r;
  }
  static slerpFlat(t, e, i, r, s, a, o) {
    let c = i[r + 0], l = i[r + 1], h = i[r + 2], u = i[r + 3];
    const f = s[a + 0], d = s[a + 1], y = s[a + 2], _ = s[a + 3];
    if (o === 0) {
      t[e + 0] = c, t[e + 1] = l, t[e + 2] = h, t[e + 3] = u;
      return;
    }
    if (o === 1) {
      t[e + 0] = f, t[e + 1] = d, t[e + 2] = y, t[e + 3] = _;
      return;
    }
    if (u !== _ || c !== f || l !== d || h !== y) {
      let p = 1 - o;
      const m = c * f + l * d + h * y + u * _, v = m >= 0 ? 1 : -1, g = 1 - m * m;
      if (g > Number.EPSILON) {
        const x = Math.sqrt(g), S = Math.atan2(x, m * v);
        p = Math.sin(p * S) / x, o = Math.sin(o * S) / x;
      }
      const b = o * v;
      if (c = c * p + f * b, l = l * p + d * b, h = h * p + y * b, u = u * p + _ * b, p === 1 - o) {
        const x = 1 / Math.sqrt(c * c + l * l + h * h + u * u);
        c *= x, l *= x, h *= x, u *= x;
      }
    }
    t[e] = c, t[e + 1] = l, t[e + 2] = h, t[e + 3] = u;
  }
  static multiplyQuaternionsFlat(t, e, i, r, s, a) {
    const o = i[r], c = i[r + 1], l = i[r + 2], h = i[r + 3], u = s[a], f = s[a + 1], d = s[a + 2], y = s[a + 3];
    return t[e] = o * y + h * u + c * d - l * f, t[e + 1] = c * y + h * f + l * u - o * d, t[e + 2] = l * y + h * d + o * f - c * u, t[e + 3] = h * y - o * u - c * f - l * d, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, i, r) {
    return this._x = t, this._y = e, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new G(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e = !0) {
    const i = t._x, r = t._y, s = t._z, a = t._order, o = Math.cos, c = Math.sin, l = o(i / 2), h = o(r / 2), u = o(s / 2), f = c(i / 2), d = c(r / 2), y = c(s / 2);
    switch (a) {
      case "XYZ":
        this._x = f * h * u + l * d * y, this._y = l * d * u - f * h * y, this._z = l * h * y + f * d * u, this._w = l * h * u - f * d * y;
        break;
      case "YXZ":
        this._x = f * h * u + l * d * y, this._y = l * d * u - f * h * y, this._z = l * h * y - f * d * u, this._w = l * h * u + f * d * y;
        break;
      case "ZXY":
        this._x = f * h * u - l * d * y, this._y = l * d * u + f * h * y, this._z = l * h * y + f * d * u, this._w = l * h * u - f * d * y;
        break;
      case "ZYX":
        this._x = f * h * u - l * d * y, this._y = l * d * u + f * h * y, this._z = l * h * y - f * d * u, this._w = l * h * u + f * d * y;
        break;
      case "YZX":
        this._x = f * h * u + l * d * y, this._y = l * d * u + f * h * y, this._z = l * h * y - f * d * u, this._w = l * h * u - f * d * y;
        break;
      case "XZY":
        this._x = f * h * u - l * d * y, this._y = l * d * u - f * h * y, this._z = l * h * y + f * d * u, this._w = l * h * u + f * d * y;
        break;
      default:
        console.warn("../math.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const i = e / 2, r = Math.sin(i);
    return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const e = t.elements, i = e[0], r = e[4], s = e[8], a = e[1], o = e[5], c = e[9], l = e[2], h = e[6], u = e[10], f = i + o + u;
    if (f > 0) {
      const d = 0.5 / Math.sqrt(f + 1);
      this._w = 0.25 / d, this._x = (h - c) * d, this._y = (s - l) * d, this._z = (a - r) * d;
    } else if (i > o && i > u) {
      const d = 2 * Math.sqrt(1 + i - o - u);
      this._w = (h - c) / d, this._x = 0.25 * d, this._y = (r + a) / d, this._z = (s + l) / d;
    } else if (o > u) {
      const d = 2 * Math.sqrt(1 + o - i - u);
      this._w = (s - l) / d, this._x = (r + a) / d, this._y = 0.25 * d, this._z = (c + h) / d;
    } else {
      const d = 2 * Math.sqrt(1 + u - i - o);
      this._w = (a - r) / d, this._x = (s + l) / d, this._y = (c + h) / d, this._z = 0.25 * d;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let i = t.dot(e) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(Yt(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const i = this.angleTo(t);
    if (i === 0)
      return this;
    const r = Math.min(1, e / i);
    return this.slerp(t, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const i = t._x, r = t._y, s = t._z, a = t._w, o = e._x, c = e._y, l = e._z, h = e._w;
    return this._x = i * h + a * o + r * l - s * c, this._y = r * h + a * c + s * o - i * l, this._z = s * h + a * l + i * c - r * o, this._w = a * h - i * o - r * c - s * l, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(t);
    const i = this._x, r = this._y, s = this._z, a = this._w;
    let o = a * t._w + i * t._x + r * t._y + s * t._z;
    if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1)
      return this._w = a, this._x = i, this._y = r, this._z = s, this;
    const c = 1 - o * o;
    if (c <= Number.EPSILON) {
      const d = 1 - e;
      return this._w = d * a + e * this._w, this._x = d * i + e * this._x, this._y = d * r + e * this._y, this._z = d * s + e * this._z, this.normalize(), this;
    }
    const l = Math.sqrt(c), h = Math.atan2(l, o), u = Math.sin((1 - e) * h) / l, f = Math.sin(e * h) / l;
    return this._w = a * u + this._w * f, this._x = i * u + this._x * f, this._y = r * u + this._y * f, this._z = s * u + this._z * f, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, i) {
    return this.copy(t).slerp(e, i);
  }
  random() {
    const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), i = Math.random(), r = Math.sqrt(1 - i), s = Math.sqrt(i);
    return this.set(r * Math.sin(t), r * Math.cos(t), s * Math.sin(e), s * Math.cos(e));
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class B {
  constructor(t = 0, e = 0, i = 0) {
    this.isVector3 = !0, B.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = i;
  }
  set(t, e, i) {
    return i === void 0 && (i = this.z), this.x = t, this.y = e, this.z = i, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new B(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(so.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(so.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x, i = this.y, r = this.z, s = t.elements;
    return this.x = s[0] * e + s[3] * i + s[6] * r, this.y = s[1] * e + s[4] * i + s[7] * r, this.z = s[2] * e + s[5] * i + s[8] * r, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x, i = this.y, r = this.z, s = t.elements, a = 1 / (s[3] * e + s[7] * i + s[11] * r + s[15]);
    return this.x = (s[0] * e + s[4] * i + s[8] * r + s[12]) * a, this.y = (s[1] * e + s[5] * i + s[9] * r + s[13]) * a, this.z = (s[2] * e + s[6] * i + s[10] * r + s[14]) * a, this;
  }
  applyQuaternion(t) {
    const e = this.x, i = this.y, r = this.z, s = t.x, a = t.y, o = t.z, c = t.w, l = 2 * (a * r - o * i), h = 2 * (o * e - s * r), u = 2 * (s * i - a * e);
    return this.x = e + c * l + a * u - o * h, this.y = i + c * h + o * l - s * u, this.z = r + c * u + s * h - a * l, this;
  }
  transformDirection(t) {
    const e = this.x, i = this.y, r = this.z, s = t.elements;
    return this.x = s[0] * e + s[4] * i + s[8] * r, this.y = s[1] * e + s[5] * i + s[9] * r, this.z = s[2] * e + s[6] * i + s[10] * r, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const i = t.x, r = t.y, s = t.z, a = e.x, o = e.y, c = e.z;
    return this.x = r * c - s * o, this.y = s * a - i * c, this.z = i * o - r * a, this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const i = t.dot(this) / e;
    return this.copy(t).multiplyScalar(i);
  }
  projectOnPlane(t) {
    return gn.copy(this).projectOnVector(t), this.sub(gn);
  }
  reflect(t) {
    return this.sub(gn.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(Yt(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, i = this.y - t.y, r = this.z - t.z;
    return e * e + i * i + r * r;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSphericalCoords(t, e, i) {
    const r = Math.sin(e) * t;
    return this.x = r * Math.sin(i), this.y = Math.cos(e) * t, this.z = r * Math.cos(i), this;
  }
  setFromCylindricalCoords(t, e, i) {
    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), r = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, i = Math.sqrt(1 - e * e);
    return this.x = i * Math.cos(t), this.y = e, this.z = i * Math.sin(t), this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this.z = Math.abs(this.z), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const gn = new B(), so = new G(), pr = 2e3, oo = 2001;
class Qt {
  constructor(t, e, i, r, s, a, o, c, l, h, u, f, d, y, _, p) {
    this.isMatrix4 = !0, Qt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], t !== void 0 && this.set(t, e, i, r, s, a, o, c, l, h, u, f, d, y, _, p);
  }
  extractPosition(t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
  }
  multiplyToArray(t, e, i) {
    return console.error("THREE.Matrix4: .multiplyToArray() has been removed."), this;
  }
  setRotationFromQuaternion(t) {
    return this.makeRotationFromQuaternion(t);
  }
  set(t, e, i, r, s, a, o, c, l, h, u, f, d, y, _, p) {
    const m = this.elements;
    return m[0] = t, m[4] = e, m[8] = i, m[12] = r, m[1] = s, m[5] = a, m[9] = o, m[13] = c, m[2] = l, m[6] = h, m[10] = u, m[14] = f, m[3] = d, m[7] = y, m[11] = _, m[15] = p, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Qt().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements, i = t.elements;
    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this;
  }
  copyPosition(t) {
    const e = this.elements, i = t.elements;
    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(t, e, i) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, e, i) {
    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(t) {
    const e = this.elements, i = t.elements, r = 1 / Je.setFromMatrixColumn(t, 0).length(), s = 1 / Je.setFromMatrixColumn(t, 1).length(), a = 1 / Je.setFromMatrixColumn(t, 2).length();
    return e[0] = i[0] * r, e[1] = i[1] * r, e[2] = i[2] * r, e[3] = 0, e[4] = i[4] * s, e[5] = i[5] * s, e[6] = i[6] * s, e[7] = 0, e[8] = i[8] * a, e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    const e = this.elements, i = t.x, r = t.y, s = t.z, a = Math.cos(i), o = Math.sin(i), c = Math.cos(r), l = Math.sin(r), h = Math.cos(s), u = Math.sin(s);
    if (t.order === "XYZ") {
      const f = a * h, d = a * u, y = o * h, _ = o * u;
      e[0] = c * h, e[4] = -c * u, e[8] = l, e[1] = d + y * l, e[5] = f - _ * l, e[9] = -o * c, e[2] = _ - f * l, e[6] = y + d * l, e[10] = a * c;
    } else if (t.order === "YXZ") {
      const f = c * h, d = c * u, y = l * h, _ = l * u;
      e[0] = f + _ * o, e[4] = y * o - d, e[8] = a * l, e[1] = a * u, e[5] = a * h, e[9] = -o, e[2] = d * o - y, e[6] = _ + f * o, e[10] = a * c;
    } else if (t.order === "ZXY") {
      const f = c * h, d = c * u, y = l * h, _ = l * u;
      e[0] = f - _ * o, e[4] = -a * u, e[8] = y + d * o, e[1] = d + y * o, e[5] = a * h, e[9] = _ - f * o, e[2] = -a * l, e[6] = o, e[10] = a * c;
    } else if (t.order === "ZYX") {
      const f = a * h, d = a * u, y = o * h, _ = o * u;
      e[0] = c * h, e[4] = y * l - d, e[8] = f * l + _, e[1] = c * u, e[5] = _ * l + f, e[9] = d * l - y, e[2] = -l, e[6] = o * c, e[10] = a * c;
    } else if (t.order === "YZX") {
      const f = a * c, d = a * l, y = o * c, _ = o * l;
      e[0] = c * h, e[4] = _ - f * u, e[8] = y * u + d, e[1] = u, e[5] = a * h, e[9] = -o * h, e[2] = -l * h, e[6] = d * u + y, e[10] = f - _ * u;
    } else if (t.order === "XZY") {
      const f = a * c, d = a * l, y = o * c, _ = o * l;
      e[0] = c * h, e[4] = -u, e[8] = l * h, e[1] = f * u + _, e[5] = a * h, e[9] = d * u - y, e[2] = y * u - d, e[6] = o * h, e[10] = _ * u + f;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(Sl, t, Tl);
  }
  lookAt(t, e, i) {
    const r = this.elements;
    return Ct.subVectors(t, e), Ct.lengthSq() === 0 && (Ct.z = 1), Ct.normalize(), ve.crossVectors(i, Ct), ve.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Ct.x += 1e-4 : Ct.z += 1e-4, Ct.normalize(), ve.crossVectors(i, Ct)), ve.normalize(), mr.crossVectors(Ct, ve), r[0] = ve.x, r[4] = mr.x, r[8] = Ct.x, r[1] = ve.y, r[5] = mr.y, r[9] = Ct.y, r[2] = ve.z, r[6] = mr.z, r[10] = Ct.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const i = t.elements, r = e.elements, s = this.elements, a = i[0], o = i[4], c = i[8], l = i[12], h = i[1], u = i[5], f = i[9], d = i[13], y = i[2], _ = i[6], p = i[10], m = i[14], v = i[3], g = i[7], b = i[11], x = i[15], S = r[0], T = r[4], P = r[8], M = r[12], C = r[1], E = r[5], w = r[9], k = r[13], R = r[2], z = r[6], U = r[10], L = r[14], I = r[3], H = r[7], K = r[11], rt = r[15];
    return s[0] = a * S + o * C + c * R + l * I, s[4] = a * T + o * E + c * z + l * H, s[8] = a * P + o * w + c * U + l * K, s[12] = a * M + o * k + c * L + l * rt, s[1] = h * S + u * C + f * R + d * I, s[5] = h * T + u * E + f * z + d * H, s[9] = h * P + u * w + f * U + d * K, s[13] = h * M + u * k + f * L + d * rt, s[2] = y * S + _ * C + p * R + m * I, s[6] = y * T + _ * E + p * z + m * H, s[10] = y * P + _ * w + p * U + m * K, s[14] = y * M + _ * k + p * L + m * rt, s[3] = v * S + g * C + b * R + x * I, s[7] = v * T + g * E + b * z + x * H, s[11] = v * P + g * w + b * U + x * K, s[15] = v * M + g * k + b * L + x * rt, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], i = t[4], r = t[8], s = t[12], a = t[1], o = t[5], c = t[9], l = t[13], h = t[2], u = t[6], f = t[10], d = t[14], y = t[3], _ = t[7], p = t[11], m = t[15];
    return y * (+s * c * u - r * l * u - s * o * f + i * l * f + r * o * d - i * c * d) + _ * (+e * c * d - e * l * f + s * a * f - r * a * d + r * l * h - s * c * h) + p * (+e * l * u - e * o * d - s * a * u + i * a * d + s * o * h - i * l * h) + m * (-r * o * h - e * c * u + e * o * f + r * a * u - i * a * f + i * c * h);
  }
  transpose() {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  setPosition(t, e, i) {
    const r = this.elements;
    return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = i), this;
  }
  invert() {
    const t = this.elements, e = t[0], i = t[1], r = t[2], s = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8], u = t[9], f = t[10], d = t[11], y = t[12], _ = t[13], p = t[14], m = t[15], v = u * p * l - _ * f * l + _ * c * d - o * p * d - u * c * m + o * f * m, g = y * f * l - h * p * l - y * c * d + a * p * d + h * c * m - a * f * m, b = h * _ * l - y * u * l + y * o * d - a * _ * d - h * o * m + a * u * m, x = y * u * c - h * _ * c - y * o * f + a * _ * f + h * o * p - a * u * p, S = e * v + i * g + r * b + s * x;
    if (S === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / S;
    return t[0] = v * T, t[1] = (_ * f * s - u * p * s - _ * r * d + i * p * d + u * r * m - i * f * m) * T, t[2] = (o * p * s - _ * c * s + _ * r * l - i * p * l - o * r * m + i * c * m) * T, t[3] = (u * c * s - o * f * s - u * r * l + i * f * l + o * r * d - i * c * d) * T, t[4] = g * T, t[5] = (h * p * s - y * f * s + y * r * d - e * p * d - h * r * m + e * f * m) * T, t[6] = (y * c * s - a * p * s - y * r * l + e * p * l + a * r * m - e * c * m) * T, t[7] = (a * f * s - h * c * s + h * r * l - e * f * l - a * r * d + e * c * d) * T, t[8] = b * T, t[9] = (y * u * s - h * _ * s - y * i * d + e * _ * d + h * i * m - e * u * m) * T, t[10] = (a * _ * s - y * o * s + y * i * l - e * _ * l - a * i * m + e * o * m) * T, t[11] = (h * o * s - a * u * s - h * i * l + e * u * l + a * i * d - e * o * d) * T, t[12] = x * T, t[13] = (h * _ * r - y * u * r + y * i * f - e * _ * f - h * i * p + e * u * p) * T, t[14] = (y * o * r - a * _ * r - y * i * c + e * _ * c + a * i * p - e * o * p) * T, t[15] = (a * u * r - h * o * r + h * i * c - e * u * c - a * i * f + e * o * f) * T, this;
  }
  scale(t) {
    const e = this.elements, i = t.x, r = t.y, s = t.z;
    return e[0] *= i, e[4] *= r, e[8] *= s, e[1] *= i, e[5] *= r, e[9] *= s, e[2] *= i, e[6] *= r, e[10] *= s, e[3] *= i, e[7] *= r, e[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, i, r));
  }
  makeTranslation(t, e, i) {
    return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    const i = Math.cos(e), r = Math.sin(e), s = 1 - i, a = t.x, o = t.y, c = t.z, l = s * a, h = s * o;
    return this.set(l * a + i, l * o - r * c, l * c + r * o, 0, l * o + r * c, h * o + i, h * c - r * a, 0, l * c - r * o, h * c + r * a, s * c * c + i, 0, 0, 0, 0, 1), this;
  }
  makeScale(t, e, i) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, i, r, s, a) {
    return this.set(1, i, s, 0, t, 1, a, 0, e, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, i) {
    const r = this.elements, s = e._x, a = e._y, o = e._z, c = e._w, l = s + s, h = a + a, u = o + o, f = s * l, d = s * h, y = s * u, _ = a * h, p = a * u, m = o * u, v = c * l, g = c * h, b = c * u, x = i.x, S = i.y, T = i.z;
    return r[0] = (1 - (_ + m)) * x, r[1] = (d + b) * x, r[2] = (y - g) * x, r[3] = 0, r[4] = (d - b) * S, r[5] = (1 - (f + m)) * S, r[6] = (p + v) * S, r[7] = 0, r[8] = (y + g) * T, r[9] = (p - v) * T, r[10] = (1 - (f + _)) * T, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this;
  }
  decompose(t, e, i) {
    const r = this.elements;
    let s = Je.set(r[0], r[1], r[2]).length();
    const a = Je.set(r[4], r[5], r[6]).length(), o = Je.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), t.x = r[12], t.y = r[13], t.z = r[14], Dt.copy(this);
    const l = 1 / s, h = 1 / a, u = 1 / o;
    return Dt.elements[0] *= l, Dt.elements[1] *= l, Dt.elements[2] *= l, Dt.elements[4] *= h, Dt.elements[5] *= h, Dt.elements[6] *= h, Dt.elements[8] *= u, Dt.elements[9] *= u, Dt.elements[10] *= u, e.setFromRotationMatrix(Dt), i.x = s, i.y = a, i.z = o, this;
  }
  makePerspective(t, e, i, r, s, a, o = pr) {
    const c = this.elements, l = 2 * s / (e - t), h = 2 * s / (i - r), u = (e + t) / (e - t), f = (i + r) / (i - r);
    let d, y;
    if (o === pr)
      d = -(a + s) / (a - s), y = -2 * a * s / (a - s);
    else if (o === oo)
      d = -a / (a - s), y = -a * s / (a - s);
    else
      throw new Error("Matrix4.makePerspective(): Invalid coordinate system: " + o);
    return c[0] = l, c[4] = 0, c[8] = u, c[12] = 0, c[1] = 0, c[5] = h, c[9] = f, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = d, c[14] = y, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(t, e, i, r, s, a, o = pr) {
    const c = this.elements, l = 1 / (e - t), h = 1 / (i - r), u = 1 / (a - s), f = (e + t) * l, d = (i + r) * h;
    let y, _;
    if (o === pr)
      y = (a + s) * u, _ = -2 * u;
    else if (o === oo)
      y = s * u, _ = -1 * u;
    else
      throw new Error("../math.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
    return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -f, c[1] = 0, c[5] = 2 * h, c[9] = 0, c[13] = -d, c[2] = 0, c[6] = 0, c[10] = _, c[14] = -y, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(t) {
    const e = this.elements, i = t.elements;
    for (let r = 0; r < 16; r++)
      if (e[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = t[i + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const i = this.elements;
    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
  }
}
const Je = new B(), Dt = new Qt(), Sl = new B(0, 0, 0), Tl = new B(1, 1, 1), ve = new B(), mr = new B(), Ct = new B(), ao = new Qt(), co = new G();
class Ai {
  constructor(t = 0, e = 0, i = 0, r = Ai.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = t, this._y = e, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, e, i, r = this._order) {
    return this._x = t, this._y = e, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new Ai(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, e = this._order, i = !0) {
    const r = t.elements, s = r[0], a = r[4], o = r[8], c = r[1], l = r[5], h = r[9], u = r[2], f = r[6], d = r[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(Yt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(f, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Yt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Yt(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, s));
        break;
      case "ZYX":
        this._y = Math.asin(-Yt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(c, s)) : (this._x = 0, this._z = Math.atan2(-a, l));
        break;
      case "YZX":
        this._z = Math.asin(Yt(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, s)) : (this._x = 0, this._y = Math.atan2(o, d));
        break;
      case "XZY":
        this._z = Math.asin(-Yt(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(f, l), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-h, d), this._y = 0);
        break;
      default:
        console.warn("../math.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, i) {
    return ao.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ao, e, i);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return co.setFromEuler(this), this.setFromQuaternion(co, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback(t) {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Ai.DEFAULT_ORDER = "XYZ";
class Qe {
  constructor(t = 0, e = 0) {
    this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new Qe(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x, i = this.y, r = t.elements;
    return this.x = r[0] * e + r[3] * i + r[6], this.y = r[1] * e + r[4] * i + r[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(Yt(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, i = this.y - t.y;
    return e * e + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  rotateAround(t, e) {
    const i = Math.cos(e), r = Math.sin(e), s = this.x - t.x, a = this.y - t.y;
    return this.x = s * i - a * r + t.x, this.y = s * r + a * i + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
Qe.isVector2 = !0;
class wt {
  constructor(t = 0, e = 0, i = 0, r = 1) {
    wt.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, i, r) {
    return this.x = t, this.y = e, this.z = i, this.w = r, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new wt(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    const e = this.x, i = this.y, r = this.z, s = this.w, a = t.elements;
    return this.x = a[0] * e + a[4] * i + a[8] * r + a[12] * s, this.y = a[1] * e + a[5] * i + a[9] * r + a[13] * s, this.z = a[2] * e + a[6] * i + a[10] * r + a[14] * s, this.w = a[3] * e + a[7] * i + a[11] * r + a[15] * s, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, i, r, s;
    const c = t.elements, l = c[0], h = c[4], u = c[8], f = c[1], d = c[5], y = c[9], _ = c[2], p = c[6], m = c[10];
    if (Math.abs(h - f) < 0.01 && Math.abs(u - _) < 0.01 && Math.abs(y - p) < 0.01) {
      if (Math.abs(h + f) < 0.1 && Math.abs(u + _) < 0.1 && Math.abs(y + p) < 0.1 && Math.abs(l + d + m - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const g = (l + 1) / 2, b = (d + 1) / 2, x = (m + 1) / 2, S = (h + f) / 4, T = (u + _) / 4, P = (y + p) / 4;
      return g > b && g > x ? g < 0.01 ? (i = 0, r = 0.707106781, s = 0.707106781) : (i = Math.sqrt(g), r = S / i, s = T / i) : b > x ? b < 0.01 ? (i = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(b), i = S / r, s = P / r) : x < 0.01 ? (i = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(x), i = T / s, r = P / s), this.set(i, r, s, e), this;
    }
    let v = Math.sqrt((p - y) * (p - y) + (u - _) * (u - _) + (f - h) * (f - h));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (p - y) / v, this.y = (u - _) / v, this.z = (f - h) / v, this.w = Math.acos((l + d + m - 1) / 2), this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Kt {
  constructor(t, e, i, r, s, a, o, c, l) {
    Kt.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], t !== void 0 && this.set(t, e, i, r, s, a, o, c, l);
  }
  set(t, e, i, r, s, a, o, c, l) {
    const h = this.elements;
    return h[0] = t, h[1] = r, h[2] = o, h[3] = e, h[4] = s, h[5] = c, h[6] = i, h[7] = a, h[8] = l, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t) {
    const e = this.elements, i = t.elements;
    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this;
  }
  extractBasis(t, e, i) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const i = t.elements, r = e.elements, s = this.elements, a = i[0], o = i[3], c = i[6], l = i[1], h = i[4], u = i[7], f = i[2], d = i[5], y = i[8], _ = r[0], p = r[3], m = r[6], v = r[1], g = r[4], b = r[7], x = r[2], S = r[5], T = r[8];
    return s[0] = a * _ + o * v + c * x, s[3] = a * p + o * g + c * S, s[6] = a * m + o * b + c * T, s[1] = l * _ + h * v + u * x, s[4] = l * p + h * g + u * S, s[7] = l * m + h * b + u * T, s[2] = f * _ + d * v + y * x, s[5] = f * p + d * g + y * S, s[8] = f * m + d * b + y * T, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], i = t[1], r = t[2], s = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8];
    return e * a * h - e * o * l - i * s * h + i * o * c + r * s * l - r * a * c;
  }
  invert() {
    const t = this.elements, e = t[0], i = t[1], r = t[2], s = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8], u = h * a - o * l, f = o * c - h * s, d = l * s - a * c, y = e * u + i * f + r * d;
    if (y === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / y;
    return t[0] = u * _, t[1] = (r * l - h * i) * _, t[2] = (o * i - r * a) * _, t[3] = f * _, t[4] = (h * e - r * c) * _, t[5] = (r * s - o * e) * _, t[6] = d * _, t[7] = (i * c - l * e) * _, t[8] = (a * e - i * s) * _, this;
  }
  transpose() {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  }
  setUvTransform(t, e, i, r, s, a, o) {
    const c = Math.cos(s), l = Math.sin(s);
    return this.set(i * c, i * l, -i * (c * a + l * o) + a + t, -r * l, r * c, -r * (-l * a + c * o) + o + e, 0, 0, 1), this;
  }
  scale(t, e) {
    return this.premultiply(vn.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(vn.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(vn.makeTranslation(t, e)), this;
  }
  makeTranslation(t, e) {
    return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
  }
  makeRotation(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(e, -i, 0, i, e, 0, 0, 0, 1), this;
  }
  makeScale(t, e) {
    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
  }
  equals(t) {
    const e = this.elements, i = t.elements;
    for (let r = 0; r < 9; r++)
      if (e[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = t[i + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const i = this.elements;
    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
  }
  clone() {
    return new Kt().fromArray(this.elements);
  }
}
const vn = new Kt();
var vt;
(function(n) {
  n[n.Random = 0] = "Random", n[n.Loop = 1] = "Loop", n[n.PingPong = 2] = "PingPong", n[n.Burst = 3] = "Burst";
})(vt || (vt = {}));
function hr(n, t, e, i) {
  let r;
  switch (vt.Random === n ? t = Math.random() : vt.Burst === n && i.isBursting && (t = i.burstParticleIndex / i.burstParticleCount), e > 0 ? r = Math.floor(t / e) * e : r = t, n) {
    case vt.Loop:
      r = r % 1;
      break;
    case vt.PingPong:
      r = Math.abs(r % 2 - 1);
      break;
  }
  return r;
}
class Fe {
  constructor(t, e, i, r) {
    this.p = [t, e, i, r];
  }
  genValue(t) {
    const e = t * t, i = t * t * t, r = 1 - t, s = r * r, a = s * r;
    return this.p[0] * a + this.p[1] * s * t * 3 + this.p[2] * r * e * 3 + this.p[3] * i;
  }
  derivativeCoefficients(t) {
    const e = [];
    for (let i = t, r = i.length - 1; r > 0; r--) {
      const s = [];
      for (let a = 0; a < r; a++) {
        const o = r * (i[a + 1] - i[a]);
        s.push(o);
      }
      e.push(s), i = s;
    }
    return e;
  }
  getSlope(t) {
    const e = this.derivativeCoefficients(this.p)[0], i = 1 - t, r = i * i, s = i * t * 2, a = t * t;
    return r * e[0] + s * e[1] + a * e[2];
  }
  controlCurve(t, e) {
    this.p[1] = t / 3 + this.p[0], this.p[2] = this.p[3] - e / 3;
  }
  hull(t) {
    let e = this.p, i = [], r, s = 0, a = 0, o = 0;
    const c = [];
    for (c[s++] = e[0], c[s++] = e[1], c[s++] = e[2], c[s++] = e[3]; e.length > 1; ) {
      for (i = [], a = 0, o = e.length - 1; a < o; a++)
        r = t * e[a] + (1 - t) * e[a + 1], c[s++] = r, i.push(r);
      e = i;
    }
    return c;
  }
  split(t) {
    const e = this.hull(t);
    return {
      left: new Fe(e[0], e[4], e[7], e[9]),
      right: new Fe(e[9], e[8], e[6], e[3]),
      span: e
    };
  }
  clone() {
    return new Fe(this.p[0], this.p[1], this.p[2], this.p[3]);
  }
  toJSON() {
    return {
      p0: this.p[0],
      p1: this.p[1],
      p2: this.p[2],
      p3: this.p[3]
    };
  }
  static fromJSON(t) {
    return new Fe(t.p0, t.p1, t.p2, t.p3);
  }
}
const zi = (n) => ({ r: n.x, g: n.y, b: n.z, a: n.w }), Oi = (n) => new wt(n.r, n.g, n.b, n.a), Cl = (n, t) => {
  switch (t) {
    case "Vector3":
      return new B(n.x, n.y, n.z);
    case "Vector4":
      return new wt(n.x, n.y, n.z, n.w);
    case "Color":
      return new B(n.r, n.g, n.b);
    case "Number":
      return n;
    default:
      return n;
  }
}, Ml = (n, t) => {
  switch (t) {
    case "Vector3":
      return { x: n.x, y: n.y, z: n.z };
    case "Vector4":
      return { x: n.x, y: n.y, z: n.z, w: n.w };
    case "Color":
      return { r: n.x, g: n.y, b: n.z };
    case "Number":
      return n;
    default:
      return n;
  }
};
class qr {
  constructor(t, e) {
    this.a = t, this.b = e, this.type = "value";
  }
  startGen(t) {
  }
  genColor(t, e) {
    const i = Math.random();
    return e.copy(this.a).lerp(this.b, i);
  }
  toJSON() {
    return {
      type: "RandomColor",
      a: zi(this.a),
      b: zi(this.b)
    };
  }
  static fromJSON(t) {
    return new qr(Oi(t.a), Oi(t.b));
  }
  clone() {
    return new qr(this.a.clone(), this.b.clone());
  }
}
class ti {
  constructor(t, e) {
    this.a = t, this.b = e, this.indexCount = -1, this.type = "value";
  }
  startGen(t) {
    this.indexCount = t.length, t.push(Math.random());
  }
  genColor(t, e) {
    return this.indexCount === -1 && this.startGen(t), e.copy(this.a).lerp(this.b, t[this.indexCount]);
  }
  toJSON() {
    return {
      type: "ColorRange",
      a: zi(this.a),
      b: zi(this.b)
    };
  }
  static fromJSON(t) {
    return new ti(Oi(t.a), Oi(t.b));
  }
  clone() {
    return new ti(this.a.clone(), this.b.clone());
  }
}
class Te {
  constructor(t, e) {
    this.subType = e, this.type = "function", this.keys = t;
  }
  findKey(t) {
    let e = 0, i = 0, r = this.keys.length - 1;
    for (; i + 1 < r; )
      if (e = Math.floor((i + r) / 2), t < this.getStartX(e))
        r = e - 1;
      else if (t > this.getEndX(e))
        i = e + 1;
      else
        return e;
    for (let s = i; s <= r; s++)
      if (t >= this.getStartX(s) && t <= this.getEndX(s))
        return s;
    return -1;
  }
  getStartX(t) {
    return this.keys[t][1];
  }
  getEndX(t) {
    return t + 1 < this.keys.length ? this.keys[t + 1][1] : 1;
  }
  genValue(t, e) {
    const i = this.findKey(e);
    return this.subType === "Number" ? i === -1 ? this.keys[0][0] : i + 1 >= this.keys.length ? this.keys[this.keys.length - 1][0] : (this.keys[i + 1][0] - this.keys[i][0]) * ((e - this.getStartX(i)) / (this.getEndX(i) - this.getStartX(i))) + this.keys[i][0] : i === -1 ? t.copy(this.keys[0][0]) : i + 1 >= this.keys.length ? t.copy(this.keys[this.keys.length - 1][0]) : t.copy(this.keys[i][0]).lerp(this.keys[i + 1][0], (e - this.getStartX(i)) / (this.getEndX(i) - this.getStartX(i)));
  }
  toJSON() {
    return this.keys[0][0].constructor.name, {
      type: "CLinearFunction",
      subType: this.subType,
      keys: this.keys.map(([t, e]) => ({ value: Ml(t, this.subType), pos: e }))
    };
  }
  static fromJSON(t) {
    return new Te(t.keys.map((e) => [Cl(e.value, t.subType), e.pos]), t.subType);
  }
  clone() {
    return this.subType === "Number" ? new Te(this.keys.map(([t, e]) => [t, e]), this.subType) : new Te(this.keys.map(([t, e]) => [t.clone(), e]), this.subType);
  }
}
const yr = new B();
class De {
  constructor(t = [
    [new B(0, 0, 0), 0],
    [new B(1, 1, 1), 0]
  ], e = [
    [1, 0],
    [1, 1]
  ]) {
    this.type = "function", this.color = new Te(t, "Color"), this.alpha = new Te(e, "Number");
  }
  genColor(t, e, i) {
    return this.color.genValue(yr, i), e.set(yr.x, yr.y, yr.z, this.alpha.genValue(1, i));
  }
  toJSON() {
    return {
      type: "Gradient",
      color: this.color.toJSON(),
      alpha: this.alpha.toJSON()
    };
  }
  static fromJSON(t) {
    if (t.functions) {
      const e = t.functions.map((i) => [ti.fromJSON(i.function).a, i.start]);
      return t.functions.length > 0 && e.push([ti.fromJSON(t.functions[t.functions.length - 1].function).b, 1]), new De(e.map((i) => [new B(i[0].x, i[0].y, i[0].z), i[1]]), e.map((i) => [i[0].w, i[1]]));
    } else {
      const e = new De();
      return e.alpha = Te.fromJSON(t.alpha), e.color = Te.fromJSON(t.color), e;
    }
  }
  clone() {
    const t = new De();
    return t.alpha = this.alpha.clone(), t.color = this.color.clone(), t;
  }
  startGen(t) {
  }
}
const _n = new wt();
class Xr {
  constructor(t, e) {
    this.indexCount = 0, this.type = "function", this.gradient1 = t, this.gradient2 = e;
  }
  startGen(t) {
    this.indexCount = t.length, t.push(Math.random());
  }
  genColor(t, e, i) {
    return this.gradient1.genColor(t, e, i), this.gradient2.genColor(t, _n, i), t && t[this.indexCount] !== void 0 ? e.lerp(_n, t[this.indexCount]) : e.lerp(_n, Math.random()), e;
  }
  toJSON() {
    return {
      type: "RandomColorBetweenGradient",
      gradient1: this.gradient1.toJSON(),
      gradient2: this.gradient2.toJSON()
    };
  }
  static fromJSON(t) {
    return new Xr(De.fromJSON(t.gradient1), De.fromJSON(t.gradient2));
  }
  clone() {
    return new Xr(this.gradient1.clone(), this.gradient2.clone());
  }
}
class ei {
  constructor(t) {
    this.color = t, this.type = "value";
  }
  startGen(t) {
  }
  genColor(t, e) {
    return e.copy(this.color);
  }
  toJSON() {
    return {
      type: "ConstantColor",
      color: zi(this.color)
    };
  }
  static fromJSON(t) {
    return new ei(Oi(t.color));
  }
  clone() {
    return new ei(this.color.clone());
  }
}
function ys(n) {
  switch (n.type) {
    case "ConstantColor":
      return ei.fromJSON(n);
    case "ColorRange":
      return ti.fromJSON(n);
    case "RandomColor":
      return qr.fromJSON(n);
    case "Gradient":
      return De.fromJSON(n);
    case "RandomColorBetweenGradient":
      return Xr.fromJSON(n);
    default:
      return new ei(new wt(1, 1, 1, 1));
  }
}
class J {
  constructor(t) {
    this.value = t, this.type = "value";
  }
  startGen(t) {
  }
  genValue(t) {
    return this.value;
  }
  toJSON() {
    return {
      type: "ConstantValue",
      value: this.value
    };
  }
  static fromJSON(t) {
    return new J(t.value);
  }
  clone() {
    return new J(this.value);
  }
}
class Le {
  constructor(t, e) {
    this.a = t, this.b = e, this.indexCount = -1, this.type = "value";
  }
  startGen(t) {
    this.indexCount = t.length, t.push(Math.random());
  }
  genValue(t) {
    return this.indexCount === -1 && this.startGen(t), ni.lerp(this.a, this.b, t[this.indexCount]);
  }
  toJSON() {
    return {
      type: "IntervalValue",
      a: this.a,
      b: this.b
    };
  }
  static fromJSON(t) {
    return new Le(t.a, t.b);
  }
  clone() {
    return new Le(this.a, this.b);
  }
}
class Pl {
  constructor() {
    this.functions = new Array();
  }
  findFunction(t) {
    let e = 0, i = 0, r = this.functions.length - 1;
    for (; i + 1 < r; )
      if (e = Math.floor((i + r) / 2), t < this.getStartX(e))
        r = e - 1;
      else if (t > this.getEndX(e))
        i = e + 1;
      else
        return e;
    for (let s = i; s <= r; s++)
      if (t >= this.functions[s][1] && t <= this.getEndX(s))
        return s;
    return -1;
  }
  getStartX(t) {
    return this.functions[t][1];
  }
  setStartX(t, e) {
    t > 0 && (this.functions[t][1] = e);
  }
  getEndX(t) {
    return t + 1 < this.functions.length ? this.functions[t + 1][1] : 1;
  }
  setEndX(t, e) {
    t + 1 < this.functions.length && (this.functions[t + 1][1] = e);
  }
  insertFunction(t, e) {
    const i = this.findFunction(t);
    this.functions.splice(i + 1, 0, [e, t]);
  }
  removeFunction(t) {
    return this.functions.splice(t, 1)[0][0];
  }
  getFunction(t) {
    return this.functions[t][0];
  }
  setFunction(t, e) {
    this.functions[t][0] = e;
  }
  get numOfFunctions() {
    return this.functions.length;
  }
}
class Bi extends Pl {
  constructor(t = [[new Fe(0, 1 / 3, 1 / 3 * 2, 1), 0]]) {
    super(), this.type = "function", this.functions = t;
  }
  genValue(t, e = 0) {
    const i = this.findFunction(e);
    return i === -1 ? 0 : this.functions[i][0].genValue((e - this.getStartX(i)) / (this.getEndX(i) - this.getStartX(i)));
  }
  toSVG(t, e) {
    if (e < 1)
      return "";
    let i = ["M", 0, this.functions[0][0].p[0]].join(" ");
    for (let r = 1 / e; r <= 1; r += 1 / e)
      i = [i, "L", r * t, this.genValue(void 0, r)].join(" ");
    return i;
  }
  toJSON() {
    return {
      type: "PiecewiseBezier",
      functions: this.functions.map(([t, e]) => ({ function: t.toJSON(), start: e }))
    };
  }
  static fromJSON(t) {
    return new Bi(t.functions.map((e) => [
      Fe.fromJSON(e.function),
      e.start
    ]));
  }
  clone() {
    return new Bi(this.functions.map(([t, e]) => [t.clone(), e]));
  }
  startGen(t) {
  }
}
function F(n) {
  switch (n.type) {
    case "ConstantValue":
      return J.fromJSON(n);
    case "IntervalValue":
      return Le.fromJSON(n);
    case "PiecewiseBezier":
      return Bi.fromJSON(n);
    default:
      return new J(0);
  }
}
class Ii {
  constructor() {
    this.indexCount = 0, this.type = "rotation";
  }
  startGen(t) {
    this.indexCount = t.length, t.push(new G());
    let e, i, r, s, a, o;
    do
      e = Math.random() * 2 - 1, i = Math.random() * 2 - 1, r = e * e + i * i;
    while (r > 1);
    do
      s = Math.random() * 2 - 1, a = Math.random() * 2 - 1, o = s * s + a * a;
    while (o > 1);
    const c = Math.sqrt((1 - r) / o);
    t[this.indexCount].set(e, i, c * s, c * a);
  }
  genValue(t, e, i, r) {
    return this.indexCount === -1 && this.startGen(t), e.copy(t[this.indexCount]), e;
  }
  toJSON() {
    return {
      type: "RandomQuat"
    };
  }
  static fromJSON(t) {
    return new Ii();
  }
  clone() {
    return new Ii();
  }
}
class Ni {
  constructor(t, e) {
    this.axis = t, this.angle = e, this.type = "rotation";
  }
  startGen(t) {
    this.angle.startGen(t);
  }
  genValue(t, e, i, r) {
    return e.setFromAxisAngle(this.axis, this.angle.genValue(t, r) * i);
  }
  toJSON() {
    return {
      type: "AxisAngle",
      axis: { x: this.axis.x, y: this.axis.y, z: this.axis.z },
      angle: this.angle.toJSON()
    };
  }
  static fromJSON(t) {
    return new Ni(new B(t.axis.x, t.axis.y, t.axis.z), F(t.angle));
  }
  clone() {
    return new Ni(this.axis.clone(), this.angle.clone());
  }
}
class Hr {
  constructor(t, e, i, r) {
    this.angleX = t, this.angleY = e, this.angleZ = i, this.type = "rotation", this.eular = new Ai(0, 0, 0, r);
  }
  startGen(t) {
    this.angleX.startGen(t), this.angleY.startGen(t), this.angleZ.startGen(t);
  }
  genValue(t, e, i, r) {
    return this.eular.set(this.angleX.genValue(t, r) * i, this.angleY.genValue(t, r) * i, this.angleZ.genValue(t, r) * i), e.setFromEuler(this.eular);
  }
  toJSON() {
    return {
      type: "Euler",
      angleX: this.angleX.toJSON(),
      angleY: this.angleY.toJSON(),
      angleZ: this.angleZ.toJSON(),
      eulerOrder: this.eular.order
    };
  }
  static fromJSON(t) {
    return new Hr(F(t.angleX), F(t.angleY), F(t.angleZ), t.eulerOrder);
  }
  clone() {
    return new Hr(this.angleX, this.angleY, this.angleZ, this.eular.order);
  }
}
function Ra(n) {
  switch (n.type) {
    case "AxisAngle":
      return Ni.fromJSON(n);
    case "Euler":
      return Hr.fromJSON(n);
    case "RandomQuat":
      return Ii.fromJSON(n);
    default:
      return new Ii();
  }
}
class Ve {
  constructor(t, e, i) {
    this.x = t, this.y = e, this.z = i, this.type = "vec3function";
  }
  startGen(t) {
    this.x.startGen(t), this.y.startGen(t), this.z.startGen(t);
  }
  genValue(t, e, i) {
    return e.set(this.x.genValue(t, i), this.y.genValue(t, i), this.z.genValue(t, i));
  }
  toJSON() {
    return {
      type: "Vector3Function",
      x: this.x.toJSON(),
      y: this.y.toJSON(),
      z: this.z.toJSON()
    };
  }
  static fromJSON(t) {
    return new Ve(F(t.x), F(t.y), F(t.z));
  }
  clone() {
    return new Ve(this.x, this.y, this.z);
  }
}
function wl(n) {
  switch (n.type) {
    case "Vector3Function":
      return Ve.fromJSON(n);
    default:
      return new Ve(new J(0), new J(0), new J(0));
  }
}
function Wr(n) {
  switch (n.type) {
    case "ConstantValue":
    case "IntervalValue":
    case "PiecewiseBezier":
      return F(n);
    case "AxisAngle":
    case "RandomQuat":
    case "Euler":
      return Ra(n);
    case "Vector3Function":
      return wl(n);
    default:
      return new J(0);
  }
}
class Ui {
  constructor(t = {}) {
    var e, i, r, s, a, o, c;
    this.type = "cone", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (r = t.thickness) !== null && r !== void 0 ? r : 1, this.angle = (s = t.angle) !== null && s !== void 0 ? s : Math.PI / 6, this.mode = (a = t.mode) !== null && a !== void 0 ? a : vt.Random, this.spread = (o = t.spread) !== null && o !== void 0 ? o : 0, this.speed = (c = t.speed) !== null && c !== void 0 ? c : new J(1), this.memory = [];
  }
  update(t, e) {
    vt.Random != this.mode && (this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e);
  }
  initialize(t, e) {
    const i = hr(this.mode, this.currentValue, this.spread, e), r = ni.lerp(1 - this.thickness, 1, Math.random()), s = i * this.arc, a = Math.sqrt(r), o = Math.sin(s), c = Math.cos(s);
    t.position.x = a * c, t.position.y = a * o, t.position.z = 0;
    const l = this.angle * a;
    t.velocity.set(0, 0, Math.cos(l)).addScaledVector(t.position, Math.sin(l)).multiplyScalar(t.startSpeed), t.position.multiplyScalar(this.radius);
  }
  toJSON() {
    return {
      type: "cone",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      angle: this.angle,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new Ui({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      angle: t.angle,
      mode: t.mode,
      speed: t.speed ? F(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new Ui({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      angle: this.angle,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
class Fi {
  constructor(t = {}) {
    var e, i, r, s, a, o;
    this.type = "circle", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (r = t.thickness) !== null && r !== void 0 ? r : 1, this.mode = (s = t.mode) !== null && s !== void 0 ? s : vt.Random, this.spread = (a = t.spread) !== null && a !== void 0 ? a : 0, this.speed = (o = t.speed) !== null && o !== void 0 ? o : new J(1), this.memory = [];
  }
  update(t, e) {
    this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e;
  }
  initialize(t, e) {
    const i = hr(this.mode, this.currentValue, this.spread, e), r = ni.lerp(1 - this.thickness, 1, Math.random()), s = i * this.arc;
    t.position.x = Math.cos(s), t.position.y = Math.sin(s), t.position.z = 0, t.velocity.copy(t.position).multiplyScalar(t.startSpeed), t.position.multiplyScalar(this.radius * r);
  }
  toJSON() {
    return {
      type: "circle",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new Fi({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      mode: t.mode,
      speed: t.speed ? F(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new Fi({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
function gr(n, t) {
  return Math.floor(Math.random() * (t - n)) + n;
}
const tn = new B(0, 1, 0), en = new B(0, 0, 0), El = new B(1, 1, 1), lo = new B(0, 0, 1);
class Di {
  constructor(t = {}) {
    var e, i, r, s, a, o, c;
    this.type = "donut", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (r = t.thickness) !== null && r !== void 0 ? r : 1, this.donutRadius = (s = t.donutRadius) !== null && s !== void 0 ? s : this.radius * 0.2, this.mode = (a = t.mode) !== null && a !== void 0 ? a : vt.Random, this.spread = (o = t.spread) !== null && o !== void 0 ? o : 0, this.speed = (c = t.speed) !== null && c !== void 0 ? c : new J(1), this.memory = [], this._m1 = new Qt();
  }
  update(t, e) {
    vt.Random != this.mode && (this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e);
  }
  initialize(t, e) {
    const i = hr(this.mode, this.currentValue, this.spread, e), r = Math.random(), s = ni.lerp(1 - this.thickness, 1, Math.random()), a = i * this.arc, o = r * Math.PI * 2, c = Math.sin(a), l = Math.cos(a);
    t.position.x = this.radius * l, t.position.y = this.radius * c, t.position.z = 0, t.velocity.z = this.donutRadius * s * Math.sin(o), t.velocity.x = this.donutRadius * s * Math.cos(o) * l, t.velocity.y = this.donutRadius * s * Math.cos(o) * c, t.position.add(t.velocity), t.velocity.normalize().multiplyScalar(t.startSpeed), t.rotation instanceof G && (this._m1.lookAt(en, t.velocity, tn), t.rotation.setFromRotationMatrix(this._m1));
  }
  toJSON() {
    return {
      type: "donut",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      donutRadius: this.donutRadius,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new Di({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      donutRadius: t.donutRadius,
      mode: t.mode,
      speed: t.speed ? F(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new Di({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      donutRadius: this.donutRadius,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
class Li {
  constructor() {
    this.type = "point", this._m1 = new Qt();
  }
  update(t, e) {
  }
  initialize(t) {
    const e = Math.random(), i = Math.random(), r = e * Math.PI * 2, s = Math.acos(2 * i - 1), a = Math.cbrt(Math.random()), o = Math.sin(r), c = Math.cos(r), l = Math.sin(s), h = Math.cos(s);
    t.velocity.x = a * l * c, t.velocity.y = a * l * o, t.velocity.z = a * h, t.velocity.multiplyScalar(t.startSpeed), t.position.setScalar(0), t.rotation instanceof G && (this._m1.lookAt(en, t.position, tn), t.rotation.setFromRotationMatrix(this._m1));
  }
  toJSON() {
    return {
      type: "point"
    };
  }
  static fromJSON(t) {
    return new Li();
  }
  clone() {
    return new Li();
  }
}
class ii {
  constructor(t = {}) {
    var e, i, r, s, a, o;
    this.type = "sphere", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (r = t.thickness) !== null && r !== void 0 ? r : 1, this.mode = (s = t.mode) !== null && s !== void 0 ? s : vt.Random, this.spread = (a = t.spread) !== null && a !== void 0 ? a : 0, this.speed = (o = t.speed) !== null && o !== void 0 ? o : new J(1), this.memory = [], this._m1 = new Qt();
  }
  update(t, e) {
    vt.Random != this.mode && (this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e);
  }
  initialize(t, e) {
    const i = hr(this.mode, this.currentValue, this.spread, e), r = Math.random(), s = ni.lerp(1 - this.thickness, 1, Math.random()), a = i * this.arc, o = Math.acos(2 * r - 1), c = Math.sin(a), l = Math.cos(a), h = Math.sin(o), u = Math.cos(o);
    t.position.x = h * l, t.position.y = h * c, t.position.z = u, t.velocity.copy(t.position).multiplyScalar(t.startSpeed), t.position.multiplyScalar(this.radius * s), t.rotation instanceof G && (this._m1.lookAt(en, t.position, tn), t.rotation.setFromRotationMatrix(this._m1));
  }
  toJSON() {
    return {
      type: "sphere",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new ii({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      mode: t.mode,
      speed: t.speed ? F(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new ii({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
class Vi {
  constructor(t = {}) {
    var e, i, r, s, a, o;
    this.type = "sphere", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (r = t.thickness) !== null && r !== void 0 ? r : 1, this.mode = (s = t.mode) !== null && s !== void 0 ? s : vt.Random, this.spread = (a = t.spread) !== null && a !== void 0 ? a : 0, this.speed = (o = t.speed) !== null && o !== void 0 ? o : new J(1), this.memory = [], this._m1 = new Qt();
  }
  update(t, e) {
    vt.Random != this.mode && (this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e);
  }
  initialize(t, e) {
    const i = hr(this.mode, this.currentValue, this.spread, e), r = Math.random(), s = ni.lerp(1 - this.thickness, 1, Math.random()), a = i * this.arc, o = Math.acos(r), c = Math.sin(a), l = Math.cos(a), h = Math.sin(o), u = Math.cos(o);
    t.position.x = h * l, t.position.y = h * c, t.position.z = u, t.velocity.copy(t.position).multiplyScalar(t.startSpeed), t.position.multiplyScalar(this.radius * s), t.rotation instanceof G && (this._m1.lookAt(en, t.position, tn), t.rotation.setFromRotationMatrix(this._m1));
  }
  toJSON() {
    return {
      type: "hemisphere",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new Vi({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      mode: t.mode,
      speed: t.speed ? F(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new Vi({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
class Ji {
  constructor(t = {}) {
    var e, i, r, s;
    this.type = "grid", this.width = (e = t.width) !== null && e !== void 0 ? e : 1, this.height = (i = t.height) !== null && i !== void 0 ? i : 1, this.column = (r = t.column) !== null && r !== void 0 ? r : 10, this.row = (s = t.row) !== null && s !== void 0 ? s : 10;
  }
  initialize(t) {
    const e = Math.floor(Math.random() * this.row), i = Math.floor(Math.random() * this.column);
    t.position.x = i * this.width / this.column - this.width / 2, t.position.y = e * this.height / this.row - this.height / 2, t.position.z = 0, t.velocity.set(0, 0, t.startSpeed);
  }
  toJSON() {
    return {
      type: "grid",
      width: this.width,
      height: this.height,
      column: this.column,
      row: this.row
    };
  }
  static fromJSON(t) {
    return new Ji(t);
  }
  clone() {
    return new Ji({
      width: this.width,
      height: this.height,
      column: this.column,
      row: this.row
    });
  }
  update(t, e) {
  }
}
const Yn = {
  circle: {
    type: "circle",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: Fi,
    loadJSON: Fi.fromJSON
  },
  cone: {
    type: "cone",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: Ui,
    loadJSON: Ui.fromJSON
  },
  donut: {
    type: "donut",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["donutRadius", ["number"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: Di,
    loadJSON: Di.fromJSON
  },
  point: { type: "point", params: [], constructor: Li, loadJSON: Li.fromJSON },
  sphere: {
    type: "sphere",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: ii,
    loadJSON: ii.fromJSON
  },
  hemisphere: {
    type: "hemisphere",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: Vi,
    loadJSON: Vi.fromJSON
  },
  grid: {
    type: "grid",
    params: [
      ["width", ["number"]],
      ["height", ["number"]],
      ["rows", ["number"]],
      ["column", ["number"]]
    ],
    constructor: Ji,
    loadJSON: Ji.fromJSON
  }
};
function kl(n, t) {
  return Yn[n.type].loadJSON(n, t);
}
class Gi {
  constructor(t) {
    this.color = t, this.type = "ColorOverLife";
  }
  initialize(t) {
    this.color.startGen(t.memory);
  }
  update(t, e) {
    this.color.genColor(t.memory, t.color, t.age / t.life), t.color.x *= t.startColor.x, t.color.y *= t.startColor.y, t.color.z *= t.startColor.z, t.color.w *= t.startColor.w;
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      color: this.color.toJSON()
    };
  }
  static fromJSON(t) {
    return new Gi(ys(t.color));
  }
  clone() {
    return new Gi(this.color.clone());
  }
  reset() {
  }
}
class ji {
  constructor(t) {
    this.angularVelocity = t, this.type = "RotationOverLife";
  }
  initialize(t) {
    typeof t.rotation == "number" && this.angularVelocity.startGen(t.memory);
  }
  update(t, e) {
    typeof t.rotation == "number" && (t.rotation += e * this.angularVelocity.genValue(t.memory, t.age / t.life));
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON()
    };
  }
  static fromJSON(t) {
    return new ji(F(t.angularVelocity));
  }
  frameUpdate(t) {
  }
  clone() {
    return new ji(this.angularVelocity.clone());
  }
  reset() {
  }
}
class $i {
  constructor(t) {
    this.angularVelocity = t, this.type = "Rotation3DOverLife", this.tempQuat = new G(), this.tempQuat2 = new G();
  }
  initialize(t) {
    t.rotation instanceof G && (t.angularVelocity = new G(), this.angularVelocity.startGen(t.memory));
  }
  update(t, e) {
    t.rotation instanceof G && (this.angularVelocity.genValue(t.memory, this.tempQuat, e, t.age / t.life), t.rotation.multiply(this.tempQuat));
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON()
    };
  }
  static fromJSON(t) {
    return new $i(Ra(t.angularVelocity));
  }
  frameUpdate(t) {
  }
  clone() {
    return new $i(this.angularVelocity.clone());
  }
  reset() {
  }
}
class qi {
  initialize(t, e) {
    this.ps = e, this.x.startGen(t.memory), this.y.startGen(t.memory), this.z.startGen(t.memory);
  }
  constructor(t, e, i) {
    this.x = t, this.y = e, this.z = i, this.type = "ForceOverLife", this._temp = new B(), this._tempScale = new B(), this._tempQ = new G();
  }
  update(t, e) {
    this._temp.set(this.x.genValue(t.memory, t.age / t.life), this.y.genValue(t.memory, t.age / t.life), this.z.genValue(t.memory, t.age / t.life)), this.ps.worldSpace ? t.velocity.addScaledVector(this._temp, e) : (this._temp.multiply(this._tempScale).applyQuaternion(this._tempQ), t.velocity.addScaledVector(this._temp, e));
  }
  toJSON() {
    return {
      type: this.type,
      x: this.x.toJSON(),
      y: this.y.toJSON(),
      z: this.z.toJSON()
    };
  }
  static fromJSON(t) {
    return new qi(F(t.x), F(t.y), F(t.z));
  }
  frameUpdate(t) {
    if (this.ps && !this.ps.worldSpace) {
      const e = this._temp, i = this._tempQ, r = this._tempScale;
      this.ps.emitter.matrixWorld.decompose(e, i, r), i.invert(), r.set(1 / r.x, 1 / r.y, 1 / r.z);
    }
  }
  clone() {
    return new qi(this.x.clone(), this.y.clone(), this.z.clone());
  }
  reset() {
  }
}
class Xi {
  initialize(t) {
    this.size.startGen(t.memory);
  }
  constructor(t) {
    this.size = t, this.type = "SizeOverLife";
  }
  update(t) {
    this.size instanceof Ve ? this.size.genValue(t.memory, t.size, t.age / t.life).multiply(t.startSize) : t.size.copy(t.startSize).multiplyScalar(this.size.genValue(t.memory, t.age / t.life));
  }
  toJSON() {
    return {
      type: this.type,
      size: this.size.toJSON()
    };
  }
  static fromJSON(t) {
    return new Xi(Wr(t.size));
  }
  frameUpdate(t) {
  }
  clone() {
    return new Xi(this.size.clone());
  }
  reset() {
  }
}
class Hi {
  initialize(t) {
    this.speed.startGen(t.memory);
  }
  constructor(t) {
    this.speed = t, this.type = "SpeedOverLife";
  }
  update(t) {
    t.speedModifier = this.speed.genValue(t.memory, t.age / t.life);
  }
  toJSON() {
    return {
      type: this.type,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new Hi(F(t.speed));
  }
  frameUpdate(t) {
  }
  clone() {
    return new Hi(this.speed.clone());
  }
  reset() {
  }
}
class Wi {
  constructor(t) {
    this.frame = t, this.type = "FrameOverLife";
  }
  initialize(t) {
    this.frame.startGen(t.memory);
  }
  update(t, e) {
    this.frame instanceof Bi && (t.uvTile = this.frame.genValue(t.memory, t.age / t.life));
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      frame: this.frame.toJSON()
    };
  }
  static fromJSON(t) {
    return new Wi(F(t.frame));
  }
  clone() {
    return new Wi(this.frame.clone());
  }
  reset() {
  }
}
class Yi {
  constructor(t, e = new B(0, 1, 0)) {
    this.orbitSpeed = t, this.axis = e, this.type = "OrbitOverLife", this.temp = new B(), this.rotation = new G();
  }
  initialize(t) {
    this.orbitSpeed.startGen(t.memory);
  }
  update(t, e) {
    this.temp.copy(t.position).projectOnVector(this.axis), this.rotation.setFromAxisAngle(this.axis, this.orbitSpeed.genValue(t.memory, t.age / t.life) * e), t.position.sub(this.temp), t.position.applyQuaternion(this.rotation), t.position.add(this.temp);
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      orbitSpeed: this.orbitSpeed.toJSON(),
      axis: [this.axis.x, this.axis.y, this.axis.z]
    };
  }
  static fromJSON(t) {
    return new Yi(F(t.orbitSpeed), t.axis ? new B(t.axis[0], t.axis[1], t.axis[2]) : void 0);
  }
  clone() {
    return new Yi(this.orbitSpeed.clone());
  }
  reset() {
  }
}
class xn {
  constructor(t) {
    this.data = t, this.next = null, this.prev = null;
  }
  hasPrev() {
    return this.prev !== null;
  }
  hasNext() {
    return this.next !== null;
  }
}
class Rl {
  constructor() {
    this.length = 0, this.head = this.tail = null;
  }
  isEmpty() {
    return this.head === null;
  }
  clear() {
    this.length = 0, this.head = this.tail = null;
  }
  front() {
    return this.head === null ? null : this.head.data;
  }
  back() {
    return this.tail === null ? null : this.tail.data;
  }
  dequeue() {
    if (this.head) {
      const t = this.head.data;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, t;
    }
  }
  pop() {
    if (this.tail) {
      const t = this.tail.data;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, t;
    }
  }
  queue(t) {
    const e = new xn(t);
    this.tail || (this.tail = e), this.head && (this.head.prev = e, e.next = this.head), this.head = e, this.length++;
  }
  push(t) {
    const e = new xn(t);
    this.head || (this.head = e), this.tail && (this.tail.next = e, e.prev = this.tail), this.tail = e, this.length++;
  }
  insertBefore(t, e) {
    const i = new xn(e);
    i.next = t, i.prev = t.prev, i.prev !== null && (i.prev.next = i), i.next.prev = i, t == this.head && (this.head = i), this.length++;
  }
  remove(t) {
    if (this.head === null || this.tail === null)
      return;
    let e = this.head;
    for (t === this.head.data && (this.head = this.head.next), t === this.tail.data && (this.tail = this.tail.prev); e.next !== null && e.data !== t; )
      e = e.next;
    e.data === t && (e.prev !== null && (e.prev.next = e.next), e.next !== null && (e.next.prev = e.prev), this.length--);
  }
  *values() {
    let t = this.head;
    for (; t !== null; )
      yield t.data, t = t.next;
  }
}
class Al {
  constructor() {
    this.startSpeed = 0, this.startColor = new wt(), this.startSize = new B(1, 1, 1), this.position = new B(), this.velocity = new B(), this.age = 0, this.life = 1, this.size = new B(1, 1, 1), this.speedModifier = 1, this.rotation = 0, this.color = new wt(), this.uvTile = 0, this.memory = [];
  }
  get died() {
    return this.age >= this.life;
  }
  reset() {
    this.memory.length = 0;
  }
}
class zl {
  constructor(t, e, i) {
    this.position = t, this.size = e, this.color = i;
  }
}
class Zn {
  constructor() {
    this.startSpeed = 0, this.startColor = new wt(), this.startSize = new B(1, 1, 1), this.position = new B(), this.velocity = new B(), this.age = 0, this.life = 1, this.size = new B(1, 1, 1), this.length = 100, this.speedModifier = 1, this.color = new wt(), this.previous = new Rl(), this.uvTile = 0, this.memory = [];
  }
  update() {
    for (this.age <= this.life ? this.previous.push(new zl(this.position.clone(), this.size.x, this.color.clone())) : this.previous.length > 0 && this.previous.dequeue(); this.previous.length > this.length; )
      this.previous.dequeue();
  }
  get died() {
    return this.age >= this.life;
  }
  reset() {
    this.memory.length = 0, this.previous.clear();
  }
}
class Zi {
  initialize(t) {
    this.width.startGen(t.memory);
  }
  constructor(t) {
    this.width = t, this.type = "WidthOverLength";
  }
  update(t) {
    if (t instanceof Zn) {
      const e = t.previous.values();
      for (let i = 0; i < t.previous.length; i++) {
        const r = e.next();
        r.value.size = this.width.genValue(t.memory, (t.previous.length - i) / t.length);
      }
    }
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      width: this.width.toJSON()
    };
  }
  static fromJSON(t) {
    return new Zi(F(t.width));
  }
  clone() {
    return new Zi(this.width.clone());
  }
  reset() {
  }
}
class Ki {
  constructor(t, e) {
    this.direction = t, this.magnitude = e, this.type = "ApplyForce", this.memory = {
      data: [],
      dataCount: 0
    }, this.magnitudeValue = this.magnitude.genValue(this.memory);
  }
  initialize(t) {
  }
  update(t, e) {
    t.velocity.addScaledVector(this.direction, this.magnitudeValue * e);
  }
  frameUpdate(t) {
    this.magnitudeValue = this.magnitude.genValue(this.memory);
  }
  toJSON() {
    return {
      type: this.type,
      direction: [this.direction.x, this.direction.y, this.direction.z],
      magnitude: this.magnitude.toJSON()
    };
  }
  static fromJSON(t) {
    var e;
    return new Ki(new B(t.direction[0], t.direction[1], t.direction[2]), F((e = t.magnitude) !== null && e !== void 0 ? e : t.force));
  }
  clone() {
    return new Ki(this.direction.clone(), this.magnitude.clone());
  }
  reset() {
  }
}
class Qi {
  constructor(t, e) {
    this.center = t, this.magnitude = e, this.type = "GravityForce", this.temp = new B();
  }
  initialize(t) {
  }
  update(t, e) {
    this.temp.copy(this.center).sub(t.position).normalize(), t.velocity.addScaledVector(this.temp, this.magnitude / t.position.distanceToSquared(this.center) * e);
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      center: [this.center.x, this.center.y, this.center.z],
      magnitude: this.magnitude
    };
  }
  static fromJSON(t) {
    return new Qi(new B(t.center[0], t.center[1], t.center[2]), t.magnitude);
  }
  clone() {
    return new Qi(this.center.clone(), this.magnitude);
  }
  reset() {
  }
}
class tr {
  constructor(t) {
    this.angle = t, this.type = "ChangeEmitDirection", this._temp = new B(), this._q = new G(), this.memory = { data: [], dataCount: 0 };
  }
  initialize(t) {
    const e = t.velocity.length();
    e != 0 && (t.velocity.normalize(), t.velocity.x === 0 && t.velocity.y === 0 ? this._temp.set(0, t.velocity.z, 0) : this._temp.set(-t.velocity.y, t.velocity.x, 0), this.angle.startGen(this.memory), this._q.setFromAxisAngle(this._temp.normalize(), this.angle.genValue(this.memory)), this._temp.copy(t.velocity), t.velocity.applyQuaternion(this._q), this._q.setFromAxisAngle(this._temp, Math.random() * Math.PI * 2), t.velocity.applyQuaternion(this._q), t.velocity.setLength(e));
  }
  update(t, e) {
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      angle: this.angle.toJSON()
    };
  }
  static fromJSON(t) {
    return new tr(F(t.angle));
  }
  clone() {
    return new tr(this.angle);
  }
  reset() {
  }
}
var Ye;
(function(n) {
  n[n.Death = 0] = "Death", n[n.Birth = 1] = "Birth", n[n.Frame = 2] = "Frame";
})(Ye || (Ye = {}));
class er {
  constructor(t, e, i, r = Ye.Frame, s = 1) {
    this.particleSystem = t, this.useVelocityAsBasis = e, this.subParticleSystem = i, this.mode = r, this.emitProbability = s, this.type = "EmitSubParticleSystem", this.q_ = new G(), this.v_ = new B(), this.v2_ = new B(), this.subEmissions = new Array(), this.subParticleSystem && this.subParticleSystem.system && (this.subParticleSystem.system.onlyUsedByOther = !0);
  }
  initialize(t) {
  }
  update(t, e) {
    this.mode === Ye.Frame ? this.emit(t, e) : this.mode === Ye.Birth && t.age === 0 ? this.emit(t, e) : this.mode === Ye.Death && t.age + e >= t.life && this.emit(t, e);
  }
  emit(t, e) {
    if (!this.subParticleSystem || Math.random() > this.emitProbability)
      return;
    const i = new Qt();
    this.setMatrixFromParticle(i, t), this.subEmissions.push({
      burstParticleCount: 0,
      burstParticleIndex: 0,
      isBursting: !1,
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0,
      matrix: i,
      travelDistance: 0,
      particle: t
    });
  }
  frameUpdate(t) {
    if (this.subParticleSystem)
      for (let e = 0; e < this.subEmissions.length; e++)
        if (this.subEmissions[e].time >= this.subParticleSystem.system.duration)
          this.subEmissions[e] = this.subEmissions[this.subEmissions.length - 1], this.subEmissions.length = this.subEmissions.length - 1, e--;
        else {
          const i = this.subEmissions[e];
          i.particle && i.particle.age < i.particle.life ? this.setMatrixFromParticle(i.matrix, i.particle) : i.particle = void 0, this.subParticleSystem.system.emit(t, i, i.matrix);
        }
  }
  toJSON() {
    return {
      type: this.type,
      subParticleSystem: this.subParticleSystem ? this.subParticleSystem.uuid : "",
      useVelocityAsBasis: this.useVelocityAsBasis,
      mode: this.mode,
      emitProbability: this.emitProbability
    };
  }
  static fromJSON(t, e) {
    return new er(e, t.useVelocityAsBasis, t.subParticleSystem, t.mode, t.emitProbability);
  }
  clone() {
    return new er(this.particleSystem, this.useVelocityAsBasis, this.subParticleSystem, this.mode, this.emitProbability);
  }
  reset() {
  }
  setMatrixFromParticle(t, e) {
    let i;
    if (e.rotation === void 0 || this.useVelocityAsBasis)
      if (e.velocity.x === 0 && e.velocity.y === 0 && (e.velocity.z === 1 || e.velocity.z === 0))
        t.set(1, 0, 0, e.position.x, 0, 1, 0, e.position.y, 0, 0, 1, e.position.z, 0, 0, 0, 1);
      else {
        this.v_.copy(lo).cross(e.velocity), this.v2_.copy(e.velocity).cross(this.v_);
        const r = this.v_.length(), s = this.v2_.length();
        t.set(this.v_.x / r, this.v2_.x / s, e.velocity.x, e.position.x, this.v_.y / r, this.v2_.y / s, e.velocity.y, e.position.y, this.v_.z / r, this.v2_.z / s, e.velocity.z, e.position.z, 0, 0, 0, 1);
      }
    else
      e.rotation instanceof G ? i = e.rotation : (this.q_.setFromAxisAngle(lo, e.rotation), i = this.q_), t.compose(e.position, i, El);
    this.particleSystem.worldSpace || t.multiplyMatrices(this.particleSystem.emitter.matrixWorld, t);
  }
}
const Ol = 0.5 * (Math.sqrt(3) - 1), fi = (3 - Math.sqrt(3)) / 6, Bl = 1 / 3, Ht = 1 / 6, Il = (Math.sqrt(5) - 1) / 4, at = (5 - Math.sqrt(5)) / 20, st = new Float32Array([
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1,
  0,
  1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  -1,
  0,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1
]), et = new Float32Array([
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0
]);
class Aa {
  constructor(t = Math.random) {
    const e = typeof t == "function" ? t : Ul(t);
    this.p = Nl(e), this.perm = new Uint8Array(512), this.permMod12 = new Uint8Array(512);
    for (let i = 0; i < 512; i++)
      this.perm[i] = this.p[i & 255], this.permMod12[i] = this.perm[i] % 12;
  }
  noise2D(t, e) {
    const i = this.permMod12, r = this.perm;
    let s = 0, a = 0, o = 0;
    const c = (t + e) * Ol, l = Math.floor(t + c), h = Math.floor(e + c), u = (l + h) * fi, f = l - u, d = h - u, y = t - f, _ = e - d;
    let p, m;
    y > _ ? (p = 1, m = 0) : (p = 0, m = 1);
    const v = y - p + fi, g = _ - m + fi, b = y - 1 + 2 * fi, x = _ - 1 + 2 * fi, S = l & 255, T = h & 255;
    let P = 0.5 - y * y - _ * _;
    if (P >= 0) {
      const E = i[S + r[T]] * 3;
      P *= P, s = P * P * (st[E] * y + st[E + 1] * _);
    }
    let M = 0.5 - v * v - g * g;
    if (M >= 0) {
      const E = i[S + p + r[T + m]] * 3;
      M *= M, a = M * M * (st[E] * v + st[E + 1] * g);
    }
    let C = 0.5 - b * b - x * x;
    if (C >= 0) {
      const E = i[S + 1 + r[T + 1]] * 3;
      C *= C, o = C * C * (st[E] * b + st[E + 1] * x);
    }
    return 70 * (s + a + o);
  }
  noise3D(t, e, i) {
    const r = this.permMod12, s = this.perm;
    let a, o, c, l;
    const h = (t + e + i) * Bl, u = Math.floor(t + h), f = Math.floor(e + h), d = Math.floor(i + h), y = (u + f + d) * Ht, _ = u - y, p = f - y, m = d - y, v = t - _, g = e - p, b = i - m;
    let x, S, T, P, M, C;
    v >= g ? g >= b ? (x = 1, S = 0, T = 0, P = 1, M = 1, C = 0) : v >= b ? (x = 1, S = 0, T = 0, P = 1, M = 0, C = 1) : (x = 0, S = 0, T = 1, P = 1, M = 0, C = 1) : g < b ? (x = 0, S = 0, T = 1, P = 0, M = 1, C = 1) : v < b ? (x = 0, S = 1, T = 0, P = 0, M = 1, C = 1) : (x = 0, S = 1, T = 0, P = 1, M = 1, C = 0);
    const E = v - x + Ht, w = g - S + Ht, k = b - T + Ht, R = v - P + 2 * Ht, z = g - M + 2 * Ht, U = b - C + 2 * Ht, L = v - 1 + 3 * Ht, I = g - 1 + 3 * Ht, H = b - 1 + 3 * Ht, K = u & 255, rt = f & 255, tt = d & 255;
    let mt = 0.6 - v * v - g * g - b * b;
    if (mt < 0)
      a = 0;
    else {
      const $ = r[K + s[rt + s[tt]]] * 3;
      mt *= mt, a = mt * mt * (st[$] * v + st[$ + 1] * g + st[$ + 2] * b);
    }
    let yt = 0.6 - E * E - w * w - k * k;
    if (yt < 0)
      o = 0;
    else {
      const $ = r[K + x + s[rt + S + s[tt + T]]] * 3;
      yt *= yt, o = yt * yt * (st[$] * E + st[$ + 1] * w + st[$ + 2] * k);
    }
    let nt = 0.6 - R * R - z * z - U * U;
    if (nt < 0)
      c = 0;
    else {
      const $ = r[K + P + s[rt + M + s[tt + C]]] * 3;
      nt *= nt, c = nt * nt * (st[$] * R + st[$ + 1] * z + st[$ + 2] * U);
    }
    let W = 0.6 - L * L - I * I - H * H;
    if (W < 0)
      l = 0;
    else {
      const $ = r[K + 1 + s[rt + 1 + s[tt + 1]]] * 3;
      W *= W, l = W * W * (st[$] * L + st[$ + 1] * I + st[$ + 2] * H);
    }
    return 32 * (a + o + c + l);
  }
  noise4D(t, e, i, r) {
    const s = this.perm;
    let a, o, c, l, h;
    const u = (t + e + i + r) * Il, f = Math.floor(t + u), d = Math.floor(e + u), y = Math.floor(i + u), _ = Math.floor(r + u), p = (f + d + y + _) * at, m = f - p, v = d - p, g = y - p, b = _ - p, x = t - m, S = e - v, T = i - g, P = r - b;
    let M = 0, C = 0, E = 0, w = 0;
    x > S ? M++ : C++, x > T ? M++ : E++, x > P ? M++ : w++, S > T ? C++ : E++, S > P ? C++ : w++, T > P ? E++ : w++;
    const k = M >= 3 ? 1 : 0, R = C >= 3 ? 1 : 0, z = E >= 3 ? 1 : 0, U = w >= 3 ? 1 : 0, L = M >= 2 ? 1 : 0, I = C >= 2 ? 1 : 0, H = E >= 2 ? 1 : 0, K = w >= 2 ? 1 : 0, rt = M >= 1 ? 1 : 0, tt = C >= 1 ? 1 : 0, mt = E >= 1 ? 1 : 0, yt = w >= 1 ? 1 : 0, nt = x - k + at, W = S - R + at, $ = T - z + at, ie = P - U + at, jt = x - L + 2 * at, $t = S - I + 2 * at, qt = T - H + 2 * at, xt = P - K + 2 * at, Bt = x - rt + 3 * at, bt = S - tt + 3 * at, re = T - mt + 3 * at, ne = P - yt + 3 * at, Y = x - 1 + 4 * at, Xt = S - 1 + 4 * at, se = T - 1 + 4 * at, Pe = P - 1 + 4 * at, oe = f & 255, ae = d & 255, ce = y & 255, le = _ & 255;
    let he = 0.6 - x * x - S * S - T * T - P * P;
    if (he < 0)
      a = 0;
    else {
      const V = s[oe + s[ae + s[ce + s[le]]]] % 32 * 4;
      he *= he, a = he * he * (et[V] * x + et[V + 1] * S + et[V + 2] * T + et[V + 3] * P);
    }
    let It = 0.6 - nt * nt - W * W - $ * $ - ie * ie;
    if (It < 0)
      o = 0;
    else {
      const V = s[oe + k + s[ae + R + s[ce + z + s[le + U]]]] % 32 * 4;
      It *= It, o = It * It * (et[V] * nt + et[V + 1] * W + et[V + 2] * $ + et[V + 3] * ie);
    }
    let Nt = 0.6 - jt * jt - $t * $t - qt * qt - xt * xt;
    if (Nt < 0)
      c = 0;
    else {
      const V = s[oe + L + s[ae + I + s[ce + H + s[le + K]]]] % 32 * 4;
      Nt *= Nt, c = Nt * Nt * (et[V] * jt + et[V + 1] * $t + et[V + 2] * qt + et[V + 3] * xt);
    }
    let Ut = 0.6 - Bt * Bt - bt * bt - re * re - ne * ne;
    if (Ut < 0)
      l = 0;
    else {
      const V = s[oe + rt + s[ae + tt + s[ce + mt + s[le + yt]]]] % 32 * 4;
      Ut *= Ut, l = Ut * Ut * (et[V] * Bt + et[V + 1] * bt + et[V + 2] * re + et[V + 3] * ne);
    }
    let Ft = 0.6 - Y * Y - Xt * Xt - se * se - Pe * Pe;
    if (Ft < 0)
      h = 0;
    else {
      const V = s[oe + 1 + s[ae + 1 + s[ce + 1 + s[le + 1]]]] % 32 * 4;
      Ft *= Ft, h = Ft * Ft * (et[V] * Y + et[V + 1] * Xt + et[V + 2] * se + et[V + 3] * Pe);
    }
    return 27 * (a + o + c + l + h);
  }
}
function Nl(n) {
  const t = new Uint8Array(256);
  for (let e = 0; e < 256; e++)
    t[e] = e;
  for (let e = 0; e < 255; e++) {
    const i = e + ~~(n() * (256 - e)), r = t[e];
    t[e] = t[i], t[i] = r;
  }
  return t;
}
function Ul(n) {
  let t = 0, e = 0, i = 0, r = 1;
  const s = Fl();
  return t = s(" "), e = s(" "), i = s(" "), t -= s(n), t < 0 && (t += 1), e -= s(n), e < 0 && (e += 1), i -= s(n), i < 0 && (i += 1), function() {
    const a = 2091639 * t + r * 23283064365386963e-26;
    return t = e, e = i, i = a - (r = a | 0);
  };
}
function Fl() {
  let n = 4022871197;
  return function(t) {
    t = t.toString();
    for (let e = 0; e < t.length; e++) {
      n += t.charCodeAt(e);
      let i = 0.02519603282416938 * n;
      n = i >>> 0, i -= n, i *= n, n = i >>> 0, i -= n, n += i * 4294967296;
    }
    return (n >>> 0) * 23283064365386963e-26;
  };
}
class ir {
  constructor(t, e, i, r) {
    this.scale = t, this.octaves = e, this.velocityMultiplier = i, this.timeScale = r, this.type = "TurbulenceField", this.generator = new Aa(), this.timeOffset = new B(), this.temp = new B(), this.temp2 = new B(), this.timeOffset.x = Math.random() / this.scale.x * this.timeScale.x, this.timeOffset.y = Math.random() / this.scale.y * this.timeScale.y, this.timeOffset.z = Math.random() / this.scale.z * this.timeScale.z;
  }
  initialize(t) {
  }
  update(t, e) {
    const i = t.position.x / this.scale.x, r = t.position.y / this.scale.y, s = t.position.z / this.scale.z;
    this.temp.set(0, 0, 0);
    let a = 1;
    for (let o = 0; o < this.octaves; o++)
      this.temp2.set(this.generator.noise4D(i * a, r * a, s * a, this.timeOffset.x * a) / a, this.generator.noise4D(i * a, r * a, s * a, this.timeOffset.y * a) / a, this.generator.noise4D(i * a, r * a, s * a, this.timeOffset.z * a) / a), this.temp.add(this.temp2), a *= 2;
    this.temp.multiply(this.velocityMultiplier), t.velocity.addScaledVector(this.temp, e);
  }
  toJSON() {
    return {
      type: this.type,
      scale: [this.scale.x, this.scale.y, this.scale.z],
      octaves: this.octaves,
      velocityMultiplier: [this.velocityMultiplier.x, this.velocityMultiplier.y, this.velocityMultiplier.z],
      timeScale: [this.timeScale.x, this.timeScale.y, this.timeScale.z]
    };
  }
  frameUpdate(t) {
    this.timeOffset.x += t * this.timeScale.x, this.timeOffset.y += t * this.timeScale.y, this.timeOffset.z += t * this.timeScale.z;
  }
  static fromJSON(t) {
    return new ir(new B(t.scale[0], t.scale[1], t.scale[2]), t.octaves, new B(t.velocityMultiplier[0], t.velocityMultiplier[1], t.velocityMultiplier[2]), new B(t.timeScale[0], t.timeScale[1], t.timeScale[2]));
  }
  clone() {
    return new ir(this.scale.clone(), this.octaves, this.velocityMultiplier.clone(), this.timeScale.clone());
  }
  reset() {
  }
}
const Wt = [], bn = new B(), Sn = new G();
class rr {
  constructor(t, e, i = new J(1), r = new J(0)) {
    if (this.frequency = t, this.power = e, this.positionAmount = i, this.rotationAmount = r, this.type = "Noise", this.duration = 0, Wt.length === 0)
      for (let s = 0; s < 100; s++)
        Wt.push(new Aa());
  }
  initialize(t) {
    t.lastPosNoise = new B(), typeof t.rotation == "number" ? t.lastRotNoise = 0 : t.lastRotNoise = new G(), t.generatorIndex = [gr(0, 100), gr(0, 100), gr(0, 100), gr(0, 100)], this.positionAmount.startGen(t.memory), this.rotationAmount.startGen(t.memory), this.frequency.startGen(t.memory), this.power.startGen(t.memory);
  }
  update(t, e) {
    let i = this.frequency.genValue(t.memory, t.age / t.life), r = this.power.genValue(t.memory, t.age / t.life), s = this.positionAmount.genValue(t.memory, t.age / t.life), a = this.rotationAmount.genValue(t.memory, t.age / t.life);
    s > 0 && t.lastPosNoise !== void 0 && (t.position.sub(t.lastPosNoise), bn.set(Wt[t.generatorIndex[0]].noise2D(0, t.age * i) * r * s, Wt[t.generatorIndex[1]].noise2D(0, t.age * i) * r * s, Wt[t.generatorIndex[2]].noise2D(0, t.age * i) * r * s), t.position.add(bn), t.lastPosNoise.copy(bn)), a > 0 && t.lastRotNoise !== void 0 && (typeof t.rotation == "number" ? (t.rotation -= t.lastRotNoise, t.rotation += Wt[t.generatorIndex[3]].noise2D(0, t.age * i) * Math.PI * r * a) : (t.lastRotNoise.invert(), t.rotation.multiply(t.lastRotNoise), Sn.set(Wt[t.generatorIndex[0]].noise2D(0, t.age * i) * r * a, Wt[t.generatorIndex[1]].noise2D(0, t.age * i) * r * a, Wt[t.generatorIndex[2]].noise2D(0, t.age * i) * r * a, Wt[t.generatorIndex[3]].noise2D(0, t.age * i) * r * a).normalize(), t.rotation.multiply(Sn), t.lastRotNoise.copy(Sn)));
  }
  toJSON() {
    return {
      type: this.type,
      frequency: this.frequency.toJSON(),
      power: this.power.toJSON(),
      positionAmount: this.positionAmount.toJSON(),
      rotationAmount: this.rotationAmount.toJSON()
    };
  }
  frameUpdate(t) {
    this.duration += t;
  }
  static fromJSON(t) {
    return new rr(F(t.frequency), F(t.power), F(t.positionAmount), F(t.rotationAmount));
  }
  clone() {
    return new rr(this.frequency.clone(), this.power.clone(), this.positionAmount.clone(), this.rotationAmount.clone());
  }
  reset() {
  }
}
class nr {
  constructor(t, e) {
    this.color = t, this.speedRange = e, this.type = "ColorBySpeed";
  }
  initialize(t) {
    this.color.startGen(t.memory);
  }
  update(t, e) {
    const i = (t.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
    this.color.genColor(t.memory, t.color, i), t.color.x *= t.startColor.x, t.color.y *= t.startColor.y, t.color.z *= t.startColor.z, t.color.w *= t.startColor.w;
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      color: this.color.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(t) {
    return new nr(ys(t.color), Le.fromJSON(t.speedRange));
  }
  clone() {
    return new nr(this.color.clone(), this.speedRange.clone());
  }
  reset() {
  }
}
class sr {
  initialize(t) {
    this.size.startGen(t.memory);
  }
  constructor(t, e) {
    this.size = t, this.speedRange = e, this.type = "SizeBySpeed";
  }
  update(t) {
    const e = (t.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
    this.size instanceof Ve ? this.size.genValue(t.memory, t.size, e).multiply(t.startSize) : t.size.copy(t.startSize).multiplyScalar(this.size.genValue(t.memory, e));
  }
  toJSON() {
    return {
      type: this.type,
      size: this.size.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(t) {
    return new sr(Wr(t.size), Le.fromJSON(t.speedRange));
  }
  frameUpdate(t) {
  }
  clone() {
    return new sr(this.size.clone(), this.speedRange.clone());
  }
  reset() {
  }
}
class or {
  constructor(t, e) {
    this.angularVelocity = t, this.speedRange = e, this.type = "RotationBySpeed", this.tempQuat = new G();
  }
  initialize(t) {
    typeof t.rotation == "number" && this.angularVelocity.startGen(t.memory);
  }
  update(t, e) {
    if (typeof t.rotation == "number") {
      const i = (t.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
      t.rotation += e * this.angularVelocity.genValue(t.memory, i);
    }
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(t) {
    return new or(F(t.angularVelocity), Le.fromJSON(t.speedRange));
  }
  frameUpdate(t) {
  }
  clone() {
    return new or(this.angularVelocity.clone(), this.speedRange.clone());
  }
  reset() {
  }
}
class ar {
  initialize(t) {
    this.speed.startGen(t.memory);
  }
  constructor(t, e) {
    this.speed = t, this.dampen = e, this.type = "LimitSpeedOverLife";
  }
  update(t, e) {
    let i = t.velocity.length(), r = this.speed.genValue(t.memory, t.age / t.life);
    if (i > r) {
      const s = (i - r) / i;
      t.velocity.multiplyScalar(1 - s * this.dampen * e * 20);
    }
  }
  toJSON() {
    return {
      type: this.type,
      speed: this.speed.toJSON(),
      dampen: this.dampen
    };
  }
  static fromJSON(t) {
    return new ar(F(t.speed), t.dampen);
  }
  frameUpdate(t) {
  }
  clone() {
    return new ar(this.speed.clone(), this.dampen);
  }
  reset() {
  }
}
const Yr = {
  ApplyForce: {
    type: "ApplyForce",
    constructor: Ki,
    params: [
      ["direction", ["vec3"]],
      ["magnitude", ["value"]]
    ],
    loadJSON: Ki.fromJSON
  },
  Noise: {
    type: "Noise",
    constructor: rr,
    params: [
      ["frequency", ["value"]],
      ["power", ["value"]],
      ["positionAmount", ["value"]],
      ["rotationAmount", ["value"]]
    ],
    loadJSON: rr.fromJSON
  },
  TurbulenceField: {
    type: "TurbulenceField",
    constructor: ir,
    params: [
      ["scale", ["vec3"]],
      ["octaves", ["number"]],
      ["velocityMultiplier", ["vec3"]],
      ["timeScale", ["vec3"]]
    ],
    loadJSON: ir.fromJSON
  },
  GravityForce: {
    type: "GravityForce",
    constructor: Qi,
    params: [
      ["center", ["vec3"]],
      ["magnitude", ["number"]]
    ],
    loadJSON: Qi.fromJSON
  },
  ColorOverLife: {
    type: "ColorOverLife",
    constructor: Gi,
    params: [["color", ["colorFunc"]]],
    loadJSON: Gi.fromJSON
  },
  RotationOverLife: {
    type: "RotationOverLife",
    constructor: ji,
    params: [["angularVelocity", ["value", "valueFunc"]]],
    loadJSON: ji.fromJSON
  },
  Rotation3DOverLife: {
    type: "Rotation3DOverLife",
    constructor: $i,
    params: [["angularVelocity", ["rotationFunc"]]],
    loadJSON: $i.fromJSON
  },
  SizeOverLife: {
    type: "SizeOverLife",
    constructor: Xi,
    params: [["size", ["value", "valueFunc", "vec3Func"]]],
    loadJSON: Xi.fromJSON
  },
  ColorBySpeed: {
    type: "ColorBySpeed",
    constructor: nr,
    params: [
      ["color", ["colorFunc"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: nr.fromJSON
  },
  RotationBySpeed: {
    type: "RotationBySpeed",
    constructor: or,
    params: [
      ["angularVelocity", ["value", "valueFunc"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: or.fromJSON
  },
  SizeBySpeed: {
    type: "SizeBySpeed",
    constructor: sr,
    params: [
      ["size", ["value", "valueFunc", "vec3Func"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: sr.fromJSON
  },
  SpeedOverLife: {
    type: "SpeedOverLife",
    constructor: Hi,
    params: [["speed", ["value", "valueFunc"]]],
    loadJSON: Hi.fromJSON
  },
  FrameOverLife: {
    type: "FrameOverLife",
    constructor: Wi,
    params: [["frame", ["value", "valueFunc"]]],
    loadJSON: Wi.fromJSON
  },
  ForceOverLife: {
    type: "ForceOverLife",
    constructor: qi,
    params: [
      ["x", ["value", "valueFunc"]],
      ["y", ["value", "valueFunc"]],
      ["z", ["value", "valueFunc"]]
    ],
    loadJSON: qi.fromJSON
  },
  OrbitOverLife: {
    type: "OrbitOverLife",
    constructor: Yi,
    params: [
      ["orbitSpeed", ["value", "valueFunc"]],
      ["axis", ["vec3"]]
    ],
    loadJSON: Yi.fromJSON
  },
  WidthOverLength: {
    type: "WidthOverLength",
    constructor: Zi,
    params: [["width", ["value", "valueFunc"]]],
    loadJSON: Zi.fromJSON
  },
  ChangeEmitDirection: {
    type: "ChangeEmitDirection",
    constructor: tr,
    params: [["angle", ["value"]]],
    loadJSON: tr.fromJSON
  },
  EmitSubParticleSystem: {
    type: "EmitSubParticleSystem",
    constructor: er,
    params: [
      ["particleSystem", ["self"]],
      ["useVelocityAsBasis", ["boolean"]],
      ["subParticleSystem", ["particleSystem"]],
      ["mode", ["number"]],
      ["emitProbability", ["number"]]
    ],
    loadJSON: er.fromJSON
  },
  LimitSpeedOverLife: {
    type: "LimitSpeedOverLife",
    constructor: ar,
    params: [
      ["speed", ["value", "valueFunc"]],
      ["dampen", ["number"]]
    ],
    loadJSON: ar.fromJSON
  }
};
function Dl(n, t) {
  return Yr[n.type] ? Yr[n.type].loadJSON(n, t) : null;
}
const Ll = [];
function Vl(n) {
  if (!Ll.find((e) => e.id === n.id)) {
    for (const e of n.emitterShapes)
      Yn[e.type] || (Yn[e.type] = e);
    for (const e of n.behaviors)
      Yr[e.type] || (Yr[e.type] = e);
  }
}
var Jl = `
#ifdef SOFT_PARTICLES

    /* #ifdef LOGDEPTH
    float distSample = linearize_depth_log(sampleDepth, near, far);
    #else
    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);
    #endif */

    vec2 p2 = projPosition.xy / projPosition.w;
    
    p2 = 0.5 * p2 + 0.5;

    float readDepth = texture2D(depthTexture, p2.xy).r;
    float viewDepth = linearize_depth(readDepth);

    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));
    
    gl_FragColor *= softParticlesFade;

    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);
#endif
`, Gl = `
#ifdef SOFT_PARTICLES

    uniform sampler2D depthTexture;
    uniform vec4 projParams;
    uniform vec2 softParams;

    varying vec4 projPosition;
    varying float linearDepth;

    #define SOFT_NEAR_FADE softParams.x
    #define SOFT_INV_FADE_DISTANCE softParams.y

    #define zNear projParams.x
    #define zFar projParams.y

    float linearize_depth(float d)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }

#endif
`, jl = `
#ifdef SOFT_PARTICLES
    varying vec4 projPosition;
    varying float linearDepth;
#endif
`, $l = `
#ifdef SOFT_PARTICLES
    projPosition = gl_Position;
    linearDepth = -mvPosition.z;
#endif
`, ql = `
#ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv);
    #ifdef TILE_BLEND
        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );
    #endif
    diffuseColor *= texelColor;
#endif
`, Xl = `
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;
#ifdef TILE_BLEND
    varying vec2 vUvNext;
    varying float vUvBlend;
#endif

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#ifdef TILE_BLEND
    varying vec2 vMapUvNext;
#endif

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`, Hl = `
#ifdef UV_TILE
    attribute float uvTile;
    uniform vec2 tileCount;
    
    mat3 makeTileTransform(float uvTile) {
        float col = mod(uvTile, tileCount.x);
        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);
        
        return mat3(
          1.0 / tileCount.x, 0.0, 0.0,
          0.0, 1.0 / tileCount.y, 0.0, 
          col / tileCount.x, row / tileCount.y, 1.0);
    }
#else
    mat3 makeTileTransform(float uvTile) {
        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    }
#endif

#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;
#ifdef TILE_BLEND
    varying vec2 vUvNext;
    varying float vUvBlend;
#endif

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#ifdef TILE_BLEND
    varying vec2 vMapUvNext;
#endif

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`, Wl = `
#ifdef UV_TILE
    mat3 tileTransform = makeTileTransform(floor(uvTile));
    #ifdef TILE_BLEND
        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));
        vUvBlend = fract(uvTile);
    #endif
#else
    mat3 tileTransform = makeTileTransform(0.0);
#endif

#if defined( USE_UV ) || defined( USE_ANISOTROPY )

vUv = (tileTransform *vec3( uv, 1 )).xy;
#if defined( TILE_BLEND ) && defined( UV_TILE )
    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;
#endif

#endif
#ifdef USE_MAP

vMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;
#if defined( TILE_BLEND ) && defined( UV_TILE )
    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;
#endif

#endif
#ifdef USE_ALPHAMAP

vAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;
    
#endif
#ifdef USE_LIGHTMAP

vLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_AOMAP

vAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_BUMPMAP

vBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_NORMALMAP

vNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_DISPLACEMENTMAP

vDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_EMISSIVEMAP

vEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_METALNESSMAP

vMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_ROUGHNESSMAP

vRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_ANISOTROPYMAP

vAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOATMAP

vClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

vClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

vClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_IRIDESCENCEMAP

vIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

vIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SHEEN_COLORMAP

vSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

vSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULARMAP

vSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULAR_COLORMAP

vSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

vSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_TRANSMISSIONMAP

vTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_THICKNESSMAP

vThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;

#endif

`;
const _e = Ga;
function Yl() {
  _e.tile_pars_vertex = Hl, _e.tile_vertex = Wl, _e.tile_pars_fragment = Xl, _e.tile_fragment = ql, _e.soft_pars_vertex = jl, _e.soft_vertex = $l, _e.soft_pars_fragment = Gl, _e.soft_fragment = Jl;
}
class Zl extends Oo {
  constructor(t) {
    super(), this.type = "ParticleEmitter", this.system = t;
  }
  clone() {
    const t = this.system.clone();
    return t.emitter.copy(this, !0), t.emitter;
  }
  dispose() {
  }
  extractFromCache(t) {
    const e = [];
    for (const i in t) {
      const r = t[i];
      delete r.metadata, e.push(r);
    }
    return e;
  }
  toJSON(t, e = {}) {
    const i = this.children;
    this.children = this.children.filter((s) => s.type !== "ParticleSystemPreview");
    const r = super.toJSON(t);
    return this.children = i, this.system !== null && (r.object.ps = this.system.toJSON(t, e)), r;
  }
}
var A;
(function(n) {
  n[n.BillBoard = 0] = "BillBoard", n[n.StretchedBillBoard = 1] = "StretchedBillBoard", n[n.Mesh = 2] = "Mesh", n[n.Trail = 3] = "Trail", n[n.HorizontalBillBoard = 4] = "HorizontalBillBoard", n[n.VerticalBillBoard = 5] = "VerticalBillBoard";
})(A || (A = {}));
class za extends hs {
  constructor(t) {
    super(), this.type = "VFXBatch", this.maxParticles = 1e3, this.systems = /* @__PURE__ */ new Set();
    const e = new Ur();
    e.mask = t.layers.mask;
    const i = t.material.clone();
    i.defines = {}, Object.assign(i.defines, t.material.defines), this.settings = {
      instancingGeometry: t.instancingGeometry,
      renderMode: t.renderMode,
      renderOrder: t.renderOrder,
      material: i,
      uTileCount: t.uTileCount,
      vTileCount: t.vTileCount,
      blendTiles: t.blendTiles,
      softParticles: t.softParticles,
      softNearFade: t.softNearFade,
      softFarFade: t.softFarFade,
      layers: e
    }, this.frustumCulled = !1, this.renderOrder = this.settings.renderOrder;
  }
  addSystem(t) {
    this.systems.add(t);
  }
  removeSystem(t) {
    this.systems.delete(t);
  }
  applyDepthTexture(t) {
    const e = this.material.uniforms.depthTexture;
    e && e.value !== t && (e.value = t, this.material.needsUpdate = !0);
  }
}
const Kl = new B(0, 0, 1), Tn = new G(), Ql = new B(), th = new B();
new B();
const ho = 60, eh = new zo(1, 1, 1, 1);
class Kn {
  set time(t) {
    this.emissionState.time = t;
  }
  get time() {
    return this.emissionState.time;
  }
  get layers() {
    return this.rendererSettings.layers;
  }
  get texture() {
    return this.rendererSettings.material.map;
  }
  set texture(t) {
    this.rendererSettings.material.map = t, this.neededToUpdateRender = !0;
  }
  get material() {
    return this.rendererSettings.material;
  }
  set material(t) {
    this.rendererSettings.material = t, this.neededToUpdateRender = !0;
  }
  get uTileCount() {
    return this.rendererSettings.uTileCount;
  }
  set uTileCount(t) {
    this.rendererSettings.uTileCount = t, this.neededToUpdateRender = !0;
  }
  get vTileCount() {
    return this.rendererSettings.vTileCount;
  }
  set vTileCount(t) {
    this.rendererSettings.vTileCount = t, this.neededToUpdateRender = !0;
  }
  get blendTiles() {
    return this.rendererSettings.blendTiles;
  }
  set blendTiles(t) {
    this.rendererSettings.blendTiles = t, this.neededToUpdateRender = !0;
  }
  get softParticles() {
    return this.rendererSettings.softParticles;
  }
  set softParticles(t) {
    this.rendererSettings.softParticles = t, this.neededToUpdateRender = !0;
  }
  get softNearFade() {
    return this.rendererSettings.softNearFade;
  }
  set softNearFade(t) {
    this.rendererSettings.softNearFade = t, this.neededToUpdateRender = !0;
  }
  get softFarFade() {
    return this.rendererSettings.softFarFade;
  }
  set softFarFade(t) {
    this.rendererSettings.softFarFade = t, this.neededToUpdateRender = !0;
  }
  get instancingGeometry() {
    return this.rendererSettings.instancingGeometry;
  }
  set instancingGeometry(t) {
    this.restart(), this.particles.length = 0, this.rendererSettings.instancingGeometry = t, this.neededToUpdateRender = !0;
  }
  get renderMode() {
    return this.rendererSettings.renderMode;
  }
  set renderMode(t) {
    if ((this.rendererSettings.renderMode != A.Trail && t === A.Trail || this.rendererSettings.renderMode == A.Trail && t !== A.Trail) && (this.restart(), this.particles.length = 0), this.rendererSettings.renderMode !== t)
      switch (t) {
        case A.Trail:
          this.rendererEmitterSettings = {
            startLength: new J(30),
            followLocalOrigin: !1
          };
          break;
        case A.Mesh:
          this.rendererEmitterSettings = {
            geometry: new zo(1, 1)
          }, this.startRotation = new Ni(new B(0, 1, 0), new J(0));
          break;
        case A.StretchedBillBoard:
          this.rendererEmitterSettings = { speedFactor: 0, lengthFactor: 2 }, this.rendererSettings.renderMode === A.Mesh && (this.startRotation = new J(0));
          break;
        case A.BillBoard:
        case A.VerticalBillBoard:
        case A.HorizontalBillBoard:
          this.rendererEmitterSettings = {}, this.rendererSettings.renderMode === A.Mesh && (this.startRotation = new J(0));
          break;
      }
    this.rendererSettings.renderMode = t, this.neededToUpdateRender = !0;
  }
  get renderOrder() {
    return this.rendererSettings.renderOrder;
  }
  set renderOrder(t) {
    this.rendererSettings.renderOrder = t, this.neededToUpdateRender = !0;
  }
  get blending() {
    return this.rendererSettings.material.blending;
  }
  set blending(t) {
    this.rendererSettings.material.blending = t, this.neededToUpdateRender = !0;
  }
  constructor(t) {
    var e, i, r, s, a, o, c, l, h, u, f, d, y, _, p, m, v, g, b, x, S, T, P, M, C, E;
    if (this.temp = new B(), this.travelDistance = 0, this.normalMatrix = new Kt(), this.memory = [], this.listeners = {}, this.firstTimeUpdate = !0, this.autoDestroy = t.autoDestroy === void 0 ? !1 : t.autoDestroy, this.duration = (e = t.duration) !== null && e !== void 0 ? e : 1, this.looping = t.looping === void 0 ? !0 : t.looping, this.prewarm = t.prewarm === void 0 ? !1 : t.prewarm, this.startLife = (i = t.startLife) !== null && i !== void 0 ? i : new J(5), this.startSpeed = (r = t.startSpeed) !== null && r !== void 0 ? r : new J(0), this.startRotation = (s = t.startRotation) !== null && s !== void 0 ? s : new J(0), this.startSize = (a = t.startSize) !== null && a !== void 0 ? a : new J(1), this.startColor = (o = t.startColor) !== null && o !== void 0 ? o : new ei(new wt(1, 1, 1, 1)), this.emissionOverTime = (c = t.emissionOverTime) !== null && c !== void 0 ? c : new J(10), this.emissionOverDistance = (l = t.emissionOverDistance) !== null && l !== void 0 ? l : new J(0), this.emissionBursts = (h = t.emissionBursts) !== null && h !== void 0 ? h : [], this.onlyUsedByOther = (u = t.onlyUsedByOther) !== null && u !== void 0 ? u : !1, this.emitterShape = (f = t.shape) !== null && f !== void 0 ? f : new ii(), this.behaviors = (d = t.behaviors) !== null && d !== void 0 ? d : new Array(), this.worldSpace = (y = t.worldSpace) !== null && y !== void 0 ? y : !1, this.rendererEmitterSettings = (_ = t.rendererEmitterSettings) !== null && _ !== void 0 ? _ : {}, t.renderMode === A.StretchedBillBoard) {
      const w = this.rendererEmitterSettings;
      t.speedFactor !== void 0 && (w.speedFactor = t.speedFactor), w.speedFactor = (p = w.speedFactor) !== null && p !== void 0 ? p : 0, w.lengthFactor = (m = w.lengthFactor) !== null && m !== void 0 ? m : 0;
    }
    this.rendererSettings = {
      instancingGeometry: (v = t.instancingGeometry) !== null && v !== void 0 ? v : eh,
      renderMode: (g = t.renderMode) !== null && g !== void 0 ? g : A.BillBoard,
      renderOrder: (b = t.renderOrder) !== null && b !== void 0 ? b : 0,
      material: t.material,
      uTileCount: (x = t.uTileCount) !== null && x !== void 0 ? x : 1,
      vTileCount: (S = t.vTileCount) !== null && S !== void 0 ? S : 1,
      blendTiles: (T = t.blendTiles) !== null && T !== void 0 ? T : !1,
      softParticles: (P = t.softParticles) !== null && P !== void 0 ? P : !1,
      softNearFade: (M = t.softNearFade) !== null && M !== void 0 ? M : 0,
      softFarFade: (C = t.softFarFade) !== null && C !== void 0 ? C : 0,
      layers: (E = t.layers) !== null && E !== void 0 ? E : new Ur()
    }, this.neededToUpdateRender = !0, this.particles = new Array(), this.startTileIndex = t.startTileIndex || new J(0), this.emitter = new Zl(this), this.paused = !1, this.particleNum = 0, this.emissionState = {
      isBursting: !1,
      burstParticleIndex: 0,
      burstParticleCount: 0,
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0,
      travelDistance: 0
    }, this.emissionBursts.forEach((w) => w.count.startGen(this.memory)), this.emissionOverDistance.startGen(this.memory), this.emitEnded = !1, this.markForDestroy = !1, this.prewarmed = !1;
  }
  pause() {
    this.paused = !0;
  }
  play() {
    this.paused = !1;
  }
  stop() {
    this.restart(), this.pause();
  }
  spawn(t, e, i) {
    Tn.setFromRotationMatrix(i);
    const r = Ql, s = Tn, a = th;
    i.decompose(r, s, a);
    for (let o = 0; o < t; o++) {
      for (e.burstParticleIndex = o, this.particleNum++; this.particles.length < this.particleNum; )
        this.rendererSettings.renderMode === A.Trail ? this.particles.push(new Zn()) : this.particles.push(new Al());
      const c = this.particles[this.particleNum - 1];
      if (c.reset(), c.speedModifier = 1, this.startColor.startGen(c.memory), this.startColor.genColor(c.memory, c.startColor, this.emissionState.time), c.color.copy(c.startColor), this.startSpeed.startGen(c.memory), c.startSpeed = this.startSpeed.genValue(c.memory, e.time / this.duration), this.startLife.startGen(c.memory), c.life = this.startLife.genValue(c.memory, e.time / this.duration), c.age = 0, this.startSize.startGen(c.memory), this.startSize.type === "vec3function")
        this.startSize.genValue(c.memory, c.startSize, e.time / this.duration);
      else {
        const l = this.startSize.genValue(c.memory, e.time / this.duration);
        c.startSize.set(l, l, l);
      }
      if (this.startTileIndex.startGen(c.memory), c.uvTile = this.startTileIndex.genValue(c.memory), c.size.copy(c.startSize), this.rendererSettings.renderMode === A.Mesh || this.rendererSettings.renderMode === A.BillBoard || this.rendererSettings.renderMode === A.VerticalBillBoard || this.rendererSettings.renderMode === A.HorizontalBillBoard || this.rendererSettings.renderMode === A.StretchedBillBoard) {
        const l = c;
        this.startRotation.startGen(c.memory), this.rendererSettings.renderMode === A.Mesh ? (l.rotation instanceof G || (l.rotation = new G()), this.startRotation.type === "rotation" ? this.startRotation.genValue(c.memory, l.rotation, 1, e.time / this.duration) : l.rotation.setFromAxisAngle(Kl, this.startRotation.genValue(l.memory, e.time / this.duration))) : this.startRotation.type === "rotation" ? l.rotation = 0 : l.rotation = this.startRotation.genValue(l.memory, e.time / this.duration);
      } else if (this.rendererSettings.renderMode === A.Trail) {
        const l = c;
        this.rendererEmitterSettings.startLength.startGen(l.memory), l.length = this.rendererEmitterSettings.startLength.genValue(l.memory, e.time / this.duration);
      }
      if (this.emitterShape.initialize(c, e), this.rendererSettings.renderMode === A.Trail && this.rendererEmitterSettings.followLocalOrigin) {
        const l = c;
        l.localPosition = new B().copy(l.position);
      }
      this.worldSpace ? (c.position.applyMatrix4(i), c.startSize.multiply(a).abs(), c.size.copy(c.startSize), c.velocity.multiply(a).applyMatrix3(this.normalMatrix), c.rotation && c.rotation instanceof G && c.rotation.multiplyQuaternions(Tn, c.rotation)) : this.onlyUsedByOther && (c.parentMatrix = i);
      for (let l = 0; l < this.behaviors.length; l++)
        this.behaviors[l].initialize(c, this);
    }
  }
  endEmit() {
    this.emitEnded = !0, this.autoDestroy && (this.markForDestroy = !0), this.fire({ type: "emitEnd", particleSystem: this });
  }
  dispose() {
    this._renderer && this._renderer.deleteSystem(this), this.emitter.dispose(), this.emitter.parent && this.emitter.parent.remove(this.emitter), this.fire({ type: "destroy", particleSystem: this });
  }
  restart() {
    this.memory.length = 0, this.paused = !1, this.particleNum = 0, this.emissionState.isBursting = !1, this.emissionState.burstIndex = 0, this.emissionState.burstWaveIndex = 0, this.emissionState.time = 0, this.emissionState.waitEmiting = 0, this.behaviors.forEach((t) => {
      t.reset();
    }), this.emitEnded = !1, this.markForDestroy = !1, this.prewarmed = !1, this.emissionBursts.forEach((t) => t.count.startGen(this.memory)), this.emissionOverDistance.startGen(this.memory);
  }
  update(t) {
    if (this.paused)
      return;
    let e = this.emitter;
    for (; e.parent; )
      e = e.parent;
    if (e.type !== "Scene") {
      this.dispose();
      return;
    }
    if (this.firstTimeUpdate && (this.firstTimeUpdate = !1, this.emitter.updateWorldMatrix(!0, !1)), this.emitEnded && this.particleNum === 0) {
      this.markForDestroy && this.emitter.parent && this.dispose();
      return;
    }
    if (this.looping && this.prewarm && !this.prewarmed) {
      this.prewarmed = !0;
      for (let i = 0; i < this.duration * ho; i++)
        this.update(1 / ho);
    }
    t > 0.1 && (t = 0.1), this.neededToUpdateRender && (this._renderer && this._renderer.updateSystem(this), this.neededToUpdateRender = !1), this.onlyUsedByOther || this.emit(t, this.emissionState, this.emitter.matrixWorld), this.emitterShape.update(this, t);
    for (let i = 0; i < this.behaviors.length; i++) {
      this.behaviors[i].frameUpdate(t);
      for (let r = 0; r < this.particleNum; r++)
        this.particles[r].died || this.behaviors[i].update(this.particles[r], t);
    }
    for (let i = 0; i < this.particleNum; i++)
      this.rendererEmitterSettings.followLocalOrigin && this.particles[i].localPosition ? (this.particles[i].position.copy(this.particles[i].localPosition), this.particles[i].parentMatrix ? this.particles[i].position.applyMatrix4(this.particles[i].parentMatrix) : this.particles[i].position.applyMatrix4(this.emitter.matrixWorld)) : this.particles[i].position.addScaledVector(this.particles[i].velocity, t * this.particles[i].speedModifier), this.particles[i].age += t;
    if (this.rendererSettings.renderMode === A.Trail)
      for (let i = 0; i < this.particleNum; i++)
        this.particles[i].update();
    for (let i = 0; i < this.particleNum; i++) {
      const r = this.particles[i];
      r.died && (!(r instanceof Zn) || r.previous.length === 0) && (this.particles[i] = this.particles[this.particleNum - 1], this.particles[this.particleNum - 1] = r, this.particleNum--, i--, this.fire({ type: "particleDied", particleSystem: this, particle: r }));
    }
  }
  emit(t, e, i) {
    e.time > this.duration && (this.looping ? (e.time -= this.duration, e.burstIndex = 0, this.behaviors.forEach((s) => {
      s.reset();
    })) : !this.emitEnded && !this.onlyUsedByOther && this.endEmit()), this.normalMatrix.getNormalMatrix(i);
    const r = Math.ceil(e.waitEmiting);
    for (this.spawn(r, e, i), e.waitEmiting -= r; e.burstIndex < this.emissionBursts.length && this.emissionBursts[e.burstIndex].time <= e.time; ) {
      if (Math.random() < this.emissionBursts[e.burstIndex].probability) {
        const s = this.emissionBursts[e.burstIndex].count.genValue(this.memory, this.time);
        e.isBursting = !0, e.burstParticleCount = s, this.spawn(s, e, i), e.isBursting = !1;
      }
      e.burstIndex++;
    }
    if (!this.emitEnded && (e.waitEmiting += t * this.emissionOverTime.genValue(this.memory, e.time / this.duration), e.previousWorldPos != null)) {
      this.temp.set(i.elements[12], i.elements[13], i.elements[14]), e.travelDistance += e.previousWorldPos.distanceTo(this.temp);
      const s = this.emissionOverDistance.genValue(this.memory, e.time / this.duration);
      if (e.travelDistance * s > 0) {
        const a = Math.floor(e.travelDistance * s);
        e.travelDistance -= a / s, e.waitEmiting += a;
      }
    }
    e.previousWorldPos === void 0 && (e.previousWorldPos = new B()), e.previousWorldPos.set(i.elements[12], i.elements[13], i.elements[14]), e.time += t;
  }
  toJSON(t, e = {}) {
    var i;
    if ((t === void 0 || typeof t == "string") && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }), t.materials[this.rendererSettings.material.uuid] = this.rendererSettings.material.toJSON(t), e.useUrlForImage && ((i = this.texture) === null || i === void 0 ? void 0 : i.source) !== void 0) {
      const o = this.texture.source;
      t.images[o.uuid] = {
        uuid: o.uuid,
        url: this.texture.image.url
      };
    }
    let s;
    this.renderMode === A.Trail ? s = {
      startLength: this.rendererEmitterSettings.startLength.toJSON(),
      followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin
    } : this.renderMode === A.Mesh ? s = {} : this.renderMode === A.StretchedBillBoard ? s = {
      speedFactor: this.rendererEmitterSettings.speedFactor,
      lengthFactor: this.rendererEmitterSettings.lengthFactor
    } : s = {};
    const a = this.rendererSettings.instancingGeometry;
    return t.geometries && !t.geometries[a.uuid] && (t.geometries[a.uuid] = a.toJSON()), {
      version: "3.0",
      autoDestroy: this.autoDestroy,
      looping: this.looping,
      prewarm: this.prewarm,
      duration: this.duration,
      shape: this.emitterShape.toJSON(),
      startLife: this.startLife.toJSON(),
      startSpeed: this.startSpeed.toJSON(),
      startRotation: this.startRotation.toJSON(),
      startSize: this.startSize.toJSON(),
      startColor: this.startColor.toJSON(),
      emissionOverTime: this.emissionOverTime.toJSON(),
      emissionOverDistance: this.emissionOverDistance.toJSON(),
      emissionBursts: this.emissionBursts.map((o) => ({
        time: o.time,
        count: o.count.toJSON(),
        probability: o.probability,
        interval: o.interval,
        cycle: o.cycle
      })),
      onlyUsedByOther: this.onlyUsedByOther,
      instancingGeometry: this.rendererSettings.instancingGeometry.uuid,
      renderOrder: this.renderOrder,
      renderMode: this.renderMode,
      rendererEmitterSettings: s,
      material: this.rendererSettings.material.uuid,
      layers: this.layers.mask,
      startTileIndex: this.startTileIndex.toJSON(),
      uTileCount: this.uTileCount,
      vTileCount: this.vTileCount,
      blendTiles: this.blendTiles,
      softParticles: this.rendererSettings.softParticles,
      softFarFade: this.rendererSettings.softFarFade,
      softNearFade: this.rendererSettings.softNearFade,
      behaviors: this.behaviors.map((o) => o.toJSON()),
      worldSpace: this.worldSpace
    };
  }
  static fromJSON(t, e, i) {
    var r, s;
    const a = kl(t.shape, e);
    let o;
    if (t.renderMode === A.Trail) {
      const h = t.rendererEmitterSettings;
      o = {
        startLength: h.startLength != null ? F(h.startLength) : new J(30),
        followLocalOrigin: h.followLocalOrigin
      };
    } else t.renderMode === A.Mesh ? o = {} : t.renderMode === A.StretchedBillBoard ? (o = t.rendererEmitterSettings, t.speedFactor != null && (o.speedFactor = t.speedFactor)) : o = {};
    const c = new Ur();
    t.layers && (c.mask = t.layers);
    const l = new Kn({
      autoDestroy: t.autoDestroy,
      looping: t.looping,
      prewarm: t.prewarm,
      duration: t.duration,
      shape: a,
      startLife: F(t.startLife),
      startSpeed: F(t.startSpeed),
      startRotation: Wr(t.startRotation),
      startSize: Wr(t.startSize),
      startColor: ys(t.startColor),
      emissionOverTime: F(t.emissionOverTime),
      emissionOverDistance: F(t.emissionOverDistance),
      emissionBursts: (r = t.emissionBursts) === null || r === void 0 ? void 0 : r.map((h) => {
        var u, f, d;
        return {
          time: h.time,
          count: typeof h.count == "number" ? new J(h.count) : F(h.count),
          probability: (u = h.probability) !== null && u !== void 0 ? u : 1,
          interval: (f = h.interval) !== null && f !== void 0 ? f : 0.1,
          cycle: (d = h.cycle) !== null && d !== void 0 ? d : 1
        };
      }),
      onlyUsedByOther: t.onlyUsedByOther,
      instancingGeometry: e.geometries[t.instancingGeometry],
      renderMode: t.renderMode,
      rendererEmitterSettings: o,
      renderOrder: t.renderOrder,
      layers: c,
      material: t.material ? e.materials[t.material] : t.texture ? new Ts({
        map: e.textures[t.texture],
        transparent: (s = t.transparent) !== null && s !== void 0 ? s : !0,
        blending: t.blending,
        side: Fn
      }) : new Ts({
        color: 16777215,
        transparent: !0,
        blending: Bo,
        side: Fn
      }),
      startTileIndex: typeof t.startTileIndex == "number" ? new J(t.startTileIndex) : F(t.startTileIndex),
      uTileCount: t.uTileCount,
      vTileCount: t.vTileCount,
      blendTiles: t.blendTiles,
      softParticles: t.softParticles,
      softFarFade: t.softFarFade,
      softNearFade: t.softNearFade,
      behaviors: [],
      worldSpace: t.worldSpace
    });
    return l.behaviors = t.behaviors.map((h) => {
      const u = Dl(h, l);
      return u.type === "EmitSubParticleSystem" && (i[h.subParticleSystem] = u), u;
    }), l;
  }
  addBehavior(t) {
    this.behaviors.push(t);
  }
  getRendererSettings() {
    return this.rendererSettings;
  }
  addEventListener(t, e) {
    this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e);
  }
  removeAllEventListeners(t) {
    this.listeners[t] && (this.listeners[t] = []);
  }
  removeEventListener(t, e) {
    if (this.listeners[t]) {
      const i = this.listeners[t].indexOf(e);
      i !== -1 && this.listeners[t].splice(i, 1);
    }
  }
  fire(t) {
    this.listeners[t.type] && this.listeners[t.type].forEach((e) => e(t));
  }
  clone() {
    const t = [];
    for (const s of this.emissionBursts) {
      const a = {};
      Object.assign(a, s), t.push(a);
    }
    const e = [];
    for (const s of this.behaviors)
      e.push(s.clone());
    let i;
    this.renderMode === A.Trail ? i = {
      startLength: this.rendererEmitterSettings.startLength.clone(),
      followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin
    } : this.renderMode === A.StretchedBillBoard ? i = {
      lengthFactor: this.rendererEmitterSettings.lengthFactor,
      speedFactor: this.rendererEmitterSettings.speedFactor
    } : i = {};
    const r = new Ur();
    return r.mask = this.layers.mask, new Kn({
      autoDestroy: this.autoDestroy,
      looping: this.looping,
      duration: this.duration,
      shape: this.emitterShape.clone(),
      startLife: this.startLife.clone(),
      startSpeed: this.startSpeed.clone(),
      startRotation: this.startRotation.clone(),
      startSize: this.startSize.clone(),
      startColor: this.startColor.clone(),
      emissionOverTime: this.emissionOverTime.clone(),
      emissionOverDistance: this.emissionOverDistance.clone(),
      emissionBursts: t,
      onlyUsedByOther: this.onlyUsedByOther,
      instancingGeometry: this.rendererSettings.instancingGeometry,
      renderMode: this.renderMode,
      renderOrder: this.renderOrder,
      rendererEmitterSettings: i,
      material: this.rendererSettings.material,
      startTileIndex: this.startTileIndex,
      uTileCount: this.uTileCount,
      vTileCount: this.vTileCount,
      blendTiles: this.blendTiles,
      softParticles: this.softParticles,
      softFarFade: this.softFarFade,
      softNearFade: this.softNearFade,
      behaviors: e,
      worldSpace: this.worldSpace,
      layers: r
    });
  }
}
var Cn = `

#include <common>
#include <color_pars_fragment>
#include <map_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
#include <alphatest_pars_fragment>

#include <tile_pars_fragment>
#include <soft_pars_fragment>

void main() {

    #include <clipping_planes_fragment>
    
    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vColor;
    
    #include <logdepthbuf_fragment>
    
    #include <tile_fragment>
    #include <alphatest_fragment>

    outgoingLight = diffuseColor.rgb;
    
    #ifdef USE_COLOR_AS_ALPHA
    gl_FragColor = vec4( outgoingLight, diffuseColor.r );
    #else
    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #endif
    
    #include <soft_fragment>
    #include <tonemapping_fragment>
}
`, gs = `
#define STANDARD

#ifdef PHYSICAL
#define IOR
#define USE_SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
uniform float ior;
#endif

#ifdef USE_SPECULAR
uniform float specularIntensity;
uniform vec3 specularColor;

#ifdef USE_SPECULAR_COLORMAP
uniform sampler2D specularColorMap;
#endif

#ifdef USE_SPECULAR_INTENSITYMAP
uniform sampler2D specularIntensityMap;
#endif
#endif

#ifdef USE_CLEARCOAT
uniform float clearcoat;
uniform float clearcoatRoughness;
#endif

#ifdef USE_DISPERSION
uniform float dispersion;
#endif

#ifdef USE_IRIDESCENCE
uniform float iridescence;
uniform float iridescenceIOR;
uniform float iridescenceThicknessMinimum;
uniform float iridescenceThicknessMaximum;
#endif

#ifdef USE_SHEEN
uniform vec3 sheenColor;
uniform float sheenRoughness;

#ifdef USE_SHEEN_COLORMAP
uniform sampler2D sheenColorMap;
#endif

#ifdef USE_SHEEN_ROUGHNESSMAP
uniform sampler2D sheenRoughnessMap;
#endif
#endif

#ifdef USE_ANISOTROPY
uniform vec2 anisotropyVector;

#ifdef USE_ANISOTROPYMAP
uniform sampler2D anisotropyMap;
#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

vec4 diffuseColor = vec4( diffuse, opacity );
#include <clipping_planes_fragment>

ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
vec3 totalEmissiveRadiance = emissive;

#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <alphahash_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>

// accumulation
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>

// modulation
#include <aomap_fragment>

vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

#include <transmission_fragment>

vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

#ifdef USE_SHEEN

// Sheen energy compensation approximation calculation can be found at the end of
// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;

#endif

#ifdef USE_CLEARCOAT

float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );

vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;

#endif

#include <opaque_fragment>
#include <tonemapping_fragment>
#include <colorspace_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`, ih = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute float rotation;
attribute vec3 size;

void main() {
	
    vec2 alignedPosition = position.xy * size.xy;
    
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
#ifdef HORIZONTAL
    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );
    mvPosition.x += rotatedPosition.x;
    mvPosition.z -= rotatedPosition.y;
    mvPosition = viewMatrix * mvPosition;
#elif defined(VERTICAL)
    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );
    mvPosition.y += rotatedPosition.y;
    mvPosition = viewMatrix * mvPosition;
    mvPosition.x += rotatedPosition.x;
#else
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    mvPosition.xy += rotatedPosition;
#endif

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>

	#include <clipping_planes_vertex>

	#include <tile_vertex>
	#include <soft_vertex>
}
`, rh = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute vec4 rotation;
attribute vec3 size;
// attribute vec4 color;

void main() {

    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;
    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;
    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;
    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;
    float sx = size.x, sy = size.y, sz = size.z;
    
    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column
                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column
                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column
                      offset.x, offset.y, offset.z, 1.0);
    
    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
    #include <tile_vertex>
    #include <soft_vertex>
}
`, vs = `
#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>

attribute vec3 offset;
attribute vec4 rotation;
attribute vec3 size;
#include <tile_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <tile_vertex>
    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;
    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;
    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;
    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;
    float sx = size.x, sy = size.y, sz = size.z;

    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column
                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column
                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column
                      offset.x, offset.y, offset.z, 1.0);

#include <color_vertex>
#include <morphinstance_vertex>
#include <morphcolor_vertex>
#include <batching_vertex>

#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>

	// replace defaultnormal_vertex
	vec3 transformedNormal = objectNormal;
    mat3 m = mat3( particleMatrix );
    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
    transformedNormal = m * transformedNormal;
    transformedNormal = normalMatrix * transformedNormal;
    #ifdef FLIP_SIDED
        transformedNormal = - transformedNormal;
    #endif
    #ifdef USE_TANGENT
        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
        #ifdef FLIP_SIDED
        transformedTangent = - transformedTangent;
        #endif
    #endif

	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>

	// replace include <project_vertex>
  vec4 mvPosition = vec4( transformed, 1.0 );
  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);
	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	
	vViewPosition = - mvPosition.xyz;
	
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
    vWorldPosition = worldPosition.xyz;
#endif
}
`, nh = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute float rotation;
attribute vec3 size;
attribute vec4 velocity;

uniform float speedFactor;

void main() {
    float lengthFactor = velocity.w;
    float avgSize = (size.x + size.y) * 0.5;
#ifdef USE_SKEW
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    vec3 viewVelocity = normalMatrix * velocity.xyz;

    vec3 scaledPos = vec3(position.xy * size.xy, position.z);
    float vlength = length(viewVelocity);
    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;
    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);
#else
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    vec3 viewVelocity = normalMatrix * velocity.xyz;
    float vlength = length(viewVelocity); 
    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation
    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation
#endif
	vColor = color;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <tile_vertex>
	#include <soft_vertex>
}
`;
function Qn(n) {
  return n === 0 ? "uv" : `uv${n}`;
}
class sh extends $a {
  constructor(t) {
    super(t);
  }
  onBeforeCompile(t, e) {
    super.onBeforeCompile(t, e), t.vertexShader = vs, t.fragmentShader = gs;
  }
}
class oh extends qa {
  constructor(t) {
    super(t);
  }
  onBeforeCompile(t, e) {
    super.onBeforeCompile(t, e), t.vertexShader = vs, t.fragmentShader = gs;
  }
}
class ah extends za {
  constructor(t) {
    super(t), this.vector_ = new B(), this.vector2_ = new B(), this.vector3_ = new B(), this.quaternion_ = new G(), this.quaternion2_ = new G(), this.quaternion3_ = new G(), this.rotationMat_ = new Kt(), this.rotationMat2_ = new Kt(), this.maxParticles = 1e3, this.setupBuffers(), this.rebuildMaterial();
  }
  buildExpandableBuffers() {
    this.offsetBuffer = new we(new Float32Array(this.maxParticles * 3), 3), this.offsetBuffer.setUsage(gt), this.geometry.setAttribute("offset", this.offsetBuffer), this.colorBuffer = new we(new Float32Array(this.maxParticles * 4), 4), this.colorBuffer.setUsage(gt), this.geometry.setAttribute("color", this.colorBuffer), this.settings.renderMode === A.Mesh ? (this.rotationBuffer = new we(new Float32Array(this.maxParticles * 4), 4), this.rotationBuffer.setUsage(gt), this.geometry.setAttribute("rotation", this.rotationBuffer)) : (this.settings.renderMode === A.BillBoard || this.settings.renderMode === A.HorizontalBillBoard || this.settings.renderMode === A.VerticalBillBoard || this.settings.renderMode === A.StretchedBillBoard) && (this.rotationBuffer = new we(new Float32Array(this.maxParticles), 1), this.rotationBuffer.setUsage(gt), this.geometry.setAttribute("rotation", this.rotationBuffer)), this.sizeBuffer = new we(new Float32Array(this.maxParticles * 3), 3), this.sizeBuffer.setUsage(gt), this.geometry.setAttribute("size", this.sizeBuffer), this.uvTileBuffer = new we(new Float32Array(this.maxParticles), 1), this.uvTileBuffer.setUsage(gt), this.geometry.setAttribute("uvTile", this.uvTileBuffer), this.settings.renderMode === A.StretchedBillBoard && (this.velocityBuffer = new we(new Float32Array(this.maxParticles * 4), 4), this.velocityBuffer.setUsage(gt), this.geometry.setAttribute("velocity", this.velocityBuffer));
  }
  setupBuffers() {
    this.geometry && this.geometry.dispose(), this.geometry = new ja(), this.geometry.setIndex(this.settings.instancingGeometry.getIndex()), this.settings.instancingGeometry.hasAttribute("normal") && this.geometry.setAttribute("normal", this.settings.instancingGeometry.getAttribute("normal")), this.geometry.setAttribute("position", this.settings.instancingGeometry.getAttribute("position")), this.geometry.setAttribute("uv", this.settings.instancingGeometry.getAttribute("uv")), this.buildExpandableBuffers();
  }
  expandBuffers(t) {
    for (; t >= this.maxParticles; )
      this.maxParticles *= 2;
    this.setupBuffers();
  }
  rebuildMaterial() {
    this.layers.mask = this.settings.layers.mask;
    const t = {}, e = {};
    this.settings.material.type !== "MeshStandardMaterial" && this.settings.material.type !== "MeshPhysicalMaterial" && (t.map = new Vt(this.settings.material.map)), this.settings.material.alphaTest && (e.USE_ALPHATEST = "", t.alphaTest = new Vt(this.settings.material.alphaTest)), e.USE_UV = "";
    const i = this.settings.uTileCount, r = this.settings.vTileCount;
    (i > 1 || r > 1) && (e.UV_TILE = "", t.tileCount = new Vt(new Qe(i, r))), this.settings.material.defines && this.settings.material.defines.USE_COLOR_AS_ALPHA !== void 0 && (e.USE_COLOR_AS_ALPHA = ""), this.settings.material.normalMap && (e.USE_NORMALMAP = "", e.NORMALMAP_UV = Qn(this.settings.material.normalMap.channel), t.normalMapTransform = new Vt(new Kt().copy(this.settings.material.normalMap.matrix))), this.settings.material.map && (e.USE_MAP = "", this.settings.blendTiles && (e.TILE_BLEND = ""), e.MAP_UV = Qn(this.settings.material.map.channel), t.mapTransform = new Vt(new Kt().copy(this.settings.material.map.matrix))), e.USE_COLOR_ALPHA = "";
    let s;
    if (this.settings.softParticles) {
      e.SOFT_PARTICLES = "";
      const o = this.settings.softNearFade, c = 1 / (this.settings.softFarFade - this.settings.softNearFade);
      t.softParams = new Vt(new Qe(o, c)), t.depthTexture = new Vt(null);
      const l = t.projParams = new Vt(new wt());
      s = (h, u, f) => {
        l.value.set(f.near, f.far, 0, 0);
      };
    }
    let a = !1;
    if (this.settings.renderMode === A.BillBoard || this.settings.renderMode === A.VerticalBillBoard || this.settings.renderMode === A.HorizontalBillBoard || this.settings.renderMode === A.Mesh) {
      let o, c;
      this.settings.renderMode === A.Mesh ? this.settings.material.type === "MeshStandardMaterial" || this.settings.material.type === "MeshPhysicalMaterial" ? (e.USE_COLOR = "", o = vs, c = gs, a = !0) : (o = rh, c = Cn) : (o = ih, c = Cn), this.settings.renderMode === A.VerticalBillBoard ? e.VERTICAL = "" : this.settings.renderMode === A.HorizontalBillBoard && (e.HORIZONTAL = "");
      let l = !1;
      this.settings.renderMode === A.Mesh && (this.settings.material.type === "MeshStandardMaterial" ? (this.material = new sh({}), this.material.copy(this.settings.material), this.material.uniforms = t, this.material.defines = e, l = !0) : this.settings.material.type === "MeshPhysicalMaterial" && (this.material = new oh({}), this.material.copy(this.settings.material), this.material.uniforms = t, this.material.defines = e, l = !0)), l || (this.material = new Dn({
        uniforms: t,
        defines: e,
        vertexShader: o,
        fragmentShader: c,
        transparent: this.settings.material.transparent,
        depthWrite: !this.settings.material.transparent,
        blending: this.settings.material.blending,
        blendDst: this.settings.material.blendDst,
        blendSrc: this.settings.material.blendSrc,
        blendEquation: this.settings.material.blendEquation,
        premultipliedAlpha: this.settings.material.premultipliedAlpha,
        side: this.settings.material.side,
        alphaTest: this.settings.material.alphaTest,
        depthTest: this.settings.material.depthTest,
        lights: a
      }));
    } else if (this.settings.renderMode === A.StretchedBillBoard)
      t.speedFactor = new Vt(1), this.material = new Dn({
        uniforms: t,
        defines: e,
        vertexShader: nh,
        fragmentShader: Cn,
        transparent: this.settings.material.transparent,
        depthWrite: !this.settings.material.transparent,
        blending: this.settings.material.blending,
        blendDst: this.settings.material.blendDst,
        blendSrc: this.settings.material.blendSrc,
        blendEquation: this.settings.material.blendEquation,
        premultipliedAlpha: this.settings.material.premultipliedAlpha,
        side: this.settings.material.side,
        alphaTest: this.settings.material.alphaTest,
        depthTest: this.settings.material.depthTest
      });
    else
      throw new Error("render mode unavailable");
    this.material && s && (this.material.onBeforeRender = s);
  }
  update() {
    let t = 0, e = 0;
    this.systems.forEach((i) => {
      e += i.particleNum;
    }), e > this.maxParticles && this.expandBuffers(e), this.systems.forEach((i) => {
      i.emitter.updateMatrixWorld && (i.emitter.updateWorldMatrix(!0, !1), i.emitter.updateMatrixWorld(!0));
      const r = i.particles, s = i.particleNum, a = this.quaternion2_, o = this.vector2_, c = this.vector3_;
      i.emitter.matrixWorld.decompose(o, a, c), this.rotationMat_.setFromMatrix4(i.emitter.matrixWorld);
      for (let l = 0; l < s; l++, t++) {
        const h = r[l];
        if (this.settings.renderMode === A.Mesh) {
          let f;
          if (i.worldSpace)
            f = h.rotation;
          else {
            let d;
            h.parentMatrix ? d = this.quaternion3_.setFromRotationMatrix(h.parentMatrix) : d = a, f = this.quaternion_, f.copy(d).multiply(h.rotation);
          }
          this.rotationBuffer.setXYZW(t, f.x, f.y, f.z, f.w);
        } else (this.settings.renderMode === A.StretchedBillBoard || this.settings.renderMode === A.VerticalBillBoard || this.settings.renderMode === A.HorizontalBillBoard || this.settings.renderMode === A.BillBoard) && this.rotationBuffer.setX(t, h.rotation);
        let u;
        if (i.worldSpace ? u = h.position : (u = this.vector_, h.parentMatrix ? u.copy(h.position).applyMatrix4(h.parentMatrix) : u.copy(h.position).applyMatrix4(i.emitter.matrixWorld)), this.offsetBuffer.setXYZ(t, u.x, u.y, u.z), this.colorBuffer.setXYZW(t, h.color.x, h.color.y, h.color.z, h.color.w), i.worldSpace ? this.sizeBuffer.setXYZ(t, h.size.x, h.size.y, h.size.z) : h.parentMatrix ? this.sizeBuffer.setXYZ(t, h.size.x, h.size.y, h.size.z) : this.sizeBuffer.setXYZ(t, h.size.x * Math.abs(c.x), h.size.y * Math.abs(c.y), h.size.z * Math.abs(c.z)), this.uvTileBuffer.setX(t, h.uvTile), this.settings.renderMode === A.StretchedBillBoard && this.velocityBuffer) {
          let f = i.rendererEmitterSettings.speedFactor;
          f === 0 && (f = 1e-3);
          const d = i.rendererEmitterSettings.lengthFactor;
          let y;
          i.worldSpace ? y = h.velocity : (y = this.vector_, h.parentMatrix ? (this.rotationMat2_.setFromMatrix4(h.parentMatrix), y.copy(h.velocity).applyMatrix3(this.rotationMat2_)) : y.copy(h.velocity).applyMatrix3(this.rotationMat_)), this.velocityBuffer.setXYZW(t, y.x * f, y.y * f, y.z * f, d);
        }
      }
    }), this.geometry.instanceCount = t, t > 0 && (this.offsetBuffer.clearUpdateRanges(), this.offsetBuffer.addUpdateRange(0, t * 3), this.offsetBuffer.needsUpdate = !0, this.sizeBuffer.clearUpdateRanges(), this.sizeBuffer.addUpdateRange(0, t * 3), this.sizeBuffer.needsUpdate = !0, this.colorBuffer.clearUpdateRanges(), this.colorBuffer.addUpdateRange(0, t * 4), this.colorBuffer.needsUpdate = !0, this.uvTileBuffer.clearUpdateRanges(), this.uvTileBuffer.addUpdateRange(0, t), this.uvTileBuffer.needsUpdate = !0, this.settings.renderMode === A.StretchedBillBoard && this.velocityBuffer && (this.velocityBuffer.clearUpdateRanges(), this.velocityBuffer.addUpdateRange(0, t * 4), this.velocityBuffer.needsUpdate = !0), this.settings.renderMode === A.Mesh ? (this.rotationBuffer.clearUpdateRanges(), this.rotationBuffer.addUpdateRange(0, t * 4), this.rotationBuffer.needsUpdate = !0) : (this.settings.renderMode === A.StretchedBillBoard || this.settings.renderMode === A.HorizontalBillBoard || this.settings.renderMode === A.VerticalBillBoard || this.settings.renderMode === A.BillBoard) && (this.rotationBuffer.clearUpdateRanges(), this.rotationBuffer.addUpdateRange(0, t), this.rotationBuffer.needsUpdate = !0));
  }
  dispose() {
    this.geometry.dispose();
  }
}
var ch = `

#include <common>
#include <tile_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

uniform sampler2D alphaMap;
uniform float useAlphaMap;
uniform float visibility;
uniform float alphaTest;

varying vec4 vColor;
    
void main() {
    #include <clipping_planes_fragment>
    #include <logdepthbuf_fragment>

    vec4 diffuseColor = vColor;
    
    #ifdef USE_MAP
    #include <tile_fragment>
    #ifndef USE_COLOR_AS_ALPHA
    #endif
    #endif
    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;
    if( diffuseColor.a < alphaTest ) discard;
    gl_FragColor = diffuseColor;

    #include <fog_fragment>
    #include <tonemapping_fragment>
}`, lh = `
#include <common>
#include <tile_pars_vertex>
#include <color_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <fog_pars_vertex>

attribute vec3 previous;
attribute vec3 next;
attribute float side;
attribute float width;

uniform vec2 resolution;
uniform float lineWidth;
uniform float sizeAttenuation;
    
vec2 fix(vec4 i, float aspect) {
    vec2 res = i.xy / i.w;
    res.x *= aspect;
    return res;
}
    
void main() {

    #include <tile_vertex>
    
    float aspect = resolution.x / resolution.y;

    vColor = color;

    mat4 m = projectionMatrix * modelViewMatrix;
    vec4 finalPosition = m * vec4( position, 1.0 );
    vec4 prevPos = m * vec4( previous, 1.0 );
    vec4 nextPos = m * vec4( next, 1.0 );

    vec2 currentP = fix( finalPosition, aspect );
    vec2 prevP = fix( prevPos, aspect );
    vec2 nextP = fix( nextPos, aspect );

    float w = lineWidth * width;

    vec2 dir;
    if( nextP == currentP ) dir = normalize( currentP - prevP );
    else if( prevP == currentP ) dir = normalize( nextP - currentP );
    else {
        vec2 dir1 = normalize( currentP - prevP );
        vec2 dir2 = normalize( nextP - currentP );
        dir = normalize( dir1 + dir2 );

        vec2 perp = vec2( -dir1.y, dir1.x );
        vec2 miter = vec2( -dir.y, dir.x );
        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );

    }

    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;
    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );
    normal.xy *= .5 * w;
    normal *= projectionMatrix;
    if( sizeAttenuation == 0. ) {
        normal.xy *= finalPosition.w;
        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;
    }

    finalPosition.xy += normal.xy * side;

    gl_Position = finalPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
	#include <fog_vertex>
}`;
class hh extends za {
  constructor(t) {
    super(t), this.vector_ = new B(), this.vector2_ = new B(), this.vector3_ = new B(), this.quaternion_ = new G(), this.maxParticles = 1e4, this.setupBuffers(), this.rebuildMaterial();
  }
  setupBuffers() {
    this.geometry && this.geometry.dispose(), this.geometry = new Pi(), this.indexBuffer = new Mt(new Uint32Array(this.maxParticles * 6), 1), this.indexBuffer.setUsage(gt), this.geometry.setIndex(this.indexBuffer), this.positionBuffer = new Mt(new Float32Array(this.maxParticles * 6), 3), this.positionBuffer.setUsage(gt), this.geometry.setAttribute("position", this.positionBuffer), this.previousBuffer = new Mt(new Float32Array(this.maxParticles * 6), 3), this.previousBuffer.setUsage(gt), this.geometry.setAttribute("previous", this.previousBuffer), this.nextBuffer = new Mt(new Float32Array(this.maxParticles * 6), 3), this.nextBuffer.setUsage(gt), this.geometry.setAttribute("next", this.nextBuffer), this.widthBuffer = new Mt(new Float32Array(this.maxParticles * 2), 1), this.widthBuffer.setUsage(gt), this.geometry.setAttribute("width", this.widthBuffer), this.sideBuffer = new Mt(new Float32Array(this.maxParticles * 2), 1), this.sideBuffer.setUsage(gt), this.geometry.setAttribute("side", this.sideBuffer), this.uvBuffer = new Mt(new Float32Array(this.maxParticles * 4), 2), this.uvBuffer.setUsage(gt), this.geometry.setAttribute("uv", this.uvBuffer), this.colorBuffer = new Mt(new Float32Array(this.maxParticles * 8), 4), this.colorBuffer.setUsage(gt), this.geometry.setAttribute("color", this.colorBuffer);
  }
  expandBuffers(t) {
    for (; t >= this.maxParticles; )
      this.maxParticles *= 2;
    this.setupBuffers();
  }
  rebuildMaterial() {
    this.layers.mask = this.settings.layers.mask;
    const t = {
      lineWidth: { value: 1 },
      map: { value: null },
      useMap: { value: 0 },
      alphaMap: { value: null },
      useAlphaMap: { value: 0 },
      resolution: { value: new Qe(1, 1) },
      sizeAttenuation: { value: 1 },
      visibility: { value: 1 },
      alphaTest: { value: 0 }
    }, e = {};
    if (e.USE_UV = "", e.USE_COLOR_ALPHA = "", this.settings.material.map && (e.USE_MAP = "", e.MAP_UV = Qn(this.settings.material.map.channel), t.map = new Vt(this.settings.material.map), t.mapTransform = new Vt(new Kt().copy(this.settings.material.map.matrix))), this.settings.material.defines && this.settings.material.defines.USE_COLOR_AS_ALPHA !== void 0 && (e.USE_COLOR_AS_ALPHA = ""), this.settings.renderMode === A.Trail)
      this.material = new Dn({
        uniforms: t,
        defines: e,
        vertexShader: lh,
        fragmentShader: ch,
        transparent: this.settings.material.transparent,
        depthWrite: !this.settings.material.transparent,
        side: this.settings.material.side,
        blending: this.settings.material.blending || Bo,
        blendDst: this.settings.material.blendDst,
        blendSrc: this.settings.material.blendSrc,
        blendEquation: this.settings.material.blendEquation,
        premultipliedAlpha: this.settings.material.premultipliedAlpha
      });
    else
      throw new Error("render mode unavailable");
  }
  update() {
    let t = 0, e = 0, i = 0;
    this.systems.forEach((r) => {
      for (let s = 0; s < r.particleNum; s++)
        i += r.particles[s].previous.length * 2;
    }), i > this.maxParticles && this.expandBuffers(i), this.systems.forEach((r) => {
      r.emitter.updateMatrixWorld && (r.emitter.updateWorldMatrix(!0, !1), r.emitter.updateMatrixWorld(!0));
      const s = this.quaternion_, a = this.vector2_, o = this.vector3_;
      r.emitter.matrixWorld.decompose(a, s, o);
      const c = r.particles, l = r.particleNum, h = this.settings.uTileCount, u = this.settings.vTileCount, f = 1 / h, d = 1 / u;
      for (let y = 0; y < l; y++) {
        const _ = c[y], p = _.uvTile % u, m = Math.floor(_.uvTile / u + 1e-3), v = _.previous.values();
        let g = v.next(), b = g.value, x = b;
        g.done || (g = v.next());
        let S;
        g.value !== void 0 ? S = g.value : S = x;
        for (let T = 0; T < _.previous.length; T++, t += 2) {
          if (this.positionBuffer.setXYZ(t, x.position.x, x.position.y, x.position.z), this.positionBuffer.setXYZ(t + 1, x.position.x, x.position.y, x.position.z), r.worldSpace ? (this.positionBuffer.setXYZ(t, x.position.x, x.position.y, x.position.z), this.positionBuffer.setXYZ(t + 1, x.position.x, x.position.y, x.position.z)) : (_.parentMatrix ? this.vector_.copy(x.position).applyMatrix4(_.parentMatrix) : this.vector_.copy(x.position).applyMatrix4(r.emitter.matrixWorld), this.positionBuffer.setXYZ(t, this.vector_.x, this.vector_.y, this.vector_.z), this.positionBuffer.setXYZ(t + 1, this.vector_.x, this.vector_.y, this.vector_.z)), r.worldSpace ? (this.previousBuffer.setXYZ(t, b.position.x, b.position.y, b.position.z), this.previousBuffer.setXYZ(t + 1, b.position.x, b.position.y, b.position.z)) : (_.parentMatrix ? this.vector_.copy(b.position).applyMatrix4(_.parentMatrix) : this.vector_.copy(b.position).applyMatrix4(r.emitter.matrixWorld), this.previousBuffer.setXYZ(t, this.vector_.x, this.vector_.y, this.vector_.z), this.previousBuffer.setXYZ(t + 1, this.vector_.x, this.vector_.y, this.vector_.z)), r.worldSpace ? (this.nextBuffer.setXYZ(t, S.position.x, S.position.y, S.position.z), this.nextBuffer.setXYZ(t + 1, S.position.x, S.position.y, S.position.z)) : (_.parentMatrix ? this.vector_.copy(S.position).applyMatrix4(_.parentMatrix) : this.vector_.copy(S.position).applyMatrix4(r.emitter.matrixWorld), this.nextBuffer.setXYZ(t, this.vector_.x, this.vector_.y, this.vector_.z), this.nextBuffer.setXYZ(t + 1, this.vector_.x, this.vector_.y, this.vector_.z)), this.sideBuffer.setX(t, -1), this.sideBuffer.setX(t + 1, 1), r.worldSpace)
            this.widthBuffer.setX(t, x.size), this.widthBuffer.setX(t + 1, x.size);
          else if (_.parentMatrix)
            this.widthBuffer.setX(t, x.size), this.widthBuffer.setX(t + 1, x.size);
          else {
            const P = (Math.abs(o.x) + Math.abs(o.y) + Math.abs(o.z)) / 3;
            this.widthBuffer.setX(t, x.size * P), this.widthBuffer.setX(t + 1, x.size * P);
          }
          this.uvBuffer.setXY(t, (T / _.previous.length + p) * f, (u - m - 1) * d), this.uvBuffer.setXY(t + 1, (T / _.previous.length + p) * f, (u - m) * d), this.colorBuffer.setXYZW(t, x.color.x, x.color.y, x.color.z, x.color.w), this.colorBuffer.setXYZW(t + 1, x.color.x, x.color.y, x.color.z, x.color.w), T + 1 < _.previous.length && (this.indexBuffer.setX(e * 3, t), this.indexBuffer.setX(e * 3 + 1, t + 1), this.indexBuffer.setX(e * 3 + 2, t + 2), e++, this.indexBuffer.setX(e * 3, t + 2), this.indexBuffer.setX(e * 3 + 1, t + 1), this.indexBuffer.setX(e * 3 + 2, t + 3), e++), b = x, x = S, g.done || (g = v.next(), g.value !== void 0 && (S = g.value));
        }
      }
    }), this.positionBuffer.clearUpdateRanges(), this.positionBuffer.addUpdateRange(0, t * 3), this.positionBuffer.needsUpdate = !0, this.previousBuffer.clearUpdateRanges(), this.previousBuffer.addUpdateRange(0, t * 3), this.previousBuffer.needsUpdate = !0, this.nextBuffer.clearUpdateRanges(), this.nextBuffer.addUpdateRange(0, t * 3), this.nextBuffer.needsUpdate = !0, this.sideBuffer.clearUpdateRanges(), this.sideBuffer.addUpdateRange(0, t), this.sideBuffer.needsUpdate = !0, this.widthBuffer.clearUpdateRanges(), this.widthBuffer.addUpdateRange(0, t), this.widthBuffer.needsUpdate = !0, this.uvBuffer.clearUpdateRanges(), this.uvBuffer.addUpdateRange(0, t * 2), this.uvBuffer.needsUpdate = !0, this.colorBuffer.clearUpdateRanges(), this.colorBuffer.addUpdateRange(0, t * 4), this.colorBuffer.needsUpdate = !0, this.indexBuffer.clearUpdateRanges(), this.indexBuffer.addUpdateRange(0, e * 3), this.indexBuffer.needsUpdate = !0, this.geometry.setDrawRange(0, e * 3);
  }
  dispose() {
    this.geometry.dispose();
  }
}
class cr {
  get geometry() {
    return this._geometry;
  }
  set geometry(t) {
    if (this._geometry = t, t === void 0 || typeof t == "string")
      return;
    const e = new Ue();
    this._triangleIndexToArea.length = 0;
    let i = 0;
    if (!t.getIndex())
      return;
    const r = t.getIndex().array, s = r.length / 3;
    this._triangleIndexToArea.push(0);
    for (let a = 0; a < s; a++)
      e.setFromAttributeAndIndices(t.getAttribute("position"), r[a * 3], r[a * 3 + 1], r[a * 3 + 2]), i += e.getArea(), this._triangleIndexToArea.push(i);
    t.userData.triangleIndexToArea = this._triangleIndexToArea;
  }
  constructor(t) {
    this.type = "mesh_surface", this._triangleIndexToArea = [], this._tempA = new N(), this._tempB = new N(), this._tempC = new N(), t && (this.geometry = t);
  }
  initialize(t) {
    const e = this._geometry;
    if (!e || e.getIndex() === null) {
      t.position.set(0, 0, 0), t.velocity.set(0, 0, 1).multiplyScalar(t.startSpeed);
      return;
    }
    const i = this._triangleIndexToArea.length - 1;
    let r = 0, s = i;
    const a = Math.random() * this._triangleIndexToArea[i];
    for (; r + 1 < s; ) {
      const d = Math.floor((r + s) / 2);
      a < this._triangleIndexToArea[d] ? s = d : r = d;
    }
    let o = Math.random(), c = Math.random();
    o + c > 1 && (o = 1 - o, c = 1 - c);
    const l = e.getIndex().array[r * 3], h = e.getIndex().array[r * 3 + 1], u = e.getIndex().array[r * 3 + 2], f = e.getAttribute("position");
    this._tempA.fromBufferAttribute(f, l), this._tempB.fromBufferAttribute(f, h), this._tempC.fromBufferAttribute(f, u), this._tempB.sub(this._tempA), this._tempC.sub(this._tempA), this._tempA.addScaledVector(this._tempB, o).addScaledVector(this._tempC, c), t.position.copy(this._tempA), this._tempA.copy(this._tempB).cross(this._tempC).normalize(), t.velocity.copy(this._tempA).normalize().multiplyScalar(t.startSpeed);
  }
  toJSON() {
    return {
      type: "mesh_surface",
      mesh: this._geometry ? this._geometry.uuid : ""
    };
  }
  static fromJSON(t, e) {
    return new cr(e.geometries[t.geometry]);
  }
  clone() {
    return new cr(this._geometry);
  }
  update(t, e) {
  }
}
Vl({
  id: "three.quarks",
  emitterShapes: [{
    type: "mesh_surface",
    params: [["geometry", ["geometry"]]],
    constructor: cr,
    loadJSON: cr.fromJSON
  }],
  behaviors: []
});
class _s extends Oo {
  constructor() {
    super(), this.batches = [], this.systemToBatchIndex = /* @__PURE__ */ new Map(), this.type = "BatchedRenderer", this.depthTexture = null;
  }
  static equals(t, e) {
    return t.material.side === e.material.side && t.material.blending === e.material.blending && t.material.blendSrc === e.material.blendSrc && t.material.blendDst === e.material.blendDst && t.material.blendEquation === e.material.blendEquation && t.material.premultipliedAlpha === e.material.premultipliedAlpha && t.material.transparent === e.material.transparent && t.material.depthTest === e.material.depthTest && t.material.type === e.material.type && t.material.alphaTest === e.material.alphaTest && t.material.map === e.material.map && t.renderMode === e.renderMode && t.blendTiles === e.blendTiles && t.softParticles === e.softParticles && t.softFarFade === e.softFarFade && t.softNearFade === e.softNearFade && t.uTileCount === e.uTileCount && t.vTileCount === e.vTileCount && t.instancingGeometry === e.instancingGeometry && t.renderOrder === e.renderOrder && t.layers.mask === e.layers.mask;
  }
  addSystem(t) {
    t._renderer = this;
    const e = t.getRendererSettings();
    for (let r = 0; r < this.batches.length; r++)
      if (_s.equals(this.batches[r].settings, e)) {
        this.batches[r].addSystem(t), this.systemToBatchIndex.set(t, r);
        return;
      }
    let i;
    switch (e.renderMode) {
      case A.Trail:
        i = new hh(e);
        break;
      case A.Mesh:
      case A.BillBoard:
      case A.VerticalBillBoard:
      case A.HorizontalBillBoard:
      case A.StretchedBillBoard:
        i = new ah(e);
        break;
    }
    this.depthTexture && i.applyDepthTexture(this.depthTexture), i.addSystem(t), this.batches.push(i), this.systemToBatchIndex.set(t, this.batches.length - 1), this.add(i);
  }
  deleteSystem(t) {
    const e = this.systemToBatchIndex.get(t);
    e != null && (this.batches[e].removeSystem(t), this.systemToBatchIndex.delete(t));
  }
  setDepthTexture(t) {
    this.depthTexture = t;
    for (const e of this.batches)
      e.applyDepthTexture(t);
  }
  updateSystem(t) {
    this.deleteSystem(t), this.addSystem(t);
  }
  update(t) {
    this.systemToBatchIndex.forEach((e, i) => {
      i.update(t);
    });
    for (let e = 0; e < this.batches.length; e++)
      this.batches[e].update();
  }
}
const Fu = _s;
Yl();
console.log("%c Particle system powered by three.quarks. https://quarks.art/", "font-size: 14px; font-weight: bold;");
const Oa = /* @__PURE__ */ Math.sqrt(5), uh = (Oa - 1) / 4, ct = (5 - Oa) / 20, vr = (n) => Math.floor(n) | 0, _r = /* @__PURE__ */ new Float64Array([
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0
]);
function Du(n = Math.random) {
  const t = fh(n), e = new Float64Array(t).map((a) => _r[a % 32 * 4]), i = new Float64Array(t).map((a) => _r[a % 32 * 4 + 1]), r = new Float64Array(t).map((a) => _r[a % 32 * 4 + 2]), s = new Float64Array(t).map((a) => _r[a % 32 * 4 + 3]);
  return function(o, c, l, h) {
    let u, f, d, y, _;
    const p = (o + c + l + h) * uh, m = vr(o + p), v = vr(c + p), g = vr(l + p), b = vr(h + p), x = (m + v + g + b) * ct, S = m - x, T = v - x, P = g - x, M = b - x, C = o - S, E = c - T, w = l - P, k = h - M;
    let R = 0, z = 0, U = 0, L = 0;
    C > E ? R++ : z++, C > w ? R++ : U++, C > k ? R++ : L++, E > w ? z++ : U++, E > k ? z++ : L++, w > k ? U++ : L++;
    const I = R >= 3 ? 1 : 0, H = z >= 3 ? 1 : 0, K = U >= 3 ? 1 : 0, rt = L >= 3 ? 1 : 0, tt = R >= 2 ? 1 : 0, mt = z >= 2 ? 1 : 0, yt = U >= 2 ? 1 : 0, nt = L >= 2 ? 1 : 0, W = R >= 1 ? 1 : 0, $ = z >= 1 ? 1 : 0, ie = U >= 1 ? 1 : 0, jt = L >= 1 ? 1 : 0, $t = C - I + ct, qt = E - H + ct, xt = w - K + ct, Bt = k - rt + ct, bt = C - tt + 2 * ct, re = E - mt + 2 * ct, ne = w - yt + 2 * ct, Y = k - nt + 2 * ct, Xt = C - W + 3 * ct, se = E - $ + 3 * ct, Pe = w - ie + 3 * ct, oe = k - jt + 3 * ct, ae = C - 1 + 4 * ct, ce = E - 1 + 4 * ct, le = w - 1 + 4 * ct, he = k - 1 + 4 * ct, It = m & 255, Nt = v & 255, Ut = g & 255, Ft = b & 255;
    let V = 0.6 - C * C - E * E - w * w - k * k;
    if (V < 0)
      u = 0;
    else {
      const X = It + t[Nt + t[Ut + t[Ft]]];
      V *= V, u = V * V * (e[X] * C + i[X] * E + r[X] * w + s[X] * k);
    }
    let oi = 0.6 - $t * $t - qt * qt - xt * xt - Bt * Bt;
    if (oi < 0)
      f = 0;
    else {
      const X = It + I + t[Nt + H + t[Ut + K + t[Ft + rt]]];
      oi *= oi, f = oi * oi * (e[X] * $t + i[X] * qt + r[X] * xt + s[X] * Bt);
    }
    let ai = 0.6 - bt * bt - re * re - ne * ne - Y * Y;
    if (ai < 0)
      d = 0;
    else {
      const X = It + tt + t[Nt + mt + t[Ut + yt + t[Ft + nt]]];
      ai *= ai, d = ai * ai * (e[X] * bt + i[X] * re + r[X] * ne + s[X] * Y);
    }
    let ci = 0.6 - Xt * Xt - se * se - Pe * Pe - oe * oe;
    if (ci < 0)
      y = 0;
    else {
      const X = It + W + t[Nt + $ + t[Ut + ie + t[Ft + jt]]];
      ci *= ci, y = ci * ci * (e[X] * Xt + i[X] * se + r[X] * Pe + s[X] * oe);
    }
    let li = 0.6 - ae * ae - ce * ce - le * le - he * he;
    if (li < 0)
      _ = 0;
    else {
      const X = It + 1 + t[Nt + 1 + t[Ut + 1 + t[Ft + 1]]];
      li *= li, _ = li * li * (e[X] * ae + i[X] * ce + r[X] * le + s[X] * he);
    }
    return 27 * (u + f + d + y + _);
  };
}
function fh(n) {
  const e = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++)
    e[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    const r = i + ~~(n() * (256 - i)), s = e[i];
    e[i] = e[r], e[r] = s;
  }
  for (let i = 256; i < 512; i++)
    e[i] = e[i - 256];
  return e;
}
class dh {
  /**
   * Creates a new ExponentialBackoff.
   * @param base the base of the exponentiation
   * @param expMax the maximum exponent, no bound if undefined
   */
  constructor(t, e) {
    if (this._retries = 0, !Number.isInteger(t) || t < 0)
      throw new Error("Base must be a positive integer or zero");
    if (e !== void 0 && (!Number.isInteger(e) || e < 0))
      throw new Error("ExpMax must be a undefined, a positive integer or zero");
    this.base = t, this.expMax = e, this.i = 0;
  }
  get retries() {
    return this._retries;
  }
  get current() {
    return this.base * Math.pow(2, this.i);
  }
  next() {
    return this._retries++, this.i = this.expMax === void 0 ? this.i + 1 : Math.min(this.i + 1, this.expMax), this.current;
  }
  reset() {
    this._retries = 0, this.i = 0;
  }
}
var j;
(function(n) {
  n.open = "open", n.close = "close", n.error = "error", n.message = "message", n.retry = "retry", n.reconnect = "reconnect";
})(j || (j = {}));
class Ba {
  /**
   * Creates a new websocket.
   *
   * @param url to connect to.
   * @param protocols optional protocols to use.
   * @param options optional options to use.
   */
  constructor(t, e, i) {
    var r, s, a, o, c, l, h, u, f, d, y, _, p, m, v;
    this._closedByUser = !1, this.handleOpenEvent = (g) => this.handleEvent(j.open, g), this.handleErrorEvent = (g) => this.handleEvent(j.error, g), this.handleCloseEvent = (g) => this.handleEvent(j.close, g), this.handleMessageEvent = (g) => this.handleEvent(j.message, g), this._url = t, this._protocols = e, this._options = {
      buffer: i?.buffer,
      retry: {
        maxRetries: (r = i?.retry) === null || r === void 0 ? void 0 : r.maxRetries,
        instantReconnect: (s = i?.retry) === null || s === void 0 ? void 0 : s.instantReconnect,
        backoff: (a = i?.retry) === null || a === void 0 ? void 0 : a.backoff
      },
      listeners: {
        open: [...(c = (o = i?.listeners) === null || o === void 0 ? void 0 : o.open) !== null && c !== void 0 ? c : []],
        close: [...(h = (l = i?.listeners) === null || l === void 0 ? void 0 : l.close) !== null && h !== void 0 ? h : []],
        error: [...(f = (u = i?.listeners) === null || u === void 0 ? void 0 : u.error) !== null && f !== void 0 ? f : []],
        message: [...(y = (d = i?.listeners) === null || d === void 0 ? void 0 : d.message) !== null && y !== void 0 ? y : []],
        retry: [...(p = (_ = i?.listeners) === null || _ === void 0 ? void 0 : _.retry) !== null && p !== void 0 ? p : []],
        reconnect: [...(v = (m = i?.listeners) === null || m === void 0 ? void 0 : m.reconnect) !== null && v !== void 0 ? v : []]
      }
    }, this._underlyingWebsocket = this.tryConnect();
  }
  /**
   * Getter for the url.
   *
   * @return the url.
   */
  get url() {
    return this._url;
  }
  /**
   * Getter for the protocols.
   *
   * @return the protocols, or undefined if none were provided.
   */
  get protocols() {
    return this._protocols;
  }
  /**
   * Getter for the buffer.
   *
   * @return the buffer, or undefined if none was provided.
   */
  get buffer() {
    return this._options.buffer;
  }
  /**
   * Getter for the maxRetries.
   *
   * @return the maxRetries, or undefined if none was provided (no limit).
   */
  get maxRetries() {
    return this._options.retry.maxRetries;
  }
  /**
   * Getter for the instantReconnect.
   *
   * @return the instantReconnect, or undefined if none was provided.
   */
  get instantReconnect() {
    return this._options.retry.instantReconnect;
  }
  /**
   * Getter for the backoff.
   *
   * @return the backoff, or undefined if none was provided.
   */
  get backoff() {
    return this._options.retry.backoff;
  }
  /**
   * Whether the websocket was closed by the user. A websocket is closed by the user by calling close().
   *
   * @return true if the websocket was closed by the user, false otherwise.
   */
  get closedByUser() {
    return this._closedByUser;
  }
  /**
   * Getter for the last 'open' event, e.g. the last time the websocket was connected.
   *
   * @return the last 'open' event, or undefined if the websocket was never connected.
   */
  get lastConnection() {
    return this._lastConnection;
  }
  /**
   * Getter for the underlying websocket. This can be used to access the browser's native websocket directly.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
   * @return the underlying websocket.
   */
  get underlyingWebsocket() {
    return this._underlyingWebsocket;
  }
  /**
   * Getter for the readyState of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
   * @return the readyState of the underlying websocket.
   */
  get readyState() {
    return this._underlyingWebsocket.readyState;
  }
  /**
   * Getter for the bufferedAmount of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount
   * @return the bufferedAmount of the underlying websocket.
   */
  get bufferedAmount() {
    return this._underlyingWebsocket.bufferedAmount;
  }
  /**
   * Getter for the extensions of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/extensions
   * @return the extensions of the underlying websocket.
   */
  get extensions() {
    return this._underlyingWebsocket.extensions;
  }
  /**
   * Getter for the binaryType of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/binaryType
   * @return the binaryType of the underlying websocket.
   */
  get binaryType() {
    return this._underlyingWebsocket.binaryType;
  }
  /**
   * Setter for the binaryType of the underlying websocket.
   *
   * @param value to set, 'blob' or 'arraybuffer'.
   */
  set binaryType(t) {
    this._underlyingWebsocket.binaryType = t;
  }
  /**
   * Sends data over the websocket.
   *
   * If the websocket is not connected and a buffer was provided on creation, the data will be added to the buffer.
   * If no buffer was provided or the websocket was closed by the user, the data will be dropped.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   * @param data to send.
   */
  send(t) {
    this.closedByUser || (this._underlyingWebsocket.readyState === this._underlyingWebsocket.OPEN ? this._underlyingWebsocket.send(t) : this.buffer !== void 0 && this.buffer.add(t));
  }
  /**
   * Close the websocket. No connection-retry will be attempted after this.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close
   * @param code optional close code.
   * @param reason optional close reason.
   */
  close(t, e) {
    this.cancelScheduledConnectionRetry(), this._closedByUser = !0, this._underlyingWebsocket.close(t, e);
  }
  /**
   * Adds an event listener for the given event-type.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   * @param type of the event to add the listener for.
   * @param listener to add.
   * @param options to use when adding the listener.
   */
  addEventListener(t, e, i) {
    this._options.listeners[t].push({ listener: e, options: i });
  }
  /**
   * Removes one or more event listener for the given event-type that match the given listener and options.
   *
   * @param type of the event to remove the listener for.
   * @param listener to remove.
   * @param options that were used when the listener was added.
   */
  removeEventListener(t, e, i) {
    const r = (s) => s.listener !== e || s.options !== i;
    this._options.listeners[t] = this._options.listeners[t].filter(r);
  }
  /**
   * Creates a new browser-native websocket and connects it to the given URL with the given protocols
   * and adds all event listeners to the browser-native websocket.
   *
   * @return the created browser-native websocket which is also stored in the '_underlyingWebsocket' property.
   */
  tryConnect() {
    return this._underlyingWebsocket = new WebSocket(this.url, this.protocols), this._underlyingWebsocket.addEventListener(j.open, this.handleOpenEvent), this._underlyingWebsocket.addEventListener(j.close, this.handleCloseEvent), this._underlyingWebsocket.addEventListener(j.error, this.handleErrorEvent), this._underlyingWebsocket.addEventListener(j.message, this.handleMessageEvent), this._underlyingWebsocket;
  }
  /**
   * Removes all event listeners from the browser-native websocket and closes it.
   */
  clearWebsocket() {
    this._underlyingWebsocket.removeEventListener(j.open, this.handleOpenEvent), this._underlyingWebsocket.removeEventListener(j.close, this.handleCloseEvent), this._underlyingWebsocket.removeEventListener(j.error, this.handleErrorEvent), this._underlyingWebsocket.removeEventListener(j.message, this.handleMessageEvent), this._underlyingWebsocket.close();
  }
  /**
   * Dispatch an event to all listeners of the given event-type.
   *
   * @param type of the event to dispatch.
   * @param event to dispatch.
   */
  dispatchEvent(t, e) {
    const i = this._options.listeners[t], r = [];
    i.forEach(({ listener: s, options: a }) => {
      s(this, e), (a === void 0 || a.once === void 0 || !a.once) && r.push({ listener: s, options: a });
    }), this._options.listeners[t] = r;
  }
  /**
   * Handles the given event by dispatching it to all listeners of the given event-type.
   *
   * @param type of the event to handle.
   * @param event to handle.
   */
  handleEvent(t, e) {
    switch (t) {
      case j.close:
        this.dispatchEvent(t, e), this.scheduleConnectionRetryIfNeeded();
        break;
      case j.open:
        if (this.backoff !== void 0 && this._lastConnection !== void 0) {
          const i = {
            retries: this.backoff.retries,
            lastConnection: new Date(this._lastConnection)
          }, r = new CustomEvent(j.reconnect, {
            detail: i
          });
          this.dispatchEvent(j.reconnect, r), this.backoff.reset();
        }
        this._lastConnection = /* @__PURE__ */ new Date(), this.dispatchEvent(t, e), this.sendBufferedData();
        break;
      case j.retry:
        this.dispatchEvent(t, e), this.clearWebsocket(), this.tryConnect();
        break;
      default:
        this.dispatchEvent(t, e);
        break;
    }
  }
  /**
   * Sends buffered data if there is a buffer defined.
   */
  sendBufferedData() {
    if (this.buffer !== void 0)
      for (let t = this.buffer.read(); t !== void 0; t = this.buffer.read())
        this.send(t);
  }
  /**
   * Schedules a connection-retry if there is a backoff defined and the websocket was not closed by the user.
   */
  scheduleConnectionRetryIfNeeded() {
    if (this.closedByUser || this.backoff === void 0)
      return;
    const t = (i) => {
      const r = new CustomEvent(j.retry, { detail: i });
      this.handleEvent(j.retry, r);
    }, e = {
      backoff: this._options.retry.instantReconnect === !0 ? 0 : this.backoff.next(),
      retries: this._options.retry.instantReconnect === !0 ? 0 : this.backoff.retries,
      lastConnection: this._lastConnection
    };
    (this._options.retry.maxRetries === void 0 || e.retries <= this._options.retry.maxRetries) && (this.retryTimeout = globalThis.setTimeout(() => t(e), e.backoff));
  }
  /**
   * Cancels the scheduled connection-retry, if there is one.
   */
  cancelScheduledConnectionRetry() {
    globalThis.clearTimeout(this.retryTimeout);
  }
}
class ph {
  /**
   * Creates a new WebsocketBuilder.
   *
   * @param url the url to connect to
   */
  constructor(t) {
    this._url = t;
  }
  /**
   * Getter for the url.
   *
   * @returns the url
   */
  get url() {
    return this._url;
  }
  /**
   * Adds protocols to the websocket. Subsequent calls to this method will override the previously set protocols.
   *
   * @param protocols the protocols to add
   */
  withProtocols(t) {
    return this._protocols = t, this;
  }
  /**
   * Getter for the protocols.
   *
   * @returns the protocols, undefined if no protocols have been set
   */
  get protocols() {
    return this._protocols;
  }
  /**
   * Sets the maximum number of retries before giving up. No limit if undefined.
   *
   * @param maxRetries the maximum number of retries before giving up
   */
  withMaxRetries(t) {
    var e;
    return this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (e = this._options) === null || e === void 0 ? void 0 : e.retry), { maxRetries: t }) }), this;
  }
  /**
   * Getter for the maximum number of retries before giving up.
   *
   * @returns the maximum number of retries before giving up, undefined if no maximum has been set
   */
  get maxRetries() {
    var t, e;
    return (e = (t = this._options) === null || t === void 0 ? void 0 : t.retry) === null || e === void 0 ? void 0 : e.maxRetries;
  }
  /**
   * Sets wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.
   *
   * @param instantReconnect wether to reconnect immediately after a connection has been lost
   */
  withInstantReconnect(t) {
    var e;
    return this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (e = this._options) === null || e === void 0 ? void 0 : e.retry), { instantReconnect: t }) }), this;
  }
  /**
   * Getter for wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.
   *
   * @returns wether to reconnect immediately after a connection has been lost, undefined if no value has been set
   */
  get instantReconnect() {
    var t, e;
    return (e = (t = this._options) === null || t === void 0 ? void 0 : t.retry) === null || e === void 0 ? void 0 : e.instantReconnect;
  }
  /**
   * Adds a backoff to the websocket. Subsequent calls to this method will override the previously set backoff.
   *
   * @param backoff the backoff to add
   */
  withBackoff(t) {
    var e;
    return this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (e = this._options) === null || e === void 0 ? void 0 : e.retry), { backoff: t }) }), this;
  }
  /**
   * Getter for the backoff.
   *
   * @returns the backoff, undefined if no backoff has been set
   */
  get backoff() {
    var t, e;
    return (e = (t = this._options) === null || t === void 0 ? void 0 : t.retry) === null || e === void 0 ? void 0 : e.backoff;
  }
  /**
   * Adds a buffer to the websocket. Subsequent calls to this method will override the previously set buffer.
   *
   * @param buffer the buffer to add
   */
  withBuffer(t) {
    return this._options = Object.assign(Object.assign({}, this._options), { buffer: t }), this;
  }
  /**
   * Getter for the buffer.
   *
   * @returns the buffer, undefined if no buffer has been set
   */
  get buffer() {
    var t;
    return (t = this._options) === null || t === void 0 ? void 0 : t.buffer;
  }
  /**
   * Adds an 'open' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onOpen(t, e) {
    return this.addListener(j.open, t, e), this;
  }
  /**
   * Adds an 'close' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onClose(t, e) {
    return this.addListener(j.close, t, e), this;
  }
  /**
   * Adds an 'error' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onError(t, e) {
    return this.addListener(j.error, t, e), this;
  }
  /**
   * Adds an 'message' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onMessage(t, e) {
    return this.addListener(j.message, t, e), this;
  }
  /**
   * Adds an 'retry' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onRetry(t, e) {
    return this.addListener(j.retry, t, e), this;
  }
  /**
   * Adds an 'reconnect' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onReconnect(t, e) {
    return this.addListener(j.reconnect, t, e), this;
  }
  /**
   * Builds the websocket.
   *
   * @return a new websocket, with the set options
   */
  build() {
    return new Ba(this._url, this._protocols, this._options);
  }
  /**
   * Adds an event listener to the options.
   *
   * @param event the event to add the listener to
   * @param listener the listener to add
   * @param options the listener options
   */
  addListener(t, e, i) {
    var r, s, a, o, c, l, h, u, f, d, y, _, p, m, v, g, b, x, S, T, P;
    return this._options = Object.assign(Object.assign({}, this._options), { listeners: {
      open: (a = (s = (r = this._options) === null || r === void 0 ? void 0 : r.listeners) === null || s === void 0 ? void 0 : s.open) !== null && a !== void 0 ? a : [],
      close: (l = (c = (o = this._options) === null || o === void 0 ? void 0 : o.listeners) === null || c === void 0 ? void 0 : c.close) !== null && l !== void 0 ? l : [],
      error: (f = (u = (h = this._options) === null || h === void 0 ? void 0 : h.listeners) === null || u === void 0 ? void 0 : u.error) !== null && f !== void 0 ? f : [],
      message: (_ = (y = (d = this._options) === null || d === void 0 ? void 0 : d.listeners) === null || y === void 0 ? void 0 : y.message) !== null && _ !== void 0 ? _ : [],
      retry: (v = (m = (p = this._options) === null || p === void 0 ? void 0 : p.listeners) === null || m === void 0 ? void 0 : m.retry) !== null && v !== void 0 ? v : [],
      reconnect: (x = (b = (g = this._options) === null || g === void 0 ? void 0 : g.listeners) === null || b === void 0 ? void 0 : b.reconnect) !== null && x !== void 0 ? x : [],
      [t]: [
        ...(P = (T = (S = this._options) === null || S === void 0 ? void 0 : S.listeners) === null || T === void 0 ? void 0 : T[t]) !== null && P !== void 0 ? P : [],
        { listener: e, options: i }
      ]
    } }), this;
  }
}
const Lu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ExponentialBackoff: dh,
  Websocket: Ba,
  WebsocketBuilder: ph,
  get WebsocketEvent() {
    return j;
  }
}, Symbol.toStringTag, { value: "Module" })), xs = 0, Ia = 1, Na = 2, ts = 2, Mn = 1.25, uo = 1, Ei = 32, rn = 65535, mh = Math.pow(2, -24), Pn = Symbol("SKIP_GENERATION");
function yh(n) {
  return n.index ? n.index.count : n.attributes.position.count;
}
function si(n) {
  return yh(n) / 3;
}
function gh(n, t = ArrayBuffer) {
  return n > 65535 ? new Uint32Array(new t(4 * n)) : new Uint16Array(new t(2 * n));
}
function vh(n, t) {
  if (!n.index) {
    const e = n.attributes.position.count, i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, r = gh(e, i);
    n.setIndex(new Mt(r, 1));
    for (let s = 0; s < e; s++)
      r[s] = s;
  }
}
function Ua(n, t) {
  const e = si(n), i = t || n.drawRange, r = i.start / 3, s = (i.start + i.count) / 3, a = Math.max(0, r), o = Math.min(e, s) - a;
  return [{
    offset: Math.floor(a),
    count: Math.floor(o)
  }];
}
function Fa(n, t) {
  if (!n.groups || !n.groups.length)
    return Ua(n, t);
  const e = [], i = /* @__PURE__ */ new Set(), r = t || n.drawRange, s = r.start / 3, a = (r.start + r.count) / 3;
  for (const c of n.groups) {
    const l = c.start / 3, h = (c.start + c.count) / 3;
    i.add(Math.max(s, l)), i.add(Math.min(a, h));
  }
  const o = Array.from(i.values()).sort((c, l) => c - l);
  for (let c = 0; c < o.length - 1; c++) {
    const l = o[c], h = o[c + 1];
    e.push({
      offset: Math.floor(l),
      count: Math.floor(h - l)
    });
  }
  return e;
}
function _h(n, t) {
  const e = si(n), i = Fa(n, t).sort((a, o) => a.offset - o.offset), r = i[i.length - 1];
  r.count = Math.min(e - r.offset, r.count);
  let s = 0;
  return i.forEach(({ count: a }) => s += a), e !== s;
}
function wn(n, t, e, i, r) {
  let s = 1 / 0, a = 1 / 0, o = 1 / 0, c = -1 / 0, l = -1 / 0, h = -1 / 0, u = 1 / 0, f = 1 / 0, d = 1 / 0, y = -1 / 0, _ = -1 / 0, p = -1 / 0;
  for (let m = t * 6, v = (t + e) * 6; m < v; m += 6) {
    const g = n[m + 0], b = n[m + 1], x = g - b, S = g + b;
    x < s && (s = x), S > c && (c = S), g < u && (u = g), g > y && (y = g);
    const T = n[m + 2], P = n[m + 3], M = T - P, C = T + P;
    M < a && (a = M), C > l && (l = C), T < f && (f = T), T > _ && (_ = T);
    const E = n[m + 4], w = n[m + 5], k = E - w, R = E + w;
    k < o && (o = k), R > h && (h = R), E < d && (d = E), E > p && (p = E);
  }
  i[0] = s, i[1] = a, i[2] = o, i[3] = c, i[4] = l, i[5] = h, r[0] = u, r[1] = f, r[2] = d, r[3] = y, r[4] = _, r[5] = p;
}
function xh(n, t = null, e = null, i = null) {
  const r = n.attributes.position, s = n.index ? n.index.array : null, a = si(n), o = r.normalized;
  let c;
  t === null ? (c = new Float32Array(a * 6), e = 0, i = a) : (c = t, e = e || 0, i = i || a);
  const l = r.array, h = r.offset || 0;
  let u = 3;
  r.isInterleavedBufferAttribute && (u = r.data.stride);
  const f = ["getX", "getY", "getZ"];
  for (let d = e; d < e + i; d++) {
    const y = d * 3, _ = d * 6;
    let p = y + 0, m = y + 1, v = y + 2;
    s && (p = s[p], m = s[m], v = s[v]), o || (p = p * u + h, m = m * u + h, v = v * u + h);
    for (let g = 0; g < 3; g++) {
      let b, x, S;
      o ? (b = r[f[g]](p), x = r[f[g]](m), S = r[f[g]](v)) : (b = l[p + g], x = l[m + g], S = l[v + g]);
      let T = b;
      x < T && (T = x), S < T && (T = S);
      let P = b;
      x > P && (P = x), S > P && (P = S);
      const M = (P - T) / 2, C = g * 2;
      c[_ + C + 0] = T + M, c[_ + C + 1] = M + (Math.abs(T) + M) * mh;
    }
  }
  return c;
}
function Z(n, t, e) {
  return e.min.x = t[n], e.min.y = t[n + 1], e.min.z = t[n + 2], e.max.x = t[n + 3], e.max.y = t[n + 4], e.max.z = t[n + 5], e;
}
function fo(n) {
  let t = -1, e = -1 / 0;
  for (let i = 0; i < 3; i++) {
    const r = n[i + 3] - n[i];
    r > e && (e = r, t = i);
  }
  return t;
}
function po(n, t) {
  t.set(n);
}
function mo(n, t, e) {
  let i, r;
  for (let s = 0; s < 3; s++) {
    const a = s + 3;
    i = n[s], r = t[s], e[s] = i < r ? i : r, i = n[a], r = t[a], e[a] = i > r ? i : r;
  }
}
function xr(n, t, e) {
  for (let i = 0; i < 3; i++) {
    const r = t[n + 2 * i], s = t[n + 2 * i + 1], a = r - s, o = r + s;
    a < e[i] && (e[i] = a), o > e[i + 3] && (e[i + 3] = o);
  }
}
function di(n) {
  const t = n[3] - n[0], e = n[4] - n[1], i = n[5] - n[2];
  return 2 * (t * e + e * i + i * t);
}
const ue = 32, bh = (n, t) => n.candidate - t.candidate, xe = new Array(ue).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
})), br = new Float32Array(6);
function Sh(n, t, e, i, r, s) {
  let a = -1, o = 0;
  if (s === xs)
    a = fo(t), a !== -1 && (o = (t[a] + t[a + 3]) / 2);
  else if (s === Ia)
    a = fo(n), a !== -1 && (o = Th(e, i, r, a));
  else if (s === Na) {
    const c = di(n);
    let l = Mn * r;
    const h = i * 6, u = (i + r) * 6;
    for (let f = 0; f < 3; f++) {
      const d = t[f], p = (t[f + 3] - d) / ue;
      if (r < ue / 4) {
        const m = [...xe];
        m.length = r;
        let v = 0;
        for (let b = h; b < u; b += 6, v++) {
          const x = m[v];
          x.candidate = e[b + 2 * f], x.count = 0;
          const {
            bounds: S,
            leftCacheBounds: T,
            rightCacheBounds: P
          } = x;
          for (let M = 0; M < 3; M++)
            P[M] = 1 / 0, P[M + 3] = -1 / 0, T[M] = 1 / 0, T[M + 3] = -1 / 0, S[M] = 1 / 0, S[M + 3] = -1 / 0;
          xr(b, e, S);
        }
        m.sort(bh);
        let g = r;
        for (let b = 0; b < g; b++) {
          const x = m[b];
          for (; b + 1 < g && m[b + 1].candidate === x.candidate; )
            m.splice(b + 1, 1), g--;
        }
        for (let b = h; b < u; b += 6) {
          const x = e[b + 2 * f];
          for (let S = 0; S < g; S++) {
            const T = m[S];
            x >= T.candidate ? xr(b, e, T.rightCacheBounds) : (xr(b, e, T.leftCacheBounds), T.count++);
          }
        }
        for (let b = 0; b < g; b++) {
          const x = m[b], S = x.count, T = r - x.count, P = x.leftCacheBounds, M = x.rightCacheBounds;
          let C = 0;
          S !== 0 && (C = di(P) / c);
          let E = 0;
          T !== 0 && (E = di(M) / c);
          const w = uo + Mn * (C * S + E * T);
          w < l && (a = f, l = w, o = x.candidate);
        }
      } else {
        for (let g = 0; g < ue; g++) {
          const b = xe[g];
          b.count = 0, b.candidate = d + p + g * p;
          const x = b.bounds;
          for (let S = 0; S < 3; S++)
            x[S] = 1 / 0, x[S + 3] = -1 / 0;
        }
        for (let g = h; g < u; g += 6) {
          let S = ~~((e[g + 2 * f] - d) / p);
          S >= ue && (S = ue - 1);
          const T = xe[S];
          T.count++, xr(g, e, T.bounds);
        }
        const m = xe[ue - 1];
        po(m.bounds, m.rightCacheBounds);
        for (let g = ue - 2; g >= 0; g--) {
          const b = xe[g], x = xe[g + 1];
          mo(b.bounds, x.rightCacheBounds, b.rightCacheBounds);
        }
        let v = 0;
        for (let g = 0; g < ue - 1; g++) {
          const b = xe[g], x = b.count, S = b.bounds, P = xe[g + 1].rightCacheBounds;
          x !== 0 && (v === 0 ? po(S, br) : mo(S, br, br)), v += x;
          let M = 0, C = 0;
          v !== 0 && (M = di(br) / c);
          const E = r - v;
          E !== 0 && (C = di(P) / c);
          const w = uo + Mn * (M * v + C * E);
          w < l && (a = f, l = w, o = b.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);
  return { axis: a, pos: o };
}
function Th(n, t, e, i) {
  let r = 0;
  for (let s = t, a = t + e; s < a; s++)
    r += n[s * 6 + i * 2];
  return r / e;
}
class En {
  constructor() {
    this.boundingData = new Float32Array(6);
  }
}
function Ch(n, t, e, i, r, s) {
  let a = i, o = i + r - 1;
  const c = s.pos, l = s.axis * 2;
  for (; ; ) {
    for (; a <= o && e[a * 6 + l] < c; )
      a++;
    for (; a <= o && e[o * 6 + l] >= c; )
      o--;
    if (a < o) {
      for (let h = 0; h < 3; h++) {
        let u = t[a * 3 + h];
        t[a * 3 + h] = t[o * 3 + h], t[o * 3 + h] = u;
      }
      for (let h = 0; h < 6; h++) {
        let u = e[a * 6 + h];
        e[a * 6 + h] = e[o * 6 + h], e[o * 6 + h] = u;
      }
      a++, o--;
    } else
      return a;
  }
}
function Mh(n, t, e, i, r, s) {
  let a = i, o = i + r - 1;
  const c = s.pos, l = s.axis * 2;
  for (; ; ) {
    for (; a <= o && e[a * 6 + l] < c; )
      a++;
    for (; a <= o && e[o * 6 + l] >= c; )
      o--;
    if (a < o) {
      let h = n[a];
      n[a] = n[o], n[o] = h;
      for (let u = 0; u < 6; u++) {
        let f = e[a * 6 + u];
        e[a * 6 + u] = e[o * 6 + u], e[o * 6 + u] = f;
      }
      a++, o--;
    } else
      return a;
  }
}
function Tt(n, t) {
  return t[n + 15] === 65535;
}
function Pt(n, t) {
  return t[n + 6];
}
function kt(n, t) {
  return t[n + 14];
}
function Rt(n) {
  return n + 8;
}
function At(n, t) {
  return t[n + 6];
}
function Da(n, t) {
  return t[n + 7];
}
let La, Ci, Jr, Va;
const Ph = Math.pow(2, 32);
function es(n) {
  return "count" in n ? 1 : 1 + es(n.left) + es(n.right);
}
function wh(n, t, e) {
  return La = new Float32Array(e), Ci = new Uint32Array(e), Jr = new Uint16Array(e), Va = new Uint8Array(e), is(n, t);
}
function is(n, t) {
  const e = n / 4, i = n / 2, r = "count" in t, s = t.boundingData;
  for (let a = 0; a < 6; a++)
    La[e + a] = s[a];
  if (r)
    if (t.buffer) {
      const a = t.buffer;
      Va.set(new Uint8Array(a), n);
      for (let o = n, c = n + a.byteLength; o < c; o += Ei) {
        const l = o / 2;
        Tt(l, Jr) || (Ci[o / 4 + 6] += e);
      }
      return n + a.byteLength;
    } else {
      const a = t.offset, o = t.count;
      return Ci[e + 6] = a, Jr[i + 14] = o, Jr[i + 15] = rn, n + Ei;
    }
  else {
    const a = t.left, o = t.right, c = t.splitAxis;
    let l;
    if (l = is(n + Ei, a), l / 4 > Ph)
      throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
    return Ci[e + 6] = l / 4, l = is(l, o), Ci[e + 7] = c, l;
  }
}
function Eh(n, t) {
  const e = (n.index ? n.index.count : n.attributes.position.count) / 3, i = e > 2 ** 16, r = i ? 4 : 2, s = t ? new SharedArrayBuffer(e * r) : new ArrayBuffer(e * r), a = i ? new Uint32Array(s) : new Uint16Array(s);
  for (let o = 0, c = a.length; o < c; o++)
    a[o] = o;
  return a;
}
function kh(n, t, e, i, r) {
  const {
    maxDepth: s,
    verbose: a,
    maxLeafTris: o,
    strategy: c,
    onProgress: l,
    indirect: h
  } = r, u = n._indirectBuffer, f = n.geometry, d = f.index ? f.index.array : null, y = h ? Mh : Ch, _ = si(f), p = new Float32Array(6);
  let m = !1;
  const v = new En();
  return wn(t, e, i, v.boundingData, p), b(v, e, i, p), v;
  function g(x) {
    l && l(x / _);
  }
  function b(x, S, T, P = null, M = 0) {
    if (!m && M >= s && (m = !0, a && (console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`), console.warn(f))), T <= o || M >= s)
      return g(S + T), x.offset = S, x.count = T, x;
    const C = Sh(x.boundingData, P, t, S, T, c);
    if (C.axis === -1)
      return g(S + T), x.offset = S, x.count = T, x;
    const E = y(u, d, t, S, T, C);
    if (E === S || E === S + T)
      g(S + T), x.offset = S, x.count = T;
    else {
      x.splitAxis = C.axis;
      const w = new En(), k = S, R = E - S;
      x.left = w, wn(t, k, R, w.boundingData, p), b(w, k, R, p, M + 1);
      const z = new En(), U = E, L = T - R;
      x.right = z, wn(t, U, L, z.boundingData, p), b(z, U, L, p, M + 1);
    }
    return x;
  }
}
function Rh(n, t) {
  const e = n.geometry;
  t.indirect && (n._indirectBuffer = Eh(e, t.useSharedArrayBuffer), _h(e, t.range) && !t.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), n._indirectBuffer || vh(e, t);
  const i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, r = xh(e), s = t.indirect ? Ua(e, t.range) : Fa(e, t.range);
  n._roots = s.map((a) => {
    const o = kh(n, r, a.offset, a.count, t), c = es(o), l = new i(Ei * c);
    return wh(0, o, l), l;
  });
}
class ge {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, e) {
    let i = 1 / 0, r = -1 / 0;
    for (let s = 0, a = t.length; s < a; s++) {
      const c = t[s][e];
      i = c < i ? c : i, r = c > r ? c : r;
    }
    this.min = i, this.max = r;
  }
  setFromPoints(t, e) {
    let i = 1 / 0, r = -1 / 0;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s], c = t.dot(o);
      i = c < i ? c : i, r = c > r ? c : r;
    }
    this.min = i, this.max = r;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
}
ge.prototype.setFromBox = (function() {
  const n = new N();
  return function(e, i) {
    const r = i.min, s = i.max;
    let a = 1 / 0, o = -1 / 0;
    for (let c = 0; c <= 1; c++)
      for (let l = 0; l <= 1; l++)
        for (let h = 0; h <= 1; h++) {
          n.x = r.x * c + s.x * (1 - c), n.y = r.y * l + s.y * (1 - l), n.z = r.z * h + s.z * (1 - h);
          const u = e.dot(n);
          a = Math.min(u, a), o = Math.max(u, o);
        }
    this.min = a, this.max = o;
  };
})();
const Ah = (function() {
  const n = new N(), t = new N(), e = new N();
  return function(r, s, a) {
    const o = r.start, c = n, l = s.start, h = t;
    e.subVectors(o, l), n.subVectors(r.end, r.start), t.subVectors(s.end, s.start);
    const u = e.dot(h), f = h.dot(c), d = h.dot(h), y = e.dot(c), p = c.dot(c) * d - f * f;
    let m, v;
    p !== 0 ? m = (u * f - y * d) / p : m = 0, v = (u + m * f) / d, a.x = m, a.y = v;
  };
})(), bs = (function() {
  const n = new Ke(), t = new N(), e = new N();
  return function(r, s, a, o) {
    Ah(r, s, n);
    let c = n.x, l = n.y;
    if (c >= 0 && c <= 1 && l >= 0 && l <= 1) {
      r.at(c, a), s.at(l, o);
      return;
    } else if (c >= 0 && c <= 1) {
      l < 0 ? s.at(0, o) : s.at(1, o), r.closestPointToPoint(o, !0, a);
      return;
    } else if (l >= 0 && l <= 1) {
      c < 0 ? r.at(0, a) : r.at(1, a), s.closestPointToPoint(a, !0, o);
      return;
    } else {
      let h;
      c < 0 ? h = r.start : h = r.end;
      let u;
      l < 0 ? u = s.start : u = s.end;
      const f = t, d = e;
      if (r.closestPointToPoint(u, !0, t), s.closestPointToPoint(h, !0, e), f.distanceToSquared(u) <= d.distanceToSquared(h)) {
        a.copy(f), o.copy(u);
        return;
      } else {
        a.copy(h), o.copy(d);
        return;
      }
    }
  };
})(), zh = (function() {
  const n = new N(), t = new N(), e = new Io(), i = new me();
  return function(s, a) {
    const { radius: o, center: c } = s, { a: l, b: h, c: u } = a;
    if (i.start = l, i.end = h, i.closestPointToPoint(c, !0, n).distanceTo(c) <= o || (i.start = l, i.end = u, i.closestPointToPoint(c, !0, n).distanceTo(c) <= o) || (i.start = h, i.end = u, i.closestPointToPoint(c, !0, n).distanceTo(c) <= o)) return !0;
    const _ = a.getPlane(e);
    if (Math.abs(_.distanceToPoint(c)) <= o) {
      const m = _.projectPoint(c, t);
      if (a.containsPoint(m)) return !0;
    }
    return !1;
  };
})(), Oh = 1e-15;
function kn(n) {
  return Math.abs(n) < Oh;
}
class Ot extends Ue {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new N()), this.satBounds = new Array(4).fill().map(() => new ge()), this.points = [this.a, this.b, this.c], this.sphere = new No(), this.plane = new Io(), this.needsUpdate = !0;
  }
  intersectsSphere(t) {
    return zh(t, this);
  }
  update() {
    const t = this.a, e = this.b, i = this.c, r = this.points, s = this.satAxes, a = this.satBounds, o = s[0], c = a[0];
    this.getNormal(o), c.setFromPoints(o, r);
    const l = s[1], h = a[1];
    l.subVectors(t, e), h.setFromPoints(l, r);
    const u = s[2], f = a[2];
    u.subVectors(e, i), f.setFromPoints(u, r);
    const d = s[3], y = a[3];
    d.subVectors(i, t), y.setFromPoints(d, r), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, t), this.needsUpdate = !1;
  }
}
Ot.prototype.closestPointToSegment = (function() {
  const n = new N(), t = new N(), e = new me();
  return function(r, s = null, a = null) {
    const { start: o, end: c } = r, l = this.points;
    let h, u = 1 / 0;
    for (let f = 0; f < 3; f++) {
      const d = (f + 1) % 3;
      e.start.copy(l[f]), e.end.copy(l[d]), bs(e, r, n, t), h = n.distanceToSquared(t), h < u && (u = h, s && s.copy(n), a && a.copy(t));
    }
    return this.closestPointToPoint(o, n), h = o.distanceToSquared(n), h < u && (u = h, s && s.copy(n), a && a.copy(o)), this.closestPointToPoint(c, n), h = c.distanceToSquared(n), h < u && (u = h, s && s.copy(n), a && a.copy(c)), Math.sqrt(u);
  };
})();
Ot.prototype.intersectsTriangle = (function() {
  const n = new Ot(), t = new Array(3), e = new Array(3), i = new ge(), r = new ge(), s = new N(), a = new N(), o = new N(), c = new N(), l = new N(), h = new me(), u = new me(), f = new me(), d = new N();
  function y(_, p, m) {
    const v = _.points;
    let g = 0, b = -1;
    for (let x = 0; x < 3; x++) {
      const { start: S, end: T } = h;
      S.copy(v[x]), T.copy(v[(x + 1) % 3]), h.delta(a);
      const P = kn(p.distanceToPoint(S));
      if (kn(p.normal.dot(a)) && P) {
        m.copy(h), g = 2;
        break;
      }
      const M = p.intersectLine(h, d);
      if (!M && P && d.copy(S), (M || P) && !kn(d.distanceTo(T))) {
        if (g <= 1)
          (g === 1 ? m.start : m.end).copy(d), P && (b = g);
        else if (g >= 2) {
          (b === 1 ? m.start : m.end).copy(d), g = 2;
          break;
        }
        if (g++, g === 2 && b === -1)
          break;
      }
    }
    return g;
  }
  return function(p, m = null, v = !1) {
    this.needsUpdate && this.update(), p.isExtendedTriangle ? p.needsUpdate && p.update() : (n.copy(p), n.update(), p = n);
    const g = this.plane, b = p.plane;
    if (Math.abs(g.normal.dot(b.normal)) > 1 - 1e-10) {
      const x = this.satBounds, S = this.satAxes;
      e[0] = p.a, e[1] = p.b, e[2] = p.c;
      for (let M = 0; M < 4; M++) {
        const C = x[M], E = S[M];
        if (i.setFromPoints(E, e), C.isSeparated(i)) return !1;
      }
      const T = p.satBounds, P = p.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let M = 0; M < 4; M++) {
        const C = T[M], E = P[M];
        if (i.setFromPoints(E, t), C.isSeparated(i)) return !1;
      }
      for (let M = 0; M < 4; M++) {
        const C = S[M];
        for (let E = 0; E < 4; E++) {
          const w = P[E];
          if (s.crossVectors(C, w), i.setFromPoints(s, t), r.setFromPoints(s, e), i.isSeparated(r)) return !1;
        }
      }
      return m && (v || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), m.start.set(0, 0, 0), m.end.set(0, 0, 0)), !0;
    } else {
      const x = y(this, b, u);
      if (x === 1 && p.containsPoint(u.end))
        return m && (m.start.copy(u.end), m.end.copy(u.end)), !0;
      if (x !== 2)
        return !1;
      const S = y(p, g, f);
      if (S === 1 && this.containsPoint(f.end))
        return m && (m.start.copy(f.end), m.end.copy(f.end)), !0;
      if (S !== 2)
        return !1;
      if (u.delta(o), f.delta(c), o.dot(c) < 0) {
        let k = f.start;
        f.start = f.end, f.end = k;
      }
      const T = u.start.dot(o), P = u.end.dot(o), M = f.start.dot(o), C = f.end.dot(o), E = P < M, w = T < C;
      return T !== C && M !== P && E === w ? !1 : (m && (l.subVectors(u.start, f.start), l.dot(o) > 0 ? m.start.copy(u.start) : m.start.copy(f.start), l.subVectors(u.end, f.end), l.dot(o) < 0 ? m.end.copy(u.end) : m.end.copy(f.end)), !0);
    }
  };
})();
Ot.prototype.distanceToPoint = (function() {
  const n = new N();
  return function(e) {
    return this.closestPointToPoint(e, n), e.distanceTo(n);
  };
})();
Ot.prototype.distanceToTriangle = (function() {
  const n = new N(), t = new N(), e = ["a", "b", "c"], i = new me(), r = new me();
  return function(a, o = null, c = null) {
    const l = o || c ? i : null;
    if (this.intersectsTriangle(a, l))
      return (o || c) && (o && l.getCenter(o), c && l.getCenter(c)), 0;
    let h = 1 / 0;
    for (let u = 0; u < 3; u++) {
      let f;
      const d = e[u], y = a[d];
      this.closestPointToPoint(y, n), f = y.distanceToSquared(n), f < h && (h = f, o && o.copy(n), c && c.copy(y));
      const _ = this[d];
      a.closestPointToPoint(_, n), f = _.distanceToSquared(n), f < h && (h = f, o && o.copy(_), c && c.copy(n));
    }
    for (let u = 0; u < 3; u++) {
      const f = e[u], d = e[(u + 1) % 3];
      i.set(this[f], this[d]);
      for (let y = 0; y < 3; y++) {
        const _ = e[y], p = e[(y + 1) % 3];
        r.set(a[_], a[p]), bs(i, r, n, t);
        const m = n.distanceToSquared(t);
        m < h && (h = m, o && o.copy(n), c && c.copy(t));
      }
    }
    return Math.sqrt(h);
  };
})();
class pt {
  constructor(t, e, i) {
    this.isOrientedBox = !0, this.min = new N(), this.max = new N(), this.matrix = new Gt(), this.invMatrix = new Gt(), this.points = new Array(8).fill().map(() => new N()), this.satAxes = new Array(3).fill().map(() => new N()), this.satBounds = new Array(3).fill().map(() => new ge()), this.alignedSatBounds = new Array(3).fill().map(() => new ge()), this.needsUpdate = !1, t && this.min.copy(t), e && this.max.copy(e), i && this.matrix.copy(i);
  }
  set(t, e, i) {
    this.min.copy(t), this.max.copy(e), this.matrix.copy(i), this.needsUpdate = !0;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = !0;
  }
}
pt.prototype.update = /* @__PURE__ */ (function() {
  return function() {
    const t = this.matrix, e = this.min, i = this.max, r = this.points;
    for (let l = 0; l <= 1; l++)
      for (let h = 0; h <= 1; h++)
        for (let u = 0; u <= 1; u++) {
          const f = 1 * l | 2 * h | 4 * u, d = r[f];
          d.x = l ? i.x : e.x, d.y = h ? i.y : e.y, d.z = u ? i.z : e.z, d.applyMatrix4(t);
        }
    const s = this.satBounds, a = this.satAxes, o = r[0];
    for (let l = 0; l < 3; l++) {
      const h = a[l], u = s[l], f = 1 << l, d = r[f];
      h.subVectors(o, d), u.setFromPoints(h, r);
    }
    const c = this.alignedSatBounds;
    c[0].setFromPointsField(r, "x"), c[1].setFromPointsField(r, "y"), c[2].setFromPointsField(r, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
  };
})();
pt.prototype.intersectsBox = (function() {
  const n = new ge();
  return function(e) {
    this.needsUpdate && this.update();
    const i = e.min, r = e.max, s = this.satBounds, a = this.satAxes, o = this.alignedSatBounds;
    if (n.min = i.x, n.max = r.x, o[0].isSeparated(n) || (n.min = i.y, n.max = r.y, o[1].isSeparated(n)) || (n.min = i.z, n.max = r.z, o[2].isSeparated(n))) return !1;
    for (let c = 0; c < 3; c++) {
      const l = a[c], h = s[c];
      if (n.setFromBox(l, e), h.isSeparated(n)) return !1;
    }
    return !0;
  };
})();
pt.prototype.intersectsTriangle = (function() {
  const n = new Ot(), t = new Array(3), e = new ge(), i = new ge(), r = new N();
  return function(a) {
    this.needsUpdate && this.update(), a.isExtendedTriangle ? a.needsUpdate && a.update() : (n.copy(a), n.update(), a = n);
    const o = this.satBounds, c = this.satAxes;
    t[0] = a.a, t[1] = a.b, t[2] = a.c;
    for (let f = 0; f < 3; f++) {
      const d = o[f], y = c[f];
      if (e.setFromPoints(y, t), d.isSeparated(e)) return !1;
    }
    const l = a.satBounds, h = a.satAxes, u = this.points;
    for (let f = 0; f < 3; f++) {
      const d = l[f], y = h[f];
      if (e.setFromPoints(y, u), d.isSeparated(e)) return !1;
    }
    for (let f = 0; f < 3; f++) {
      const d = c[f];
      for (let y = 0; y < 4; y++) {
        const _ = h[y];
        if (r.crossVectors(d, _), e.setFromPoints(r, t), i.setFromPoints(r, u), e.isSeparated(i)) return !1;
      }
    }
    return !0;
  };
})();
pt.prototype.closestPointToPoint = /* @__PURE__ */ (function() {
  return function(t, e) {
    return this.needsUpdate && this.update(), e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), e;
  };
})();
pt.prototype.distanceToPoint = (function() {
  const n = new N();
  return function(e) {
    return this.closestPointToPoint(e, n), e.distanceTo(n);
  };
})();
pt.prototype.distanceToBox = (function() {
  const n = ["x", "y", "z"], t = new Array(12).fill().map(() => new me()), e = new Array(12).fill().map(() => new me()), i = new N(), r = new N();
  return function(a, o = 0, c = null, l = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(a))
      return (c || l) && (a.getCenter(r), this.closestPointToPoint(r, i), a.closestPointToPoint(i, r), c && c.copy(i), l && l.copy(r)), 0;
    const h = o * o, u = a.min, f = a.max, d = this.points;
    let y = 1 / 0;
    for (let p = 0; p < 8; p++) {
      const m = d[p];
      r.copy(m).clamp(u, f);
      const v = m.distanceToSquared(r);
      if (v < y && (y = v, c && c.copy(m), l && l.copy(r), v < h))
        return Math.sqrt(v);
    }
    let _ = 0;
    for (let p = 0; p < 3; p++)
      for (let m = 0; m <= 1; m++)
        for (let v = 0; v <= 1; v++) {
          const g = (p + 1) % 3, b = (p + 2) % 3, x = m << g | v << b, S = 1 << p | m << g | v << b, T = d[x], P = d[S];
          t[_].set(T, P);
          const C = n[p], E = n[g], w = n[b], k = e[_], R = k.start, z = k.end;
          R[C] = u[C], R[E] = m ? u[E] : f[E], R[w] = v ? u[w] : f[E], z[C] = f[C], z[E] = m ? u[E] : f[E], z[w] = v ? u[w] : f[E], _++;
        }
    for (let p = 0; p <= 1; p++)
      for (let m = 0; m <= 1; m++)
        for (let v = 0; v <= 1; v++) {
          r.x = p ? f.x : u.x, r.y = m ? f.y : u.y, r.z = v ? f.z : u.z, this.closestPointToPoint(r, i);
          const g = r.distanceToSquared(i);
          if (g < y && (y = g, c && c.copy(i), l && l.copy(r), g < h))
            return Math.sqrt(g);
        }
    for (let p = 0; p < 12; p++) {
      const m = t[p];
      for (let v = 0; v < 12; v++) {
        const g = e[v];
        bs(m, g, i, r);
        const b = i.distanceToSquared(r);
        if (b < y && (y = b, c && c.copy(i), l && l.copy(r), b < h))
          return Math.sqrt(b);
      }
    }
    return Math.sqrt(y);
  };
})();
class Ss {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
}
class Bh extends Ss {
  constructor() {
    super(() => new Ot());
  }
}
const zt = /* @__PURE__ */ new Bh();
class Ih {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t = [];
    let e = null;
    this.setBuffer = (i) => {
      e && t.push(e), e = i, this.float32Array = new Float32Array(i), this.uint16Array = new Uint16Array(i), this.uint32Array = new Uint32Array(i);
    }, this.clearBuffer = () => {
      e = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, t.length !== 0 && this.setBuffer(t.pop());
    };
  }
}
const q = new Ih();
let Ce, Ze;
const Ge = [], Sr = /* @__PURE__ */ new Ss(() => new te());
function Nh(n, t, e, i, r, s) {
  Ce = Sr.getPrimitive(), Ze = Sr.getPrimitive(), Ge.push(Ce, Ze), q.setBuffer(n._roots[t]);
  const a = rs(0, n.geometry, e, i, r, s);
  q.clearBuffer(), Sr.releasePrimitive(Ce), Sr.releasePrimitive(Ze), Ge.pop(), Ge.pop();
  const o = Ge.length;
  return o > 0 && (Ze = Ge[o - 1], Ce = Ge[o - 2]), a;
}
function rs(n, t, e, i, r = null, s = 0, a = 0) {
  const { float32Array: o, uint16Array: c, uint32Array: l } = q;
  let h = n * 2;
  if (Tt(h, c)) {
    const f = Pt(n, l), d = kt(h, c);
    return Z(n, o, Ce), i(f, d, !1, a, s + n, Ce);
  } else {
    let C = function(w) {
      const { uint16Array: k, uint32Array: R } = q;
      let z = w * 2;
      for (; !Tt(z, k); )
        w = Rt(w), z = w * 2;
      return Pt(w, R);
    }, E = function(w) {
      const { uint16Array: k, uint32Array: R } = q;
      let z = w * 2;
      for (; !Tt(z, k); )
        w = At(w, R), z = w * 2;
      return Pt(w, R) + kt(z, k);
    };
    const f = Rt(n), d = At(n, l);
    let y = f, _ = d, p, m, v, g;
    if (r && (v = Ce, g = Ze, Z(y, o, v), Z(_, o, g), p = r(v), m = r(g), m < p)) {
      y = d, _ = f;
      const w = p;
      p = m, m = w, v = g;
    }
    v || (v = Ce, Z(y, o, v));
    const b = Tt(y * 2, c), x = e(v, b, p, a + 1, s + y);
    let S;
    if (x === ts) {
      const w = C(y), R = E(y) - w;
      S = i(w, R, !0, a + 1, s + y, v);
    } else
      S = x && rs(
        y,
        t,
        e,
        i,
        r,
        s,
        a + 1
      );
    if (S) return !0;
    g = Ze, Z(_, o, g);
    const T = Tt(_ * 2, c), P = e(g, T, m, a + 1, s + _);
    let M;
    if (P === ts) {
      const w = C(_), R = E(_) - w;
      M = i(w, R, !0, a + 1, s + _, g);
    } else
      M = P && rs(
        _,
        t,
        e,
        i,
        r,
        s,
        a + 1
      );
    return !!M;
  }
}
const pi = /* @__PURE__ */ new N(), Rn = /* @__PURE__ */ new N();
function Uh(n, t, e = {}, i = 0, r = 1 / 0) {
  const s = i * i, a = r * r;
  let o = 1 / 0, c = null;
  if (n.shapecast(
    {
      boundsTraverseOrder: (h) => (pi.copy(t).clamp(h.min, h.max), pi.distanceToSquared(t)),
      intersectsBounds: (h, u, f) => f < o && f < a,
      intersectsTriangle: (h, u) => {
        h.closestPointToPoint(t, pi);
        const f = t.distanceToSquared(pi);
        return f < o && (Rn.copy(pi), o = f, c = u), f < s;
      }
    }
  ), o === 1 / 0) return null;
  const l = Math.sqrt(o);
  return e.point ? e.point.copy(Rn) : e.point = Rn.clone(), e.distance = l, e.faceIndex = c, e;
}
const Fh = parseInt(Ha) >= 169, Re = /* @__PURE__ */ new N(), Ae = /* @__PURE__ */ new N(), ze = /* @__PURE__ */ new N(), Tr = /* @__PURE__ */ new Ke(), Cr = /* @__PURE__ */ new Ke(), Mr = /* @__PURE__ */ new Ke(), yo = /* @__PURE__ */ new N(), go = /* @__PURE__ */ new N(), vo = /* @__PURE__ */ new N(), mi = /* @__PURE__ */ new N();
function Dh(n, t, e, i, r, s, a, o) {
  let c;
  if (s === Xa ? c = n.intersectTriangle(i, e, t, !0, r) : c = n.intersectTriangle(t, e, i, s !== Fn, r), c === null) return null;
  const l = n.origin.distanceTo(r);
  return l < a || l > o ? null : {
    distance: l,
    point: r.clone()
  };
}
function Lh(n, t, e, i, r, s, a, o, c, l, h) {
  Re.fromBufferAttribute(t, s), Ae.fromBufferAttribute(t, a), ze.fromBufferAttribute(t, o);
  const u = Dh(n, Re, Ae, ze, mi, c, l, h);
  if (u) {
    const f = new N();
    Ue.getBarycoord(mi, Re, Ae, ze, f), i && (Tr.fromBufferAttribute(i, s), Cr.fromBufferAttribute(i, a), Mr.fromBufferAttribute(i, o), u.uv = Ue.getInterpolation(mi, Re, Ae, ze, Tr, Cr, Mr, new Ke())), r && (Tr.fromBufferAttribute(r, s), Cr.fromBufferAttribute(r, a), Mr.fromBufferAttribute(r, o), u.uv1 = Ue.getInterpolation(mi, Re, Ae, ze, Tr, Cr, Mr, new Ke())), e && (yo.fromBufferAttribute(e, s), go.fromBufferAttribute(e, a), vo.fromBufferAttribute(e, o), u.normal = Ue.getInterpolation(mi, Re, Ae, ze, yo, go, vo, new N()), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = {
      a: s,
      b: a,
      c: o,
      normal: new N(),
      materialIndex: 0
    };
    Ue.getNormal(Re, Ae, ze, d.normal), u.face = d, u.faceIndex = s, Fh && (u.barycoord = f);
  }
  return u;
}
function nn(n, t, e, i, r, s, a) {
  const o = i * 3;
  let c = o + 0, l = o + 1, h = o + 2;
  const u = n.index;
  n.index && (c = u.getX(c), l = u.getX(l), h = u.getX(h));
  const { position: f, normal: d, uv: y, uv1: _ } = n.attributes, p = Lh(e, f, d, y, _, c, l, h, t, s, a);
  return p ? (p.faceIndex = i, r && r.push(p), p) : null;
}
function it(n, t, e, i) {
  const r = n.a, s = n.b, a = n.c;
  let o = t, c = t + 1, l = t + 2;
  e && (o = e.getX(o), c = e.getX(c), l = e.getX(l)), r.x = i.getX(o), r.y = i.getY(o), r.z = i.getZ(o), s.x = i.getX(c), s.y = i.getY(c), s.z = i.getZ(c), a.x = i.getX(l), a.y = i.getY(l), a.z = i.getZ(l);
}
function Vh(n, t, e, i, r, s, a, o) {
  const { geometry: c, _indirectBuffer: l } = n;
  for (let h = i, u = i + r; h < u; h++)
    nn(c, t, e, h, s, a, o);
}
function Jh(n, t, e, i, r, s, a) {
  const { geometry: o, _indirectBuffer: c } = n;
  let l = 1 / 0, h = null;
  for (let u = i, f = i + r; u < f; u++) {
    let d;
    d = nn(o, t, e, u, null, s, a), d && d.distance < l && (h = d, l = d.distance);
  }
  return h;
}
function Gh(n, t, e, i, r, s, a) {
  const { geometry: o } = e, { index: c } = o, l = o.attributes.position;
  for (let h = n, u = t + n; h < u; h++) {
    let f;
    if (f = h, it(a, f * 3, c, l), a.needsUpdate = !0, i(a, f, r, s))
      return !0;
  }
  return !1;
}
function jh(n, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = n.geometry, i = e.index ? e.index.array : null, r = e.attributes.position;
  let s, a, o, c, l = 0;
  const h = n._roots;
  for (let f = 0, d = h.length; f < d; f++)
    s = h[f], a = new Uint32Array(s), o = new Uint16Array(s), c = new Float32Array(s), u(0, l), l += s.byteLength;
  function u(f, d, y = !1) {
    const _ = f * 2;
    if (o[_ + 15] === rn) {
      const m = a[f + 6], v = o[_ + 14];
      let g = 1 / 0, b = 1 / 0, x = 1 / 0, S = -1 / 0, T = -1 / 0, P = -1 / 0;
      for (let M = 3 * m, C = 3 * (m + v); M < C; M++) {
        let E = i[M];
        const w = r.getX(E), k = r.getY(E), R = r.getZ(E);
        w < g && (g = w), w > S && (S = w), k < b && (b = k), k > T && (T = k), R < x && (x = R), R > P && (P = R);
      }
      return c[f + 0] !== g || c[f + 1] !== b || c[f + 2] !== x || c[f + 3] !== S || c[f + 4] !== T || c[f + 5] !== P ? (c[f + 0] = g, c[f + 1] = b, c[f + 2] = x, c[f + 3] = S, c[f + 4] = T, c[f + 5] = P, !0) : !1;
    } else {
      const m = f + 8, v = a[f + 6], g = m + d, b = v + d;
      let x = y, S = !1, T = !1;
      t ? x || (S = t.has(g), T = t.has(b), x = !S && !T) : (S = !0, T = !0);
      const P = x || S, M = x || T;
      let C = !1;
      P && (C = u(m, d, x));
      let E = !1;
      M && (E = u(v, d, x));
      const w = C || E;
      if (w)
        for (let k = 0; k < 3; k++) {
          const R = m + k, z = v + k, U = c[R], L = c[R + 3], I = c[z], H = c[z + 3];
          c[f + k] = U < I ? U : I, c[f + k + 3] = L > H ? L : H;
        }
      return w;
    }
  }
}
function Me(n, t, e, i, r) {
  let s, a, o, c, l, h;
  const u = 1 / e.direction.x, f = 1 / e.direction.y, d = 1 / e.direction.z, y = e.origin.x, _ = e.origin.y, p = e.origin.z;
  let m = t[n], v = t[n + 3], g = t[n + 1], b = t[n + 3 + 1], x = t[n + 2], S = t[n + 3 + 2];
  return u >= 0 ? (s = (m - y) * u, a = (v - y) * u) : (s = (v - y) * u, a = (m - y) * u), f >= 0 ? (o = (g - _) * f, c = (b - _) * f) : (o = (b - _) * f, c = (g - _) * f), s > c || o > a || ((o > s || isNaN(s)) && (s = o), (c < a || isNaN(a)) && (a = c), d >= 0 ? (l = (x - p) * d, h = (S - p) * d) : (l = (S - p) * d, h = (x - p) * d), s > h || l > a) ? !1 : ((l > s || s !== s) && (s = l), (h < a || a !== a) && (a = h), s <= r && a >= i);
}
function $h(n, t, e, i, r, s, a, o) {
  const { geometry: c, _indirectBuffer: l } = n;
  for (let h = i, u = i + r; h < u; h++) {
    let f = l ? l[h] : h;
    nn(c, t, e, f, s, a, o);
  }
}
function qh(n, t, e, i, r, s, a) {
  const { geometry: o, _indirectBuffer: c } = n;
  let l = 1 / 0, h = null;
  for (let u = i, f = i + r; u < f; u++) {
    let d;
    d = nn(o, t, e, c ? c[u] : u, null, s, a), d && d.distance < l && (h = d, l = d.distance);
  }
  return h;
}
function Xh(n, t, e, i, r, s, a) {
  const { geometry: o } = e, { index: c } = o, l = o.attributes.position;
  for (let h = n, u = t + n; h < u; h++) {
    let f;
    if (f = e.resolveTriangleIndex(h), it(a, f * 3, c, l), a.needsUpdate = !0, i(a, f, r, s))
      return !0;
  }
  return !1;
}
function Hh(n, t, e, i, r, s, a) {
  q.setBuffer(n._roots[t]), ns(0, n, e, i, r, s, a), q.clearBuffer();
}
function ns(n, t, e, i, r, s, a) {
  const { float32Array: o, uint16Array: c, uint32Array: l } = q, h = n * 2;
  if (Tt(h, c)) {
    const f = Pt(n, l), d = kt(h, c);
    Vh(t, e, i, f, d, r, s, a);
  } else {
    const f = Rt(n);
    Me(f, o, i, s, a) && ns(f, t, e, i, r, s, a);
    const d = At(n, l);
    Me(d, o, i, s, a) && ns(d, t, e, i, r, s, a);
  }
}
const Wh = ["x", "y", "z"];
function Yh(n, t, e, i, r, s) {
  q.setBuffer(n._roots[t]);
  const a = ss(0, n, e, i, r, s);
  return q.clearBuffer(), a;
}
function ss(n, t, e, i, r, s) {
  const { float32Array: a, uint16Array: o, uint32Array: c } = q;
  let l = n * 2;
  if (Tt(l, o)) {
    const u = Pt(n, c), f = kt(l, o);
    return Jh(t, e, i, u, f, r, s);
  } else {
    const u = Da(n, c), f = Wh[u], y = i.direction[f] >= 0;
    let _, p;
    y ? (_ = Rt(n), p = At(n, c)) : (_ = At(n, c), p = Rt(n));
    const v = Me(_, a, i, r, s) ? ss(_, t, e, i, r, s) : null;
    if (v) {
      const x = v.point[f];
      if (y ? x <= a[p + u] : (
        // min bounding data
        x >= a[p + u + 3]
      ))
        return v;
    }
    const b = Me(p, a, i, r, s) ? ss(p, t, e, i, r, s) : null;
    return v && b ? v.distance <= b.distance ? v : b : v || b || null;
  }
}
const Pr = /* @__PURE__ */ new te(), je = /* @__PURE__ */ new Ot(), $e = /* @__PURE__ */ new Ot(), yi = /* @__PURE__ */ new Gt(), _o = /* @__PURE__ */ new pt(), wr = /* @__PURE__ */ new pt();
function Zh(n, t, e, i) {
  q.setBuffer(n._roots[t]);
  const r = os(0, n, e, i);
  return q.clearBuffer(), r;
}
function os(n, t, e, i, r = null) {
  const { float32Array: s, uint16Array: a, uint32Array: o } = q;
  let c = n * 2;
  if (r === null && (e.boundingBox || e.computeBoundingBox(), _o.set(e.boundingBox.min, e.boundingBox.max, i), r = _o), Tt(c, a)) {
    const h = t.geometry, u = h.index, f = h.attributes.position, d = e.index, y = e.attributes.position, _ = Pt(n, o), p = kt(c, a);
    if (yi.copy(i).invert(), e.boundsTree)
      return Z(n, s, wr), wr.matrix.copy(yi), wr.needsUpdate = !0, e.boundsTree.shapecast({
        intersectsBounds: (v) => wr.intersectsBox(v),
        intersectsTriangle: (v) => {
          v.a.applyMatrix4(i), v.b.applyMatrix4(i), v.c.applyMatrix4(i), v.needsUpdate = !0;
          for (let g = _ * 3, b = (p + _) * 3; g < b; g += 3)
            if (it($e, g, u, f), $e.needsUpdate = !0, v.intersectsTriangle($e))
              return !0;
          return !1;
        }
      });
    for (let m = _ * 3, v = (p + _) * 3; m < v; m += 3) {
      it(je, m, u, f), je.a.applyMatrix4(yi), je.b.applyMatrix4(yi), je.c.applyMatrix4(yi), je.needsUpdate = !0;
      for (let g = 0, b = d.count; g < b; g += 3)
        if (it($e, g, d, y), $e.needsUpdate = !0, je.intersectsTriangle($e))
          return !0;
    }
  } else {
    const h = n + 8, u = o[n + 6];
    return Z(h, s, Pr), !!(r.intersectsBox(Pr) && os(h, t, e, i, r) || (Z(u, s, Pr), r.intersectsBox(Pr) && os(u, t, e, i, r)));
  }
}
const Er = /* @__PURE__ */ new Gt(), An = /* @__PURE__ */ new pt(), gi = /* @__PURE__ */ new pt(), Kh = /* @__PURE__ */ new N(), Qh = /* @__PURE__ */ new N(), tu = /* @__PURE__ */ new N(), eu = /* @__PURE__ */ new N();
function iu(n, t, e, i = {}, r = {}, s = 0, a = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), An.set(t.boundingBox.min, t.boundingBox.max, e), An.needsUpdate = !0;
  const o = n.geometry, c = o.attributes.position, l = o.index, h = t.attributes.position, u = t.index, f = zt.getPrimitive(), d = zt.getPrimitive();
  let y = Kh, _ = Qh, p = null, m = null;
  r && (p = tu, m = eu);
  let v = 1 / 0, g = null, b = null;
  return Er.copy(e).invert(), gi.matrix.copy(Er), n.shapecast(
    {
      boundsTraverseOrder: (x) => An.distanceToBox(x),
      intersectsBounds: (x, S, T) => T < v && T < a ? (S && (gi.min.copy(x.min), gi.max.copy(x.max), gi.needsUpdate = !0), !0) : !1,
      intersectsRange: (x, S) => {
        if (t.boundsTree)
          return t.boundsTree.shapecast({
            boundsTraverseOrder: (P) => gi.distanceToBox(P),
            intersectsBounds: (P, M, C) => C < v && C < a,
            intersectsRange: (P, M) => {
              for (let C = P, E = P + M; C < E; C++) {
                it(d, 3 * C, u, h), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
                for (let w = x, k = x + S; w < k; w++) {
                  it(f, 3 * w, l, c), f.needsUpdate = !0;
                  const R = f.distanceToTriangle(d, y, p);
                  if (R < v && (_.copy(y), m && m.copy(p), v = R, g = w, b = C), R < s)
                    return !0;
                }
              }
            }
          });
        {
          const T = si(t);
          for (let P = 0, M = T; P < M; P++) {
            it(d, 3 * P, u, h), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
            for (let C = x, E = x + S; C < E; C++) {
              it(f, 3 * C, l, c), f.needsUpdate = !0;
              const w = f.distanceToTriangle(d, y, p);
              if (w < v && (_.copy(y), m && m.copy(p), v = w, g = C, b = P), w < s)
                return !0;
            }
          }
        }
      }
    }
  ), zt.releasePrimitive(f), zt.releasePrimitive(d), v === 1 / 0 ? null : (i.point ? i.point.copy(_) : i.point = _.clone(), i.distance = v, i.faceIndex = g, r && (r.point ? r.point.copy(m) : r.point = m.clone(), r.point.applyMatrix4(Er), _.applyMatrix4(Er), r.distance = _.sub(r.point).length(), r.faceIndex = b), i);
}
function ru(n, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = n.geometry, i = e.index ? e.index.array : null, r = e.attributes.position;
  let s, a, o, c, l = 0;
  const h = n._roots;
  for (let f = 0, d = h.length; f < d; f++)
    s = h[f], a = new Uint32Array(s), o = new Uint16Array(s), c = new Float32Array(s), u(0, l), l += s.byteLength;
  function u(f, d, y = !1) {
    const _ = f * 2;
    if (o[_ + 15] === rn) {
      const m = a[f + 6], v = o[_ + 14];
      let g = 1 / 0, b = 1 / 0, x = 1 / 0, S = -1 / 0, T = -1 / 0, P = -1 / 0;
      for (let M = m, C = m + v; M < C; M++) {
        const E = 3 * n.resolveTriangleIndex(M);
        for (let w = 0; w < 3; w++) {
          let k = E + w;
          k = i ? i[k] : k;
          const R = r.getX(k), z = r.getY(k), U = r.getZ(k);
          R < g && (g = R), R > S && (S = R), z < b && (b = z), z > T && (T = z), U < x && (x = U), U > P && (P = U);
        }
      }
      return c[f + 0] !== g || c[f + 1] !== b || c[f + 2] !== x || c[f + 3] !== S || c[f + 4] !== T || c[f + 5] !== P ? (c[f + 0] = g, c[f + 1] = b, c[f + 2] = x, c[f + 3] = S, c[f + 4] = T, c[f + 5] = P, !0) : !1;
    } else {
      const m = f + 8, v = a[f + 6], g = m + d, b = v + d;
      let x = y, S = !1, T = !1;
      t ? x || (S = t.has(g), T = t.has(b), x = !S && !T) : (S = !0, T = !0);
      const P = x || S, M = x || T;
      let C = !1;
      P && (C = u(m, d, x));
      let E = !1;
      M && (E = u(v, d, x));
      const w = C || E;
      if (w)
        for (let k = 0; k < 3; k++) {
          const R = m + k, z = v + k, U = c[R], L = c[R + 3], I = c[z], H = c[z + 3];
          c[f + k] = U < I ? U : I, c[f + k + 3] = L > H ? L : H;
        }
      return w;
    }
  }
}
function nu(n, t, e, i, r, s, a) {
  q.setBuffer(n._roots[t]), as(0, n, e, i, r, s, a), q.clearBuffer();
}
function as(n, t, e, i, r, s, a) {
  const { float32Array: o, uint16Array: c, uint32Array: l } = q, h = n * 2;
  if (Tt(h, c)) {
    const f = Pt(n, l), d = kt(h, c);
    $h(t, e, i, f, d, r, s, a);
  } else {
    const f = Rt(n);
    Me(f, o, i, s, a) && as(f, t, e, i, r, s, a);
    const d = At(n, l);
    Me(d, o, i, s, a) && as(d, t, e, i, r, s, a);
  }
}
const su = ["x", "y", "z"];
function ou(n, t, e, i, r, s) {
  q.setBuffer(n._roots[t]);
  const a = cs(0, n, e, i, r, s);
  return q.clearBuffer(), a;
}
function cs(n, t, e, i, r, s) {
  const { float32Array: a, uint16Array: o, uint32Array: c } = q;
  let l = n * 2;
  if (Tt(l, o)) {
    const u = Pt(n, c), f = kt(l, o);
    return qh(t, e, i, u, f, r, s);
  } else {
    const u = Da(n, c), f = su[u], y = i.direction[f] >= 0;
    let _, p;
    y ? (_ = Rt(n), p = At(n, c)) : (_ = At(n, c), p = Rt(n));
    const v = Me(_, a, i, r, s) ? cs(_, t, e, i, r, s) : null;
    if (v) {
      const x = v.point[f];
      if (y ? x <= a[p + u] : (
        // min bounding data
        x >= a[p + u + 3]
      ))
        return v;
    }
    const b = Me(p, a, i, r, s) ? cs(p, t, e, i, r, s) : null;
    return v && b ? v.distance <= b.distance ? v : b : v || b || null;
  }
}
const kr = /* @__PURE__ */ new te(), qe = /* @__PURE__ */ new Ot(), Xe = /* @__PURE__ */ new Ot(), vi = /* @__PURE__ */ new Gt(), xo = /* @__PURE__ */ new pt(), Rr = /* @__PURE__ */ new pt();
function au(n, t, e, i) {
  q.setBuffer(n._roots[t]);
  const r = ls(0, n, e, i);
  return q.clearBuffer(), r;
}
function ls(n, t, e, i, r = null) {
  const { float32Array: s, uint16Array: a, uint32Array: o } = q;
  let c = n * 2;
  if (r === null && (e.boundingBox || e.computeBoundingBox(), xo.set(e.boundingBox.min, e.boundingBox.max, i), r = xo), Tt(c, a)) {
    const h = t.geometry, u = h.index, f = h.attributes.position, d = e.index, y = e.attributes.position, _ = Pt(n, o), p = kt(c, a);
    if (vi.copy(i).invert(), e.boundsTree)
      return Z(n, s, Rr), Rr.matrix.copy(vi), Rr.needsUpdate = !0, e.boundsTree.shapecast({
        intersectsBounds: (v) => Rr.intersectsBox(v),
        intersectsTriangle: (v) => {
          v.a.applyMatrix4(i), v.b.applyMatrix4(i), v.c.applyMatrix4(i), v.needsUpdate = !0;
          for (let g = _, b = p + _; g < b; g++)
            if (it(Xe, 3 * t.resolveTriangleIndex(g), u, f), Xe.needsUpdate = !0, v.intersectsTriangle(Xe))
              return !0;
          return !1;
        }
      });
    for (let m = _, v = p + _; m < v; m++) {
      const g = t.resolveTriangleIndex(m);
      it(qe, 3 * g, u, f), qe.a.applyMatrix4(vi), qe.b.applyMatrix4(vi), qe.c.applyMatrix4(vi), qe.needsUpdate = !0;
      for (let b = 0, x = d.count; b < x; b += 3)
        if (it(Xe, b, d, y), Xe.needsUpdate = !0, qe.intersectsTriangle(Xe))
          return !0;
    }
  } else {
    const h = n + 8, u = o[n + 6];
    return Z(h, s, kr), !!(r.intersectsBox(kr) && ls(h, t, e, i, r) || (Z(u, s, kr), r.intersectsBox(kr) && ls(u, t, e, i, r)));
  }
}
const Ar = /* @__PURE__ */ new Gt(), zn = /* @__PURE__ */ new pt(), _i = /* @__PURE__ */ new pt(), cu = /* @__PURE__ */ new N(), lu = /* @__PURE__ */ new N(), hu = /* @__PURE__ */ new N(), uu = /* @__PURE__ */ new N();
function fu(n, t, e, i = {}, r = {}, s = 0, a = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), zn.set(t.boundingBox.min, t.boundingBox.max, e), zn.needsUpdate = !0;
  const o = n.geometry, c = o.attributes.position, l = o.index, h = t.attributes.position, u = t.index, f = zt.getPrimitive(), d = zt.getPrimitive();
  let y = cu, _ = lu, p = null, m = null;
  r && (p = hu, m = uu);
  let v = 1 / 0, g = null, b = null;
  return Ar.copy(e).invert(), _i.matrix.copy(Ar), n.shapecast(
    {
      boundsTraverseOrder: (x) => zn.distanceToBox(x),
      intersectsBounds: (x, S, T) => T < v && T < a ? (S && (_i.min.copy(x.min), _i.max.copy(x.max), _i.needsUpdate = !0), !0) : !1,
      intersectsRange: (x, S) => {
        if (t.boundsTree) {
          const T = t.boundsTree;
          return T.shapecast({
            boundsTraverseOrder: (P) => _i.distanceToBox(P),
            intersectsBounds: (P, M, C) => C < v && C < a,
            intersectsRange: (P, M) => {
              for (let C = P, E = P + M; C < E; C++) {
                const w = T.resolveTriangleIndex(C);
                it(d, 3 * w, u, h), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
                for (let k = x, R = x + S; k < R; k++) {
                  const z = n.resolveTriangleIndex(k);
                  it(f, 3 * z, l, c), f.needsUpdate = !0;
                  const U = f.distanceToTriangle(d, y, p);
                  if (U < v && (_.copy(y), m && m.copy(p), v = U, g = k, b = C), U < s)
                    return !0;
                }
              }
            }
          });
        } else {
          const T = si(t);
          for (let P = 0, M = T; P < M; P++) {
            it(d, 3 * P, u, h), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
            for (let C = x, E = x + S; C < E; C++) {
              const w = n.resolveTriangleIndex(C);
              it(f, 3 * w, l, c), f.needsUpdate = !0;
              const k = f.distanceToTriangle(d, y, p);
              if (k < v && (_.copy(y), m && m.copy(p), v = k, g = C, b = P), k < s)
                return !0;
            }
          }
        }
      }
    }
  ), zt.releasePrimitive(f), zt.releasePrimitive(d), v === 1 / 0 ? null : (i.point ? i.point.copy(_) : i.point = _.clone(), i.distance = v, i.faceIndex = g, r && (r.point ? r.point.copy(m) : r.point = m.clone(), r.point.applyMatrix4(Ar), _.applyMatrix4(Ar), r.distance = _.sub(r.point).length(), r.faceIndex = b), i);
}
function du() {
  return typeof SharedArrayBuffer < "u";
}
const ki = new q.constructor(), Zr = new q.constructor(), Se = new Ss(() => new te()), He = new te(), We = new te(), On = new te(), Bn = new te();
let In = !1;
function pu(n, t, e, i) {
  if (In)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  In = !0;
  const r = n._roots, s = t._roots;
  let a, o = 0, c = 0;
  const l = new Gt().copy(e).invert();
  for (let h = 0, u = r.length; h < u; h++) {
    ki.setBuffer(r[h]), c = 0;
    const f = Se.getPrimitive();
    Z(0, ki.float32Array, f), f.applyMatrix4(l);
    for (let d = 0, y = s.length; d < y && (Zr.setBuffer(s[d]), a = Lt(
      0,
      0,
      e,
      l,
      i,
      o,
      c,
      0,
      0,
      f
    ), Zr.clearBuffer(), c += s[d].length, !a); d++)
      ;
    if (Se.releasePrimitive(f), ki.clearBuffer(), o += r[h].length, a)
      break;
  }
  return In = !1, a;
}
function Lt(n, t, e, i, r, s = 0, a = 0, o = 0, c = 0, l = null, h = !1) {
  let u, f;
  h ? (u = Zr, f = ki) : (u = ki, f = Zr);
  const d = u.float32Array, y = u.uint32Array, _ = u.uint16Array, p = f.float32Array, m = f.uint32Array, v = f.uint16Array, g = n * 2, b = t * 2, x = Tt(g, _), S = Tt(b, v);
  let T = !1;
  if (S && x)
    h ? T = r(
      Pt(t, m),
      kt(t * 2, v),
      Pt(n, y),
      kt(n * 2, _),
      c,
      a + t,
      o,
      s + n
    ) : T = r(
      Pt(n, y),
      kt(n * 2, _),
      Pt(t, m),
      kt(t * 2, v),
      o,
      s + n,
      c,
      a + t
    );
  else if (S) {
    const P = Se.getPrimitive();
    Z(t, p, P), P.applyMatrix4(e);
    const M = Rt(n), C = At(n, y);
    Z(M, d, He), Z(C, d, We);
    const E = P.intersectsBox(He), w = P.intersectsBox(We);
    T = E && Lt(
      t,
      M,
      i,
      e,
      r,
      a,
      s,
      c,
      o + 1,
      P,
      !h
    ) || w && Lt(
      t,
      C,
      i,
      e,
      r,
      a,
      s,
      c,
      o + 1,
      P,
      !h
    ), Se.releasePrimitive(P);
  } else {
    const P = Rt(t), M = At(t, m);
    Z(P, p, On), Z(M, p, Bn);
    const C = l.intersectsBox(On), E = l.intersectsBox(Bn);
    if (C && E)
      T = Lt(
        n,
        P,
        e,
        i,
        r,
        s,
        a,
        o,
        c + 1,
        l,
        h
      ) || Lt(
        n,
        M,
        e,
        i,
        r,
        s,
        a,
        o,
        c + 1,
        l,
        h
      );
    else if (C)
      if (x)
        T = Lt(
          n,
          P,
          e,
          i,
          r,
          s,
          a,
          o,
          c + 1,
          l,
          h
        );
      else {
        const w = Se.getPrimitive();
        w.copy(On).applyMatrix4(e);
        const k = Rt(n), R = At(n, y);
        Z(k, d, He), Z(R, d, We);
        const z = w.intersectsBox(He), U = w.intersectsBox(We);
        T = z && Lt(
          P,
          k,
          i,
          e,
          r,
          a,
          s,
          c,
          o + 1,
          w,
          !h
        ) || U && Lt(
          P,
          R,
          i,
          e,
          r,
          a,
          s,
          c,
          o + 1,
          w,
          !h
        ), Se.releasePrimitive(w);
      }
    else if (E)
      if (x)
        T = Lt(
          n,
          M,
          e,
          i,
          r,
          s,
          a,
          o,
          c + 1,
          l,
          h
        );
      else {
        const w = Se.getPrimitive();
        w.copy(Bn).applyMatrix4(e);
        const k = Rt(n), R = At(n, y);
        Z(k, d, He), Z(R, d, We);
        const z = w.intersectsBox(He), U = w.intersectsBox(We);
        T = z && Lt(
          M,
          k,
          i,
          e,
          r,
          a,
          s,
          c,
          o + 1,
          w,
          !h
        ) || U && Lt(
          M,
          R,
          i,
          e,
          r,
          a,
          s,
          c,
          o + 1,
          w,
          !h
        ), Se.releasePrimitive(w);
      }
  }
  return T;
}
const zr = /* @__PURE__ */ new pt(), bo = /* @__PURE__ */ new te(), mu = {
  strategy: xs,
  maxDepth: 40,
  maxLeafTris: 10,
  useSharedArrayBuffer: !1,
  setBoundingBox: !0,
  onProgress: null,
  indirect: !1,
  verbose: !0,
  range: null
};
class sn {
  static serialize(t, e = {}) {
    e = {
      cloneBuffers: !0,
      ...e
    };
    const i = t.geometry, r = t._roots, s = t._indirectBuffer, a = i.getIndex();
    let o;
    return e.cloneBuffers ? o = {
      roots: r.map((c) => c.slice()),
      index: a ? a.array.slice() : null,
      indirectBuffer: s ? s.slice() : null
    } : o = {
      roots: r,
      index: a ? a.array : null,
      indirectBuffer: s
    }, o;
  }
  static deserialize(t, e, i = {}) {
    i = {
      setIndex: !0,
      indirect: !!t.indirectBuffer,
      ...i
    };
    const { index: r, roots: s, indirectBuffer: a } = t, o = new sn(e, { ...i, [Pn]: !0 });
    if (o._roots = s, o._indirectBuffer = a || null, i.setIndex) {
      const c = e.getIndex();
      if (c === null) {
        const l = new Mt(t.index, 1, !1);
        e.setIndex(l);
      } else c.array !== r && (c.array.set(r), c.needsUpdate = !0);
    }
    return o;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t, e = {}) {
    if (t.isBufferGeometry) {
      if (t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (e = Object.assign({
      ...mu,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Pn]: !1
    }, e), e.useSharedArrayBuffer && !du())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t, this._roots = null, this._indirectBuffer = null, e[Pn] || (Rh(this, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new te()))), this.resolveTriangleIndex = e.indirect ? (i) => this._indirectBuffer[i] : (i) => i;
  }
  refit(t = null) {
    return (this.indirect ? ru : jh)(this, t);
  }
  traverse(t, e = 0) {
    const i = this._roots[e], r = new Uint32Array(i), s = new Uint16Array(i);
    a(0);
    function a(o, c = 0) {
      const l = o * 2, h = s[l + 15] === rn;
      if (h) {
        const u = r[o + 6], f = s[l + 14];
        t(c, h, new Float32Array(i, o * 4, 6), u, f);
      } else {
        const u = o + Ei / 4, f = r[o + 6], d = r[o + 7];
        t(c, h, new Float32Array(i, o * 4, 6), d) || (a(u, c + 1), a(f, c + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(t, e = Cs, i = 0, r = 1 / 0) {
    const s = this._roots, a = this.geometry, o = [], c = e.isMaterial, l = Array.isArray(e), h = a.groups, u = c ? e.side : e, f = this.indirect ? nu : Hh;
    for (let d = 0, y = s.length; d < y; d++) {
      const _ = l ? e[h[d].materialIndex].side : u, p = o.length;
      if (f(this, d, _, t, o, i, r), l) {
        const m = h[d].materialIndex;
        for (let v = p, g = o.length; v < g; v++)
          o[v].face.materialIndex = m;
      }
    }
    return o;
  }
  raycastFirst(t, e = Cs, i = 0, r = 1 / 0) {
    const s = this._roots, a = this.geometry, o = e.isMaterial, c = Array.isArray(e);
    let l = null;
    const h = a.groups, u = o ? e.side : e, f = this.indirect ? ou : Yh;
    for (let d = 0, y = s.length; d < y; d++) {
      const _ = c ? e[h[d].materialIndex].side : u, p = f(this, d, _, t, i, r);
      p != null && (l == null || p.distance < l.distance) && (l = p, c && (p.face.materialIndex = h[d].materialIndex));
    }
    return l;
  }
  intersectsGeometry(t, e) {
    let i = !1;
    const r = this._roots, s = this.indirect ? au : Zh;
    for (let a = 0, o = r.length; a < o && (i = s(this, a, t, e), !i); a++)
      ;
    return i;
  }
  shapecast(t) {
    const e = zt.getPrimitive(), i = this.indirect ? Xh : Gh;
    let {
      boundsTraverseOrder: r,
      intersectsBounds: s,
      intersectsRange: a,
      intersectsTriangle: o
    } = t;
    if (a && o) {
      const u = a;
      a = (f, d, y, _, p) => u(f, d, y, _, p) ? !0 : i(f, d, this, o, y, _, e);
    } else a || (o ? a = (u, f, d, y) => i(u, f, this, o, d, y, e) : a = (u, f, d) => d);
    let c = !1, l = 0;
    const h = this._roots;
    for (let u = 0, f = h.length; u < f; u++) {
      const d = h[u];
      if (c = Nh(this, u, s, a, r, l), c)
        break;
      l += d.byteLength;
    }
    return zt.releasePrimitive(e), c;
  }
  bvhcast(t, e, i) {
    let {
      intersectsRanges: r,
      intersectsTriangles: s
    } = i;
    const a = zt.getPrimitive(), o = this.geometry.index, c = this.geometry.attributes.position, l = this.indirect ? (y) => {
      const _ = this.resolveTriangleIndex(y);
      it(a, _ * 3, o, c);
    } : (y) => {
      it(a, y * 3, o, c);
    }, h = zt.getPrimitive(), u = t.geometry.index, f = t.geometry.attributes.position, d = t.indirect ? (y) => {
      const _ = t.resolveTriangleIndex(y);
      it(h, _ * 3, u, f);
    } : (y) => {
      it(h, y * 3, u, f);
    };
    if (s) {
      const y = (_, p, m, v, g, b, x, S) => {
        for (let T = m, P = m + v; T < P; T++) {
          d(T), h.a.applyMatrix4(e), h.b.applyMatrix4(e), h.c.applyMatrix4(e), h.needsUpdate = !0;
          for (let M = _, C = _ + p; M < C; M++)
            if (l(M), a.needsUpdate = !0, s(a, h, M, T, g, b, x, S))
              return !0;
        }
        return !1;
      };
      if (r) {
        const _ = r;
        r = function(p, m, v, g, b, x, S, T) {
          return _(p, m, v, g, b, x, S, T) ? !0 : y(p, m, v, g, b, x, S, T);
        };
      } else
        r = y;
    }
    return pu(this, t, e, r);
  }
  /* Derived Cast Functions */
  intersectsBox(t, e) {
    return zr.set(t.min, t.max, e), zr.needsUpdate = !0, this.shapecast(
      {
        intersectsBounds: (i) => zr.intersectsBox(i),
        intersectsTriangle: (i) => zr.intersectsTriangle(i)
      }
    );
  }
  intersectsSphere(t) {
    return this.shapecast(
      {
        intersectsBounds: (e) => t.intersectsBox(e),
        intersectsTriangle: (e) => e.intersectsSphere(t)
      }
    );
  }
  closestPointToGeometry(t, e, i = {}, r = {}, s = 0, a = 1 / 0) {
    return (this.indirect ? fu : iu)(
      this,
      t,
      e,
      i,
      r,
      s,
      a
    );
  }
  closestPointToPoint(t, e = {}, i = 0, r = 1 / 0) {
    return Uh(
      this,
      t,
      e,
      i,
      r
    );
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((i) => {
      Z(0, new Float32Array(i), bo), t.union(bo);
    }), t;
  }
}
function So(n, t, e) {
  return n === null ? null : (n.point.applyMatrix4(t.matrixWorld), n.distance = n.point.distanceTo(e.ray.origin), n.object = t, n);
}
const Or = /* @__PURE__ */ new Ya(), To = /* @__PURE__ */ new N(), Co = /* @__PURE__ */ new Gt(), yu = hs.prototype.raycast, gu = Wa.prototype.raycast, Mo = /* @__PURE__ */ new N(), lt = /* @__PURE__ */ new hs(), Br = [];
function vu(n, t) {
  this.isBatchedMesh ? _u.call(this, n, t) : xu.call(this, n, t);
}
function _u(n, t) {
  if (this.boundsTrees) {
    const e = this.boundsTrees, i = this._drawInfo || this._instanceInfo, r = this._drawRanges || this._geometryInfo, s = this.matrixWorld;
    lt.material = this.material, lt.geometry = this.geometry;
    const a = lt.geometry.boundsTree, o = lt.geometry.drawRange;
    lt.geometry.boundingSphere === null && (lt.geometry.boundingSphere = new No());
    for (let c = 0, l = i.length; c < l; c++) {
      if (!this.getVisibleAt(c))
        continue;
      const h = i[c].geometryIndex;
      if (lt.geometry.boundsTree = e[h], this.getMatrixAt(c, lt.matrixWorld).premultiply(s), !lt.geometry.boundsTree) {
        this.getBoundingBoxAt(h, lt.geometry.boundingBox), this.getBoundingSphereAt(h, lt.geometry.boundingSphere);
        const u = r[h];
        lt.geometry.setDrawRange(u.start, u.count);
      }
      lt.raycast(n, Br);
      for (let u = 0, f = Br.length; u < f; u++) {
        const d = Br[u];
        d.object = this, d.batchId = c, t.push(d);
      }
      Br.length = 0;
    }
    lt.geometry.boundsTree = a, lt.geometry.drawRange = o, lt.material = null, lt.geometry = null;
  } else
    gu.call(this, n, t);
}
function xu(n, t) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0) return;
    Co.copy(this.matrixWorld).invert(), Or.copy(n.ray).applyMatrix4(Co), Mo.setFromMatrixScale(this.matrixWorld), To.copy(Or.direction).multiply(Mo);
    const e = To.length(), i = n.near / e, r = n.far / e, s = this.geometry.boundsTree;
    if (n.firstHitOnly === !0) {
      const a = So(s.raycastFirst(Or, this.material, i, r), this, n);
      a && t.push(a);
    } else {
      const a = s.raycast(Or, this.material, i, r);
      for (let o = 0, c = a.length; o < c; o++) {
        const l = So(a[o], this, n);
        l && t.push(l);
      }
    }
  } else
    yu.call(this, n, t);
}
function bu(n = {}) {
  return this.boundsTree = new sn(this, n), this.boundsTree;
}
const Oe = /* @__PURE__ */ new N(), Be = /* @__PURE__ */ new N(), Ie = /* @__PURE__ */ new N(), Po = /* @__PURE__ */ new us(), Ir = /* @__PURE__ */ new N(), Nn = /* @__PURE__ */ new N(), wo = /* @__PURE__ */ new us(), Eo = /* @__PURE__ */ new us(), Nr = /* @__PURE__ */ new Gt(), ko = /* @__PURE__ */ new Gt();
function xi(n, t) {
  if (!n && !t)
    return;
  const e = n.count === t.count, i = n.normalized === t.normalized, r = n.array.constructor === t.array.constructor, s = n.itemSize === t.itemSize;
  if (!e || !i || !r || !s)
    throw new Error();
}
function Mi(n, t = null) {
  const e = n.array.constructor, i = n.normalized, r = n.itemSize, s = t === null ? n.count : t;
  return new Mt(new e(r * s), r, i);
}
function Ja(n, t, e = 0) {
  if (n.isInterleavedBufferAttribute) {
    const i = n.itemSize;
    for (let r = 0, s = n.count; r < s; r++) {
      const a = r + e;
      t.setX(a, n.getX(r)), i >= 2 && t.setY(a, n.getY(r)), i >= 3 && t.setZ(a, n.getZ(r)), i >= 4 && t.setW(a, n.getW(r));
    }
  } else {
    const i = t.array, r = i.constructor, s = i.BYTES_PER_ELEMENT * n.itemSize * e;
    new r(i.buffer, s, n.array.length).set(n.array);
  }
}
function Su(n, t, e) {
  const i = n.elements, r = t.elements;
  for (let s = 0, a = r.length; s < a; s++)
    i[s] += r[s] * e;
}
function Ro(n, t, e) {
  const i = n.skeleton, r = n.geometry, s = i.bones, a = i.boneInverses;
  wo.fromBufferAttribute(r.attributes.skinIndex, t), Eo.fromBufferAttribute(r.attributes.skinWeight, t), Nr.elements.fill(0);
  for (let o = 0; o < 4; o++) {
    const c = Eo.getComponent(o);
    if (c !== 0) {
      const l = wo.getComponent(o);
      ko.multiplyMatrices(s[l].matrixWorld, a[l]), Su(Nr, ko, c);
    }
  }
  return Nr.multiply(n.bindMatrix).premultiply(n.bindMatrixInverse), e.transformDirection(Nr), e;
}
function Un(n, t, e, i, r) {
  Ir.set(0, 0, 0);
  for (let s = 0, a = n.length; s < a; s++) {
    const o = t[s], c = n[s];
    o !== 0 && (Nn.fromBufferAttribute(c, i), e ? Ir.addScaledVector(Nn, o) : Ir.addScaledVector(Nn.sub(r), o));
  }
  r.add(Ir);
}
function Tu(n, t = { useGroups: !1, updateIndex: !1, skipAttributes: [] }, e = new Pi()) {
  const i = n[0].index !== null, { useGroups: r = !1, updateIndex: s = !1, skipAttributes: a = [] } = t, o = new Set(Object.keys(n[0].attributes)), c = {};
  let l = 0;
  e.clearGroups();
  for (let h = 0; h < n.length; ++h) {
    const u = n[h];
    let f = 0;
    if (i !== (u.index !== null))
      throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
    for (const d in u.attributes) {
      if (!o.has(d))
        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "' + d + '" attribute exists among all geometries, or in none of them.');
      c[d] === void 0 && (c[d] = []), c[d].push(u.attributes[d]), f++;
    }
    if (f !== o.size)
      throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");
    if (r) {
      let d;
      if (i)
        d = u.index.count;
      else if (u.attributes.position !== void 0)
        d = u.attributes.position.count;
      else
        throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");
      e.addGroup(l, d, h), l += d;
    }
  }
  if (i) {
    let h = !1;
    if (!e.index) {
      let u = 0;
      for (let f = 0; f < n.length; ++f)
        u += n[f].index.count;
      e.setIndex(new Mt(new Uint32Array(u), 1, !1)), h = !0;
    }
    if (s || h) {
      const u = e.index;
      let f = 0, d = 0;
      for (let y = 0; y < n.length; ++y) {
        const _ = n[y], p = _.index;
        if (a[y] !== !0)
          for (let m = 0; m < p.count; ++m)
            u.setX(f, p.getX(m) + d), f++;
        d += _.attributes.position.count;
      }
    }
  }
  for (const h in c) {
    const u = c[h];
    if (!(h in e.attributes)) {
      let y = 0;
      for (const _ in u)
        y += u[_].count;
      e.setAttribute(h, Mi(c[h][0], y));
    }
    const f = e.attributes[h];
    let d = 0;
    for (let y = 0, _ = u.length; y < _; y++) {
      const p = u[y];
      a[y] !== !0 && Ja(p, f, d), d += p.count;
    }
  }
  return e;
}
function Cu(n, t) {
  if (n === null || t === null)
    return n === t;
  if (n.length !== t.length)
    return !1;
  for (let e = 0, i = n.length; e < i; e++)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
function Mu(n) {
  const { index: t, attributes: e } = n;
  if (t)
    for (let i = 0, r = t.count; i < r; i += 3) {
      const s = t.getX(i), a = t.getX(i + 2);
      t.setX(i, a), t.setX(i + 2, s);
    }
  else
    for (const i in e) {
      const r = e[i], s = r.itemSize;
      for (let a = 0, o = r.count; a < o; a += 3)
        for (let c = 0; c < s; c++) {
          const l = r.getComponent(a, c), h = r.getComponent(a + 2, c);
          r.setComponent(a, c, h), r.setComponent(a + 2, c, l);
        }
    }
  return n;
}
class Pu {
  constructor(t) {
    this.matrixWorld = new Gt(), this.geometryHash = null, this.boneMatrices = null, this.primitiveCount = -1, this.mesh = t, this.update();
  }
  update() {
    const t = this.mesh, e = t.geometry, i = t.skeleton, r = (e.index ? e.index.count : e.attributes.position.count) / 3;
    if (this.matrixWorld.copy(t.matrixWorld), this.geometryHash = e.attributes.position.version, this.primitiveCount = r, i) {
      i.boneTexture || i.computeBoneTexture(), i.update();
      const s = i.boneMatrices;
      !this.boneMatrices || this.boneMatrices.length !== s.length ? this.boneMatrices = s.slice() : this.boneMatrices.set(s);
    } else
      this.boneMatrices = null;
  }
  didChange() {
    const t = this.mesh, e = t.geometry, i = (e.index ? e.index.count : e.attributes.position.count) / 3;
    return !(this.matrixWorld.equals(t.matrixWorld) && this.geometryHash === e.attributes.position.version && Cu(t.skeleton && t.skeleton.boneMatrices || null, this.boneMatrices) && this.primitiveCount === i);
  }
}
class wu {
  constructor(t) {
    Array.isArray(t) || (t = [t]);
    const e = [];
    t.forEach((i) => {
      i.traverseVisible((r) => {
        r.isMesh && e.push(r);
      });
    }), this.meshes = e, this.useGroups = !0, this.applyWorldTransforms = !0, this.attributes = ["position", "normal", "color", "tangent", "uv", "uv2"], this._intermediateGeometry = new Array(e.length).fill().map(() => new Pi()), this._diffMap = /* @__PURE__ */ new WeakMap();
  }
  getMaterials() {
    const t = [];
    return this.meshes.forEach((e) => {
      Array.isArray(e.material) ? t.push(...e.material) : t.push(e.material);
    }), t;
  }
  generate(t = new Pi()) {
    let e = [];
    const { meshes: i, useGroups: r, _intermediateGeometry: s, _diffMap: a } = this;
    for (let o = 0, c = i.length; o < c; o++) {
      const l = i[o], h = s[o], u = a.get(l);
      !u || u.didChange(l) ? (this._convertToStaticGeometry(l, h), e.push(!1), u ? u.update() : a.set(l, new Pu(l))) : e.push(!0);
    }
    if (s.length === 0) {
      t.setIndex(null);
      const o = t.attributes;
      for (const c in o)
        t.deleteAttribute(c);
      for (const c in this.attributes)
        t.setAttribute(this.attributes[c], new Mt(new Float32Array(0), 4, !1));
    } else
      Tu(s, { useGroups: r, skipAttributes: e }, t);
    for (const o in t.attributes)
      t.attributes[o].needsUpdate = !0;
    return t;
  }
  _convertToStaticGeometry(t, e = new Pi()) {
    const i = t.geometry, r = this.applyWorldTransforms, s = this.attributes.includes("normal"), a = this.attributes.includes("tangent"), o = i.attributes, c = e.attributes;
    !e.index && i.index && (e.index = i.index.clone()), c.position || e.setAttribute("position", Mi(o.position)), s && !c.normal && o.normal && e.setAttribute("normal", Mi(o.normal)), a && !c.tangent && o.tangent && e.setAttribute("tangent", Mi(o.tangent)), xi(i.index, e.index), xi(o.position, c.position), s && xi(o.normal, c.normal), a && xi(o.tangent, c.tangent);
    const l = o.position, h = s ? o.normal : null, u = a ? o.tangent : null, f = i.morphAttributes.position, d = i.morphAttributes.normal, y = i.morphAttributes.tangent, _ = i.morphTargetsRelative, p = t.morphTargetInfluences, m = new Za();
    m.getNormalMatrix(t.matrixWorld), i.index && e.index.array.set(i.index.array);
    for (let v = 0, g = o.position.count; v < g; v++)
      Oe.fromBufferAttribute(l, v), h && Be.fromBufferAttribute(h, v), u && (Po.fromBufferAttribute(u, v), Ie.fromBufferAttribute(u, v)), p && (f && Un(f, p, _, v, Oe), d && Un(d, p, _, v, Be), y && Un(y, p, _, v, Ie)), t.isSkinnedMesh && (t.applyBoneTransform(v, Oe), h && Ro(t, v, Be), u && Ro(t, v, Ie)), r && Oe.applyMatrix4(t.matrixWorld), c.position.setXYZ(v, Oe.x, Oe.y, Oe.z), h && (r && Be.applyNormalMatrix(m), c.normal.setXYZ(v, Be.x, Be.y, Be.z)), u && (r && Ie.transformDirection(t.matrixWorld), c.tangent.setXYZW(v, Ie.x, Ie.y, Ie.z, Po.w));
    for (const v in this.attributes) {
      const g = this.attributes[v];
      g === "position" || g === "tangent" || g === "normal" || !(g in o) || (c[g] || e.setAttribute(g, Mi(o[g])), xi(o[g], c[g]), Ja(o[g], c[g]));
    }
    return t.matrixWorld.determinant() < 0 && Mu(e), e;
  }
}
const Vu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AVERAGE: Ia,
  CENTER: xs,
  CONTAINED: ts,
  ExtendedTriangle: Ot,
  MeshBVH: sn,
  OrientedBox: pt,
  SAH: Na,
  StaticGeometryGenerator: wu,
  acceleratedRaycast: vu,
  computeBoundsTree: bu
}, Symbol.toStringTag, { value: "Module" }));
class Ju {
  constructor(t) {
    this.name = "WorkerBase", this.running = !1, this.worker = t, this.worker.onerror = (e) => {
      throw e.message ? new Error(`${this.name}: Could not create Web Worker with error "${e.message}"`) : new Error(`${this.name}: Could not create Web Worker.`);
    };
  }
  runTask() {
  }
  generate(...t) {
    if (this.running)
      throw new Error("GenerateMeshBVHWorker: Already running job.");
    if (this.worker === null)
      throw new Error("GenerateMeshBVHWorker: Worker has been disposed.");
    this.running = !0;
    const e = this.runTask(this.worker, ...t);
    return e.finally(() => {
      this.running = !1;
    }), e;
  }
  dispose() {
    this.worker.terminate(), this.worker = null;
  }
}
const Et = {
  node: "node",
  material: "material",
  camera: "camera",
  light: "light"
}, Ne = "KHR_animation_pointer", Eu = {
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  CUBICSPLINE: void 0,
  LINEAR: Uo,
  STEP: Qa
};
class ku {
  /** @type {import("three/examples/jsm/loaders/GLTFLoader").GLTFParser} */
  constructor(t) {
    this.name = Ne, this.parser = t, this.animationPointerResolver = null;
  }
  /** 
   * @param {import("..").AnimationPointerResolver | null} animationPointerResolver
   */
  setAnimationPointerResolver(t) {
    return this.animationPointerResolver = t, this;
  }
  /* DUPLICATE of functionality in GLTFLoader */
  loadAnimationTargetFromChannel(t) {
    const e = t.target, i = e.node !== void 0 ? e.node : e.id;
    return this.parser.getDependency("node", i);
  }
  loadAnimationTargetFromChannelWithAnimationPointer(t) {
    Au();
    const e = t.target, i = e.extensions && e.extensions[Ne] && e.path && e.path === "pointer";
    if (!i) return null;
    let r, s = Et.node, a;
    if (i) {
      const c = e.extensions[Ne];
      let l = c.pointer;
      if (!l) {
        console.warn("Invalid path", c, e);
        return;
      }
      if (l.startsWith("/materials/") ? s = Et.material : l.startsWith("/extensions/KHR_lights_punctual/lights/") ? s = Et.light : l.startsWith("/cameras/") && (s = Et.camera), a = this._tryResolveTargetId(l, s), a === null || isNaN(a)) {
        console.warn("Failed resolving animation node id: " + a, l);
        return;
      }
      switch (s) {
        case Et.material:
          const h = ("/materials/" + a.toString() + "/").length, u = l.substring(0, h);
          switch (r = l.substring(h), r) {
            // Core Spec PBR Properties
            case "pbrMetallicRoughness/baseColorFactor":
              r = "color";
              break;
            case "pbrMetallicRoughness/roughnessFactor":
              r = "roughness";
              break;
            case "pbrMetallicRoughness/metallicFactor":
              r = "metalness";
              break;
            case "emissiveFactor":
              r = "emissive";
              break;
            case "alphaCutoff":
              r = "alphaTest";
              break;
            case "occlusionTexture/strength":
              r = "aoMapIntensity";
              break;
            case "normalTexture/scale":
              r = "normalScale";
              break;
            // Core Spec + KHR_texture_transform
            case "pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale":
              r = "map/repeat";
              break;
            case "pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset":
              r = "map/offset";
              break;
            // UV transforms for anything but map doesn't seem to currently be supported in three.js
            case "emissiveTexture/extensions/KHR_texture_transform/scale":
              r = "emissiveMap/repeat";
              break;
            case "emissiveTexture/extensions/KHR_texture_transform/offset":
              r = "emissiveMap/offset";
              break;
            // KHR_materials_emissive_strength
            case "extensions/KHR_materials_emissive_strength/emissiveStrength":
              r = "emissiveIntensity";
              break;
            // KHR_materials_transmission
            case "extensions/KHR_materials_transmission/transmissionFactor":
              r = "transmission";
              break;
            // KHR_materials_ior
            case "extensions/KHR_materials_ior/ior":
              r = "ior";
              break;
            // KHR_materials_volume
            case "extensions/KHR_materials_volume/thicknessFactor":
              r = "thickness";
              break;
            case "extensions/KHR_materials_volume/attenuationColor":
              r = "attenuationColor";
              break;
            case "extensions/KHR_materials_volume/attenuationDistance":
              r = "attenuationDistance";
              break;
            // KHR_materials_iridescence
            case "extensions/KHR_materials_iridescence/iridescenceFactor":
              r = "iridescence";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceIor":
              r = "iridescenceIOR";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceThicknessMinimum":
              r = "iridescenceThicknessRange[0]";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceThicknessMaximum":
              r = "iridescenceThicknessRange[1]";
              break;
            // KHR_materials_clearcoat
            case "extensions/KHR_materials_clearcoat/clearcoatFactor":
              r = "clearcoat";
              break;
            case "extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor":
              r = "clearcoatRoughness";
              break;
            // KHR_materials_sheen
            case "extensions/KHR_materials_sheen/sheenColorFactor":
              r = "sheenColor";
              break;
            case "extensions/KHR_materials_sheen/sheenRoughnessFactor":
              r = "sheenRoughness";
              break;
            // KHR_materials_specular
            case "extensions/KHR_materials_specular/specularFactor":
              r = "specularIntensity";
              break;
            case "extensions/KHR_materials_specular/specularColorFactor":
              r = "specularColor";
              break;
          }
          l = u + r;
          break;
        case Et.node:
          const f = ("/nodes/" + a.toString() + "/").length, d = l.substring(0, f);
          switch (r = l.substring(f), r) {
            case "translation":
              r = "position";
              break;
            case "rotation":
              r = "quaternion";
              break;
            case "scale":
              r = "scale";
              break;
            case "weights":
              r = "morphTargetInfluences";
              break;
          }
          l = d + r;
          break;
        case Et.light:
          const y = ("/extensions/KHR_lights_punctual/lights/" + a.toString() + "/").length;
          switch (r = l.substring(y), r) {
            case "color":
              break;
            case "intensity":
              break;
            case "spot/innerConeAngle":
              r = "penumbra";
              break;
            case "spot/outerConeAngle":
              r = "angle";
              break;
            case "range":
              r = "distance";
              break;
          }
          l = "/lights/" + a.toString() + "/" + r;
          break;
        case Et.camera:
          const _ = ("/cameras/" + a.toString() + "/").length, p = l.substring(0, _);
          switch (r = l.substring(_), r) {
            case "perspective/yfov":
              r = "fov";
              break;
            case "perspective/znear":
            case "orthographic/znear":
              r = "near";
              break;
            case "perspective/zfar":
            case "orthographic/zfar":
              r = "far";
              break;
            case "perspective/aspect":
              r = "aspect";
              break;
            // these two write to the same target property since three.js orthographic camera only supports 'zoom'.
            // TODO should there be a warning for either of them? E.g. a warning for "xmag" so that "yfov" + "ymag" work by default?
            case "orthographic/xmag":
              r = "zoom";
              break;
            case "orthographic/ymag":
              r = "zoom";
              break;
          }
          l = p + r;
          break;
      }
      this.animationPointerResolver?.resolvePath && (l = this.animationPointerResolver.resolvePath(l)), e.extensions[Ne].pointer = l;
    }
    if (a == null || isNaN(a)) {
      console.warn("Failed resolving animation node id: " + a, e);
      return;
    }
    let o;
    return s === Et.node ? o = this.parser.getDependency("node", a) : s === Et.material ? o = this.parser.getDependency("material", a) : s === Et.light ? o = this.parser.getDependency("light", a) : s === Et.camera ? o = this.parser.getDependency("camera", a) : console.error("Unhandled type", s), o;
  }
  createAnimationTracksWithAnimationPointer(t, e, i, r, s) {
    if (!(s.extensions && s.extensions[Ne] && s.path && s.path === "pointer")) return null;
    let o = s.extensions[Ne].pointer;
    if (!o) return null;
    const c = [];
    o = o.replaceAll("/", ".");
    const l = o.split(".");
    var u = t.name !== void 0 && t.name !== null ? t.name : t.uuid;
    if (l[2] = u, l[3] === "morphTargetInfluences" && t.type === "Group") {
      for (const d of t.children)
        d instanceof Ka && d.morphTargetInfluences && (l[3] = d.name, l[4] = "morphTargetInfluences", f(this.parser));
      return c;
    }
    f(this.parser);
    function f(d) {
      o = l.join(".");
      let y;
      switch (i.itemSize) {
        case 1:
          y = nc;
          break;
        case 2:
        case 3:
          y = rc;
          break;
        case 4:
          o.endsWith(".quaternion") ? y = ec : y = ic;
          break;
      }
      if (!y) {
        console.warn("Unsupported output accessor format", i);
        return;
      }
      const _ = r.interpolation !== void 0 ? Eu[r.interpolation] : Uo;
      let p = d._getArrayFromAccessor(i);
      o.endsWith(".fov") && (p = p.map((v) => v / Math.PI * 180));
      const m = new y(
        o,
        e.array,
        p,
        _
      );
      if (_ === "CUBICSPLINE" && d._createCubicSplineTrackInterpolant(m), c.push(m), o && i.itemSize === 4 && o.startsWith(".materials.") && o.endsWith(".color")) {
        const v = new Float32Array(p.length / 4);
        for (let b = 0, x = p.length / 4; b < x; b += 1)
          v[b] = p[b * 4 + 3];
        const g = new y(
          o.replace(".color", ".opacity"),
          e.array,
          v,
          _
        );
        _ === "CUBICSPLINE" && d._createCubicSplineTrackInterpolant(m), c.push(g);
      }
    }
    return c;
  }
  _tryResolveTargetId(t, e) {
    let i = "";
    return e === "node" ? i = t.substring(7) : e === "material" ? i = t.substring(11) : e === "light" ? i = t.substring(39) : e === "camera" && (i = t.substring(9)), i = i.substring(0, i.indexOf("/")), Number.parseInt(i);
  }
  /* MOSTLY DUPLICATE of GLTFLoader.loadAnimation, but also tries to resolve KHR_animation_pointer. */
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(t) {
    const e = this, i = this.parser.json, r = this.parser, s = i.animations[t], a = s.name ? s.name : "animation_" + t, o = [], c = [], l = [], h = [], u = [];
    for (let f = 0, d = s.channels.length; f < d; f++) {
      const y = s.channels[f], _ = s.samplers[y.sampler], p = y.target, m = s.parameters !== void 0 ? s.parameters[_.input] : _.input, v = s.parameters !== void 0 ? s.parameters[_.output] : _.output;
      let g = e.loadAnimationTargetFromChannelWithAnimationPointer(y);
      g || (g = e.loadAnimationTargetFromChannel(y)), o.push(g), c.push(r.getDependency("accessor", m)), l.push(r.getDependency("accessor", v)), h.push(_), u.push(p);
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(c),
      Promise.all(l),
      Promise.all(h),
      Promise.all(u)
    ]).then(function(f) {
      const d = f[0], y = f[1], _ = f[2], p = f[3], m = f[4], v = [];
      for (let g = 0, b = d.length; g < b; g++) {
        const x = d[g], S = y[g], T = _[g], P = p[g], M = m[g];
        if (x === void 0) continue;
        x.updateMatrix && (x.updateMatrix(), x.matrixAutoUpdate = !0);
        let C = e.createAnimationTracksWithAnimationPointer(x, S, T, P, M);
        if (C || (C = r._createAnimationTracks(x, S, T, P, M)), C)
          for (let E = 0; E < C.length; E++)
            v.push(C[E]);
      }
      return new tc(a, void 0, v);
    });
  }
}
let Ao = !1, Ru = null;
function Au() {
  if (Ao) return;
  Ao = !0;
  const n = Ru ||= Ms.findNode;
  Ms.findNode = function(t, e) {
    if (e.startsWith(".materials.")) {
      const i = e.substring(11).substring(e.indexOf(".")), r = i.indexOf("."), s = r < 0 ? i : i.substring(0, r);
      let a = null;
      return t.traverse((o) => {
        a !== null || o.type !== "Mesh" && o.type !== "SkinnedMesh" || o.material && (o.material.uuid === s || o.material.name === s) && (a = o.material, a !== null && (i.endsWith(".map") ? a = a.map : i.endsWith(".emissiveMap") && (a = a.emissiveMap)));
      }), a;
    } else if (e.startsWith(".nodes.") || e.startsWith(".lights.") || e.startsWith(".cameras.")) {
      const i = e.split(".");
      let r;
      for (let s = 1; s < i.length; s++) {
        const a = i[s];
        if (a.length == 36)
          r = t.getObjectByProperty("uuid", a);
        else if (r && r[a]) {
          const c = Number.parseInt(a);
          let l = a;
          c >= 0 && (l = c), r = r[l];
        } else {
          const c = t.getObjectByName(a);
          c && (r = c);
        }
      }
      if (!r) {
        const s = n(t, i[2]);
        return s || console.warn(Ne + ": Property binding not found", e, t, t.name, i), s;
      }
      return r;
    }
    return n(t, e);
  };
}
const Gu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GLTFAnimationPointerExtension: ku
}, Symbol.toStringTag, { value: "Module" }));
export {
  Jc as $70d766613f57b014$export$2e2bcd8739ae039,
  Fu as BatchedParticleRenderer,
  Do as Builder,
  Gr as ByteBuffer,
  ei as ConstantColor,
  J as ConstantValue,
  Qt as Matrix4,
  sn as MeshBVH,
  Bu as MotionController,
  Kn as ParticleSystem,
  A as RenderMode,
  hc as SIZE_PREFIX_LENGTH,
  Zn as TrailParticle,
  wt as Vector4,
  Ju as WorkerBase,
  Iu as bundler,
  Du as createNoise4D,
  Ou as fetchProfile,
  Lu as index,
  Vu as index$1,
  Gu as index$2,
  Uu as md5,
  Nu as v5
};
