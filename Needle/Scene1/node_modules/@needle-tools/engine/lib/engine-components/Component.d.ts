/// <reference types="webxr" />
import { Euler, Object3D, Quaternion, Scene, Vector3 } from "three";
import { type AssetReference } from "../engine/engine_addressables.js";
import { type IInstantiateOptions } from "../engine/engine_gameobject.js";
import { SyncInstantiateOptions } from "../engine/engine_networking_instantiate.js";
import { Context, FrameEvent } from "../engine/engine_setup.js";
import type { Collision, ComponentInit, Constructor, ConstructorConcrete, GuidsMap, ICollider, IComponent, IGameObject, SourceIdentifier } from "../engine/engine_types.js";
import type { INeedleXRSessionEventReceiver, NeedleXRControllerEventArgs, NeedleXREventArgs } from "../engine/engine_xr.js";
import { type IPointerEventHandler, PointerEventData } from "./ui/PointerEvents.js";
/**
 * Base class for objects in Needle Engine. Extends {@link Object3D} from three.js.
 * GameObjects can have components attached to them, which can be used to add functionality to the object.
 * They manage their components and provide methods to add, remove and get components.
 *
 * All {@link Object3D} types loaded in Needle Engine have methods like {@link addComponent}.
 * These methods are available directly on the GameObject instance:
 * ```typescript
 * target.addComponent(MyComponent);
 * ```
 *
 * And can be called statically on the GameObject class as well:
 * ```typescript
 * GameObject.setActive(target, true);
 * ```
 */
export declare abstract class GameObject extends Object3D implements Object3D, IGameObject {
    /**
     * Indicates if the GameObject is currently active. Inactive GameObjects will not be rendered or updated.
     * When the activeSelf state changes, components will receive {@link Component.onEnable} or {@link Component.onDisable} callbacks.
     */
    abstract activeSelf: boolean;
    /** @deprecated Use {@link addComponent} instead */
    abstract addNewComponent<T extends IComponent>(type: ConstructorConcrete<T>, init?: ComponentInit<T>): T;
    /**
     * Creates a new component on this gameObject or adds an existing component instance
     * @param comp Component type constructor or existing component instance
     * @param init Optional initialization values for the component
     * @returns The newly created or added component
     */
    abstract addComponent<T extends IComponent>(comp: T | ConstructorConcrete<T>, init?: ComponentInit<T>): T;
    /**
     * Removes a component from this GameObject
     * @param comp Component instance to remove
     * @returns The removed component
     */
    abstract removeComponent<T extends IComponent>(comp: T): T;
    /**
     * Gets an existing component of the specified type or adds a new one if it doesn't exist
     * @param typeName Constructor of the component type to get or add
     * @returns The existing or newly added component
     */
    abstract getOrAddComponent<T>(typeName: ConstructorConcrete<T> | null): T;
    /**
     * Gets a component of the specified type attached to this GameObject
     * @param type Constructor of the component type to get
     * @returns The component if found, otherwise null
     */
    abstract getComponent<T>(type: Constructor<T>): T | null;
    /**
     * Gets all components of the specified type attached to this GameObject
     * @param type Constructor of the component type to get
     * @param arr Optional array to populate with the components
     * @returns Array of components
     */
    abstract getComponents<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    /**
     * Gets a component of the specified type in this GameObject's children hierarchy
     * @param type Constructor of the component type to get
     * @returns The first matching component if found, otherwise null
     */
    abstract getComponentInChildren<T>(type: Constructor<T>): T | null;
    /**
     * Gets all components of the specified type in this GameObject's children hierarchy
     * @param type Constructor of the component type to get
     * @param arr Optional array to populate with the components
     * @returns Array of components
     */
    abstract getComponentsInChildren<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    /**
     * Gets a component of the specified type in this GameObject's parent hierarchy
     * @param type Constructor of the component type to get
     * @returns The first matching component if found, otherwise null
     */
    abstract getComponentInParent<T>(type: Constructor<T>): T | null;
    /**
     * Gets all components of the specified type in this GameObject's parent hierarchy
     * @param type Constructor of the component type to get
     * @param arr Optional array to populate with the components
     * @returns Array of components
     */
    abstract getComponentsInParent<T>(type: Constructor<T>, arr?: T[]): Array<T>;
    /**
     * The position of this GameObject in world space
     */
    abstract get worldPosition(): Vector3;
    abstract set worldPosition(val: Vector3);
    /**
     * The rotation of this GameObject in world space as a quaternion
     */
    abstract set worldQuaternion(val: Quaternion);
    abstract get worldQuaternion(): Quaternion;
    /**
     * The rotation of this GameObject in world space in euler angles (degrees)
     */
    abstract set worldRotation(val: Vector3);
    abstract get worldRotation(): Vector3;
    /**
     * The scale of this GameObject in world space
     */
    abstract set worldScale(val: Vector3);
    abstract get worldScale(): Vector3;
    /**
     * The forward direction vector of this GameObject in world space
     */
    abstract get worldForward(): Vector3;
    /**
     * The right direction vector of this GameObject in world space
     */
    abstract get worldRight(): Vector3;
    /**
     * The up direction vector of this GameObject in world space
     */
    abstract get worldUp(): Vector3;
    /**
     * Unique identifier for this GameObject
     */
    guid: string | undefined;
    /**
     * Destroys this GameObject and all its components.
     * Internally, this is added to the three.js {@link Object3D} prototype.
     */
    abstract destroy(): any;
    /**
     * Checks if a GameObject has been destroyed
     * @param go The GameObject to check
     * @returns True if the GameObject has been destroyed
     */
    static isDestroyed(go: Object3D): boolean;
    /**
     * Sets the active state of a GameObject
     * @param go The GameObject to modify
     * @param active Whether the GameObject should be active
     * @param processStart Whether to process the start callbacks if being activated
     */
    static setActive(go: Object3D, active: boolean, processStart?: boolean): void;
    /**
     * Checks if the GameObject itself is active (same as go.visible)
     * @param go The GameObject to check
     * @returns True if the GameObject is active
     */
    static isActiveSelf(go: Object3D): boolean;
    /**
     * Checks if the GameObject is active in the hierarchy (e.g. if any parent is invisible or not in the scene it will be false)
     * @param go The GameObject to check
     * @returns True if the GameObject is active in the hierarchy
     */
    static isActiveInHierarchy(go: Object3D): boolean;
    /**
     * Marks a GameObject to be rendered using instancing
     * @param go The GameObject to mark
     * @param instanced Whether the GameObject should use instanced rendering
     */
    static markAsInstancedRendered(go: Object3D, instanced: boolean): void;
    /**
     * Checks if a GameObject is using instanced rendering
     * @param instance The GameObject to check
     * @returns True if the GameObject is using instanced rendering
     */
    static isUsingInstancing(instance: Object3D): boolean;
    /**
     * Executes a callback for all components of the provided type on the provided object and its children
     * @param instance Object to run the method on
     * @param cb Callback to run on each component, "return undefined;" to continue and "return <anything>;" to break the loop
     * @param recursive If true, the method will be run on all children as well
     * @returns The last return value of the callback
     */
    static foreachComponent(instance: Object3D, cb: (comp: Component) => any, recursive?: boolean): any;
    /**
     * Creates a new instance of the provided object that will be replicated to all connected clients
     * @param instance Object to instantiate
     * @param opts Options for the instantiation
     * @returns The newly created instance or null if creation failed
     */
    static instantiateSynced(instance: GameObject | Object3D | null, opts: SyncInstantiateOptions): GameObject | null;
    /**
     * Creates a new instance of the provided object (like cloning it including all components and children)
     * @param instance Object to instantiate
     * @param opts Options for the instantiation (e.g. with what parent, position, etc.)
     * @returns The newly created instance
     */
    static instantiate(instance: AssetReference, opts?: IInstantiateOptions | null | undefined): Promise<Object3D | null>;
    static instantiate(instance: GameObject | Object3D, opts?: IInstantiateOptions | null | undefined): GameObject;
    /**
     * Destroys an object on all connected clients (if in a networked session)
     * @param instance Object to destroy
     * @param context Optional context to use
     * @param recursive If true, all children will be destroyed as well
     */
    static destroySynced(instance: Object3D | Component, context?: Context, recursive?: boolean): void;
    /**
     * Destroys an object
     * @param instance Object to destroy
     * @param recursive If true, all children will be destroyed as well. Default: true
     */
    static destroy(instance: Object3D | Component, recursive?: boolean): void;
    /**
     * Adds an object to parent and ensures all components are properly registered
     * @param instance Object to add
     * @param parent Parent to add the object to
     * @param context Optional context to use
     */
    static add(instance: Object3D | null | undefined, parent: Object3D, context?: Context): void;
    /**
     * Removes the object from its parent and deactivates all of its components
     * @param instance Object to remove
     */
    static remove(instance: Object3D | null | undefined): void;
    /**
     * Invokes a method on all components including children (if a method with that name exists)
     * @param go GameObject to invoke the method on
     * @param functionName Name of the method to invoke
     * @param args Arguments to pass to the method
     */
    static invokeOnChildren(go: Object3D | null | undefined, functionName: string, ...args: any): void;
    /**
     * Invokes a method on all components that have a method matching the provided name
     * @param go GameObject to invoke the method on
     * @param functionName Name of the method to invoke
     * @param children Whether to invoke on children as well
     * @param args Arguments to pass to the method
     */
    static invoke(go: Object3D | null | undefined, functionName: string, children?: boolean, ...args: any): void;
    /** @deprecated use `addComponent` */
    static addNewComponent<T extends IComponent>(go: IGameObject | Object3D, type: T | ConstructorConcrete<T>, init?: ComponentInit<T>, callAwake?: boolean): T;
    /**
     * Adds a new component (or moves an existing component) to the provided object
     * @param go Object to add the component to
     * @param instanceOrType If an instance is provided it will be moved to the new object, if a type is provided a new instance will be created
     * @param init Optional init object to initialize the component with
     * @param opts Optional options for adding the component
     * @returns The added or moved component
     */
    static addComponent<T extends IComponent>(go: IGameObject | Object3D, instanceOrType: T | ConstructorConcrete<T>, init?: ComponentInit<T>, opts?: {
        callAwake: boolean;
    }): T;
    /**
     * Moves a component to a new object
     * @param go GameObject to move the component to
     * @param instance Component to move
     * @returns The moved component
     */
    static moveComponent<T extends IComponent>(go: IGameObject | Object3D, instance: T | ConstructorConcrete<T>): T;
    /**
     * Removes a component from its object
     * @param instance Component to remove
     * @returns The removed component
     */
    static removeComponent<T extends IComponent>(instance: T): T;
    /**
     * Gets or adds a component of the specified type
     * @param go GameObject to get or add the component to
     * @param typeName Constructor of the component type
     * @returns The existing or newly added component
     */
    static getOrAddComponent<T extends IComponent>(go: IGameObject | Object3D, typeName: ConstructorConcrete<T>): T;
    /**
     * Gets a component on the provided object
     * @param go GameObject to get the component from
     * @param typeName Constructor of the component type
     * @returns The component if found, otherwise null
     */
    static getComponent<T extends IComponent>(go: IGameObject | Object3D | null, typeName: Constructor<T> | null): T | null;
    /**
     * Gets all components of the specified type on the provided object
     * @param go GameObject to get the components from
     * @param typeName Constructor of the component type
     * @param arr Optional array to populate with the components
     * @returns Array of components
     */
    static getComponents<T extends IComponent>(go: IGameObject | Object3D | null, typeName: Constructor<T>, arr?: T[] | null): T[];
    /**
     * Finds an object or component by its unique identifier
     * @param guid Unique identifier to search for
     * @param hierarchy Root object to search in
     * @returns The found GameObject or Component, or null/undefined if not found
     */
    static findByGuid(guid: string, hierarchy: Object3D): GameObject | Component | null | undefined;
    /**
     * Finds the first object of the specified component type in the scene
     * @param typeName Constructor of the component type
     * @param context Context or root object to search in
     * @param includeInactive Whether to include inactive objects in the search
     * @returns The first matching component if found, otherwise null
     */
    static findObjectOfType<T extends IComponent>(typeName: Constructor<T>, context?: Context | Object3D, includeInactive?: boolean): T | null;
    /**
     * Finds all objects of the specified component type in the scene
     * @param typeName Constructor of the component type
     * @param context Context or root object to search in
     * @returns Array of matching components
     */
    static findObjectsOfType<T extends IComponent>(typeName: Constructor<T>, context?: Context | Object3D): Array<T>;
    /**
     * Gets a component of the specified type in the gameObject's children hierarchy
     * @param go GameObject to search in
     * @param typeName Constructor of the component type
     * @returns The first matching component if found, otherwise null
     */
    static getComponentInChildren<T extends IComponent>(go: IGameObject | Object3D, typeName: Constructor<T>): T | null;
    /**
     * Gets all components of the specified type in the gameObject's children hierarchy
     * @param go GameObject to search in
     * @param typeName Constructor of the component type
     * @param arr Optional array to populate with the components
     * @returns Array of components
     */
    static getComponentsInChildren<T extends IComponent>(go: IGameObject | Object3D, typeName: Constructor<T>, arr?: T[] | null): Array<T>;
    /**
     * Gets a component of the specified type in the gameObject's parent hierarchy
     * @param go GameObject to search in
     * @param typeName Constructor of the component type
     * @returns The first matching component if found, otherwise null
     */
    static getComponentInParent<T extends IComponent>(go: IGameObject | Object3D, typeName: Constructor<T>): T | null;
    /**
     * Gets all components of the specified type in the gameObject's parent hierarchy
     * @param go GameObject to search in
     * @param typeName Constructor of the component type
     * @param arr Optional array to populate with the components
     * @returns Array of components
     */
    static getComponentsInParent<T extends IComponent>(go: IGameObject | Object3D, typeName: Constructor<T>, arr?: Array<T> | null): Array<T>;
    /**
     * Gets all components on the gameObject
     * @param go GameObject to get components from
     * @returns Array of all components
     */
    static getAllComponents(go: IGameObject | Object3D): Component[];
    /**
     * Iterates through all components on the gameObject
     * @param go GameObject to iterate components on
     * @returns Generator yielding each component
     */
    static iterateComponents(go: IGameObject | Object3D): Generator<any, void, unknown>;
}
/**
 * Needle Engine component base class. Component's are the main building blocks of the Needle Engine.
 * Derive from {@link Behaviour} to implement your own using the provided lifecycle methods.
 * Components can be added to any {@link Object3D} using {@link addComponent} or {@link GameObject.addComponent}.
 *
 * The most common lifecycle methods are {@link update}, {@link awake}, {@link start}, {@link onEnable}, {@link onDisable} and {@link onDestroy}.
 *
 * XR specific callbacks include {@link onEnterXR}, {@link onLeaveXR}, {@link onUpdateXR}, {@link onXRControllerAdded} and {@link onXRControllerRemoved}.
 *
 * To receive pointer events implement {@link onPointerDown}, {@link onPointerUp}, {@link onPointerEnter}, {@link onPointerExit} and {@link onPointerMove}.
 *
 * @example
 * ```typescript
 * import { Behaviour } from "@needle-tools/engine";
 * export class MyComponent extends Behaviour {
 *  start() {
 *     console.log("Hello World");
 *  }
 *  update() {
 *    console.log("Frame", this.context.time.frame);
 *  }
 * }
 * ```
 *
 * @group Components
 */
export declare abstract class Component implements IComponent, EventTarget, Partial<INeedleXRSessionEventReceiver>, Partial<IPointerEventHandler> {
    /**
     * Indicates whether this object is a component
     * @internal
     */
    get isComponent(): boolean;
    private __context;
    /**
     * The context this component belongs to, providing access to the runtime environment
     * including physics, timing utilities, camera, and scene
     */
    get context(): Context;
    set context(context: Context);
    /**
     * Shorthand accessor for the current scene from the context
     * @returns The scene this component belongs to
     */
    get scene(): Scene;
    /**
     * The layer value of the GameObject this component is attached to
     * Used for visibility and physics filtering
     */
    get layer(): number;
    /**
     * The name of the GameObject this component is attached to
     * Used for debugging and finding objects
     */
    get name(): string;
    private __name?;
    set name(str: string);
    /**
     * The tag of the GameObject this component is attached to
     * Used for categorizing objects and efficient lookup
     */
    get tag(): string;
    set tag(str: string);
    /**
     * Indicates whether the GameObject is marked as static
     * Static objects typically don't move and can be optimized by the engine
     */
    get static(): boolean;
    set static(value: boolean);
    /**
     * Checks if this component is currently active (enabled and part of an active GameObject hierarchy)
     * Components that are inactive won't receive lifecycle method calls
     * @returns True if the component is enabled and all parent GameObjects are active
     */
    get activeAndEnabled(): boolean;
    private get __isActive();
    private get __isActiveInHierarchy();
    private set __isActiveInHierarchy(value);
    /**
     * Reference to the GameObject this component is attached to
     * This is a three.js Object3D with additional GameObject functionality
     */
    gameObject: GameObject;
    /**
     * Unique identifier for this component instance,
     * used for finding and tracking components
     */
    guid: string;
    /**
     * Identifier for the source asset that created this component.
     * For example, URL to the glTF file this component was loaded from
     */
    sourceId?: SourceIdentifier;
    /**
     * Called when this component needs to remap guids after an instantiate operation.
     * @param guidsMap Mapping from old guids to newly generated guids
     */
    resolveGuids?(guidsMap: GuidsMap): void;
    /**
     * Called once when the component becomes active for the first time.
     * This is the first lifecycle callback to be invoked
     */
    awake(): void;
    /**
     * Called every time the component becomes enabled or active in the hierarchy.
     * Invoked after {@link awake} and before {@link start}.
     */
    onEnable(): void;
    /**
     * Called every time the component becomes disabled or inactive in the hierarchy.
     * Invoked when the component or any parent GameObject becomes invisible
     */
    onDisable(): void;
    /**
     * Called when the component is destroyed.
     * Use for cleanup operations like removing event listeners
     */
    onDestroy(): void;
    /**
     * Called when a field decorated with @validate() is modified.
     * @param prop The name of the field that was changed
     */
    onValidate?(prop?: string): void;
    /**
     * Called when the context's pause state changes.
     * @param isPaused Whether the context is currently paused
     * @param wasPaused The previous pause state
     */
    onPausedChanged?(isPaused: boolean, wasPaused: boolean): void;
    /**
     * Called once at the beginning of the first frame after the component is enabled.
     * Use for initialization that requires other components to be awake.
     */
    start?(): void;
    /**
     * Called at the beginning of each frame before regular updates.
     * Use for logic that needs to run before standard update callbacks.
     */
    earlyUpdate?(): void;
    /**
     * Called once per frame during the main update loop.
     * The primary location for frame-based game logic.
     */
    update?(): void;
    /**
     * Called after all update functions have been called.
     * Use for calculations that depend on other components being updated first.
     */
    lateUpdate?(): void;
    /**
     * Called immediately before the scene is rendered.
     * @param frame Current XRFrame if in an XR session, null otherwise
     */
    onBeforeRender?(frame: XRFrame | null): void;
    /**
     * Called after the scene has been rendered.
     * Use for post-processing or UI updates that should happen after rendering
     */
    onAfterRender?(): void;
    /**
     * Called when this component's collider begins colliding with another collider.
     * @param col Information about the collision that occurred
     */
    onCollisionEnter?(col: Collision): any;
    /**
     * Called when this component's collider stops colliding with another collider.
     * @param col Information about the collision that ended
     */
    onCollisionExit?(col: Collision): any;
    /**
     * Called each frame while this component's collider is colliding with another collider
     * @param col Information about the ongoing collision
     */
    onCollisionStay?(col: Collision): any;
    /**
     * Called when this component's trigger collider is entered by another collider
     * @param col The collider that entered this trigger
     */
    onTriggerEnter?(col: ICollider): any;
    /**
     * Called each frame while another collider is inside this component's trigger collider
     * @param col The collider that is inside this trigger
     */
    onTriggerStay?(col: ICollider): any;
    /**
     * Called when another collider exits this component's trigger collider
     * @param col The collider that exited this trigger
     */
    onTriggerExit?(col: ICollider): any;
    /**
     * Determines if this component supports a specific XR mode
     * @param mode The XR session mode to check support for
     * @returns True if the component supports the specified mode
     */
    supportsXR?(mode: XRSessionMode): boolean;
    /**
     * Called before an XR session is requested
     * Use to modify session initialization parameters
     * @param mode The XR session mode being requested
     * @param args The session initialization parameters that can be modified
     */
    onBeforeXR?(mode: XRSessionMode, args: XRSessionInit): void;
    /**
     * Called when this component joins an XR session or becomes active in a running session
     * @param args Event data for the XR session
     */
    onEnterXR?(args: NeedleXREventArgs): void;
    /**
     * Called each frame while this component is active in an XR session
     * @param args Event data for the current XR frame
     */
    onUpdateXR?(args: NeedleXREventArgs): void;
    /**
     * Called when this component exits an XR session or becomes inactive during a session
     * @param args Event data for the XR session
     */
    onLeaveXR?(args: NeedleXREventArgs): void;
    /**
     * Called when an XR controller is connected or when this component becomes active
     * in a session with existing controllers
     * @param args Event data for the controller that was added
     */
    onXRControllerAdded?(args: NeedleXRControllerEventArgs): void;
    /**
     * Called when an XR controller is disconnected or when this component becomes inactive
     * during a session with controllers
     * @param args Event data for the controller that was removed
     */
    onXRControllerRemoved?(args: NeedleXRControllerEventArgs): void;
    /**
     * Called when a pointer enters this component's GameObject
     * @param args Data about the pointer event
     */
    onPointerEnter?(args: PointerEventData): any;
    /**
     * Called when a pointer moves while over this component's GameObject
     * @param args Data about the pointer event
     */
    onPointerMove?(args: PointerEventData): any;
    /**
     * Called when a pointer exits this component's GameObject
     * @param args Data about the pointer event
     */
    onPointerExit?(args: PointerEventData): any;
    /**
     * Called when a pointer button is pressed while over this component's GameObject
     * @param args Data about the pointer event
     */
    onPointerDown?(args: PointerEventData): any;
    /**
     * Called when a pointer button is released while over this component's GameObject
     * @param args Data about the pointer event
     */
    onPointerUp?(args: PointerEventData): any;
    /**
     * Called when a pointer completes a click interaction with this component's GameObject
     * @param args Data about the pointer event
     */
    onPointerClick?(args: PointerEventData): any;
    /**
     * Starts a coroutine that can yield to wait for events.
     * Coroutines allow for time-based sequencing of operations without blocking.
     * Coroutines are based on generator functions, a JavaScript language feature.
     *
     * @param routine Generator function to start
     * @param evt Event to register the coroutine for (default: FrameEvent.Update)
     * @returns The generator function that can be used to stop the coroutine
     * @example
     * Time-based sequencing of operations
     * ```ts
     * *myCoroutine() {
     *   yield WaitForSeconds(1); // wait for 1 second
     *   yield WaitForFrames(10); // wait for 10 frames
     *   yield new Promise(resolve => setTimeout(resolve, 1000)); // wait for a promise to resolve
     * }
     * ```
     * @example
     * Coroutine that logs a message every 5 frames
     * ```ts
     * onEnable() {
     *   this.startCoroutine(this.myCoroutine());
     * }
     * private *myCoroutine() {
     *   while(this.activeAndEnabled) {
     *     console.log("Hello World", this.context.time.frame);
     *     // wait for 5 frames
     *     for(let i = 0; i < 5; i++) yield;
     *   }
     * }
     * ```
     */
    startCoroutine(routine: Generator, evt?: FrameEvent): Generator;
    /**
     * Stops a coroutine that was previously started with startCoroutine
     * @param routine The routine to be stopped
     * @param evt The frame event the routine was registered with
     */
    stopCoroutine(routine: Generator, evt?: FrameEvent): void;
    /**
     * Checks if this component has been destroyed
     * @returns True if the component or its GameObject has been destroyed
     */
    get destroyed(): boolean;
    /**
     * Destroys this component and removes it from its GameObject
     * After destruction, the component will no longer receive lifecycle callbacks
     */
    destroy(): void;
    /** @internal */
    protected __didAwake: boolean;
    /** @internal */
    private __didStart;
    /** @internal */
    protected __didEnable: boolean;
    /** @internal */
    protected __isEnabled: boolean | undefined;
    /** @internal */
    private __destroyed;
    /** @internal */
    get __internalDidAwakeAndStart(): boolean;
    /** @internal */
    constructor(init?: ComponentInit<Component>);
    /** @internal */
    __internalNewInstanceCreated(init?: ComponentInit<this>): this;
    /**
     * Initializes component properties from an initialization object
     * @param init Object with properties to copy to this component
     * @internal
     */
    _internalInit(init?: ComponentInit<this>): void;
    /** @internal */
    __internalAwake(): void;
    /** @internal */
    __internalStart(): void;
    /** @internal */
    __internalEnable(isAddingToScene?: boolean): boolean;
    /** @internal */
    __internalDisable(isRemovingFromScene?: boolean): void;
    /** @internal */
    __internalDestroy(): void;
    /**
     * Controls whether this component is enabled
     * Disabled components don't receive lifecycle callbacks
     */
    get enabled(): boolean;
    set enabled(val: boolean);
    /**
     * Gets the position of this component's GameObject in world space.
     * Note: This is equivalent to calling `this.gameObject.worldPosition`
     */
    get worldPosition(): Vector3;
    /**
     * Sets the position of this component's GameObject in world space
     * @param val The world position vector to set
     */
    set worldPosition(val: Vector3);
    /**
     * Sets the position of this component's GameObject in world space using individual coordinates
     * @param x X-coordinate in world space
     * @param y Y-coordinate in world space
     * @param z Z-coordinate in world space
     */
    setWorldPosition(x: number, y: number, z: number): void;
    /**
     * Gets the rotation of this component's GameObject in world space as a quaternion
     * Note: This is equivalent to calling `this.gameObject.worldQuaternion`
     */
    get worldQuaternion(): Quaternion;
    /**
     * Sets the rotation of this component's GameObject in world space using a quaternion
     * @param val The world rotation quaternion to set
     */
    set worldQuaternion(val: Quaternion);
    /**
     * Sets the rotation of this component's GameObject in world space using quaternion components
     * @param x X component of the quaternion
     * @param y Y component of the quaternion
     * @param z Z component of the quaternion
     * @param w W component of the quaternion
     */
    setWorldQuaternion(x: number, y: number, z: number, w: number): void;
    /**
     * Gets the rotation of this component's GameObject in world space as Euler angles (in radians)
     */
    get worldEuler(): Euler;
    /**
     * Sets the rotation of this component's GameObject in world space using Euler angles (in radians)
     * @param val The world rotation Euler angles to set
     */
    set worldEuler(val: Euler);
    /**
     * Gets the rotation of this component's GameObject in world space as Euler angles (in degrees)
     * Note: This is equivalent to calling `this.gameObject.worldRotation`
     */
    get worldRotation(): Vector3;
    /**
     * Sets the rotation of this component's GameObject in world space using Euler angles (in degrees)
     * @param val The world rotation vector to set (in degrees)
     */
    set worldRotation(val: Vector3);
    /**
     * Sets the rotation of this component's GameObject in world space using individual Euler angles
     * @param x X-axis rotation
     * @param y Y-axis rotation
     * @param z Z-axis rotation
     * @param degrees Whether the values are in degrees (true) or radians (false)
     */
    setWorldRotation(x: number, y: number, z: number, degrees?: boolean): void;
    private static _forward;
    /**
     * Gets the forward direction vector (0,0,-1) of this component's GameObject in world space
     */
    get forward(): Vector3;
    private static _right;
    /**
     * Gets the right direction vector (1,0,0) of this component's GameObject in world space
     */
    get right(): Vector3;
    private static _up;
    /**
     * Gets the up direction vector (0,1,0) of this component's GameObject in world space
     */
    get up(): Vector3;
    /**
     * Storage for event listeners registered to this component
     * @private
     */
    private _eventListeners;
    /**
     * Registers an event listener for the specified event type
     * @param type The event type to listen for
     * @param listener The callback function to execute when the event occurs
     */
    addEventListener<T extends Event>(type: string, listener: (evt: T) => any): void;
    /**
     * Removes a previously registered event listener
     * @param type The event type the listener was registered for
     * @param listener The callback function to remove
     */
    removeEventListener<T extends Event>(type: string, listener: (arg: T) => any): void;
    /**
     * Dispatches an event to all registered listeners
     * @param evt The event object to dispatch
     * @returns Always returns false (standard implementation of EventTarget)
     */
    dispatchEvent(evt: Event): boolean;
}
export { Component as Behaviour };
