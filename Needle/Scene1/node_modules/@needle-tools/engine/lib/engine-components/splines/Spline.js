var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BufferGeometry, CatmullRomCurve3, Line, LineBasicMaterial, LineCurve3, Quaternion, Vector3 } from "three";
import { Mathf } from "../../engine/engine_math.js";
import { serializeable } from "../../engine/engine_serialization.js";
import { getParam } from "../../engine/engine_utils.js";
import { Behaviour } from "../Component.js";
const debug = getParam("debugsplines");
export class SplineData {
    position = new Vector3();
    rotation = new Quaternion();
    tangentIn = new Vector3();
    tangentOut = new Vector3();
}
__decorate([
    serializeable(Vector3)
], SplineData.prototype, "position", void 0);
__decorate([
    serializeable(Quaternion)
], SplineData.prototype, "rotation", void 0);
__decorate([
    serializeable(Vector3)
], SplineData.prototype, "tangentIn", void 0);
__decorate([
    serializeable(Vector3)
], SplineData.prototype, "tangentOut", void 0);
// enum SplineTypeEnum {
//     CatmullRom = 0,
//     Bezier = 1,
//     Linear = 2
// }
// type SplineType = "CatmullRom" | "Bezier" | "Linear";
//@dont-generate-component
/**
 * Holds spline data and generates a spline curve. Use with SplineWalker to move objects along the spline or call getPointAt to sample points on the spline.
 * The spline is defined by an array of knots (SplineData) which define position, rotation and tangents.
 *
 * You can create a SplineContainer from an array of points using the static method 'createFromPoints'.
 */
export class SplineContainer extends Behaviour {
    /**
     * Adds a knot to the end of the spline.
     */
    addKnot(knot) {
        if (knot instanceof SplineData) {
            this.spline.push(knot);
            this._isDirty = true;
        }
        else {
            const k = new SplineData();
            k.position.copy(knot.position);
            this.spline.push(k);
            this._isDirty = true;
        }
        return this;
    }
    /**
     * Removes a knot by index or by reference.
     */
    removeKnot(index) {
        if (typeof index === "number") {
            this.spline.splice(index, 1);
            this._isDirty = true;
        }
        else {
            const i = this.spline.indexOf(index);
            if (i !== -1) {
                this.spline.splice(i, 1);
                this._isDirty = true;
            }
        }
        return this;
    }
    /**
     * Gets a point on the spline in world space.
     */
    getPointAt(t, target) {
        if (!this.curve)
            return new Vector3();
        const pos = this.curve.getPointAt(Mathf.clamp01(t), target);
        const worldMatrix = this.gameObject.matrixWorld ?? undefined;
        if (worldMatrix) {
            pos.applyMatrix4(worldMatrix);
        }
        return pos;
    }
    /**
     * Marks the spline as dirty, causing it to be rebuilt on the next update.
     */
    markDirty() {
        this._isDirty = true;
    }
    /**
     * Gets the tangent vector on the spline in world space.
     */
    getTangentAt(t, target) {
        if (!this.curve)
            return target ?? new Vector3();
        const wr = this.gameObject.worldQuaternion;
        return this.curve.getTangentAt(Mathf.clamp01(t), target).applyQuaternion(wr);
    }
    set closed(value) {
        this._closed = value;
        this._isDirty = true;
    }
    get closed() { return this._closed; }
    _closed = false;
    /** Spline data. Call 'markDirty' if modified */
    spline = [];
    /** Enable to render the spline curve for debugging */
    set debug(debug) {
        if (debug && !this._builtCurve)
            this.buildCurve();
        if (!this._debugLine)
            return;
        this._debugLine.visible = debug;
    }
    /** Gets the spline curve generated from the 'spline' data */
    get curve() {
        return this._curve;
    }
    get isDirty() { return this._isDirty; }
    _isDirty = false;
    _curve = null;
    _builtCurve = false;
    _debugLine = null;
    /** @internal */
    awake() {
        if (debug) {
            console.log(`[Spline] ${this.name}`, this);
            this.buildCurve();
        }
    }
    /** @internal */
    update() {
        if (this._isDirty) {
            this.buildCurve(true);
        }
        if (this._debugLine && this._debugLine.parent !== this.gameObject)
            this.gameObject.add(this._debugLine);
    }
    buildCurve(force = false) {
        if (this._builtCurve && !force)
            return;
        this._builtCurve = true;
        if (!this.spline) {
            console.error("[Spline] Can not build curve, no spline data", this.name);
            return;
        }
        this._isDirty = false;
        this._curve = createCatmullRomCurve(this.spline, this.closed);
        this.buildDebugCurve();
        // TODO: Unity supports spline interpolation type per knot which we don't support right now. Additionally EditType is deprecated. For simplicity we're just supporting CatmullRom for now.
        // switch (this.editType) {
        //     case SplineType.CatmullRom:
        //         this.createCatmullRomCurve();
        //         break;
        //     case SplineType.Bezier:
        //         console.warn("Bezier spline not implemented yet", this.name);
        //         this.createCatmullRomCurve();
        //         // this.createBezierCurve();
        //         break;
        //     case SplineType.Linear:
        //         this.createLinearCurve();
        //         break;
        // }
    }
    buildDebugCurve() {
        if (debug && this.spline && this._curve) {
            this._debugLine?.removeFromParent();
            this._debugLine = null;
            const material = new LineBasicMaterial({
                color: 0x6600ff,
            });
            const res = this.spline.length * 10;
            const splinePoints = this._curve.getPoints(res);
            const geometry = new BufferGeometry().setFromPoints(splinePoints);
            this._debugLine = new Line(geometry, material);
            this.gameObject?.add(this._debugLine);
        }
    }
}
__decorate([
    serializeable()
], SplineContainer.prototype, "closed", null);
__decorate([
    serializeable(SplineData)
], SplineContainer.prototype, "spline", void 0);
function createCatmullRomCurve(data, closed) {
    const points = data.map(knot => new Vector3(-knot.position.x, knot.position.y, knot.position.z));
    if (points.length === 1)
        points.push(points[0]);
    const averageTension = data.reduce((acc, knot) => acc + Math.abs(knot.tangentOut.x) + Math.abs(knot.tangentOut.y) + Math.abs(knot.tangentOut.z), 0) / data.length;
    const tension = Mathf.remap(averageTension, 0, 0.3, 0, .5);
    return new CatmullRomCurve3(points, closed, "catmullrom", tension);
}
function createLinearCurve(data, closed) {
    if (!data || data.length < 2)
        return null;
    const points = data.map(knot => new Vector3(-knot.position.x, knot.position.y, knot.position.z));
    if (closed)
        points.push(points[0]);
    return new LineCurve3(points.at(0), points.at(1));
}
// function createBezierCurve(data: SplineData[], closed: boolean): CubicBezierCurve3 | null {
//     if (!data || data.length < 2) return null;
//     for (let k = 0; k < data.length; k++) {
//         const k0 = data[k];
//         let nextIndex = k + 1;
//         if (nextIndex >= data.length) {
//             if (!closed) break;
//             nextIndex = 0;
//         }
//         const k1 = data[nextIndex];
//         // points
//         const p0 = new Vector3(-k0.position.x, k0.position.y, k0.position.z);
//         const p1 = new Vector3(-k1.position.x, k1.position.y, k1.position.z);
//         // tangents
//         const t0 = new Vector3(-k0.tangentOut.x, k0.tangentOut.y, k0.tangentOut.z);
//         const t1 = new Vector3(-k1.tangentIn.x, k1.tangentIn.y, k1.tangentIn.z);
//         // rotations
//         // const q0 = k0.rotation;// new Quaternion(k0.rotation.value.x, k0.rotation.value.y, k0.rotation.value.z, k0.rotation.value.w);
//         // const q1 = k1.rotation;// new Quaternion(k1.rotation.value.x, k1.rotation.value.y, k1.rotation.value.z, k1.rotation.value.w);
//         // const a = new Vector3(0,1,0);
//         // const angle = Math.PI*.5;
//         // t0.sub(p0).applyQuaternion(q0).add(p0);
//         // t1.sub(p1).applyQuaternion(q1).add(p1);
//         t0.add(p0);
//         // t0.applyQuaternion(q0);
//         t1.add(p1);
//         const curve = new CubicBezierCurve3(p0, t0, t1, p1);
//         return curve;
//     }
//     return null;
// }
// class SplineCurve {
//     private spline: Spline;
//     constructor(spline: Spline) {
//         this.spline = spline;
//     }
//     getPoints(num: number): Vector3[] {
//         const points: Vector3[] = [];
//         const samplePerKnot = num / this.spline.length;
//         for (let k = 1; k < this.spline.length; k++) {
//             const cur = this.spline[k];
//             const prev = this.spline[k - 1];
//             for (let i = 0; i < samplePerKnot; i++) {
//                 const t = i / (samplePerKnot - 1);
//                 console.log(CurveUtils);
//                 const x = this.interpolate(-prev.Position.x, -cur.Position.x, -prev.tangentOut.x, -cur.TangentIn.x, t);
//                 const y = this.interpolate(prev.Position.y, cur.Position.y, prev.tangentOut.y, cur.TangentIn.y, t);
//                 const z = this.interpolate(prev.Position.z, cur.Position.z, prev.tangentOut.z, cur.TangentIn.z, t);
//                 points.push(new Vector3(x, y, z));
//             }
//         }
//         return points;
//     }
//     interpolate(p0, p1, p2, p3, t) {
//         var v0 = (p2 - p0) * 0.5;
//         var v1 = (p3 - p1) * 0.5;
//         var t2 = t * t;
//         var t3 = t * t2;
//         return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
//     }
// }
//# sourceMappingURL=Spline.js.map