var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { serializable } from "../../engine/engine_serialization_decorator.js";
import { getTempVector } from "../../engine/engine_three_utils.js";
import { Behaviour } from "../Component.js";
/**
 * The CursorFollow component makes the object follow the cursor (or touch) position on screen.
 */
export class CursorFollow extends Behaviour {
    /**
     * Damping for the movement, set to 0 for instant movement
     * @default 0
     */
    damping = 0;
    /**
     * If true, the initial distance to the camera is maintained when following the cursor.
     * @default true
     */
    keepDistance = true;
    awake() {
        this._distance = -1;
    }
    _distance = -1;
    updateDistance() {
        if (this.keepDistance && this._distance !== -1) {
            return;
        }
        this._distance = this.gameObject.worldPosition.distanceTo(this.context.mainCamera.worldPosition);
    }
    /** @internal */
    update() {
        // continuously update distance in case camera or object moves
        this.updateDistance();
        // follow cursor in screenspace but maintain initial distance from camera
        const cursor = this.context.input.mousePositionRC;
        const camera = this.context.mainCamera;
        const cameraPosition = camera.worldPosition;
        // create ray from camera through cursor position
        const rayDirection = getTempVector(cursor.x, cursor.y, 1).unproject(camera);
        rayDirection.sub(cameraPosition).normalize();
        // position object at initial distance along the ray
        const newPosition = rayDirection.multiplyScalar(this._distance).add(cameraPosition);
        if (this.damping > 0) {
            const pos = this.gameObject.worldPosition;
            pos.lerp(newPosition, this.context.time.deltaTime / this.damping);
            this.gameObject.worldPosition = pos;
        }
        else {
            this.gameObject.worldPosition = newPosition;
        }
    }
}
__decorate([
    serializable()
], CursorFollow.prototype, "damping", void 0);
__decorate([
    serializable()
], CursorFollow.prototype, "keepDistance", void 0);
//# sourceMappingURL=CursorFollow.js.map