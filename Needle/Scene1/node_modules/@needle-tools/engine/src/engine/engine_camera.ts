import { Camera, HemisphereLightHelper, Object3D, PerspectiveCamera, Vector2, WebGLRenderer } from "three";

import { Mathf } from "./engine_math.js";
import type { ICameraController } from "./engine_types.js";


const $cameraController = "needle:cameraController";

/** Get the camera controller for the given camera (if any)
 */
export function getCameraController(cam: Camera): ICameraController | null {
    return cam[$cameraController];
}

/** Set the camera controller for the given camera */
export function setCameraController(cam: Camera, cameraController: ICameraController, active: boolean) {
    if (active)
        cam[$cameraController] = cameraController;
    else {
        if (cam[$cameraController] === cameraController)
            cam[$cameraController] = null;
    }
}


const autofit = "needle:autofit";

/** 
 * Used by e.g. getBoundingBox via ContactShadows or OrbitControls when fitting the camera or shadow planes. Objects can be marked to be excluded from bounding box calculations via `setAutoFitEnabled(obj, <bool>)`
 * @see setAutoFitEnabled
 * @internal 
 */
export function useForAutoFit(obj: Object3D): boolean {
    // if autofit is not defined we assume it may be included
    if (obj[autofit] === undefined) return true;
    // otherwise if anything is set except false we assume it should be included
    return obj[autofit] !== false;
}

/**
 * Enable or disable autofitting for the given object. Objects that are 'disabled' will be excluded in getBoundingBox calculations.   
 * This is used by ContactShadows or OrbitControls when fitting the shadow plane or camera to the given objects or scene.
 * @see useForAutoFit
 */
export function setAutoFitEnabled(obj: Object3D, enabled: boolean): void {
    obj[autofit] = enabled;
}



export type FocusRectSettings = {
    /** Lower values will result in faster alignment with the rect (value ~= seconds to reach target) 
     * Minimum value is 0.
     */
    damping: number
}
export type FocusRect = DOMRect | Element | { x: number, y: number, width: number, height: number };

let rendererRect: DOMRect | undefined = undefined;
const overlapRect = { x: 0, y: 0, width: 0, height: 0 };

/** Used internally by the Needle Engine context via 'setFocusRect(<rect>)'  */
export function updateCameraFocusRect(focusRect: FocusRect, dt: number, camera: PerspectiveCamera, renderer: WebGLRenderer) {

    if (focusRect instanceof Element) {
        focusRect = focusRect.getBoundingClientRect();
    }
    rendererRect = renderer.domElement.getBoundingClientRect();

    const rect = overlapRect;
    rect.x = focusRect.x;
    rect.y = focusRect.y;
    rect.width = focusRect.width;
    rect.height = focusRect.height;

    rect.x -= rendererRect.x;
    rect.y -= rendererRect.y;

    const targetX = rect.width / -2 - (rect.x - (rendererRect.width / 2));
    const targetY = rect.height / -2 - (rect.y - (rendererRect.height / 2));

    const view = camera.view;

    let offsetX = view?.offsetX || 0;
    let offsetY = view?.offsetY || 0;
    offsetX = Mathf.lerp(offsetX, targetX, dt);
    offsetY = Mathf.lerp(offsetY, targetY, dt);

    camera.setViewOffset(rendererRect.width, rendererRect.height, offsetX, offsetY, rendererRect.width, rendererRect.height);
    camera.updateProjectionMatrix();
}