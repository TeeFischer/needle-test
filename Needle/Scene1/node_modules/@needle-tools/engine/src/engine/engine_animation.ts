import { AnimationAction, AnimationClip, AnimationMixer, Object3D, PropertyBinding } from "three";

import type { Context } from "./engine_context.js";
import { GLTF, IAnimationComponent, Model } from "./engine_types.js";
import { TypeStore } from "./engine_typestore.js";

/**
 * Registry for animation related data. Use {@link registerAnimationMixer} to register an animation mixer instance.  
 * Can be accessed from {@link Context.animations} and is used internally e.g. when exporting GLTF files.
 * @category Animation
 */
export class AnimationsRegistry {

    readonly context: Context
    readonly mixers: AnimationMixer[] = []

    constructor(context: Context) {
        this.context = context;
    }

    /** @hidden @internal */
    onDestroy() {
        this.mixers.forEach(mixer => mixer.stopAllAction());
        this.mixers.length = 0;
    }

    /**
     * Register an animation mixer instance.
     */
    registerAnimationMixer(mixer: AnimationMixer): void {
        if (!mixer) {
            console.warn("AnimationsRegistry.registerAnimationMixer called with null or undefined mixer")
            return;
        }
        if (this.mixers.includes(mixer)) return;
        this.mixers.push(mixer);
    }
    /**
     * Unregister an animation mixer instance.
     */
    unregisterAnimationMixer(mixer: AnimationMixer | null | undefined): void {
        if (!mixer) {
            console.warn("AnimationsRegistry.unregisterAnimationMixer called with null or undefined mixer")
            return;
        }
        const index = this.mixers.indexOf(mixer);
        if (index === -1) return;
        this.mixers.splice(index, 1);
    }

}


/**
 * Utility class for working with animations.
 */
export class AnimationUtils {

    /**
     * Tries to get the animation actions from an animation mixer.
     * @param mixer The animation mixer to get the actions from
     * @returns The actions or null if the mixer is invalid
     */
    static tryGetActionsFromMixer(mixer: AnimationMixer): Array<AnimationAction> | null {
        const actions = mixer["_actions"] as Array<AnimationAction>;
        if (!actions) return null;
        return actions;
    }

    static tryGetAnimationClipsFromObjectHierarchy(obj: Object3D, target?: Array<AnimationClip>): Array<AnimationClip> {
        if (!target) target = new Array<AnimationClip>();

        if (!obj) {
            return target;
        }
        else if (obj.animations) {
            target.push(...obj.animations);
        }
        if (obj.children) {
            for (const child of obj.children) {
                this.tryGetAnimationClipsFromObjectHierarchy(child, target);
            }
        }
        return target;
    }

    /**
     * Assigns animations from a GLTF file to the objects in the scene.  
     * This method will look for objects in the scene that have animations and assign them to the correct objects.  
     * @param file The GLTF file to assign the animations from
     */
    static autoplayAnimations(file: Object3D | Pick<Model, "animations" | "scene">): Array<IAnimationComponent> | null {
        if (!file || !file.animations) {
            console.debug("No animations found in file");
            return null;
        }

        const scene = "scene" in file ? file.scene : file as Object3D;
        const animationComponents = new Array<IAnimationComponent>();

        for (let i = 0; i < file.animations.length; i++) {
            const animation = file.animations[i];
            if (!animation.tracks || animation.tracks.length <= 0) {
                console.warn("Animation has no tracks");
                continue;
            }
            for (const t in animation.tracks) {
                const track = animation.tracks[t];
                const parsedPath = PropertyBinding.parseTrackName(track.name);
                let obj = PropertyBinding.findNode(scene, parsedPath.nodeName);
                if (!obj) {
                    const objectName = track["__objectName"] ?? track.name.substring(0, track.name.indexOf("."));
                    // let obj = gltf.scene.getObjectByName(objectName);
                    // this finds unnamed objects that still have tracks targeting them
                    obj = scene.getObjectByProperty('uuid', objectName);

                    if (!obj) {
                        // console.warn("could not find " + objectName, animation, gltf.scene);
                        continue;
                    }
                }

                let animationComponent = findAnimationComponentInParent(obj) || findAnimationComponentInParent(scene);
                if (!animationComponent) {
                    const anim = TypeStore.get("Animation");
                    animationComponent = scene.addComponent(anim);
                    if (!animationComponent) {
                        console.error("Failed creating Animation component: No 'Animation' component found in TypeStore");
                        break;
                    }
                }
                animationComponents.push(animationComponent);
                if (animationComponent.addClip) {
                    animationComponent.addClip(animation);
                }
            }
        }
        return animationComponents;

        function findAnimationComponentInParent(obj): IAnimationComponent | null {
            if (!obj) return null;
            const components = obj.userData?.components;
            if (components && components.length > 0) {
                for (let i = 0; i < components.length; i++) {
                    const component = components[i] as IAnimationComponent;
                    if (component.isAnimationComponent === true) {
                        return component;
                    }
                }
            }
            return findAnimationComponentInParent(obj.parent);
        }
    }
}