import { serializable } from "../../engine/engine_serialization_decorator.js";
import { getTempVector } from "../../engine/engine_three_utils.js";
import { Behaviour } from "../Component.js";

/**
 * The CursorFollow component makes the object follow the cursor (or touch) position on screen.
 */
export class CursorFollow extends Behaviour {

    /**
     * Damping for the movement, set to 0 for instant movement
     * @default 0
     */
    @serializable()
    damping: number = 0;

    /**
     * If true, the initial distance to the camera is maintained when following the cursor.
     * @default true
     */
    @serializable()
    keepDistance: boolean = true;

    awake() {
        this._distance = -1;
    }

    private _distance: number = -1;

    updateDistance() {
        if (this.keepDistance && this._distance !== -1) {
            return;
        }
        this._distance = this.gameObject.worldPosition.distanceTo(this.context.mainCamera.worldPosition);
    }

    /** @internal */
    update() {
        // continuously update distance in case camera or object moves
        this.updateDistance();

        // follow cursor in screenspace but maintain initial distance from camera
        const cursor = this.context.input.mousePositionRC;
        const camera = this.context.mainCamera;
        const cameraPosition = camera.worldPosition;

        // create ray from camera through cursor position
        const rayDirection = getTempVector(cursor.x, cursor.y, 1).unproject(camera);
        rayDirection.sub(cameraPosition).normalize();

        // position object at initial distance along the ray
        const newPosition = rayDirection.multiplyScalar(this._distance).add(cameraPosition);
        if (this.damping > 0) {
            const pos = this.gameObject.worldPosition;
            pos.lerp(newPosition, this.context.time.deltaTime / this.damping);
            this.gameObject.worldPosition = pos;
        }
        else {
            this.gameObject.worldPosition = newPosition;
        }

    }

}