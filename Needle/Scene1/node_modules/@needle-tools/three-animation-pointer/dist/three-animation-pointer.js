import { SkinnedMesh as S, InterpolateDiscrete as M, InterpolateLinear as F, AnimationClip as W, PropertyBinding as C, QuaternionKeyframeTrack as w, ColorKeyframeTrack as D, VectorKeyframeTrack as E, NumberKeyframeTrack as O } from "three";
const f = {
  node: "node",
  material: "material",
  camera: "camera",
  light: "light"
}, R = "KHR_animation_pointer", U = {
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  CUBICSPLINE: void 0,
  LINEAR: F,
  STEP: M
};
class j {
  /** @type {import("three/examples/jsm/loaders/GLTFLoader").GLTFParser} */
  constructor(a) {
    this.name = R, this.parser = a, this.animationPointerResolver = null;
  }
  /** 
   * @param {import("..").AnimationPointerResolver | null} animationPointerResolver
   */
  setAnimationPointerResolver(a) {
    return this.animationPointerResolver = a, this;
  }
  /* DUPLICATE of functionality in GLTFLoader */
  loadAnimationTargetFromChannel(a) {
    const t = a.target, r = t.node !== void 0 ? t.node : t.id;
    return this.parser.getDependency("node", r);
  }
  loadAnimationTargetFromChannelWithAnimationPointer(a) {
    var c;
    B();
    const t = a.target, r = t.extensions && t.extensions[R] && t.path && t.path === "pointer";
    if (!r) return null;
    let e, n = f.node, s;
    if (r) {
      const m = t.extensions[R];
      let o = m.pointer;
      if (!o) {
        console.warn("Invalid path", m, t);
        return;
      }
      if (o.startsWith("/materials/") ? n = f.material : o.startsWith("/extensions/KHR_lights_punctual/lights/") ? n = f.light : o.startsWith("/cameras/") && (n = f.camera), s = this._tryResolveTargetId(o, n), s === null || isNaN(s)) {
        console.warn("Failed resolving animation node id: " + s, o);
        return;
      }
      switch (n) {
        case f.material:
          const x = ("/materials/" + s.toString() + "/").length, h = o.substring(0, x);
          switch (e = o.substring(x), e) {
            case "pbrMetallicRoughness/baseColorFactor":
              e = "color";
              break;
            case "pbrMetallicRoughness/roughnessFactor":
              e = "roughness";
              break;
            case "pbrMetallicRoughness/metallicFactor":
              e = "metalness";
              break;
            case "emissiveFactor":
              e = "emissive";
              break;
            case "alphaCutoff":
              e = "alphaTest";
              break;
            case "occlusionTexture/strength":
              e = "aoMapIntensity";
              break;
            case "normalTexture/scale":
              e = "normalScale";
              break;
            case "pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale":
              e = "map/repeat";
              break;
            case "pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset":
              e = "map/offset";
              break;
            case "emissiveTexture/extensions/KHR_texture_transform/scale":
              e = "emissiveMap/repeat";
              break;
            case "emissiveTexture/extensions/KHR_texture_transform/offset":
              e = "emissiveMap/offset";
              break;
            case "extensions/KHR_materials_emissive_strength/emissiveStrength":
              e = "emissiveIntensity";
              break;
            case "extensions/KHR_materials_transmission/transmissionFactor":
              e = "transmission";
              break;
            case "extensions/KHR_materials_ior/ior":
              e = "ior";
              break;
            case "extensions/KHR_materials_volume/thicknessFactor":
              e = "thickness";
              break;
            case "extensions/KHR_materials_volume/attenuationColor":
              e = "attenuationColor";
              break;
            case "extensions/KHR_materials_volume/attenuationDistance":
              e = "attenuationDistance";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceFactor":
              e = "iridescence";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceIor":
              e = "iridescenceIOR";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceThicknessMinimum":
              e = "iridescenceThicknessRange[0]";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceThicknessMaximum":
              e = "iridescenceThicknessRange[1]";
              break;
            case "extensions/KHR_materials_clearcoat/clearcoatFactor":
              e = "clearcoat";
              break;
            case "extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor":
              e = "clearcoatRoughness";
              break;
            case "extensions/KHR_materials_sheen/sheenColorFactor":
              e = "sheenColor";
              break;
            case "extensions/KHR_materials_sheen/sheenRoughnessFactor":
              e = "sheenRoughness";
              break;
            case "extensions/KHR_materials_specular/specularFactor":
              e = "specularIntensity";
              break;
            case "extensions/KHR_materials_specular/specularColorFactor":
              e = "specularColor";
              break;
          }
          o = h + e;
          break;
        case f.node:
          const u = ("/nodes/" + s.toString() + "/").length, l = o.substring(0, u);
          switch (e = o.substring(u), e) {
            case "translation":
              e = "position";
              break;
            case "rotation":
              e = "quaternion";
              break;
            case "scale":
              e = "scale";
              break;
            case "weights":
              e = "morphTargetInfluences";
              break;
          }
          o = l + e;
          break;
        case f.light:
          const p = ("/extensions/KHR_lights_punctual/lights/" + s.toString() + "/").length;
          switch (e = o.substring(p), e) {
            case "color":
              break;
            case "intensity":
              break;
            case "spot/innerConeAngle":
              e = "penumbra";
              break;
            case "spot/outerConeAngle":
              e = "angle";
              break;
            case "range":
              e = "distance";
              break;
          }
          o = "/lights/" + s.toString() + "/" + e;
          break;
        case f.camera:
          const g = ("/cameras/" + s.toString() + "/").length, b = o.substring(0, g);
          switch (e = o.substring(g), e) {
            case "perspective/yfov":
              e = "fov";
              break;
            case "perspective/znear":
            case "orthographic/znear":
              e = "near";
              break;
            case "perspective/zfar":
            case "orthographic/zfar":
              e = "far";
              break;
            case "perspective/aspect":
              e = "aspect";
              break;
            case "orthographic/xmag":
              e = "zoom";
              break;
            case "orthographic/ymag":
              e = "zoom";
              break;
          }
          o = b + e;
          break;
      }
      (c = this.animationPointerResolver) != null && c.resolvePath && (o = this.animationPointerResolver.resolvePath(o)), t.extensions[R].pointer = o;
    }
    if (s == null || isNaN(s)) {
      console.warn("Failed resolving animation node id: " + s, t);
      return;
    }
    let i;
    return n === f.node ? i = this.parser.getDependency("node", s) : n === f.material ? i = this.parser.getDependency("material", s) : n === f.light ? i = this.parser.getDependency("light", s) : n === f.camera ? i = this.parser.getDependency("camera", s) : console.error("Unhandled type", n), i;
  }
  createAnimationTracksWithAnimationPointer(a, t, r, e, n) {
    if (!(n.extensions && n.extensions[R] && n.path && n.path === "pointer")) return null;
    let i = n.extensions[R].pointer;
    if (!i) return null;
    const c = [];
    i = i.replaceAll("/", ".");
    const m = i.split(".");
    var x = a.name !== void 0 && a.name !== null ? a.name : a.uuid;
    if (m[2] = x, m[3] === "morphTargetInfluences" && a.type === "Group") {
      for (const u of a.children)
        u instanceof S && u.morphTargetInfluences && (m[3] = u.name, m[4] = "morphTargetInfluences", h(this.parser));
      return c;
    }
    h(this.parser);
    function h(u) {
      i = m.join(".");
      let l;
      switch (r.itemSize) {
        case 1:
          l = O;
          break;
        case 2:
        case 3:
          l = E;
          break;
        case 4:
          i.endsWith(".quaternion") ? l = w : l = D;
          break;
      }
      if (!l) {
        console.warn("Unsupported output accessor format", r);
        return;
      }
      const p = e.interpolation !== void 0 ? U[e.interpolation] : F;
      let g = u._getArrayFromAccessor(r);
      i.endsWith(".fov") && (g = g.map((k) => k / Math.PI * 180));
      const b = new l(
        i,
        t.array,
        g,
        p
      );
      if (p === "CUBICSPLINE" && u._createCubicSplineTrackInterpolant(b), c.push(b), i && r.itemSize === 4 && i.startsWith(".materials.") && i.endsWith(".color")) {
        const k = new Float32Array(g.length / 4);
        for (let T = 0, _ = g.length / 4; T < _; T += 1)
          k[T] = g[T * 4 + 3];
        const d = new l(
          i.replace(".color", ".opacity"),
          t.array,
          k,
          p
        );
        p === "CUBICSPLINE" && u._createCubicSplineTrackInterpolant(b), c.push(d);
      }
    }
    return c;
  }
  _tryResolveTargetId(a, t) {
    let r = "";
    return t === "node" ? r = a.substring(7) : t === "material" ? r = a.substring(11) : t === "light" ? r = a.substring(39) : t === "camera" && (r = a.substring(9)), r = r.substring(0, r.indexOf("/")), Number.parseInt(r);
  }
  /* MOSTLY DUPLICATE of GLTFLoader.loadAnimation, but also tries to resolve KHR_animation_pointer. */
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(a) {
    const t = this, r = this.parser.json, e = this.parser, n = r.animations[a], s = n.name ? n.name : "animation_" + a, i = [], c = [], m = [], o = [], x = [];
    for (let h = 0, u = n.channels.length; h < u; h++) {
      const l = n.channels[h], p = n.samplers[l.sampler], g = l.target, b = n.parameters !== void 0 ? n.parameters[p.input] : p.input, k = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      let d = t.loadAnimationTargetFromChannelWithAnimationPointer(l);
      d || (d = t.loadAnimationTargetFromChannel(l)), i.push(d), c.push(e.getDependency("accessor", b)), m.push(e.getDependency("accessor", k)), o.push(p), x.push(g);
    }
    return Promise.all([
      Promise.all(i),
      Promise.all(c),
      Promise.all(m),
      Promise.all(o),
      Promise.all(x)
    ]).then(function(h) {
      const u = h[0], l = h[1], p = h[2], g = h[3], b = h[4], k = [];
      for (let d = 0, T = u.length; d < T; d++) {
        const _ = u[d], v = l[d], A = p[d], N = g[d], K = b[d];
        if (_ === void 0) continue;
        _.updateMatrix && (_.updateMatrix(), _.matrixAutoUpdate = !0);
        let y = t.createAnimationTracksWithAnimationPointer(_, v, A, N, K);
        if (y || (y = e._createAnimationTracks(_, v, A, N, K)), y)
          for (let P = 0; P < y.length; P++)
            k.push(y[P]);
      }
      return new W(s, void 0, k);
    });
  }
}
let H = !1, z = null;
function B() {
  if (H) return;
  H = !0;
  const I = z || (z = C.findNode);
  C.findNode = function(a, t) {
    if (!t) return I(a, t);
    if (t.startsWith(".materials.")) {
      const r = t.substring(11).substring(t.indexOf(".")), e = r.indexOf("."), n = e < 0 ? r : r.substring(0, e);
      let s = null;
      return a.traverse((i) => {
        s !== null || i.type !== "Mesh" && i.type !== "SkinnedMesh" || i.material && (i.material.uuid === n || i.material.name === n) && (s = i.material, s !== null && (r.endsWith(".map") ? s = s.map : r.endsWith(".emissiveMap") && (s = s.emissiveMap)));
      }), s;
    } else if (t.startsWith(".nodes.") || t.startsWith(".lights.") || t.startsWith(".cameras.")) {
      const r = t.split(".");
      let e;
      for (let n = 1; n < r.length; n++) {
        const s = r[n];
        if (s.length == 36)
          e = a.getObjectByProperty("uuid", s);
        else if (e && e[s]) {
          const c = Number.parseInt(s);
          let m = s;
          c >= 0 && (m = c), e = e[m];
        } else {
          const c = a.getObjectByName(s);
          c && (e = c);
        }
      }
      if (!e) {
        const n = I(a, r[2]);
        return n || console.warn(R + ": Property binding not found", t, a, a.name, r), n;
      }
      return e;
    }
    return I(a, t);
  };
}
export {
  j as GLTFAnimationPointerExtension,
  j as default
};
