{
  "version": 3,
  "sources": ["../../@needle-tools/engine/node_modules/three/examples/jsm/loaders/EXRLoader.js"],
  "sourcesContent": ["import {\r\n\tDataTextureLoader,\r\n\tDataUtils,\r\n\tFloatType,\r\n\tHalfFloatType,\r\n\tNoColorSpace,\r\n\tLinearFilter,\r\n\tLinearSRGBColorSpace,\r\n\tRedFormat,\r\n\tRGBAFormat\r\n} from 'three';\r\nimport * as fflate from '../libs/fflate.module.js';\r\n\r\n/**\r\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\r\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\r\n *\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation, so I have preserved their copyright notices.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\nclass EXRLoader extends DataTextureLoader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\tthis.type = HalfFloatType;\r\n\r\n\t}\r\n\r\n\tparse( buffer ) {\r\n\r\n\t\tconst USHORT_RANGE = ( 1 << 16 );\r\n\t\tconst BITMAP_SIZE = ( USHORT_RANGE >> 3 );\r\n\r\n\t\tconst HUF_ENCBITS = 16; // literal (value) bit length\r\n\t\tconst HUF_DECBITS = 14; // decoding bit size (>= 8)\r\n\r\n\t\tconst HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size\r\n\t\tconst HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\r\n\t\tconst HUF_DECMASK = HUF_DECSIZE - 1;\r\n\r\n\t\tconst NBITS = 16;\r\n\t\tconst A_OFFSET = 1 << ( NBITS - 1 );\r\n\t\tconst MOD_MASK = ( 1 << NBITS ) - 1;\r\n\r\n\t\tconst SHORT_ZEROCODE_RUN = 59;\r\n\t\tconst LONG_ZEROCODE_RUN = 63;\r\n\t\tconst SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\r\n\r\n\t\tconst ULONG_SIZE = 8;\r\n\t\tconst FLOAT32_SIZE = 4;\r\n\t\tconst INT32_SIZE = 4;\r\n\t\tconst INT16_SIZE = 2;\r\n\t\tconst INT8_SIZE = 1;\r\n\r\n\t\tconst STATIC_HUFFMAN = 0;\r\n\t\tconst DEFLATE = 1;\r\n\r\n\t\tconst UNKNOWN = 0;\r\n\t\tconst LOSSY_DCT = 1;\r\n\t\tconst RLE = 2;\r\n\r\n\t\tconst logBase = Math.pow( 2.7182818, 2.2 );\r\n\r\n\t\tfunction reverseLutFromBitmap( bitmap, lut ) {\r\n\r\n\t\t\tlet k = 0;\r\n\r\n\t\t\tfor ( let i = 0; i < USHORT_RANGE; ++ i ) {\r\n\r\n\t\t\t\tif ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {\r\n\r\n\t\t\t\t\tlut[ k ++ ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst n = k - 1;\r\n\r\n\t\t\twhile ( k < USHORT_RANGE ) lut[ k ++ ] = 0;\r\n\r\n\t\t\treturn n;\r\n\r\n\t\t}\r\n\r\n\t\tfunction hufClearDecTable( hdec ) {\r\n\r\n\t\t\tfor ( let i = 0; i < HUF_DECSIZE; i ++ ) {\r\n\r\n\t\t\t\thdec[ i ] = {};\r\n\t\t\t\thdec[ i ].len = 0;\r\n\t\t\t\thdec[ i ].lit = 0;\r\n\t\t\t\thdec[ i ].p = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst getBitsReturn = { l: 0, c: 0, lc: 0 };\r\n\r\n\t\tfunction getBits( nBits, c, lc, uInt8Array, inOffset ) {\r\n\r\n\t\t\twhile ( lc < nBits ) {\r\n\r\n\t\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\r\n\t\t\t\tlc += 8;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlc -= nBits;\r\n\r\n\t\t\tgetBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );\r\n\t\t\tgetBitsReturn.c = c;\r\n\t\t\tgetBitsReturn.lc = lc;\r\n\r\n\t\t}\r\n\r\n\t\tconst hufTableBuffer = new Array( 59 );\r\n\r\n\t\tfunction hufCanonicalCodeTable( hcode ) {\r\n\r\n\t\t\tfor ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;\r\n\t\t\tfor ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;\r\n\r\n\t\t\tlet c = 0;\r\n\r\n\t\t\tfor ( let i = 58; i > 0; -- i ) {\r\n\r\n\t\t\t\tconst nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );\r\n\t\t\t\thufTableBuffer[ i ] = c;\r\n\t\t\t\tc = nc;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0; i < HUF_ENCSIZE; ++ i ) {\r\n\r\n\t\t\t\tconst l = hcode[ i ];\r\n\t\t\t\tif ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {\r\n\r\n\t\t\tconst p = inOffset;\r\n\t\t\tlet c = 0;\r\n\t\t\tlet lc = 0;\r\n\r\n\t\t\tfor ( ; im <= iM; im ++ ) {\r\n\r\n\t\t\t\tif ( p.value - inOffset.value > ni ) return false;\r\n\r\n\t\t\t\tgetBits( 6, c, lc, uInt8Array, p );\r\n\r\n\t\t\t\tconst l = getBitsReturn.l;\r\n\t\t\t\tc = getBitsReturn.c;\r\n\t\t\t\tlc = getBitsReturn.lc;\r\n\r\n\t\t\t\thcode[ im ] = l;\r\n\r\n\t\t\t\tif ( l == LONG_ZEROCODE_RUN ) {\r\n\r\n\t\t\t\t\tif ( p.value - inOffset.value > ni ) {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgetBits( 8, c, lc, uInt8Array, p );\r\n\r\n\t\t\t\t\tlet zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\r\n\t\t\t\t\tc = getBitsReturn.c;\r\n\t\t\t\t\tlc = getBitsReturn.lc;\r\n\r\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\r\n\r\n\t\t\t\t\tim --;\r\n\r\n\t\t\t\t} else if ( l >= SHORT_ZEROCODE_RUN ) {\r\n\r\n\t\t\t\t\tlet zerun = l - SHORT_ZEROCODE_RUN + 2;\r\n\r\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\r\n\r\n\t\t\t\t\tim --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\thufCanonicalCodeTable( hcode );\r\n\r\n\t\t}\r\n\r\n\t\tfunction hufLength( code ) {\r\n\r\n\t\t\treturn code & 63;\r\n\r\n\t\t}\r\n\r\n\t\tfunction hufCode( code ) {\r\n\r\n\t\t\treturn code >> 6;\r\n\r\n\t\t}\r\n\r\n\t\tfunction hufBuildDecTable( hcode, im, iM, hdecod ) {\r\n\r\n\t\t\tfor ( ; im <= iM; im ++ ) {\r\n\r\n\t\t\t\tconst c = hufCode( hcode[ im ] );\r\n\t\t\t\tconst l = hufLength( hcode[ im ] );\r\n\r\n\t\t\t\tif ( c >> l ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'Invalid table entry' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( l > HUF_DECBITS ) {\r\n\r\n\t\t\t\t\tconst pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];\r\n\r\n\t\t\t\t\tif ( pl.len ) {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'Invalid table entry' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpl.lit ++;\r\n\r\n\t\t\t\t\tif ( pl.p ) {\r\n\r\n\t\t\t\t\t\tconst p = pl.p;\r\n\t\t\t\t\t\tpl.p = new Array( pl.lit );\r\n\r\n\t\t\t\t\t\tfor ( let i = 0; i < pl.lit - 1; ++ i ) {\r\n\r\n\t\t\t\t\t\t\tpl.p[ i ] = p[ i ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpl.p = new Array( 1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpl.p[ pl.lit - 1 ] = im;\r\n\r\n\t\t\t\t} else if ( l ) {\r\n\r\n\t\t\t\t\tlet plOffset = 0;\r\n\r\n\t\t\t\t\tfor ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {\r\n\r\n\t\t\t\t\t\tconst pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];\r\n\r\n\t\t\t\t\t\tif ( pl.len || pl.p ) {\r\n\r\n\t\t\t\t\t\t\tthrow new Error( 'Invalid table entry' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpl.len = l;\r\n\t\t\t\t\t\tpl.lit = im;\r\n\r\n\t\t\t\t\t\tplOffset ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tconst getCharReturn = { c: 0, lc: 0 };\r\n\r\n\t\tfunction getChar( c, lc, uInt8Array, inOffset ) {\r\n\r\n\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\r\n\t\t\tlc += 8;\r\n\r\n\t\t\tgetCharReturn.c = c;\r\n\t\t\tgetCharReturn.lc = lc;\r\n\r\n\t\t}\r\n\r\n\t\tconst getCodeReturn = { c: 0, lc: 0 };\r\n\r\n\t\tfunction getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {\r\n\r\n\t\t\tif ( po == rlc ) {\r\n\r\n\t\t\t\tif ( lc < 8 ) {\r\n\r\n\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\r\n\t\t\t\t\tc = getCharReturn.c;\r\n\t\t\t\t\tlc = getCharReturn.lc;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlc -= 8;\r\n\r\n\t\t\t\tlet cs = ( c >> lc );\r\n\t\t\t\tcs = new Uint8Array( [ cs ] )[ 0 ];\r\n\r\n\t\t\t\tif ( outBufferOffset.value + cs > outBufferEndOffset ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst s = outBuffer[ outBufferOffset.value - 1 ];\r\n\r\n\t\t\t\twhile ( cs -- > 0 ) {\r\n\r\n\t\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = s;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( outBufferOffset.value < outBufferEndOffset ) {\r\n\r\n\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = po;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgetCodeReturn.c = c;\r\n\t\t\tgetCodeReturn.lc = lc;\r\n\r\n\t\t}\r\n\r\n\t\tfunction UInt16( value ) {\r\n\r\n\t\t\treturn ( value & 0xFFFF );\r\n\r\n\t\t}\r\n\r\n\t\tfunction Int16( value ) {\r\n\r\n\t\t\tconst ref = UInt16( value );\r\n\t\t\treturn ( ref > 0x7FFF ) ? ref - 0x10000 : ref;\r\n\r\n\t\t}\r\n\r\n\t\tconst wdec14Return = { a: 0, b: 0 };\r\n\r\n\t\tfunction wdec14( l, h ) {\r\n\r\n\t\t\tconst ls = Int16( l );\r\n\t\t\tconst hs = Int16( h );\r\n\r\n\t\t\tconst hi = hs;\r\n\t\t\tconst ai = ls + ( hi & 1 ) + ( hi >> 1 );\r\n\r\n\t\t\tconst as = ai;\r\n\t\t\tconst bs = ai - hi;\r\n\r\n\t\t\twdec14Return.a = as;\r\n\t\t\twdec14Return.b = bs;\r\n\r\n\t\t}\r\n\r\n\t\tfunction wdec16( l, h ) {\r\n\r\n\t\t\tconst m = UInt16( l );\r\n\t\t\tconst d = UInt16( h );\r\n\r\n\t\t\tconst bb = ( m - ( d >> 1 ) ) & MOD_MASK;\r\n\t\t\tconst aa = ( d + bb - A_OFFSET ) & MOD_MASK;\r\n\r\n\t\t\twdec14Return.a = aa;\r\n\t\t\twdec14Return.b = bb;\r\n\r\n\t\t}\r\n\r\n\t\tfunction wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {\r\n\r\n\t\t\tconst w14 = mx < ( 1 << 14 );\r\n\t\t\tconst n = ( nx > ny ) ? ny : nx;\r\n\t\t\tlet p = 1;\r\n\t\t\tlet p2;\r\n\t\t\tlet py;\r\n\r\n\t\t\twhile ( p <= n ) p <<= 1;\r\n\r\n\t\t\tp >>= 1;\r\n\t\t\tp2 = p;\r\n\t\t\tp >>= 1;\r\n\r\n\t\t\twhile ( p >= 1 ) {\r\n\r\n\t\t\t\tpy = 0;\r\n\t\t\t\tconst ey = py + oy * ( ny - p2 );\r\n\t\t\t\tconst oy1 = oy * p;\r\n\t\t\t\tconst oy2 = oy * p2;\r\n\t\t\t\tconst ox1 = ox * p;\r\n\t\t\t\tconst ox2 = ox * p2;\r\n\t\t\t\tlet i00, i01, i10, i11;\r\n\r\n\t\t\t\tfor ( ; py <= ey; py += oy2 ) {\r\n\r\n\t\t\t\t\tlet px = py;\r\n\t\t\t\t\tconst ex = py + ox * ( nx - p2 );\r\n\r\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\r\n\r\n\t\t\t\t\t\tconst p01 = px + ox1;\r\n\t\t\t\t\t\tconst p10 = px + oy1;\r\n\t\t\t\t\t\tconst p11 = p10 + ox1;\r\n\r\n\t\t\t\t\t\tif ( w14 ) {\r\n\r\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\r\n\r\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\r\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\r\n\r\n\t\t\t\t\t\t\twdec14( buffer[ p01 + j ], buffer[ p11 + j ] );\r\n\r\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\r\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\r\n\r\n\t\t\t\t\t\t\twdec14( i00, i01 );\r\n\r\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\r\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t\t\t\twdec14( i10, i11 );\r\n\r\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\r\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p10 + j ] );\r\n\r\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\r\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\r\n\r\n\t\t\t\t\t\t\twdec16( buffer[ p01 + j ], buffer[ p11 + j ] );\r\n\r\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\r\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\r\n\r\n\t\t\t\t\t\t\twdec16( i00, i01 );\r\n\r\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\r\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t\t\t\twdec16( i10, i11 );\r\n\r\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\r\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\r\n\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( nx & p ) {\r\n\r\n\t\t\t\t\t\tconst p10 = px + oy1;\r\n\r\n\t\t\t\t\t\tif ( w14 )\r\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p10 + j ] );\r\n\r\n\t\t\t\t\t\ti00 = wdec14Return.a;\r\n\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ny & p ) {\r\n\r\n\t\t\t\t\tlet px = py;\r\n\t\t\t\t\tconst ex = py + ox * ( nx - p2 );\r\n\r\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\r\n\r\n\t\t\t\t\t\tconst p01 = px + ox1;\r\n\r\n\t\t\t\t\t\tif ( w14 )\r\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p01 + j ] );\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p01 + j ] );\r\n\r\n\t\t\t\t\t\ti00 = wdec14Return.a;\r\n\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tp2 = p;\r\n\t\t\t\tp >>= 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn py;\r\n\r\n\t\t}\r\n\r\n\t\tfunction hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {\r\n\r\n\t\t\tlet c = 0;\r\n\t\t\tlet lc = 0;\r\n\t\t\tconst outBufferEndOffset = no;\r\n\t\t\tconst inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );\r\n\r\n\t\t\twhile ( inOffset.value < inOffsetEnd ) {\r\n\r\n\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\r\n\r\n\t\t\t\tc = getCharReturn.c;\r\n\t\t\t\tlc = getCharReturn.lc;\r\n\r\n\t\t\t\twhile ( lc >= HUF_DECBITS ) {\r\n\r\n\t\t\t\t\tconst index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;\r\n\t\t\t\t\tconst pl = decodingTable[ index ];\r\n\r\n\t\t\t\t\tif ( pl.len ) {\r\n\r\n\t\t\t\t\t\tlc -= pl.len;\r\n\r\n\t\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\r\n\r\n\t\t\t\t\t\tc = getCodeReturn.c;\r\n\t\t\t\t\t\tlc = getCodeReturn.lc;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( ! pl.p ) {\r\n\r\n\t\t\t\t\t\t\tthrow new Error( 'hufDecode issues' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet j;\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < pl.lit; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst l = hufLength( encodingTable[ pl.p[ j ] ] );\r\n\r\n\t\t\t\t\t\t\twhile ( lc < l && inOffset.value < inOffsetEnd ) {\r\n\r\n\t\t\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\r\n\r\n\t\t\t\t\t\t\t\tc = getCharReturn.c;\r\n\t\t\t\t\t\t\t\tlc = getCharReturn.lc;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( lc >= l ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {\r\n\r\n\t\t\t\t\t\t\t\t\tlc -= l;\r\n\r\n\t\t\t\t\t\t\t\t\tgetCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\r\n\r\n\t\t\t\t\t\t\t\t\tc = getCodeReturn.c;\r\n\t\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\r\n\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( j == pl.lit ) {\r\n\r\n\t\t\t\t\t\t\tthrow new Error( 'hufDecode issues' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst i = ( 8 - ni ) & 7;\r\n\r\n\t\t\tc >>= i;\r\n\t\t\tlc -= i;\r\n\r\n\t\t\twhile ( lc > 0 ) {\r\n\r\n\t\t\t\tconst pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];\r\n\r\n\t\t\t\tif ( pl.len ) {\r\n\r\n\t\t\t\t\tlc -= pl.len;\r\n\r\n\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\r\n\r\n\t\t\t\t\tc = getCodeReturn.c;\r\n\t\t\t\t\tlc = getCodeReturn.lc;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( 'hufDecode issues' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tfunction hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {\r\n\r\n\t\t\tconst outOffset = { value: 0 };\r\n\t\t\tconst initialInOffset = inOffset.value;\r\n\r\n\t\t\tconst im = parseUint32( inDataView, inOffset );\r\n\t\t\tconst iM = parseUint32( inDataView, inOffset );\r\n\r\n\t\t\tinOffset.value += 4;\r\n\r\n\t\t\tconst nBits = parseUint32( inDataView, inOffset );\r\n\r\n\t\t\tinOffset.value += 4;\r\n\r\n\t\t\tif ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {\r\n\r\n\t\t\t\tthrow new Error( 'Something wrong with HUF_ENCSIZE' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst freq = new Array( HUF_ENCSIZE );\r\n\t\t\tconst hdec = new Array( HUF_DECSIZE );\r\n\r\n\t\t\thufClearDecTable( hdec );\r\n\r\n\t\t\tconst ni = nCompressed - ( inOffset.value - initialInOffset );\r\n\r\n\t\t\thufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );\r\n\r\n\t\t\tif ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'Something wrong with hufUncompress' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\thufBuildDecTable( freq, im, iM, hdec );\r\n\r\n\t\t\thufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );\r\n\r\n\t\t}\r\n\r\n\t\tfunction applyLut( lut, data, nData ) {\r\n\r\n\t\t\tfor ( let i = 0; i < nData; ++ i ) {\r\n\r\n\t\t\t\tdata[ i ] = lut[ data[ i ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction predictor( source ) {\r\n\r\n\t\t\tfor ( let t = 1; t < source.length; t ++ ) {\r\n\r\n\t\t\t\tconst d = source[ t - 1 ] + source[ t ] - 128;\r\n\t\t\t\tsource[ t ] = d;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction interleaveScalar( source, out ) {\r\n\r\n\t\t\tlet t1 = 0;\r\n\t\t\tlet t2 = Math.floor( ( source.length + 1 ) / 2 );\r\n\t\t\tlet s = 0;\r\n\t\t\tconst stop = source.length - 1;\r\n\r\n\t\t\twhile ( true ) {\r\n\r\n\t\t\t\tif ( s > stop ) break;\r\n\t\t\t\tout[ s ++ ] = source[ t1 ++ ];\r\n\r\n\t\t\t\tif ( s > stop ) break;\r\n\t\t\t\tout[ s ++ ] = source[ t2 ++ ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction decodeRunLength( source ) {\r\n\r\n\t\t\tlet size = source.byteLength;\r\n\t\t\tconst out = new Array();\r\n\t\t\tlet p = 0;\r\n\r\n\t\t\tconst reader = new DataView( source );\r\n\r\n\t\t\twhile ( size > 0 ) {\r\n\r\n\t\t\t\tconst l = reader.getInt8( p ++ );\r\n\r\n\t\t\t\tif ( l < 0 ) {\r\n\r\n\t\t\t\t\tconst count = - l;\r\n\t\t\t\t\tsize -= count + 1;\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\t\t\tout.push( reader.getUint8( p ++ ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconst count = l;\r\n\t\t\t\t\tsize -= 2;\r\n\r\n\t\t\t\t\tconst value = reader.getUint8( p ++ );\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < count + 1; i ++ ) {\r\n\r\n\t\t\t\t\t\tout.push( value );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn out;\r\n\r\n\t\t}\r\n\r\n\t\tfunction lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {\r\n\r\n\t\t\tlet dataView = new DataView( outBuffer.buffer );\r\n\r\n\t\t\tconst width = channelData[ cscSet.idx[ 0 ] ].width;\r\n\t\t\tconst height = channelData[ cscSet.idx[ 0 ] ].height;\r\n\r\n\t\t\tconst numComp = 3;\r\n\r\n\t\t\tconst numFullBlocksX = Math.floor( width / 8.0 );\r\n\t\t\tconst numBlocksX = Math.ceil( width / 8.0 );\r\n\t\t\tconst numBlocksY = Math.ceil( height / 8.0 );\r\n\t\t\tconst leftoverX = width - ( numBlocksX - 1 ) * 8;\r\n\t\t\tconst leftoverY = height - ( numBlocksY - 1 ) * 8;\r\n\r\n\t\t\tconst currAcComp = { value: 0 };\r\n\t\t\tconst currDcComp = new Array( numComp );\r\n\t\t\tconst dctData = new Array( numComp );\r\n\t\t\tconst halfZigBlock = new Array( numComp );\r\n\t\t\tconst rowBlock = new Array( numComp );\r\n\t\t\tconst rowOffsets = new Array( numComp );\r\n\r\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\r\n\r\n\t\t\t\trowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];\r\n\t\t\t\tcurrDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;\r\n\t\t\t\tdctData[ comp ] = new Float32Array( 64 );\r\n\t\t\t\thalfZigBlock[ comp ] = new Uint16Array( 64 );\r\n\t\t\t\trowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {\r\n\r\n\t\t\t\tlet maxY = 8;\r\n\r\n\t\t\t\tif ( blocky == numBlocksY - 1 )\r\n\t\t\t\t\tmaxY = leftoverY;\r\n\r\n\t\t\t\tlet maxX = 8;\r\n\r\n\t\t\t\tfor ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {\r\n\r\n\t\t\t\t\tif ( blockx == numBlocksX - 1 )\r\n\t\t\t\t\t\tmaxX = leftoverX;\r\n\r\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\r\n\r\n\t\t\t\t\t\thalfZigBlock[ comp ].fill( 0 );\r\n\r\n\t\t\t\t\t\t// set block DC component\r\n\t\t\t\t\t\thalfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];\r\n\t\t\t\t\t\t// set block AC components\r\n\t\t\t\t\t\tunRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );\r\n\r\n\t\t\t\t\t\t// UnZigZag block to float\r\n\t\t\t\t\t\tunZigZag( halfZigBlock[ comp ], dctData[ comp ] );\r\n\t\t\t\t\t\t// decode float dct\r\n\t\t\t\t\t\tdctInverse( dctData[ comp ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( numComp == 3 ) {\r\n\r\n\t\t\t\t\t\tcsc709Inverse( dctData );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\r\n\r\n\t\t\t\t\t\tconvertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // blockx\r\n\r\n\t\t\t\tlet offset = 0;\r\n\r\n\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\r\n\r\n\t\t\t\t\tconst type = channelData[ cscSet.idx[ comp ] ].type;\r\n\r\n\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\r\n\r\n\t\t\t\t\t\toffset = rowOffsets[ comp ][ y ];\r\n\r\n\t\t\t\t\t\tfor ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {\r\n\r\n\t\t\t\t\t\t\tconst src = blockx * 64 + ( ( y & 0x7 ) * 8 );\r\n\r\n\t\t\t\t\t\t\tdataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );\r\n\t\t\t\t\t\t\tdataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );\r\n\t\t\t\t\t\t\tdataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );\r\n\t\t\t\t\t\t\tdataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );\r\n\r\n\t\t\t\t\t\t\tdataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );\r\n\t\t\t\t\t\t\tdataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );\r\n\t\t\t\t\t\t\tdataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );\r\n\t\t\t\t\t\t\tdataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );\r\n\r\n\t\t\t\t\t\t\toffset += 8 * INT16_SIZE * type;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle partial X blocks\r\n\t\t\t\t\tif ( numFullBlocksX != numBlocksX ) {\r\n\r\n\t\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\r\n\r\n\t\t\t\t\t\t\tconst offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;\r\n\t\t\t\t\t\t\tconst src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );\r\n\r\n\t\t\t\t\t\t\tfor ( let x = 0; x < maxX; ++ x ) {\r\n\r\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // comp\r\n\r\n\t\t\t} // blocky\r\n\r\n\t\t\tconst halfRow = new Uint16Array( width );\r\n\t\t\tdataView = new DataView( outBuffer.buffer );\r\n\r\n\t\t\t// convert channels back to float, if needed\r\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\r\n\r\n\t\t\t\tchannelData[ cscSet.idx[ comp ] ].decoded = true;\r\n\t\t\t\tconst type = channelData[ cscSet.idx[ comp ] ].type;\r\n\r\n\t\t\t\tif ( channelData[ comp ].type != 2 ) continue;\r\n\r\n\t\t\t\tfor ( let y = 0; y < height; ++ y ) {\r\n\r\n\t\t\t\t\tconst offset = rowOffsets[ comp ][ y ];\r\n\r\n\t\t\t\t\tfor ( let x = 0; x < width; ++ x ) {\r\n\r\n\t\t\t\t\t\thalfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( let x = 0; x < width; ++ x ) {\r\n\r\n\t\t\t\t\t\tdataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction unRleAC( currAcComp, acBuffer, halfZigBlock ) {\r\n\r\n\t\t\tlet acValue;\r\n\t\t\tlet dctComp = 1;\r\n\r\n\t\t\twhile ( dctComp < 64 ) {\r\n\r\n\t\t\t\tacValue = acBuffer[ currAcComp.value ];\r\n\r\n\t\t\t\tif ( acValue == 0xff00 ) {\r\n\r\n\t\t\t\t\tdctComp = 64;\r\n\r\n\t\t\t\t} else if ( acValue >> 8 == 0xff ) {\r\n\r\n\t\t\t\t\tdctComp += acValue & 0xff;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\thalfZigBlock[ dctComp ] = acValue;\r\n\t\t\t\t\tdctComp ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrAcComp.value ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction unZigZag( src, dst ) {\r\n\r\n\t\t\tdst[ 0 ] = decodeFloat16( src[ 0 ] );\r\n\t\t\tdst[ 1 ] = decodeFloat16( src[ 1 ] );\r\n\t\t\tdst[ 2 ] = decodeFloat16( src[ 5 ] );\r\n\t\t\tdst[ 3 ] = decodeFloat16( src[ 6 ] );\r\n\t\t\tdst[ 4 ] = decodeFloat16( src[ 14 ] );\r\n\t\t\tdst[ 5 ] = decodeFloat16( src[ 15 ] );\r\n\t\t\tdst[ 6 ] = decodeFloat16( src[ 27 ] );\r\n\t\t\tdst[ 7 ] = decodeFloat16( src[ 28 ] );\r\n\t\t\tdst[ 8 ] = decodeFloat16( src[ 2 ] );\r\n\t\t\tdst[ 9 ] = decodeFloat16( src[ 4 ] );\r\n\r\n\t\t\tdst[ 10 ] = decodeFloat16( src[ 7 ] );\r\n\t\t\tdst[ 11 ] = decodeFloat16( src[ 13 ] );\r\n\t\t\tdst[ 12 ] = decodeFloat16( src[ 16 ] );\r\n\t\t\tdst[ 13 ] = decodeFloat16( src[ 26 ] );\r\n\t\t\tdst[ 14 ] = decodeFloat16( src[ 29 ] );\r\n\t\t\tdst[ 15 ] = decodeFloat16( src[ 42 ] );\r\n\t\t\tdst[ 16 ] = decodeFloat16( src[ 3 ] );\r\n\t\t\tdst[ 17 ] = decodeFloat16( src[ 8 ] );\r\n\t\t\tdst[ 18 ] = decodeFloat16( src[ 12 ] );\r\n\t\t\tdst[ 19 ] = decodeFloat16( src[ 17 ] );\r\n\r\n\t\t\tdst[ 20 ] = decodeFloat16( src[ 25 ] );\r\n\t\t\tdst[ 21 ] = decodeFloat16( src[ 30 ] );\r\n\t\t\tdst[ 22 ] = decodeFloat16( src[ 41 ] );\r\n\t\t\tdst[ 23 ] = decodeFloat16( src[ 43 ] );\r\n\t\t\tdst[ 24 ] = decodeFloat16( src[ 9 ] );\r\n\t\t\tdst[ 25 ] = decodeFloat16( src[ 11 ] );\r\n\t\t\tdst[ 26 ] = decodeFloat16( src[ 18 ] );\r\n\t\t\tdst[ 27 ] = decodeFloat16( src[ 24 ] );\r\n\t\t\tdst[ 28 ] = decodeFloat16( src[ 31 ] );\r\n\t\t\tdst[ 29 ] = decodeFloat16( src[ 40 ] );\r\n\r\n\t\t\tdst[ 30 ] = decodeFloat16( src[ 44 ] );\r\n\t\t\tdst[ 31 ] = decodeFloat16( src[ 53 ] );\r\n\t\t\tdst[ 32 ] = decodeFloat16( src[ 10 ] );\r\n\t\t\tdst[ 33 ] = decodeFloat16( src[ 19 ] );\r\n\t\t\tdst[ 34 ] = decodeFloat16( src[ 23 ] );\r\n\t\t\tdst[ 35 ] = decodeFloat16( src[ 32 ] );\r\n\t\t\tdst[ 36 ] = decodeFloat16( src[ 39 ] );\r\n\t\t\tdst[ 37 ] = decodeFloat16( src[ 45 ] );\r\n\t\t\tdst[ 38 ] = decodeFloat16( src[ 52 ] );\r\n\t\t\tdst[ 39 ] = decodeFloat16( src[ 54 ] );\r\n\r\n\t\t\tdst[ 40 ] = decodeFloat16( src[ 20 ] );\r\n\t\t\tdst[ 41 ] = decodeFloat16( src[ 22 ] );\r\n\t\t\tdst[ 42 ] = decodeFloat16( src[ 33 ] );\r\n\t\t\tdst[ 43 ] = decodeFloat16( src[ 38 ] );\r\n\t\t\tdst[ 44 ] = decodeFloat16( src[ 46 ] );\r\n\t\t\tdst[ 45 ] = decodeFloat16( src[ 51 ] );\r\n\t\t\tdst[ 46 ] = decodeFloat16( src[ 55 ] );\r\n\t\t\tdst[ 47 ] = decodeFloat16( src[ 60 ] );\r\n\t\t\tdst[ 48 ] = decodeFloat16( src[ 21 ] );\r\n\t\t\tdst[ 49 ] = decodeFloat16( src[ 34 ] );\r\n\r\n\t\t\tdst[ 50 ] = decodeFloat16( src[ 37 ] );\r\n\t\t\tdst[ 51 ] = decodeFloat16( src[ 47 ] );\r\n\t\t\tdst[ 52 ] = decodeFloat16( src[ 50 ] );\r\n\t\t\tdst[ 53 ] = decodeFloat16( src[ 56 ] );\r\n\t\t\tdst[ 54 ] = decodeFloat16( src[ 59 ] );\r\n\t\t\tdst[ 55 ] = decodeFloat16( src[ 61 ] );\r\n\t\t\tdst[ 56 ] = decodeFloat16( src[ 35 ] );\r\n\t\t\tdst[ 57 ] = decodeFloat16( src[ 36 ] );\r\n\t\t\tdst[ 58 ] = decodeFloat16( src[ 48 ] );\r\n\t\t\tdst[ 59 ] = decodeFloat16( src[ 49 ] );\r\n\r\n\t\t\tdst[ 60 ] = decodeFloat16( src[ 57 ] );\r\n\t\t\tdst[ 61 ] = decodeFloat16( src[ 58 ] );\r\n\t\t\tdst[ 62 ] = decodeFloat16( src[ 62 ] );\r\n\t\t\tdst[ 63 ] = decodeFloat16( src[ 63 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction dctInverse( data ) {\r\n\r\n\t\t\tconst a = 0.5 * Math.cos( 3.14159 / 4.0 );\r\n\t\t\tconst b = 0.5 * Math.cos( 3.14159 / 16.0 );\r\n\t\t\tconst c = 0.5 * Math.cos( 3.14159 / 8.0 );\r\n\t\t\tconst d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );\r\n\t\t\tconst e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );\r\n\t\t\tconst f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );\r\n\t\t\tconst g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );\r\n\r\n\t\t\tconst alpha = new Array( 4 );\r\n\t\t\tconst beta = new Array( 4 );\r\n\t\t\tconst theta = new Array( 4 );\r\n\t\t\tconst gamma = new Array( 4 );\r\n\r\n\t\t\tfor ( let row = 0; row < 8; ++ row ) {\r\n\r\n\t\t\t\tconst rowPtr = row * 8;\r\n\r\n\t\t\t\talpha[ 0 ] = c * data[ rowPtr + 2 ];\r\n\t\t\t\talpha[ 1 ] = f * data[ rowPtr + 2 ];\r\n\t\t\t\talpha[ 2 ] = c * data[ rowPtr + 6 ];\r\n\t\t\t\talpha[ 3 ] = f * data[ rowPtr + 6 ];\r\n\r\n\t\t\t\tbeta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];\r\n\t\t\t\tbeta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];\r\n\t\t\t\tbeta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];\r\n\t\t\t\tbeta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];\r\n\r\n\t\t\t\ttheta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );\r\n\t\t\t\ttheta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );\r\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\r\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\r\n\r\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\r\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\r\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\r\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\r\n\r\n\t\t\t\tdata[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];\r\n\t\t\t\tdata[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];\r\n\t\t\t\tdata[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];\r\n\t\t\t\tdata[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];\r\n\r\n\t\t\t\tdata[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];\r\n\t\t\t\tdata[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];\r\n\t\t\t\tdata[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];\r\n\t\t\t\tdata[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let column = 0; column < 8; ++ column ) {\r\n\r\n\t\t\t\talpha[ 0 ] = c * data[ 16 + column ];\r\n\t\t\t\talpha[ 1 ] = f * data[ 16 + column ];\r\n\t\t\t\talpha[ 2 ] = c * data[ 48 + column ];\r\n\t\t\t\talpha[ 3 ] = f * data[ 48 + column ];\r\n\r\n\t\t\t\tbeta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];\r\n\t\t\t\tbeta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];\r\n\t\t\t\tbeta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];\r\n\t\t\t\tbeta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];\r\n\r\n\t\t\t\ttheta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );\r\n\t\t\t\ttheta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );\r\n\r\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\r\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\r\n\r\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\r\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\r\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\r\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\r\n\r\n\t\t\t\tdata[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];\r\n\t\t\t\tdata[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];\r\n\t\t\t\tdata[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];\r\n\t\t\t\tdata[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];\r\n\r\n\t\t\t\tdata[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];\r\n\t\t\t\tdata[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];\r\n\t\t\t\tdata[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];\r\n\t\t\t\tdata[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction csc709Inverse( data ) {\r\n\r\n\t\t\tfor ( let i = 0; i < 64; ++ i ) {\r\n\r\n\t\t\t\tconst y = data[ 0 ][ i ];\r\n\t\t\t\tconst cb = data[ 1 ][ i ];\r\n\t\t\t\tconst cr = data[ 2 ][ i ];\r\n\r\n\t\t\t\tdata[ 0 ][ i ] = y + 1.5747 * cr;\r\n\t\t\t\tdata[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;\r\n\t\t\t\tdata[ 2 ][ i ] = y + 1.8556 * cb;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction convertToHalf( src, dst, idx ) {\r\n\r\n\t\t\tfor ( let i = 0; i < 64; ++ i ) {\r\n\r\n\t\t\t\tdst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction toLinear( float ) {\r\n\r\n\t\t\tif ( float <= 1 ) {\r\n\r\n\t\t\t\treturn Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction uncompressRAW( info ) {\r\n\r\n\t\t\treturn new DataView( info.array.buffer, info.offset.value, info.size );\r\n\r\n\t\t}\r\n\r\n\t\tfunction uncompressRLE( info ) {\r\n\r\n\t\t\tconst compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );\r\n\r\n\t\t\tconst rawBuffer = new Uint8Array( decodeRunLength( compressed ) );\r\n\t\t\tconst tmpBuffer = new Uint8Array( rawBuffer.length );\r\n\r\n\t\t\tpredictor( rawBuffer ); // revert predictor\r\n\r\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\r\n\r\n\t\t\treturn new DataView( tmpBuffer.buffer );\r\n\r\n\t\t}\r\n\r\n\t\tfunction uncompressZIP( info ) {\r\n\r\n\t\t\tconst compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\r\n\r\n\t\t\tconst rawBuffer = fflate.unzlibSync( compressed );\r\n\t\t\tconst tmpBuffer = new Uint8Array( rawBuffer.length );\r\n\r\n\t\t\tpredictor( rawBuffer ); // revert predictor\r\n\r\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\r\n\r\n\t\t\treturn new DataView( tmpBuffer.buffer );\r\n\r\n\t\t}\r\n\r\n\t\tfunction uncompressPIZ( info ) {\r\n\r\n\t\t\tconst inDataView = info.viewer;\r\n\t\t\tconst inOffset = { value: info.offset.value };\r\n\r\n\t\t\tconst outBuffer = new Uint16Array( info.columns * info.lines * ( info.inputChannels.length * info.type ) );\r\n\t\t\tconst bitmap = new Uint8Array( BITMAP_SIZE );\r\n\r\n\t\t\t// Setup channel info\r\n\t\t\tlet outBufferEnd = 0;\r\n\t\t\tconst pizChannelData = new Array( info.inputChannels.length );\r\n\t\t\tfor ( let i = 0, il = info.inputChannels.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpizChannelData[ i ] = {};\r\n\t\t\t\tpizChannelData[ i ][ 'start' ] = outBufferEnd;\r\n\t\t\t\tpizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];\r\n\t\t\t\tpizChannelData[ i ][ 'nx' ] = info.columns;\r\n\t\t\t\tpizChannelData[ i ][ 'ny' ] = info.lines;\r\n\t\t\t\tpizChannelData[ i ][ 'size' ] = info.type;\r\n\r\n\t\t\t\toutBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Read range compression data\r\n\r\n\t\t\tconst minNonZero = parseUint16( inDataView, inOffset );\r\n\t\t\tconst maxNonZero = parseUint16( inDataView, inOffset );\r\n\r\n\t\t\tif ( maxNonZero >= BITMAP_SIZE ) {\r\n\r\n\t\t\t\tthrow new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( minNonZero <= maxNonZero ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {\r\n\r\n\t\t\t\t\tbitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Reverse LUT\r\n\t\t\tconst lut = new Uint16Array( USHORT_RANGE );\r\n\t\t\tconst maxValue = reverseLutFromBitmap( bitmap, lut );\r\n\r\n\t\t\tconst length = parseUint32( inDataView, inOffset );\r\n\r\n\t\t\t// Huffman decoding\r\n\t\t\thufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );\r\n\r\n\t\t\t// Wavelet decoding\r\n\t\t\tfor ( let i = 0; i < info.inputChannels.length; ++ i ) {\r\n\r\n\t\t\t\tconst cd = pizChannelData[ i ];\r\n\r\n\t\t\t\tfor ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {\r\n\r\n\t\t\t\t\twav2Decode(\r\n\t\t\t\t\t\toutBuffer,\r\n\t\t\t\t\t\tcd.start + j,\r\n\t\t\t\t\t\tcd.nx,\r\n\t\t\t\t\t\tcd.size,\r\n\t\t\t\t\t\tcd.ny,\r\n\t\t\t\t\t\tcd.nx * cd.size,\r\n\t\t\t\t\t\tmaxValue\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Expand the pixel data to their original range\r\n\t\t\tapplyLut( lut, outBuffer, outBufferEnd );\r\n\r\n\t\t\t// Rearrange the pixel data into the format expected by the caller.\r\n\t\t\tlet tmpOffset = 0;\r\n\t\t\tconst tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );\r\n\t\t\tfor ( let y = 0; y < info.lines; y ++ ) {\r\n\r\n\t\t\t\tfor ( let c = 0; c < info.inputChannels.length; c ++ ) {\r\n\r\n\t\t\t\t\tconst cd = pizChannelData[ c ];\r\n\r\n\t\t\t\t\tconst n = cd.nx * cd.size;\r\n\t\t\t\t\tconst cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );\r\n\r\n\t\t\t\t\ttmpBuffer.set( cp, tmpOffset );\r\n\t\t\t\t\ttmpOffset += n * INT16_SIZE;\r\n\t\t\t\t\tcd.end += n;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new DataView( tmpBuffer.buffer );\r\n\r\n\t\t}\r\n\r\n\t\tfunction uncompressPXR( info ) {\r\n\r\n\t\t\tconst compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\r\n\r\n\t\t\tconst rawBuffer = fflate.unzlibSync( compressed );\r\n\r\n\t\t\tconst byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;\r\n\t\t\tconst tmpBuffer = new ArrayBuffer( byteSize );\r\n\t\t\tconst viewer = new DataView( tmpBuffer );\r\n\r\n\t\t\tlet tmpBufferEnd = 0;\r\n\t\t\tlet writePtr = 0;\r\n\t\t\tconst ptr = new Array( 4 );\r\n\r\n\t\t\tfor ( let y = 0; y < info.lines; y ++ ) {\r\n\r\n\t\t\t\tfor ( let c = 0; c < info.inputChannels.length; c ++ ) {\r\n\r\n\t\t\t\t\tlet pixel = 0;\r\n\r\n\t\t\t\t\tconst type = info.inputChannels[ c ].pixelType;\r\n\t\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\t\tcase 1:\r\n\r\n\t\t\t\t\t\t\tptr[ 0 ] = tmpBufferEnd;\r\n\t\t\t\t\t\t\tptr[ 1 ] = ptr[ 0 ] + info.columns;\r\n\t\t\t\t\t\t\ttmpBufferEnd = ptr[ 1 ] + info.columns;\r\n\r\n\t\t\t\t\t\t\tfor ( let j = 0; j < info.columns; ++ j ) {\r\n\r\n\t\t\t\t\t\t\t\tconst diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];\r\n\r\n\t\t\t\t\t\t\t\tpixel += diff;\r\n\r\n\t\t\t\t\t\t\t\tviewer.setUint16( writePtr, pixel, true );\r\n\t\t\t\t\t\t\t\twritePtr += 2;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 2:\r\n\r\n\t\t\t\t\t\t\tptr[ 0 ] = tmpBufferEnd;\r\n\t\t\t\t\t\t\tptr[ 1 ] = ptr[ 0 ] + info.columns;\r\n\t\t\t\t\t\t\tptr[ 2 ] = ptr[ 1 ] + info.columns;\r\n\t\t\t\t\t\t\ttmpBufferEnd = ptr[ 2 ] + info.columns;\r\n\r\n\t\t\t\t\t\t\tfor ( let j = 0; j < info.columns; ++ j ) {\r\n\r\n\t\t\t\t\t\t\t\tconst diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );\r\n\r\n\t\t\t\t\t\t\t\tpixel += diff;\r\n\r\n\t\t\t\t\t\t\t\tviewer.setUint32( writePtr, pixel, true );\r\n\t\t\t\t\t\t\t\twritePtr += 4;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn viewer;\r\n\r\n\t\t}\r\n\r\n\t\tfunction uncompressDWA( info ) {\r\n\r\n\t\t\tconst inDataView = info.viewer;\r\n\t\t\tconst inOffset = { value: info.offset.value };\r\n\t\t\tconst outBuffer = new Uint8Array( info.columns * info.lines * ( info.inputChannels.length * info.type * INT16_SIZE ) );\r\n\r\n\t\t\t// Read compression header information\r\n\t\t\tconst dwaHeader = {\r\n\r\n\t\t\t\tversion: parseInt64( inDataView, inOffset ),\r\n\t\t\t\tunknownUncompressedSize: parseInt64( inDataView, inOffset ),\r\n\t\t\t\tunknownCompressedSize: parseInt64( inDataView, inOffset ),\r\n\t\t\t\tacCompressedSize: parseInt64( inDataView, inOffset ),\r\n\t\t\t\tdcCompressedSize: parseInt64( inDataView, inOffset ),\r\n\t\t\t\trleCompressedSize: parseInt64( inDataView, inOffset ),\r\n\t\t\t\trleUncompressedSize: parseInt64( inDataView, inOffset ),\r\n\t\t\t\trleRawSize: parseInt64( inDataView, inOffset ),\r\n\t\t\t\ttotalAcUncompressedCount: parseInt64( inDataView, inOffset ),\r\n\t\t\t\ttotalDcUncompressedCount: parseInt64( inDataView, inOffset ),\r\n\t\t\t\tacCompression: parseInt64( inDataView, inOffset )\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( dwaHeader.version < 2 )\r\n\t\t\t\tthrow new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );\r\n\r\n\t\t\t// Read channel ruleset information\r\n\t\t\tconst channelRules = new Array();\r\n\t\t\tlet ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;\r\n\r\n\t\t\twhile ( ruleSize > 0 ) {\r\n\r\n\t\t\t\tconst name = parseNullTerminatedString( inDataView.buffer, inOffset );\r\n\t\t\t\tconst value = parseUint8( inDataView, inOffset );\r\n\t\t\t\tconst compression = ( value >> 2 ) & 3;\r\n\t\t\t\tconst csc = ( value >> 4 ) - 1;\r\n\t\t\t\tconst index = new Int8Array( [ csc ] )[ 0 ];\r\n\t\t\t\tconst type = parseUint8( inDataView, inOffset );\r\n\r\n\t\t\t\tchannelRules.push( {\r\n\t\t\t\t\tname: name,\r\n\t\t\t\t\tindex: index,\r\n\t\t\t\t\ttype: type,\r\n\t\t\t\t\tcompression: compression,\r\n\t\t\t\t} );\r\n\r\n\t\t\t\truleSize -= name.length + 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Classify channels\r\n\t\t\tconst channels = EXRHeader.channels;\r\n\t\t\tconst channelData = new Array( info.inputChannels.length );\r\n\r\n\t\t\tfor ( let i = 0; i < info.inputChannels.length; ++ i ) {\r\n\r\n\t\t\t\tconst cd = channelData[ i ] = {};\r\n\t\t\t\tconst channel = channels[ i ];\r\n\r\n\t\t\t\tcd.name = channel.name;\r\n\t\t\t\tcd.compression = UNKNOWN;\r\n\t\t\t\tcd.decoded = false;\r\n\t\t\t\tcd.type = channel.pixelType;\r\n\t\t\t\tcd.pLinear = channel.pLinear;\r\n\t\t\t\tcd.width = info.columns;\r\n\t\t\t\tcd.height = info.lines;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst cscSet = {\r\n\t\t\t\tidx: new Array( 3 )\r\n\t\t\t};\r\n\r\n\t\t\tfor ( let offset = 0; offset < info.inputChannels.length; ++ offset ) {\r\n\r\n\t\t\t\tconst cd = channelData[ offset ];\r\n\r\n\t\t\t\tfor ( let i = 0; i < channelRules.length; ++ i ) {\r\n\r\n\t\t\t\t\tconst rule = channelRules[ i ];\r\n\r\n\t\t\t\t\tif ( cd.name == rule.name ) {\r\n\r\n\t\t\t\t\t\tcd.compression = rule.compression;\r\n\r\n\t\t\t\t\t\tif ( rule.index >= 0 ) {\r\n\r\n\t\t\t\t\t\t\tcscSet.idx[ rule.index ] = offset;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcd.offset = offset;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet acBuffer, dcBuffer, rleBuffer;\r\n\r\n\t\t\t// Read DCT - AC component data\r\n\t\t\tif ( dwaHeader.acCompressedSize > 0 ) {\r\n\r\n\t\t\t\tswitch ( dwaHeader.acCompression ) {\r\n\r\n\t\t\t\t\tcase STATIC_HUFFMAN:\r\n\r\n\t\t\t\t\t\tacBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );\r\n\t\t\t\t\t\thufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase DEFLATE:\r\n\r\n\t\t\t\t\t\tconst compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );\r\n\t\t\t\t\t\tconst data = fflate.unzlibSync( compressed );\r\n\t\t\t\t\t\tacBuffer = new Uint16Array( data.buffer );\r\n\t\t\t\t\t\tinOffset.value += dwaHeader.totalAcUncompressedCount;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Read DCT - DC component data\r\n\t\t\tif ( dwaHeader.dcCompressedSize > 0 ) {\r\n\r\n\t\t\t\tconst zlibInfo = {\r\n\t\t\t\t\tarray: info.array,\r\n\t\t\t\t\toffset: inOffset,\r\n\t\t\t\t\tsize: dwaHeader.dcCompressedSize\r\n\t\t\t\t};\r\n\t\t\t\tdcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );\r\n\t\t\t\tinOffset.value += dwaHeader.dcCompressedSize;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Read RLE compressed data\r\n\t\t\tif ( dwaHeader.rleRawSize > 0 ) {\r\n\r\n\t\t\t\tconst compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );\r\n\t\t\t\tconst data = fflate.unzlibSync( compressed );\r\n\t\t\t\trleBuffer = decodeRunLength( data.buffer );\r\n\r\n\t\t\t\tinOffset.value += dwaHeader.rleCompressedSize;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Prepare outbuffer data offset\r\n\t\t\tlet outBufferEnd = 0;\r\n\t\t\tconst rowOffsets = new Array( channelData.length );\r\n\t\t\tfor ( let i = 0; i < rowOffsets.length; ++ i ) {\r\n\r\n\t\t\t\trowOffsets[ i ] = new Array();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let y = 0; y < info.lines; ++ y ) {\r\n\r\n\t\t\t\tfor ( let chan = 0; chan < channelData.length; ++ chan ) {\r\n\r\n\t\t\t\t\trowOffsets[ chan ].push( outBufferEnd );\r\n\t\t\t\t\toutBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Lossy DCT decode RGB channels\r\n\t\t\tlossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );\r\n\r\n\t\t\t// Decode other channels\r\n\t\t\tfor ( let i = 0; i < channelData.length; ++ i ) {\r\n\r\n\t\t\t\tconst cd = channelData[ i ];\r\n\r\n\t\t\t\tif ( cd.decoded ) continue;\r\n\r\n\t\t\t\tswitch ( cd.compression ) {\r\n\r\n\t\t\t\t\tcase RLE:\r\n\r\n\t\t\t\t\t\tlet row = 0;\r\n\t\t\t\t\t\tlet rleOffset = 0;\r\n\r\n\t\t\t\t\t\tfor ( let y = 0; y < info.lines; ++ y ) {\r\n\r\n\t\t\t\t\t\t\tlet rowOffsetBytes = rowOffsets[ i ][ row ];\r\n\r\n\t\t\t\t\t\t\tfor ( let x = 0; x < cd.width; ++ x ) {\r\n\r\n\t\t\t\t\t\t\t\tfor ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {\r\n\r\n\t\t\t\t\t\t\t\t\toutBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\trleOffset ++;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\trow ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase LOSSY_DCT: // skip\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error( 'EXRLoader.parse: unsupported channel compression' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new DataView( outBuffer.buffer );\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseNullTerminatedString( buffer, offset ) {\r\n\r\n\t\t\tconst uintBuffer = new Uint8Array( buffer );\r\n\t\t\tlet endOffset = 0;\r\n\r\n\t\t\twhile ( uintBuffer[ offset.value + endOffset ] != 0 ) {\r\n\r\n\t\t\t\tendOffset += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst stringValue = new TextDecoder().decode(\r\n\t\t\t\tuintBuffer.slice( offset.value, offset.value + endOffset )\r\n\t\t\t);\r\n\r\n\t\t\toffset.value = offset.value + endOffset + 1;\r\n\r\n\t\t\treturn stringValue;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseFixedLengthString( buffer, offset, size ) {\r\n\r\n\t\t\tconst stringValue = new TextDecoder().decode(\r\n\t\t\t\tnew Uint8Array( buffer ).slice( offset.value, offset.value + size )\r\n\t\t\t);\r\n\r\n\t\t\toffset.value = offset.value + size;\r\n\r\n\t\t\treturn stringValue;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseRational( dataView, offset ) {\r\n\r\n\t\t\tconst x = parseInt32( dataView, offset );\r\n\t\t\tconst y = parseUint32( dataView, offset );\r\n\r\n\t\t\treturn [ x, y ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseTimecode( dataView, offset ) {\r\n\r\n\t\t\tconst x = parseUint32( dataView, offset );\r\n\t\t\tconst y = parseUint32( dataView, offset );\r\n\r\n\t\t\treturn [ x, y ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseInt32( dataView, offset ) {\r\n\r\n\t\t\tconst Int32 = dataView.getInt32( offset.value, true );\r\n\r\n\t\t\toffset.value = offset.value + INT32_SIZE;\r\n\r\n\t\t\treturn Int32;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseUint32( dataView, offset ) {\r\n\r\n\t\t\tconst Uint32 = dataView.getUint32( offset.value, true );\r\n\r\n\t\t\toffset.value = offset.value + INT32_SIZE;\r\n\r\n\t\t\treturn Uint32;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseUint8Array( uInt8Array, offset ) {\r\n\r\n\t\t\tconst Uint8 = uInt8Array[ offset.value ];\r\n\r\n\t\t\toffset.value = offset.value + INT8_SIZE;\r\n\r\n\t\t\treturn Uint8;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseUint8( dataView, offset ) {\r\n\r\n\t\t\tconst Uint8 = dataView.getUint8( offset.value );\r\n\r\n\t\t\toffset.value = offset.value + INT8_SIZE;\r\n\r\n\t\t\treturn Uint8;\r\n\r\n\t\t}\r\n\r\n\t\tconst parseInt64 = function ( dataView, offset ) {\r\n\r\n\t\t\tlet int;\r\n\r\n\t\t\tif ( 'getBigInt64' in DataView.prototype ) {\r\n\r\n\t\t\t\tint = Number( dataView.getBigInt64( offset.value, true ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tint = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset.value += ULONG_SIZE;\r\n\r\n\t\t\treturn int;\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseFloat32( dataView, offset ) {\r\n\r\n\t\t\tconst float = dataView.getFloat32( offset.value, true );\r\n\r\n\t\t\toffset.value += FLOAT32_SIZE;\r\n\r\n\t\t\treturn float;\r\n\r\n\t\t}\r\n\r\n\t\tfunction decodeFloat32( dataView, offset ) {\r\n\r\n\t\t\treturn DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );\r\n\r\n\t\t}\r\n\r\n\t\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\r\n\t\tfunction decodeFloat16( binary ) {\r\n\r\n\t\t\tconst exponent = ( binary & 0x7C00 ) >> 10,\r\n\t\t\t\tfraction = binary & 0x03FF;\r\n\r\n\t\t\treturn ( binary >> 15 ? - 1 : 1 ) * (\r\n\t\t\t\texponent ?\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\texponent === 0x1F ?\r\n\t\t\t\t\t\t\tfraction ? NaN : Infinity :\r\n\t\t\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\r\n\t\t\t\t\t) :\r\n\t\t\t\t\t6.103515625e-5 * ( fraction / 0x400 )\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseUint16( dataView, offset ) {\r\n\r\n\t\t\tconst Uint16 = dataView.getUint16( offset.value, true );\r\n\r\n\t\t\toffset.value += INT16_SIZE;\r\n\r\n\t\t\treturn Uint16;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseFloat16( buffer, offset ) {\r\n\r\n\t\t\treturn decodeFloat16( parseUint16( buffer, offset ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseChlist( dataView, buffer, offset, size ) {\r\n\r\n\t\t\tconst startOffset = offset.value;\r\n\t\t\tconst channels = [];\r\n\r\n\t\t\twhile ( offset.value < ( startOffset + size - 1 ) ) {\r\n\r\n\t\t\t\tconst name = parseNullTerminatedString( buffer, offset );\r\n\t\t\t\tconst pixelType = parseInt32( dataView, offset );\r\n\t\t\t\tconst pLinear = parseUint8( dataView, offset );\r\n\t\t\t\toffset.value += 3; // reserved, three chars\r\n\t\t\t\tconst xSampling = parseInt32( dataView, offset );\r\n\t\t\t\tconst ySampling = parseInt32( dataView, offset );\r\n\r\n\t\t\t\tchannels.push( {\r\n\t\t\t\t\tname: name,\r\n\t\t\t\t\tpixelType: pixelType,\r\n\t\t\t\t\tpLinear: pLinear,\r\n\t\t\t\t\txSampling: xSampling,\r\n\t\t\t\t\tySampling: ySampling\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset.value += 1;\r\n\r\n\t\t\treturn channels;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseChromaticities( dataView, offset ) {\r\n\r\n\t\t\tconst redX = parseFloat32( dataView, offset );\r\n\t\t\tconst redY = parseFloat32( dataView, offset );\r\n\t\t\tconst greenX = parseFloat32( dataView, offset );\r\n\t\t\tconst greenY = parseFloat32( dataView, offset );\r\n\t\t\tconst blueX = parseFloat32( dataView, offset );\r\n\t\t\tconst blueY = parseFloat32( dataView, offset );\r\n\t\t\tconst whiteX = parseFloat32( dataView, offset );\r\n\t\t\tconst whiteY = parseFloat32( dataView, offset );\r\n\r\n\t\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCompression( dataView, offset ) {\r\n\r\n\t\t\tconst compressionCodes = [\r\n\t\t\t\t'NO_COMPRESSION',\r\n\t\t\t\t'RLE_COMPRESSION',\r\n\t\t\t\t'ZIPS_COMPRESSION',\r\n\t\t\t\t'ZIP_COMPRESSION',\r\n\t\t\t\t'PIZ_COMPRESSION',\r\n\t\t\t\t'PXR24_COMPRESSION',\r\n\t\t\t\t'B44_COMPRESSION',\r\n\t\t\t\t'B44A_COMPRESSION',\r\n\t\t\t\t'DWAA_COMPRESSION',\r\n\t\t\t\t'DWAB_COMPRESSION'\r\n\t\t\t];\r\n\r\n\t\t\tconst compression = parseUint8( dataView, offset );\r\n\r\n\t\t\treturn compressionCodes[ compression ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBox2i( dataView, offset ) {\r\n\r\n\t\t\tconst xMin = parseInt32( dataView, offset );\r\n\t\t\tconst yMin = parseInt32( dataView, offset );\r\n\t\t\tconst xMax = parseInt32( dataView, offset );\r\n\t\t\tconst yMax = parseInt32( dataView, offset );\r\n\r\n\t\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseLineOrder( dataView, offset ) {\r\n\r\n\t\t\tconst lineOrders = [\r\n\t\t\t\t'INCREASING_Y',\r\n\t\t\t\t'DECREASING_Y',\r\n\t\t\t\t'RANDOM_Y',\r\n\t\t\t];\r\n\r\n\t\t\tconst lineOrder = parseUint8( dataView, offset );\r\n\r\n\t\t\treturn lineOrders[ lineOrder ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEnvmap( dataView, offset ) {\r\n\r\n\t\t\tconst envmaps = [\r\n\t\t\t\t'ENVMAP_LATLONG',\r\n\t\t\t\t'ENVMAP_CUBE'\r\n\t\t\t];\r\n\r\n\t\t\tconst envmap = parseUint8( dataView, offset );\r\n\r\n\t\t\treturn envmaps[ envmap ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseTiledesc( dataView, offset ) {\r\n\r\n\t\t\tconst levelModes = [\r\n\t\t\t\t'ONE_LEVEL',\r\n\t\t\t\t'MIPMAP_LEVELS',\r\n\t\t\t\t'RIPMAP_LEVELS',\r\n\t\t\t];\r\n\r\n\t\t\tconst roundingModes = [\r\n\t\t\t\t'ROUND_DOWN',\r\n\t\t\t\t'ROUND_UP',\r\n\t\t\t];\r\n\r\n\t\t\tconst xSize = parseUint32( dataView, offset );\r\n\t\t\tconst ySize = parseUint32( dataView, offset );\r\n\t\t\tconst modes = parseUint8( dataView, offset );\r\n\r\n\t\t\treturn {\r\n\t\t\t\txSize: xSize,\r\n\t\t\t\tySize: ySize,\r\n\t\t\t\tlevelMode: levelModes[ modes & 0xf ],\r\n\t\t\t\troundingMode: roundingModes[ modes >> 4 ]\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseV2f( dataView, offset ) {\r\n\r\n\t\t\tconst x = parseFloat32( dataView, offset );\r\n\t\t\tconst y = parseFloat32( dataView, offset );\r\n\r\n\t\t\treturn [ x, y ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseV3f( dataView, offset ) {\r\n\r\n\t\t\tconst x = parseFloat32( dataView, offset );\r\n\t\t\tconst y = parseFloat32( dataView, offset );\r\n\t\t\tconst z = parseFloat32( dataView, offset );\r\n\r\n\t\t\treturn [ x, y, z ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseValue( dataView, buffer, offset, type, size ) {\r\n\r\n\t\t\tif ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {\r\n\r\n\t\t\t\treturn parseFixedLengthString( buffer, offset, size );\r\n\r\n\t\t\t} else if ( type === 'chlist' ) {\r\n\r\n\t\t\t\treturn parseChlist( dataView, buffer, offset, size );\r\n\r\n\t\t\t} else if ( type === 'chromaticities' ) {\r\n\r\n\t\t\t\treturn parseChromaticities( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'compression' ) {\r\n\r\n\t\t\t\treturn parseCompression( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'box2i' ) {\r\n\r\n\t\t\t\treturn parseBox2i( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'envmap' ) {\r\n\r\n\t\t\t\treturn parseEnvmap( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'tiledesc' ) {\r\n\r\n\t\t\t\treturn parseTiledesc( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'lineOrder' ) {\r\n\r\n\t\t\t\treturn parseLineOrder( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'float' ) {\r\n\r\n\t\t\t\treturn parseFloat32( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'v2f' ) {\r\n\r\n\t\t\t\treturn parseV2f( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'v3f' ) {\r\n\r\n\t\t\t\treturn parseV3f( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'int' ) {\r\n\r\n\t\t\t\treturn parseInt32( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'rational' ) {\r\n\r\n\t\t\t\treturn parseRational( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'timecode' ) {\r\n\r\n\t\t\t\treturn parseTimecode( dataView, offset );\r\n\r\n\t\t\t} else if ( type === 'preview' ) {\r\n\r\n\t\t\t\toffset.value += size;\r\n\t\t\t\treturn 'skipped';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\toffset.value += size;\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction roundLog2( x, mode ) {\r\n\r\n\t\t\tconst log2 = Math.log2( x );\r\n\t\t\treturn mode == 'ROUND_DOWN' ? Math.floor( log2 ) : Math.ceil( log2 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction calculateTileLevels( tiledesc, w, h ) {\r\n\r\n\t\t\tlet num = 0;\r\n\r\n\t\t\tswitch ( tiledesc.levelMode ) {\r\n\r\n\t\t\t\tcase 'ONE_LEVEL':\r\n\t\t\t\t\tnum = 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'MIPMAP_LEVELS':\r\n\t\t\t\t\tnum = roundLog2( Math.max( w, h ), tiledesc.roundingMode ) + 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'RIPMAP_LEVELS':\r\n\t\t\t\t\tthrow new Error( 'THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn num;\r\n\r\n\t\t}\r\n\r\n\t\tfunction calculateTiles( count, dataSize, size, roundingMode ) {\r\n\r\n\t\t\tconst tiles = new Array( count );\r\n\r\n\t\t\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\tconst b = ( 1 << i );\r\n\t\t\t\tlet s = ( dataSize / b ) | 0;\r\n\r\n\t\t\t\tif ( roundingMode == 'ROUND_UP' && s * b < dataSize ) s += 1;\r\n\r\n\t\t\t\tconst l = Math.max( s, 1 );\r\n\r\n\t\t\t\ttiles[ i ] = ( ( l + size - 1 ) / size ) | 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn tiles;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseTiles() {\r\n\r\n\t\t\tconst EXRDecoder = this;\r\n\t\t\tconst offset = EXRDecoder.offset;\r\n\t\t\tconst tmpOffset = { value: 0 };\r\n\r\n\t\t\tfor ( let tile = 0; tile < EXRDecoder.tileCount; tile ++ ) {\r\n\r\n\t\t\t\tconst tileX = parseInt32( EXRDecoder.viewer, offset );\r\n\t\t\t\tconst tileY = parseInt32( EXRDecoder.viewer, offset );\r\n\t\t\t\toffset.value += 8; // skip levels - only parsing top-level\r\n\t\t\t\tEXRDecoder.size = parseUint32( EXRDecoder.viewer, offset );\r\n\r\n\t\t\t\tconst startX = tileX * EXRDecoder.blockWidth;\r\n\t\t\t\tconst startY = tileY * EXRDecoder.blockHeight;\r\n\t\t\t\tEXRDecoder.columns = ( startX + EXRDecoder.blockWidth > EXRDecoder.width ) ? EXRDecoder.width - startX : EXRDecoder.blockWidth;\r\n\t\t\t\tEXRDecoder.lines = ( startY + EXRDecoder.blockHeight > EXRDecoder.height ) ? EXRDecoder.height - startY : EXRDecoder.blockHeight;\r\n\r\n\t\t\t\tconst bytesBlockLine = EXRDecoder.columns * EXRDecoder.totalBytes;\r\n\t\t\t\tconst isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesBlockLine;\r\n\t\t\t\tconst viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );\r\n\r\n\t\t\t\toffset.value += EXRDecoder.size;\r\n\r\n\t\t\t\tfor ( let line = 0; line < EXRDecoder.lines; line ++ ) {\r\n\r\n\t\t\t\t\tconst lineOffset = line * EXRDecoder.columns * EXRDecoder.totalBytes;\r\n\r\n\t\t\t\t\tfor ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {\r\n\r\n\t\t\t\t\t\tconst name = EXRHeader.channels[ channelID ].name;\r\n\t\t\t\t\t\tconst lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;\r\n\t\t\t\t\t\tconst cOff = EXRDecoder.decodeChannels[ name ];\r\n\r\n\t\t\t\t\t\tif ( cOff === undefined ) continue;\r\n\r\n\t\t\t\t\t\ttmpOffset.value = lineOffset + lOff;\r\n\t\t\t\t\t\tconst outLineOffset = ( EXRDecoder.height - ( 1 + startY + line ) ) * EXRDecoder.outLineWidth;\r\n\r\n\t\t\t\t\t\tfor ( let x = 0; x < EXRDecoder.columns; x ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst outIndex = outLineOffset + ( x + startX ) * EXRDecoder.outputChannels + cOff;\r\n\t\t\t\t\t\t\tEXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseScanline() {\r\n\r\n\t\t\tconst EXRDecoder = this;\r\n\t\t\tconst offset = EXRDecoder.offset;\r\n\t\t\tconst tmpOffset = { value: 0 };\r\n\r\n\t\t\tfor ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.blockHeight; scanlineBlockIdx ++ ) {\r\n\r\n\t\t\t\tconst line = parseInt32( EXRDecoder.viewer, offset ) - EXRHeader.dataWindow.yMin; // line_no\r\n\t\t\t\tEXRDecoder.size = parseUint32( EXRDecoder.viewer, offset ); // data_len\r\n\t\t\t\tEXRDecoder.lines = ( ( line + EXRDecoder.blockHeight > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.blockHeight );\r\n\r\n\t\t\t\tconst bytesPerLine = EXRDecoder.columns * EXRDecoder.totalBytes;\r\n\t\t\t\tconst isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesPerLine;\r\n\t\t\t\tconst viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );\r\n\r\n\t\t\t\toffset.value += EXRDecoder.size;\r\n\r\n\t\t\t\tfor ( let line_y = 0; line_y < EXRDecoder.blockHeight; line_y ++ ) {\r\n\r\n\t\t\t\t\tconst scan_y = scanlineBlockIdx * EXRDecoder.blockHeight;\r\n\t\t\t\t\tconst true_y = line_y + EXRDecoder.scanOrder( scan_y );\r\n\t\t\t\t\tif ( true_y >= EXRDecoder.height ) continue;\r\n\r\n\t\t\t\t\tconst lineOffset = line_y * bytesPerLine;\r\n\t\t\t\t\tconst outLineOffset = ( EXRDecoder.height - 1 - true_y ) * EXRDecoder.outLineWidth;\r\n\r\n\t\t\t\t\tfor ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {\r\n\r\n\t\t\t\t\t\tconst name = EXRHeader.channels[ channelID ].name;\r\n\t\t\t\t\t\tconst lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;\r\n\t\t\t\t\t\tconst cOff = EXRDecoder.decodeChannels[ name ];\r\n\r\n\t\t\t\t\t\tif ( cOff === undefined ) continue;\r\n\r\n\t\t\t\t\t\ttmpOffset.value = lineOffset + lOff;\r\n\r\n\t\t\t\t\t\tfor ( let x = 0; x < EXRDecoder.columns; x ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst outIndex = outLineOffset + x * EXRDecoder.outputChannels + cOff;\r\n\t\t\t\t\t\t\tEXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseHeader( dataView, buffer, offset ) {\r\n\r\n\t\t\tconst EXRHeader = {};\r\n\r\n\t\t\tif ( dataView.getUint32( 0, true ) != 20000630 ) { // magic\r\n\r\n\t\t\t\tthrow new Error( 'THREE.EXRLoader: Provided file doesn\\'t appear to be in OpenEXR format.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tEXRHeader.version = dataView.getUint8( 4 );\r\n\r\n\t\t\tconst spec = dataView.getUint8( 5 ); // fullMask\r\n\r\n\t\t\tEXRHeader.spec = {\r\n\t\t\t\tsingleTile: !! ( spec & 2 ),\r\n\t\t\t\tlongName: !! ( spec & 4 ),\r\n\t\t\t\tdeepFormat: !! ( spec & 8 ),\r\n\t\t\t\tmultiPart: !! ( spec & 16 ),\r\n\t\t\t};\r\n\r\n\t\t\t// start of header\r\n\r\n\t\t\toffset.value = 8; // start at 8 - after pre-amble\r\n\r\n\t\t\tlet keepReading = true;\r\n\r\n\t\t\twhile ( keepReading ) {\r\n\r\n\t\t\t\tconst attributeName = parseNullTerminatedString( buffer, offset );\r\n\r\n\t\t\t\tif ( attributeName == 0 ) {\r\n\r\n\t\t\t\t\tkeepReading = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconst attributeType = parseNullTerminatedString( buffer, offset );\r\n\t\t\t\t\tconst attributeSize = parseUint32( dataView, offset );\r\n\t\t\t\t\tconst attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );\r\n\r\n\t\t\t\t\tif ( attributeValue === undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( `THREE.EXRLoader: Skipped unknown header attribute type \\'${attributeType}\\'.` );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tEXRHeader[ attributeName ] = attributeValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( spec & ~ 0x06 ) != 0 ) { // unsupported deep-image, multi-part\r\n\r\n\t\t\t\tconsole.error( 'THREE.EXRHeader:', EXRHeader );\r\n\t\t\t\tthrow new Error( 'THREE.EXRLoader: Provided file is currently unsupported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn EXRHeader;\r\n\r\n\t\t}\r\n\r\n\t\tfunction setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {\r\n\r\n\t\t\tconst EXRDecoder = {\r\n\t\t\t\tsize: 0,\r\n\t\t\t\tviewer: dataView,\r\n\t\t\t\tarray: uInt8Array,\r\n\t\t\t\toffset: offset,\r\n\t\t\t\twidth: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\r\n\t\t\t\theight: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\r\n\t\t\t\tinputChannels: EXRHeader.channels,\r\n\t\t\t\tchannelByteOffsets: {},\r\n\t\t\t\tscanOrder: null,\r\n\t\t\t\ttotalBytes: null,\r\n\t\t\t\tcolumns: null,\r\n\t\t\t\tlines: null,\r\n\t\t\t\ttype: null,\r\n\t\t\t\tuncompress: null,\r\n\t\t\t\tgetter: null,\r\n\t\t\t\tformat: null,\r\n\t\t\t\tcolorSpace: LinearSRGBColorSpace,\r\n\t\t\t};\r\n\r\n\t\t\tswitch ( EXRHeader.compression ) {\r\n\r\n\t\t\t\tcase 'NO_COMPRESSION':\r\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\r\n\t\t\t\t\tEXRDecoder.uncompress = uncompressRAW;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'RLE_COMPRESSION':\r\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\r\n\t\t\t\t\tEXRDecoder.uncompress = uncompressRLE;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ZIPS_COMPRESSION':\r\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\r\n\t\t\t\t\tEXRDecoder.uncompress = uncompressZIP;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ZIP_COMPRESSION':\r\n\t\t\t\t\tEXRDecoder.blockHeight = 16;\r\n\t\t\t\t\tEXRDecoder.uncompress = uncompressZIP;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PIZ_COMPRESSION':\r\n\t\t\t\t\tEXRDecoder.blockHeight = 32;\r\n\t\t\t\t\tEXRDecoder.uncompress = uncompressPIZ;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PXR24_COMPRESSION':\r\n\t\t\t\t\tEXRDecoder.blockHeight = 16;\r\n\t\t\t\t\tEXRDecoder.uncompress = uncompressPXR;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'DWAA_COMPRESSION':\r\n\t\t\t\t\tEXRDecoder.blockHeight = 32;\r\n\t\t\t\t\tEXRDecoder.uncompress = uncompressDWA;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'DWAB_COMPRESSION':\r\n\t\t\t\t\tEXRDecoder.blockHeight = 256;\r\n\t\t\t\t\tEXRDecoder.uncompress = uncompressDWA;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst channels = {};\r\n\t\t\tfor ( const channel of EXRHeader.channels ) {\r\n\r\n\t\t\t\tswitch ( channel.name ) {\r\n\r\n\t\t\t\t\tcase 'Y':\r\n\t\t\t\t\tcase 'R':\r\n\t\t\t\t\tcase 'G':\r\n\t\t\t\t\tcase 'B':\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\t\tchannels[ channel.name ] = true;\r\n\t\t\t\t\t\tEXRDecoder.type = channel.pixelType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// RGB images will be converted to RGBA format, preventing software emulation in select devices.\r\n\t\t\tlet fillAlpha = false;\r\n\r\n\t\t\tif ( channels.R && channels.G && channels.B ) {\r\n\r\n\t\t\t\tfillAlpha = ! channels.A;\r\n\t\t\t\tEXRDecoder.outputChannels = 4;\r\n\t\t\t\tEXRDecoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };\r\n\r\n\t\t\t} else if ( channels.Y ) {\r\n\r\n\t\t\t\tEXRDecoder.outputChannels = 1;\r\n\t\t\t\tEXRDecoder.decodeChannels = { Y: 0 };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'EXRLoader.parse: file contains unsupported data channels.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( EXRDecoder.type == 1 ) {\r\n\r\n\t\t\t\t// half\r\n\t\t\t\tswitch ( outputType ) {\r\n\r\n\t\t\t\t\tcase FloatType:\r\n\t\t\t\t\t\tEXRDecoder.getter = parseFloat16;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase HalfFloatType:\r\n\t\t\t\t\t\tEXRDecoder.getter = parseUint16;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( EXRDecoder.type == 2 ) {\r\n\r\n\t\t\t\t// float\r\n\t\t\t\tswitch ( outputType ) {\r\n\r\n\t\t\t\t\tcase FloatType:\r\n\t\t\t\t\t\tEXRDecoder.getter = parseFloat32;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase HalfFloatType:\r\n\t\t\t\t\t\tEXRDecoder.getter = decodeFloat32;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tEXRDecoder.columns = EXRDecoder.width;\r\n\t\t\tconst size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\r\n\r\n\t\t\tswitch ( outputType ) {\r\n\r\n\t\t\t\tcase FloatType:\r\n\t\t\t\t\tEXRDecoder.byteArray = new Float32Array( size );\r\n\r\n\t\t\t\t\t// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\r\n\t\t\t\t\tif ( fillAlpha )\r\n\t\t\t\t\t\tEXRDecoder.byteArray.fill( 1, 0, size );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase HalfFloatType:\r\n\t\t\t\t\tEXRDecoder.byteArray = new Uint16Array( size );\r\n\r\n\t\t\t\t\tif ( fillAlpha )\r\n\t\t\t\t\t\tEXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tconsole.error( 'THREE.EXRLoader: unsupported type: ', outputType );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet byteOffset = 0;\r\n\t\t\tfor ( const channel of EXRHeader.channels ) {\r\n\r\n\t\t\t\tif ( EXRDecoder.decodeChannels[ channel.name ] !== undefined ) {\r\n\r\n\t\t\t\t\tEXRDecoder.channelByteOffsets[ channel.name ] = byteOffset;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbyteOffset += channel.pixelType * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tEXRDecoder.totalBytes = byteOffset;\r\n\t\t\tEXRDecoder.outLineWidth = EXRDecoder.width * EXRDecoder.outputChannels;\r\n\r\n\t\t\tif ( EXRHeader.lineOrder === 'INCREASING_Y' ) {\r\n\r\n\t\t\t\tEXRDecoder.scanOrder = ( y ) => y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tEXRDecoder.scanOrder = ( y ) => EXRDecoder.height - 1 - y;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( EXRDecoder.outputChannels == 4 ) {\r\n\r\n\t\t\t\tEXRDecoder.format = RGBAFormat;\r\n\t\t\t\tEXRDecoder.colorSpace = LinearSRGBColorSpace;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tEXRDecoder.format = RedFormat;\r\n\t\t\t\tEXRDecoder.colorSpace = NoColorSpace;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( EXRHeader.spec.singleTile ) {\r\n\r\n\t\t\t\tEXRDecoder.blockHeight = EXRHeader.tiles.ySize;\r\n\t\t\t\tEXRDecoder.blockWidth = EXRHeader.tiles.xSize;\r\n\r\n\t\t\t\tconst numXLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );\r\n\t\t\t\t// const numYLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );\r\n\r\n\t\t\t\tconst numXTiles = calculateTiles( numXLevels, EXRDecoder.width, EXRHeader.tiles.xSize, EXRHeader.tiles.roundingMode );\r\n\t\t\t\tconst numYTiles = calculateTiles( numXLevels, EXRDecoder.height, EXRHeader.tiles.ySize, EXRHeader.tiles.roundingMode );\r\n\r\n\t\t\t\tEXRDecoder.tileCount = numXTiles[ 0 ] * numYTiles[ 0 ];\r\n\r\n\t\t\t\tfor ( let l = 0; l < numXLevels; l ++ )\r\n\t\t\t\t\tfor ( let y = 0; y < numYTiles[ l ]; y ++ )\r\n\t\t\t\t\t\tfor ( let x = 0; x < numXTiles[ l ]; x ++ )\r\n\t\t\t\t\t\t\tparseInt64( dataView, offset ); // tileOffset\r\n\r\n\t\t\t\tEXRDecoder.decode = parseTiles.bind( EXRDecoder );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tEXRDecoder.blockWidth = EXRDecoder.width;\r\n\t\t\t\tconst blockCount = Math.ceil( EXRDecoder.height / EXRDecoder.blockHeight );\r\n\r\n\t\t\t\tfor ( let i = 0; i < blockCount; i ++ )\r\n\t\t\t\t\tparseInt64( dataView, offset ); // scanlineOffset\r\n\r\n\t\t\t\tEXRDecoder.decode = parseScanline.bind( EXRDecoder );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn EXRDecoder;\r\n\r\n\t\t}\r\n\r\n\t\t// start parsing file [START]\r\n\t\tconst offset = { value: 0 };\r\n\t\tconst bufferDataView = new DataView( buffer );\r\n\t\tconst uInt8Array = new Uint8Array( buffer );\r\n\r\n\t\t// get header information and validate format.\r\n\t\tconst EXRHeader = parseHeader( bufferDataView, buffer, offset );\r\n\r\n\t\t// get input compression information and prepare decoding.\r\n\t\tconst EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );\r\n\r\n\t\t// parse input data\r\n\t\tEXRDecoder.decode();\r\n\r\n\t\treturn {\r\n\t\t\theader: EXRHeader,\r\n\t\t\twidth: EXRDecoder.width,\r\n\t\t\theight: EXRDecoder.height,\r\n\t\t\tdata: EXRDecoder.byteArray,\r\n\t\t\tformat: EXRDecoder.format,\r\n\t\t\tcolorSpace: EXRDecoder.colorSpace,\r\n\t\t\ttype: this.type,\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tsetDataType( value ) {\r\n\r\n\t\tthis.type = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tfunction onLoadCallback( texture, texData ) {\r\n\r\n\t\t\ttexture.colorSpace = texData.colorSpace;\r\n\t\t\ttexture.minFilter = LinearFilter;\r\n\t\t\ttexture.magFilter = LinearFilter;\r\n\t\t\ttexture.generateMipmaps = false;\r\n\t\t\ttexture.flipY = false;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\r\n\t\t}\r\n\r\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { EXRLoader };\r\n"],
  "mappings": "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AAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,CAAE,CAAE;AACpC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AAErC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AAErC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AACrC,UAAK,EAAG,IAAI,cAAe,IAAK,EAAG,CAAE;AA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",
  "names": ["uInt8Array", "buffer", "offset", "EXRDecoder", "EXRHeader"]
}
